<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX8E824A7343324BDE9953A093DEE982DC">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">_ScriptExport</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX0035231AA6164802BBF91367B2959064">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Workspace</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX77A3C9D4BCFB49DFB68565C137A082C2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[SEB
	- ChangeLog update

ADNAN	
	- 
		
ORIANE
	-
		
		
	La valeur GameMode de Server_Context est utilisée à bcp d'endroits notamment sur Fight Assignement etc. 
pour l'instant comme je ne sis pas si on genere très bien sa valeur tout le temps, notamment en Standard donc 
j'ai parfois utilisé Utils.GetServerGameMode() == Global_Params_Mod.Server_Mode.TOURNAMENT or Utils.GetServerGameMode() == "" 
pour dire que si la valeur est vide >> ca se comporte comme en standard, c'est pas bien mais c'était pour éviter d'avoir des
regressions partout si on n'a pas de valeur dans ce champ


Les compteurs "Total Wins" et "Total Matches" dans Player Data ont vraiment un souci, je ne sais pas si c'est exclusible
qui avait mal nommé cette entrée ou nous qui l'avons mal utilisée par la suite mais il y a un mic mac, c'est nommé comme un 
total (casual + ranked) mais utilisé comme si c'était que les casual. D'ou les valeurs absurdes


Et pour le match making aussi ca peutetre bien de voir des trucs, genre une pulsation à toutes les vagues ou qqch
un message Display pour quant t'es pas apairé]]></ProtectedString>
					<string name="ScriptGuid">{0C1D9345-3999-4F02-AAF8-71901F0B1EB9}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">TO_CHECK_BEFORE_RELEASE.server.lua</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXC6BE4045BEC443DDA1A109E1C6C145AB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main_World_F</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX26E49969122041F3B844485921BE0300">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Gameplay</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX4FAEE8B7EAB04D2EA49FEE83F48608A2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Shop</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX06BB27F958EA44D9AAD59534EBEB4B56">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Offers_Data</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX7469BCDCAAC54A10A8707183861EC45E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Display_Podium_Left</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX86ED81ABE0EF49759FF032ACC35F922C">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[local Color_Mod = require( game.ReplicatedStorage.Data_Mods_F:WaitForChild("PodiumColors_Mod"))
Color_Mod.new(script.Parent, "S1", {

	{
		Name = {"Region/Base","Region/RingAlpha","RegionLite/Base","RegionLite/RingAlpha"},
		Use  = "NeonEffectColor",
	},
	{
		Name = "TextLabel",
		Use  = "RibbonGradient", -- multi-stop, UIGradient with Rotation=40
	}
},
{
	CanSetText=true,
	TextObjName="TextLabel",
	Text="EXCLUSIVE OFFER!"
})]]></ProtectedString>
										<string name="ScriptGuid">{92966223-F725-4F6D-95FC-059F7C081EC2}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Display_Podium_Left_ColorAdjustemt.server.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Folder" referent="RBXD48A44D1E6BC413192AD7B26BFFB50C1">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">OfferAttachment</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX8D662E8D1FB5435D88A66B0725B2406C">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/OffersService.lua
--
--  Description:
--      Handles cloth offers for players. Manages showing offers, saving
--      and loading offer states via DataStoreService, and syncing offer
--      data with clients using RemoteEvents and RemoteFunctions.
--
--      Key features:
--        - Trigger offers when player interacts with GateToEnterPrompt
--        - Store active and expired cloth offers per player
--        - Fire RemoteEvents to client to display offers
--        - Retrieve current cloth offer for a player
--        - Update player's offer attributes and state
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-3 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Remotes/Offers/UGC/ShowOfferSignalBind (RemoteEvent)
--          * Remotes/Offers/GetCurrentClothOffer (RemoteFunction)
--          * Remotes/Offers/ClothItemIdSignal (RemoteEvent)
--      - Roblox Services:
--          * DataStoreService (Player offer state persistence)
--      - Player Instances:
--          * Attributes: ClothItemData_Type, ClothItemData_Key
--          * ActiveOffer and expiredItems in DataStore
--
--  Notes:
--      - Uses DataStore "PlayerOfferState" to persist offer data
--      - Maintains a max of 30 expired items per player
--      - Dynamically updates player attributes when a new offer is claimed
--      - Offers are uniquely identified by Key + Kind
--      - Handles both server-triggered and client-triggered events
--
--======================================================================
-- Services
local RS 					 = game:GetService("ReplicatedStorage")
local DSS 					 = game:GetService("DataStoreService")
local OfferStore 			 = DSS:GetDataStore("PlayerOfferState")
local RunService 			 = game:GetService("RunService")
-- Modules
local OfferConfig 			 = require(game.ReplicatedStorage:WaitForChild("Data_Mods_F"):WaitForChild("Offers_Config"))

-- Events
local Channels 			   	 = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local ShowOfferSignalBind	 = Channels.Offers.ShowOfferSignalBind
local GetCurrentClothOffer	 = Channels.Offers.GetCurrentClothOffer
local ClothItemIdSignal 	 = Channels.Offers.ClothItemIdSignal

local parent = script.Parent
local GateToEnterPrompt=parent.Prompt
GateToEnterPrompt.ActionText	= OfferConfig.Podiums.LeftPodium.prompt

local isMoving=false

function UpDownGlove(target, opts)
	opts = opts or {}
	isMoving=true
	local amplitude       = tonumber(opts.amplitude) or 2      -- vertical travel (studs)
	local freq            = tonumber(opts.freq)      or 0.2    -- bob cycles per second
	local spinDegPerStep  = tonumber(opts.spinDegPerStep) or 0.5

	-- accept either a Model or a BasePart; if nil, fall back to self.ClonedObjBasePart / self.Model
	--target = target or self.Model or self.ClonedObjBasePart
	if not target then return end

	local isModel = target:IsA("Model")
	local getCF   = function()
		return isModel and target:GetPivot() or target.CFrame
	end
	local setCF   = function(cf)
		if isModel then
			target:PivotTo(cf)
		else
			target.CFrame = cf
		end
	end

	local originCF = getCF()
	local t0       = os.clock()
	local spin     = 0
	local spinStep = math.rad(spinDegPerStep)

	isMoving= true
	while isMoving and target do
		local t = os.clock() - t0
		local y = (math.sin(2 * math.pi * freq * t) + 1) * (amplitude / 2)  -- 0..amplitude

		spin += spinStep
		setCF(originCF * CFrame.new(0,y, .1) * CFrame.Angles(0, spin, 0))

		RunService.Heartbeat:Wait()
	end
end







GateToEnterPrompt.Triggered:Connect(function(player)

	local Itype = player:GetAttribute("ClothItemData_Type")
	local IKey = player:GetAttribute("ClothItemData_Key")
	ShowOfferSignalBind:Fire(player,Itype,IKey)

end)




local function loadOfferState(plr)
	local key = "ClothOffer_" .. plr.UserId

	local ok, err = pcall(function()
		return OfferStore:GetAsync(key)
	end)
	if ok and err then
		return err
	else
		--print("Failed to load offer state for", plr.UserId, err)
	end
	return nil
end

local function saveOfferState(plr, offerAC)
	local key = "ClothOffer_" .. plr.UserId
	local now=os.time() 
	local ok, err = pcall(function()
		OfferStore:UpdateAsync(key, function(old)
			old = old or {}
			old.expiredItems = old.expiredItems or {}
			local prev = old.ActiveOffer

			if prev then
				local expCount = #old.expiredItems
				if expCount == 30 then
					old.expiredItems={}
				else
					table.insert(old.expiredItems, {
						Key = prev.CurrentKey,
						EndedAt = now,
						EndReason ="expired",
					})
				end
			end

			old.ActiveOffer = {
				CurrentKey =offerAC.Key.."_"..offerAC.Kind,
				EndsAt = offerAC.EndsAt,
			}
			return old
		end)
	end)

	if not ok then
		warn("Failed to save offer state:", err)
	end
end

GetCurrentClothOffer.OnServerInvoke=function(player)
	local PP =	loadOfferState(player)
	task.wait()
	if PP then
		local data =string.split(PP.ActiveOffer.CurrentKey,"_")	
		OfferConfig.GetAndCreateClothOfferOnKey(player,data[1],data[2],PP.EndsAt or nil)
	end
	return nil
end

ClothItemIdSignal.OnServerEvent:Connect(function(plr, offer)
	local Itype = plr:SetAttribute("ClothItemData_Type",offer.Kind)
	local IKey = plr:SetAttribute("ClothItemData_Key",offer.Key)
	local profile = loadOfferState(plr)
	
	if profile ~= nil and profile.ActiveOffer ~= nil then

		local data =string.split(profile.ActiveOffer.CurrentKey,"_")	
		if offer.Kind == data[2] and offer.Key == data[1] then
			return
		end
	end
	saveOfferState(plr, offer)
end)]]></ProtectedString>
											<string name="ScriptGuid">{AF7FAAB3-57A0-4418-8E0F-BFEE9B9616CD}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Display_Podium_Left.server.lua</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXD64B0D960AAE4EE5B7CC22CA55E7D220">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UGCPodiums</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX20E6F49C869549368D0C363631ECB23E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">1-Display_Podium</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX9DAFFC37E8814D58A5F51BFCA0839B4B">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[local Color_Mod = require( game.ReplicatedStorage.Data_Mods_F:WaitForChild("PodiumColors_Mod"))

Color_Mod.new(script.Parent, "S2", {
	{
		Name = {"Region/Base","Region/RingAlpha","RegionLite/Base","RegionLite/RingAlpha"},
		Use  = "NeonEffectColor",
	},
	{
		Name ="TextLabel",
		Use  = "RibbonGradient",
	},
},
{
	CanSetText=true,
	TextObjName="TextLabel",
	Text="UGC EPIC CREATIONS"
})]]></ProtectedString>
											<string name="ScriptGuid">{B45E0C69-7C3C-4508-AB42-DB6DFBE97E2E}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">1-Display_Podium_ColorAdjustemt.server.lua</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX3218CF4EF2064C4B9522F3D475990B49">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Display_Podium_Right</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX6D44B4FDB3A2404FA377ABDE2781C488">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[local Color_Mod = require( game.ReplicatedStorage.Data_Mods_F:WaitForChild("PodiumColors_Mod"))
Color_Mod.new(script.Parent, "S3", {
	{
		Name = {"Region/Base","Region/RingAlpha","RegionLite/Base","RegionLite/RingAlpha"},
		Use  = "NeonEffectColor",
	},
	{
		Name ="TextLabel",
		Use  = "RibbonGradient",
	},
},
{
	CanSetText=true,
	TextObjName="TextLabel",
	Text="GET NEW EQUIPMENT"
})]]></ProtectedString>
										<string name="ScriptGuid">{6B5E2580-D40F-4F92-9603-30D8CEE8BC70}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Display_Podium_Right_ColorAdjustemt.server.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Folder" referent="RBXE38BB1AE790C4167902570D1CFA774AA">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">RegionLite</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX2778594FDADC40189A7EC1CC69580F11">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Base</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX865E3D45AE4C4541866778B12F678497">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local parent = script.Parent.Parent  -- parent of your MeshPart

-- Tween settings
local tweenInfo = TweenInfo.new(
	1,                      -- duration for each color change
	Enum.EasingStyle.Linear,  -- smooth change
	Enum.EasingDirection.InOut,
	0, false, 0
)

-- Function to make a random bright color
local function randomDiscoColor()
	return Color3.fromHSV(math.random(), 1, 1) -- random hue, full saturation, full brightness
end

while true do
	for _, obj in ipairs(parent:GetDescendants()) do
		if obj:IsA("MeshPart") then
			local goal = {Color = randomDiscoColor()}
			local tween = TweenService:Create(obj, tweenInfo, goal)
			tween:Play()
		end
	end
	task.wait(1) -- sync with tween duration
end
]]></ProtectedString>
												<string name="ScriptGuid">{0ED86BE8-E56A-4FD4-A815-0F2EC2838901}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">DiscoLights.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBXC68E1FF4BFFF4CC792869C85A2CE29A1">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">OfferAttachment</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX9EF5E220FE48422D9A899D8BDFAF2760">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/CoinGatePurchase.lua
--
--  Description:
--      Handles in-game purchases when a player interacts with the
--      GateToEnterPrompt. Uses MarketplaceService to prompt the
--      purchase of DevProducts (Coins or Gems) based on player's
--      current internal currency.
--
--      Key features:
--        - Checks player's Coins to determine which DevProduct to prompt
--        - Triggers MarketplaceService purchase prompt on player interaction
--        - Supports dynamic selection between Coins and Gems products
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-13 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * MarketplaceService (for DevProduct purchases)
--      - Player Instances:
--          * Player.Player_Data.Coins (used to check player's balance)
--
--  Notes:
--      - DevProduct IDs:
--          * Coins: 3306908329
--          * Gems: 3306910278
--      - Purchase logic uses a coin limit (cointLimit = 5000) to decide
--        which product to prompt
--      - Triggered when player interacts with GateToEnterPrompt
--======================================================================

-- Services
local RunService 				= game:GetService("RunService")
local RS 						= game:GetService("ReplicatedStorage")

-- Modules
local Data_Mods_F 				= RS:WaitForChild("Data_Mods_F")
local Offers_Config 			= require(Data_Mods_F:WaitForChild("Offers_Config"))
local Channels 					= require(game.ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Channels"))
local Open_Shop					= Channels.SC_Remote_Events.Open_Shop

local parent 					= script.Parent
local GateToEnterPrompt 		= parent.Prompt
GateToEnterPrompt.ActionText	= Offers_Config.Podiums.RightPodium.prompt

local isMoving					= false
local IsShort					= false

function UpDownGlove(target, opts)

	opts = opts or {}
	isMoving=true
	task.wait(1)
	local amplitude       = tonumber(opts.amplitude) or 2      -- vertical travel (studs)
	local freq            = tonumber(opts.freq)      or 0.2    -- bob cycles per second
	local spinDegPerStep  = tonumber(opts.spinDegPerStep) or 0.5

	-- accept either a Model or a BasePart; if nil, fall back to self.ClonedObjBasePart / self.Model
	--target = target or self.Model or self.ClonedObjBasePart
	if not target then return end

	local isModel = target:IsA("Model")
	local getCF   = function()
		return isModel and target:GetPivot() or target.CFrame
	end
	local setCF   = function(cf)
		if isModel then
			target:PivotTo(cf)
		else
			target.CFrame = cf
		end
	end

	local originCF = getCF()
	local t0       = os.clock()
	local spin     = 0
	local spinStep = math.rad(spinDegPerStep)

	isMoving= true
	while isMoving and target do
		local t = os.clock() - t0
		local y = (math.sin(2 * math.pi * freq * t) + 1) * (amplitude / 2)  -- 0..amplitude

		spin += spinStep
		setCF(originCF * CFrame.new(0,y, .1) * CFrame.Angles(0, spin, 0))

		RunService.Heartbeat:Wait()
	end
end



task.spawn(function()
	UpDownGlove(parent.Parent.Display)
end)

local function ApplyDisplay()
	local disp =parent.Parent.Display
	for _,item in pairs(disp:GetDescendants()) do
		if item:IsA("MeshPart") then
			item.Transparency=1
		end
	end
	local showable = IsShort and disp:FindFirstChild("Short") or disp:FindFirstChild("Gloves")
	for _,item in pairs(showable:GetDescendants()) do
		if item:IsA("MeshPart") then
			item.Transparency=0
		end
	end
	
end

task.spawn(function()
	while true do
		ApplyDisplay()
		task.wait(30)
		IsShort =( not IsShort )
	end
end)

GateToEnterPrompt.Triggered:Connect(function(player)
	Open_Shop:FireClient(player, IsShort and "Shorts" or "Gloves")
end)]]></ProtectedString>
											<string name="ScriptGuid">{2DAE242C-26F1-4A14-99AA-12E5E2C81C81}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Display_Podium_Right.server.lua</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX3E3BBAFB237B4D0BAB53C731A0F33D20">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Objects</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX5EA0C71D96BA44058AC44C64FF693E86">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">TeleportPads</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX12CBA00FC6F54644928A929D332A3044">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local inside = {}    -- [userId] = zone actuelle
local lastZone = {}  -- [userId] = zone d'où il vient

local function isInZone(hrp, zone)
	if not hrp or not zone or not zone:IsA("BasePart") then return false end
	local rel = hrp.Position - zone.Position
	return math.abs(rel.X) <= zone.Size.X / 2
		and math.abs(rel.Y) <= zone.Size.Y / 2
		and math.abs(rel.Z) <= zone.Size.Z / 2
end

local function warpPlayer(player, fromZone, toPad)
	local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
	local toZone = toPad:FindFirstChild("TeleportZone")
	if not hrp or not toZone then return end

	local pos = toZone.Position + Vector3.new(0, 3, 0)
	local lookAt = pos + hrp.CFrame.LookVector
	player.Character:PivotTo(CFrame.new(pos, lookAt))

	hrp.AssemblyLinearVelocity = Vector3.new()
	hrp.AssemblyAngularVelocity = Vector3.new()

	inside[player.UserId] = toZone
	lastZone[player.UserId] = fromZone
end

RunService.Heartbeat:Connect(function()
	for _, player in pairs(game.Players:GetPlayers()) do
		local char = player.Character
		local hrp = char and char:FindFirstChild("HumanoidRootPart")
		if not hrp then continue end

		local currentZone = inside[player.UserId]

		for _, teleporter in pairs(script.Parent:GetChildren()) do
			if not teleporter:IsA("Model") then continue end
			local zone = teleporter:FindFirstChild("TeleportZone")
			local linkedValue = zone and zone:FindFirstChild("LinkedPad")
			if not zone or not linkedValue or not linkedValue.Value then continue end

			local inZone = isInZone(hrp, zone)

			-- Entrée dans une zone
			if inZone and currentZone ~= zone then
				-- bloquer retour instantané
				if linkedValue.Value == lastZone[player.UserId] then
					-- ignore ce TP, joueur vient juste de cette zone
					continue
				end
				warpPlayer(player, zone, linkedValue.Value)
				break
			end

			-- Sortie d'une zone
			if not inZone and currentZone == zone then
				inside[player.UserId] = nil
			end
		end
	end
end)
]]></ProtectedString>
									<string name="ScriptGuid">{CFE35764-A4EE-45FA-BF47-5D826C45C3BF}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Teleport.server.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX933A51C3582A448CADD08A65D10029EC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Rankings</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXF55C951339AE43E3B4401125175ED712">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Ranking_Items</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX8368F38C28E64B62A4891D921CDDDB85">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">1_Stand</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX7A328DDFCA204179AF1313DC34BE22EE">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Spotlight</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBX272546FAA2574CC993A6D16F1EEB030B">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Model</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBX657E396F72454F6B8EA02ED34AFD4811">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
													<string name="ScriptGuid">{5D01DB9A-070F-43F4-9C7D-7E3F92EEB3C0}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">ApplyLights.server.lua</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBXE2410902426A48D78EDF5C447FDE28FC">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">2_Stand</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBXEDC363FBE56844A183E0595535D364C9">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Spotlight</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBX7162EF486C2A466B950C86F02E28E4EC">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Model</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBX17804F7F9EDB4D75A9E5010E95EF94AE">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
													<string name="ScriptGuid">{DEA28C8C-4B0F-4392-BF43-6B9B9C4561F7}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">ApplyLights.server.lua</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBXC6DBE21B6881409491DAD7B2FF47B6EA">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">3_Stand</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX4C4251912FBF416398F2DDF7FAA0DEF0">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Spotlight</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBXD45533C033D24DAFB403C91E4CB1B4C0">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Model</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBX6826844177574A20BC382277D5BC0F65">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
													<string name="ScriptGuid">{2D84A9EF-05B5-4EE4-84CA-C2239301FBBC}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">ApplyLights.server.lua</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXBF9D9D7B476B4E7A9302C7070C1EBD29">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">PunchingGame</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX893C18F750434B61938D6F4446C44634">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">PunchGame</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX53AC4E4F6052404CAAF1EE7074B35463">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- Punching_Machine_Activate.server.lua



local RS = game:GetService("ReplicatedStorage")
local Data_Mod_F = RS.Data_Mods_F
local Channels = require(RS.Modules.Channels)
local Config = require(Data_Mod_F.Punching_Game_Config_Mod)

local Controller = require(Data_Mod_F.Punching_Game_Controller_Mod)
local SlowMo = require(Data_Mod_F.AnimationSlowmo)

local ctrl = Controller.new(script.Parent, Channels, Config, SlowMo)
ctrl:Init()
]]></ProtectedString>
										<string name="ScriptGuid">{3B4411B4-C653-45D3-980D-5C2FF8667E08}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Punching_Game.server.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXCC240BDB2AF34FE3ACEBC50473320231">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[local Color_Mod = require( game.ReplicatedStorage.Data_Mods_F:WaitForChild("PodiumColors_Mod"))
Color_Mod.new(script.Parent, "S1", {

	
	{
		Name = "TextLabel",
		Use  = "RibbonGradient", -- multi-stop, UIGradient with Rotation=40
	},
	
},
{
	CanSetText=true,
	TextObjName="TextLabel",
	Text="TRY ME!"
})]]></ProtectedString>
										<string name="ScriptGuid">{648A2DBB-50EF-477D-B900-DEC1FEAE6483}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Display_Podium_Left_ColorAdjustemt.server.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXE16F06AEC45B456C8347AE332122CA28">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- Punching_Machine_Activate.server.lua



local RS = game:GetService("ReplicatedStorage")
local Data_Mod_F = RS.Data_Mods_F
local Channels = require(RS.Modules.Channels)
local Config = require(Data_Mod_F.Punching_Game_Config_Mod)

local Controller = require(Data_Mod_F.Punching_Game_Controller_Mod)
local SlowMo = require(Data_Mod_F.AnimationSlowmo)

local ctrl = Controller.new(script.Parent, Channels, Config, SlowMo)
ctrl:Init()
]]></ProtectedString>
										<string name="ScriptGuid">{CD47D8CC-3DF1-444F-B1C6-7029C468E3F2}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Punching_Game.server.lua (2)</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX9BB29D1C980746B98612A52760683C83">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[local Color_Mod = require( game.ReplicatedStorage.Data_Mods_F:WaitForChild("PodiumColors_Mod"))
Color_Mod.new(script.Parent, "S1", {

	
	{
		Name = "TextLabel",
		Use  = "RibbonGradient", -- multi-stop, UIGradient with Rotation=40
	},
	
},
{
	CanSetText=true,
	TextObjName="TextLabel",
	Text="TRY ME!"
})]]></ProtectedString>
										<string name="ScriptGuid">{041B1432-A770-4BCC-B441-0F8F6CB5A599}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Display_Podium_Left_ColorAdjustemt.server.lua (2)</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX62A254993F534265AFF40A95A54E7B7B">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- Punching_Machine_Activate.server.lua



local RS = game:GetService("ReplicatedStorage")
local Data_Mod_F = RS.Data_Mods_F
local Channels = require(RS.Modules.Channels)
local Config = require(Data_Mod_F.Punching_Game_Config_Mod)

local Controller = require(Data_Mod_F.Punching_Game_Controller_Mod)
local SlowMo = require(Data_Mod_F.AnimationSlowmo)

local ctrl = Controller.new(script.Parent, Channels, Config, SlowMo)
ctrl:Init()
]]></ProtectedString>
										<string name="ScriptGuid">{408B403F-73C3-4E56-B6A3-CE51B593F13B}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Punching_Game.server.lua (3)</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX26A91452EC9B40F78446E73D1B5F36FD">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[local Color_Mod = require( game.ReplicatedStorage.Data_Mods_F:WaitForChild("PodiumColors_Mod"))
Color_Mod.new(script.Parent, "S1", {

	
	{
		Name = "TextLabel",
		Use  = "RibbonGradient", -- multi-stop, UIGradient with Rotation=40
	},
	
},
{
	CanSetText=true,
	TextObjName="TextLabel",
	Text="TRY ME!"
})]]></ProtectedString>
										<string name="ScriptGuid">{2287A885-9D13-4817-8EAA-7537767EC5C2}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Display_Podium_Left_ColorAdjustemt.server.lua (3)</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX7D8B6A0B869E4B5E9B675656D3E37081">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Environment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXB4AB8C0EC5104BC1AED62B91F217D1F3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Art</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXE17850B7F27E41BA9CF2C101B8553112">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Shop</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX070CD371CFAA4A45BEF89119DCA7E939">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Shop_Improvement</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBXCDED324044964969B7B6FE9E1428B691">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">ShopTxtTopRight</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX0F50FEF2B24F4E12BB890A8846C57022">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ShopTxtLights</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX607BE4D6780C4747AD3E2CFAB1B5BA7E">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
												<string name="ScriptGuid">{B96BCB08-3303-4F74-BFE1-97C509AA3678}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ApplyLights.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBXC28E032BE877471FBCBF699C27454556">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Arrow</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBXD81B41D4C4884344A64967F9B5411F30">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ArrowBodyTransparent</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX14582DA174CE4BAC8C5490481341CFC2">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")

-- Constants
local OFFSET_STUDS = -30
local MOVE_TIME = 2.0
local HOLD_TIME = 0.25
local RESET_PAUSE = 1.0
local EASING_STYLE = Enum.EasingStyle.Sine
local EASING_DIR = Enum.EasingDirection.InOut
local FADE_DECALS_AND_TEXTURES = true

-- Locate model
local model = script:FindFirstAncestorOfClass("Model")
assert(model, "This script must be parented under the Model you want to tween.")

-- Collect parts and decals/textures
local parts, decalsOrTextures = {}, {}
for _, d in ipairs(model:GetDescendants()) do
	if d:IsA("BasePart") then
		parts[#parts + 1] = d
	elseif FADE_DECALS_AND_TEXTURES and (d:IsA("Decal") or d:IsA("Texture")) then
		decalsOrTextures[#decalsOrTextures + 1] = d
	end
end

-- Cache original transparency
local originalTransparency = {}
for _, obj in ipairs(parts) do originalTransparency[obj] = obj.Transparency end
for _, obj in ipairs(decalsOrTextures) do originalTransparency[obj] = obj.Transparency end

local function resetVisuals()
	for obj, t in pairs(originalTransparency) do
		if obj and obj.Parent then
			obj.Transparency = t
		end
	end
end

local homeCF = model:GetPivot()

local function tweenTransparency(targetTransparency)
	local tweens = {}
	local info = TweenInfo.new(MOVE_TIME, EASING_STYLE, EASING_DIR)
	for _, obj in ipairs(parts) do
		if obj.Parent then
			tweens[#tweens + 1] = TweenService:Create(obj, info, { Transparency = targetTransparency })
		end
	end
	for _, obj in ipairs(decalsOrTextures) do
		if obj.Parent then
			tweens[#tweens + 1] = TweenService:Create(obj, info, { Transparency = targetTransparency })
		end
	end
	for _, tw in ipairs(tweens) do tw:Play() end
	return tweens
end

local function runOnce()
	local proxy = Instance.new("CFrameValue")
	proxy.Value = homeCF
	local connection = proxy:GetPropertyChangedSignal("Value"):Connect(function()
		if model.Parent then
			model:PivotTo(proxy.Value)
		end
	end)

	local goalCF = homeCF * CFrame.new(0, 0, OFFSET_STUDS)
	local info = TweenInfo.new(MOVE_TIME, EASING_STYLE, EASING_DIR)
	local moveTween = TweenService:Create(proxy, info, { Value = goalCF })

	-- Run movement + fade together
	moveTween:Play()
	tweenTransparency(1)
	moveTween.Completed:Wait()

	task.wait(HOLD_TIME)

	-- Reset
	connection:Disconnect()
	model:PivotTo(homeCF)
	resetVisuals()
	proxy:Destroy()

	task.wait(RESET_PAUSE)
end

while task.wait() do
	runOnce()
end
]]></ProtectedString>
												<string name="ScriptGuid">{46C53377-32E6-4B64-B480-E319BF4B96D9}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">move.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="Folder" referent="RBX948F6B75DECE4811BD2FA383BAF65774">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ShopTxt</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBX8D3BC4831959483CA3262C45C5D38771">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ShopTxtLights</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBX84FFBDD79A5A4E61A31167B99695F09E">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
													<string name="ScriptGuid">{5C031CCE-C5DC-4396-93AF-317CF56D1C0A}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">ApplyLights.server.lua</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX3A939D9BA41F45D7A19886273FC8FAD2">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
													<string name="ScriptGuid">{A4061AD6-324B-4048-A7A9-04411D75D528}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">ApplyLights.server.lua (2)</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="Folder" referent="RBX8F3D9BF175B74891BE8163690A52B773">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">ShopText</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBXA8A0AEB05E38494A8C1C686E47A36299">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local parent = script.Parent.Parent 

local tweenInfo = TweenInfo.new(
	1,                      
	Enum.EasingStyle.Linear,  
	Enum.EasingDirection.InOut,
	0, false, 0
)

local rng = Random.new()

local EXCLUDE_CYAN_HALF_WIDTH = 0.04
local CYAN_HUE = 0.5  

local function hueInBand(h, center, half)
	-- circular distance on the hue ring
	local d = math.abs(((h - center + 0.5) % 1) - 0.5)
	return d <= half
end

local function randomDiscoColor()
	local h
	repeat
		h = rng:NextNumber(0, 1)
	until not hueInBand(h, CYAN_HUE, EXCLUDE_CYAN_HALF_WIDTH)
	return Color3.fromHSV(h, 1, 1)
end

while true do
	local goal = {Color = randomDiscoColor()}
	for _, obj in ipairs(parent:GetDescendants()) do
		if obj:IsA("MeshPart") then
			local tween = TweenService:Create(obj, tweenInfo, goal)
			tween:Play()
		end
		if obj:IsA("SpotLight") then
			local tween = TweenService:Create(obj, tweenInfo, goal)
			tween:Play()
		end
	end
	task.wait(5) 
end
]]></ProtectedString>
														<string name="ScriptGuid">{0A5A4AF1-F658-414D-B0A3-F6C0490223B0}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">DiscoLights.server.lua</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBX4179608C05694EDEA5DC850C66D7DCB9">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">ShopTxtTopFront</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBXF6A6E03CFCF84CE88763BAA47F40EF74">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ShopTxtLights</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX65B8FB318B1B4967BEA7496B14705667">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
												<string name="ScriptGuid">{B9854B8E-B846-41AE-826A-2BD7C639C861}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ApplyLights.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXF2342D5F9B84435E9CEF79340A4FA25A">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ReplicatedFirst</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXBBFE0A5ECF124BBAAA35A2DCE3275AC5">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local Players 				= game:GetService("Players")
local player 				= Players.LocalPlayer
local TweenService 			= game:GetService("TweenService")
local ContentProvider 		= game:GetService("ContentProvider")
local RunService 			= game:GetService("RunService")
local ThemeManagerModule 	= game.ReplicatedStorage:WaitForChild("Design", 1):WaitForChild("ThemeManager", 1)
local ThemeManager 			= require(ThemeManagerModule)

--  UIs to preload
local CriticalUIs = {
	"Shop/Offer_UI",
	"Menus/Rewards_UI"
}

-- UI references
local ui = script:WaitForChild("Loading_UI", 5)
if not ui then return warn("[LoadingUI] Missing Loading_UI") end
ui.Parent = player:WaitForChild("PlayerGui", 5)
ui.Enabled = true

local canvas = ui:WaitForChild("CanvasGroup")
local Logo = canvas:WaitForChild("Logo")
local ScalingLogo = Logo:WaitForChild("Frame")
ScalingLogo.Size = UDim2.new(1, 0, 0, 0)

local FightImages = {
	canvas:WaitForChild("FightImage1"),
	canvas:WaitForChild("FightImage2"),
}

local splashscreens = ThemeManager.getPath("splashscreens")
if type(splashscreens) ~= "table" or #splashscreens == 0 then
	warn("[LoadingUI] No splashscreens in theme, using fallback.")
	splashscreens = {
		"rbxassetid://133655844729939"
	}
end
-- === Helpers ===
local function safePreload(instances, timeoutSec)
	local done, ok = false, false
	task.spawn(function()
		ok = pcall(function() ContentProvider:PreloadAsync(instances) end)
		done = true
	end)
	local t0 = time()
	while not done and time() - t0 < (timeoutSec or 3) do
		RunService.Heartbeat:Wait()
	end
	return ok or done
end

local function setImage(imgObj, assetId)
	if not imgObj then return false end
	local ok, err = pcall(function() imgObj.Image = assetId end)
	if not ok then warn("[LoadingUI] Failed to set image:", assetId, err) end
	return ok
end

-- === UI Animations ===
local function showInitialImage()
	for _,img in ipairs(FightImages) do img.Visible = false end

	math.randomseed(os.time() + tonumber(tostring({}):sub(8), 16))
	
	local chosenImage = splashscreens[math.random(1, #splashscreens)]
	setImage(FightImages[1], chosenImage)

	safePreload({FightImages[1], ScalingLogo}, 2.0)

	FightImages[1].Visible = true
	TweenService:Create(ScalingLogo, TweenInfo.new(0.3), {
		Size = UDim2.new(1, 0, 0.25, 0)
	}):Play()
end

local function startCarousel()
	task.spawn(function()
		local frames = {FightImages[1], FightImages[2]}
		local idx, previous = 1, FightImages[1]

		while ui and ui.Parent do
			task.wait(3)

			local frame = frames[idx]
			frame.Position = UDim2.new(0.55, 0, 0.5, 0)
			frame.ImageTransparency = 1
			setImage(frame, splashscreens[math.random(1, #splashscreens)])

			if previous then
				TweenService:Create(previous, TweenInfo.new(0.3), {ImageTransparency = 1}):Play()
			end
			TweenService:Create(frame, TweenInfo.new(3, Enum.EasingStyle.Linear), {
				Position = UDim2.new(0.45, 0, 0.5, 0),
				ImageTransparency = 0
			}):Play()

			previous = frame
			idx = (idx % #frames) + 1
		end
	end)
end

local function exitLoading()
	task.spawn(function()
		for i = 1, 4 do
			task.wait(0.15 + math.random()*0.05)
			TweenService:Create(ScalingLogo, TweenInfo.new(0.2), {
				Size = UDim2.new(1, 0, i/4, 0)
			}):Play()
		end
		task.wait(0.6)
		TweenService:Create(canvas, TweenInfo.new(0.25), {GroupTransparency = 1}):Play()
		task.wait(0.4)
		if ui then ui:Destroy() end
	end)
end


local function preloadCriticalUIs()
	local PlayerGui = player:WaitForChild("PlayerGui")
	local toPreload = {}

	local function getUIByPath(root, path)
		local current = root
		for segment in string.gmatch(path, "[^/]+") do
			current = current:FindFirstChild(segment)
			if not current then
				return nil
			end
		end
		return current
	end

	for _, path in ipairs(CriticalUIs) do
		local uiObj = getUIByPath(PlayerGui, path)
		if uiObj then
			for _, d in ipairs(uiObj:GetDescendants()) do
				if d:IsA("ImageLabel") or d:IsA("ImageButton") or d:IsA("Sound") then
					table.insert(toPreload, d)
				end
			end
		else
			warn(string.format("[LoadingUI] Critical UI not found: %s", path))
		end
	end

	if #toPreload > 0 then
		safePreload(toPreload, 3.0)
	end
end



-- === Main Flow ===
local MIN_DISPLAY_TIME = 3  -- seconds
local startTime = os.clock()

showInitialImage()
startCarousel()
preloadCriticalUIs()

-- === Background Audio Preload (non-blocking) ===
task.spawn(function()
	local function collectSounds(folder)
		local list = {}
		for _, obj in ipairs(folder:GetDescendants()) do
			if obj:IsA("Sound") then
				table.insert(list, obj)
			end
		end
		return list
	end

	local AudioFolder = game.ReplicatedStorage:FindFirstChild("Audio")
	if AudioFolder then
		local sounds = collectSounds(AudioFolder)
		if #sounds > 0 then
			pcall(function()
				ContentProvider:PreloadAsync(sounds)
			end)
		end
	end
end)

-- Ensure minimum display duration before exit
local elapsed = os.clock() - startTime
if elapsed < MIN_DISPLAY_TIME then
	task.wait(MIN_DISPLAY_TIME - elapsed)
end

exitLoading()

task.defer(function()
	game.ReplicatedStorage.Channels_F.Bindable_F.Events.Game_Loading_Finished:Fire()
end)]]></ProtectedString>
					<string name="ScriptGuid">{5F3E7449-BC3E-4E69-959E-AD3EC28C0F6F}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">LoadingScreen.client.lua</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXD93F757BC0D54624AA577C6076EBAFBA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">LoadingScreen</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX9EA0B9B2F1514602B8AB43B6605F3CFD">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Loading_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX9411E710F6BB4142995DB7419E42B0B4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CanvasGroup</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXC37479147A4C44498923485991150032">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">TextLabel</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXB58A0F32B62541C8BDD7FE2BF79E65BE">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local textOne = script.Parent
local textTwo = textOne:WaitForChild("TextLabel")

local updateDelay = 1/5

local iterator = 1

while textOne do
	local text = `Loading{string.rep(".",iterator%4)}`
	textOne.Text = text
	textTwo.Text = text
	task.wait(updateDelay)
	iterator += 1
end]]></ProtectedString>
									<string name="ScriptGuid">{D5A9FFEE-B8F6-45AC-A4A4-7CE7C95D5D64}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalScript.client.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX544940B272E04C198B8144D9234A6979">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">StarterPlayer</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX7742A6F93A1C49DBB1F21F53839AB0F1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">StarterPlayerScripts</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXCEC267EFF6BB46ADB3C6DAB9C3F26C2A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Ranked_Wall_Handle.lua
--
--  Description:
--      Handles the ranked arena access wall for players.
--      Displays a progress bar based on the player's total wins and
--      removes the wall once the required wins threshold is reached.
--
--  Author(s): Exclusible, Darkzeb
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage/Channels_F/Bindable_F/Events
--      - ReplicatedStorage/Channels_F/Bindable_F/RF
--      - StarterPlayerScripts/Player_Data ("Total Wins")
--
--  Notes:
--      - Wall disappears once Total Wins >= Wins_Requirement
--      - Sends a notification to the player when access is granted
--      - Wins_Requirement can be adjusted via the script variable
--
--======================================================================


local RS 						= game:GetService("ReplicatedStorage")

local Data_Mods_F 				= RS:WaitForChild("Data_Mods_F")
local Fight_Params_Mod			= require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Display_Data 				= Channels.Bindable_Events.Display_Data
local Player_Can_Access_Arena 	= Channels.Bindable_Functions.Player_Can_Access_Arena

local Workspace 				= game:GetService("Workspace")
local Players 					= game:GetService("Players")
local Plr 						= Players.LocalPlayer
local PD						= Plr:WaitForChild("Player_Data")
local Total_Wins_V 				= PD:WaitForChild("Total Wins")
local Wall_Template 			= script:WaitForChild("Ranked_Arena_Wall")

local WALL_POSITION 			= CFrame.new(-342.939, 103.164, 144.812)

--==================================================
-- Create and manage arena wall
--==================================================
local function CreateArenaWall()
	local wall = Wall_Template:Clone()
	wall.Name = "Ranked_Arena_Wall"
	wall.CFrame = WALL_POSITION
	wall.Parent = Workspace

	local ui = wall:WaitForChild("SurfaceGui")
	local bar = ui.Main_F.Prog_Bar_F.Bar_F

	-- Updates the progress bar fill based on win ratio
	local function UpdateBar()
		local ratio = math.clamp((Total_Wins_V.Value or 0) / Fight_Params_Mod.Ranked_Arena_Required_Wins, 0, 1)
		bar:TweenSize(UDim2.new(ratio, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.35, true)
	end

	UpdateBar()

	-- Handle dynamic updates and removal when unlocked
	local connection
	connection = Total_Wins_V.Changed:Connect(function()
		if Total_Wins_V.Value < Fight_Params_Mod.Ranked_Arena_Required_Wins then
			UpdateBar()
			return
		end

		if connection then
			connection:Disconnect()
			connection = nil
		end

		if wall and wall.Parent then
			wall:Destroy()
		end

		Display_Data:Fire("🏆 You can now engage in Ranked Fights at The Arena!", Color3.fromRGB(255, 170, 0))
	end)
end

Player_Can_Access_Arena.OnInvoke = function()
	return (Total_Wins_V and Total_Wins_V.Value >= Fight_Params_Mod.Ranked_Arena_Required_Wins)
end

--==================================================
-- Initialization
--==================================================
task.defer(function()
	if Total_Wins_V.Value < Fight_Params_Mod.Ranked_Arena_Required_Wins then
		CreateArenaWall()
	end
end)]]></ProtectedString>
						<string name="ScriptGuid">{EECB73C6-5963-4818-9B8B-CBCCBFF5BAD5}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Ranked_Wall_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD786A8152D6B46E8BACD919758412710">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Damage_OverheadDisplay_Client.lua
--
--  Description:
--      Displays animated floating damage numbers above the target's head 
--      whenever the client receives a damage event from the server.
--      Each damage number fades in, rises slightly, and then fades out 
--      before being cleaned up automatically.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-10-304 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events/Overhead_Display
--      - Script:
--          * Damage_TMP (BillboardGui template with Damage_Detail TextLabel)
--      - Roblox Services:
--          * TweenService (for animations)
--          * Debris (for cleanup, though manual destroy is used)
--          * Players (LocalPlayer)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Receives damage info from server via Overhead_Display event
--      - Randomizes small rotation and movement offsets for natural variation
--      - Uses three sequential tweens: fade-in, rise, fade-out
--      - Safely cleans up the BillboardGui instance after display
--      - Can be extended to support crit indicators, heal effects, or fonts
--
--======================================================================

local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local RS = game:GetService("ReplicatedStorage")

local Channels 			= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Overhead_Display 	= Channels.SC_Remote_Events.Overhead_Display

local Damage_TMP = script:WaitForChild("Damage_TMP")

--==================================================
-- Tween settings
--==================================================
local TWEEN_IN = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local TWEEN_MOVE = TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
local TWEEN_OUT = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)

local POS_OPTIONS = {
	{Rotation = -10, EndPos = Vector3.new(-5, 10, 0)},
	{Rotation = 0,   EndPos = Vector3.new(0, 10, 0)},
	{Rotation = 10,  EndPos = Vector3.new(5, 10, 0)},
}

--==================================================
-- Core: Display floating damage
--==================================================
local function ApplyDamageUI(targetModel, damageText, color)
	local head = targetModel:FindFirstChild("Head")
	if not head then return end

	local posData = POS_OPTIONS[math.random(1, #POS_OPTIONS)]
	local clone = Damage_TMP:Clone()
	local label = clone:WaitForChild("Damage_Detail")

	label.Text = tostring(damageText)
	label.TextColor3 = color
	label.Rotation = posData.Rotation
	label.TextTransparency = 1
	label.TextStrokeTransparency = 1

	clone.Adornee = head
	clone.Parent = head
	clone.ExtentsOffset = Vector3.new(0, 2.75, 0)
	clone.Enabled = true
	clone.AlwaysOnTop = targetModel == game.Players.LocalPlayer.Character

	-- Fade in + float upward
	TweenService:Create(label, TWEEN_IN, {
		TextTransparency = 0,
		TextStrokeTransparency = 0
	}):Play()

	TweenService:Create(clone, TWEEN_MOVE, {
		ExtentsOffset = posData.EndPos
	}):Play()

	-- Fade out after float
	task.delay(1.5, function()
		if not clone or not clone.Parent then return end

		TweenService:Create(label, TWEEN_OUT, {
			TextTransparency = 1,
			TextStrokeTransparency = 1,
			TextColor3 = Color3.new(1, 1, 1)
		}):Play()

		-- Cleanup automatically after fade out
		Debris:AddItem(clone, 1)
	end)
end

Overhead_Display.OnClientEvent:Connect(function(targetChar, damageTxt, damageCol)
	if targetChar and targetChar:FindFirstChild("Head") then
		ApplyDamageUI(targetChar, damageTxt, damageCol)
	end
end)
]]></ProtectedString>
						<string name="ScriptGuid">{F086BFC0-4FF9-42E7-A313-31AAA74D5EB3}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Overhead_Display_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3C4F92A4447D47AFA206AD717C5F8223">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Player_DeviceDetector_Client.lua
--
--  Description:
--      Detects the player's current device type (Mobile, Console, or PC) 
--      using UserInputService capabilities and reports it back to the server 
--      via RemoteEvents when requested.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events/Update_Player_Device
--          * Channels_F/Client_Server_F/Events/Set_Player_Device
--      - Roblox Services:
--          * UserInputService (to detect input device type)
--          * Players (LocalPlayer)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Device detection logic priority:
--          1. TouchEnabled → "Mobile"
--          2. GamepadEnabled → "Console"
--          3. Otherwise → "PC"
--      - Server triggers Update_Player_Device; client responds with device type
--      - Useful for adaptive UI or gameplay behavior per platform
--
--======================================================================
local RS 					= game:GetService("ReplicatedStorage")

local PlayerUtils			= require(RS:WaitForChild("Modules"):WaitForChild("PlayerUtils"))
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Update_Player_Device 	= Channels.SC_Remote_Events.Update_Player_Device
local Game_Startup_Ready 	= Channels.SC_Remote_Events.Game_Startup_Ready
local Set_Player_Device		= Channels.CS_Remote_Events.Set_Player_Device
local Game_Loading_Finished	= Channels.Bindable_Events.Game_Loading_Finished

local StartupUIManager 		= require(game.ReplicatedStorage.Modules.StartupUIManager)


local loadingFinished = false
local gameReadyPayload = nil
local started = false

local function tryStart()
	local StarterGui = game:GetService("StarterGui")
	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, false)
	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
	
	if started then return end
	if loadingFinished and gameReadyPayload then
		started = true
		StartupUIManager.start(gameReadyPayload.firstTime)
	end
end

Game_Loading_Finished.Event:Connect(function()
	loadingFinished = true
	tryStart()
end)

Game_Startup_Ready.OnClientEvent:Connect(function(payload)
	gameReadyPayload = payload
	tryStart()
end)

--==================================================
-- Listen for player device change
--==================================================
Update_Player_Device.OnClientEvent:Connect(function()
	local playerDevice = PlayerUtils.GetPlayerDevice()
	Set_Player_Device:FireServer(playerDevice)
end)]]></ProtectedString>
						<string name="ScriptGuid">{23C02DF8-DF08-482D-AFC0-725D6FAAEA43}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">General_Client_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD59FB7D2428B4AF3BBD357B62C9FB9BD">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/UGC_Offers_Client.lua
--
--  Description:
--      Handles client-side display and timing of UGC (User Generated Content)
--      offers shown on world podiums. Listens to remote events from the server
--      to update podiums with active offers, countdown timers, and status messages.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Remotes/Offers/UGC
--              - SendUGCOfferToClient (RemoteEvent)
--              - ShowMessage (RemoteEvent)
--          * OfferItems/UGCItems (folder containing displayable UGC assets)
--          * Channels_F/Bindable_F/Events/Display_Data
--          * Script.UGCClientHelper (module handling countdown logic)
--      - Workspace:
--          * Main_World_F/Objects/Offers_Data/UGCPodiums
--              - Each podium must contain:
--                  * OfferAttachment with BillboardGui and Prompt
--                  * Item (container for the displayed UGC object)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Dynamically updates podium visuals when receiving new UGC offer data
--      - Creates and manages independent countdown timers for each podium
--      - On offer expiration, automatically requests new data from the server
--      - Displays colored success/error messages via the Display_Data event
--      - Cleans up old models and disables prompts before reloading new offers
--
--======================================================================

-- Services
local RS = game:GetService("ReplicatedStorage")

-- Events
local Channels 			   	= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local SendUGCOfferToClient 	= Channels.Offers.SendUGCOfferToClient
local ShowMessage 			= Channels.Offers.ShowMessage
local Display_Data 			= Channels.Bindable_Events.Display_Data


--====================================================
-- References
--====================================================
local Main_World_F 		 = game.Workspace:WaitForChild("Main_World_F")
local Gameplay 			 = Main_World_F:WaitForChild("Gameplay")
local Offers_Data 		 = Gameplay:WaitForChild("Shop"):WaitForChild("Offers_Data")
local PodiumsFolder      = Offers_Data:WaitForChild("UGCPodiums")

local UGCItemsFolder     = RS:WaitForChild("Models"):WaitForChild("UGC"):WaitForChild("OfferItems"):WaitForChild("UGCItems")
local UGCTimmer          = require(script:WaitForChild("UGCClientHelper"))

local TimmerObjects = {}

--====================================================
-- Utility: Safe clear function
--====================================================
local function clearChildrenSafe(container)
	if not container or not container:IsDescendantOf(game) then return end
	container:ClearAllChildren()
end


SendUGCOfferToClient.OnClientEvent:Connect(function(offerData, podiumID)
	if not podiumID then return end

	-- Stop any previous countdown
	local existingTimer = TimmerObjects[podiumID]
	if existingTimer then
		pcall(function() existingTimer:StopCountdown() end)
		TimmerObjects[podiumID] = nil
	end

	local podium = PodiumsFolder:FindFirstChild(podiumID)
	if not podium then return end

	local offerAttachment = podium:FindFirstChild("OfferAttachment")
	if not offerAttachment then return end

	local prompt = offerAttachment:FindFirstChild("Prompt")
	local itemContainer = podium:FindFirstChild("Item")

	if not itemContainer or not prompt then return end

	-- Clean podium before loading new offer
	clearChildrenSafe(itemContainer)
	prompt.Enabled = false

	if not offerData then
		return
	end

	-- Clone and position new UGC item
	local showableItem = UGCItemsFolder:FindFirstChild(offerData.RefName)
	local showablePart
	if showableItem then
		showablePart = showableItem:Clone()
		showablePart.Parent = itemContainer
		showablePart.CFrame = offerAttachment.WorldCFrame * CFrame.new(0, 3, 0)
	end

	-- Enable prompt and start countdown
	prompt.Enabled = true
	prompt.ObjectText = tostring(offerData.Title) .. "!"

	local timerObj = UGCTimmer.new(nil, podiumID, showablePart,offerData.Key)
	TimmerObjects[podiumID] = timerObj

	timerObj:StartCountdown(offerData.EndsAt, function(podiumName)
		-- Refresh when timer ends
		SendUGCOfferToClient:FireServer(podiumName)
	end)

end)

--====================================================
-- Message Display
--====================================================
local function showMessage(message, isSuccess)
	local prefix = isSuccess and "" or ""
	local color = isSuccess and Color3.fromRGB(35, 244, 68) or Color3.new(1, 0, 0)
	Display_Data:Fire(prefix .. tostring(message), color)
end

ShowMessage.OnClientEvent:Connect(showMessage)]]></ProtectedString>
						<string name="ScriptGuid">{8D6B50BD-DB63-442A-B657-0063FCE6F185}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Display_Podium_UGC_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX2D0B791DA8664D2C98261ED66EFF87B7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Display_Podium_UGC_Handle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX00445446BDBA439A8FDDC7E18EB123FC">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Display_Podium_UGC_Handle/UGCClientHelper.lua
--
--  Description:
--      Handles countdown timers and rotation for UGC items displayed
--      on podiums in the game. Provides a class-like structure to:
--        - Start and stop countdowns for limited-time offers
--        - Rotate displayed UGC objects continuously
--        - Update GUI text with formatted remaining time
--        - Trigger callbacks when offers expire
--
--      Key features:
--        - Supports multiple podiums independently
--        - Manages asynchronous countdown threads safely
--        - Includes formatting for days, hours, minutes, and seconds
--        - Stops countdowns and rotation when offers end
--
--  Author(s): Adnan
--
--  Last Modified: 2025-09-30 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - None external (pure Lua module)
--      - Expects:
--          * TextObject (GUI TextLabel) for displaying countdown
--          * ClonedObjBasePart (UGC item BasePart) for rotation
--          * PodiumName (string identifier for the podium)
--
--  Notes:
--      - Uses task.spawn for asynchronous updates
--      - RotateObject rotates the object 0.5° per frame around Y-axis
--      - Countdown can be safely restarted; previous threads are invalidated
--      - onExpire callback is called when countdown reaches zero
--======================================================================

local Channels 			   = require(game.ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Channels"))
local Shop_Item_Purchased = Channels.SC_Remote_Events.Shop_Item_Purchased

local UGCCH = {}

UGCCH.__index = UGCCH

function UGCCH.new(textObject,podiumName,obj,Key)
	local self = setmetatable({}, UGCCH)
	self.TextObject = textObject
	self.PodiumName = podiumName
	self.countdownThread =nil
	self.countdownRev = 0  
	self.ClonedObjBasePart=obj
	self.IsObjectRotating=false
	self.onExpire=nil
	self.Key=Key
	self.PurchasedCon = Shop_Item_Purchased.OnClientEvent:Connect(function(ItemType,key)
		local data=string.split(ItemType,"_")
		if data[1]~="UGC" then
			return
		end	

		if self.Key == key then
			self.onExpire(self.PodiumName)
			self.onExpire=nil
			self:StopCountdown()
		end
	end)
	return self
end


local function formatDHMS(rem: number): string
	rem = math.max(0, rem)
	local d = math.floor(rem / 86400)
	local h = math.floor((rem % 86400) / 3600)
	local m = math.floor((rem % 3600) / 60)
	local s = rem % 60

	if d > 0 then
		return string.format("LIMITED TIME OFFER\n%dd %dh %dm", d, h, m)
	elseif h > 0 then
		return string.format("LIMITED TIME OFFER\n%dh %dm %ds", h, m, s)
	else
		return string.format("LIMITED TIME OFFER\n%dm %ds", m, s)
	end
end
local function SetText(txtObj,txt)
	if txtObj then
		txtObj.Text = txt
	end
end

local RunService = game:GetService("RunService")

function UGCCH:RotateObject()
	if not self.ClonedObjBasePart then return end
	local part = self.ClonedObjBasePart
	local originCF = part.CFrame              -- starting pose
	local t0 = os.clock()
	local spin = 0                            -- accumulated yaw
	local spinPerStep = math.rad(0.5)         -- same as before
	local amplitude = 2                       -- max up offset
	local freq = 0.2                            -- cycles per second (bobbing speed)

	self.IsObjectRotating = true
	while self.IsObjectRotating and part do
		-- elapsed time
		local t = os.clock() - t0

		-- 0..2 offset: (sin + 1) maps from [-1,1] to [0,2]
		local y = (math.sin(2*math.pi*freq * t) + 1) * (amplitude/2)

		-- accumulate spin
		spin += spinPerStep

		-- rebuild transform from origin: origin -> up offset -> yaw
		part.CFrame = originCF * CFrame.new(0, y, 0) * CFrame.Angles(0, spin, 0)

		RunService.Heartbeat:Wait()
	end
end

function UGCCH:StopCountdown()
	self.countdownRev += 1
	SetText(self.TextObject,"")
	self.IsObjectRotating = false

end

function  UGCCH:StartCountdown(endsAt: number,onExpire)
	-- Validate input

	if typeof(endsAt) ~= "number" or endsAt <= 0 then
		onExpire(self.PodiumName)
		self.onExpire=nil
		self:StopCountdown()
		return
	end
	self.onExpire = onExpire
	task.spawn(function() self:RotateObject() end)
	self.countdownRev += 1
	local myRev = self.countdownRev
	self.countdownThread = task.spawn(function()
		while myRev == self.countdownRev do


			local now = os.time()
			local rem = math.max(0, endsAt - now)

			if rem <= 0 then
				SetText(self.TextObject, "OFFER ENDED")
				onExpire(self.PodiumName)
				self.onExpire=nil
				if myRev == self.countdownRev then
					self.countdownRev += 1
				end
				break
			end
			SetText(self.TextObject, formatDHMS(rem))

			task.wait(1)
		end

		if myRev == self.countdownRev then
			self.countdownThread = nil
		end
	end)
end


return UGCCH
]]></ProtectedString>
							<string name="ScriptGuid">{1FFD4E2D-A1BD-41E3-8D7C-9A32156959DE}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UGCClientHelper.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXE38F5D0BCC0F4E3EA14CD0126EE408F9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Display_Podium_UGC_Handle.lua
--
--  Description:
--      Handles the client-side display of limited-time cloth offers.
--      Manages showing 3D cloth models on podiums, updating countdown
--      timers, and syncing with server offer data via RemoteEvents and
--      RemoteFunctions.
--
--      Key features:
--        - Requests current and new cloth offers from the server
--        - Displays the offer model on podiums with proper positioning
--        - Anchors models to prevent physics issues
--        - Starts and updates a countdown timer until the offer expires
--        - Fires RemoteEvents to notify server of displayed cloth items
--        - Handles automatic refresh when a new offer is available
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-13 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Remotes/Offers/GetCurrentClothOffer (RemoteFunction)
--          * Remotes/Offers/GetNewClothOffer (RemoteFunction)
--          * Remotes/Offers/ClothItemIdSignal (RemoteEvent)
--          * Clothing_F (Folder containing cloth models)
--      - Workspace:
--          * Offers_Data (Folder containing podiums and GUI elements)
--      - Player Instances:
--          * LocalPlayer (used to track current client session)
--
--  Notes:
--      - Countdown format: "LIMITED TIME OFFER\nXd Xh Xm" etc.
--      - Supports Shorts and Gloves display with proper positioning
--      - Ensures only one active countdown at a time
--      - Dynamically cleans and replaces podium items
--      - Uses task.spawn and task.wait for asynchronous updates
--      - setData flag prevents repeated loading of the same offer
--======================================================================
task.wait(1)

-- Services
local RS  					= game:GetService("ReplicatedStorage")
local RunService 			= game:GetService("RunService")

-- Events
local Channels 			  	= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local GetCurrentClothOffer 	= Channels.Offers.GetCurrentClothOffer
local GetNewClothOffer     	= Channels.Offers.GetNewClothOffer
local ClothItemIdSignal    	= Channels.Offers.ClothItemIdSignal
local Shop_Item_Purchased 	= Channels.SC_Remote_Events.Shop_Item_Purchased

-- Workspace references
local Main_World_F = workspace:WaitForChild("Main_World_F")
local Gameplay = Main_World_F:WaitForChild("Gameplay")
local OfferFolder =Gameplay:WaitForChild("Shop"):WaitForChild("Offers_Data")
local ClothsFolder = game.ReplicatedStorage:WaitForChild("Models"):WaitForChild("Clothing_F")
local ClothShowableItemPlace = OfferFolder.Display_Podium_Left.Item

local setData = false
local countdownRev = 0
local countdownThread = nil
local PingServerForNewCloth
local CurrentOfferItem=nil
--====================================================
-- Utility Functions
--====================================================

local function stopCountdown()
	countdownRev += 1
	-- billboard text handling was removed (disabled in original)
end

local function startCountdown(endsAt: number)
	if typeof(endsAt) ~= "number" or endsAt <= 0 then
		stopCountdown()
		return
	end

	countdownRev += 1
	local myRev = countdownRev

	if countdownThread then
		task.cancel(countdownThread)
	end

	countdownThread = task.spawn(function()
		while myRev == countdownRev do
			local now = os.time()
			local rem = math.max(0, endsAt - now)

			if rem <= 0 then
				if typeof(PingServerForNewCloth) == "function" then
					pcall(PingServerForNewCloth)
				end
				break
			end

			-- text update intentionally disabled (consistent with original)
			task.wait(1)
		end
	end)
end

local function SetPosition(ObjectMesh, pos)
	if not ObjectMesh then return end
	local rotOnly = ObjectMesh.CFrame - ObjectMesh.CFrame.Position
	ObjectMesh.CFrame = CFrame.new(pos) * rotOnly
end

local function AnchoredModel(model)
	for _, descendant in ipairs(model:GetDescendants()) do
		if descendant:IsA("BasePart") then
			descendant.Anchored = true
			--	descendant.Parent = model
		end
		--if descendant:IsA("WeldConstraint") then
		--	descendant:Destroy()
		--end
	end
end

--====================================================
-- Unified floating animation (replaces UpDownShort/Glove)
--====================================================
local function FloatModel(target: Instance, opts)
	if not target then return end
	opts = opts or {}
	local amplitude = opts.amplitude or 2
	local freq = opts.freq or 0.2
	local axis = opts.axis or Vector3.new(0, 1, 0)

	local isModel = target:IsA("Model")
	local getCF = function() return isModel and target:GetPivot() or target.CFrame end
	local setCF = function(cf)
		if isModel then target:PivotTo(cf) else target.CFrame = cf end
	end

	local originCF = getCF()
	local t0 = os.clock()
	local conn

	conn = RunService.Heartbeat:Connect(function()
		if not target or not target.Parent then
			conn:Disconnect()
			return
		end

		local t = os.clock() - t0
		local offset = math.sin(2 * math.pi * freq * t) * (amplitude / 2)
		setCF(originCF * CFrame.new(axis * offset))
	end)

	return conn
end

local isMoving=false

function UpDownGlove(target, opts)
	opts = opts or {}
	isMoving=true
	local amplitude       = tonumber(opts.amplitude) or 2      -- vertical travel (studs)
	local freq            = tonumber(opts.freq)      or 0.2    -- bob cycles per second
	local spinDegPerStep  = tonumber(opts.spinDegPerStep) or 0.5

	-- accept either a Model or a BasePart; if nil, fall back to self.ClonedObjBasePart / self.Model
	--target = target or self.Model or self.ClonedObjBasePart
	if not target then return end

	local isModel = target:IsA("Model")
	local getCF   = function()
		return isModel and target:GetPivot() or target.CFrame
	end
	local setCF   = function(cf)
		if isModel then
			target:PivotTo(cf)
		else
			target.CFrame = cf
		end
	end

	local originCF = getCF()
	local t0       = os.clock()
	local spin     = 0
	local spinStep = math.rad(spinDegPerStep)

	isMoving= true
	while isMoving and target do
		local t = os.clock() - t0
		local y = (math.sin(2 * math.pi * freq * t) + 1) * (amplitude / 2)  -- 0..amplitude

		spin += spinStep
		setCF(originCF * CFrame.new(0,y, .1) * CFrame.Angles(0, spin, 0))

		RunService.Heartbeat:Wait()
	end
end


--====================================================
-- Offer Handling
--====================================================

PingServerForNewCloth = function()
	-- cleanup previous display
	ClothShowableItemPlace.Parent.OfferAttachment.Prompt.Enabled=false
	ClothShowableItemPlace.Parent.OfferAttachment.BillboardGui.TextLabel.Visible=false

	ClothShowableItemPlace:ClearAllChildren()
	isMoving=false
	local CurrentOfferData
	if not setData then
		CurrentOfferData = GetCurrentClothOffer:InvokeServer()
	end

	task.wait()

	local item = CurrentOfferData and CurrentOfferData.offer or GetNewClothOffer:InvokeServer()
	for _,item in ipairs(ClothShowableItemPlace:GetChildren()) do
		item:Destroy()
	end
	if not item then 
		CurrentOfferItem=nil
		return
	end

	local folderName = (item.Kind == "Shorts") and "Shorts_F" or "Gloves_F"
	local ClothItemsParent = ClothsFolder:WaitForChild(folderName)
	local showableItem = ClothItemsParent:FindFirstChild(item.Title)

	if not showableItem then return end

	local showableItemModel = showableItem:Clone()
	showableItemModel.Parent = ClothShowableItemPlace
	ClothItemIdSignal:FireServer(item)
	CurrentOfferItem=item
	showableItemModel:ScaleTo(2)
	if showableItemModel then
		ClothShowableItemPlace.Parent.OfferAttachment.Prompt.Enabled=true
		ClothShowableItemPlace.Parent.OfferAttachment.BillboardGui.TextLabel.Visible=true
	end
	local offerAttachment = ClothShowableItemPlace.Parent:FindFirstChild("OfferAttachment")

	if item.Kind == "Shorts" then
		AnchoredModel(showableItemModel)
		showableItemModel:MoveTo( offerAttachment.WorldCFrame.Position+Vector3.new(0, 5, 0))
		task.defer(function() FloatModel(showableItemModel, { axis = Vector3.new(0, 1, 0) }) end)
	else
		showableItemModel:FindFirstChild("LeftHand").Anchored=true
		showableItemModel:FindFirstChild("RightHand").Anchored=true

		showableItemModel:MoveTo( offerAttachment.WorldCFrame.Position+Vector3.new(0, 3, 0))

		SetPosition(showableItemModel:FindFirstChild("LeftHand"),  offerAttachment.WorldCFrame.Position+Vector3.new(-1, 3, 0))
		SetPosition(showableItemModel:FindFirstChild("RightHand"),  offerAttachment.WorldCFrame.Position+Vector3.new(1, 3, 0))

		task.defer(function() FloatModel(showableItemModel, { axis = Vector3.new(0, 0, 1) }) end)
	end

	startCountdown(item.EndsAt)
end

--====================================================
-- Initialization
--====================================================

task.defer(PingServerForNewCloth)

ClothItemIdSignal.OnClientEvent:Connect(function()
	task.wait(1)
	setData = true
	PingServerForNewCloth()
end)

Shop_Item_Purchased.OnClientEvent:Connect(function(ItemType,key)
	local data=string.split(ItemType,"_")
	if data[1]~="Cloth" then
		return
	end	
	if CurrentOfferItem and CurrentOfferItem.Key == key then
		task.wait(1)
		setData = true
		PingServerForNewCloth()
	end
end)]]></ProtectedString>
						<string name="ScriptGuid">{5CC53696-A0C9-4E17-A302-E2B7B8EB775C}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Display_Podium_Left_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5B334416B4D14596842E7AEF77F71059">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Chat_Customization_Client.lua
--
--  Description:
--      Enhances the Roblox TextChatService system by adding dynamic player 
--      tags, server announcements, and periodic gameplay tips.
--      Features:
--        * Custom prefixes for VIPs, Rookies, and Top 3 leaderboard players
--        * Colored and formatted server messages
--        * Client-side typing status query via BindableFunction
--        * Automated rotating gameplay tips in chat
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events
--              - Top3_Players_Updated
--              - Server_Chat
--          * Channels_F/Bindable_F/RF/Is_Chatbox_Typing
--          * Channels_F/Bindable_F/Events
--      - Roblox Services:
--          * TextChatService
--          * Players (LocalPlayer)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Requires TextChatService enabled (not LegacyChat)
--      - VIP and Rookie tags depend on player attributes:
--            "Is_VIP", "Is_Ultimate_VIP_Sub", "Rookie"
--      - Leaderboard ranks updated from server via "Top3_Players_Updated"
--      - Server messages formatted through <font> HTML color tags
--      - Chat tips rotate every 120s, starting 60s after join
--      - Safe pcall-style access for TextChatService instances
--
--======================================================================

local RS 					= game:GetService("ReplicatedStorage")
local TCS 					= game:GetService("TextChatService")
local TextChannels 			= TCS:WaitForChild("TextChannels")
local SystemChannel			 = TextChannels:WaitForChild("RBXSystem")
local Players 				= game:GetService("Players")

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Top3_Players_Updated 	= Channels.SC_Remote_Events.Top3_Players_Updated
local Is_Chatbox_Typing		= Channels.Bindable_Functions.Is_Chatbox_Typing
local Server_Chat			= Channels.SC_Remote_Events.Server_Chat

local VIP_Tag 				= "[👑 VIP]"
local VIP_Color 			= "rgb(255,175,0)"
local Rookie_Tag 			= "[Rookie]"
local Rookie_Color			= "rgb(205,127,50)"

local Workspace 			= game:GetService("Workspace")
local Main_World_F 			= Workspace:WaitForChild("Main_World_F")
local Gameplay				= Main_World_F:WaitForChild("Gameplay")
local workspaceRankings		 = Gameplay:WaitForChild("Objects"):WaitForChild("Rankings"):WaitForChild("Ranking_Items")

local TOP_COLORS = {
	[1] = "rgb(255,215,0)",   -- Gold
	[2] = "rgb(192,192,192)", -- Silver
	[3] = "rgb(205,127,50)",  -- Bronze
}

local TopPlayers = {}

--==================================================
-- Utility: Reset avatar displays
--==================================================
local function ClearAvatars()
	for _, stand in ipairs(workspaceRankings:GetChildren()) do
		local avatarFolder = stand:FindFirstChild("Avatar")
		if avatarFolder then
			avatarFolder:ClearAllChildren()
		end
	end
end

local function AddPrefix(t, color, text)
	t[#t+1] = string.format("<font color='%s'>%s</font>", color, text)
end

--==================================================
-- Utility: Validate userId and resolve username
--==================================================
local function IsValidUserId(userId)
	if typeof(userId) ~= "number" or userId <= 0 or userId % 1 ~= 0 then
		return false
	end
	local ok, result = pcall(function()
		return Players:GetNameFromUserIdAsync(userId)
	end)
	return ok and result ~= nil and result ~= "", result
end

--==================================================
-- Update leaderboard avatars
--==================================================
Top3_Players_Updated.OnClientEvent:Connect(function(newTop)
	ClearAvatars()
	table.clear(TopPlayers)

	for rank = 1, 3 do
		local userId = newTop[rank]
		TopPlayers[rank] = userId  -- store directly

		-- skip empty slots or invalid default (-1)
		if not userId or userId == -1 then
			continue
		end

		-- resolve username
		local isValid, name = IsValidUserId(userId)
		if not isValid then continue end

		-- get stand components
		local stand = workspaceRankings:FindFirstChild(rank .. "_Stand")
		if not stand then continue end

		local posPoint = stand:FindFirstChild("Top")
		local avatarFolder = stand:FindFirstChild("Avatar")
		if not (posPoint and avatarFolder) then continue end

		-- spawn avatar
		local ok, model = pcall(function()
			return Players:CreateHumanoidModelFromUserId(userId)
		end)

		if ok and model then
			model.Name = name
			model:ScaleTo(1.5)
			model:PivotTo(posPoint.CFrame)
			model.Parent = avatarFolder

			task.delay(0.5, function()
				local root = model:FindFirstChild("HumanoidRootPart")
				if root then root.Anchored = true end
			end)
		else
			warn("Failed to load avatar for userId:", userId, "Error:", model)
		end
	end
end)

--==================================================
-- Chat message prefix customization
--==================================================
TCS.OnIncomingMessage = function(msg: TextChatMessage)
	local source = msg.TextSource
	if not source then return end

	local sender = Players:GetPlayerByUserId(source.UserId)
	if not sender then return end

	local prefix = {}

	-- VIP tags
	if sender:GetAttribute("Is_VIP") or sender:GetAttribute("Is_Ultimate_VIP_Sub") then
		AddPrefix(prefix, VIP_Color, VIP_Tag)
	end

	-- Rookie tag
	if sender:GetAttribute("Rookie") then
		AddPrefix(prefix, Rookie_Color, Rookie_Tag)
	end

	-- Top 3 tag
	for rank, uid in pairs(TopPlayers) do
		if uid == sender.UserId then
			
			local color = TOP_COLORS[rank] or "rgb(255,255,255)"
			table.insert(prefix, string.format("<font color='%s'>[TOP #%d]</font>", color, rank))
			break
		end
	end

	if #prefix > 0 then
		local props = Instance.new("TextChatMessageProperties")
		props.PrefixText = table.concat(prefix, " ") .. " " .. msg.PrefixText
		return props
	end
end

--==================================================
-- Utility: Convert Color3 → font tag
--==================================================
local function ColorToFontTag(color: Color3)
	local r, g, b = math.floor(color.R * 255), math.floor(color.G * 255), math.floor(color.B * 255)
	return string.format("<font color='rgb(%d,%d,%d)'>", r, g, b)
end

--==================================================
-- Server → client chat messages
--==================================================
Server_Chat.OnClientEvent:Connect(function(txt, color)
	local prefix = ColorToFontTag(color)
	SystemChannel:DisplaySystemMessage(prefix .. "[SERVER] " .. txt .. "</font>")
end)

--==================================================
-- Check if player is typing in chat
--==================================================
Is_Chatbox_Typing.OnInvoke = function()
	local bar = TCS:FindFirstChildOfClass("ChatInputBarConfiguration")
	return bar and bar.IsFocused or false
end

local tipsRoutine = nil

--==================================================
-- Rotating gameplay tips
--==================================================
local function StartServerTips()
	if tipsRoutine then return end
	
	local tips = {
		"Think you hit hard? Prove it on the Punching Machine next to the Gym",
		"Find out latest MMA Fighters features through the tutorial, see '?'",
		"The longer you play, the more you are rewarded, see Rewards",
		"Wanna enjoy the Golde Punch event ? Play between 6pm and 10pm in the Gym",
		"Earn more luck by inviting your friends!",
	}
	local TIP_COLOR = "#FFFF00" -- Yellow

	local function DisplayTip(txt)
		local formatted = string.format("<font color='%s'><b>[TIP]</b> %s</font>", TIP_COLOR, txt)
		SystemChannel:DisplaySystemMessage(formatted)
	end

	tipsRoutine = task.spawn(function()
		task.wait(60)
		local index = 1
		while true do
			DisplayTip(tips[index])
			index = (index % #tips) + 1
			task.wait(120)
		end
	end)
end
StartServerTips()]]></ProtectedString>
						<string name="ScriptGuid">{83FB6BF3-FF61-4942-A22A-307675257478}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Custom_Chat_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0525594B5EDD425CA1BA08419A589FBD">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Shop_OpenTrigger_Client.lua
--
--  Description:
--      Detects when the player's character enters predefined collider 
--      zones around shop areas, and fires a BindableEvent to open the 
--      corresponding Shop UI. Each collider group under "OpenColliders"
--      represents a specific shop type or section.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/Shop/OpenColliders
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/Open_Shop
--      - PlayerGui:
--          * Shop_UI
--      - Roblox Services:
--          * Players (LocalPlayer)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - All colliders are made invisible (Transparency = 1)
--      - When player’s HumanoidRootPart touches a collider, fires 
--        the Open_Shop event with the collider group name as parameter
--      - Assumes each collider group represents a distinct shop category
--      - Relies on BindableEvents for decoupled UI control
--
--======================================================================

-- Services
local RS 				= game:GetService("ReplicatedStorage")
local Plr 				= game.Players.LocalPlayer
local Channels 			= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Open_Shop_UI 		= Channels.Bindable_Events.Open_Shop_UI

-- UI References
local Main_World_F 		= game.Workspace:WaitForChild("Main_World_F")
local Gameplay 			= Main_World_F:WaitForChild("Gameplay")
local Shop_F 			= Gameplay:WaitForChild("Shop")
local OpenColliders 	= Shop_F:WaitForChild("OpenColliders")

function On_Init()
	for i, openType in pairs(OpenColliders:GetChildren()) do
		for _, collider in pairs(openType:GetDescendants()) do
			if collider:IsA("BasePart") == false then
				continue
			end
			
			collider.Transparency = 1
			collider.Touched:Connect(function(part)
				if part.Name == "HumanoidRootPart" and part.Parent == Plr.Character then
					Open_Shop_UI:Fire(openType.Name)
				end
			end)
		end
	end
end
On_Init()]]></ProtectedString>
						<string name="ScriptGuid">{649CA582-E75F-4B2A-A46C-DF2AC8862C01}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Colliders_Open_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX399DAC049D2E497EAC3C0766EDAB1C96">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- Services
local RS  = game:GetService("ReplicatedStorage")
local MPS = game:GetService("MarketplaceService")


-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Display_Data 				= Channels.Bindable_Events.Display_Data
local ShowAvatarAndGetTriggerRE = Channels.UGC_Pack.ShowAvatarAndGetTriggerRE
local ApplyAccessoriesRE 		=  Channels.UGC_Pack.ApplyAccessoriesRE

-- Workspace references
local UGCPacks = RS.Models.UGC.OfferItems.UGCPacks
local Main_World_F = workspace:WaitForChild("Main_World_F")
local Gameplay = Main_World_F:WaitForChild("Gameplay")
local OfferFolder =Gameplay:WaitForChild("Shop"):WaitForChild("Offers_Data")

local WorkSpacePlacement = OfferFolder.UGCAvatar
local avatarLocFol = OfferFolder.UGCAvatarLoc


MPS.PromptBulkPurchaseFinished:Connect(function(player, status, results)
	if status == Enum.MarketplaceBulkPurchasePromptStatus.Completed then
		local idList={}
		for i, itemInfo in ipairs(results) do
			-- Each entry may contain assetId or bundleId, plus a purchaseResult Enum
			local assetId = itemInfo.assetId or "N/A"
			table.insert(idList,assetId)
		end
		local Txt = "✅ Items purchased you can apply on your avatar!"
		Display_Data:Fire(Txt, Color3.fromRGB(35, 244, 68))
		ApplyAccessoriesRE:FireServer(idList)
	end

end)
local Color_Mod = require( game.ReplicatedStorage.Data_Mods_F:WaitForChild("PodiumColors_Mod"))
local TextData = {
	["Guy_Pack1"]={
		
		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="START THE FIGHT!"
		}
	},
	["Guy_Pack2"]={
		
		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="BURN YOUR LIMIT"
		}
	}
	,
	["Guy_Pack3"]={
	
		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="DOMINATE THE ARENA"
		}
	},
	["Guy_Pack4"]={
		
		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="MASTER YOUR POWER"
		}
	},
	["Guy_Pack5"]={

		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="START THE FIGHT!"
		}
	},
	["Guy_Pack6"]={

		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="BURN YOUR LIMIT"
		}
	}
	,
	["Guy_Pack7"]={

		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="DOMINATE THE ARENA"
		}
	},
	["Guy_Pack8"]={

		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="MASTER YOUR POWER"
		}
	}
}

ShowAvatarAndGetTriggerRE.OnClientEvent:Connect(function(PackNames)

	for _,placed in pairs(WorkSpacePlacement:GetChildren()) do
		placed:Destroy()
	end
	task.wait(1)
	local plr = game.Players.LocalPlayer
	local character = plr.Character or plr.CharacterAdded:Wait()

	local count = 1

	for i,PackName in ipairs(PackNames) do

		if (PackName=="")  then
			return
		end

		local ItemName = "Guy_"..PackName

		local Guy = UGCPacks:FindFirstChild(ItemName)
		if Guy then
			local loc = avatarLocFol:FindFirstChild("Loc"..count)
			if loc then
				local clone = Guy:Clone()
				count+=1
				clone.Parent = WorkSpacePlacement

				clone:PivotTo(loc.CFrame)

				local guyTextData=TextData[ItemName]
				Color_Mod.new(
					clone,guyTextData.scheem,guyTextData.Items,guyTextData.text
				)
				local prompt=clone:FindFirstChild("ProximityPrompt")
				prompt.Triggered:Connect(function(player)
					ShowAvatarAndGetTriggerRE:FireServer(PackName)
				end)
			end
		end
	end
end)]]></ProtectedString>
						<string name="ScriptGuid">{26AFB526-DFE7-4C64-930A-9D07CF1A1E18}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Client_UGC_Pack_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1C405446E560433BA3A436A189E2573B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/GameAnalytics_Init_Client.lua
--
--  Description:
--      Initializes the GameAnalytics client SDK for telemetry and event 
--      tracking within the Roblox experience. This script ensures the 
--      GameAnalytics client module is properly required and started on 
--      the player's client.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * GameAnalytics  (manual import or via Rojo)
--          * OR Packages/GameAnalytics (if using Wally)
--      - Roblox Services:
--          * ReplicatedStorage
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Supports both Wally package-based and manual module placement
--      - Ensure GameAnalytics credentials/config are initialized separately
--      - Call `GameAnalytics:initClient()` only once per client session
--
--======================================================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local GameAnalytics = require(ReplicatedStorage.Modules.GameAnalytics)
GameAnalytics:initClient()]]></ProtectedString>
						<string name="ScriptGuid">{7A9D957F-9BE7-4856-89E2-4EBC7AF6574F}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Client_GA_Init.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFAAF7BDAF80244D68FB3FA063B50B8C5">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Fight_SpawnEffects_Client.lua
--
--  Description:
--      Handles spinning animations and combat visual effects for fight cages:
--        * Continuously rotates the "Rot_Part" of each fighter spawn circle
--        * Initializes rotation tweens on all existing cages at startup
--        * Reacts to server events to display punch impact visual and haptic effects
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/Fight_Cages_F
--              - Each cage must contain submodels "Fighter_1" and "Fighter_2"
--                each having a "Rot_Part" for spinning visual effect
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events/Show_Punch_Effects
--          * Channels_F/Server_Client_F/Events/Got_Hit_Effect
--      - Roblox Services:
--          * TweenService (for rotation)
--          * Debris (for cleanup of temporary haptic effects)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Uses infinite Tween rotation with linear easing for spawn circle spin
--      - Punch impact events emit short ParticleEmitter bursts from target head
--      - Haptic feedback triggered on local client using UINotification type
--      - Automatically initializes all fight cages on startup and listens for new ones
--
--======================================================================
local RS = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Show_Punch_Effects 	= Channels.SC_Remote_Events.Show_Punch_Effects
local Got_Hit_Effect 		= Channels.SC_Remote_Events.Got_Hit_Effect

local Main_World_F = game.Workspace:WaitForChild("Main_World_F")
local Objects = Main_World_F:WaitForChild("Gameplay"):WaitForChild("Objects")
local Fight_Cages_F = Objects:WaitForChild("Fight_Cages_F")

local Tween_Rot = TweenInfo.new(5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, math.huge, false, 0)

--==================================================
-- Helper: Setup rotation tween for a given fighter
--==================================================
local function Set_Up_Rot_Effects(FighterModel)
	if not FighterModel then return end
	local Rot_P = FighterModel:FindFirstChild("Rot_Part")
	if not Rot_P then return end

	local tween = TweenService:Create(Rot_P, Tween_Rot, {
		CFrame = Rot_P.CFrame * CFrame.Angles(0, math.rad(179), 0)
	})
	tween:Play()
end

--==================================================
-- Setup rotation effects for an entire fight model
--==================================================
local function Set_Up_Fight_Model_Effects(FightModel)
	if not FightModel then return end
	Set_Up_Rot_Effects(FightModel:FindFirstChild("Fighter_1"))
	Set_Up_Rot_Effects(FightModel:FindFirstChild("Fighter_2"))
end

--==================================================
-- Initialize all cages on startup
--==================================================
local function Init_Fight_Model_Effects()
	task.defer(function()
		for _, FM in ipairs(Fight_Cages_F:GetChildren()) do
			Set_Up_Fight_Model_Effects(FM)
		end
	end)
end

--==================================================
-- Listen for new cages dynamically
--==================================================
Fight_Cages_F.ChildAdded:Connect(function(C)
	if C:IsA("Model") then
		Set_Up_Fight_Model_Effects(C)
	end
end)

--==================================================
-- Show punch visual effects
--==================================================
Show_Punch_Effects.OnClientEvent:Connect(function(Hit_Char)
	local Head = Hit_Char and Hit_Char:FindFirstChild("Head")
	local Hit_VFX = Head and Head:FindFirstChild("Hit_VFX")
	if not Hit_VFX then return end

	for _, PE in ipairs(Hit_VFX:GetChildren()) do
		if PE:IsA("ParticleEmitter") then
			PE:Emit(2)
		end
	end
end)

--==================================================
-- Trigger haptic feedback effect
--==================================================
Got_Hit_Effect.OnClientEvent:Connect(function()
	local hep = Instance.new("HapticEffect")
	hep.Name = "PUNCHED"
	hep.Type = Enum.HapticEffectType.UINotification
	hep.Parent = workspace
	hep:Play()
	Debris:AddItem(hep, 3)
end)

--==================================================
-- Run initialization
--==================================================
Init_Fight_Model_Effects()]]></ProtectedString>
						<string name="ScriptGuid">{6ED2188B-5FB9-40E2-B7CD-2A53908E60DD}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Client_Effects_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX06A537AC3B4A4AB596C3FC7538DCE599">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")

local function ClearAllBlurs()
	for _, child in ipairs(Lighting:GetChildren()) do
		if child:IsA("BlurEffect") then
			child:Destroy()
		end
	end
end

local plr = Players.LocalPlayer

plr.CharacterAdded:Connect(function()
	ClearAllBlurs()
end)]]></ProtectedString>
						<string name="ScriptGuid">{5C5660E9-6E36-4437-B433-7C4D745087F0}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Clean_Blur_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX37F39116A8EA47D4AA423A98E1D3391E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayer/StarterCharacterScripts/Tutorial_Handle.client.lua
--
--  Description:
--      Manages the interactive tutorial flow for new players. 
--      Displays step-by-step guidance with titles, messages, camera
--      transitions, destination trails, and UI panel openings. 
--      Resets tutorial state when completed or closed.
--
--  Author(s): Exclusible, Oriane
--
--  Last Modified: 2025-09-30 by Oriane
--
--  Version: V2025-09
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/Tutorial_Parts_F (contains camera positions & destinations)
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/Display_Tuto_Message
--          * Channels_F/Bindable_F/Events/Toggle_Cutscene
--          * Channels_F/Bindable_F/Events/Set_Trail
--          * Channels_F/Bindable_F/Events/Remove_Trail
--          * Channels_F/Bindable_F/Events/Open_Combos
--          * Channels_F/Bindable_F/Events/Open_Equipment
--          * Channels_F/Bindable_F/Events/Open_Skill_Tree
--          * Channels_F/Bindable_F/Events/Start_Tour
--          * Channels_F/Bindable_F/Events/Next_Tutorial_Step
--          * Channels_F/Bindable_F/Events/Close_Tutorial
--          * Channels_F/Bindable_F/Events/Toggle_Fight_Mode
--          * Channels_F/Bindable_F/Events/Disable_Fight_Mode
--          * Channels_F/Bindable_F/Events/Close_Fight_Result
--          * Channels_F/Bindable_F/Events/Toggle_Commands_Panel
--          * Server_Client_F/Events/End_Fight
--      - Roblox Services:
--          * TweenService
--          * Players
--          * Lighting
--
--  Notes:
--      - Each tutorial step is defined in Full_Tour_Steps with:
--          * title, txt, camera_key, destination_key, open_panel_event
--      - Camera smoothly tweens to tutorial markers
--      - Trails guide players to destinations
--      - Panels open dynamically per step definition
--      - Tutorial can be closed anytime, resetting camera & trail
--
--======================================================================
-- Services
local RS = game:GetService("ReplicatedStorage")

-- Modules
local Data_Mods_F 			= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Tutorial_Mod			= require(Data_Mods_F:WaitForChild("Tutorial_Mod"))
local Tour_Mod 				= require(script.Tour)
local Basic_Fight_Mod 		= require(script.Basic_Fight)

-- Events
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Start_Cage_Tutorial	= Channels.Bindable_Events.Start_Cage_Tutorial
local Start_Tour			= Channels.Bindable_Events.Start_Tour
local Next_Tutorial_Step	= Channels.Bindable_Events.Next_Tutorial_Step
local Close_Tutorial		= Channels.Bindable_Events.Close_Tutorial


local Step_Index = 0
local Steps_Data = nil 
local Step_Handler, Stop_Handler = nil

local function Tutorial_Handle()
	if Steps_Data~=nil and Step_Handler ~= nil then
		Step_Index +=1
		local step = Steps_Data[Step_Index]
		Step_Handler(step)
	end
	
end

local function Tutorial_Close()
	if Stop_Handler ~= nil then
		Stop_Handler()
	end
	
	Step_Index = 0
	Steps_Data = nil
	Step_Handler = nil
end

local function Init_Tutorial(type)
	Step_Index = 0
	if type == "Tour" then
		Steps_Data = Tutorial_Mod.Tour_Steps
		Step_Handler = Tour_Mod.Handle_Step
		Stop_Handler = Tour_Mod.Handle_Stop
		Tutorial_Handle()
	elseif type == "Cage" then
		Steps_Data = Tutorial_Mod.Basic_Fight_Steps
		Step_Handler = Basic_Fight_Mod.Handle_Step
		Stop_Handler = Basic_Fight_Mod.Handle_Stop
		Tutorial_Handle()
	else
		warn("Invalid tutorial type"..type)
	end
end

Start_Tour.Event:Connect(function()
	Init_Tutorial("Tour")
end)

Start_Cage_Tutorial.Event:Connect(function()
	Init_Tutorial("Cage")
end)

Next_Tutorial_Step.Event:Connect(function()
	if Step_Index > 0 then
		if Step_Index < #Steps_Data then
			Tutorial_Handle()
		else
			Tutorial_Close()
			Close_Tutorial:Fire()
		end
	else
		warn("Tutorial not running")
	end
end)

Close_Tutorial.Event:Connect(function()
	Tutorial_Close()
end)

]]></ProtectedString>
						<string name="ScriptGuid">{AF84879B-E4C3-4007-ABB6-A45AE4778E89}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tutorial_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX77B5B60DABD24835B6E5433C28826A47">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tutorial_Handle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXCFBB387BD9574E53B00C2E62092910FB">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F 	= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Tutorial_Mod 			= require(Data_Mods_F:WaitForChild("Tutorial_Mod"))

-- Channels
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local Display_Tuto_Message 	= Channels.Bindable_Events.Display_Tuto_Message
local Display_Tuto_Indicator = Channels.Bindable_Events.Display_Tuto_Indicator

local Toggle_Cutscene		= Channels.Bindable_Events.Toggle_Cutscene

local Set_Trail_E			= Channels.Bindable_Events.Set_Trail
local Remove_Trail_E		= Channels.Bindable_Events.Remove_Trail

local Toggle_Commands_Panel	= Channels.Bindable_Events.Toggle_Commands_Panel
local Toggle_Fight_Mode		= Channels.Bindable_Events.Toggle_Fight_Mode
local Disable_Fight_Mode	= Channels.Bindable_Events.Disable_Fight_Mode
local Close_Fight_Result	= Channels.Bindable_Events.Close_Fight_Result
local End_Fight				= Channels.SC_Remote_Events.End_Fight
local Fight_Set_Up			= Channels.SC_Remote_Events.Fight_Set_Up

local Tour = {}

--[[
	* Every step of the tutorial is describe with a object following this structure
	{
		title= "", -- Title of the Step
		txt="", -- Text of the Step
		camera_key="", -- Key of object for position and orientation of camera (see Workspace.Main_World_F.Gameplay.Objects.Tutorial_Parts_F)
		destination_key="", -- Key of object for position trail destination (see Workspace.Main_World_F.Gameplay.Objects.Tutorial_Parts_F)
		open_panel_event = "" -- Name of the event to open the panel
	}
	
	* Camera, Destination and Panel fields are optional
	* If a step has no camera_key, the camera will not move
	* If a step has no destination_key, the trail will show
	* If a step has no open_panel_event, no panel will open
]]--

-- Local function

local Tour_Running = false
local Tuto_Blur = nil
local Trail_color = Color3.fromRGB(35, 244, 68)

local Tutorial_Parts_F = Tutorial_Mod:GetTutorialPartsFolder()

local function Go_To_Camera(Key)
	local Tween_Cam = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
	Toggle_Cutscene:Fire(true)

	Tuto_Blur = Instance.new("BlurEffect", game.Lighting)
	Tuto_Blur.Name = "Tutorial_Blurr"
	Tuto_Blur.Size = 0

	local Camera_CFrame = Tutorial_Parts_F:FindFirstChild(Key).CFrame

	if(Camera_CFrame == nil)then
		warn("Missing Tutorial camera for key:"..Key)
		return
	end

	Cam.CameraType = Enum.CameraType.Scriptable
	TS:Create(Cam, Tween_Cam, {CFrame = Camera_CFrame}):Play()
end

local function Camera_Back_To_Player()
	if(Tuto_Blur ~= nil) then 
		Tuto_Blur:Destroy()
	end
	Toggle_Cutscene:Fire(false)
	Cam.CameraType = Enum.CameraType.Custom
	Cam.CameraSubject = Hum
end

local function Show_Message(Title, Txt)
	Display_Tuto_Message:Fire(Title, Txt)
end

local function Show_Trail(Destination_Key)
	local Destination_Position = Tutorial_Parts_F:FindFirstChild(Destination_Key).Position
	Set_Trail_E:Fire(Destination_Position, Trail_color)
end

local function Remove_Trail()
	Remove_Trail_E:Fire()
end

local function Apply_Hint_Indicator(Should_Show, Hint_Data)
	--print("Apply_Hint_Indicator: ",Should_Show, Hint_Data)
	Display_Tuto_Indicator:Fire(Should_Show, Hint_Data)
end

local function Open_Panel(Event_Name)
	local event = Channels.Bindable_Events[Event_Name]
	if event then
		event:Fire()
	else
		warn("[Open_Panel] Unknown event: " .. tostring(Event_Name))
	end
end


local function Close_Commands_Panel()
	if Tour_Running then
		Toggle_Commands_Panel:Fire(false)
	end
end

-- Public functions
function Tour.Handle_Step(Step_Data)
	Tour_Running = true
	local step = Step_Data
	
	-- show modal message
	Show_Message(step["title"], step["txt"])

	-- camera tween
	if step["camera_key"] ~= nil and step["camera_key"] ~= "" then 
		Go_To_Camera(step["camera_key"]) 
	else
		Camera_Back_To_Player()
	end

	-- trail to destination
	if step["destination_key"] ~= nil and step["destination_key"] ~= "" then 
		Show_Trail(step["destination_key"]) 
	else
		Remove_Trail() 
	end

	-- open panel
	if step["open_panel_event"] ~= nil and step["open_panel_event"] ~= "" then
		Open_Panel(step["open_panel_event"])
	end

	-- apply hand indicator depending on position and orientation
	if step["hint"] ~=nil and step["hint"] ~= "" then
		Apply_Hint_Indicator(true, step["hint"])
	else
		Apply_Hint_Indicator(false)
	end
end

function Tour.Handle_Stop()
	Tour_Running = false
	Camera_Back_To_Player()
	Remove_Trail()
	Apply_Hint_Indicator(false)
end


-- Connections

Toggle_Fight_Mode.Event:Connect(function()
	if Tour_Running then
		task.wait(0.1)
		local Char = Plr.Character
		local is_fighting = Char:GetAttribute("Is_Fighting")
		Toggle_Commands_Panel:Fire(is_fighting)
	end
end)

Fight_Set_Up.OnClientEvent:Connect(function()
	task.wait(0.05)
	if Tour_Running then
		Toggle_Commands_Panel:Fire(true)
	end
end)

End_Fight.OnClientEvent:Connect(function(Target_Char)
	Close_Commands_Panel()
end)

Disable_Fight_Mode.Event:Connect(function()
	Close_Commands_Panel()
end)

Close_Fight_Result.Event:Connect(function()
	Close_Commands_Panel()
end)


return Tour
]]></ProtectedString>
							<string name="ScriptGuid">{AEC1D472-4AD9-4473-9924-9DC16177B1C7}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Tour.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX87ED1AD9283E48F58B0A9EA4A4F93546">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer

-- Modules
local Data_Mods_F 			= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Cage_Factory 			= require(Data_Mods_F:WaitForChild("Cage_Factory"))
local Fight_Params_Mod 		= require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))

-- Channels
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Next_Tutorial_Step 			= Channels.Bindable_Events.Next_Tutorial_Step
local Start_Tour					= Channels.Bindable_Events.Start_Tour
local Get_Fights_Keys				= Channels.Bindable_Functions.Get_Fights_Keys
local Disable_Fight_Mode  	        = Channels.Bindable_Events.Disable_Fight_Mode
local Display_InCage_Message 		= Channels.Bindable_Events.Display_InCage_Message
local Blinking_UIStroke    			= Channels.Bindable_Events.Display_InCage_UIStroke
local Blinking_ImageStroke  		= Channels.Bindable_Events.Display_InCage_ImageStroke
local Display_InCage_Indicator     	= Channels.Bindable_Events.Display_InCage_Indicator

local Create_Training_Bot			= Channels.CS_Remote_Functions.Create_Training_Bot
local Destroy_Training_Bot			= Channels.CS_Remote_Functions.Destroy_Training_Bot

local Basic_Fight = {}

local Is_Running = false
local Tuto_Cage_Name = ""
local Fight_Keys = {}
local Condition_Conn = nil

-- Local Function
local function Visible_Fight_Inputs(data) 
	for name, value in data do
		if Fight_Keys[name] then
			Fight_Keys[name].Visible = value
		end
	end
end

local function Apply_Stroke(stroke_data)
	local device  = Fight_Keys.Device
	
	for Keybind_Name, Keybind_Data in pairs(stroke_data) do
		if Fight_Keys[Keybind_Name] then
			local Keybind_Frame = Fight_Keys[Keybind_Name]
			-- Display stroke
			if Keybind_Frame:FindFirstChild("Action") then
				Keybind_Frame = Keybind_Frame.Action
			end
			
			local Template = Keybind_Data["Stroke_Template"]
			local Y_Offset = Keybind_Data["Y_Offset"]
			local Hand_Indicator_Data = Keybind_Data["Hand_Indicator"]
			if not Template then
				if Keybind_Data["Mobile"] and device == "Mobile" then
					Template 				=  Keybind_Data["Mobile"]["Stroke_Template"]
					Y_Offset 				= Keybind_Data["Mobile"]["Y_Offset"]
					Hand_Indicator_Data 	= Keybind_Data["Mobile"]["Hand_Indicator"]
				elseif Keybind_Data["Other"] and device ~= "Mobile" then
					Template 				= Keybind_Data["Other"]["Stroke_Template"]
					Y_Offset 				= Keybind_Data["Other"]["Y_Offset"]
					Hand_Indicator_Data 	= Keybind_Data["Other"]["Hand_Indicator"]
				end
			end	
			
			if Template then
				Blinking_ImageStroke:Fire(Keybind_Frame,Template, Y_Offset)
			end
			
			if Hand_Indicator_Data then
				Display_InCage_Indicator:Fire(Keybind_Frame, Hand_Indicator_Data)
			end
		end
	end
end

local function Remove_Stroke()
	Blinking_UIStroke:Fire(nil)
	Blinking_ImageStroke:Fire(nil, nil)
	Display_InCage_Indicator:Fire(nil,nil)
end


local function Reset_Next_Condition()
	if Condition_Conn ~= nil then
		Condition_Conn:Disconnect()
		Condition_Conn = nil
	end
end

local function Apply_Next_Condition(condition_data)
	Reset_Next_Condition()

	if condition_data["CharAttribute"] ~= nil then
		task.delay(condition_data["Delay"], function()
			local Char = Plr.Character
			if Char:GetAttribute(condition_data["CharAttribute"]) == condition_data["ExpectedValue"] then
				Next_Tutorial_Step:Fire()
			else 
				Condition_Conn = Char.AttributeChanged:Connect(function(attributeName)
					if attributeName == condition_data["CharAttribute"] then
						if Char:GetAttribute(condition_data["CharAttribute"]) == condition_data["ExpectedValue"] then
							Condition_Conn:Disconnect()
							Next_Tutorial_Step:Fire()
						end
					end
				end)
			end
		end)
	elseif condition_data == "TakedownAvailable" then 
		
		local Tuto_Cage = Cage_Factory:getCageFolder(Fight_Params_Mod.CageType.TUTORIAL):FindFirstChild(Tuto_Cage_Name)
		local Takedown_Tracker = Tuto_Cage:FindFirstChild("Fight_Data_F"):FindFirstChild("Takedown_Track")
		if Takedown_Tracker.Value then
			Next_Tutorial_Step:Fire()
		else 
			Condition_Conn = Takedown_Tracker.Changed:Connect(function()
				if Takedown_Tracker.Value then
					Condition_Conn:Disconnect()
					Next_Tutorial_Step:Fire()
				end
			end)
		end
	end
end


-- Public functions

function Basic_Fight.Handle_Step(Step_Data)
	if not Is_Running then 
		-- Create Cage and bot
		local res = Create_Training_Bot:InvokeServer(Fight_Params_Mod.CageType.TUTORIAL)
		if not res.success then
			warn(res.err) 
			return
		else
			Tuto_Cage_Name = res.cageName
			Is_Running=true
			Fight_Keys = Get_Fights_Keys:Invoke()
			while not Fight_Keys.Damage_Bar.Visible do
				wait(0.5)
			end
		end	
	end
	
	Display_InCage_Message:Fire(Step_Data)
	
	if Step_Data["visible_keys"] ~= nil then
		Visible_Fight_Inputs(Step_Data["visible_keys"])
	end
	
	if Step_Data["highlight"] ~= nil then
		Apply_Stroke(Step_Data["highlight"])
	else
		Remove_Stroke()
	end

	if Step_Data["next_condition"] ~= nil then
		Apply_Next_Condition(Step_Data["next_condition"])
	else
		Reset_Next_Condition()
	end
end

function Basic_Fight.Handle_Stop()
	if Is_Running and Tuto_Cage_Name ~= "" then
		-- Destroy Cage and bot
		local res = Destroy_Training_Bot:InvokeServer(Tuto_Cage_Name)
	end

	Remove_Stroke()
	Reset_Next_Condition()
	
	Disable_Fight_Mode:Fire()
	Is_Running = false
	
	local End_Conn = nil 
	End_Conn = Plr.AttributeChanged:Connect(function(attributeName)
		if attributeName == "IsTutorialRunning" then
			if Plr:GetAttribute(attributeName) == false then
				Start_Tour:Fire()
				End_Conn:Disconnect()
			end
		end
	end)
end

return Basic_Fight
]]></ProtectedString>
							<string name="ScriptGuid">{2E1A66AA-E341-4849-BE2C-4A374B2EEEAE}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Basic_Fight.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX841360F14EE2454AA0A5EC00FAC69711">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local RS 							= game:GetService("ReplicatedStorage")
local Players						= game:GetService("Players")
local player 						= Players.LocalPlayer

local Server_Context 				= workspace:WaitForChild("Server_Context")

-- Modules
local Data_Mods_F      				= RS:WaitForChild("Data_Mods_F")
local Global_Params_Mod				= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))


-- Events
local Channels						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local League_Portal_Teleport		= Channels.CS_Remote_Events.League_Portal_Teleport
local League_Portal_Init 			= Channels.SC_Remote_Events.League_Portal_Init
local Open_Leagues 					= Channels.Bindable_Events.Open_Leagues
local Display_Data 			    	= Channels.Bindable_Events.Display_Data

-- UI handler (holds tournament state)
local UI_LeagueTournament_Handler 	= require(RS:WaitForChild("Data_Mods_F"):WaitForChild("UI_LeagueTournament_Handler"))

local ThemesFolder 					= workspace.Main_World_F.Themes

-- ==========================================================
-- TO LOBBY PORTAL
-- ==========================================================
-- Bind when a theme is added into workspace.Main_World_F.Themes
ThemesFolder.ChildAdded:Connect(function(themeFolder)
	if themeFolder.Name ~= "Tournament" then
		return
	end

	local lobby = themeFolder:FindFirstChild("LobbyPortal", true)
	if not lobby then return end

	local telepad = lobby:FindFirstChild("Telepad")
	if not telepad then return end

	local prompt = telepad:FindFirstChildOfClass("ProximityPrompt")
	if not prompt then return end

	local connection
	connection = prompt.Triggered:Connect(function(player)
		-- Immediately disconnect to avoid leaks / double fire
		if connection then
			connection:Disconnect()
			connection = nil
		end

		League_Portal_Teleport:FireServer({
			mode = Global_Params_Mod.Server_Mode.STANDARD,
			league = "",
			division = "",
		})
	end)
end)

League_Portal_Init.OnClientEvent:Connect(function(serverType)
	if serverType.mode then
		Server_Context.Mode.Value = serverType.mode
	end
	if serverType.division then
		Server_Context.Division.Value = serverType.division
	end

end)]]></ProtectedString>
						<string name="ScriptGuid">{23235520-EA7D-4AFE-9F50-E159E711739F}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Client_League_Portal_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX498DC88429D4492CB1798B4E91E4A9B7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local Utils	= require(game.ReplicatedStorage.Modules.Utils)
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Global_Params_Mod	= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))
local Players = game:GetService("Players")
local plr = Players.LocalPlayer

local Game_Mode = Utils.GetServerGameMode()
if Game_Mode ~= Global_Params_Mod.Server_Mode.TOURNAMENT then
	return
end

local ATTR = "T_Waiting_Active"


local waitingZone = Utils.SafePath(workspace, {
	"Main_World_F","Themes","Tournament","MatchMaking","WaitingZone"
})

if not waitingZone then return end

local QueueGlow = waitingZone:WaitForChild("QueueGlow")
local QueueNeon = waitingZone:WaitForChild("QueueNeon")


local targets = { QueueGlow, QueueNeon }

-- === colors ===
local OFF_COLOR = Color3.fromRGB(255, 255, 255) -- white
local ON_COLOR  = Color3.fromRGB(0, 255, 0)     -- green


local function applyColor(inst: Instance, color: Color3)
	if inst:IsA("BasePart") then
		inst.Color = color

	elseif inst:IsA("PointLight") or inst:IsA("SpotLight") or inst:IsA("SurfaceLight") then
		inst.Color = color

	elseif inst:IsA("ParticleEmitter") then
		inst.Color = ColorSequence.new(color)


	end
end

local function setWaitingVisual(active: boolean)
	local c = active and ON_COLOR or OFF_COLOR
	for _, inst in ipairs(targets) do
		applyColor(inst, c)
	end
end

local function readActive(): boolean
	return plr:GetAttribute(ATTR) == true
end


local prev = plr:GetAttribute(ATTR)

local function onAttrAdded(initialValue)
	
end

local function onAttrChanged()

	setWaitingVisual(readActive())
end


if prev ~= nil then
	onAttrAdded(prev)
	onAttrChanged()
end

-- Listen for changes (and detect first-time add)
plr.AttributeChanged:Connect(function(name)
	if name ~= ATTR then return end

	local now = plr:GetAttribute(ATTR)

	if prev == nil and now ~= nil then
		onAttrAdded(now)
	end

	onAttrChanged()
	prev = now
end)


if prev == nil then
	setWaitingVisual(false)
end
]]></ProtectedString>
						<string name="ScriptGuid">{9B732091-AD35-49FF-AA5D-7D970FA2D41F}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tournament_WaitingZone_Client_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX8EA7CF6911964212935D9AFA8545386E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">StarterCharacterScripts</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX47EE089F3B9B4F09B287FB4FCC449421">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Trail_Beam_Client.lua
--
--  Description:
--      Handles the visual Beam effect between the player's character 
--      (HumanoidRootPart) and a target position. The beam color and position 
--      are updated through BindableEvents, allowing dynamic control from 
--      other client-side or replicated scripts.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2026-01-13 by Darkzeb
--
--  Version: V2026-01
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/Beam (template Beam object)
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/Set_Trail
--          * Channels_F/Bindable_F/Events/Remove_Trail
--      - Roblox Services:
--          * Players (LocalPlayer)
--          * Lighting (for BlurEffect detection)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Creates and reuses a cloned Beam attached to the player
--      - Generates target attachment parts dynamically for trail visualization
--      - Automatically disables and cleans up when Lighting adds a BlurEffect
--      - Trail color and visibility are controlled via BindableEvents
--      - Beam color defined by received Color3, default orange when created
--
--======================================================================

local RS 			= game:GetService("ReplicatedStorage")
local Utils 		= require(game.ReplicatedStorage.Modules.Utils)
local Plr 			= game.Players.LocalPlayer
local Char 			= Plr.Character or Plr.CharacterAdded:Wait()
local HRP 			= Char:WaitForChild("HumanoidRootPart")

local Channels 		= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Remove_Trail 	= Channels.Bindable_Events.Remove_Trail
local Set_Trail 	= Channels.Bindable_Events.Set_Trail

local GymObjects = Utils.SafePath(workspace, {
	"Main_World_F", "Gameplay", "Objects", "GymObjects"
})

if not GymObjects then
	return
end

local function Create_Attachment(Main_P)
	local A = Main_P:FindFirstChild("Trail_Attachment")
	if(A == nil)then
		A = Instance.new("Attachment", Main_P)
		A.Name = "Trail_Attachment"
	end
	return A
end

local function Create_Beam()

	
	local B = GymObjects:WaitForChild("Beam"):Clone()
	B.Parent = Char
	B.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 170, 0)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 170, 0))
	}
	B.Attachment0 = Create_Attachment(HRP)

	return B
end

local Beam = Create_Beam()

local function Delete_A1_Part()
	if(Beam ~= nil and Beam.Attachment1 ~= nil and Beam.Attachment1.Parent ~= nil)then
		Beam.Attachment1.Parent:Destroy()
		Beam.Attachment1 = nil
	end
end

local function Set_Trail_Handle(Pos, Col)
	if(Beam.Enabled == true)then
		Delete_A1_Part()
		Beam.Enabled = false
	end

	local function Create_A1_Part()
		local P = Instance.new("Part", game.Workspace)
		P.Name = "Trail_Target_Part"
		P.Transparency = 1
		P.Material = Enum.Material.SmoothPlastic
		P.CanCollide = false
		P.CanTouch = false
		P.Anchored = true
		P.Size = Vector3.new(1, 1, 1)
		P.CFrame = CFrame.new(Pos) * CFrame.Angles(0, 0, 0)

		return P
	end
	local A1_Part = Create_A1_Part()

	Beam.Attachment1 = Create_Attachment(A1_Part)
	Beam.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Col),
		ColorSequenceKeypoint.new(1, Col)
	}
	Beam.Enabled = true
end

Set_Trail.Event:Connect(function(Pos, Col)
	if(Beam ~= nil)then
		Set_Trail_Handle(Pos, Col)
	end
end)

Remove_Trail.Event:Connect(function()
	if(Beam ~= nil and Beam.Enabled == true)then
		Delete_A1_Part()
		Beam.Enabled = false
	end
end)

game.Lighting.ChildAdded:Connect(function(C)
	if(C ~= nil and C:IsA("BlurEffect") and Beam ~= nil and Beam.Enabled == true)then
		Beam.Enabled = false
		Delete_A1_Part()
	end
end)]]></ProtectedString>
						<string name="ScriptGuid">{ADB1C477-E35A-4914-BFD9-CF0ACCFA02D1}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Trail_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7050499596654B2C8B54893E03348CA4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Toggle_Reset_Client.lua
--
--  Description:
--      Handles dynamic enabling or disabling of the "Reset Character" button
--      in the Roblox menu, based on BindableEvents from ReplicatedStorage.
--      Ensures SetCore("ResetButtonCallback") succeeds even when CoreGui 
--      initialization is delayed.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/Toggle_Reset
--      - Roblox Services:
--          * StarterGui (SetCore API)
--          * Players (LocalPlayer)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Re-attempts SetCore until success (CoreGui ready)
--      - Default behavior enables ResetButton at startup
--      - Can be toggled externally via BindableEvent:Fire(bool)
--
--======================================================================
local RS 			= game:GetService("ReplicatedStorage")

local StarterGUI	= game:GetService("StarterGui")

local Channels 		= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_Reset 	= Channels.Bindable_Events.Toggle_Reset

local function Toggle_Reset_Call_Back(Enable)
	local function Async()
		local success = pcall(function() 
			StarterGUI:SetCore("ResetButtonCallback", Enable) 
		end)
		
		if(success)then
			return true
		end
		return false
	end
	
	while Async() == false do
		task.wait(1)
	end
end

Toggle_Reset.Event:Connect(function(Is_Enabled)
	task.spawn(Toggle_Reset_Call_Back, Is_Enabled)
end)

task.spawn(Toggle_Reset_Call_Back, true)
]]></ProtectedString>
						<string name="ScriptGuid">{E2CB9C10-2BEB-4F7B-B8AB-9C54B53490BA}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Toggle_Reset_Button.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBB44EEC3B72D4F2DB0158A652EBF0E87">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Arena_Ambience_Client.lua
--
--  Description:
--      Controls the arena ambience based on the player's position. When the 
--      player crosses a defined Z-axis threshold, the arena ambience activates:
--          * Crowd and arena background sound effects play
--          * Main background sound fades out
--          * Random camera flash effects emit from audience seats
--      Ambience stops automatically when the player leaves the region.
--		Once a Players Character passes this Z Value turn it on until the Player Leaves
--		When inside, Play the Crowd Ambient Sound Effect
--		Play the Lighting Spark Effects over all the Seats
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/RF/Player_Can_Access_Arena
--          * Data_Mods_F/Sound_Mod
--      - Workspace:
--          * Main_World_F/Map/Arena_Seating_F (audience seating models)
--      - Script:
--          * Flash_PE (ParticleEmitter template for camera flashes)
--      - Roblox Services:
--          * Debris (for temporary cleanup)
--          * Players (LocalPlayer)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Uses HumanoidRootPart Z-position to determine if player is inside arena
--      - Plays or stops layered audio effects dynamically
--      - Randomly selects audience seats to emit camera flashes
--      - Continues ambience while Is_Within_Arena_Region == true
--      - Reverts to normal background ambience when player exits region
--
--======================================================================
local RS = game:GetService("ReplicatedStorage")
local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Player_Can_Access_Arena 	= Channels.Bindable_Functions.Player_Can_Access_Arena

local Debris = game:GetService("Debris")
local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()

local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Flash_PE = script:WaitForChild("Flash_PE")

local Is_Within_Arena_Region = false
local Pos_Min = 120

local function Effects_Handle()
	SE_Mod.PlaySFX(Plr, "Crowd_SE")	
	SE_Mod.PlayMusic(Plr, "Arena_BG_SE")

	
	local Can_Access_Arena = Player_Can_Access_Arena:Invoke()
	if(Can_Access_Arena)then
		SE_Mod.Play_Voice_Over("Entering_Arena")
	else
		SE_Mod.Play_Voice_Over("Locked_Arena")
	end
	
	local function Flash_Camera_From_Seats()
		--10% of Seating
		--Pick Random Seats, Create Flash Parts, Debris, Emit Flash Particle on them
		local function Get_Arena_Seating()
			local World_F = game.Workspace:FindFirstChild("Main_World_F")
			if(World_F ~= nil and World_F:FindFirstChild("Environment") ~= nil)then
				local Environment = World_F:FindFirstChild("Environment")
				local Seating_F = Environment:FindFirstChild("Arena_Seating_F", true)
				if(Seating_F ~= nil)then
					return Seating_F:GetChildren()
				end
			end
			return {}
		end
		local Seats_Arr = Get_Arena_Seating()
		local Amount = 100 -- Can Change
		
		if(Seats_Arr ~= nil and #Seats_Arr > Amount)then
			local function Play_Camera_Flash()
				local Seat_Index = math.random(1, #Seats_Arr)
				local Seat_M = Seats_Arr[Seat_Index]
				if(Seat_M ~= nil and Seat_M:FindFirstChild("Chair_SeatColor") ~= nil)then
					table.remove(Seats_Arr, Seat_Index)
					
					local Main_P = Seat_M:FindFirstChild("Chair_SeatColor")
					local A = Instance.new("Attachment", Main_P)
					A.Name = "Flash_A"
					A.Visible = false
					A.CFrame = CFrame.new(0, 0.775, 0) * CFrame.Angles(0, 0, 0)
					
					local Emit_Count = math.random(2, 8)
					local PE = Flash_PE:Clone()
					PE.Parent = A
					PE:Emit(Emit_Count)
					
					Debris:AddItem(A, 0.25)
				end
			end
			
			for i = 1, Amount do
				Play_Camera_Flash()
				if(i % 2 == 0)then
					task.wait(0.02)
				end
			end
			
			return
		end
		
		task.wait(1)
	end
	
	
	while Is_Within_Arena_Region do
		Flash_Camera_From_Seats()
	end

	SE_Mod.PlayMusic(Plr, "Standard_Main_BG_SE")
end

function On_Init_Check()
	SE_Mod.PlayMusic(Plr, "Arena_BG_SE")
	
	local function Is_Within_Region()
		local HRP = Char:WaitForChild("HumanoidRootPart")
		if(HRP ~= nil and HRP.Position.Z > Pos_Min)then
			return true
		end
		return false
	end
	
	-- TODO handle the music switch into Theme directly
	if ThemeManager.getCurrentTheme() == "Halloween" then
		SE_Mod.PlayMusic(Plr, "Halloween_Main_BG_SE")
	else
		SE_Mod.PlayMusic(Plr, "Standard_Main_BG_SE")
	end
	
	while task.wait(0.5) do
		local Is_In_Region = Is_Within_Region()
		if(Is_In_Region and Is_Within_Arena_Region == false)then
			Is_Within_Arena_Region = true
			task.spawn(Effects_Handle)
			
		elseif(Is_In_Region == false and Is_Within_Arena_Region == true)then
			Is_Within_Arena_Region = false
		end
	end
end
On_Init_Check()]]></ProtectedString>
						<string name="ScriptGuid">{BBD82549-BD77-4298-BE76-9D66C101851F}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Ranked_Arena_Effects_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB0A9D4AE70004A38B9BA40A8654320EB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/FixCamera_Client.lua
--
--  Description:
--      Temporarily switches the player's camera to Scriptable mode to focus
--      on a specific CFrame received from the server, then restores normal
--      control. Used typically for teleport or cinematic transitions.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/TeleportPads/RemoteEvents/FixCamera
--      - Roblox Services:
--          * Workspace (CurrentCamera)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Waits for all folders to exist before connecting
--      - Briefly offsets camera behind the target CFrame then restores control
--      - Uses Scriptable → Custom transition to avoid abrupt snapping
--
--======================================================================

local Plr = game.Players.LocalPlayer

local folder = workspace:WaitForChild("Main_World_F"):WaitForChild("Gameplay"):WaitForChild("Objects"):WaitForChild("TeleportPads")
local fixCameraEvent = folder:WaitForChild("RemoteEvents"):WaitForChild("FixCamera")

fixCameraEvent.OnClientEvent:Connect(function(cf)
	local camera = workspace.CurrentCamera
	camera.CameraType = Enum.CameraType.Scriptable
	camera.CFrame = CFrame.new(
		cf.Position - cf.LookVector * 10 + Vector3.new(0, 5, 0),
		cf.Position
	)
	task.wait(0.1)
	camera.CameraType = Enum.CameraType.Custom
end)

local function SetCameraSubject(newCharacter,Plr)
	local humanoid = newCharacter:WaitForChild("Humanoid", 5)
	local cam = workspace.CurrentCamera

	if humanoid and cam then
		cam.CameraSubject = humanoid
	end

end

if Plr.Character then
	SetCameraSubject(Plr.Character,Plr)
end

Plr.CharacterAdded:Connect(SetCameraSubject)]]></ProtectedString>
						<string name="ScriptGuid">{C6EECB6B-6DB0-4249-8EE7-A36746FCD89F}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CameraFix.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD4DD10864E6B476D979232606D6ED589">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Cage_Visibility_Client.lua
--
--  Description:
--      Dynamically adjusts the transparency of nearby MMA cage elements 
--      based on the player's position and camera orientation. When the player
--      is fighting inside a cage, obstructing parts become more transparent
--      to improve visibility.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/Fight_Cages_F
--              - Each cage must contain a "MMA_Cage" model with expected parts:
--                CageFence, CornerTrim, PaddingCorner, PaddingFenceDoor,
--                FenceDoor, PaddingFence, FenceFrame
--      - Roblox Services:
--          * RunService (RenderStepped)
--          * Players (LocalPlayer)
--          * Workspace (CurrentCamera, Raycast)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Uses raycasting from camera to determine which cage obstructs view
--      - Cages not currently intersecting camera view remain fully visible
--      - Player attribute "Is_Fighting" determines if logic is active
--      - Transparency transitions are instantaneous (non-tweened)
--
--======================================================================


local RS = game:GetService("RunService")
local Plr = game.Players.LocalPlayer
local Char =  Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Main_World_F = game.Workspace:WaitForChild("Main_World_F")
local Objects = Main_World_F:WaitForChild("Gameplay"):WaitForChild("Objects")
local Fight_Cages_F = Objects:WaitForChild("Fight_Cages_F")
local Cam = game.Workspace.CurrentCamera

local Part_Names = {"CageFence", "CornerTrim", "PaddingCorner", "PaddingFenceDoor", "FenceDoor", 
	"PaddingFence", "FenceFrame"}
local Selected_M = nil

local function Get_Whitelist()
	local Cages_M = {}
	local All_Fight_Cages = Fight_Cages_F:GetChildren()
	for i = 1, #All_Fight_Cages do
		local FCM = All_Fight_Cages[i]
		if(FCM ~= nil and FCM:FindFirstChild("MMA_Cage") ~= nil)then
			table.insert(Cages_M, FCM:FindFirstChild("MMA_Cage"))
		end
	end
	
	return Cages_M
end

local function Get_Cage_M()
	local Dist = (Cam.CFrame.Position - HRP.Position).Magnitude
	local Dir = Cam.CFrame.LookVector
	local Raycast_Parm = RaycastParams.new()
	Raycast_Parm.FilterDescendantsInstances = Get_Whitelist()
	Raycast_Parm.FilterType = Enum.RaycastFilterType.Include

	local Ray_Res = game.Workspace:Raycast(Cam.CFrame.Position, Dir * Dist, Raycast_Parm)
	if(Ray_Res ~= nil and Ray_Res.Instance ~= nil and 
		Ray_Res.Instance:FindFirstAncestorWhichIsA("Model") ~= nil)then
		
		return Ray_Res.Instance:FindFirstAncestorWhichIsA("Model")
	end
	
	return nil
end

local function Toggle_Cage_Parts(M, Is_Visible)
	for i = 1, #Part_Names do
		local PN = Part_Names[i]
		local P = M:FindFirstChild(PN)
		if(P ~= nil)then
			if(Is_Visible)then
				if(PN == "CageFence")then
					P.Transparency = 0.6
				else
					P.Transparency = 0
				end
			else
				P.Transparency = 0.75
			end
		end
	end
end

RS.RenderStepped:Connect(function()
	local Is_Fighting = Char:GetAttribute("Is_Fighting") or false
	if(Is_Fighting)then
		local Cage_M = Get_Cage_M()
		if(Cage_M ~= nil and Cage_M ~= Selected_M)then
			if(Selected_M ~= nil)then
				Toggle_Cage_Parts(Selected_M, true)
			end

			Toggle_Cage_Parts(Cage_M, false)
			Selected_M = Cage_M

		elseif(Cage_M == nil and Selected_M ~= nil)then
			Toggle_Cage_Parts(Selected_M, true)
			Selected_M = nil
		end
	elseif(Selected_M ~= nil)then
		Toggle_Cage_Parts(Selected_M, true)
		Selected_M = nil
	end
end)]]></ProtectedString>
						<string name="ScriptGuid">{AC00B1E7-E795-47AC-AF87-8677E34FED11}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Cage_Camera_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXC272651F014A4AD5B886A22DE4337BAB">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">StarterGui</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXFCF650DFE7DB4E1BB990C90425FFBACB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Shop</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXF9834D4A32C541718579D35ED8CE382E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Offer_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX53C1A3462F14426E8BC4793872C8876F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")

local Plr = game.Players.LocalPlayer
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F 			= RS:WaitForChild("Data_Mods_F")
local StartupUIManager		= require(RS:WaitForChild("Modules"):WaitForChild("StartupUIManager"))
local SE_Mod 				= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local MenuButtons_Mod   	= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Display_Data_E 		= Channels.Bindable_Events.Display_Data
local Toggle_Side_Buttons 	= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Starter_Pack 	= Channels.Bindable_Events.Open_Starter_Pack

local GetActiveOffers		= Channels.Offers.GetActiveOffers
local RequestPurchase 		= Channels.Offers.RequestPurchase
local SendOfferToClient		= Channels.Offers.SendOfferToClient

-- UI References
local Main_Frame = script.Parent:WaitForChild("Main_F")

local HeaderHolder = Main_Frame:WaitForChild("Header")
local Exit_B = HeaderHolder:WaitForChild("Exit_B")


local Body = Main_Frame:WaitForChild("Body")

local Content = Body:WaitForChild("Stroke"):WaitForChild("Content")
local Purchase_B = Content:WaitForChild("Claim_B")

local oldPriceTxt = Content:WaitForChild("OldPrice")
local newPriceTxt = Content:WaitForChild("NewPrice")
local ramingTimeTxt = Content:WaitForChild("TextLabel"):WaitForChild("TimeRaming")
local amountTxt = Content:WaitForChild("Amount")
local DiscountTxt = Content:WaitForChild("Discount")

local GetNowTxt = Purchase_B:WaitForChild("Get"):WaitForChild("txt")
local Title = HeaderHolder:WaitForChild("Title")

local ItemIcon = Content:WaitForChild("TextLabel"):WaitForChild("Icon")

local ItemVPIconFrame = Content:WaitForChild("TextLabel"):WaitForChild("ViewportFrame")
local ItemVPIconWM = ItemVPIconFrame:WaitForChild("WorldModel")


local Debounce = false
local Debounce_E = false
local Debounce_UI = false
local currentOffer -- table with productKey, endsAt, etc.
local countdownConn
local pulseTween
local isSeverCall=false
local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Remove_UI()
	Disconnect_Cons()
	Main_Frame:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	task.wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Starter_Pack_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_Frame.Visible = false
	Main_Frame.Position = UDim2.new(0.5, 0, 0.675, 0)

	Toggle_Side_Buttons:Fire(true, true)

	Debounce = false
	Debounce_E = false
	Debounce_UI = false

	-- notify StartupUIManager to move to the next UI
	StartupUIManager.notifyClose("StarterGui.Shop.Offer_UI")
end

local countdownThread

local function stopCountdown()
	if countdownThread then
		task.cancel(countdownThread)
		countdownThread = nil
	end
end

local function formatDHMS(rem)
	rem = math.max(0, rem)
	local d = math.floor(rem / 86400)
	local h = math.floor((rem % 86400) / 3600)
	local m = math.floor((rem % 3600) / 60)
	local s = rem % 60
	if d > 0 then
		return string.format("LIMITED TIME OFFER %dd %dh %dm", d, h, m)
	elseif h > 0 then
		return string.format("LIMITED TIME OFFER %dh %dm %ds", h, m, s)
	else
		return string.format("LIMITED TIME OFFER %dm %ds", m, s)
	end
end

local function startCountdown()
	stopCountdown()
	local endsAt = currentOffer and currentOffer.EndsAt
	if typeof(endsAt) ~= "number" or endsAt <= 0 then
		ramingTimeTxt.Text = ""
		return
	end

	countdownThread = task.spawn(function()
		while true do
			local now = os.time()
			local rem = math.max(0, math.floor(endsAt - now))

			if rem <= 0 then
				ramingTimeTxt.Text = "Offer ended"
				stopCountdown()
				return
			end

			ramingTimeTxt.Text = formatDHMS(rem)
			if not script.Parent then
				stopCountdown()
				return
			end
			task.wait(1)
		end
	end)
end

local function SetUpViewPortIcon(offer)
	local function SetPosition(ObjectMesh,pos)
		local rotOnly = ObjectMesh.CFrame - ObjectMesh.CFrame.Position
		ObjectMesh.CFrame = CFrame.new(pos) * rotOnly
	end
	local function AnchoredModel(model)
		for _, descendant in ipairs(model:GetDescendants()) do
			if descendant:IsA("BasePart") then
				descendant.Anchored = true
			end
		end
	end

	ItemVPIconWM:ClearAllChildren()
	local oldCam = ItemVPIconFrame:FindFirstChildOfClass("Camera")
	if oldCam then
		oldCam:Destroy()
	end

	local LeftHandPos= Vector3.new(-0.741, 0, -1.972)
	local RightHandPos= Vector3.new(0.061, -0, -1.972)

	local ShortsModelPostion= Vector3.new(0, 0.8, -2)

	local ClothsFolder = game.ReplicatedStorage.Models.Clothing_F
	local ClothItemsParent
	if offer.Kind == "Shorts" then
		ClothItemsParent = ClothsFolder:WaitForChild("Shorts_F")
	else
		ClothItemsParent = ClothsFolder:WaitForChild("Gloves_F")
	end
	local showableItem = ClothItemsParent:FindFirstChild(offer.Title)
	if showableItem then
		local showableItemModel = showableItem:Clone()
		showableItemModel.Parent=ItemVPIconWM

		local camera = Instance.new("Camera")
		ItemVPIconFrame.CurrentCamera = camera
		camera.Parent = ItemVPIconFrame
		camera.CFrame=CFrame.new(0,0,0)

		if offer.Kind == "Shorts" then

			AnchoredModel(showableItemModel)
			showableItemModel:PivotTo(CFrame.new(ShortsModelPostion) *  CFrame.Angles(math.rad(-90), 0, 0) * CFrame.Angles(0, math.rad(180), math.rad(180)))
		else
			
			showableItemModel:FindFirstChild("LeftHand").Anchored=true
			showableItemModel:FindFirstChild("RightHand").Anchored=true
			showableItemModel:MoveTo(Vector3.new(0, 0, 0))
			SetPosition(showableItemModel:FindFirstChild("LeftHand"), LeftHandPos)
			SetPosition(showableItemModel:FindFirstChild("RightHand"), RightHandPos)

		end
	end
end

local function fillUIFromOffer(offer)

	if  offer.Kind=="Gloves" or  offer.Kind=="Shorts" then
		ItemVPIconFrame.Visible=true
		ItemIcon.Visible=false
		SetUpViewPortIcon(offer)
	else
		ItemVPIconFrame.Visible=false
		ItemIcon.Visible=true
		ItemIcon.Image   = offer.ItemIcon or ""
	end

	if offer.Amount == nil or offer.Amount == "" then
		amountTxt.Visible = false
	else
		amountTxt.Visible = true
		amountTxt.Text   = tostring(offer.Amount or 0)
	end

	if offer.Kind=="Shorts" or offer.Kind=="Gloves" then
		newPriceTxt.IngameCU.Visible=false
		oldPriceTxt.IngameCU.Visible=false
		oldPriceTxt.GemCU.Visible=true
		newPriceTxt.GemCU.Visible=true
	else
		oldPriceTxt.GemCU.Visible=false
		newPriceTxt.GemCU.Visible=false
		newPriceTxt.IngameCU.Visible=true
		oldPriceTxt.IngameCU.Visible=true
	end
	Title.Text = string.upper(tostring(offer.Title or "Special Offer"))
	newPriceTxt.Text = tostring(offer.NewPrice or "")
	oldPriceTxt.Text = tostring(offer.OldPrice or "")
	DiscountTxt.Text = tostring(math.floor(((offer.OldPrice - offer.NewPrice) / (offer.OldPrice))*100)or 0).."%"
	startCountdown(offer.EndsAt or 0)
end

SendOfferToClient.OnClientEvent:Connect(function(offer)
	isSeverCall=true
	currentOffer = offer
	fillUIFromOffer(currentOffer)
	Open_Starter_Pack:Fire()
end)

local function GetOfferPanel()
	local offers = GetActiveOffers:InvokeServer()
	if not offers or #offers == 0 then
		return false
	end
	currentOffer = offers[1]
	fillUIFromOffer(currentOffer)
	return true
end

local function ensureUIScale(guiObject)
	local s = guiObject:FindFirstChildOfClass("UIScale")
	if not s then
		s = Instance.new("UIScale")
		s.Scale = 1
		s.Parent = guiObject
	end
	return s
end

local function startPulse()
	if pulseTween and pulseTween.PlaybackState == Enum.PlaybackState.Playing then return end
	local s = ensureUIScale(GetNowTxt)
	local ti = TweenInfo.new(0.7, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, math.huge, true, 0)
	pulseTween = TS:Create(s, ti, { Scale = 1.05 })
	pulseTween:Play()
end

local function stopPulse()
	if pulseTween then
		pulseTween:Cancel()
		pulseTween = nil
	end
	local s = GetNowTxt:FindFirstChildOfClass("UIScale")
	if s then s.Scale = 1 end
end

local function Show_UI()
	if not isSeverCall then
		if not GetOfferPanel() then
			Main_Frame.Visible = false
			return 
		end
	end

	startPulse()
	

	local function Reset_Display()
		Disconnect_Cons()
		Main_Frame.Visible = false
		Main_Frame.Position = UDim2.new(0.5, 0, 0.675, 0)
		local Starter_Pack_Blur = game.Lighting:FindFirstChild("Starter_Pack_Blurr")
		if(Starter_Pack_Blur ~= nil)then
			Starter_Pack_Blur:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()

	local function Purchase_Button()
		table.insert(Cons, Purchase_B.MouseButton1Click:Connect(function()
			if Debounce == true then return end
			Debounce = true
			SE_Mod.PlaySFX(Plr, "Click_SE")
			TS:Create(Purchase_B, Tween_Click, {Size = UDim2.new(0.21, 0, 0.27075, 0)}):Play()
			if currentOffer and (currentOffer.ProductKey ) then
				if os.time() > (currentOffer.EndsAt or 0) then
					Display_Data_E:Fire("? Offer is Expired!", Color3.new(1, 0, 0))
					return
				end
				RequestPurchase:FireServer(currentOffer.Kind, currentOffer.ProductKey)
			else
				Display_Data_E:Fire("? Offer is not available!", Color3.new(1, 0, 0))
			end
			task.wait(0.25)
			Debounce = false
			Open_Starter_Pack:Fire()
		end))
	end
	Purchase_Button()

	MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, function()
		Remove_UI()
		stopPulse()
		stopCountdown()
	end)

	local function Display_UI()
		Main_Frame.Visible = true
		Main_Frame:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Starter_Pack_Blurr"
		Toggle_Side_Buttons:Fire(false, true)
		Debounce_UI = true
		Debounce = false
		Debounce_E = false
	end
	Display_UI()
end

Open_Starter_Pack.Event:Connect(function()
	if(Debounce_UI == false)then
		Show_UI()
	else
		Remove_UI()
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{5B1B34D0-0F5A-4C2B-BFA3-AEE3BF3DA6D6}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Offer_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXBE9202E0BC5644C288E412EDB070688F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CreatorCode</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX0A23D3F7EAF445DEAEA4C952CA882505">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterGui/CreatorCode_UI_Handle.lua
--
--  Description:
--      Handles the Creator Code interface and integrates it with in-game
--      monetization events (MTX). This script manages code validation,
--      UI feedback, and transitions when purchases or redemptions occur.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * CreatorCodes (table of valid creator codes)
--          * Channels_F/Client_Server_F/Events/Set_Creator_Reward_Code
--          * Channels_F/Bindable_F/Events:
--

-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local MarketPlaceService = game:GetService("MarketplaceService")

local CreatorCodes = require(game.ReplicatedStorage.Modules.CreatorCodes)

local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes MTX_Prompted
local MTX_Finished 				= Channels.Bindable_Events.MTX_Finished
local MTX_Prompted 				= Channels.Bindable_Events.MTX_Prompted
local Set_Creator_Reward_Code	= Channels.CS_Remote_Events.Set_Creator_Reward_Code
local isMenuActive=false

MarketPlaceService.PromptProductPurchaseFinished:Connect(function()

	MTX_Finished:Fire()
end)

MarketPlaceService.PromptGamePassPurchaseFinished:Connect(function()
	
	MTX_Finished:Fire()
end)

MarketPlaceService.PromptPurchaseFinished:Connect(function()
	
	MTX_Finished:Fire()
	
end)

-- UI References
local InnerFrame = script.Parent.InnerFrame
local CreatorCodeFrame = InnerFrame.CreatorCodeFrame
local TextBox = CreatorCodeFrame.CodeField.TextBox

local animating = false

CreatorCodeFrame.Submit.Activated:Connect(function()
	if animating == true then
		return
	end
	
	local code = TextBox.Text
	local lastTextColor = TextBox.TextColor3
	
	local codeIndex = nil
	local found = false
	for i, v in pairs(CreatorCodes) do
		if string.lower(v.Name) == string.lower(code) then
			code = v.Name
			codeIndex = i
			
			found = true
			break
		end
	end
	
	TextBox.TextEditable = false
	animating = true
	if found == true then
		Set_Creator_Reward_Code:FireServer(codeIndex)
		
		TextBox.TextColor3 = Color3.fromRGB(0, 255, 0)
		TextBox.Text = "Code ok!"
		
		task.wait(1.5)
		
		TextBox.Text = code
		TextBox.TextColor3 = lastTextColor
	else
		Set_Creator_Reward_Code:FireServer(nil)
		
		TextBox.TextColor3 = Color3.fromRGB(255, 0, 0)
		TextBox.Text = "Code not ok!"

		task.wait(1.5)

		TextBox.Text = ""
		TextBox.TextColor3 = lastTextColor
	end
	animating = false
	TextBox.TextEditable = true
end)


local showMenu = function(t: number?)
	t = t or 1
	TS:Create(
		InnerFrame, 
		TweenInfo.new(t, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0),
		{
			Position = UDim2.new(0.5, 0, 0.5, 0), 
			AnchorPoint = Vector2.new(0.5, 0.5)
		}
	):Play()
	isMenuActive=true
end

local hideMenu = function(t: number?)
	t = t or 0.25
	TS:Create(
		InnerFrame, 
		TweenInfo.new(t, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0),
		{
			Position = UDim2.new(0.5, 0, 1.1, 0), 
			AnchorPoint = Vector2.new(0.5, 0)
		}
	):Play()
	isMenuActive=false
end
hideMenu(0)

MTX_Prompted.Event:Connect(function()
	if isMenuActive then
		return
	end
	showMenu()
	
	local function Trim(s)
		return (s:gsub("^%s*(.-)%s*$", "%1"))
	end

	task.delay(20, function()
		if isMenuActive and Trim(TextBox.Text) == "" then
			MTX_Finished:Fire()
		end
	end)
	
end)
MTX_Finished.Event:Connect(function()
	hideMenu()
end)

local cam = game.Workspace.CurrentCamera
cam:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	local vpSize = cam.ViewportSize
	
	local posMin = CreatorCodeFrame.AbsolutePosition
	local posMax = posMin + Vector2.new(CreatorCodeFrame.Size.X.Scale * InnerFrame.AbsoluteSize.X, 0) + Vector2.new(5, 0)
	
	local delta = 0
	if posMax.X >= vpSize.X then
		delta = posMax.X - vpSize.X
	end
	
	CreatorCodeFrame.Size = UDim2.new(CreatorCodeFrame.Size.X.Scale, -delta, CreatorCodeFrame.Size.Y.Scale, 0)
end)

local plrData = game.Players.LocalPlayer:WaitForChild("Player_Data")
plrData:WaitForChild("Creator Code")

local data = CreatorCodes[plrData["Creator Code"].Value]
if data ~= nil then
	TextBox.Text = data.Name
end]]></ProtectedString>
							<string name="ScriptGuid">{5F69D53C-B316-4A17-9D42-278F27C7C9B0}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CreatorCodeHandle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX368C81AD2C914421B235735FEABB5065">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Shop_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX6CD288A4A51B4391A9456025AF19D2ED">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Cam = game.Workspace.CurrentCamera

local Owned_Passes_V = PD:WaitForChild("Owned Gamepasses")
local Cash_V = PD:WaitForChild("Coins")
local Gems_V = PD:WaitForChild("Gems")

-- Modules
local Data_Mods_F 			= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Monetization_Mod 		= require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Utils 				= require(game.ReplicatedStorage.Modules.Utils)
local Core_Frame_Handlers 	= require(script:WaitForChild("Core_Frame_Handlers"))
local Core_Utils 			= require(script:WaitForChild("Core_Utils"))
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local MenuButtons_Mod		= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local SE_Mod 				= require(Data_Mods_F:WaitForChild("Sound_Mod"))


-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 		= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Shop_UI 				= Channels.Bindable_Events.Open_Shop_UI
local Change_Shop_UIFrames 		= Channels.Bindable_Events.Change_Shop_UIFrames
local Display_Data_E 			= Channels.Bindable_Events.Display_Data

local Crate_Display 			= Channels.CS_Remote_Events.Crate_Display
local Server_Message_Crate 		= Channels.CS_Remote_Events.Server_Message_Crate
local Crate_Action_Request		= Channels.CS_Remote_Functions.Crate_Action_Request

local Show_Crate_Effects		= Channels.SC_Remote_Events.Show_Crate_Effects
local Grant_Free_Crate			= Channels.SC_Remote_Events.Grant_Free_Crate
local Open_Shop					= Channels.SC_Remote_Events.Open_Shop
local Convert_Feedback 			= Channels.SC_Remote_Events.Convert_Feedback
local Shop_Purchase_Rejected	= Channels.SC_Remote_Events.Shop_Purchase_Rejected
local Shop_Item_Purchased		= Channels.SC_Remote_Events.Shop_Item_Purchased


-- UI References
local Main_World_F 				= game.Workspace:WaitForChild("Main_World_F")
local Gameplay 					= Main_World_F:WaitForChild("Gameplay")
local Crates					= Gameplay:WaitForChild("Shop"):WaitForChild("Crates")
local ClothsFolder 				= game.ReplicatedStorage:WaitForChild("Models"):WaitForChild("Clothing_F")

-- Base frames
local Main_F 					= script.Parent.Main_F
local Data_Main_F 				= Main_F:WaitForChild("Data_Main_F")
local Top_Tab_Buttons_F 		= Data_Main_F.Top_Tab_Buttons_F
local Exit_B 					= Main_F.Header.Exit_B
local Player_Cash_Display 		= Data_Main_F:WaitForChild("Player_Currency"):WaitForChild("Cash_B")
local Player_Gems_Display 		= Data_Main_F:WaitForChild("Player_Currency"):WaitForChild("Gems_B")

-- Equipments section
local Equipments_F 				= Data_Main_F:WaitForChild("Equipments_F")
local Shorts_Display_F 			= Equipments_F:WaitForChild("Shorts_Display_F")
local Gloves_Display_F 			= Equipments_F:WaitForChild("Gloves_Display_F")
local Crates_Display_F 			= Equipments_F:WaitForChild("Crates_Display_F")

-- Crates / Items preview
local Crate_Data_F 				= Data_Main_F:WaitForChild("Crate_Data_F")
local Item_Preview_F 			= script.Parent.Item_Preview_F

-- Store section
local Shop_Store_F 				= Data_Main_F:WaitForChild("Shop_Store_F")
local Gamepass_Display_F		= Shop_Store_F:WaitForChild("Gamepass_Display_F")
local Merch_Display_F			= Shop_Store_F:WaitForChild("Merch_Display_F")

-- Currency section
local Currency_F 				= Data_Main_F:WaitForChild("Currency_F")
local Cash_F 					= Currency_F:WaitForChild("Cash_F")
local Gems_F 					= Currency_F:WaitForChild("Gems_F")
local Exchange_F 				= Currency_F:WaitForChild("Exchange_F")

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local tweenInfo = TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)

local Debounce_UI = false
local Debounce_C = false
local Debounce_E = false

local Reset_Button_Colors=nil
local TopTab_Button_Click=nil

local Cons = {}
local Top_Tabs_Cons = {}

local Tabs_Data = {
	{
		Main_Tab = "Equipments_F",
		SubButtons = {
			"Gloves_B",
			"Shorts_B",
			"Crates_B"
		},
		Handlers = {
			Gloves_B = Core_Frame_Handlers.Gloves.Handle,
			Shorts_B = Core_Frame_Handlers.Shorts.Handle,
			Crates_B = Core_Frame_Handlers.Crates.Handle
		},
		MainFrames = {
			Gloves_B = Gloves_Display_F,
			Shorts_B = Shorts_Display_F,
			Crates_B = Crates_Display_F
		}
	},
	{
		Main_Tab = "Currency_F",
		SubButtons = {
			"Exchange_B",
			"Cash_B",
			"Gems_B"
		},
		Handlers = {
			Exchange_B = Core_Frame_Handlers.Exchange.Handle,
			Cash_B = Core_Frame_Handlers.Cash.Handle,
			Gems_B = Core_Frame_Handlers.Gems.Handle
		},
		MainFrames = {
			Exchange_B = Exchange_F,
			Cash_B = Cash_F,
			Gems_B = Gems_F
		}
	},
	{
		Main_Tab = "Shop_Store_F",
		SubButtons = {
			"Merch_B",
			"Passes_B"
		},
		Handlers = {
			Merch_B = Core_Frame_Handlers.Merch.Handle,
			Passes_B = Core_Frame_Handlers.Passes.Handle
		},
		MainFrames = {
			Merch_B = Merch_Display_F,
			Passes_B = Gamepass_Display_F
		}
	},
	{
		Main_Tab = "Skills_F",
		SubButtons = {
			"Emotes_B",
			"SpecialPunch_B"
		},
		Handlers = {} -- tu pourras les brancher plus tard
	}
}

local function TriggerTransactionEffects()
	local function AnimateCurrency(container)
		if not container then return end

		local originalSize = container.Size
		local popSize = originalSize + UDim2.new(0, 6, 0, 6)

		local tweenIn  = TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		local tweenOut = TweenInfo.new(0.15, Enum.EasingStyle.Sine, Enum.EasingDirection.In)

		-- detect internal text if any
		local textObj = container:FindFirstChild("Data_Txt")
			or container:FindFirstChild("TextLabel")
			or container:FindFirstChildWhichIsA("TextLabel")

		-- pop
		TS:Create(container, tweenIn, { Size = popSize }):Play()
		if textObj then
			TS:Create(textObj, tweenIn, { TextColor3 = Color3.fromRGB(255, 230, 120) }):Play()
		end

		task.delay(0.15, function()
			TS:Create(container, tweenOut, { Size = originalSize }):Play()
			if textObj then
				TS:Create(textObj, tweenOut, { TextColor3 = Color3.fromRGB(255, 255, 255) }):Play()
			end
		end)
	end

	SE_Mod.PlaySFX(Plr, "Cash_SE")
	AnimateCurrency(Player_Gems_Display)
	AnimateCurrency(Player_Cash_Display)
end

local function Find_MainTab_By_SubButton(subButton)
	if type(subButton) ~= "string" then return nil end
	for _, tab in ipairs(Tabs_Data) do
		for _, btn in ipairs(tab.SubButtons or {}) do
			if btn == subButton then
				return tab.Main_Tab, tab -- also return the tab table if you need more data
			end
		end
	end
	return nil,nil
end

local function Find_Buttons_By_Tab(TabName)
	if type(TabName) ~= "string" then return nil end
	for _, tab in ipairs(Tabs_Data) do

		if tab.Main_Tab == TabName then
			return tab.SubButtons
		end
	end
	return nil
end

local function Select_Main_Tab(SelectedTab)
	for _, tab in ipairs(Tabs_Data) do
		local tabFrame = Data_Main_F:FindFirstChild(tab.Main_Tab)
		if tabFrame.Name == SelectedTab then
			tabFrame.Visible = true
		else
			tabFrame.Visible = false
		end
	end
end

local function Change_Peers_Fill_Effect(PeersParent,Selected)

	for _,btn in ipairs(PeersParent:GetChildren()) do
		if btn ~=nil and btn:IsA("Frame") or btn:IsA("ImageButton") then
			if btn.Name == Selected then
				btn.BackgroundTransparency=0
			else
				btn.BackgroundTransparency=1
			end
		end
	end
end

local function Load_Merch()	
	local Merch_Data = Monetization_Mod.Get_All_UGC_Data()

	local X, Y = 0.12, 0.25

	for key, values in pairs(Merch_Data) do

		-- Skip if already created
		local existing = Merch_Display_F.Tabs_F:FindFirstChild(values.Name)
		if existing and existing:GetAttribute("Key") == key then
			continue
		end

		local template = Merch_Display_F.Item_Tab_TMP:Clone()
		template.Name = values.Name
		template:SetAttribute("Key", key)

		-- Name
		template.Item_Name_F.Item_Name_Txt.Text = string.upper(values.Name)

		-- Price (cached)
		template.Price_F.Robux_F.Data_Txt.Text = Utils.Format_Number(values.Price)

		-- Thumbnail (cached)
		template.Item_Img.Image = values.Thumbnail

		-- Position
		template.Position = UDim2.new(X, 0, Y, 0)
		template.Parent = Merch_Display_F.Tabs_F
		template.Visible = true

		X += 0.245
		if X > 0.9 then
			X = 0.12
			Y += 0.5
		end
	end
end
Load_Merch()

local function Change_Frames(Key)
	if not Key then
		-- Hide all subframes
		for _, tab in ipairs(Tabs_Data) do
			for _, frame in pairs(tab.MainFrames or {}) do
				if frame and (frame:IsA("Frame") or frame:IsA("ScrollingFrame")) then
					frame.Visible = false
				end
			end
		end
		return
	end

	for _, tab in ipairs(Tabs_Data) do
		for subButton, frame in pairs(tab.MainFrames or {}) do
			if frame and (frame:IsA("Frame") or frame:IsA("ScrollingFrame")) then
				frame.Visible = (subButton == Key .. "_B") -- visible only for selected key
			end
		end

		-- Call the right handler if it exists
		local handler = (tab.Handlers or {})[Key .. "_B"]
		if handler then
			handler({
				Cash_F = Cash_F,
				Gems_F = Gems_F,
				Gamepass_Display_F = Gamepass_Display_F,
				Merch_Display_F = Merch_Display_F,
				Crates_Display_F = Crates_Display_F,
				Crate_Data_F = Crate_Data_F,
				Item_Preview_F = Item_Preview_F,
				Exchange_F = Exchange_F,
				Gloves_Display_F = Gloves_Display_F,
				Shorts_Display_F = Shorts_Display_F,
				Cash_V = Cash_V,
				Gems_V = Gems_V,
				Owned_Passes_V = Owned_Passes_V,
				Main_F = Main_F,
				Exit_B = Exit_B,
				Cons = Cons,
				Player_Cash_Display = Player_Cash_Display,
				Player_Gems_Display = Player_Gems_Display,
				TriggerTransactionEffects = TriggerTransactionEffects
			})
			return
		end
	end

	warn("No handler found for Key:", Key)
end

local function Track_Player_Cash_Gems()
	local function Update_Button_Val(B, Amount_V)
		local Data_Txt = B:FindFirstChildWhichIsA("TextLabel")
		if(Data_Txt ~= nil)then
			Data_Txt.Text = Utils.NumToString(Amount_V) .. ""
			local Tween_Bounce = TweenInfo.new(0.125, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, true, 0)
			Data_Txt.Position = UDim2.new(0.975, 0, 0.5, 0)
			TS:Create(Data_Txt, Tween_Bounce, {Position = UDim2.new(0.975, 0, 0, 0)}):Play()
		end
	end

	table.insert(Cons, Cash_V.Changed:Connect(function()
		Update_Button_Val(Player_Cash_Display, Cash_V.Value)
	end))
	Update_Button_Val(Player_Cash_Display, Cash_V.Value)

	table.insert(Cons, Gems_V.Changed:Connect(function()
		Update_Button_Val(Player_Gems_Display, Gems_V.Value)
	end))
	Update_Button_Val(Player_Gems_Display, Gems_V.Value)
end

local function Remove_UI()
	Core_Utils.Disconnect_Cons(Cons)

	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	task.wait(0.25)

	Change_Frames(nil)
	local Blur = game.Lighting:FindFirstChild("Shop_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Toggle_Side_Buttons:Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Display_UI(Default_Display_Type)	
	local function Reset_Display()
		Core_Utils.Disconnect_Cons(Cons)
		Change_Frames(nil)

		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)
		Item_Preview_F.Visible = false
		Item_Preview_F.Size = UDim2.new(0, 0, 0, 0)

		Cam.FieldOfView = 70
		local Blur = game.Lighting:FindFirstChild("Shop_Blurr")
		if(Blur ~= nil)then
			Blur:Destroy()
		end

	end
	Reset_Display()

	local function Bottom_Bar_Handle()
		local All_B = {}
		for _,Item in ipairs(Data_Main_F:GetDescendants()) do
			if Item:IsA("Frame") and Item.name=="Side_Tabs_F" then
				for _, btn in ipairs(Item:GetChildren()) do
					if btn:IsA("Frame") then
						table.insert(All_B,btn)
					end
				end
			end
		end

		Reset_Button_Colors = function(New_Selected)
			local function Update_Button_Text_Color(B)
				local Data_Txt = B:FindFirstChildWhichIsA("TextLabel")
				if(Data_Txt ~= nil) then
					Data_Txt.TextColor3 = Color3.new(1, 1, 1)					
				end
			end

			for i = 1, #All_B do
				local B = All_B[i]
				if(B ~= nil and B:IsA("Frame"))then
					Update_Button_Text_Color(B)
				end
			end
		end

		local function Button_Handle(B)
			local Data_Type = string.gsub(B.Name, "_B", "")
			local Selected = B:FindFirstChild("Selected")

			table.insert(Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")
					Debounce_E = false
				end
			end))


			table.insert(Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false) then

					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(B, Tween_Click, {Size = UDim2.new(0.13125, 0, 0.5625, 0)}):Play()

					Reset_Button_Colors(B)
					Change_Peers_Fill_Effect(B.Parent,B.Name)
					Change_Frames(Data_Type)

					task.wait(0.25)
					Debounce_C = false
				end
			end))

			--On Init
			if(Data_Type == Default_Display_Type)then
				local tabName, tabData = Find_MainTab_By_SubButton(B.Name)
				local TabBtnName = string.gsub(tabName, "_F", "")
				Select_Main_Tab(tabName)
				Change_Peers_Fill_Effect(Top_Tab_Buttons_F,TabBtnName)
				Change_Peers_Fill_Effect(B.Parent,B.Name)
				Reset_Button_Colors(B)
				Change_Frames(Data_Type)
			end
		end

		for i = 1, #All_B do
			local B = All_B[i]
			if(B ~= nil and B:IsA("Frame"))then
				Button_Handle(B)
			end
		end		
	end
	Bottom_Bar_Handle()

	MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)

	local function Display_Handle()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Shop_Blurr"

		Toggle_Side_Buttons:Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_Handle()

	Track_Player_Cash_Gems()
end

local function Top_Tabs_Bind()
	for _, btn in ipairs(Top_Tab_Buttons_F:GetChildren()) do
		if btn:IsA("ImageButton") then
			local Def_S = UDim2.new(0.22, 0, 1.0, 0)
			local Hover_S = UDim2.new(0.24, 0, 1.1, 0)
			local Click_S = UDim2.new(0.15, 0, 0.75, 0)
			

			-- Hover animation
			table.insert(Top_Tabs_Cons, btn.MouseEnter:Connect(function()
				if Main_F.Visible then
					SE_Mod.PlaySFX(Plr, "Hover_SE")
					btn:TweenSize(Hover_S, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true)
				end
			end))

			table.insert(Top_Tabs_Cons, btn.MouseLeave:Connect(function()
				if Main_F.Visible then
					btn:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true)
				end
			end))
			TopTab_Button_Click = function(btn)

				local ButtonNames = Find_Buttons_By_Tab(btn.Name .. "_F")
				local TabName = btn.Name .. "_F"
				Select_Main_Tab(TabName)

				local firstSubButton = ButtonNames and ButtonNames[1]
				if firstSubButton then
					local key = string.gsub(firstSubButton, "_B", "")
					Change_Frames(key)

					-- Highlight top tab
					Change_Peers_Fill_Effect(Top_Tab_Buttons_F, btn.Name)

					-- Highlight correct subbutton in the sidebar
					local sideTabs = Data_Main_F:FindFirstChild(TabName)
					if sideTabs and sideTabs:FindFirstChild("Side_Tabs_F") then
						Change_Peers_Fill_Effect(sideTabs.Side_Tabs_F, firstSubButton)
					end
				end

			end
			-- Click logic
			table.insert(Top_Tabs_Cons, btn.MouseButton1Click:Connect(function()
				if Main_F.Visible then
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TopTab_Button_Click(btn)
					TS:Create(btn, Tween_Click, { Size = Click_S }):Play()
					task.wait(0.25)
				end
			end))
		end
	end
end
Top_Tabs_Bind()

Convert_Feedback.OnClientEvent:Connect(function(newCash, newGems)
	if typeof(newCash) == "number" then
		Cash_V.Value = newCash
	end
	if typeof(newGems) == "number" then
		Gems_V.Value = newGems
	end
end)

Change_Shop_UIFrames.Event:Connect(function(Button,isUpperTab)
	if isUpperTab then
		TopTab_Button_Click(Button)
	else

		Reset_Button_Colors(Button)
		Change_Peers_Fill_Effect(Button.Parent,Button.Name)
		local Data_Type = string.gsub(Button.Name, "_B", "")
		Change_Frames(Data_Type)
	end
end)

Open_Shop_UI.Event:Connect(function(Type)
	if(Debounce_UI == false)then
		if(Type == nil)then
			Type = "Gloves"
		end
		Display_UI(Type)
	else
		Remove_UI()
	end	
end)

Open_Shop.OnClientEvent:Connect(function(Type)
	if(Debounce_UI == false)then
		if(Type == nil)then
			Type = "Gloves"
		end
		Display_UI(Type)
	end	
end)

Show_Crate_Effects.OnClientEvent:Connect(function(crateModel, gloveModel, color)

	local Crate_Owner = workspace:WaitForChild(crateModel.Name) 

	if (Crate_Owner ~= nil) then

		local VFXParts = crateModel:WaitForChild("VFX_Parts_F")
		local effect_cons = {}
		Core_Utils.Emit_VFX(VFXParts.emit6)
		task.wait(1)
		Core_Utils.Emit_VFX(VFXParts.emit1)
		Core_Utils.Emit_VFX(VFXParts.emit2)
		Core_Utils.Emit_VFX(VFXParts.emit3)
		task.wait(3)
		Core_Utils.Emit_VFX(VFXParts.emit7)
		task.wait(1)

		local glove_Owner
		for _, glove in pairs(Crates:GetChildren()) do
			if (glove and glove:GetAttribute("Owner") == crateModel.Name) then
				glove_Owner = glove
			end
		end

		if (glove_Owner ~= nil) then
			local rootPart = Crate_Owner:WaitForChild("HumanoidRootPart")
			local startCFrame = glove_Owner:GetPivot()
			local endCFrame = startCFrame + Vector3.new(0, 6, 0) 
			endCFrame = endCFrame * CFrame.Angles(0, math.rad(180), 0) 
			local cfValue = Instance.new("CFrameValue")
			cfValue.Value = startCFrame

			table.insert(effect_cons,cfValue:GetPropertyChangedSignal("Value"):Connect(function()
				glove_Owner:PivotTo(cfValue.Value)
			end))

			local tween = TS:Create(cfValue, tweenInfo, { Value = endCFrame })
			--// crate opened
			Core_Utils.Color_VFX(VFXParts.vfxpart3, color)
			Core_Utils.Color_VFX(VFXParts.emit7, color)
			Core_Utils.Toggle_VFX(VFXParts.vfxpart3, true)
			Core_Utils.Toggle_VFX(VFXParts.emit7, true)
			tween:Play()
			task.wait(6)

			local fadeTweens = {}
			for _, part in pairs(glove_Owner:GetDescendants()) do
				if part:IsA("BasePart") then
					local fadeTween = TS:Create(part, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.In), { Transparency = 1 })
					table.insert(fadeTweens, fadeTween)
				end
			end

			startCFrame = glove_Owner:GetPivot()
			endCFrame = rootPart.CFrame * CFrame.new(0, 2, 0)
			endCFrame = endCFrame * CFrame.Angles(0, math.rad(180), 0) 

			cfValue.Value = startCFrame

			local moveTween = TS:Create(cfValue, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.In), { Value = endCFrame })

			moveTween:Play()

			for _, t in pairs(fadeTweens) do
				t:Play()
			end

			task.wait(.8)

			Core_Utils.Toggle_VFX(VFXParts.vfxpart3, false)
			Core_Utils.Toggle_VFX(VFXParts.emit7, false)
			Core_Utils.Disconnect_Cons(effect_cons)
			cfValue:Destroy()
			table.clear(fadeTweens)
		end
	end

end)

Grant_Free_Crate.OnClientEvent:Connect(function(Crate_Data)
	local function Get_Rarity(Item)
		if (Item and Item["Rarity"]) then
			local Color = nil
			local Fraction = nil
			if (Item["Rarity"] == 0.7) then -- bronze
				Color = Color3.fromRGB(255, 203, 112)
				Fraction = "7 in 10"
			elseif (Item["Rarity"] == 0.15) then -- silver
				Color = Color3.fromRGB(217, 217, 217)
				Fraction = "3 in 20"
			elseif (Item["Rarity"] == 0.1) then -- gold
				Color = Color3.fromRGB(255, 170, 0)
				Fraction = "1 in 10"
			elseif (Item["Rarity"] == 0.01) then -- diamond
				Color = Color3.fromRGB(170, 255, 255)
				Fraction = "1 in 100"
			elseif (Item["Rarity"] == 0.0001) then -- platinum
				Color = Color3.fromRGB(255, 170, 255)
				Fraction = "1 in 1,000"
			end
			return Item["Rarity"], Color, Fraction
		end
	end

	local function Open_Crate(Item, Rarity, Color)
		if (ClothsFolder:FindFirstChild(Item["Name"], true)) then
			Crate_Display:FireServer(ClothsFolder:FindFirstChild(Item["Name"], true), Rarity, Color)
		end	

	end

	if(Cash_V.Value >= Crate_Data["PriceCoins"]) then

		local b,c = Crate_Action_Request:InvokeServer(Crate_Data.Name, "Coins")

		if b == true then

			local itemm = nil
			for a, v in pairs(Crate_Data["Items"]) do
				if (v["Name"] == c) then
					itemm = v
					break
				end
			end

			local rarity,color,fraction = Get_Rarity(itemm)

			Open_Crate(itemm, rarity, color)

			local txt = Plr.Name.." unlocked "..c.." ("..fraction.." rarity)"
			Server_Message_Crate:FireServer(txt, color)
			task.wait()
		end

		task.wait(.25)
	end
end)

Shop_Item_Purchased.OnClientEvent:Connect(function(type, key)
	TriggerTransactionEffects()
end)

Shop_Purchase_Rejected.OnClientEvent:Connect(function(reason, message, color)
	if reason == "NOT_ENOUGH_GEMS" then
		Display_Data_E:Fire(message, color) 
		Display_UI("Gems")
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{C8EB74EF-A3B1-40ED-830C-F13A346D8F29}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Shop_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXBDAF2BD7056945D5B5FF474887F02B43">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Shop_Handle</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX6D1A8E9F7E3A4928B4BF05313FB1CE4B">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Core_Utils.lua
-- Shared utility functions used by Client_Shop_Handle and Core_Frame_Handlers

local Core_Utils = {}

-- Disconnect all active connections
function Core_Utils.Disconnect_Cons(C)
	for i = 1, #C do
		if C[i] then
			C[i]:Disconnect()
		end
	end
	table.clear(C)
end

-- Multiply a UDim2 by a scalar (used in animations)
function Core_Utils.MultiUDim2(ud, scalar)
	return UDim2.new(
		ud.X.Scale * scalar,
		ud.X.Offset * scalar,
		ud.Y.Scale * scalar,
		ud.Y.Offset * scalar
	)
end

-- Standard button sizing for UI elements
function Core_Utils.Get_Size_Data(T)
	if string.match(T.Name, "Mega_Huge") then
		local def = UDim2.new(0.45, 0, 0.875, 0)
		local hover = UDim2.new(0.4725, 0, 0.91875, 0)
		local click = UDim2.new(0.3375, 0, 0.65625, 0)
		return def, hover, click
	else
		local def = UDim2.new(0.2, 0, 0.425, 0)
		local hover = UDim2.new(0.23, 0, 0.48875, 0)
		local click = UDim2.new(0.15, 0, 0.31875, 0)
		return def, hover, click
	end
end

-- Colorize all ParticleEmitters in a VFX part
function Core_Utils.Color_VFX(vfx_part, color)
	for _, particle in pairs(vfx_part:GetDescendants()) do
		if particle:IsA("ParticleEmitter") then
			particle.Color = ColorSequence.new(color)
		end
	end
end

-- Toggle all ParticleEmitters in a VFX part
function Core_Utils.Toggle_VFX(vfx_part, toggle)
	for _, particle in pairs(vfx_part:GetDescendants()) do
		if particle:IsA("ParticleEmitter") then
			particle.Enabled = toggle
		end
	end
end

-- Emit all ParticleEmitters once, using their EmitCount attribute
function Core_Utils.Emit_VFX(vfx_part)
	for _, particle in pairs(vfx_part:GetDescendants()) do
		if particle:IsA("ParticleEmitter") then
			particle:Emit(particle:GetAttribute("EmitCount"))
		end
	end
end

return Core_Utils
]]></ProtectedString>
								<string name="ScriptGuid">{506A9550-BDEB-44DC-AB8F-765172C9AC70}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Core_Utils.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX20A323B293FB49A7AA604F04D1878317">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local Core_Frame_Handlers = {}

-- Services
local TS 	= game:GetService("TweenService")
local MPS 	= game:GetService("MarketplaceService")
local RS 	= game:GetService("ReplicatedStorage")
local Plr 	= game.Players.LocalPlayer
local PD 	= Plr:WaitForChild("Player_Data")
local Cam 	= game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = RS:WaitForChild("Data_Mods_F")

local Core_Utils 				= require(script.Parent:WaitForChild("Core_Utils"))
local Utils 					= require(game.ReplicatedStorage.Modules.Utils)
local MenuButtons_Mod			= require(game.ReplicatedStorage.Design.MenuButtons)

local Monetization_Mod 			= require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Crate_Mod 				= require(Data_Mods_F:WaitForChild("Crate_Mod"))
local Offers_Config 			= require(Data_Mods_F:WaitForChild("Offers_Config"))

local Clothing_Mod 				= require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local ClothsFolder 				= game.ReplicatedStorage:WaitForChild("Models"):WaitForChild("Clothing_F")

local SE_Mod 					= require(Data_Mods_F:WaitForChild("Sound_Mod"))

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local Crate_Display 			= Channels.CS_Remote_Events.Crate_Display
local Crate_Action_Request		= Channels.CS_Remote_Functions.Crate_Action_Request
local Server_Message_Crate 		= Channels.CS_Remote_Events.Server_Message_Crate
local Convert_Cash_To_Gems 		= Channels.CS_Remote_Events.Convert_Cash_To_Gems
local Purchase_Cloth_Item 		= Channels.CS_Remote_Events.Purchase_Cloth_Item

local Toggle_Side_Buttons 		= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Shop_UI 				= Channels.Bindable_Events.Open_Shop_UI
local Display_Data_E 			= Channels.Bindable_Events.Display_Data
local MTX_Prompted 				= Channels.Bindable_Events.MTX_Prompted

local Convert_Feedback			= Channels.SC_Remote_Events.Convert_Feedback

-- UI 
local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

local Debounce_C = false
local Debounce_E = false
local Debounce_S = false
local Debounce_UI = false

local Crate_Preview_Cons = {}
local BuyConnections = {}

-- HANDLER FUNCTIONS
local function Cash_Handle(context)
	local Cash_Cons = {}
	local mainFrame = context.Cash_F
	local Tabs = mainFrame:GetChildren()

	local function Update_Tab_Cash_Amounts()
		local function Update_Tab_Amount(T)
			local Dev_Key = T:GetAttribute("Key")

			-- update the boost amount
			local Boost_Amount_Txt = T:FindFirstChild("Boost_Amount_Txt")

			local cash_amount = Monetization_Mod.Get_Cash_Pack_Amount(Dev_Key)
			if(Boost_Amount_Txt ~= nil and Dev_Key ~= nil and cash_amount ~= nil)then
				Boost_Amount_Txt.Text = "+ " .. Utils.NumToString(cash_amount)
			end

			-- update the price =
			local Boost_Price = T:FindFirstChild("Price_F"):FindFirstChild("TextLabel")

			local pack_price = Monetization_Mod.Get_Cash_Pack_Price(Dev_Key)
			if(Boost_Price ~= nil and Dev_Key ~= nil and pack_price ~= nil)then
				Boost_Price.Text = Utils.NumToString(pack_price)
			end
		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil and T:IsA("Frame"))then
				Update_Tab_Amount(T)
			end
		end
	end
	Update_Tab_Cash_Amounts()

	table.insert(Cash_Cons, context.Cash_V.Changed:Connect(function()
		Update_Tab_Cash_Amounts()
	end))

	local function Init_Tab_Click_Handles()
		local function Tab_Handle(T)
			local Selected = T:FindFirstChild("Selected")
			local Key = T:GetAttribute("Key") or "A"
			local Dev_ID = Monetization_Mod.Get_ID_From_Key(false, Key)
			local Def_S, Hover_S, Click_S = Core_Utils.Get_Size_Data(T)
			T.Size = Def_S

			table.insert(Cash_Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false and mainFrame.Visible == true)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")

					T:TweenSize(Hover_S, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					Debounce_E = false
				end
			end))

			table.insert(Cash_Cons, Selected.MouseLeave:Connect(function()
				if(mainFrame.Visible == true)then
					T:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
				end
			end))

			table.insert(Cash_Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false and mainFrame.Visible == true)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(T, Tween_Click, {Size = Click_S}):Play()

					MPS:PromptProductPurchase(Plr, Dev_ID)
					MTX_Prompted:Fire()

					task.wait(0.25)
					Debounce_C = false
				end
			end))	
		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil and T:IsA("Frame"))then
				Tab_Handle(T)
			end
		end

		mainFrame.Visible = true
	end
	Init_Tab_Click_Handles()

	table.insert(Cash_Cons, mainFrame:GetPropertyChangedSignal("Visible"):Connect(function()
		if(context.Cash_F.Visible == false)then
			Core_Utils.Disconnect_Cons(Cash_Cons)
		end
	end))
end

local function Gems_Handle(context)
	local Gems_Cons = {}
	local mainFrame = context.Gems_F
	local Tabs = mainFrame:GetChildren()

	local function Update_Tab_Gems_Amounts()

		local function Update_Tab_Amount(T)
			local Dev_Key = T:GetAttribute("Key")

			-- update the boost amount
			local Boost_Amount_Txt = T:FindFirstChild("Boost_Amount_Txt")

			local gems_amount = Monetization_Mod.Get_Gems_Pack_Amount(Dev_Key)
			if(Boost_Amount_Txt ~= nil and Dev_Key ~= nil and gems_amount ~= nil)then
				Boost_Amount_Txt.Text = "+ " .. Utils.NumToString(gems_amount)
			end

			-- update the price =
			local Boost_Price = T:FindFirstChild("Price_F"):FindFirstChild("TextLabel")

			local pack_price = Monetization_Mod.Get_Gems_Pack_Price(Dev_Key)
			if(Boost_Price ~= nil and Dev_Key ~= nil and pack_price ~= nil)then
				Boost_Price.Text = Utils.NumToString(pack_price)
			end

		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil and T:IsA("Frame"))then
				Update_Tab_Amount(T)
			end
		end
	end
	Update_Tab_Gems_Amounts()

	local function Init_Tab_Click_Handles()
		local function Tab_Handle(T)
			local Selected = T:FindFirstChild("Selected")
			local Key = T:GetAttribute("Key") or "A"
			local Dev_ID = Monetization_Mod.Get_ID_From_Key(false, Key)
			local Def_S, Hover_S, Click_S = Core_Utils.Get_Size_Data(T)
			T.Size = Def_S

			table.insert(Gems_Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false and mainFrame.Visible == true)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")

					T:TweenSize(Hover_S, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					Debounce_E = false
				end
			end))

			table.insert(Gems_Cons, Selected.MouseLeave:Connect(function()
				if(mainFrame.Visible == true)then
					T:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
				end
			end))

			table.insert(Gems_Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false and mainFrame.Visible == true)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(T, Tween_Click, {Size = Click_S}):Play()

					MPS:PromptProductPurchase(Plr, Dev_ID)
					MTX_Prompted:Fire()

					task.wait(0.25)
					Debounce_C = false
				end
			end))	
		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil and T:IsA("Frame"))then
				Tab_Handle(T)
			end
		end

		mainFrame.Visible = true
	end
	Init_Tab_Click_Handles()

	table.insert(Gems_Cons, mainFrame:GetPropertyChangedSignal("Visible"):Connect(function()
		if(mainFrame.Visible == false)then
			Core_Utils.Disconnect_Cons(Gems_Cons)
		end
	end))
end

local function Gamepasses_Handle(context)
	local GP_Cons = {}
	local mainFrame = context.Gamepass_Display_F


	local Tabs = mainFrame:GetChildren()

	local function Update_Owned_Gamepass_Tabs()
		local function Update_Tab(T)
			local GP_Key = T:GetAttribute("GP_Key")
			local Action_F = T:FindFirstChild("Action_F")
			local Owned_F = Action_F:FindFirstChild("Owned_F")
			local Buy_F = Action_F:FindFirstChild("Buy_F")

			if(GP_Key ~= nil and Monetization_Mod.Does_Player_Own_Gamepass_Key(Plr, GP_Key))then
				Owned_F.Visible = true
				Buy_F.Visible = false
			else
				Buy_F.Visible = true
				Owned_F.Visible = false
			end
		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil and T:IsA("Frame"))then
				Update_Tab(T)
			end
		end
	end
	Update_Owned_Gamepass_Tabs()

	table.insert(GP_Cons, MPS.PromptGamePassPurchaseFinished:Connect(function(player, gamePassId, bought)
		if bought then
			local GP_Key = Monetization_Mod.Get_Key_From_ID(true, gamePassId)
			
			if(context.Owned_Passes_V ~= nil)then
				local Keys = string.split(context.Owned_Passes_V.Value, ",")
				Keys[#Keys + 1] = GP_Key
				context.Owned_Passes_V.Value = table.concat(Keys, ",")
			end
			
			Update_Owned_Gamepass_Tabs()
		end
	end))

	local function Init_Tab_Click_Handles()
		local function Tab_Handle(T)
			local Selected = T:FindFirstChild("Selected")
			local Key = T:GetAttribute("GP_Key") or "A"
			local GP_ID = Monetization_Mod.Get_ID_From_Key(true, Key)
			local GP_Data = Monetization_Mod.Get_Data_From_Key(true, Key)
			local Stroke = T:FindFirstChild("UIStroke")
			local Gamepass_Img = T:FindFirstChild("Gamepass_Img")
			local GP_Name_Txt = T:FindFirstChild("Gamepass_Name_Txt")
			local Action_F = T:FindFirstChild("Action_F")
			local Owned_F = Action_F:FindFirstChild("Owned_F")
			local Buy_F = Action_F:FindFirstChild("Buy_F")
			local Buy_B = Buy_F:FindFirstChild("Buy_B")
			local Def_S = UDim2.new(0.975, -5, 0.3875, 0)
			local Click_S = UDim2.new(0.73125, -5, 0.290625, 0)

			T.Size = Def_S
			Gamepass_Img.Image = GP_Data['Icon'] .. ""
			Gamepass_Img.ImageColor3 = Color3.new(1, 1, 1)
			GP_Name_Txt.TextColor3 = Color3.new(1, 1, 1)
			Stroke.Color = Color3.new(1, 1, 1)

			table.insert(GP_Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false and mainFrame.Visible == true)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")

					Gamepass_Img.ImageColor3 = Color3.fromRGB(150, 150, 150)
					GP_Name_Txt.TextColor3 = Color3.fromRGB(150, 150, 150)
					Stroke.Color = Color3.fromRGB(35, 244, 68)

					Debounce_E = false
				end
			end))

			table.insert(GP_Cons, Selected.MouseLeave:Connect(function()
				if(mainFrame.Visible == true)then
					Gamepass_Img.ImageColor3 = Color3.new(1, 1, 1)
					GP_Name_Txt.TextColor3 = Color3.new(1, 1, 1)
					Stroke.Color = Color3.new(1, 1, 1)
				end
			end))

			table.insert(GP_Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false and mainFrame.Visible == true)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(T, Tween_Click, {Size = Click_S}):Play()

					if(Owned_F.Visible == false)then
						MPS:PromptGamePassPurchase(Plr, GP_ID)
						
						
						--MTX_Prompted:Fire()
					else
						local Txt = "✔️ You already own this Gamepass!"
						Display_Data_E:Fire(Txt, Color3.fromRGB(35, 244, 68))
					end

					task.wait(0.25)
					Debounce_C = false
				end
			end))	
		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil and T:IsA("Frame"))then
				Tab_Handle(T)
			end
		end

		mainFrame.CanvasPosition = Vector2.new(0, 0)
		mainFrame.Visible = true
	end
	Init_Tab_Click_Handles()

	table.insert(GP_Cons, mainFrame:GetPropertyChangedSignal("Visible"):Connect(function()
		if(mainFrame.Visible == false)then
			Core_Utils.Disconnect_Cons(GP_Cons)
		end
	end))

end

local function Merch_Handle(context)
	local Merch_Cons = {}
	local mainFrame = context.Merch_Display_F
	local Tabs = mainFrame.Tabs_F:GetChildren()

	local function styleMerchCard(card)
		-- Gradient background (sleek dark)
		local gradient = Instance.new("UIGradient")
		gradient.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 25)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(55, 55, 55))
		}
		gradient.Rotation = 90
		gradient.Parent = card

		-- Subtle stroke (neutral gray tone)
		local glow = Instance.new("UIStroke")
		glow.Thickness = 1.5
		glow.Transparency = 0.5
		glow.Color = Color3.fromRGB(180, 180, 180)
		glow.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		glow.Parent = card

	end

	local function enhanceViewport(vf)
		if not vf then return end

		-- Light tuning
		vf.LightColor = Color3.fromRGB(255, 245, 230)
		vf.Ambient = Color3.fromRGB(200, 200, 200)

		-- Gentle color correction for better contrast
		local cam = vf:FindFirstChildOfClass("Camera")
		if cam then
			local cc = Instance.new("ColorCorrectionEffect")
			cc.Brightness = 0.15
			cc.Contrast = 0.25
			cc.Saturation = 0.15
			cc.Parent = cam
		end
	end

	local function Init_Tab_Click_Handles()
		local function Tab_Handle(T)
			local Selected = T:FindFirstChild("Selected")
			local Key = T:GetAttribute("Key") or "A"
			local Dev_ID = Monetization_Mod.Get_ID_From_Key_UGC(Key)
			local Def_S, Hover_S, Click_S = Core_Utils.Get_Size_Data(T)
			T.Size = Def_S

			-- Apply visual style
			styleMerchCard(T)
			enhanceViewport(T:FindFirstChild("VF"))

			-- Hover animation
			table.insert(Merch_Cons, Selected.MouseEnter:Connect(function()
				if not mainFrame.Visible then return end
				if not Debounce_E then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")

					T:TweenSize(Hover_S, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.15, true)
					local stroke = T:FindFirstChildOfClass("UIStroke")
					if stroke then stroke.Transparency = 0 end
					task.wait(0.15)
					Debounce_E = false
				end
			end))

			table.insert(Merch_Cons, Selected.MouseLeave:Connect(function()
				if not mainFrame.Visible then return end
				T:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.15, true)
				local stroke = T:FindFirstChildOfClass("UIStroke")
				if stroke then stroke.Transparency = 0.5 end
			end))

			-- Purchase click
			table.insert(Merch_Cons, Selected.MouseButton1Click:Connect(function()
				if not mainFrame.Visible or Debounce_C then return end
				Debounce_C = true
				SE_Mod.PlaySFX(Plr, "Click_SE")
				TS:Create(T, Tween_Click, {Size = Click_S}):Play()
				MPS:PromptPurchase(Plr, Dev_ID)
				task.wait(0.25)
				Debounce_C = false
			end))
		end

		for _, T in ipairs(Tabs) do
			if T:IsA("Frame") then
				Tab_Handle(T)
			end
		end

		mainFrame.Visible = true
	end

	Init_Tab_Click_Handles()

	table.insert(Merch_Cons, mainFrame:GetPropertyChangedSignal("Visible"):Connect(function()
		if not mainFrame.Visible then
			Core_Utils.Disconnect_Cons(Merch_Cons)
		end
	end))

end

local function Crates_Handle(context)
	local Crate_Cons = {}
	local Crates_Display_F = context.Crates_Display_F
	local Crate_Data_F = context.Crate_Data_F
	local Item_Preview_F = context.Item_Preview_F

	local Tabs = Crates_Display_F:GetChildren()
	Crate_Data_F.Visible = false
	Item_Preview_F.Visible = false

	Crates_Display_F.Tabs_F:ClearAllChildren()
	Crates_Display_F.Visible = true

	--// setup the crate frames displaying the items in that crate frame, rarity, etc...
	local Crates = Crate_Mod.Get_Crate_Data_Arr()

	local x,y = 0.165,0.275

	local function Get_Rarity(Item)
		if (Item and Item["Rarity"]) then
			local Color = nil
			local Fraction = nil
			if (Item["Rarity"] == 0.7) then -- bronze
				Color = Color3.fromRGB(255, 203, 112)
				Fraction = "70% chance"
			elseif (Item["Rarity"] == 0.15) then -- silver
				Color = Color3.fromRGB(217, 217, 217)
				Fraction = "15% chance"
			elseif (Item["Rarity"] == 0.1) then -- gold
				Color = Color3.fromRGB(255, 170, 0)
				Fraction = "10% chance"
			elseif (Item["Rarity"] == 0.01) then -- diamond
				Color = Color3.fromRGB(170, 255, 255)
				Fraction = "1% chance"
			elseif (Item["Rarity"] == 0.0001) then -- platinum
				Color = Color3.fromRGB(255, 170, 255)
				Fraction = "0.01% chance"
			end
			return Item["Rarity"], Color, Fraction
		end
	end

	local function Open_Crate(Item, Rarity, Color)
	
		if (ClothsFolder:FindFirstChild(Item["Name"], true)) then

			--// UI Stuff
			Item_Preview_F:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)

			task.wait(0.25)

			Core_Utils.Disconnect_Cons(Crate_Cons)
			Crate_Data_F.Visible = false
			context.Exit_B.Visible = true
			Crates_Display_F.Visible = false
			Item_Preview_F.Visible = false

			Core_Utils.Disconnect_Cons(context.Cons)
			context.Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
			TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

			task.wait(0.25)

			local Blur = game.Lighting:FindFirstChild("Shop_Blurr")
			if(Blur ~= nil)then
				Blur:Destroy()
			end
			Cam.FieldOfView = 70

			context.Main_F.Visible = false
			context.Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

			Toggle_Side_Buttons:Fire(true, true)

			Debounce_UI = false
			Debounce_C = false
			Debounce_E = false
			Debounce_S = false

			--// Crate Stuff
			if (ClothsFolder:FindFirstChild(Item["Name"], true)) then
				Crate_Display:FireServer(ClothsFolder:FindFirstChild(Item["Name"], true), Rarity, Color)
			end
		end	
	end

	local function Tab_Handle(T, crate_values)
		local Selected = T:FindFirstChild("Selected")
		local Def_S = UDim2.new(0.3, 0,0.5, 0)
		T.Size = Def_S

		table.insert(Crate_Cons, Selected.MouseEnter:Connect(function()
			if(Debounce_E == false and Crates_Display_F.Visible == true)then
				Debounce_E = true
				SE_Mod.PlaySFX(Plr, "Hover_SE")

				T:TweenSize(Core_Utils.MultiUDim2(T.Size, 1.03), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
				Debounce_E = false
			end
		end))

		table.insert(Crate_Cons, Selected.MouseLeave:Connect(function()
			if(Crates_Display_F.Visible == true)then
				T:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
			end
		end))

		table.insert(Crate_Cons, Selected.MouseButton1Click:Connect(function()
			if(Debounce_C == false and Crates_Display_F.Visible == true)then
				Debounce_C = true
				SE_Mod.PlaySFX(Plr, "Click_SE")
				TS:Create(T, Tween_Click, {Size = Core_Utils.MultiUDim2(T.Size, 0.85)}):Play()

				local t_X,t_Y = 0.125,0.25

				Crate_Data_F.Items_F.Tabs_F:ClearAllChildren()

				task.wait()

				Crate_Data_F.Title_Text.Text = crate_values["Name"]:upper()
				Crate_Data_F.Bottom_Bar_F.Gems_B.Data_Txt.Text = Utils.Format_Number(crate_values["PriceGems"])

				Core_Utils.Disconnect_Cons(Crate_Preview_Cons)	
				Crate_Preview_Cons = {} 

				table.insert(Crate_Preview_Cons, Crate_Data_F.Bottom_Bar_F.Gems_B.Selected.MouseButton1Click:Connect(function()
					task.wait()
					if Debounce_S then return end
					Debounce_S = true

					local playerGems = context.Gems_V.Value
					local price = crate_values["PriceGems"]

					if playerGems >= price then
						local success, won_item = Crate_Action_Request:InvokeServer(crate_values.Name, "Gems")

						if success and won_item then
							local selectedItem = nil
							for _, v in pairs(crate_values["Items"]) do
								if v["Name"] == won_item then
									selectedItem = v
									break
								end
							end

							if selectedItem then
								local rarity, color, fraction = Get_Rarity(selectedItem)
								Open_Crate(selectedItem, rarity, color)
								context.TriggerTransactionEffects()
								
								task.delay(10, function()
									local msg_for_player = "🎁 You unlocked " .. won_item .. " (" .. fraction .. " rarity)"
									Display_Data_E:Fire(msg_for_player, Color3.fromRGB(255, 215, 0))
								end)


								local msg_for_chat = Plr.Name .. " unlocked " .. won_item .. " (" .. fraction .. " rarity)"
								Server_Message_Crate:FireServer(msg_for_chat, color)
							end
						end
					else
						Display_Data_E:Fire("❌ You don't have enough Gems!", Color3.fromRGB(225, 0, 0))
						Open_Shop_UI:Fire("Gems")
						-- Open_InsufficientFunds_UI:Fire(true, price - playerGems)
					end

					task.wait(0.25)
					Debounce_S = false
				end))

				--// Crate Data Stuff
				local allRarities = {}
				local tempKeys = {}

				for i,v in pairs(crate_values["Items"]) do
					allRarities[i] = v["Rarity"]
				end

				for key, _ in pairs(allRarities) do
					table.insert(tempKeys, key)
				end

				table.sort(tempKeys, function(a, b)
					return allRarities[a] < allRarities[b]
				end)


				for _, item in ipairs(tempKeys) do 
					if (Clothing_Mod.Get_Gloves_Data(crate_values["Items"][item]["Name"]) or Clothing_Mod.Get_Shorts_Data(crate_values["Items"][item]["Name"]) ) then
						--// Load Template
						local Rarity, Color, Fraction = Get_Rarity(crate_values["Items"][item])
						local tmp_Item = Crate_Data_F.Items_F.Item_Tab_TMP:Clone()
						tmp_Item.Name = crate_values["Items"][item]["Name"]
						tmp_Item.Item_Name_F.Item_Name_Txt.Text = string.upper(crate_values["Items"][item]["Name"])
						tmp_Item.Position = UDim2.new(t_X, 0, t_Y, 0)
						tmp_Item.BackgroundColor3 = Color
						tmp_Item.UIStroke.Color = Color
						tmp_Item.Parent = Crate_Data_F.Items_F.Tabs_F
						tmp_Item.Visible = true

						--// VF
						local display = ClothsFolder:FindFirstChild(crate_values["Items"][item]["Name"], true):Clone()
						local Viewport_Camera = Instance.new("Camera")
						if (display:FindFirstChild("LeftHand")) then
							for _, hand in pairs(display:GetChildren()) do
								if (hand.Name == "LeftHand") then
									if (display:FindFirstChild("LeftHandM") == nil) then
										local model = Instance.new("Model")
										model.Name = "LeftHandM"
										model.Parent = display
										hand.Parent = model
									elseif (display:FindFirstChild("LeftHandM") ~= nil) then
										hand.Parent = display:FindFirstChild("LeftHandM")
									end
								elseif (hand.Name == "RightHand") then
									if (display:FindFirstChild("RightHandM") == nil) then
										local model = Instance.new("Model")
										model.Name = "RightHandM"
										model.Parent = display
										hand.Parent = model
									elseif (display:FindFirstChild("RightHandM") ~= nil) then
										hand.Parent = display:FindFirstChild("RightHandM")
									end
								end
							end
							display:WaitForChild("RightHandM"):PivotTo(CFrame.new(0.245, 0, -0) * CFrame.Angles(0, math.rad(90), 0))
							display:WaitForChild("LeftHandM"):PivotTo(CFrame.new(-0.645, 0, 0) * CFrame.Angles(0, math.rad(90), 0))
							display:PivotTo(CFrame.new(0,0,0))
							tmp_Item.VF.CurrentCamera = Viewport_Camera
							display.Parent = tmp_Item.VF.WM
							tmp_Item.VF.WM:PivotTo(CFrame.new(0,0,0)* CFrame.Angles(0,math.rad(90),0)) -- * CFrame.Angles(math.rad(180),0,0)
							Viewport_Camera.Parent = tmp_Item.VF
							Viewport_Camera.CFrame = CFrame.new(0, -0.15, 1.3)
						elseif (display:FindFirstChild("LowerTorso")) then
							display:PivotTo(CFrame.new(0,0,0))
							tmp_Item.VF.CurrentCamera = Viewport_Camera
							display.Parent = tmp_Item.VF.WM
							tmp_Item.VF.WM:PivotTo(CFrame.new(0,0,0)) 
							Viewport_Camera.Parent = tmp_Item.VF
							Viewport_Camera.CFrame = CFrame.new(0, 0, 2)
						end

						t_X += 0.25

						if t_X >= 0.9 then
							t_X = 0.125
							t_Y += 0.525
						end

						table.insert(Crate_Preview_Cons, tmp_Item.Selected.MouseButton1Click:Connect(function()
							--// setup the item preview thing
							if (Item_Preview_F.Main_Data_F.VF:FindFirstChildOfClass("Camera")) then
								Item_Preview_F.Main_Data_F.VF.WM:ClearAllChildren()
								Item_Preview_F.Main_Data_F.VF:FindFirstChildOfClass("Camera"):Destroy()	
							end

							MenuButtons_Mod.Setup_Exit_X_Button(Crate_Preview_Cons, Item_Preview_F.Main_Data_F.Exit_B, function()
								Item_Preview_F:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true)
								Item_Preview_F.Visible = false
							end)

							local display2 = ClothsFolder:FindFirstChild(crate_values["Items"][item]["Name"], true):Clone()
							local Viewport_Camera2 = Instance.new("Camera")
							if (display2:FindFirstChild("LeftHand")) then

								-- Wrap parts into LeftHandM / RightHandM models
								for _, part in ipairs(display2:GetChildren()) do
									if part:IsA("BasePart") and (part.Name == "LeftHand" or part.Name == "RightHand") then
										local groupName = part.Name .. "M"
										local group = display2:FindFirstChild(groupName) or Instance.new("Model")
										group.Name = groupName
										group.Parent = display2
										part.Parent = group
										part.Anchored = true
									end
								end

								local left  = display2:FindFirstChild("LeftHandM")
								local right = display2:FindFirstChild("RightHandM")

								if left and right then
									-- reset the model pivot
									display2.Parent = Item_Preview_F.Main_Data_F.VF.WM
									display2:PivotTo(CFrame.new(0,0,0))
									Item_Preview_F.Main_Data_F.VF.WM:PivotTo(CFrame.new(0,0,0)) 
									Item_Preview_F.Main_Data_F.VF.CurrentCamera = Viewport_Camera2
									Viewport_Camera2.Parent = Item_Preview_F.Main_Data_F.VF
									Viewport_Camera2.CFrame = CFrame.new(0, -0.15, 1.6)

									-- reduce spacing (crates preview space was too large)
									local OFFSET = 0.5

									-- initial pose: thumbs inward (same as Equipment and Shop)
									left:PivotTo(CFrame.new(-OFFSET, 0, 0) * CFrame.Angles(0, math.rad(90), 0))
									right:PivotTo(CFrame.new( OFFSET, 0, 0) * CFrame.Angles(0, math.rad(-90), 0))

									-- apply unified hover rotation
									Utils.SetupRotation(left, 3)
									Utils.SetupRotation(right, -3)
								end

							elseif (display2:FindFirstChild("LowerTorso")) then
								local torso = display2:FindFirstChild("LowerTorso")
								if torso then
									display2.PrimaryPart = torso
									display2.PrimaryPart.PivotOffset = CFrame.new(0, 0, 0)
								else
									warn("[Shop Preview] LowerTorso not found for:", display2.Name)
								end
								display2:PivotTo(CFrame.new(0,0,0))
								Item_Preview_F.Main_Data_F.VF.CurrentCamera = Viewport_Camera2
								display2.Parent = Item_Preview_F.Main_Data_F.VF.WM
								Item_Preview_F.Main_Data_F.VF.WM:PivotTo(CFrame.new(0,0,0)) 
								Viewport_Camera2.Parent = Item_Preview_F.Main_Data_F.VF
								Viewport_Camera2.CFrame = CFrame.new(0, -0.5, 2)
							end

							Item_Preview_F.Main_Data_F.Item_Name_Txt.Text = crate_values["Items"][item]["Name"]
							Item_Preview_F.Main_Data_F.Rare_F.Visible = true
							Item_Preview_F.Main_Data_F.Rare_F.Rare_Data_Txt.Text = Fraction
							Item_Preview_F.Main_Data_F.Rare_F.Rare_Data_Txt.TextColor3 = Color

							local buyButton = Item_Preview_F.Main_Data_F.Buy_B
							buyButton.Visible = false

							Item_Preview_F.Visible = true		

							Item_Preview_F:TweenSize(UDim2.new(1, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
						end))
					end
				end


				Crate_Data_F.Visible = true
				context.Exit_B.Visible = false
				Crates_Display_F.Visible = false
				Item_Preview_F.Visible = false

				MenuButtons_Mod.Setup_Exit_X_Button(Crate_Preview_Cons, Crate_Data_F.Exit_B, function()
					Item_Preview_F.Visible = false
					Crate_Data_F.Visible = false
					Crates_Display_F.Visible = true
					context.Exit_B.Visible = true
				end)

				task.wait(0.25)
				Debounce_C = false
			end
		end))
	end

	for i = 1, #Crates do
		--// setup crate
		local Crates_Info = Crates[i]
		if(Crates_Display_F.Crate_Tab_TMP:FindFirstChild(Crates_Info["Name"]) == nil) then

			--// Crate Tabs
			local tmp = Crates_Display_F.Crate_Tab_TMP:Clone()
			tmp.Name = Crates_Info["Name"]
			tmp.Crate_Name_F.Crate_Name_Txt.Text = string.upper(Crates_Info["Name"])
			tmp.Price_F.Gems_F.Data_Txt.Text = Utils.Format_Number(Crates_Info["PriceGems"])			
			tmp.BackgroundColor3 = Crates_Info["Color_BG"]
			tmp.UIStroke.Color = Crates_Info["Color_BG"]
			tmp.Position = UDim2.new(x,0,y,0)
			tmp.Parent = Crates_Display_F.Tabs_F
			tmp.Visible = true
			x += 0.315
			if x >= 0.8 then
				x = 0.165
				y += 0.535
			end


			local Shorts={}
			local Gloves={}
			local ShortCount=0
			local GloveCount=0
			local function SplitShortAndGloves(dict)
				for k,item in pairs(dict) do
					local itemData =	ClothsFolder:FindFirstChild(item.Name, true)
					if itemData.Parent.Name=="Gloves_F" then
						GloveCount+=1
						table.insert(Gloves, item)
					else
						ShortCount+=1
						table.insert(Shorts, item)
					end
				end
			end
			SplitShortAndGloves(Crates_Info.Items)

			local function getLastN(list, n)
				local total = #list
				local result = {}
				local startIndex = math.max(1, total - n + 1)

				for i = startIndex, total do
					table.insert(result, list[i])
				end

				return result
			end
			local function ReplaceGloves(gloveItems)
				local glovesParent = tmp.VF_Glove.WM.Model

				for slotIndex, itemData in ipairs(gloveItems) do
					local gloveTempModel = glovesParent:FindFirstChild(slotIndex .. "_Glove")
					if not gloveTempModel then
						warn("Glove placeholder not found for slot:", slotIndex)
						continue
					end

					local template = ClothsFolder:FindFirstChild(itemData.Name, true)
					if not template then
						warn("Glove template not found for item:", itemData.Name)
						continue
					end

					local newGloveModel = template:Clone()

					local leftHand = newGloveModel:FindFirstChild("LeftHand")
					if leftHand then
						leftHand:Destroy()
					end

					local pivot = gloveTempModel:GetPivot()
					newGloveModel.Parent = glovesParent
					newGloveModel:PivotTo(pivot)

					if newGloveModel:FindFirstChild("RightHand") and gloveTempModel:FindFirstChild("RightHand") then
						newGloveModel.RightHand.CFrame = gloveTempModel.RightHand.CFrame
					end

					gloveTempModel:Destroy()
				end

				tmp.VF_Glove.Visible = true
			end
			local function ReplaceShorts(shortItems)
				local shortsParent = tmp.VF_Short.WM.Model

				for slotIndex, itemData in ipairs(shortItems) do
					local shortTempModel = shortsParent:FindFirstChild(slotIndex .. "_Short")
					if not shortTempModel then
						warn("Short placeholder not found for slot:", slotIndex)
						continue
					end

					local template = ClothsFolder:FindFirstChild(itemData.Name, true)
					if not template then
						warn("Short template not found for item:", itemData.Name)
						continue
					end

					local newShortModel = template:Clone()
					newShortModel.PrimaryPart=nil
					local pivot = shortTempModel:GetPivot()
					newShortModel.Parent = shortsParent
					newShortModel:PivotTo(pivot)
					newShortModel.LeftUpperLeg.CFrame = shortTempModel.LeftUpperLeg.CFrame
					newShortModel.LowerTorso.CFrame = shortTempModel.LowerTorso.CFrame
					newShortModel.RightUpperLeg.CFrame = shortTempModel.RightUpperLeg.CFrame

					shortTempModel:Destroy()
				end

				tmp.VF_Short.Visible = true
			end
			local isGloves = GloveCount >= ShortCount
			if isGloves and GloveCount < 3 and ShortCount >= 2 then
				isGloves = false
			end

			if isGloves then
				ReplaceGloves(getLastN(Gloves, 3))
			else
				ReplaceShorts(getLastN(Shorts, 2))
			end

			--// Crate Functions Clicking etc..
			Tab_Handle(tmp, Crates_Info)
		end
	end

	table.insert(Crate_Cons, Crates_Display_F:GetPropertyChangedSignal("Visible"):Connect(function()
		if(Crates_Display_F.Visible == false and Crate_Data_F.Visible == false)then
			Core_Utils.Disconnect_Cons(Crate_Cons)
			Crate_Data_F.Visible = false
			Item_Preview_F.Visible = false
		end
	end))
end

local function Exchange_Handle(context)
	local mainFrame = context.Exchange_F

	local Cash_V = PD:WaitForChild("Coins")
	local Gems_V = PD:WaitForChild("Gems")
	local Data_Box_F = mainFrame:WaitForChild("Data_Box_F")

	local Input = Data_Box_F:WaitForChild("CashInput")
	local Result = Data_Box_F:WaitForChild("ResultLabel")
	local Confirm = Data_Box_F:WaitForChild("ConfirmButton")

	local convertion_settings = Monetization_Mod.Get_Conversion_Settings()
	local RATE = convertion_settings.RATE
	local FEE = convertion_settings.FEE
	local MIN_CASH = 1 / RATE

	-- Helper: animate message display (fade-in only)
	local function showMessage(text)
		Result.Text = text
		Result.TextTransparency = 1
		local fadeIn = TS:Create(Result, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextTransparency = 0})
		fadeIn:Play()
	end

	-- Helper to toggle confirm state
	local function setConfirmEnabled(state)
		Confirm.Active = state
		Confirm.AutoButtonColor = state
		Confirm.BackgroundTransparency = state and 0 or 0.5
	end

	setConfirmEnabled(false)

	local function validateInput()
		local text = Input.Text
		if text == "" then
			Result.Text = ""
			setConfirmEnabled(false)
			return nil
		end

		local amount = tonumber(text)
		if not amount or amount < MIN_CASH then
			showMessage("Minimum " .. tostring(MIN_CASH) .. " cash required.")
			setConfirmEnabled(false)
			return nil
		end

		local gemsRaw = amount / MIN_CASH
		local gems = math.floor(gemsRaw * (1 - FEE))
		if amount >= MIN_CASH and gems < 1 then
			gems = 1
		end

		if gems < 1 then
			showMessage("Not enough for 1 gem.")
			setConfirmEnabled(false)
			return nil
		end

		Result.Text = string.format("You will receive: %d 💎 (%.0f%% fee)", gems, FEE * 100)
		setConfirmEnabled(true)
		return amount
	end

	-- Live validation
	Input:GetPropertyChangedSignal("Text"):Connect(validateInput)

	Confirm.MouseButton1Click:Connect(function()
		local amount = validateInput()
		if not amount then return end

		if Cash_V.Value < amount then
			showMessage("Not enough cash.")
			return
		end

		-- Fire to server
		Convert_Cash_To_Gems:FireServer(amount)

		showMessage("⏳ Processing...")
		Input.Text = ""
		setConfirmEnabled(false)
	end)

	Convert_Feedback.OnClientEvent:Connect(function(newCash, newGems)
		context.TriggerTransactionEffects()
		local message = string.format("✅ You received %d 💎!", newGems)
		showMessage(message)
	end)

	mainFrame.Visible = true
end

--local function Emotes_Handle()
--	-- TODO when emotes will be sold
--end

--local function SpecialPunch_Handle()
--	-- TODO when special punches will be sold
--end

local function Fill_Cloth_Display(context, IsGlove,panel)
	panel.Tabs_F:ClearAllChildren()

	local function Show_Item_Preview(context, itemKey, itemName, isGlove, price, callback)
		local previewFrame = context.Item_Preview_F

		local buyButton = previewFrame.Main_Data_F.Buy_B
		local Rare_F = previewFrame.Main_Data_F.Rare_F
		Rare_F.Visible = false
		local viewport = previewFrame.Main_Data_F.VF
		local wm = viewport:WaitForChild("WM")

		-- Cleanup
		wm:ClearAllChildren()
		local oldCam = viewport:FindFirstChildOfClass("Camera")
		if oldCam then oldCam:Destroy() end

		-- Disconnect any previous connection for this button
		if BuyConnections[buyButton] then
			BuyConnections[buyButton]:Disconnect()
			BuyConnections[buyButton] = nil
		end

		local itemModel = ClothsFolder:FindFirstChild(itemName, true)
		if not itemModel then
			warn("Item model not found:", itemName)
			return
		end

		local display = itemModel:Clone()
		display.Parent = wm

		-- Create camera
		local cam = Instance.new("Camera")
		cam.Parent = viewport
		viewport.CurrentCamera = cam

		-- Orientation and camera distance aligned with Crates_Handle
		if display:FindFirstChild("LeftHand") then
			-- Gloves
			for _, part in pairs(display:GetChildren()) do
				if part:IsA("BasePart") and (part.Name == "LeftHand" or part.Name == "RightHand") then
					local groupName = part.Name .. "M"
					local group = display:FindFirstChild(groupName) or Instance.new("Model")
					group.Name = groupName
					group.Parent = display
					part.Parent = group
					part.Anchored = true
				end
			end

			if display:FindFirstChild("LeftHandM") and display:FindFirstChild("RightHandM") then
				display:PivotTo(CFrame.new(0, 0, 0))

				local OFFSET = 0.5

				display.LeftHandM:PivotTo(CFrame.new(-OFFSET, 0, 0))
				display.RightHandM:PivotTo(CFrame.new( OFFSET, 0, 0))

				Utils.SetupRotation(display.LeftHandM, 3)
				Utils.SetupRotation(display.RightHandM, -3)
			end

			cam.CFrame = CFrame.new(0, -0.15, 1.6)

			---- Shorts
		elseif display:FindFirstChild("LowerTorso") then	
			local torso = display:FindFirstChild("LowerTorso")
			if torso then
				display.PrimaryPart = torso
				display.PrimaryPart.PivotOffset = CFrame.new(0, 0, 0)
			else
				warn("[Shop Preview] LowerTorso not found for:", display.Name)
			end
			display.Parent = previewFrame.Main_Data_F.VF.WM
			previewFrame.Main_Data_F.VF.WM:PivotTo(CFrame.new(0,0,0)) 
			display:PivotTo(CFrame.new(0,0,0))
			previewFrame.Main_Data_F.VF.CurrentCamera = cam
			cam.Parent = previewFrame.Main_Data_F.VF
			cam.CFrame = CFrame.new(0, -0.5, 2)
		end

		viewport.LightColor = Color3.fromRGB(255, 255, 240)
		viewport.Ambient = Color3.fromRGB(200, 200, 200)

		-- Name & price
		previewFrame.Main_Data_F.Item_Name_Txt.Text = string.upper(itemName)
		buyButton.buy_label.Text = string.format("BUY FOR %d 💎", price)
		buyButton.Visible = true

		BuyConnections[buyButton] = buyButton.MouseButton1Click:Connect(function()
			Purchase_Cloth_Item:FireServer(isGlove, itemKey)
			if callback then callback() end
			previewFrame.Visible = false
		end)

		local function Close_Preview()
			previewFrame:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true)
			previewFrame.Visible = false
		end

		MenuButtons_Mod.Setup_Exit_X_Button(context.Cons, previewFrame.Main_Data_F.Exit_B, Close_Preview)
		previewFrame.Background_Select.MouseButton1Click:Connect(function()
			Close_Preview()
		end)

		previewFrame.Visible = true
		previewFrame:TweenSize(UDim2.new(1, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true)
	end

	local DataTable ={}

	if IsGlove then
		DataTable = Clothing_Mod.Get_All_Gloves_Data()
	else
		DataTable = Clothing_Mod.Get_All_Shorts_Data()
	end


	local sortedKeys = {}
	for key, _ in pairs(DataTable) do
		table.insert(sortedKeys, key)
	end

	table.sort(sortedKeys, function(a, b)
		local priceA = Offers_Config.GetClothDataByKey(a, IsGlove)["Gems"] or 0
		local priceB = Offers_Config.GetClothDataByKey(b, IsGlove)["Gems"] or 0
		return priceA > priceB
	end)

	local t_X, t_Y = 0.125, 0.25
	local Def_S = UDim2.new(0.22, 0, 0.475, 0)
	local Hover_S = UDim2.new(0.24, 0, 0.48875, 0)
	local Click_S = UDim2.new(0.15, 0, 0.31875, 0)

	for _, Key in ipairs(sortedKeys) do
		local item = DataTable[Key]
		if item then
			local offerPriceData = Offers_Config.GetClothDataByKey(Key, IsGlove)
			local Color = Clothing_Mod.Get_Rarity_Color(offerPriceData.Rarity)

			local tmp_Item = panel.Item_Tab_TMP:Clone()
			tmp_Item.Name = item
			tmp_Item.Item_Name_F.Item_Name_Txt.Text = string.upper(item)
			tmp_Item.Position = UDim2.new(t_X, 0, t_Y, 0)
			tmp_Item.UIStroke.Color = Color
			tmp_Item.Price_F.Gems_F.Data_Txt.Text = offerPriceData["Gems"]
			tmp_Item.Parent = panel.Tabs_F
			tmp_Item.Owned.Visible = IsGlove and Clothing_Mod.Player_Owns_Gloves_Key(Plr, Key)
				or Clothing_Mod.Player_Owns_Shorts_Key(Plr, Key)
			tmp_Item.Visible = true

			--// VF
			local display = ClothsFolder:FindFirstChild(item, true):Clone()
			local Viewport_Camera = Instance.new("Camera")

			if (display:FindFirstChild("LeftHand")) and (display:FindFirstChild("RightHand")) then
				-- Wrap hands into small models for independent rotation
				local leftModel = Instance.new("Model")
				leftModel.Name = "LeftHandM"
				display.LeftHand.Parent = leftModel
				leftModel.Parent = display

				local rightModel = Instance.new("Model")
				rightModel.Name = "RightHandM"
				display.RightHand.Parent = rightModel
				rightModel.Parent = display

				-- Ensure WM exists
				if not tmp_Item.VF:FindFirstChild("WM") then
					local wm = Instance.new("WorldModel")
					wm.Name = "WM"
					wm.Parent = tmp_Item.VF
				end

				-- Scale down both hands globally 
				display:ScaleTo(0.85)

				-- Center both models in front of the camera
				Utils.AlignGloves(leftModel, rightModel)

				-- Attach to WorldModel
				display.Parent = tmp_Item.VF.WM

				-- Camera
				local Viewport_Camera = Instance.new("Camera")
				Viewport_Camera.CFrame = CFrame.new(0, 0, 2)
				Viewport_Camera.Parent = tmp_Item.VF
				tmp_Item.VF.CurrentCamera = Viewport_Camera

				-- Enhanced lighting simulation
				tmp_Item.VF.LightColor = Color3.fromRGB(255, 255, 235)  -- light warmer tone
				tmp_Item.VF.Ambient = Color3.fromRGB(200, 200, 200)      -- overall ambient brightness
				tmp_Item.VF.ImageColor3 = Color3.new(1, 1, 1)            -- no dimming
				tmp_Item.VF.ImageTransparency = 0    

				Utils.SetupHoverRotation(tmp_Item, leftModel, 3)
				Utils.SetupHoverRotation(tmp_Item, rightModel, -3)

			elseif (display:FindFirstChild("LowerTorso")) then
				local torso = display:FindFirstChild("LowerTorso")
				if torso then
					display.PrimaryPart = torso
					display.PrimaryPart.PivotOffset = CFrame.new(0, 0, 0)
				else
					warn("[Shop Preview] LowerTorso not found for:", display.Name)
				end
				display:PivotTo(CFrame.new(0,0,0))
				tmp_Item.VF.CurrentCamera = Viewport_Camera
				display.Parent = tmp_Item.VF.WM
				tmp_Item.VF.WM:PivotTo(CFrame.new(0,0,0)) 
				Viewport_Camera.Parent = tmp_Item.VF
				Viewport_Camera.CFrame = CFrame.new(0, 0, 2)
			end

			t_X += 0.25

			if t_X >= 0.9 then
				t_X = 0.125
				t_Y += 0.525
			end
			table.insert(context.Cons, tmp_Item.MouseEnter:Connect(function()
				if(Debounce_E == false and panel.Visible == true)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")

					tmp_Item:TweenSize(Hover_S, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					Debounce_E = false
				end
			end))

			table.insert(context.Cons, tmp_Item.MouseLeave:Connect(function()
				if(panel.Visible == true)then
					tmp_Item:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
				end
			end))

			table.insert(context.Cons, tmp_Item.Selected.MouseButton1Click:Connect(function()
				if not Debounce_C and panel.Visible then
					Debounce_C = true

					local alreadyOwned = IsGlove
						and Clothing_Mod.Player_Owns_Gloves_Key(Plr, Key)
						or Clothing_Mod.Player_Owns_Shorts_Key(Plr, Key)

					if alreadyOwned then
						SE_Mod.PlaySFX(Plr, "Hover_SE")
						Debounce_C = false
						return -- stop here (no purchase)
					end

					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(tmp_Item, Tween_Click, {Size = Click_S}):Play()

					local itemName = DataTable[Key]
					Show_Item_Preview(context, Key, itemName, IsGlove, offerPriceData["Gems"], function()
						task.delay(0.3, function()
							local ownsNow = IsGlove
								and Clothing_Mod.Player_Owns_Gloves_Key(Plr, Key)
								or Clothing_Mod.Player_Owns_Shorts_Key(Plr, Key)
							if ownsNow and tmp_Item:FindFirstChild("Owned") then
								tmp_Item.Owned.Visible = true
							end
						end)
					end)

					task.wait(0.25)
					Debounce_C = false
				end
			end))

		end
	end
	panel.Visible=true
end

--------------------------------------------------------------------
-- ✅ EXPORT HANDLERS (required by Client_Shop_Handle)
--------------------------------------------------------------------

-- Currency
Core_Frame_Handlers.Cash = { Handle = Cash_Handle }
Core_Frame_Handlers.Gems = { Handle = Gems_Handle }
Core_Frame_Handlers.Exchange = { Handle = Exchange_Handle }

-- Gamepasses
Core_Frame_Handlers.Passes = { Handle = Gamepasses_Handle }

-- UGC / Merch
Core_Frame_Handlers.Merch = { Handle = Merch_Handle }

-- Crates
Core_Frame_Handlers.Crates = { Handle = Crates_Handle }

-- Shorts / Gloves (clothing)
Core_Frame_Handlers.Shorts = {
	Handle = function(ctx)
		-- false → Shorts
		ctx.Item_Preview_F = ctx.Item_Preview_F 
		Fill_Cloth_Display(ctx, false, ctx.Shorts_Display_F)
	end
}

Core_Frame_Handlers.Gloves = {
	Handle = function(ctx)
		-- true → Gloves
		ctx.Item_Preview_F = ctx.Item_Preview_F 
		Fill_Cloth_Display(ctx, true, ctx.Gloves_Display_F)
	end
}

return Core_Frame_Handlers]]></ProtectedString>
								<string name="ScriptGuid">{B112C59D-0A66-43F7-BAFF-2A9AF918E4DC}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Core_Frame_Handlers.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX2AF4544BE3E34EB0875CC458F623AF0D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">System</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX7BC6355FD36A4E29A7794ADAF65F80E6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterGui/System/Check_Screen_Orientation.lua
--
--  Description:
--      Prevents to play the game in portrait mode
--
--  Author(s): Exclusible, Darkzeb
--
--  Last Modified: 2025-10-30 by Darkzeb
--
--  Version: V2025-
--
--======================================================================

local StarterGui 		= game:GetService("StarterGui")
local Players 			= game:GetService("Players")
local RunService 		= game:GetService("RunService")
local UserInputService 	= game:GetService("UserInputService")
local camera 			= workspace.CurrentCamera
local player 			= Players.LocalPlayer
local playerGui 		= player:WaitForChild("PlayerGui")

StarterGui.ScreenOrientation = Enum.ScreenOrientation.LandscapeLeft

-- Main ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "OrientationWarning"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

-- Blocker (invisible button to block all interactions)
local blocker = Instance.new("TextButton")
blocker.Size = UDim2.new(1, 0, 1, 0)
blocker.BackgroundTransparency = 1
blocker.Text = ""
blocker.Visible = false
blocker.Modal = true -- 🚫 empêche toute autre interaction
blocker.Parent = screenGui

-- Background overlay
local frame = Instance.new("Frame")
frame.Size = UDim2.new(1, 0, 1, 0)
frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
frame.BackgroundTransparency = 0.5
frame.Visible = false
frame.Parent = blocker -- ⚠️ mettre dans blocker pour bloquer en même temps

-- Center container
local container = Instance.new("Frame")
container.AnchorPoint = Vector2.new(0.5, 0.5)
container.Position = UDim2.new(0.5, 0, 0.5, 0)
container.Size = UDim2.new(0.8, 0, 0.4, 0)
container.BackgroundTransparency = 1
container.Parent = frame

-- Icon
local icon = Instance.new("ImageLabel")
icon.AnchorPoint = Vector2.new(0.5, 0.5)
icon.Position = UDim2.new(0.5, 0, 0.3, 0)
icon.Size = UDim2.new(0.2, 0, 0.4, 0)
icon.BackgroundTransparency = 1
icon.Image = "rbxassetid://6035047409"
icon.ImageColor3 = Color3.fromRGB(255, 255, 255)
icon.Parent = container

-- Text
local textLabel = Instance.new("TextLabel")
textLabel.AnchorPoint = Vector2.new(0.5, 0)
textLabel.Position = UDim2.new(0.5, 0, 0.65, 0)
textLabel.Size = UDim2.new(1, 0, 0.3, 0)
textLabel.BackgroundTransparency = 1
textLabel.Text = "Please rotate your device to landscape 📱↔️"
textLabel.TextScaled = true
textLabel.Font = Enum.Font.GothamBold
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
textLabel.Parent = container

-- Function to check orientation
local function checkOrientation()
	local size = camera.ViewportSize
	local isPortrait = size.X < size.Y

	-- sécuriser l'accès aux UI si elles existent
	local offerUI = playerGui:FindFirstChild("Shop"):FindFirstChild("Offer_UI")
	local dailyRewardUI = playerGui:FindFirstChild("Menus"):FindFirstChild("Daily_Rewards_UI")

	if RunService:IsStudio() then
		blocker.Visible = isPortrait
		frame.Visible = isPortrait
	else
		if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled then
			blocker.Visible = isPortrait
			frame.Visible = isPortrait
		else
			blocker.Visible = false
			frame.Visible = false
		end
	end

	-- forcer le blocage/désactivation des popups
	if offerUI then
		offerUI.Enabled = not isPortrait
	end
	if dailyRewardUI then
		dailyRewardUI.Enabled = not isPortrait
	end
end

-- Initial check
task.wait(1)
checkOrientation()

-- Update on screen resize/orientation change
camera:GetPropertyChangedSignal("ViewportSize"):Connect(checkOrientation)]]></ProtectedString>
						<string name="ScriptGuid">{BBC68EE8-698F-4A92-BA9F-9896BB5F4925}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Check_Screen_Orientation.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX94EACCEA17E148F99C574AEDC2CA43B2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Hole_Transition_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX91D58D1B2CD54A02B6E8444FB527A4EF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")

-- Modules
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Transition_Hole_UI = Channels.Bindable_Events.Transition_Hole_UI
local Transition_Fade_UI = Channels.Bindable_Events.Transition_Fade_UI
local Transition_Hole    = Channels.SC_Remote_Events.Transition_Hole
local Transition_Fade    = Channels.SC_Remote_Events.Transition_Fade

local Main_F = script.Parent.Main
local Fade_F =  script.Parent.Fade_F
local Debounce_Effect = false


local function Set_Color(BG_Col)
	Main_F.ImageColor3 = BG_Col
	local Tabs = Main_F:GetChildren()
	for i = 1, #Tabs do
		if(Tabs[i]:IsA("Frame"))then
			Tabs[i].BackgroundColor3 = BG_Col
		end
	end
end

local function Apply_Effect()
	Main_F.Visible = false
	Main_F.Size = UDim2.new(3, 0, 3, 0)
	Main_F.Visible = true
	Main_F:TweenSize(UDim2.new(0.0125, 0, 0.3, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quart, 0.375, true, nil)
	task.wait(0.5)
	Main_F:TweenSize(UDim2.new(3, 0, 3, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quad, 0.375, true, nil)
	task.wait(0.375)
	Main_F.Visible = false
	Main_F.Size = UDim2.new(3, 0, 3, 0)
end

Transition_Hole.OnClientEvent:Connect(function(BG_Col)
	if(Debounce_Effect == false)then
		Debounce_Effect = true
		Set_Color(BG_Col)
		Apply_Effect()
		Debounce_Effect = false
	end
end)

Transition_Hole_UI.Event:Connect(function(BG_Col)
	if(Debounce_Effect == false)then
		Debounce_Effect = true
		Set_Color(BG_Col)
		Apply_Effect()
		Debounce_Effect = false
	end
end)

local function Launch_Transition_Fade(Tween_Time, Delay_Time)
	local Tween_I = TweenInfo.new(Tween_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
	Fade_F.Visible = false
	Fade_F.BackgroundTransparency = 1
	Fade_F.Visible = true
	TS:Create(Fade_F, Tween_I, {BackgroundTransparency = 0}):Play()
	task.wait(Delay_Time)
	TS:Create(Fade_F, Tween_I, {BackgroundTransparency = 1}):Play()
	task.wait(Tween_Time)
	Fade_F.Visible = false
end

Transition_Fade.OnClientEvent:Connect(function(Tween_Time, Delay_Time)
	Launch_Transition_Fade(Tween_Time, Delay_Time)
end)

Transition_Fade_UI.Event:Connect(function(Tween_Time, Delay_Time)
	Launch_Transition_Fade(Tween_Time, Delay_Time)
end)
]]></ProtectedString>
							<string name="ScriptGuid">{C1F7C947-37A7-4CEC-9762-A9229B6E5470}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Hole_Transition_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXD65DDEAF92AC4757907D4F784284F33E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Sound_Effects_F</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX409BC25BD54D48488684EAE4B0F29B8A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Sound_Effects_V = PD:WaitForChild("Sound Effects")
local Channels 	= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_BG_Volume = Channels.Bindable_Events.Toggle_BG_Volume

local Sound_Groups_F = game.ReplicatedStorage:WaitForChild("Audio"):WaitForChild("Sound_Groups")
local Sound_Effect_Group = Sound_Groups_F:WaitForChild("Sound_Effects")
local Missed_Hit_SE_Group = Sound_Groups_F:WaitForChild("Missed_Hit_Sound_Effects")
local BG_SE_Group = Sound_Groups_F:WaitForChild("BG_Sound")
local BG_V = PD:WaitForChild("Background Music")

local function Update_Sound_Group()
	if(Sound_Effects_V ~= nil and Sound_Effects_V.Value == true)then
		Sound_Effect_Group.Volume = 1
		Missed_Hit_SE_Group.Volume = 2
	else
		Sound_Effect_Group.Volume = 0
		Missed_Hit_SE_Group.Volume = 0
	end
end
Update_Sound_Group()

Sound_Effects_V.Changed:Connect(function()
	Update_Sound_Group()
end)


local function Update_BG_Sound_Group()
	if(BG_V ~= nil and BG_V.Value == true)then
		BG_SE_Group.Volume = 0.5
	else
		BG_SE_Group.Volume = 0
	end
end
Update_BG_Sound_Group()

BG_V.Changed:Connect(function()
	Update_BG_Sound_Group()
end)

Toggle_BG_Volume.Event:Connect(function(Toggle_On)
	if(Toggle_On and BG_V ~= nil and BG_V.Value == true)then
		BG_SE_Group.Volume = 0.5
	else
		BG_SE_Group.Volume = 0
	end
end)

]]></ProtectedString>
							<string name="ScriptGuid">{85863B22-A6EE-42AD-984A-696EEC5C3242}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Sound_Effect_Settings_Toggle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX921DB2934F214115B9FB397E202126D7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Settings_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXBBD2543A5EFC48A2B9A788DE1C9021CF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")

local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 	= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Settings 		= Channels.Bindable_Events.Open_Settings
local Close_Settings_E 		= Channels.Bindable_Events.Close_Settings
local Save_Settings_E		= Channels.CS_Remote_Events.Save_Settings

-- UI References
local Main_F = script.Parent.Main_F
local Data_F = Main_F.Data_F
local Exit_B = Main_F.Header.Exit_B
local Main_Data_F = Data_F.Main_Data_F

local Debounce_C = false
local Debounce_E = false
local Debounce_UI = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Get_Server_Settings_Data()
	local Tabs = Main_Data_F:GetChildren()
	local Data = {}

	local function Get_Data_From_Key(Key)
		local V = PD:FindFirstChild(Key)
		if(V ~= nil)then
			return V.Value
		end
		return false
	end

	for i = 1, #Tabs do
		local T = Tabs[i]
		if(T ~= nil)then
			local Key = T.Name
			Data[Key] = Get_Data_From_Key(Key)
		end
	end

	return Data
end

local function Get_Client_Settings_Data()
	local Tabs = Main_Data_F:GetChildren()
	local Data = {}

	local function Get_Data_From_Tab(T)
		local Toggle_F = T:FindFirstChild("Toggle_F")
		if(Toggle_F ~= nil and Toggle_F.BackgroundColor3 == Color3.fromRGB(35, 244, 68))then
			return true
		end
		return false
	end

	for i = 1, #Tabs do
		local T = Tabs[i]
		if(T ~= nil)then
			Data[T.Name] = Get_Data_From_Tab(T)
		end
	end

	return Data
end

local function Save_Settings()
	local newSettings = Get_Client_Settings_Data()
	Save_Settings_E:FireServer(newSettings)
	local SFX_Enabled  = newSettings["Sound Effects"]
	local Music_Enabled  = newSettings["Background Music"]
	
	game.SoundService:SetAttribute("SFX_Enabled", SFX_Enabled)
	game.SoundService:SetAttribute("Music_Enabled", Music_Enabled)
	
	local hum = Plr.Character:WaitForChild("Humanoid")
	if hum then
		hum:SetAttribute("DisableSounds", not SFX_Enabled)
		hum:SetAttribute("DisableFootstepSounds", not SFX_Enabled)
	end
end

local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	Main_Data_F.CanvasPosition = Vector2.new(0, 0)

	task.spawn(function()
		Save_Settings()
	end)

	task.wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Settings_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Toggle_Side_Buttons:Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Display_UI()

	local function Reset_Display()
		Disconnect_Cons()
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.575, 0)
		Main_Data_F.CanvasPosition = Vector2.new(0, 0)

		local Stats_Blurr = game.Lighting:FindFirstChild("Settings_Blurr")
		if(Stats_Blurr ~= nil)then
			Stats_Blurr:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()

	local function Set_Up_Data_Tabs()
		local Tabs = Main_Data_F:GetChildren()
		local Settings_Data = Get_Server_Settings_Data()

		local function Tab_Handle(T)
			local Key = T.Name
			local Key_Txt = T:FindFirstChild("Settings_Key_Txt")
			local Toggle_F = T:FindFirstChild("Toggle_F")
			local Bar_F = Toggle_F:FindFirstChild("Bar_F")
			local Selected = Toggle_F:FindFirstChild("Selected")

			local function Update_Toggle_Display(Is_Enabled)
				if(Is_Enabled)then
					Toggle_F.BackgroundColor3 = Color3.fromRGB(35, 244, 68)
					Bar_F:TweenPosition(UDim2.new(0.775, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
				else
					Toggle_F.BackgroundColor3 = Color3.new(1, 0, 0)
					Bar_F:TweenPosition(UDim2.new(0.225, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
				end
			end
			Update_Toggle_Display(Settings_Data[Key])
			Key_Txt.TextColor3 = Color3.new(1, 1, 1)

			table.insert(Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")

					Key_Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					Debounce_E = false
				end
			end))

			table.insert(Cons, Selected.MouseLeave:Connect(function()
				Key_Txt.TextColor3 = Color3.new(1, 1, 1)
			end))	

			table.insert(Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")

					local Current_V = (Toggle_F.BackgroundColor3 == Color3.fromRGB(35, 244, 68))
					Update_Toggle_Display(not Current_V)

					Save_Settings()

					task.wait(0.375)
					Debounce_C = false
				end
			end))
		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil)then
				Tab_Handle(T)
			end
		end
	end
	Set_Up_Data_Tabs()

	MenuButtons_Mod.Setup_Exit_X_Button({}, Exit_B, function()
		Close_Settings_E:Fire()
		Remove_UI()
	end)

	local function Display_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Settings_Blurr"

		Toggle_Side_Buttons:Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

Open_Settings.Event:Connect(function(value)
	if(Debounce_UI == false and value == true)then
		Display_UI()
	elseif ( Debounce_UI == true and value == false) then
		Remove_UI()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{4DFF856A-F590-415B-99DA-727E25652824}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Settings_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX404854A36C55487FBD6053578CA3442A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Elo_Limit_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX1A7210CD2F654810949623E71213C740">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Elo_Rank_Dif 			= Channels.SC_Remote_Events.Elo_Rank_Dif

-- UI references
local Main_F = script.Parent.Main_F
local Main_Tab_F = Main_F.Main_Tab_F
local Rank_Data_F = Main_Tab_F.Rank_Data_F
local Your_Elo_F = Rank_Data_F.Your_Elo_F
local Your_Elo_Img = Your_Elo_F.Elo_Img
local Other_Elo_F = Rank_Data_F.Current_Elo_F
local Other_Elo_Img = Other_Elo_F.Elo_Img

local Debounce_UI = false

local Player_Thumbnail_Data = {

}
local function Get_Player_Thumbnail(ID)
	if(Player_Thumbnail_Data[ID] ~= nil)then
		return Player_Thumbnail_Data[ID]
	else
		local Type = Enum.ThumbnailType.HeadShot
		local Size = Enum.ThumbnailSize.Size420x420

		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				Data = game.Players:GetUserThumbnailAsync(ID, Type, Size)
			end)

			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end

		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				Player_Thumbnail_Data[ID] = D
				return D
			end
		end

		return "rbxassetid://100127687172105"
	end
end

local function Special_Txt(text, color)
	return string.format(
		'<font color="rgb(%d, %d, %d)">%s</font>',
		color.R * 255, color.G * 255, color.B * 255, text
	)
end


local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

local function Display_Effects(Other_Plr)
	Debounce_UI = true

	SE_Mod.PlaySFX(Plr, "Elo_Error_SE")
	
	local function Reset_Display()
		Main_F.Visible = false
		Main_F.BackgroundTransparency = 1
		Main_Tab_F.Position = UDim2.new(0.5, 0, -0.25, 0)
		Main_F.Visible = true
	end
	Reset_Display()
	
	if(Other_Plr ~= nil)then
		local function Update_Elo_Difference_Display()
			local Your_Elo_Data, Your_Elo_Val = Elo_Mod.Get_Player_Rank_Data(Plr)
			local Other_Elo_Data, Other_Elo_Val = Elo_Mod.Get_Player_Rank_Data(Other_Plr)
			
			local function Compile_Range_Txt(D)
				local Range_Min, Range_Max = D['Elo Range'].Min, D['Elo Range'].Max
				local Txt = Format_Number(Range_Min) .. " - inf"
				if(D['Index'] <= 5)then
					Txt = Format_Number(Range_Min) .. " - " .. Format_Number(Range_Max)
				end
				
				return Special_Txt(Txt, D['Color'])
			end
			Rank_Data_F:FindFirstChild("Elo_Range_Txt").Text = Compile_Range_Txt(Your_Elo_Data) .. " | " .. Compile_Range_Txt(Other_Elo_Data)
			Rank_Data_F:FindFirstChild("Your_Img").Image = Get_Player_Thumbnail(Plr.UserId)
			Rank_Data_F:FindFirstChild("Other_Img").Image = Get_Player_Thumbnail(Other_Plr.UserId)
			
			Your_Elo_Img.Image = Your_Elo_Data['Icon']
			Your_Elo_Img.ImageColor3 = Your_Elo_Data['Color']
			Your_Elo_F:FindFirstChild("Elo_Txt").Text = Format_Number(Your_Elo_Val) .. ""
			
			Other_Elo_Img.Image = Other_Elo_Data['Icon']
			Other_Elo_Img.ImageColor3 = Other_Elo_Data['Color']
			Other_Elo_F:FindFirstChild("Elo_Txt").Text = Format_Number(Other_Elo_Val) .. ""
			
			Rank_Data_F.Visible = true
		end
		Update_Elo_Difference_Display()
	else
		Rank_Data_F.Visible = false
	end
	
	local function Show_Effects()
		local Tween_Trans = TweenInfo.new(0.375, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
		TS:Create(Main_F, Tween_Trans, {BackgroundTransparency = 0.5}):Play()
		Main_Tab_F:TweenPosition(UDim2.new(0.5, 0, 0.475, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.5, true, nil)
		task.wait(0.5)
		Main_Tab_F:TweenPosition(UDim2.new(0.5, 0, 0.5125, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 2.5, true, nil)
		task.wait(2.5)	
		Main_Tab_F:TweenPosition(UDim2.new(0.5, 0, 1.1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.5, true, nil)
		task.wait(0.125)
		TS:Create(Main_F, Tween_Trans, {BackgroundTransparency = 1}):Play()
		task.wait(0.5)
	end
	Show_Effects()

	Reset_Display()
	
	Debounce_UI = false
end

Elo_Rank_Dif.OnClientEvent:Connect(function(Other_Plr)
	if(Debounce_UI == false)then
		Display_Effects(Other_Plr)
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{9C951BFF-02DD-44D0-AB74-270ECB503DE2}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Elo_Limit_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXCEF8F946045B44F39C0899F98CC250BE">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Emotes_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX3062434814DC493BB7FC124625030215">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local PD = Plr:WaitForChild("Player_Data")
local Selected_Emotes_V = PD:WaitForChild("Current Emotes")

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animations_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Emotes_Data = Animations_Mod.Get_Combinations("Emotes")

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Emote_Slot_Request = Channels.CS_Remote_Functions.Emote_Slot_Request
local Open_Emotes_UI 	 = Channels.Bindable_Events.Open_Emotes_UI
local Open_Emotes 		 = Channels.SC_Remote_Events.Open_Emotes

-- UI references
local Emotes_F = script.Parent.Main_F
local Backdrop_Effects_F = Emotes_F.Frame_Backdrops_F
local Edit_Emotes_F = Emotes_F.Edit_Emotes_F
local Emote_Select_F = Emotes_F.Emote_Select_F
local Emote_List_F = Emote_Select_F.Emote_List_F
local Tabs_F = Emote_List_F.Tabs_F
local TMP_Tab = Emote_List_F.TMP_Tab

local Debounce_E = false
local Debounce_C = false
local Debounce_T = false
local Debounce_UI = false

local Edit_Mode = false
local Selected_Slot

local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Remove_UI()
	Disconnect_Cons()
	Emotes_F:TweenPosition(UDim2.new(0.6575, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

	local Is_Fighting = Char:GetAttribute("Is_Fighting")
	if(Is_Fighting ~= nil and Is_Fighting == true)then
		UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
		UIS.MouseIconEnabled = false
	end

	task.wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Emotes_Blur")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	
	Emotes_F.Edit_Emotes_F:TweenSize(UDim2.new(0.173, 0, 0.297, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, false, nil)
	Emotes_F.Edit_Emotes_F.TextLabel.Text = "Edit Emotes"
	Emotes_F.Edit_Emotes_F.TextLabel.TextColor3 = Color3.fromRGB(255,255,255)
	Emotes_F.Visible = false
	Emotes_F.Position = UDim2.new(0.6575, 0, 0.675, 0)
	Emote_Select_F.Visible = false
	Emote_List_F.CanvasPosition = Vector2.new(0, 0)
	Tabs_F:ClearAllChildren()

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
	Debounce_T = false
	Edit_Mode = false
	Selected_Slot = nil
end
Remove_UI()

local function Show_UI()
	local Hum = Char:WaitForChild("Humanoid")

	local function Reset_Backdrop_Imgs()
		local All_Backdrop_Tabs = Backdrop_Effects_F:GetChildren()
		for i = 1, #All_Backdrop_Tabs do
			local T = All_Backdrop_Tabs[i]
			if(T ~= nil and T:IsA("ImageLabel"))then
				T.ImageColor3 = Color3.new(1, 1, 1)
			end
		end
	end

	local function Reset_Display()
		Disconnect_Cons()
		Emotes_F.Edit_Emotes_F:TweenSize(UDim2.new(0.173, 0, 0.297, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, false, nil)
		Emotes_F.Edit_Emotes_F.TextLabel.Text = "Edit Emotes"
		Emotes_F.Edit_Emotes_F.TextLabel.TextColor3 = Color3.fromRGB(255,255,255)
		Emotes_F.Visible = false
		Emotes_F.Position = UDim2.new(0.6575, 0, 0.575, 0)
		Emote_Select_F.Visible = false
		Emote_List_F.CanvasPosition = Vector2.new(0, 0)
		Tabs_F:ClearAllChildren()
		Reset_Backdrop_Imgs()

		local Emotes_Blur = game.Lighting:FindFirstChild("Emotes_Blur")
		if(Emotes_Blur ~= nil)then
			Emotes_Blur:Destroy()
		end
	end
	Reset_Display()

	--// load all the emotes they have selected
	--//setup buttons when clicked play emote and close menu
	--// setup edit menu load all the emotes they own, and when clicked assign that emote to that selected slot edit menu >select slot > select emote > save
	local Emote_Slots = Emotes_F:GetChildren()
	local EmotesSelected = Selected_Emotes_V.Value:split(",")

	local function LoadEmotes()
		--// setup all the buttons binds
		--// clear old ones
		Emote_List_F.CanvasPosition = Vector2.new(0, 0)
		Tabs_F:ClearAllChildren()

		local X = 0.25
		local Y = 0.25
		for key, values in pairs(Emotes_Data) do
			if (Animations_Mod.Player_Owns_Emote_Key(Plr, key) == true or values["Price"] <= 0) then
				local tmp = Emote_List_F.TMP_Tab:Clone()
				tmp.Name = key
				tmp.Main_Txt.Text = values["Name"]
				tmp.Emote_Img.Image = values['Icon']
				tmp.Visible = true
				tmp.Position = UDim2.new(X,0,Y,0)
				tmp.Parent = Emote_List_F.Tabs_F
				
				--// setup when pressed change slot to new emote selected and send request to server for confirmation.
				table.insert(Cons, tmp.Selected.MouseButton1Click:Connect(function()
					if (Selected_Slot) then
						local Server_Response = Emote_Slot_Request:InvokeServer(Selected_Slot, key)
						if (Server_Response == true) then
							EmotesSelected[tonumber(Selected_Slot:match("%d+"))] = key
							Emotes_F[Selected_Slot].Emote_Name_Txt.Text = values["Name"]
							Emotes_F[Selected_Slot].Emote_Icon.Image = values["Icon"]
							Emote_Select_F.Visible = false
						else
							Emote_Select_F.Visible = false
						end
					end
				end))

				X += 0.48
				if X > 0.74 then
					X = 0.25
					Y += 0.54
				end
			end
		end

		Emote_Select_F.Visible = true
	end

	for i = 1, #Emote_Slots do
		local S = Emote_Slots[i]
		if(S ~= nil and S:IsA("Frame") and string.match(S.Name, "T") ~= nil)then
			--print(EmotesSelected)
			if (EmotesSelected[1] ~= "") then
				local ES_Selected = EmotesSelected[tonumber(S.Name:match("%d+"))]
				if (ES_Selected ~= nil and Emotes_Data[ES_Selected] ~= nil) then


					S.Emote_Name_Txt.Text = Emotes_Data[ES_Selected]["Name"]
					S.Emote_Icon.Image = Emotes_Data[EmotesSelected[tonumber(S.Name:match("%d+"))]]["Icon"]

					table.insert(Cons, S.Selected.MouseButton1Click:Connect(function() --// debounce and play anim 
						if(Debounce_T == false and Edit_Mode == false) then
							Debounce_T = true
							Animations_Mod.Reset_Character_Animations(Char)
							task.wait()
							Animations_Mod.Play_Emote_Track_From_Key(Plr, Hum, EmotesSelected[tonumber(S.Name:match("%d+"))], false)
							task.wait(.1)
							Debounce_T = false
							Reset_Display()
						elseif (Debounce_T == false and Edit_Mode == true) then
							if (Emote_Select_F.Visible == false) then
								Debounce_T = true
								Selected_Slot = S.Name
								LoadEmotes()
								task.wait(.1)
								Debounce_T = false
							elseif (Emote_Select_F.Visible == true) then
								Debounce_T = true
								Selected_Slot = nil
								Emote_Select_F.Visible = false
								task.wait(.1)
								Debounce_T = false
							end

						end	
					end))

				end
			end

		end
	end

	--LoadEmotes()

	table.insert(Cons, Emotes_F.Edit_Emotes_F.Selected.MouseButton1Click:Connect(function()
		if(Edit_Mode == false) then -- starting editing
			Edit_Mode = true
			Emotes_F.Edit_Emotes_F:TweenSize(UDim2.new(0.173, 0, 0.31, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, false, nil)
			Emotes_F.Edit_Emotes_F.TextLabel.Text = "Save"
			TS:Create(Emotes_F.Edit_Emotes_F.TextLabel, TweenInfo.new(.25, Enum.EasingStyle.Linear), {TextColor3 = Color3.fromRGB(52, 255, 29)}):Play()
		elseif (Edit_Mode == true) then -- check if anything was changed and save
			Edit_Mode = false
			Emotes_F.Edit_Emotes_F:TweenSize(UDim2.new(0.173, 0, 0.297, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, false, nil)
			Emotes_F.Edit_Emotes_F.TextLabel.Text = "Edit Emotes"
			TS:Create(Emotes_F.Edit_Emotes_F.TextLabel, TweenInfo.new(.25, Enum.EasingStyle.Linear), {TextColor3 = Color3.fromRGB(255, 255, 255)}):Play()
		end
	end))

	local function Display_UI()
		Emotes_F.Visible = true
		Emotes_F:TweenPosition(UDim2.new(0.6575, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Emotes_Blur"
		Blur.Enabled = false

		local Is_Fighting = Char:GetAttribute("Is_Fighting")
		if(Is_Fighting ~= nil and Is_Fighting == true)then
			UIS.MouseBehavior = Enum.MouseBehavior.Default
			UIS.MouseIconEnabled = true
		end

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

Open_Emotes_UI.Event:Connect(function()
	if(Debounce_UI == false)then
		Show_UI()
	else
		Remove_UI()
	end
end)

Open_Emotes.OnClientEvent:Connect(function()
	if(Debounce_UI == false)then
		Show_UI()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{4060C8D0-4FAD-42D6-BDF4-904490818E5C}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Emotes_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXB0C100C546C1492A9D703BEAA3AD74D0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Changelog_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX224AEEF98578410395F6DE03418670C7">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local Cam = workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 	= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Changelog		= Channels.Bindable_Events.Open_Changelog
local Close_Changelog		= Channels.Bindable_Events.Close_Changelog

-- UI references
local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local Debounce_UI = false

local gui = script.Parent
local frame = gui:WaitForChild("Main_F")

--------------------------------------------------------------------
-- Changelog Carousel
--------------------------------------------------------------------
local bodyFrame = frame:WaitForChild("Body")
local dataFrame = bodyFrame:WaitForChild("Data_F") 
local leftBtn = frame:WaitForChild("Left_B")
local rightBtn = frame:WaitForChild("Right_B")
local header = frame:WaitForChild("Header")
local versionLabel = header:WaitForChild("Title")
local Exit_B = header:WaitForChild("Exit_B")

local changelogData = require(RS:WaitForChild("Data_Mods_F"):WaitForChild("Changelog_Mod")) 

-- limiter à 5 versions max
local versions = {}
for i = 1, math.min(5, #changelogData) do
	table.insert(versions, changelogData[i])
end

local currentIndex = 1
local maxItems = 8

local function displayVersion(index)
	local data = versions[index]
	if not data then return end

	-- update header
	versionLabel.Text = data.version

	-- clear old lines
	for _, child in ipairs(dataFrame:GetChildren()) do
		if child:IsA("TextLabel") then
			child:Destroy()
		end
	end

	-- create up to 8 items
	for i, change in ipairs(data.changes) do
		if i > maxItems then break end
		local item = Instance.new("TextLabel")
		item.Size = UDim2.new(1, 0, 0.8, 0)
		item.BackgroundTransparency = 1
		item.TextXAlignment = Enum.TextXAlignment.Left
		item.Font = Enum.Font.Nunito
		item.TextSize = 44
		item.TextScaled = true
		item.TextColor3 = Color3.new(1, 1, 1)
		item.Text = change
		item.Parent = dataFrame
	end

	-- fix button visibility logic
	if #versions <= 1 then
		leftBtn.Visible = false
		rightBtn.Visible = false
	else
		-- LEFT = older, RIGHT = newer
		leftBtn.Visible = index < #versions
		rightBtn.Visible = index > 1
	end
end

local function goLeft()
	SE_Mod.PlaySFX(Plr, "Click_SE")
	currentIndex = currentIndex + 1
	if currentIndex > #versions then currentIndex = 1 end
	displayVersion(currentIndex)
end

local function goRight()
	SE_Mod.PlaySFX(Plr, "Click_SE")
	currentIndex = currentIndex - 1
	if currentIndex < 1 then currentIndex = #versions end
	displayVersion(currentIndex)
end

leftBtn.MouseButton1Click:Connect(goLeft)
rightBtn.MouseButton1Click:Connect(goRight)

--------------------------------------------------------------------
-- UI Animations
--------------------------------------------------------------------
local function Remove_UI()
	frame:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	task.wait(0.25)
	local Blur = game.Lighting:FindFirstChild("Rewards_Blurr")
	if Blur then Blur:Destroy() end
	Cam.FieldOfView = 70
	gui.Enabled = false
	frame.Position = UDim2.new(0.5, 0, 0.675, 0)
	Toggle_Side_Buttons:Fire(true, true)
	Debounce_UI = false

	-- warn topmenu
	Close_Changelog:Fire()
	
end

local function Display_UI()
	gui.Enabled = true
	frame.Position = UDim2.new(0.5, 0, 0.675, 0)
	frame.Visible = true
	frame:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
	local Blur = Instance.new("BlurEffect")
	Blur.Name = "Rewards_Blurr"
	Blur.Parent = game.Lighting
	Toggle_Side_Buttons:Fire(false, true)
	Debounce_UI = true

	-- afficher première version au lancement
	currentIndex = 1
	displayVersion(currentIndex)
end

MenuButtons_Mod.Setup_Exit_X_Button({}, Exit_B, Remove_UI)

Open_Changelog.Event:Connect(function()
	if not Debounce_UI then
		Display_UI()
	end
end)

Close_Changelog.Event:Connect(function()
	if Debounce_UI then
		Remove_UI()
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{55B1D548-C94E-472F-B489-2B3F527194BA}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Changelog_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX4A083C83D68641CEB72901361595887D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Player_List_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX88E78E4A20654F0BB70D34A9B4F8537C">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Is_Chatbox_Typing 	= Channels.Bindable_Functions.Is_Chatbox_Typing 
local Open_Stats 			= Channels.Bindable_Events.Open_Stats

local Toggle_Player_List 	= Channels.Bindable_Events.Toggle_Player_List
local Toggle_Side_Buttons   = Channels.Bindable_Events.Toggle_Side_Buttons

local Update_Player_List 	= Channels.SC_Remote_Events.Update_Player_List

-- UI References
local Main_F = script.Parent.Main_F
local List_F = Main_F.Data_F
local Tabs_F = List_F.Tabs_F
local TMP_Tab = List_F.TMP_Tab

local Debounce_E = false
local Debounce_C = false
local Debounce_UI = false

local function Core_List_Handle()
	
	local function Format_Number(n)
		n = tostring(n)
		return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
	end
	
	local function Get_Player_Data_Vals(Plr)
		local PD = Plr:WaitForChild("Player_Data")
		if(PD ~= nil)then
			return PD:WaitForChild("Elo"), PD:WaitForChild("Win Streak"), 
				PD:WaitForChild("Punch Knockout Wins"), PD:WaitForChild("Leg Knockout Wins")
		end
		
		return nil, nil, nil, nil
	end
	
	local function Update_Win_Streak_Crown()
		local All_T = Tabs_F:GetChildren()
		table.sort(All_T, function(A, B)
			local A_Streak = A:GetAttribute("Win_Streak") or 0
			local B_Streak = B:GetAttribute("Win_Streak") or 0
			return A_Streak > B_Streak
		end)
		
		for i = 1, #All_T do
			local T = All_T[i]
			if(T ~= nil and T:IsA("Frame") and T:FindFirstChild("Streak_F") ~= nil)then
				local Streak_F = T:FindFirstChild("Streak_F")
				local Crown_Icon = Streak_F:FindFirstChild("Crown_Img")
				if(Crown_Icon ~= nil)then
					Crown_Icon.Visible = (i == 1)
				end
			end
		end
	end
	
	local function Update_Elo_Order()
		local Y_Pos = 0
		local All_T = Tabs_F:GetChildren()
		table.sort(All_T, function(A, B)
			local A_Elo = A:GetAttribute("Elo") or 0
			local B_Elo = B:GetAttribute("Elo") or 0
			return A_Elo > B_Elo
		end)
		
		for i = 1, #All_T do
			local T = All_T[i]
			if(T ~= nil and T:IsA("Frame"))then
				T.Position = UDim2.new(0, 0, Y_Pos, 0)
				Y_Pos += 0.15
			end
		end
	end
	
	local function Create_Player_Tab(Plr)
		local Elo_V, Win_Streak_V, Punch_KO_V, Kick_KO_V = Get_Player_Data_Vals(Plr)
		if(Elo_V ~= nil and Win_Streak_V ~= nil and Punch_KO_V ~= nil and Kick_KO_V ~= nil)then
			local Tab = TMP_Tab:Clone()
			Tab.Parent = Tabs_F
			Tab.Name = "Tab_" .. Plr.UserId
			Tab.Position = UDim2.new(1, 0, 0, 0)
			Tab:SetAttribute("Elo", Elo_V.Value or 400)
			Tab:SetAttribute("Win_Streak", Win_Streak_V.Value or 0)
			
			local Elo_Key, Elo_Data = Elo_Mod.Get_Elo_Data_From_Val(Elo_V.Value)
			local Selected = Tab:WaitForChild("Selected")
			local Elo_Txt = Tab:WaitForChild("Elo_F"):WaitForChild("Elo_Txt")
			local Name_F = Tab:WaitForChild("Plr_Name_F")
			local Elo_Icon = Name_F:WaitForChild("Elo_Img")
			local Name_Txt = Name_F:WaitForChild("Plr_Name_Txt")
			local Streak_F = Tab:WaitForChild("Streak_F")
			local Crown_Icon = Streak_F:WaitForChild("Crown_Img")
			local Streak_Txt = Streak_F:WaitForChild("Streak_Txt")
			local KO_Txt = Tab:WaitForChild("KO_F"):WaitForChild("KO_Txt")
			
			Name_Txt.Text = Plr.DisplayName .. ""
			Name_Txt.TextColor3 = Color3.new(1, 1, 1)
			Crown_Icon.Visible = false
			Streak_Txt.Text = Format_Number(Win_Streak_V.Value) .. ""
			KO_Txt.Text = Format_Number(Punch_KO_V.Value + Kick_KO_V.Value) .. ""
			Elo_Icon.Image = Elo_Data['Icon']
			Elo_Icon.ImageColor3 = Elo_Data['Color']
			Elo_Txt.Text = Format_Number(Elo_V.Value) .. ""
			Elo_Txt.TextColor3 = Elo_Data['Color']
			Tab.BackgroundColor3 = Elo_Data['Color']
			
			Punch_KO_V.Changed:Connect(function()
				KO_Txt.Text = Format_Number(Punch_KO_V.Value + Kick_KO_V.Value) .. ""
			end)
			
			Kick_KO_V.Changed:Connect(function()
				KO_Txt.Text = Format_Number(Punch_KO_V.Value + Kick_KO_V.Value) .. ""
			end)
			
			Win_Streak_V.Changed:Connect(function()
				local New_V = Win_Streak_V.Value or 0
				Tab:SetAttribute("Win_Streak", New_V)
				Streak_Txt.Text = Format_Number(New_V) .. ""
				Update_Win_Streak_Crown()
			end)
			
			Elo_V.Changed:Connect(function()
				local New_V = Elo_V.Value or 400
				local Elo_Key, Elo_Data = Elo_Mod.Get_Elo_Data_From_Val(New_V)
				Tab:SetAttribute("Elo", New_V)
				Elo_Icon.Image = Elo_Data['Icon']
				Elo_Icon.ImageColor3 = Elo_Data['Color']
				Elo_Txt.Text = Format_Number(New_V) .. ""
				Elo_Txt.TextColor3 = Elo_Data['Color']
				Tab.BackgroundColor3 = Elo_Data['Color']
				Update_Elo_Order()
			end)
			
			Selected.MouseEnter:Connect(function()
				if(Debounce_E == false)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")
					Name_Txt.TextColor3 = Color3.fromRGB(34, 244, 68)
					Name_Txt:TweenPosition(UDim2.new(0.25, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
					
					Debounce_E = false
				end
			end)
			
			Selected.MouseLeave:Connect(function()
				Name_Txt.TextColor3 = Color3.new(1, 1, 1)
				Name_Txt:TweenPosition(UDim2.new(0.25, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
			end)
			
			Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					
					Open_Stats:Fire(Plr)
					
					task.wait(0.25)
					Debounce_C = false
				end
			end)
			
			Tab.Visible = true
		end
	end
	
	local function Remove_Tab(Plr)
		local Tab = Tabs_F:FindFirstChild("Tab_" .. Plr.UserId)
		if(Tab ~= nil)then
			Tab:Destroy()
		end
		
		Update_Elo_Order()
		Update_Win_Streak_Crown()
	end
	
	local function On_Init()
		local All_P = game.Players:GetPlayers()
		for i = 1, #All_P do
			local Plr = All_P[i]
			if(Plr ~= nil and Tabs_F:FindFirstChild("Tab_" .. Plr.UserId) == nil)then
				Create_Player_Tab(Plr)
			end
		end
		
		Update_Win_Streak_Crown()
		Update_Elo_Order()
		
		game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
		Debounce_UI = true
	end
	On_Init()
	
	Update_Player_List.OnClientEvent:Connect(function(Plr, Did_Join)
		if(Did_Join == true and Tabs_F:FindFirstChild("Tab_" .. Plr.UserId) == nil)then
			Create_Player_Tab(Plr)
		elseif(Did_Join == false)then
			Remove_Tab(Plr)
		end
	end)
end
Core_List_Handle()

local function Toggle_Player_List_Handle()
	local function Toggle_Display(Should_Show)
		Debounce_UI = not Should_Show
		local Frame_Position = Should_Show and UDim2.new(1, 0, 0, 0) or UDim2.new(1, 275, 0, 0)
		Main_F:TweenPosition(Frame_Position, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.75, true, nil)
	end
	
	UIS.InputBegan:Connect(function(input, GPE)
		if((input.KeyCode == Enum.KeyCode.Tab or input.KeyCode == Enum.KeyCode.ButtonR3) and 
			Is_Chatbox_Typing:Invoke() == false)then
			
			Toggle_Display(Debounce_UI)
		end
	end)
	
	Toggle_Player_List.Event:Connect(function(Should_Show)
		Toggle_Display(Should_Show)
	end)

	Toggle_Side_Buttons.Event:Connect(function(Should_Show)	
		if Should_Show then
			if game.Players.LocalPlayer:GetAttribute("IsTutorialRunning") then
				return
			end
		end
		Main_F.Parent.Enabled = Should_Show
	end)
end
Toggle_Player_List_Handle()]]></ProtectedString>
							<string name="ScriptGuid">{4714AE1D-4DE0-40BB-AD54-D781D49DDDCA}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Player_List_UI.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXB145C9B8DDE043B8A10EAB94D02D29BF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">White_Crate_Fade_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX89E58B0E95654FB6B3714F706B64AD88">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")

-- Modules
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Show_White_Fade 		= Channels.Bindable_Events.Show_White_Fade

local Main_F = script.Parent.Main_F

local function Reset_UI(T)
	Main_F.Visible = false
	Main_F.Size = UDim2.new(1, 0, 1, 0)
	
	for i = 1, #T do
		if(T[i] ~= nil)then
			T[i].BackgroundTransparency = 1
		end
	end
end

local function Show_UI_Effects()
	local T = Main_F:GetChildren()
	Reset_UI(T)
	Main_F.Visible = true
	
	local function Show_White_Fade()
		local Tween_In = TweenInfo.new(0.075, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
		
		for i = 1, #T do
			if(T[i] ~= nil)then
				TS:Create(T[i], Tween_In, {BackgroundTransparency = 0}):Play()
			end
		end
		
		task.wait(0.075)
	end
	Show_White_Fade()
	
	local function Remove_Fade()
		local Tween_Remove = TweenInfo.new(0.075, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
		Main_F:TweenSize(UDim2.new(2, 0, 2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.075, true, nil)
		
		for i = 1, #T do
			if(T[i] ~= nil)then
				TS:Create(T[i], Tween_Remove, {BackgroundTransparency = 1}):Play()
			end
		end
		
		task.wait(0.075)
	end
	Remove_Fade()
	
	Reset_UI(T)
end

local function Set_Frame_Colors(Col)
	local All_T = Main_F:GetChildren()
	for i = 1, #All_T do
		local T = All_T[i]
		if(T ~= nil and T:IsA("Frame"))then
			T.BackgroundColor3 = Col
		end
	end
end

Show_White_Fade.Event:Connect(function(Col)
	Set_Frame_Colors(Col)
	Show_UI_Effects()
end)
]]></ProtectedString>
							<string name="ScriptGuid">{3F1EA708-4E37-4D04-8E1D-58A5CD8FEE82}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Crate_White_Fade_Client.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX879835CF65DD413D992E6CC770D66408">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Notification_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX840BA0C3A4184DD59E989120D89E7D71">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")
local Plr = game.Players.LocalPlayer

-- Modules
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod 			= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Display_Data_Client 		= Channels.Bindable_Events.Display_Data
local Display_Data_From_Server  = Channels.SC_Remote_Events.Display_Data

-- UI References
local Tabs_F = script.Parent.Tabs_F
local TMP = script.Parent.Txt_TMP
local Msg_Stack = {}
local Debounce_Msgs = false
local IsRunning = false

local function RecomputePositions()
	local children = Tabs_F:GetChildren()
	table.sort(children, function(a,b)
		return a.LayoutOrder < b.LayoutOrder
	end)

	for i, tab in ipairs(children) do
		local targetY = 0.875 - ((i - 1) * 0.12)
		TS:Create(tab, TweenInfo.new(0.25, Enum.EasingStyle.Quint), {
			Position = UDim2.new(0.5, 0, targetY, 0)
		}):Play()
	end
end

local function Create_New_Tab(Txt, Col)
	local Tab = TMP:Clone()
	Tab.Name = "Notif_" .. tick()
	Tab.LayoutOrder = tick()
	Tab.Text = Txt
	Tab.TextColor3 = Col or Color3.new(1,1,1)

	Tab.Parent = Tabs_F
	Tab.Size = UDim2.new(0.5, 0, 0, 0)
	Tab.Position = UDim2.new(0.5, 0, 0.875, 0)
	Tab.Visible = true

	SE_Mod.PlaySFX(Plr, "Click_SE")

	TS:Create(Tab, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0.5, 0, 0.1, 0)
	}):Play()

	-- Recompute all positions after adding
	RecomputePositions()

	task.delay(5, function()
		if not Tab.Parent then return end

		TS:Create(Tab, TweenInfo.new(0.2, Enum.EasingStyle.Quint, Enum.EasingDirection.In), {
			Size = UDim2.new(0,0,0,0)
		}):Play()

		Debris:AddItem(Tab, 0.2)

		task.delay(0.21, function()
			RecomputePositions()
		end)
	end)
end

local function Process_Msg()
	if IsRunning then return end
	IsRunning = true

	while #Msg_Stack > 0 do
		local m = table.remove(Msg_Stack, 1)
		Create_New_Tab(m.Text, m.Color)
		task.wait(0.2) -- petite latence pour éviter l'overlap à la frame
	end

	IsRunning = false
end

local function Process_Event(Txt, Color)
	local Data = {
		['Text'] = Txt,
		['Color'] = Color
	}
	table.insert(Msg_Stack, Data)

	if(Debounce_Msgs == false)then
		Process_Msg()
	end
end

Display_Data_Client.Event:Connect(function(Txt, Color)
	Process_Event(Txt, Color)
end)

Display_Data_From_Server.OnClientEvent:Connect(function(Txt, Color)
	Process_Event(Txt, Color)
end)]]></ProtectedString>
							<string name="ScriptGuid">{E9542371-528A-487D-964C-63733837474A}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Notification_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXD557B423DD8D4E58A7D223E6358AFB2C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">LeaderBoards_Filter_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX1D084065B59B4D4F8290889F11D71BEB">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Cam = game.Workspace.CurrentCamera
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Modules
local MenuButtons_Mod 			= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local PlayerUtils 				= require(RS:WaitForChild("Modules"):WaitForChild("PlayerUtils"))

-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 		= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Leaderboards_Filter	= Channels.Bindable_Events.Open_Leaderboards_Filter
local LeaderboardModeChanged 	= Channels.CS_Remote_Events.Leaderboard_Mode_Changed

-- UI references
local Main_F = script.Parent.Main_F
local Header = Main_F:WaitForChild("Header")
local Exit_B = Header:WaitForChild("Exit_B")
local Body = Main_F:WaitForChild("Body")
local Content = Body:WaitForChild("Stroke"):WaitForChild("Content")
local ModeSwitch_F = Content:WaitForChild("ModeSwitch_F")

local buttons = {
	Weekly = ModeSwitch_F:WaitForChild("Weekly_Btn"),
	Monthly = ModeSwitch_F:WaitForChild("Monthly_Btn"),
	AllTime = ModeSwitch_F:WaitForChild("AllTime_Btn"),
}

-- Hide AllTime button if player is not a developer
if not PlayerUtils.isDeveloper(LocalPlayer) then
	if buttons.AllTime then
		buttons.AllTime.Visible = false
		buttons.AllTime.Active = false
		buttons.AllTime = nil -- remove from logic
	end
end

local DEFAULT_FILTER = "Weekly"

-- Leaderboard base colors 
local MODE_VISUALS = {
	Weekly = {
		Color = Color3.fromRGB(196,124,57),
		Reflectance = 0.15,
	},
	Monthly = {
		Color = Color3.fromRGB(217,217,217),
		Reflectance = 0.2
	},
	AllTime = {
		Color = Color3.fromRGB(212,175,55),
		Reflectance = 0.25,
		Highlight = Color3.fromRGB(255,220,120),
		Text = "ALL TIME",
		TextColor = Color3.fromRGB(255,230,140)
	}
}

local INACTIVE_BG = Color3.fromRGB(40, 40, 40)

local ACTIVE_TEXT = Color3.fromRGB(255, 255, 255)
local INACTIVE_TEXT = Color3.fromRGB(180, 180, 180)

local LeaderboardsFolder = workspace
	:WaitForChild("Main_World_F")
	:WaitForChild("Gameplay")
	:WaitForChild("Objects")
	:WaitForChild("Leaderboards")

-- ProximityPrompt reference
local prompt = LeaderboardsFolder
	:WaitForChild("Best Elo")
	:WaitForChild("Base")
	:WaitForChild("ProximityPrompt")

-- UI states
local Debounce_E = false
local Debounce_C = false
local Debounce_UI = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)


local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	task.wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Codes_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Toggle_Side_Buttons:Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Show_UI()

	local function Reset_Display()
		Disconnect_Cons()
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.575, 0)
	

		local Codes_Blur = game.Lighting:FindFirstChild("Codes_Blurr")
		if(Codes_Blur ~= nil)then
			Codes_Blur:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()

	MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)

	local function Display_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Codes_Blurr"

		Toggle_Side_Buttons:Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

local function applyLeaderboardBaseColor(mode)

	for _, board in ipairs(LeaderboardsFolder:GetChildren()) do
		local base = board:FindFirstChild("Base")
		if base and base:IsA("BasePart") then
			
			local v = MODE_VISUALS[mode]
			base.Color = v.Color
			base.Material = Enum.Material.Metal
			base.Reflectance = v.Reflectance or 0.15

			if v.Highlight then
				local h = base:FindFirstChild("GoldHighlight") or Instance.new("Highlight")
				h.Name = "GoldHighlight"
				h.Parent = base
				h.FillTransparency = 1
				h.OutlineTransparency = 0.6
				h.OutlineColor = v.Highlight
			else
				local h = base:FindFirstChild("GoldHighlight")
				if h then h:Destroy() end
			end
		end
	end
end


Open_Leaderboards_Filter.Event:Connect(function()

	if(Debounce_UI == false)then
		Show_UI()
	else
		Remove_UI()
	end
end)


local function setButtonState(button, active, mode)
	local label = button:WaitForChild("TextLabel")

	if active then
		local v = MODE_VISUALS[mode]
		button.BackgroundColor3 = v.Color
		label.TextColor3 = ACTIVE_TEXT
	else
		button.BackgroundColor3 = INACTIVE_BG
		label.TextColor3 = INACTIVE_TEXT
	end
end

local function setActive(mode)
	for name, button in pairs(buttons) do
		setButtonState(button, name == mode, name)
	end
end

-- Default state
setActive(DEFAULT_FILTER)
applyLeaderboardBaseColor(DEFAULT_FILTER)

-- Click wiring
for mode, button in pairs(buttons) do
	if button then
		button.MouseButton1Click:Connect(function()
			setActive(mode)
			applyLeaderboardBaseColor(mode)
			LeaderboardModeChanged:FireServer(mode)
			Remove_UI()
		end)
	end
end

-- Open popup
prompt.Triggered:Connect(function()
	Open_Leaderboards_Filter:Fire()
end)]]></ProtectedString>
							<string name="ScriptGuid">{2E06B978-B56B-47C9-8B1E-990EBBC93158}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">LeaderBoards_Controller.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX932E822A732E4A6D8E08DEDC36039940">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Menus</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX4CFCC74CEF4348C0A8CB66DE0EB517C0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Codes_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX4D2040C89DA44C14A4AE48D141162CFF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Cam = game.Workspace.CurrentCamera

-- Modules
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Display_Data_E 		= Channels.Bindable_Events.Display_Data
local Toggle_Side_Buttons 	= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Codes			= Channels.Bindable_Events.Open_Codes
local Redeem_Code 			= Channels.CS_Remote_Functions.Redeem_Code

-- UI references
local Codes_F = script.Parent.Main_F
local Header = Codes_F:WaitForChild("Header")
local Exit_B = Header:WaitForChild("Exit_B")
local Body = Codes_F:WaitForChild("Body")
local Content = Body:WaitForChild("Stroke"):WaitForChild("Content")
local Redeem_B = Content.Send_Code_B
local Data_Txt = Content.Data_Box_F.Data_Txt_Box

-- UI states
local Debounce_E = false
local Debounce_C = false
local Debounce_UI = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)

local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Remove_UI()
	Disconnect_Cons()
	Codes_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	task.wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Codes_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Codes_F.Visible = false
	Codes_F.Position = UDim2.new(0.5, 0, 0.675, 0)
	Data_Txt.Text = ""

	Toggle_Side_Buttons:Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Show_UI()

	local function Reset_Display()
		Disconnect_Cons()
		Codes_F.Visible = false
		Codes_F.Position = UDim2.new(0.5, 0, 0.575, 0)
		Data_Txt.Text = ""

		local Codes_Blur = game.Lighting:FindFirstChild("Codes_Blurr")
		if(Codes_Blur ~= nil)then
			Codes_Blur:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()

	MenuButtons_Mod.Setup_Base_Button(Cons, Redeem_B, function()
		if(Data_Txt.Text ~= "")then
			local Code = string.upper(Data_Txt.Text)

			local Server_Response = Redeem_Code:InvokeServer(Code)
			Display_Data_E:Fire(Server_Response)
		else
			Display_Data_E:Fire("❌ Enter your Code!", Color3.new(1, 0, 0))
		end
	end)
	
	MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)

	local function Display_UI()
		Codes_F.Visible = true
		Codes_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Codes_Blurr"

		Toggle_Side_Buttons:Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

Open_Codes.Event:Connect(function()
	
	if(Debounce_UI == false)then
		Show_UI()
	else
		Remove_UI()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{3A7E2409-2864-463F-A35E-0BB7DEA9A8F1}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Codes_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX61587EDEA38E4783836E889ADA9DF0F5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Avatar_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX24DD172A533242708A634C7DDB8BE9A0">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local Cam = game.Workspace.CurrentCamera

-- Modules
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
-- Require submodules
local EquipmentPanel = require(script:WaitForChild("EquipmentPanel"))
local CombosPanel = require(script:WaitForChild("CombosPanel"))
local PlayerInfosPanel = require(script:WaitForChild("PlayerInfosPanel"))

local Channels = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 		= Channels.Bindable_Events.Toggle_Side_Buttons
local Toggle_Tutorial_OK_Button = Channels.Bindable_Events.Toggle_Tutorial_OK_Button
local Open_Combos 				= Channels.Bindable_Events.Open_Combos
local Open_Equipment 			= Channels.Bindable_Events.Open_Equipment
local Open_Appearance 			= Channels.Bindable_Events.Open_Appearance
local Save_Appearance 			= Channels.CS_Remote_Events.Save_Appearance

-- Data
local PD = Plr:WaitForChild("Player_Data")

-- UI References
local Core_UI = script.Parent.Main_F
local Exit_B = Core_UI.Header.Exit_B
local Header = Core_UI.Header
local Main_Data_F = Core_UI.Main_Data_F
local Top_Change_Buttons_F = Main_Data_F.Top_Change_Buttons_F
local Combination_F = Main_Data_F.Combination_F
local Combination_Select_F = Core_UI.Combination_Select_F
local Equipment_F = Main_Data_F.Equipment_F
local Appearance_F = Main_Data_F.Appearance_F

local Tabs_Data = {
	["equipment tab"] = {
		Frame =  Main_Data_F:WaitForChild("Equipment_F"),
		Show_Function = EquipmentPanel.Show
	}, 
	["combos tab"] = {
		Frame =Main_Data_F:WaitForChild("Combination_F"),
		Show_Function = CombosPanel.Show
	},
	["appearance tab"] = {
		Frame = Main_Data_F:WaitForChild("Appearance_F"),
		Show_Function = PlayerInfosPanel.Show
	}
}

-- Debounce variables
local Debounce_UI = false

-- Connections table
local Cons = {}
local function Disconnect_Cons()
    for i = 1, #Cons do
        if Cons[i] ~= nil then
            Cons[i]:Disconnect()
        end
    end
    table.clear(Cons)
end

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)

local function PositionWithAnimationPreview()
    Main_Data_F:TweenPosition(UDim2.new(0.33, 0 ,0.53, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
    Header:TweenPosition(UDim2.new(0.33, 0,0.11, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
end

local function InitialPositions()
    Main_Data_F:TweenPosition(UDim2.new(0.5, 0, 0.53, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
    Header:TweenPosition(UDim2.new(0.5, 0, 0.11, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
end


local function Before_Closing_Tab()
	InitialPositions()
	Combination_Select_F.Visible = false
	
	task.spawn(function()
		Save_Appearance:FireServer(
			Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text, 
			Appearance_F.Country_F.Country_Txt.Text, 
			Appearance_F.Skin_Tone_F.Skin_Tone_Txt.Text,
			(Appearance_F.BodyType_F.Frame.Male_B.UIStroke.Enabled and "Male") or (Appearance_F.BodyType_F.Frame.Female_B.UIStroke.Enabled and "Female") or ""
		)
	end)
	
	
	task.wait(0.25)
end

local function Remove_UI()
    Disconnect_Cons()
    Core_UI:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
    TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	Before_Closing_Tab()
	
    Core_UI.Visible = false
    Core_UI.Position = UDim2.new(0.5, 0, 0.675, 0)
    Combination_Select_F.Visible = false
    local Blur = game.Lighting:FindFirstChild("Inventory_Blurr")
    if Blur ~= nil then
        Blur:Destroy()
    end
    Cam.FieldOfView = 70
    Toggle_Side_Buttons:Fire(true, true)
    Toggle_Tutorial_OK_Button:Fire(true)
    Debounce_UI = false
end

local function Set_Init_Cam_Effects()
	Disconnect_Cons()
	Core_UI.Visible = false
	Core_UI.Position = UDim2.new(0.5, 0, 0.575, 0)
	local Inv_Blurr = game.Lighting:FindFirstChild("Inventory_Blurr")
	if Inv_Blurr ~= nil then
		Inv_Blurr:Destroy()
	end
	Cam.FieldOfView = 70
	Core_UI.Visible = true
	Core_UI:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
	local Blur = Instance.new("BlurEffect", game.Lighting)
	Blur.Name = "Inventory_Blurr"
	Toggle_Side_Buttons:Fire(false, true)
	Toggle_Tutorial_OK_Button:Fire(false)
end


-- Build context for submodules
local context = {
	-- Player Data
	PD = PD,
	-- UI References
    Equipment_F = Equipment_F,
    Combination_F = Combination_F,
    Combination_Select_F = Combination_Select_F,
	Appearance_F = Appearance_F,
	-- UI Functions
    InitialPositions = InitialPositions,
	PositionWithAnimationPreview = PositionWithAnimationPreview,
	Remove_UI = Remove_UI
}

-- Set up combinations and equipment panels
CombosPanel:SetUp(context)
EquipmentPanel:SetUp(context)
PlayerInfosPanel:SetUp(context)

-- Display UI function
local function Display_UI(open)
    if Core_UI.Visible == false then
        
		Set_Init_Cam_Effects()
		
		-- Tabs and Exit buttons handlers based on Tabs table
		for Tab_B_Name, Tab_Data in pairs(Tabs_Data) do
			local Tab_B = Top_Change_Buttons_F:FindFirstChild(Tab_B_Name)
			if Tab_B:IsA("ImageButton") then
				MenuButtons_Mod.Setup_Tab_Button(Cons, Tab_B, Top_Change_Buttons_F, Tabs_Data, Before_Closing_Tab)
			end	
		end
		
		MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)
		
		-- Activated the called tab
		if open == "Avatar" then
			MenuButtons_Mod.Activate_Tab("equipment tab", Top_Change_Buttons_F, Tabs_Data, Before_Closing_Tab) 
		elseif open == "Combos" then
			MenuButtons_Mod.Activate_Tab("combos tab", Top_Change_Buttons_F, Tabs_Data, Before_Closing_Tab) 
		elseif open == "Appearance" then
			MenuButtons_Mod.Activate_Tab("appearance tab", Top_Change_Buttons_F, Tabs_Data, Before_Closing_Tab) 
		end
    end
end

-- Connect open events
Open_Combos.Event:Connect(function()
    if Debounce_UI == false then
        Debounce_UI = true
        Display_UI("Combos")
    else
        Remove_UI()
    end
end)

Open_Equipment.Event:Connect(function()
    if Debounce_UI == false then
        Debounce_UI = true
        Display_UI("Avatar")
    else
        Remove_UI()
    end
end)

Open_Appearance.Event:Connect(function()
    if Debounce_UI == false then
        Debounce_UI = true
        Display_UI("Appearance")
    else
        Remove_UI()
    end
end)]]></ProtectedString>
							<string name="ScriptGuid">{8D1E3E9D-9C88-4523-A79B-DB9C61244D50}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Avatar_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXAAD28F935B0F4E15BBED86E4E4F5F6EA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Avatar_Handle</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXF0D676E7DA3946249B4268B449A5006E">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--====================================================--
-- // COMBOS PANEL MODULE
-- // Handles Combo UI, Animation Previews & Data Sync
--====================================================--

local CombosPanel = {}

--------------------------------------------------------
-- // SERVICES & DEPENDENCIES
--------------------------------------------------------
local RS   = game:GetService("ReplicatedStorage")
local Plr  = game.Players.LocalPlayer

--------------------------------------------------------
-- // CHANNELS & EVENTS
--------------------------------------------------------
local Channels              = require(RS.Modules.Channels)
local Reset_Sequence        = Channels.CS_Remote_Events.Reset_Sequence
local Display_Data_E        = Channels.Bindable_Events.Display_Data
local Combo_Action_Request  = Channels.CS_Remote_Functions.Combo_Action_Request

--------------------------------------------------------
-- // MODULES & DATA
--------------------------------------------------------
local Data_Mods_F   = RS:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))

local Combination_Data = Animation_Mod.Get_Combinations("Combination")
local Punch_Data       = Animation_Mod.Get_Combinations("Punch")
local Kick_Data        = Animation_Mod.Get_Combinations("Kick")
local Emotes_Data      = Animation_Mod.Get_Combinations("Emotes")
local Submission_Data  = Animation_Mod.Get_Combinations("Submission")
local Takedown_Data    = Animation_Mod.Get_Combinations("Takedown")

--------------------------------------------------------
-- // STATE VARIABLES
--------------------------------------------------------
local cons = {}
local Selected_Combo, Selected_Strike, Selected_Action = nil, nil, nil
local Selected_Player_Data_Entry, Selected_Action_Type = nil, nil
local Debounce_S, Debounce_R, Debounce_T = false, false, false
local context = nil
local Combo_Main_F, Side_Tabs_F, Preview_F = nil, nil, nil
local Reset_F = nil

--------------------------------------------------------
-- // DEFAULT COMBOS
--------------------------------------------------------
local Default_Strikes = {
	['Punch Combo'] = "C,A,B,C,A,G",
	['Kick Combo']  = "F,D,E,F,J,H",
	['Submission Key'] = "A",
	['Fight Intro Key']   = "A",
	['Fight Outro Key']   = "A",
}

--------------------------------------------------------
-- // UTILITY FUNCTIONS
--------------------------------------------------------

-- Disconnect all event connections
local function DisconnectCons()
	for _, c in ipairs(cons) do
		c:Disconnect()
	end
	table.clear(cons)
end

-- Stop all animations on animator
local function StopAnimations(animator)
	for _, tr in pairs(animator:GetPlayingAnimationTracks()) do
		tr:Stop()
		tr:Destroy()
	end
end

-- Play an animation and return its track
local function PlayAnimation(animator, animId)
	StopAnimations(animator)
	local anim = Instance.new("Animation")
	anim.AnimationId = "rbxassetid://" .. tostring(animId)
	local track = animator:LoadAnimation(anim)
	track.Looped = true
	track:Play()
	return anim, track
end

-- Display locked UI for locked actions
local function HandleLockUI(frame, value)
	frame.Visible = true
	--frame.Combo_Name_Txt.Text = value["Name"]
	Display_Data_E:Fire("❗ This Move is Currently Locked! Unlock it via Achievement or Shop!", Color3.fromRGB(225, 0, 0))
	frame.Price_F.Visible = false
	
	--if value["Price"] > 0 then
	--	frame.Price_F.Visible = true
	--	frame.Price_F.Price_Txt = value["Price"]
	--end
end

local function Remove_Strike_Selection()
	if Selected_Combo and Selected_Strike then
		Combo_Main_F[Selected_Combo][Selected_Strike].Action_Title_Selected.Visible = false
		Selected_Strike = nil
	end
end

local function Close_Preview_F()
	Preview_F.Visible = false
	Remove_Strike_Selection()
	Selected_Combo, Selected_Strike, Selected_Action = nil, nil, nil
	context.InitialPositions()
end

local function Activate_Tab(Tab_Name, Frame_Name, Player_Data_Entry, Action_Type)
	for _, tab in ipairs(Side_Tabs_F:GetChildren()) do
		if tab:IsA("ImageButton") then
			tab.BackgroundTransparency = (tab.Name == Tab_Name) and 0 or 1
		end
	end

	for _, frame in ipairs(Combo_Main_F:GetChildren()) do
		if frame:IsA("Frame") then
			frame.Visible = (frame.Name == Frame_Name)
		end
	end

	Close_Preview_F()
	if Player_Data_Entry and Action_Type then 
		Selected_Action_Type = Action_Type
		Selected_Player_Data_Entry = Player_Data_Entry
		Reset_F.Visible = true
	else
		Selected_Action_Type = nil
		Selected_Player_Data_Entry = nil
		Reset_F.Visible = false
	end
	Selected_Combo = Frame_Name
	Selected_Strike = nil
end

-- Update UI frame text/icons with action data
local function Get_Icon_Indication(Action_Data)
	if not Action_Data["Icon"] then
		if Action_Data["Punch"] then
			return "rbxassetid://79720394914031"
		else
			return "rbxassetid://136568604314712"
		end
	else 
		return Action_Data["Icon"]
	end
end

local function Get_Time_Indication(Action_Data)
	if not Action_Data["Time Length"] then
		return ""
	else
		local Time_Length = Action_Data["Time Length"]
		if Time_Length<0.5 then
			return "⏱️🟩⬜⬜"
		elseif Time_Length <0.61 then
			return "⏱️🟩🟩⬜"
		else
			return "⏱️🟩🟩🟩"
		end
	end
end

local function Get_Damage_Indication(Action_Data)
	if not Action_Data["Damage"] then
		return ""
	else 
		return "-"..Action_Data["Damage"].."Pts 💥"
	end
end

local function Update_Action_Frame(Action_Frame, Action_Data)
	if (Action_Data) then
		Action_Frame.Action_Name_Txt.Text = Action_Data["Name"]
		Action_Frame.Icon_Img.Image = Get_Icon_Indication(Action_Data)
		Action_Frame.Action_Multi_Txt.Text  = Get_Damage_Indication(Action_Data)
		Action_Frame.Action_Length_Txt.Text = Get_Time_Indication(Action_Data)
	end
end

--------------------------------------------------------
-- // DATA MAPPING
--------------------------------------------------------

local function Get_Action_Data_List(Action_Type)
	if(Action_Type == "Punch") then
		return Punch_Data
	elseif(Action_Type == "Kick") then
		return Kick_Data
	elseif(Action_Type == "Strike") then
		return Combination_Data
	elseif(Action_Type == "Takedown") then
		return Takedown_Data
	elseif(Action_Type == "Submission") then
		return Submission_Data
	elseif(Action_Type == "Emote") then
		return Emotes_Data
	end
end

local function Get_Action_Data_From_Key(Action_Type, Action_Key)
	return Get_Action_Data_List(Action_Type)[Action_Key]
end

local function Get_Action_ID(action_type, value)
	if action_type == "Submission" then
		return value["Submission ID"]
	elseif action_type == "Takedown" then
		return value["Takedown ID"]
	else
		return value["ID"]
	end
end


local function Reset_Selected_Combo()

	if Selected_Player_Data_Entry ~= nil then
		local Default_Value = Default_Strikes[Selected_Player_Data_Entry]
		Reset_Sequence:FireServer(Selected_Player_Data_Entry, Default_Value)

		local strikes = Default_Value:split(",")
		for i, Action_Key in ipairs(strikes) do
			local Action_Data = Get_Action_Data_From_Key(Selected_Action_Type, Action_Key)
			Update_Action_Frame(Combo_Main_F[Selected_Combo]["Action_F_"..i], Action_Data)
		end
	end
end
--------------------------------------------------------
-- // ACTION BUTTONS & PREVIEW
--------------------------------------------------------
local function GenerateActionTabs(actionType)
	local animator = Preview_F.Animation_Preview_F.VF.WM.Model.Humanoid:FindFirstChild("Animator")
	local overview = Preview_F.Animation_Preview_F
	
	local listData = Get_Action_Data_List(Selected_Action_Type)
	
	for key, value in pairs(listData) do
		if value then
			local unlocked = Animation_Mod.Player_Owns_Action(Plr, actionType, key) or value["Price"] == 0
			local Action_Button = Preview_F.Action_Select_F.Action_Data_F.Tab_TMP:Clone()
			Action_Button.Name = value["Name"]
			Action_Button.Strike_Name_Txt.Text = (unlocked and "" or "🔒 ").. value["Name"]
			Action_Button.Parent = Preview_F.Action_Select_F.Action_Data_F.Tabs_F
			Action_Button.Visible = true
			table.insert(cons, Action_Button.Selected.MouseButton1Click:Connect(function()
				if Debounce_T then return end
				Debounce_T = true

				local Locked_F = Preview_F.Animation_Preview_F.Locked_F
				if unlocked then
					Locked_F.Visible = false
					Selected_Action = key
				else
					HandleLockUI(Locked_F, value)
					Selected_Action = nil
				end

				for _, tab in ipairs(Preview_F.Action_Select_F.Action_Data_F.Tabs_F:GetChildren()) do
					if tab:IsA("Frame") then
						tab:FindFirstChild("Selection").Visible = false
					end
				end
				Action_Button:FindFirstChild("Selection").Visible = true
				
				local id = Get_Action_ID(actionType, value)
				local anim, track = PlayAnimation(animator, id)
				overview.Action_Multi_Txt.Text  = Get_Damage_Indication(value)
				overview.Action_Length_Txt.Text = Get_Time_Indication(value)
				track:AdjustSpeed(actionType == "Submission" or actionType == "Takedown" and 0 or 0.5)

				task.wait(0.5)
				Debounce_T = false
			end))
		end
	end
end


--------------------------------------------------------
-- // COMBO PREVIEW HANDLER
--------------------------------------------------------

function CombosPanel:Load_Combination()
	local animator = Preview_F.Animation_Preview_F.VF.WM.Model.Humanoid:FindFirstChild("Animator")
	local overview = Preview_F.Animation_Preview_F

	-- Clear old tabs & animations
	for _, c in ipairs(Preview_F.Action_Select_F.Action_Data_F.Tabs_F:GetChildren()) do
		if c:IsA("Frame") then c:Destroy() end
		overview.Action_Multi_Txt.Text  = "" 
		overview.Action_Length_Txt.Text = ""
	end
	StopAnimations(animator)
	DisconnectCons()

	-- Load proper list based on combo type
	if not Selected_Combo then return end
	GenerateActionTabs(Selected_Action_Type)

	-- Equip / Close handlers
	table.insert(cons, Preview_F.Equip_B.MouseButton1Click:Connect(function()
		if context.Click_SE then context.Click_SE:Play() end
		if Selected_Action then
			local Strike_Index = tonumber(Selected_Strike:match("%d+"))
			local result = Combo_Action_Request:InvokeServer(Selected_Player_Data_Entry, Strike_Index, Selected_Action_Type, Selected_Action)
			if result then
				local Action_Data = Get_Action_Data_From_Key(Selected_Action_Type, Selected_Action)
				Update_Action_Frame(Combo_Main_F[Selected_Combo][Selected_Strike], Action_Data)
			end
		end
	end))

	table.insert(cons, Preview_F.Close_B.MouseButton1Click:Connect(function()
		Close_Preview_F()
	end))
end


--------------------------------------------------------
-- // COMBO FRAME CREATION
--------------------------------------------------------

local function Setup_Action_Frame(Action_Key, Player_Data_Entry, Container_Frame, Action_Type, Action_Template, Action_Name, Order)
	
	local Action_Data = Get_Action_Data_From_Key(Action_Type, Action_Key)
	
	local Action_Frame = Action_Template:Clone()
	Action_Frame.Parent = Container_Frame
	Action_Frame.Name = "Action_F_"..Action_Name
	Action_Frame.LayoutOrder = Order
	Action_Frame.Action_Title.text.Text = Action_Name
	Action_Frame.Action_Title_Selected.text.Text = Action_Frame.Action_Title.text.Text
	Action_Frame.Action_Title_Selected.Visible = false
	Update_Action_Frame(Action_Frame, Action_Data)
	Action_Frame.Visible = true

	Action_Frame.Selected.MouseButton1Click:Connect(function()
		if Debounce_S then return end
		Debounce_S = true
		Remove_Strike_Selection()

		Selected_Strike, Selected_Combo = Action_Frame.Name, Container_Frame.Name
		Selected_Player_Data_Entry, Selected_Action_Type = Player_Data_Entry , Action_Type
		CombosPanel:Load_Combination()
		Combo_Main_F[Selected_Combo][Selected_Strike].Action_Title_Selected.Visible = true

		context.PositionWithAnimationPreview()
		task.wait(0.7)
		Preview_F.Visible = true
		Debounce_S = false
	end)
end

local function Setup_Combo_Frame(Combo_Value, Player_Data_Entry, Combo_Frame, Action_Type, Action_Template)
	local strikes = Combo_Value:split(",")
	for i, Action_Key in ipairs(strikes) do
		Setup_Action_Frame(Action_Key, Player_Data_Entry, Combo_Frame, Action_Type, Action_Template, i, i)
	end
end

--------------------------------------------------------
-- // INITIAL SETUP
--------------------------------------------------------

function CombosPanel:SetUp(ctx)
	context = ctx
	Combo_Main_F = context.Combination_F.Main_Data_F
	Side_Tabs_F  = context.Combination_F.Side_Tabs_F
	Preview_F    = context.Combination_Select_F
	Reset_F 	 = Combo_Main_F.Reset_F

	-- Player data
	local Player_Punch_Combo      = context.PD:FindFirstChild("Punch Combo").Value
	local Player_Kick_Combo       = context.PD:FindFirstChild("Kick Combo").Value
	local Player_Intro_Action     = context.PD:FindFirstChild("Fight Intro Key").Value
	local Player_Takedown_Action  = context.PD:FindFirstChild("Takedown Key").Value
	local Player_Outro_Action     = context.PD:FindFirstChild("Fight Outro Key").Value


	-- UI references
	local Punch_Combo_F = Combo_Main_F.Punch_Combo_F
	local Kick_Combo_F  = Combo_Main_F.Kick_Combo_F
	local Animations_F  = Combo_Main_F.Animations_F
	local Action_Template = Combo_Main_F.TMP_Tab

	-- Setup frames
	Setup_Combo_Frame(Player_Punch_Combo, "Punch Combo", Punch_Combo_F, "Punch", Action_Template)
	Setup_Combo_Frame(Player_Kick_Combo, "Kick Combo", Kick_Combo_F, "Kick", Action_Template)
	
	Setup_Action_Frame(Player_Intro_Action, "Fight Intro Key", Animations_F, "Emote",  Action_Template, "FIGHT INTRO", 1)
	Setup_Action_Frame(Player_Takedown_Action, "Submission Key", Animations_F, "Submission", Action_Template, "SUBMISSION", 3)
	Setup_Action_Frame(Player_Outro_Action, "Fight Outro Key", Animations_F, "Emote",  Action_Template, "FIGHT OUTRO", 4)

	-- Tab button handlers
	MenuButtons_Mod.Setup_Base_Button({}, Side_Tabs_F["punch"],       function()      Activate_Tab("punch", "Punch_Combo_F", "Punch Combo", "Punch") end)
	MenuButtons_Mod.Setup_Base_Button({}, Side_Tabs_F["kick"],        function()      Activate_Tab("kick", "Kick_Combo_F", "Kick Combo", "Kick") end)
	MenuButtons_Mod.Setup_Base_Button({}, Side_Tabs_F["animations"],  function()      Activate_Tab("animations", "Animations_F") end)
	
	--Setup Reset button
	MenuButtons_Mod.Setup_Colored_Button({}, Reset_F.Reset_B, Color3.new(0.772549, 0, 0),  Reset_Selected_Combo)

	-- Activate default tab
	Activate_Tab("punch", "Punch_Combo_F", "Punch Combo", "Punch")
end

--------------------------------------------------------
-- // RETURN MODULE
--------------------------------------------------------
return CombosPanel
]]></ProtectedString>
								<string name="ScriptGuid">{2C4FA236-C327-41AE-B8CB-537A856DC35F}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">CombosPanel.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC149828D8C514933BA1EE71D8C617F04">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")

-- References
local Plr = game.Players.LocalPlayer

-- Modules
local Data_Mods_F 		= RS:WaitForChild("Data_Mods_F")
local Utils 			= require(game.ReplicatedStorage.Modules.Utils)
local Clothing_Mod 		= require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Offers_Config 	= require(Data_Mods_F:WaitForChild("Offers_Config"))
local Sound_Mod 	= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))


local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Avatar_Clothing_Request 	= Channels.CS_Remote_Functions.Avatar_Clothing_Request
local Open_Shop_UI 				= Channels.Bindable_Events.Open_Shop_UI


local ctx = nil
local Equipment_F = nil

-- Catalog of Items
local Gloves = game.ReplicatedStorage.Models.Clothing_F.Gloves_F
local Shorts = game.ReplicatedStorage.Models.Clothing_F.Shorts_F

-- Sorted and Personal data on items
local Gloves_Data = nil
local Shorts_Data = nil

local EquipmentPanel = {}

local cons = {}

local function DisconnectCons()
	for _, c in ipairs(cons) do
		c:Disconnect()
	end
	table.clear(cons)
end

--// Sorting Method

local function sortItems(data, playerOwnsFunc, currentKey, isGlove)
	local items = {}
	for key, value in pairs(data) do
		local offer = Offers_Config.GetClothDataByKey(key, isGlove)
		local rarity = offer and offer.Rarity or "Common"
		table.insert(items, {
			key = key,
			name = value,
			owned = playerOwnsFunc(key),
			rarity = rarity,
		})
	end

	table.sort(items, function(a, b)
		if a.key == currentKey then return true end
		if b.key == currentKey then return false end
		if a.owned ~= b.owned then return a.owned end
		return Clothing_Mod.Get_Rarity_Order(a.rarity) < Clothing_Mod.Get_Rarity_Order(b.rarity)
	end)

	return items
end

local function Get_Sorted_Gloves_Data()
	return sortItems(
		Clothing_Mod.Get_Gloves_Data(),
		function(key) return Clothing_Mod.Player_Owns_Gloves_Key(Plr, key) end,
		Clothing_Mod.Get_Player_Current_Gloves(Plr),
		true
	)
end

local function Get_Sorted_Shorts_Data()
	return sortItems(
		Clothing_Mod.Get_Shorts_Data(),
		function(key) return Clothing_Mod.Player_Owns_Shorts_Key(Plr, key) end,
		Clothing_Mod.Get_Player_Current_Shorts(Plr),
		false
	)
end

Gloves_Data = Get_Sorted_Gloves_Data()
Shorts_Data = Get_Sorted_Shorts_Data()

function EquipmentPanel:Load_Equipment(equipment_type)
    -- Clear existing tabs and disconnect previous connections
	for _, child in ipairs(Equipment_F.Main_Data_F.Tabs_F:GetChildren()) do
        if child:IsA("Frame") then
            child:Destroy()
        end
    end
    DisconnectCons()

	if equipment_type == "Gloves" then
		Gloves_Data = Get_Sorted_Gloves_Data()
		
        local c = 0
		--for index, value in pairs(Gloves_Data) do
		for _, item in ipairs(Gloves_Data) do
			local index = item.key
			local value = item.name
			local owned = item.owned				
			
            c = c + 1
			local temp = Equipment_F.Main_Data_F.TMP_Tab:Clone()
			temp.Parent = Equipment_F.Main_Data_F.Tabs_F
            temp.LayoutOrder = c
            if index == "K" or index == "K1" then
                temp.LayoutOrder = 5
            end
            temp.Name = index
            temp = temp.Frame
			temp.Name_F.Name_Txt.Text = value
			
			local rarityColor = Clothing_Mod.Get_Rarity_Color(item.rarity)
			temp.UIStroke.Color = rarityColor
			
			local owns = Clothing_Mod.Player_Owns_Gloves_Key(Plr, index)
			if not owns then
				temp.Locked_F.Visible = true
			end
			
			temp.Visible = true
            local display = Gloves:FindFirstChild(value):Clone()
            local Viewport_Camera = Instance.new("Camera")
            if display:FindFirstChild("LeftHand") then
                for _, part in pairs(display:GetChildren()) do
                    if part:IsA("BasePart") and (part.Name == "LeftHand" or part.Name == "RightHand") then
                        local groupName = part.Name .. "M"
                        local group = display:FindFirstChild(groupName) or Instance.new("Model")
                        group.Name = groupName
                        group.Parent = display
                        part.Parent = group
                        part.Anchored = true
                    end
                end
                if display:FindFirstChild("LeftHandM") and display:FindFirstChild("RightHandM") then
					display:PivotTo(CFrame.new(0,0,0))
					display:ScaleTo(0.85)
					Utils.AlignGloves(display.LeftHandM, display.RightHandM)
					
                    for _, modelName in ipairs({"LeftHandM", "RightHandM"}) do
                        local model = display[modelName]
                        local hitbox = Instance.new("Part")
                        hitbox.Name = "Hitbox"
                        hitbox.Size = model:GetExtentsSize()
                        hitbox.CFrame = model:GetPivot()
                        hitbox.Anchored = true
                        hitbox.Transparency = 1
                        hitbox.CanCollide = false
                        hitbox.Parent = model
                        model.PrimaryPart = hitbox
                        for _, part in ipairs(model:GetChildren()) do
                            if part:IsA("BasePart") and part ~= model.PrimaryPart then
                                local weld = Instance.new("WeldConstraint")
                                weld.Part0 = model.PrimaryPart
                                weld.Part1 = part
                                weld.Parent = model.PrimaryPart
                                part.Anchored = false
                            end
                        end
					end
					
					Utils.AlignGloves(display.LeftHandM, display.RightHandM)
		
					if owns then
						Utils.SetupHoverRotation(temp, display.LeftHandM, 3)
						Utils.SetupHoverRotation(temp, display.RightHandM, -3)
					end
				end
				
                temp.VF.CurrentCamera = Viewport_Camera
                display.Parent = temp.VF.WorldModel
                temp.VF.WorldModel:PivotTo(CFrame.new(0,0,0))
                Viewport_Camera.Parent = temp.VF
                Viewport_Camera.CFrame = CFrame.new(0, -0.15, 1.6)
            end
			
			table.insert(cons, temp.Selected.MouseButton1Click:Connect(function()
				if Clothing_Mod.Get_Player_Current_Gloves(Plr) ~= index then
					if owns  then
	                    local result = Avatar_Clothing_Request:InvokeServer(equipment_type, index)
						if result == true then
							Sound_Mod.Play_Voice_Over("New_Look")
							
							Gloves_Data =  Get_Sorted_Gloves_Data()
							for i, item in ipairs(Gloves_Data) do
								local Frame = Equipment_F.Main_Data_F.Tabs_F:FindFirstChild(item.key)
								if(Frame) then
									Frame.LayoutOrder = i
								end
							end
												
							-- Reset all UIStroke to rarity color + normal thickness
							for _, child in ipairs(Equipment_F.Main_Data_F.Tabs_F:GetChildren()) do
								if child:IsA("Frame") then
									local itemList = (equipment_type == "Gloves") and Gloves_Data or Shorts_Data
									for _, i in ipairs(itemList) do
										if i.key == child.Name then			
											local rarityColor = Clothing_Mod.Get_Rarity_Color(i.rarity)
											child.Frame.UIStroke.Color = rarityColor
											child.Frame.UIStroke.Thickness = 2
											break
										end
									end
								end
							end

							-- Highlight the selected one
							temp.UIStroke.Thickness = 5			
						end
					else
						pcall(ctx.Remove_UI)
						Open_Shop_UI:Fire("Gloves")
					end
				end
            end))
		end
		
        local current = Clothing_Mod.Get_Player_Current_Gloves(Plr)
		
		local tab = Equipment_F.Main_Data_F.Tabs_F:FindFirstChild(current)
        if tab then
			tab.Frame.UIStroke.Thickness = 5
        end
	elseif equipment_type == "Shorts" then
		Shorts_Data = Get_Sorted_Shorts_Data()
        local c = 0
		
		for _, item in ipairs(Shorts_Data) do
			local index = item.key
			local value = item.name
			local owned = item.owned
		
		
			c = c + 1
			local temp = Equipment_F.Main_Data_F.TMP_Tab:Clone()
			temp.Parent = Equipment_F.Main_Data_F.Tabs_F
            temp.LayoutOrder = c
            temp.Name = index
            temp = temp.Frame
			temp.Name_F.Name_Txt.Text = value
		
			local rarityColor = Clothing_Mod.Get_Rarity_Color(item.rarity)
			temp.UIStroke.Color = rarityColor

			
			local owns = Clothing_Mod.Player_Owns_Shorts_Key(Plr, index)
			if not owns then
				temp.Locked_F.Visible = true
			end
			
            temp.Visible = true
            local display = Shorts:FindFirstChild(value):Clone()
            local Viewport_Camera = Instance.new("Camera")
            if display:FindFirstChild("LowerTorso") then
                display.PrimaryPart = display:FindFirstChild("LowerTorso")
            end
            display:PivotTo(CFrame.new(0,0,0))
            temp.VF.CurrentCamera = Viewport_Camera
            display.Parent = temp.VF.WorldModel
            temp.VF.WorldModel:PivotTo(CFrame.new(0,0,0))
            Viewport_Camera.Parent = temp.VF
            Viewport_Camera.CFrame = CFrame.new(0,-0.2,2)

			
			table.insert(cons, temp.Selected.MouseButton1Click:Connect(function()
				if Clothing_Mod.Get_Player_Current_Shorts(Plr) ~= index then
	                if owns then
	                    local result = Avatar_Clothing_Request:InvokeServer(equipment_type, index)
						if result == true then
							Sound_Mod.Play_Voice_Over("New_Look")
							
							Shorts_Data =  Get_Sorted_Shorts_Data()
							for i, item in ipairs(Shorts_Data) do
								local Frame = Equipment_F.Main_Data_F.Tabs_F:FindFirstChild(item.key)
								if(Frame) then
									Frame.LayoutOrder = i
								end
							end

							for _, child in ipairs(Equipment_F.Main_Data_F.Tabs_F:GetChildren()) do
								if child:IsA("Frame") then
									local itemList = (equipment_type == "Gloves") and Gloves_Data or Shorts_Data
									for _, i in ipairs(itemList) do
										if i.key == child.Name then
											
											local rarityColor = Clothing_Mod.Get_Rarity_Color(i.rarity)
											child.Frame.UIStroke.Color = rarityColor
											child.Frame.UIStroke.Thickness = 2
											break
										end
									end
								end
							end
							temp.UIStroke.Thickness = 5
						end
					else
						pcall(ctx.Remove_UI)
						Open_Shop_UI:Fire("Shorts")
					end
				end
            end))
        end
		
		-- Update UIStroke for the current shorts
		local current = Clothing_Mod.Get_Player_Current_Shorts(Plr)
		local tab = Equipment_F.Main_Data_F.Tabs_F:FindFirstChild(current)
        if tab then
			tab.Frame.UIStroke.Thickness = 5
        end
    end
end

local function Activate_Tab( Tab_Name, equipment_type)
	for _,tab in ipairs(ctx.Equipment_F.Top_Tabs_F:GetChildren()) do
		if tab:IsA("ImageButton") then
			if tab.Name == Tab_Name then
				tab.BackgroundTransparency = 0
			else
				tab.BackgroundTransparency = 1
			end
		end
	end

	EquipmentPanel:Load_Equipment(equipment_type)
end

function EquipmentPanel:SetUp(context)
	ctx = context
	Equipment_F = ctx.Equipment_F
	
    local UIGridLayout = Instance.new("UIGridLayout")
	UIGridLayout.Parent = Equipment_F.Main_Data_F.Tabs_F
    UIGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
    UIGridLayout.CellSize = UDim2.new(0.315, 0, 0.5, 0)
    UIGridLayout.CellPadding = UDim2.new(0.02, 0, 0.04, 0)
	
	MenuButtons_Mod.Setup_Base_Button({}, Equipment_F.Top_Tabs_F["Gloves Tab"], function() Activate_Tab( "Gloves Tab", "Gloves") end)
	MenuButtons_Mod.Setup_Base_Button({}, Equipment_F.Top_Tabs_F["Shorts Tab"], function() Activate_Tab( "Shorts Tab", "Shorts") end)
	
	Activate_Tab( "Gloves Tab","Gloves")
end

function EquipmentPanel:Show(ctx)
	Activate_Tab( "Gloves Tab","Gloves")
end

return EquipmentPanel
]]></ProtectedString>
								<string name="ScriptGuid">{15D2C024-64F6-4492-AD2F-AAD0732372F3}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">EquipmentPanel.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX057C79C489A042CD928129474B1F2260">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local PlayerInfosPanel = {}

-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")

-- References
local Plr  = game.Players.LocalPlayer

-- Modules
local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local Country_Mod = require(Data_Mods_F:WaitForChild("Country_Mod"))
local Skin_Tone_Mod = require(Data_Mods_F:WaitForChild("Skin_Tone_Mod"))

-- Data
local Country_Data 				= Country_Mod.Get_Country_Data()

-- Variables
local context = nil
local Appearance_F = nil
local cons = {}
local Can_Edit = false
local Toggle_DropDown = false

local function DisconnectCons()
    for _, c in ipairs(cons) do
        c:Disconnect()
    end
    table.clear(cons)
end

-- Body type change constraints
local MAX_DISTANCE_FROM_SPAWN = 50 

local function IsPlayerNearSpawn(player: Player): boolean
	local character = player.Character
	if not character then return false end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return false end

	local spawnLocation = workspace
		:WaitForChild("Main_World_F")
		:WaitForChild("Environment")
		:WaitForChild("Spawns")
		:WaitForChild("SpawnLocation")
	if not spawnLocation or not spawnLocation:IsA("BasePart") then return false end

	return (hrp.Position - spawnLocation.Position).Magnitude <= MAX_DISTANCE_FROM_SPAWN
end

local function Body_Type_Handle(Body_Type_V)
	
	-- cache buttons once
	local male_B   = Appearance_F.BodyType_F:WaitForChild("Frame"):WaitForChild("Male_B")
	local female_B = Appearance_F.BodyType_F:WaitForChild("Frame"):WaitForChild("Female_B")
	local Hint_Txt  = Appearance_F.BodyType_F:WaitForChild("Hint_Txt")

	local function ChangeEffect(Is_Male)
		local IsPlayerNearSpawn = IsPlayerNearSpawn(Plr)
		
		Hint_Txt.Visible = not IsPlayerNearSpawn
		male_B.UIStroke.Enabled   = IsPlayerNearSpawn and Is_Male
		female_B.UIStroke.Enabled = IsPlayerNearSpawn and not Is_Male
	end

	ChangeEffect(Body_Type_V.Value=="Male")


	table.insert(cons, male_B.MouseButton1Click:Connect(function()
		ChangeEffect(true)
	end))

	table.insert(cons, female_B.MouseButton1Click:Connect(function()
		ChangeEffect(false)
	end))
end

local function Skin_Tone_Handle(SkinTone_V)
	local Skin_Data = Skin_Tone_Mod.Get_Skin_Tone_Data()
	
	if SkinTone_V.Value then
		local strData = string.split(SkinTone_V.Value, ",")
		local R,G,B = tonumber(strData[1]), tonumber(strData[2]), tonumber(strData[3])
		for name, color in pairs(Skin_Data) do
			local r = math.round(color.R*255)
			local g = math.round(color.G*255)
			local b = math.round(color.B*255)
			if r == R and g == G and b == B then
				Appearance_F.Skin_Tone_F.Skin_Tone_Txt.Text = name
				Appearance_F.Skin_Tone_F.BackgroundColor3 = Color3.fromRGB(R,G,B)
				break
			end
		end
	end
	
	-- Skin tone dropdown
	table.insert(cons, Appearance_F.Skin_Tone_F.Dropdown_B.MouseButton1Click:Connect(function()
		if not Toggle_DropDown then
			Toggle_DropDown = true
			Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
			Appearance_F.Drop_Down_Data_F.Position = UDim2.new(1,0,0.475,0)
			Appearance_F.Drop_Down_Data_F.Size = UDim2.new(0.375,0,0,0)
			Appearance_F.Drop_Down_Data_F.Visible = true
			local y = 0
			for color_name, color in pairs(Skin_Data) do
				local TMP = Appearance_F.Drop_Down_Data_F.TMP_Tab:Clone()
				TMP.Name = color_name
				TMP.Data_Txt.Text = color_name
				TMP.BackgroundColor3 = color
				TMP.Country_Flag_Img.Visible = false
				TMP.Position = UDim2.new(0,0,y,0)
				TMP.Parent = Appearance_F.Drop_Down_Data_F.Tabs_F
				TMP.Visible = true
				table.insert(cons, TMP.Selected.MouseButton1Click:Connect(function()
					Toggle_DropDown = false
					TS:Create(Appearance_F.Skin_Tone_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut), {Rotation = 0}):Play()
					Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
					task.wait(.2)
					Appearance_F.Drop_Down_Data_F.Visible = false
					Appearance_F.Skin_Tone_F.BackgroundColor3 = color
					Appearance_F.Skin_Tone_F.Skin_Tone_Txt.Text = color_name
				end))
				y = y + 0.3
			end
			Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
			TS:Create(Appearance_F.Skin_Tone_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut), {Rotation = 180}):Play()
		elseif Toggle_DropDown and Appearance_F.Skin_Tone_F.Dropdown_B.Rotation == 180 then
			Toggle_DropDown = false
			TS:Create(Appearance_F.Skin_Tone_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut), {Rotation = 0}):Play()
			Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
			task.wait(.2)
			Appearance_F.Drop_Down_Data_F.Visible = false
			Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
		end
	end))
end

local function Bio_Handle(Bio_V)
	Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text = Bio_V.Value or ""
	
	local ogText = Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text
	table.insert(cons, Appearance_F.Bio_F.Data_F.Data_Box_Txt:GetPropertyChangedSignal("Text"):Connect(function()
		local textLen = string.len(Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text)
		if Can_Edit then
			if textLen >= 25 then
				Can_Edit = false
				ogText = Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text
				Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text = ogText
				task.wait()
			end
		else
			if textLen < 25 then
				Can_Edit = true
			elseif textLen >= 25 then
				Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text = ogText
				task.wait()
			end
		end
	end))
end

local function Country_Handle()
	local country, img = Country_Mod.Get_Player_Country_Data(Plr)
	Appearance_F.Country_F.Country_Flag_Img.Image = img
	Appearance_F.Country_F.Country_Txt.Text = country
	
	-- Country dropdown
	table.insert(cons, Appearance_F.Country_F.Dropdown_B.MouseButton1Click:Connect(function()
		if not Toggle_DropDown then
			Toggle_DropDown = true
			Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
			Appearance_F.Drop_Down_Data_F.Position = UDim2.new(1,0,0.225,0)
			Appearance_F.Drop_Down_Data_F.Size = UDim2.new(0.375,0,0,0)
			Appearance_F.Drop_Down_Data_F.Visible = true
			local y = 0
			local keys = {}
			for k in pairs(Country_Data) do
				table.insert(keys, k)
			end
			table.sort(keys)
			for _, country_name in pairs(keys) do
				local image = Country_Data[country_name]
				local TMP = Appearance_F.Drop_Down_Data_F.TMP_Tab:Clone()
				TMP.Name = country_name
				TMP.Data_Txt.Text = country_name
				TMP.Country_Flag_Img.Image = image
				TMP.Position = UDim2.new(0,0,y,0)
				TMP.Parent = Appearance_F.Drop_Down_Data_F.Tabs_F
				TMP.Visible = true
				table.insert(cons, TMP.Selected.MouseButton1Click:Connect(function()
					Toggle_DropDown = false
					TS:Create(Appearance_F.Country_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut), {Rotation = 0}):Play()
					Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
					task.wait(.2)
					Appearance_F.Drop_Down_Data_F.Visible = false
					Appearance_F.Country_F.Country_Flag_Img.Image = image
					Appearance_F.Country_F.Country_Txt.Text = country_name
				end))
				y = y + 0.3
			end
			Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
			TS:Create(Appearance_F.Country_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut), {Rotation = 180}):Play()
		elseif Toggle_DropDown and Appearance_F.Country_F.Dropdown_B.Rotation == 180 then
			Toggle_DropDown = false
			TS:Create(Appearance_F.Country_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut), {Rotation = 0}):Play()
			Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
			task.wait(.2)
			Appearance_F.Drop_Down_Data_F.Visible = false
			Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
		end
	end))
end

function PlayerInfosPanel:Load_Appearance()
    local Bio_V = context.PD:WaitForChild("Bio")
	local SkinTone_V = context.PD:WaitForChild("Skin Tone")
	local Body_Type_V = context.PD:WaitForChild("Body Type")
	DisconnectCons()
    
    
    Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
    Appearance_F.Drop_Down_Data_F.Size = UDim2.new(0.375,0,0,0)
	Appearance_F.Drop_Down_Data_F.Visible = false
	
	Body_Type_Handle(Body_Type_V)
	Skin_Tone_Handle(SkinTone_V)
	Bio_Handle(Bio_V)
	Country_Handle()

end

function PlayerInfosPanel:SetUp(ctx)
	context = ctx
	Appearance_F = context.Appearance_F
end

function PlayerInfosPanel:Show()
	PlayerInfosPanel:Load_Appearance()
end

return PlayerInfosPanel
]]></ProtectedString>
								<string name="ScriptGuid">{7E84F28F-5C1F-48C1-BF99-8E134F965AFD}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">PlayerInfosPanel.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX614CCC15405A4981AEA798AE4B0EBE2C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Main_F</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX2BFE85D8DED147BCA0E48C55A6C4FD06">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Combination_Select_F</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXCCFC69FD2A484D6FA6E5C239A88B3FE6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Animation_Preview_F</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX829648C72DD845E6875DD6915559E915">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">VF</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBXBF1ECB01FC9A4F7BB4050EA16CBF6688">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">WM</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBX200E4EADB37747EC869FC945D18F5CA5">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Model</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBXA9BB01AA4B6644F2A367094E9E8D0726">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end


local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1


	local deltaTime = currentTime - lastTick
	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

	if (jumpAnimTime > 0) then
		jumpAnimTime = jumpAnimTime - deltaTime
	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			animStringValueObject.Parent = nil -- message received, delete StringValue
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end


-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
													<string name="ScriptGuid">{A9964B88-C1CD-44D2-A679-D2E2768DB58A}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Animate.client.lua</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX367EBE2DC359420BBAFC05833DCB2085">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Main_Data_F</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXA53342272BD3429BBC63BAA8697BBDD2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Appearance_F</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX10B0DE2F7FF54D4298D1C7B34C4DE33E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Gender_Preview_F</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX24DAD6A0206844888B6A4CB6B535BB58">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Male_VF</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBX21829F309B284D64A30BFCA1E7EEC190">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">WM</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="Folder" referent="RBXAD0FD952C25D4FDBB8D7B1231B2417E4">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Model_M</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX234152459D4B4E32B1E39647EA67AD90">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end


local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1


	local deltaTime = currentTime - lastTick
	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

	if (jumpAnimTime > 0) then
		jumpAnimTime = jumpAnimTime - deltaTime
	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			animStringValueObject.Parent = nil -- message received, delete StringValue
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end


-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
														<string name="ScriptGuid">{C7A66289-6E93-44D4-A63C-FFCA06602DF0}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Animate.client.lua</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
										</Item>
									</Item>
									<Item class="Folder" referent="RBX28F9C295E19347D9853FD8DBD03339EB">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Female_VF</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBXD1301DAE0CBD4CC7BD7E30922B39EB5C">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">WM</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="Folder" referent="RBX9BFACCF972144D24AF4796ACD6A3EA1D">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Model_F</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBXD168DAA54C4F4B24A9C3AF636423918A">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
														<string name="ScriptGuid">{C5FBA9A5-3C16-411E-B6CC-8257E0736EE6}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Animate.client.lua</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBX4FE0E29B6FDC4785B3D95C2DE70D008D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">BodyType_F</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX2FE66CFC7AD140A49F436326BEFC1E98">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Frame</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBXD8D2BCAD1D08450082FC69E3C6F9BDAA">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Female_B</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="Folder" referent="RBXD5622C91AD934E2ABFFC38F5BFF100E8">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Female_VF</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="Folder" referent="RBX59144572DA2042B5A6874D6388F4C12C">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">WM</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
													<Item class="Folder" referent="RBX1DEE812E0406438B9C505933F37FFAC9">
														<Properties>
															<BinaryString name="AttributesSerialize"></BinaryString>
															<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
															<bool name="DefinesCapabilities">false</bool>
															<string name="Name">Model_F</string>
															<int64 name="SourceAssetId">-1</int64>
															<BinaryString name="Tags"></BinaryString>
														</Properties>
														<Item class="ModuleScript" referent="RBX6D87F14BDB2241FEA61909D3AD29A9AB">
															<Properties>
																<Content name="LinkedSource"><null></null></Content>
																<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
																<string name="ScriptGuid">{1DECBFB9-7552-476A-96D3-4394803DF003}</string>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<bool name="DefinesCapabilities">false</bool>
																<string name="Name">Animate.client.lua</string>
																<int64 name="SourceAssetId">-1</int64>
																<BinaryString name="Tags"></BinaryString>
															</Properties>
														</Item>
													</Item>
												</Item>
											</Item>
										</Item>
										<Item class="Folder" referent="RBXD669F11A831B443691D14D059B72298C">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Male_B</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="Folder" referent="RBX9EA4979BA7DF479FB4B61564D7F50B04">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Male_VF</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="Folder" referent="RBX9D08431175A7446681784593269C5521">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">WM</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
													<Item class="Folder" referent="RBX320A3BFBD21E43BBA4F877A62C265F52">
														<Properties>
															<BinaryString name="AttributesSerialize"></BinaryString>
															<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
															<bool name="DefinesCapabilities">false</bool>
															<string name="Name">Model_M</string>
															<int64 name="SourceAssetId">-1</int64>
															<BinaryString name="Tags"></BinaryString>
														</Properties>
														<Item class="ModuleScript" referent="RBX62383F1503724A55AC43C690F4882DAA">
															<Properties>
																<Content name="LinkedSource"><null></null></Content>
																<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end


local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1


	local deltaTime = currentTime - lastTick
	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

	if (jumpAnimTime > 0) then
		jumpAnimTime = jumpAnimTime - deltaTime
	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			animStringValueObject.Parent = nil -- message received, delete StringValue
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end


-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
																<string name="ScriptGuid">{5FF3E7FD-A68B-44E2-B55F-3150524F4067}</string>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<bool name="DefinesCapabilities">false</bool>
																<string name="Name">Animate.client.lua</string>
																<int64 name="SourceAssetId">-1</int64>
																<BinaryString name="Tags"></BinaryString>
															</Properties>
														</Item>
													</Item>
												</Item>
											</Item>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX9A6643832CA84AB58886285050243FE5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">League_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX80DCB45142B34202AA369CF2461ADB5B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- StarterGui/Menus/League_UI/Client_League_Handle.client.lua
-- ==========================================================
-- TYPE: LocalScript (Client)
-- Unified handler for League + Tournament UI
-- ==========================================================

-- Services
local RunService 					= game:GetService("RunService")
local TS 							= game:GetService("TweenService")
local RS 							= game:GetService("ReplicatedStorage")
local Lighting 						= game:GetService("Lighting")
local Players						= game:GetService("Players")
local player 						= Players.LocalPlayer

-- Modules
local Data_Mods_F      				= RS:WaitForChild("Data_Mods_F")
local Global_Params_Mod				= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))

-- Centralized UI handler
local UI_Handler					= require(RS.Data_Mods_F.UI_LeagueTournament_Handler)

local MenuButtons_Mod 				= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 			= Channels.Bindable_Events.Toggle_Side_Buttons
local Tournament_Register			= Channels.CS_Remote_Events.Tournament_Register
local Open_Leagues 					= Channels.Bindable_Events.Open_Leagues
local Display_Data 			    	= Channels.Bindable_Events.Display_Data
local League_Portal_Teleport		= Channels.CS_Remote_Events.League_Portal_Teleport

-- UI references
local PlayerGui = player:WaitForChild("PlayerGui")
local MenusFolder = PlayerGui:WaitForChild("Menus")
local LeagueUI = MenusFolder:WaitForChild("League_UI")

local MainFrame = LeagueUI:WaitForChild("Main_F")
local Body = MainFrame:WaitForChild("Body"):WaitForChild("Stroke"):WaitForChild("Content")
local Exit_B = MainFrame:WaitForChild("Header"):WaitForChild("Exit_B")

-- League section
local LeagueSection = Body:WaitForChild("League_Section")
local LeagueLabel = LeagueSection:WaitForChild("LeagueLabel")
local RankLabel = LeagueSection:WaitForChild("RankLabel")
local WinsLabel = LeagueSection:WaitForChild("WinsLabel")

-- Buttons section
local Buttons_Section = Body:WaitForChild("Buttons_Section")
local RegisterButton = Buttons_Section:WaitForChild("Register_B")
local JoinButton = Buttons_Section:WaitForChild("Join_B")

-- Bind UI to centralized handler
UI_Handler:BindUI("LeagueTournament", LeagueUI)


local Cam = workspace.CurrentCamera
local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local Debounce_UI = false
local Cons = {}

MenuButtons_Mod.Setup_Base_Button(Cons, RegisterButton, function()
	Tournament_Register:FireServer()
end)

MenuButtons_Mod.Setup_Base_Button(Cons, JoinButton, function()
	-- Player must be registered to enter tournament mode
	if not UI_Handler.IsRegistered then
		-- Open League UI so the player can register
		Display_Data:Fire("You must first register to the league tournament", Color3.new(1, 0, 0))
		return
	end

	--TODO create RF GetCurrentLeagueRF and bind it into LeagueManager
	local division = "Bronze"
	
	if RunService:IsStudio() then
		Display_Data:Fire("You can't jump into ".. division .. " division in Studio mode", Color3.new(1, 0, 0))
	else
		League_Portal_Teleport:FireServer({
			mode = Global_Params_Mod.Server_Mode.TOURNAMENT,
			league = Global_Params_Mod.League.MMA_FIGHTERS,
			division = division
		})
	end

end)


local stats = UI_Handler:GetCurrentLeague()
if stats then
	LeagueLabel.Text = ("Current division: %s"):format(string.upper(tostring(stats.Division or "Bronze")))
	RankLabel.Text = ("Rank: %s"):format(stats.Rank or "-")
	WinsLabel.Text = ("Wins: %d"):format(stats.Wins or 0)
end


--====================================================
-- UI handling
--====================================================

local function Remove_UI()
	MainFrame:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	task.wait(0.25)

	local Blur = Lighting:FindFirstChild("Rewards_Blurr")
	if Blur then Blur:Destroy() end
	Cam.FieldOfView = 70
	LeagueUI.Enabled = false
	MainFrame.Position = UDim2.new(0.5, 0, 0.675, 0)
	Toggle_Side_Buttons:Fire(true, true)
	Debounce_UI = false
end

local function Display_UI()
	LeagueUI.Enabled = true
	MainFrame.Position = UDim2.new(0.5, 0, 0.675, 0)
	MainFrame.Visible = true
	MainFrame:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

	local Blur = Instance.new("BlurEffect")
	Blur.Name = "Rewards_Blurr"
	Blur.Parent = Lighting

	Toggle_Side_Buttons:Fire(false, true)
	Debounce_UI = true		
end

MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)

Open_Leagues.Event:Connect(function()
	if not Debounce_UI then
		Display_UI()
	else
		Remove_UI()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{ABB3C1B2-00B2-4D10-AAEC-145B7E364858}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_League_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXA56664625D774B62AD480230346A8E0E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Servers_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXC914FC8B46F14FAEBAC8E042FBBA5D0D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Cam = game.Workspace.CurrentCamera
local Plr = game.Players.LocalPlayer

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

local MenuButtons_Mod				= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))

local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Get_All_Server_Data			= Channels.CS_Remote_Functions.Get_All_Server_Data
local Update_All_Server_Data		= Channels.SC_Remote_Events.Update_All_Server_Data
local Teleport_To_Server			= Channels.CS_Remote_Functions.Teleport_To_Server
local Display_Data_E 				= Channels.Bindable_Events.Display_Data
local Toggle_Side_Buttons 			= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Servers 					= Channels.Bindable_Events.Open_Servers

-- UI References
local Main_F = script.Parent.Main_F
local Main_Data_F = Main_F.Main_Data_F
local Rank_B = Main_Data_F.Buttons_F.Rank_B
local Ranked_Wins_B = Main_Data_F.Buttons_F.Ranked_Wins_B
local Wins_B = Main_Data_F.Buttons_F.Wins_B
local Server_Size_B = Main_Data_F.Buttons_F.Server_Size_B
local Exit_B = Main_F.Header.Exit_B 
local Data_F = Main_Data_F.Data_F
local Tabs_F = Data_F.Tabs_F
local TMP_Tab = Data_F.Server_TMP
local Sort_Buttons = {Rank_B, Ranked_Wins_B, Server_Size_B, Wins_B}

local Debounce_C = false
local Debounce_E = false
local Debounce_UI = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if Cons[i] ~= nil then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local Core_Servers_Data = {}
task.spawn(function()
	Core_Servers_Data = Get_All_Server_Data:InvokeServer()	
end)

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

-- Transform dictionary into sorted array
local function Sort_Data_Handle(Data, Key)
	local Key_Vals = {
		['Rank'] = "Average Elo",
		['Ranked Wins'] = "Average Ranked Wins",
		['Wins'] = "Average Wins",
		['Server Size'] = "Server Size"
	}

	local Main_Key = Key_Vals[Key]

	if not Main_Key then
		return {}
	end

	local sorted = {}
	for _, v in pairs(Data) do
		table.insert(sorted, v)
	end

	table.sort(sorted, function(A, B)
		local A_Val = A[Main_Key] or 0
		local B_Val = B[Main_Key] or 0
		if Main_Key == "Server Size" then
			A_Val = #A[Main_Key]
			B_Val = #B[Main_Key]
		end
		return A_Val > B_Val
	end)

	return sorted
end

local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	task.wait(0.25)

	Tabs_F:ClearAllChildren()
	Data_F.CanvasPosition = Vector2.new(0, 0)

	local Blur = game.Lighting:FindFirstChild("Servers_Blurr")
	if Blur ~= nil then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Toggle_Side_Buttons:Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Display_UI()
	local function Reset_UI()
		Disconnect_Cons()
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)
		Tabs_F:ClearAllChildren()
		Data_F.CanvasPosition = Vector2.new(0, 0)
		Cam.FieldOfView = 70
		local Blur = game.Lighting:FindFirstChild("Servers_Blurr")
		if Blur ~= nil then
			Blur:Destroy()
		end
	end
	Reset_UI()

	local function Activate_Tab(Tab_Name)
		for _, B in ipairs(Sort_Buttons) do
			if B.Name == Tab_Name then
				B.BackgroundTransparency = 0 
			else
				B.BackgroundTransparency = 1
			end
		end
	end

	local function Populate_Data_Tabs(Sort_Type)
		local Tween_Scroll = TweenInfo.new(0.375, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
		local X_Pos, Y_Pos = 0.165, 0.225

		Tabs_F:ClearAllChildren()

		local uiGrid = Instance.new("UIGridLayout")
		uiGrid.CellPadding = UDim2.new(0.005, 0, 0.05, 0)
		uiGrid.CellSize = UDim2.new(0.32, 0, 0.35, 0)
		uiGrid.SortOrder = Enum.SortOrder.LayoutOrder
		uiGrid.Parent = Tabs_F

		local function Create_Server_Tab(Data, i)
			local Avg_Elo = Data['Average Elo'] or 0
			local Server_ID = Data['Server ID'] or -1
			local Ranked_Wins_V = Data['Average Ranked Wins'] or 0
			local Wins_V = Data['Average Wins'] or 0
			local Player_List = Data['Server Size'] or {}
			local Elo, Elo_Data = Elo_Mod.Get_Elo_Data_From_Val(Avg_Elo)

			local Tab = TMP_Tab:Clone()
			local Join_B = Tab:WaitForChild("Join_B")
			local Join_Txt = Join_B:FindFirstChildWhichIsA("TextLabel")
			local Elo_Txt = Tab:WaitForChild("Elo_F"):WaitForChild("Elo_Num_Txt")
			local Elo_Img = Tab:WaitForChild("Elo_Img")
			local Server_Size_Txt = Tab:WaitForChild("Server_Size_Txt")

			Tab.Parent = Tabs_F
			Tab.Name = "Server_" .. Server_ID
			Tab.LayoutOrder = i

			Elo_Txt.Text = Format_Number(Avg_Elo)
			Elo_Txt.TextColor3 = Elo_Data['Color']
			Elo_Img.Image = Elo_Data['Icon']
			Elo_Img.ImageColor3 = Elo_Data['Color']

			Tab:WaitForChild("Ranked_Wins_Txt").Text = Format_Number(Ranked_Wins_V)
			Tab:WaitForChild("Wins_Txt").Text = Format_Number(Wins_V)

			Server_Size_Txt.Text = #Player_List .. " / 25"
			if (#Player_List >= 25 or #Player_List == 0 or table.find(Player_List, Plr.UserId) ~= nil) then
				Server_Size_Txt.TextColor3 = Color3.new(1, 0, 0)
			else
				Server_Size_Txt.TextColor3 = Color3.new(1, 1, 1)
			end

			-- Join button handlers
			table.insert(Cons, Join_B.MouseEnter:Connect(function()
				if not Debounce_E then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")
					Join_B.ImageColor3 = Color3.fromRGB(150, 150, 150)
					Join_Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					Debounce_E = false
				end
			end))

			table.insert(Cons, Join_B.MouseLeave:Connect(function()
				Join_B.ImageColor3 = Color3.new(1, 1, 1)
				Join_Txt.TextColor3 = Color3.new(1, 1, 1)
			end))

			table.insert(Cons, Join_B.MouseButton1Click:Connect(function()
				if not Debounce_C then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(Join_B, Tween_Click, {Size = UDim2.new(0.35625, 0, 0.225, 0)}):Play()

					if Server_Size_Txt.TextColor3 == Color3.new(1, 0, 0) then
						Display_Data_E:Fire("? This Server is unavailable right now! Try Again later!", Color3.fromRGB(225, 0, 0))
					else
						local Did_Teleport = Teleport_To_Server:InvokeServer(Server_ID)
						if Did_Teleport == false then
							Display_Data_E:Fire("? Failed to Teleport! Try another Server!", Color3.fromRGB(225, 0, 0))
						end
					end

					task.wait(0.25)
					Debounce_C = false
				end
			end))

			Tab.Position = UDim2.new(X_Pos, 0, Y_Pos, 0)
			Tab.Visible = true
			X_Pos += 0.33
			if X_Pos >= 1 then
				X_Pos = 0.165
				Y_Pos += 0.4125
			end
		end

		local sorted_data = Sort_Data_Handle(Core_Servers_Data, Sort_Type)
		for i, S_Data in pairs(sorted_data) do
			if S_Data and S_Data['Server Size'] then
				--print("DEBUG create tab for", S_Data["Server ID"], "players:", #S_Data["Server Size"])
				Create_Server_Tab(S_Data, i)
			else
				--print("DEBUG skipping entry", S_Data)
			end
		end

		TS:Create(Data_F, Tween_Scroll, {CanvasPosition = Vector2.new(0, 0)}):Play()
	end

	local function Sort_Button_Handle()

		local function Button_Handle(B)
			local Key = string.gsub(B.Name, "_B", "")
			local Txt = B:FindFirstChildWhichIsA("TextLabel")
			Key = string.gsub(Key, "_", " ")

			Txt.TextColor3 = Color3.new(1, 1, 1)
			B.Size = UDim2.new(0.086, 0, 0.066, 0)

			table.insert(Cons, B.MouseEnter:Connect(function()
				if not Debounce_E then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")
					Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					Debounce_E = false
				end
			end))

			table.insert(Cons, B.MouseLeave:Connect(function()
				Txt.TextColor3 = Color3.new(1, 1, 1)
			end))

			table.insert(Cons, B.MouseButton1Click:Connect(function()
				if not Debounce_C then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(B, Tween_Click, {Size = UDim2.new(0.0645, 0, 0.0495, 0)}):Play()
					Activate_Tab(B.Name)
					Populate_Data_Tabs(Key)
					task.wait(0.25)
					Debounce_C = false
				end
			end))
		end

		for _, B in ipairs(Sort_Buttons) do
			if B and B:IsA("ImageButton") then
				Button_Handle(B)
			end
		end
	end
	Sort_Button_Handle()
	
	Activate_Tab("Rank_B")
	Populate_Data_Tabs("Rank")

	MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)

	local function Display_Main_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Servers_Blurr"
		Toggle_Side_Buttons:Fire(false, true)
		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_Main_UI()
end

Open_Servers.Event:Connect(function()
	if not Debounce_UI then
		Display_UI()
	else
		Remove_UI()
	end
end)

Update_All_Server_Data.OnClientEvent:Connect(function(New_Data)
	Core_Servers_Data = New_Data
end)
]]></ProtectedString>
							<string name="ScriptGuid">{BDE6AF98-AEFF-4675-AC8A-74A84FDF260C}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Servers_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX5017A629EB2C4DDD91C7136A8E6D0E8F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Skill_Tree_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX62E1EB2BC82E4CFBB308A380A995F796">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer

local PD = Plr:WaitForChild("Player_Data")
local Char = Plr.Character or Plr.CharacterAdded:Wait()

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Skill_Tree_Mod = require(Data_Mods_F:WaitForChild("Skill_Tree_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

local MenuButtons_Mod				= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))

local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Redeem_Skill_Tree_Reward		= Channels.CS_Remote_Functions.Redeem_Skill_Tree_Reward
local Toggle_Side_Buttons 			= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Skill_Tree 				= Channels.Bindable_Events.Open_Skill_Tree
local Display_Data_E 				= Channels.Bindable_Events.Display_Data

-- UI References
local Main_F = script.Parent.Main_F
local Exit_B = Main_F.Exit_B
local Data_F = Main_F.Data_F
local Tabs_F = Data_F.Tabs_F
local Update_Tabs_E = script.Parent.Update_Tabs

local Debounce_UI = false
local Debounce_C = false
local Debounce_E = false

local UNLOCKED_TRANSPARENCY = 0.8

local Skill_Tree_Data, Reward_Data = Skill_Tree_Mod.Get_All_Skill_Tree_Data()
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

local function Format_Time(sec)
	return math.floor(sec / 3600)
end

local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.25, true, nil)
	task.wait(0.25)
	
	Main_F.Visible = false
	
	Debounce_C = false
	Debounce_E = false
	Debounce_UI = false
	
	Toggle_Side_Buttons:Fire(true)
end

local function Show_Skill_Tree()
	local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
	
	local function Reset_Display()
		Main_F.Visible = false
		Main_F.Size = UDim2.new(0, 0, 0, 0)
		Data_F.Position = UDim2.new(0.5, 0, 0.5, 0)
	end
	Reset_Display()
	
	local function Tree_Button_Configs()
		--[[
			* Assess each Button
			- Have you unlocked it yet? Add Check
			- Can you redeem it? Show the Reward
			- Can you see it? Show the Locked and Requirements
			- Can't see it? Visible  = false
		]]--

		local Owned_Rewards = Skill_Tree_Mod.Compile_Skill_Tree_Data(Plr)
		
		local Reward_Vectors = {
			['Cash'] = "rbxassetid://119234133505316",
			['Gems'] = "rbxassetid://101452762537147",
			['Cash Pack'] = "rbxassetid://15365698744",
			['Ranked Move'] = "rbxassetid://107665571679632",
			['Crate'] = "rbxassetid://113984353478299",
			['Ranked Strike'] = "rbxassetid://83651269157787",
			['Emotes'] = "rbxassetid://96813195617891"
		}
		
		local Skill_Vectors = {
			['Total Wins'] = "rbxassetid://108423557329774",
			['Ranked Wins'] = "rbxassetid://84882681331411",
			['Punch Knockout Wins'] = "rbxassetid://110581737976151",
			['Leg Knockout Wins'] = "rbxassetid://136568604314712",
			['Submissions Wins'] = "rbxassetid://104272697213386",
			['Total Playtime'] = "rbxassetid://104629740938145"
		}
		
		local Skill_Txt = {
			['Total Wins'] = {" Wins!", " Win!"},
			['Ranked Wins'] = {" Ranked Wins!", " Ranked Win!"},
			['Punch Knockout Wins'] = {" KO's!", " KO!"},
			['Leg Knockout Wins'] = {" Kick KO's!", " Kick KO!"},
			['Submissions Wins'] = {" Submissions!", " Submission!"},
			['Total Playtime'] = {" Hours!", " Hour!"},
		}
		
		local function Get_Reward_Txt(R_Data)
			if(R_Data['Reward'] == "Crate")then
				return "Free Crate!"
			elseif(R_Data['Reward'] == "Emotes")then
				return "Special Emote!"
			elseif(R_Data['Reward'] == "Ranked Move")then
				return "Special Combo!"
			elseif(R_Data['Reward'] == "Ranked Strike")then
				return "Special Strike!"
			elseif(R_Data['Reward'] == "Cash Pack")then
				return "Cash Pack!"
			else
				local Amount = R_Data['Amount']
				local Text = R_Data['Reward']
				if math.round(Amount) == 1 then
					warn(Text)
					Text = string.sub(Text, 1, string.len(Text) - 1)
					warn(Text)
					warn()
				end

				return "+" .. Amount .. " " .. Text .. "!"
			end
		end
		
		local function Adjust_Frame_Position(Tab)
			--get the Difference Away from the Center Position
				--Center Position = Current Data_F Position
			local T_Pos = Tab.Position
			local X_Dif = 0.5 - T_Pos.X.Scale
			local Y_Dif = 0.5 - T_Pos.Y.Scale
			local X_Pos = 0.5 + X_Dif
			local Y_Pos = 0.5 + Y_Dif
			
			local New_Pos = UDim2.new(X_Pos, 0, Y_Pos, 0)
			Data_F:TweenPosition(New_Pos, Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
		end

		local function Configure_Data_Type(TF)
			local Key = TF.Name
			local Tabs = TF:GetChildren()
			
			local function Process_Tab(Tab)
				local Selected = Tab:FindFirstChild("Selected")
				local Main_Img = Tab:FindFirstChild("Main_Img")
				local Main_Txt = Tab:FindFirstChild("Main_Txt")
				local Tree_Index = string.gsub(Tab.Name, "Tab_", "")
				Tree_Index = tonumber(Tree_Index)
				
				local function Already_Claimed()
					if(Owned_Rewards ~= nil and Owned_Rewards[Key] ~= nil and #Owned_Rewards[Key] > 0 and 
						table.find(Owned_Rewards[Key], Tree_Index) ~= nil)then
						
						return true
					end
					return false
				end

				if(Already_Claimed())then
					--> Show the Claimed Status
					Main_Img.Image = "rbxassetid://122099475285175"
					Main_Img.ImageColor3 = Color3.new(1, 1, 1)
					
					Main_Txt.Text = "Claimed!"
					Main_Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					
					Tab.Image = "rbxassetid://104891328720619"
					Tab.ImageColor3 = Color3.new(1, 1, 1)
					
					Tab.Visible = true
					Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					
					Tab:SetAttribute("Process_Data", "Claimed")
					return "Claimed"
				end


				local function Can_Redeem_Button()
					--> Check Requirements
					local D_Val = PD:FindFirstChild(Key)
					local Max_Amount = Skill_Tree_Data[Key][Tree_Index] or math.huge
					
					if(D_Val ~= nil and D_Val.Value >= Max_Amount) then
						return true
					end
					return false
				end

				if(Can_Redeem_Button()) then
					--> Show the Reward avaiable
					local R_Data = Skill_Tree_Mod.Get_Reward_Data_Arr(Key)[Tree_Index]
					Main_Img.Image = Reward_Vectors[R_Data['Reward']]
					Main_Img.ImageColor3 = Color3.new(1, 1, 1)

					Main_Txt.Text = Get_Reward_Txt(R_Data)
					Main_Txt.TextColor3 = Color3.new(1, 1, 1)

					Tab.Image = "rbxassetid://138946019587089"
					Tab.ImageColor3 = Color3.new(1, 1, 1)
					
					Tab.Visible = true
					Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					
					Tab:SetAttribute("Process_Data", "Redeem")
					return "Redeem"
				end


				local function Can_See_On_Progress()
					--> If Ranked Wins or Total Wins, get the next 2 from their most Selected
					--> If not, get the next one
					local function Get_Starting_Index()
						local Max = 0
						local Redeemed_Vals = Owned_Rewards[Key] or {}
						
						for i = 1, #Redeemed_Vals do
							local Val = Redeemed_Vals[i]
							if(Val ~= nil)then
								local Num = tonumber(Val) 
								if(Num ~= nil and Num > Max)then
									Max = Num
								end
							end
						end
						
						return Max
					end
					local Start_Index = Get_Starting_Index()
					local Max_Index = Start_Index + 1
					
					if(Start_Index > 0 and (Key == "Total Wins" or Key == "Ranked Wins"))then
						Max_Index += 1
					end
					
					if(Tree_Index <= Max_Index)then
						return true
					end
					
					return false
				end
				
				if(Can_See_On_Progress())then
					--> Unknown					
					Main_Img.Image = Skill_Vectors[Key]
					Main_Img.ImageColor3 = Color3.new(1, 1, 1)

					if Key == "Total Playtime" then
						local hours = Format_Time(Skill_Tree_Data[Key][Tree_Index])
						local Txt = (hours <= 1) and Skill_Txt[Key][2] or Skill_Txt[Key][1]
						Main_Txt.Text = hours .. Txt
					else
						local Txt = Skill_Txt[Key]
						Txt = (math.round(Skill_Tree_Data[Key][Tree_Index]) <= 1.25) and Txt[2] or Txt[1]
						Main_Txt.Text = Format_Number(Skill_Tree_Data[Key][Tree_Index]) .. Txt
					end
					
					Main_Txt.TextColor3 = Color3.new(1, 1, 1)

					Tab.Image = "rbxassetid://138946019587089"
					Tab.ImageColor3 = Color3.new(1, 1, 1)
					
					Tab.Visible = true
					Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					
					Tab:SetAttribute("Process_Data", "Show")
					return "Show"
				else
					--Tab.Visible = false
					--Tab.Size = UDim2.new(0, 0, 0, 0)
					--Tab:SetAttribute("Process_Data", "N/A")
					--return nil
					-- LOCKED: affichage grisé/disabled
					
					Main_Img.Image = Skill_Vectors[Key]
					Main_Img.ImageColor3 = Color3.fromRGB(170,170,170)
					Main_Img.ImageTransparency = UNLOCKED_TRANSPARENCY

					local Txt = Skill_Txt[Key]
					
					if Key == "Total Playtime" then
						local hours = Format_Time(Skill_Tree_Data[Key][Tree_Index])
						local Txt = (hours <= 1) and Skill_Txt[Key][2] or Skill_Txt[Key][1]
						Main_Txt.Text = hours .. Txt
					else
						local Txt = Skill_Txt[Key]
						Txt = (math.round(Skill_Tree_Data[Key][Tree_Index]) <= 1.25) and Txt[2] or Txt[1]
						Main_Txt.Text = Format_Number(Skill_Tree_Data[Key][Tree_Index]) .. Txt
					end
					
					Main_Txt.TextColor3 = Color3.fromRGB(180,180,180)
					Main_Txt.TextTransparency = UNLOCKED_TRANSPARENCY

					Tab.Image = "rbxassetid://138946019587089"
					Tab.ImageColor3 = Color3.fromRGB(130,130,130)
					Tab.ImageTransparency = UNLOCKED_TRANSPARENCY + 0.05

					Tab.Visible = true
					Tab.Size = UDim2.new(0.125, 0, 0.25, 0)
					Tab:SetAttribute("Process_Data", "Locked")
					return "Locked"
				end
			end
			
			local function Tab_Handle(Tab)
				local Selected = Tab:FindFirstChild("Selected")
				local Main_Img = Tab:FindFirstChild("Main_Img")
				local Main_Txt = Tab:FindFirstChild("Main_Txt")
				local Tree_Index = string.gsub(Tab.Name, "Tab_", "")
				Tree_Index = tonumber(Tree_Index)
				
				Tab.Visible = false
				Tab.Size = UDim2.new(0, 0, 0, 0)
				Tab.Image = "rbxassetid://138946019587089"
				Tab.ImageColor3 = Color3.new(1, 1, 1)
				
				local Process_Data = Process_Tab(Tab)
				
				local function Click_Handle()
					local Process_D = Tab:GetAttribute("Process_Data")
					if(Process_D ~= nil and Process_D ~= "N/A")then
						if(Process_D == "Redeem")then
							--Bulk Action, Grant the Reward!
							--> Tell the Server
							--> If True, Update the Skill Tree Display and all Tab Status
							--> False?, Error Message
							
							local Res, Txt = Redeem_Skill_Tree_Reward:InvokeServer(Key, Tree_Index)
							if(Res)then
								local Is_Crate = (Main_Txt.Text == "Free Crate!")
								Display_Data_E:Fire(Txt, Color3.fromRGB(255, 170, 0))
								
								Owned_Rewards = Skill_Tree_Mod.Compile_Skill_Tree_Data(Plr)
								for i = 1, #Tabs do
									local T = Tabs[i]
									if(T ~= nil)then
										Process_Tab(T)
									end
								end
								
								--if you unlocked a Crate, remove the UI
								if(Is_Crate and Debounce_UI)then
									Remove_UI()
								end
			
							else
								local Txt = "❗ Failed to Redeem! Keep working to Unlock this Reward!"
								Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
							end
							
						elseif(Process_D == "Claimed")then
							local Txt = "✔️ You've already Claimed this Reward!"
							Display_Data_E:Fire(Txt, Color3.fromRGB(35, 244, 68))
						elseif(Process_D == "Show")then
							local Txt = "❗ Keep working to Unlock your next Reward!"
							Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
						elseif(Process_D == "Locked") then
							local Txt = "🔒 Continue pour débloquer cette récompense."
							Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
						end
					end
				end
				
				table.insert(Cons, Selected.MouseEnter:Connect(function()
					if(Debounce_E == false and Tab.Visible == true)then
						Debounce_E = true
						SE_Mod.PlaySFX(Plr, "Hover_SE")
						Tab:TweenSize(UDim2.new(0.175, 0, 0.3, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
						Tab.ImageColor3 = Color3.fromRGB(35, 244, 68)
						
						Debounce_E = false
					end
				end))
				
				table.insert(Cons, Selected.MouseLeave:Connect(function()
					if(Tab.Visible == true)then
						Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
						Tab.ImageColor3 = Color3.new(1, 1, 1)	
					end
				end))
				
				table.insert(Cons, Selected.MouseButton1Click:Connect(function()
					if(Debounce_C == false and Tab.Visible == true)then
						Debounce_C = true
						SE_Mod.PlaySFX(Plr, "Click_SE")
						TS:Create(Tab, Tween_Click, {Size = UDim2.new(0.09375, 0, 0.1875, 0)}):Play()
						Adjust_Frame_Position(Tab)
						
						Click_Handle()
						
						task.wait(0.25)
						Debounce_C = false
					end
				end))	
				
				table.insert(Cons, Update_Tabs_E.Event:Connect(function()
					Process_Data = Process_Tab(Tab)
				end))
				
				if(Process_Data ~= nil)then
					Tab.Visible = true
					Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
				end
			end
			
			for i = 1, #Tabs do
				local T = Tabs[i]
				if(T ~= nil)then
					Tab_Handle(T)
				end
			end
		end
		
		local Tab_Data_F = Tabs_F:GetChildren()
		for i = 1, #Tab_Data_F do
			local TF = Tab_Data_F[i]
			if(TF ~= nil)then
				Configure_Data_Type(TF)
			end
		end
		
	end
	Tree_Button_Configs()
	
	MenuButtons_Mod.Setup_Base_Button(Cons, Exit_B, Remove_UI, Exit_B.Selected)
	
	local function Display_UI()
		Main_F.Visible = true
		Main_F:TweenSize(UDim2.new(1, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)

		Debounce_C = false
		Debounce_E = false
		Debounce_UI = true
		
		Toggle_Side_Buttons:Fire(false)		
	end
	Display_UI()
end

Open_Skill_Tree.Event:Connect(function()
	if(Debounce_UI == false)then
		Show_Skill_Tree()
	else
		Remove_UI()
	end
end)

function Auto_Open_Handle()
	
	local function Prompt_Open_Handle()
		local function Is_Player_Not_Fighting()
			local Is_Fighting = Char:GetAttribute("Is_Fighting")
			if(Is_Fighting == nil or (Is_Fighting ~= nil and Is_Fighting == false))then
				return true
			end
			return false
		end
		
		repeat task.wait(1) until Is_Player_Not_Fighting() == true	
		
		if(Debounce_UI == false)then
			Show_Skill_Tree()
		end
	end
	
	for Skill_Key, Requirement_Vals_Arr in next, Skill_Tree_Data do
		local Data_Val = PD:WaitForChild(Skill_Key)
		Data_Val.Changed:Connect(function()
			local V = Data_Val.Value
			if(table.find(Requirement_Vals_Arr, V) ~= nil and Debounce_UI == false)then
				Prompt_Open_Handle()
			end
			Update_Tabs_E:Fire()
		end)
	end
end
Auto_Open_Handle()]]></ProtectedString>
							<string name="ScriptGuid">{A59E0DA7-D47F-4A0A-9575-A71096B2C846}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Skill_Tree_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX100981904C7D47CDA2FB16AC81E8506C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Main_F</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX4C1A54C19EE94F129297F0D8E1C27073">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Exit_B</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX8AA5D7B51F944E95896BA90616BC83CA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Xbox</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX7EC32EF5EA934302841485FE655EE978">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local updateXbox = function()
	local Mapped_Key = uis:GetStringForKeyCode(Enum.KeyCode.ButtonX)
	if(Mapped_Key == "ButtonX")then
		script.Parent.Image = "rbxassetid://115257536194509"
	else
		--PS5
		script.Parent.Image = "rbxassetid://137985933701432"
	end
	
	script.Parent.Visible = uis.GamepadEnabled
end

if uis.GamepadEnabled then
	updateXbox(true)
else
	updateXbox(false)
end
local conn2 = uis.GamepadConnected:Connect(function()
	if uis.GamepadEnabled then
		updateXbox(true)
	else
		updateXbox(false)
	end
end)
local conn2 = uis.GamepadDisconnected:Connect(function()
	if uis.GamepadEnabled then
		updateXbox(true)
	else
		updateXbox(false)
	end
end)]]></ProtectedString>
										<string name="ScriptGuid">{13BE9A70-FEC8-410B-B8E7-E0BB74BC5F3D}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">LocalScript.client.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX3DA7CE78FDC44B289AEF50B98A324213">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">HUD</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXC392AFACB6504D17B918184A1861A5F3">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local Players:Players = game:GetService("Players")
local Player = Players.LocalPlayer

local Vendor:Folder = RS:FindFirstChild("Vendor")

local BindCurrency = require(script.BindCurrency)
local BindTopbar = require(script.BindTopbar)
local BindTools = require(script.BindTools)
local BindMenu = require(script.BindMenu)

local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 			= Channels.Bindable_Events.Toggle_Side_Buttons

local HUD:ScreenGui = script.Parent
local CurrencyFrame:Frame = HUD:WaitForChild("CurrencyIndicators")
local ToolsFrame:Frame = HUD:WaitForChild("Tools")
local MenuFrame:Frame = HUD:WaitForChild("Menu")

local function ToggleMenu(toggleValue:boolean, affectsBottomBar:boolean)
	if toggleValue then
		if Player:GetAttribute("IsTutorialRunning") then
			return
		end
	end
	CurrencyFrame.Visible = toggleValue
	MenuFrame.Visible = toggleValue
	
	if affectsBottomBar == true then
		ToolsFrame.Visible = toggleValue
	end
end

local function Init()
	Toggle_Side_Buttons.Event:Connect(ToggleMenu)
	task.spawn(BindCurrency,CurrencyFrame)
	task.spawn(BindTools,ToolsFrame)
	task.spawn(BindMenu,MenuFrame)
	task.spawn(BindTopbar)
end

Init()]]></ProtectedString>
							<string name="ScriptGuid">{EA375E67-3640-4720-8F38-51CBB07EAC05}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">HUD_Handler.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXF0FCC7421C7C4273953964ABCE237CD9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">HUD_Handler</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXE99055E9B9AE45E68689B283DE80E33E">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local RS = game:GetService("ReplicatedStorage")
local SS = game:GetService("SocialService")
local VCS = game:GetService("VoiceChatService")
local Plr = game.Players.LocalPlayer

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Prompt_Invite			= Channels.Bindable_Events.Prompt_Invite
local Voice_Chat_Prompt		= Channels.Bindable_Events.Voice_Chat_Prompt
local Display_Data_E 		= Channels.Bindable_Events.Display_Data

local Invite_Options = Instance.new("ExperienceInviteOptions")
Invite_Options.PromptMessage = "Invite your Friends for +10% Luck!"
Invite_Options.InviteMessageId = "bc7cffbc-7709-214a-8ecb-b6452021927d"

local function Display_Invite_UI(Show_Msg)
	local function Can_Send_Invite()
		local function Async()
			local success, errormessage = pcall(function()
				return SS:CanSendGameInviteAsync(Plr)
			end)

			if(success)then
				return true
			end
			return false
		end

		for i = 1, 3 do
			local D = Async()
			if(D)then
				return D
			end
		end

		return false
	end

	if(Show_Msg)then
		Display_Data_E:Fire("❤️ Invite your Friends to earn more Luck!", Color3.new(1, 1, 0))
	end

	if(Can_Send_Invite())then
		local function Show_Invite()
			local function Async()
				local success, errormessage = pcall(function()
					SS:PromptGameInvite(Plr, Invite_Options)
				end)

				if(success)then
					return true
				end
				return false
			end

			for i = 1, 3 do
				local D = Async()
				if(D)then
					return
				end
			end
		end
		Show_Invite()
	end
end

Prompt_Invite.Event:Connect(function()
	Display_Invite_UI(true)
end)


local function VC_Prompt()
	local function Can_Prompt_VC()
		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				VCS:IsVoiceEnabledForUserIdAsync(Plr.UserId)
			end)
			
			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end
		
		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				return D
			end
		end	
		
		return false
	end
	
	if(Can_Prompt_VC() == false)then
		local Txt = "❗ You must enable your Voice Chat within your Roblox Settings!"
		Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
	else
		local Txt = "🎤 Trash Talk with Voice Chat!"
		Display_Data_E:Fire(Txt, Color3.fromRGB(0, 170, 255))
	end
end

Voice_Chat_Prompt.Event:Connect(function()
	VC_Prompt()
end)]]></ProtectedString>
								<string name="ScriptGuid">{CBA8B470-08E5-495D-A469-3A17216D45AD}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Friend_Invite_Handle.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3FEC1FED75B34D2E8428F42B5CA5E4B9">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local Players:Players = game:GetService("Players")
local Player = Players.LocalPlayer

local PlayerDataDir:Folder = Player:WaitForChild("Player_Data")
local PlayerCash:NumberValue = PlayerDataDir:WaitForChild("Coins")
local PlayerGems:NumberValue = PlayerDataDir:WaitForChild("Gems")

-- Modules
local Utils = require(game.ReplicatedStorage.Modules.Utils)
local Find = require(RS.Vendor.Find)

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Open_Shop_UI 			= Channels.Bindable_Events.Open_Shop_UI

return function(currencyFrame:Frame, self)
	local function SetupCurrency(valueObject:NumberValue,index:string)
		local targetFrame:Frame = currencyFrame:WaitForChild(index)
		Find(targetFrame,"Currency",function(currencyField:TextLabel)
			currencyField.Text = Utils.NumToString(valueObject.Value)
			valueObject.Changed:Connect(function()
				currencyField.Text = Utils.NumToString(valueObject.Value)
			end)
		end)

		Find(targetFrame,"AddCurrency",function(addButton:ImageButton)
			addButton.Activated:Connect(function()
				Open_Shop_UI:Fire(index)
			end)
		end)
	end

	SetupCurrency(PlayerCash,"Cash")
	SetupCurrency(PlayerGems,"Gems")
end]]></ProtectedString>
								<string name="ScriptGuid">{7D4565E7-8666-4792-B2AA-DF9D6B107A36}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">BindCurrency.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX22BE7B4BA9264EFEACAB6A93B3F73AAA">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local Players:Players = game:GetService("Players")
local Player = Players.LocalPlayer
local PlayerDataDir:Folder = Player:WaitForChild("Player_Data")
local PlayerCash:NumberValue = PlayerDataDir:WaitForChild("Coins")
local PlayerGems:NumberValue = PlayerDataDir:WaitForChild("Gems")

-- Modules
local Spr = require(RS.Vendor.Spr)

local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local EventsList = {
	['SkillTree'] = Channels.Bindable_Events.Open_Skill_Tree,
	['Servers'] = Channels.Bindable_Events.Open_Servers,
	['Fighter'] =Channels.Bindable_Events.Open_Equipment,
	['Combo'] = Channels.Bindable_Events.Open_Combos,
	['Codes'] = Channels.Bindable_Events.Open_Codes,
	['Stats'] = Channels.Bindable_Events.Open_Stats,
	['Shop'] = Channels.Bindable_Events.Open_Shop_UI,
	['Rewards'] = Channels.Bindable_Events.Open_Session_Rewards,
	['Leagues'] = Channels.Bindable_Events.Open_Leagues,
}

local function CreateButton(root:Frame)
	local newButton = Instance.new("ImageButton")
	newButton.Size = UDim2.fromScale(1,1)
	newButton.BackgroundTransparency = 1
	newButton.ImageTransparency = 1
	newButton.Parent = root
	return newButton
end

return function(menuFrame:Frame)
	local function SetupButton(entryFrame:Frame)
		local mainEntry:Frame = entryFrame:FindFirstChild("Entry")
		if not mainEntry then
			return
		end

		local entryButton:ImageButton = CreateButton(mainEntry)
		local animationLocked = false

		entryButton.MouseEnter:Connect(function()
			if animationLocked then
				return
			end
			Spr.target(mainEntry,0.6,3,{
				Size = UDim2.fromScale(1.1,1.1)
			})
		end)

		entryButton.MouseLeave:Connect(function()
			if animationLocked then
				return
			end
			Spr.target(mainEntry,0.6,3,{
				Size = UDim2.fromScale(1,1)
			})
		end)

		entryButton.Activated:Connect(function()
			animationLocked = true

			Spr.target(mainEntry,0.6,3,{
				Size = UDim2.fromScale(0.9,0.9)
			})

			task.delay(1/8,function()
				animationLocked = false
				Spr.target(mainEntry,0.6,3,{
					Size = UDim2.fromScale(1,1)
				})
			end)

			if(EventsList[entryFrame.Name] ~= nil)then
				EventsList[entryFrame.Name]:Fire()
			end
		end)
	end

	local skillTreeFrame:Frame = menuFrame:FindFirstChild("SkillTree")
	local mainFrame:Frame = menuFrame:FindFirstChild("MainFrame")
	if mainFrame then
		for _, entryFrame:Frame in mainFrame:GetChildren() do
			if not entryFrame:IsA("Frame") then
				continue
			end

			task.spawn(SetupButton,entryFrame)
		end
	end
	if skillTreeFrame then
		task.spawn(SetupButton,skillTreeFrame)
	end
end
]]></ProtectedString>
								<string name="ScriptGuid">{BC22A2EC-D926-4C66-B0D4-319DA2C5A765}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">BindMenu.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXCD66A984EB6344838005080FDB19F0E8">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/BindTools.lua
--
--  Description:
--      Handles the client-side Tools UI (Fight / Emotes) including
--      input bindings, button animations, and visibility logic.
--      Integrates with the Channels system to toggle fight mode,
--      open the emotes panel, and react to gameplay states
--      (submission, attack, UI lock).
--
--  Author(s): Darkzeb
--
--  Last Modified: 2026-01-13 by Darkzeb
--
--  Version: V2026-01
--
--  Dependencies:
--      - Workspace (optional, feature-flagged):
--          * Main_World_F/Gameplay/Objects/GymObjects
--              - Gym_Entry
--              - Gym_Exit
--      - ReplicatedStorage:
--          * Data_Mods_F:
--              - Sound_Mod
--              - Animation_Mod
--          * Modules:
--              - Channels
--              - Utils (SafePath)
--          * Vendor:
--              - Spr
--      - Roblox Services:
--          * Players (LocalPlayer)
--          * UserInputService
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Supports keyboard, gamepad, and touch inputs
--      - Buttons are animated using Spr
--      - Gym-related logic is optional (tournament-safe)
--      - UI visibility reacts to combat and submission states
--      - All actions are dispatched through BindableEvents
--
--======================================================================

-- Services
local UserInputService:UserInputService = game:GetService("UserInputService")
local RS 					= game:GetService("ReplicatedStorage")
local Players 				= game:GetService("Players")
local Player:Player 		= Players.LocalPlayer

-- Modules
local Data_Mods_F 			= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod 				= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Utils 				= require(game.ReplicatedStorage.Modules.Utils)

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local Open_Emotes_UI 		= Channels.Bindable_Events.Open_Emotes_UI
local ToggleFightMode 		= Channels.Bindable_Events.Toggle_Fight_Mode
local DisableFightMode 		= Channels.Bindable_Events.Disable_Fight_Mode
local ToggleFightButton 	= Channels.Bindable_Events.Toggle_Fight_Button
local ToggleToolsButtons 	= Channels.Bindable_Events.Toggle_Tools_Buttons
local OnSubmissionHandle 	= Channels.Bindable_Events.On_Submission_Handle
local Is_Chatbox_Typing 	= Channels.Bindable_Functions.Is_Chatbox_Typing 

local Spr 					= require(RS.Vendor.Spr)

local function CreateButton(root:Frame)
	local newButton = Instance.new("ImageButton")
	newButton.Size = UDim2.fromScale(1,1)
	newButton.BackgroundTransparency = 1
	newButton.ImageTransparency = 1
	newButton.Parent = root
	return newButton
end

return function(toolsFrame:Frame)
	local emotesFrame:Frame = toolsFrame:WaitForChild("Emotes")
	local fightFrame:Frame = toolsFrame:WaitForChild("Fight")

	local emotesKeybind:Frame = emotesFrame:WaitForChild("Keybind")
	local fightKeybind:Frame = fightFrame:WaitForChild("Keybind")

	local emotesKey:TextLabel = emotesKeybind:WaitForChild("Keybind"):WaitForChild("Txt")
	local fightKey:TextLabel = fightKeybind:WaitForChild("Keybind"):WaitForChild("Txt")
	
	CreateButton(emotesFrame)
	CreateButton(fightFrame)
	
	local function SetupButton(rootFrame:Frame,callback)
		local newButton = CreateButton(rootFrame)
		local animLocked = false
		newButton.MouseEnter:Connect(function()
			if animLocked then
				return
			end
			Spr.target(rootFrame,0.6,3,{
				Size = UDim2.fromScale(1.1,1.1)
			})
		end)
		newButton.MouseLeave:Connect(function()
			if animLocked then
				return
			end
			Spr.target(rootFrame,0.6,3,{
				Size = UDim2.fromScale(1,1)
			})
		end)
		newButton.Activated:Connect(function()
			animLocked = true
			Spr.target(rootFrame,0.6,3,{
				Size = UDim2.fromScale(0.9,0.9)
			})
			task.delay(1/5,function()
				animLocked = false
				Spr.target(rootFrame,0.6,3,{
					Size = UDim2.fromScale(1,1)
				})
				callback()
			end)
		end)
	end

	local function Keycode_Display_Handle()
		if(UserInputService.TouchEnabled)then
			emotesKeybind.Visible = false
			fightKeybind.Visible = false
		else
			if(UserInputService.GamepadEnabled)then
				fightKey.Text = "L1"
				emotesKey.Text = "R1"
			else
				fightKey.Text = "1"
				emotesKey.Text = "2"
			end

			emotesKeybind.Visible = true
			fightKeybind.Visible = true
		end
	end

	Keycode_Display_Handle()
	--UserInputService.LastInputTypeChanged:Connect(Keycode_Display_Handle)

	if(UserInputService.TouchEnabled == false)then
		UserInputService.InputBegan:Connect(function(input, GPE)
			if (Is_Chatbox_Typing:Invoke() == true) or not toolsFrame.Visible then
				return
			end
			
			if toolsFrame.Visible then
				if ((input.KeyCode == Enum.KeyCode.One or input.KeyCode == Enum.KeyCode.ButtonL1)) then
					if(fightFrame.Visible) then
						SE_Mod.PlaySFX(nil, "Click_SE")
						ToggleFightMode:Fire()
					end
				elseif(input.KeyCode == Enum.KeyCode.Two or input.KeyCode == Enum.KeyCode.ButtonR1)then
					if(emotesFrame.Visible) then
						SE_Mod.PlaySFX(nil, "Click_SE")
						Open_Emotes_UI:Fire()
					end
				end
			end
		end)
	end
	
	SetupButton(emotesFrame,function()
		Open_Emotes_UI:Fire()
	end)
	SetupButton(fightFrame,function()
		ToggleFightMode:Fire()
	end)
	
	
	local function Toggle_Fight_Button(Is_Enabled)
		fightFrame.Visible = Is_Enabled
	end
	
	Toggle_Fight_Button(false)

	local function Toggle_Whole_Menu(Is_Enabled)
		toolsFrame.Visible = Is_Enabled
	end
	
	ToggleFightButton.Event:Connect(function(Is_Enabled)
		Toggle_Fight_Button(Is_Enabled)
	end)
	
	ToggleToolsButtons.Event:Connect(function(Should_Show)
		Toggle_Whole_Menu(Should_Show)
	end)

	OnSubmissionHandle.Event:Connect(function(Is_Attacking, Is_Submission)
		local state = not (Is_Attacking or Is_Submission)
		Toggle_Whole_Menu(state)
	end)

	local GymObjects = Utils.SafePath(workspace, {
		"Main_World_F", "Gameplay", "Objects", "GymObjects"
	})

	if GymObjects then
		local Gym_Entry = GymObjects:FindFirstChild("Gym_Entry")
		local Gym_Exit  = GymObjects:FindFirstChild("Gym_Exit")

		if Gym_Entry and Gym_Exit then
			-- Detect is the player enter the gym
			local fight_button_enabled=false
			Gym_Entry.Touched:Connect(function(hit)
				if(not fight_button_enabled) then
					local character = hit.Parent
					local player = game.Players:GetPlayerFromCharacter(character)
					if player and player == game.Players.LocalPlayer then
						fight_button_enabled=true
						Toggle_Fight_Button(true)
					end
				end
			end)

			-- Detect is the player leave the gym
			Gym_Exit.Touched:Connect(function(hit)
				if(fight_button_enabled) then
					local character = hit.Parent
					local player = game.Players:GetPlayerFromCharacter(character)
					if player and player == game.Players.LocalPlayer then
						fight_button_enabled = false
						Toggle_Fight_Button(false)

						if character:getAttribute("Is_Fighting") then
							DisableFightMode:Fire()
						end
					end
				end
			end)
		end
	else
		warn("[BindTools] GymObjects disabled (tournament mode)")
	end

end]]></ProtectedString>
								<string name="ScriptGuid">{D11B24FB-043C-4490-AC07-9876D65EDE7A}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">BindTools.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD2A6A14657E0427AB0207FCD6CCD1678">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterGui/HUD/HUD_Handler/BindTopbar.client.lua
--
--  Description:
--      Sets up and manages custom topbar buttons using TopbarPlus.
--      Provides quick access to settings, invites, changelog, tutorial,
--      and player list toggling. Handles open/close events for UI panels
--      and synchronizes button states accordingly.
--
--  Author(s): Exclusible, Darkzeb, Oriane
--
--  Last Modified: 2025-09-30 by Oriane
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/Open_Settings
--          * Channels_F/Bindable_F/Events/Close_Settings
--          * Channels_F/Bindable_F/Events/Prompt_Invite
--          * Channels_F/Bindable_F/Events/Show_Tutorial_Launcher
--          * Channels_F/Bindable_F/Events/Close_Tutorial
--          * Channels_F/Bindable_F/Events/Voice_Chat_Prompt
--          * Channels_F/Bindable_F/Events/Toggle_Player_List
--          * Channels_F/Bindable_F/Events/Toggle_TopBar
--          * Channels_F/Bindable_F/Events/Open_Changelog
--          * Channels_F/Bindable_F/Events/Close_Changelog
--          * Channels_F/Bindable_F/Events/Close_DailyRewards
--          * Vendor/TopbarPlus (preferred)
--          * TopbarPlus (fallback in ReplicatedStorage)
--      - Roblox Services:
--          * ReplicatedStorage
--          * TweenService
--
--  Notes:
--      - Requires TopbarPlus (v3 Icon API)
--      - Buttons auto-sync with UI states (deselect when closed externally)
--      - ToggleTopBar event controls visibility of all buttons
--      - Designed for client-side use only (StarterPlayerScripts)
--
--======================================================================

-- Services
local RS = game:GetService("ReplicatedStorage")
local CS = game:GetService("CollectionService")

-- Modules

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local Open_Settings 		= Channels.Bindable_Events.Open_Settings
local Prompt_Invite 		= Channels.Bindable_Events.Prompt_Invite
local Show_Tutorial_Launcher 	= Channels.Bindable_Events.Show_Tutorial_Launcher
local Close_Tutorial 		= Channels.Bindable_Events.Close_Tutorial
local Toggle_Player_List 	= Channels.Bindable_Events.Toggle_Player_List
local Toggle_TopBar 		= Channels.Bindable_Events.Toggle_TopBar
local Open_Changelog 		= Channels.Bindable_Events.Open_Changelog
local Close_Changelog 		= Channels.Bindable_Events.Close_Changelog
local Close_Settings 		= Channels.Bindable_Events.Close_Settings
local Close_DailyRewards 	= Channels.Bindable_Events.Close_DailyRewards

local function findTopbarPlus()
	-- Priorité: Packages/TopbarPlus (Wally) -> ReplicatedStorage/TopbarPlus (modèle)
	local pkg = RS:FindFirstChild("Vendor")
	if pkg and pkg:FindFirstChild("TopbarPlus") then
		return pkg.TopbarPlus
	end
	return RS:FindFirstChild("TopbarPlus")
end


local TopbarPlusModule = findTopbarPlus()
assert(TopbarPlusModule, "TopBarPlus module not found. Place it in ReplicatedStorage or ReplicatedStorage/Packages.")

local TopbarPlus = require(TopbarPlusModule) -- retourne l’API v3 (Icon)

return function()
	-- clean top bar is already exixting, remove it
	local icons = TopbarPlus.getIcons()
	for _, icon in pairs(icons) do
		icon:Destroy()
	end
	
	-- Settings button
	local settingsButton = TopbarPlus.new()
		:align("Left")
		:setLabel("⚙️", "Deselected")
		:setLabel("❌", "Selected")
		:setCaption("Settings")

	settingsButton.toggled:Connect(function(isSelected)
		Open_Settings:Fire(isSelected)
	end)

	Close_Settings.Event:Connect(function()
		settingsButton:deselect()
	end)

	-- Invite button
	local inviteButton = TopbarPlus.new():setImage("rbxassetid://13436732683"):align("Left")
	inviteButton.toggled:Connect(function()
		Prompt_Invite:Fire()
	end)

	-- Bouton What's New (changelog) en premier
	local changelogButton = TopbarPlus.new()
		:align("Left")
		:setCaption("What's New")  
		:setLabel("📰","Deselected")
		:setLabel("❌","Selected")

	changelogButton.toggled:Connect(function(isSelected)
		if isSelected then
			Open_Changelog:Fire()
		else
			Close_Changelog:Fire()
		end
	end)

	Close_Changelog.Event:Connect(function()
		changelogButton:deselect()
	end)

	-- Tutorial button
	local helpButton = TopbarPlus.new()
		:align("Left")
		:setCaption("Tutorial")
		:setLabel("❔", "Deselected")
		:setLabel("❌", "Selected")

	local widget =	helpButton["cachedNamesToInstances"]["Widget"]
	CS:AddTag(widget, "TutorialButton")
	widget.ClipsDescendants=false
	widget.Parent.ClipsDescendants=false

	helpButton.toggled:Connect(function(isSelected)
		if isSelected then
			Show_Tutorial_Launcher:Fire()
		else
			Close_Tutorial:Fire()
		end
	end)

	Close_Tutorial.Event:Connect(function()
		helpButton:deselect()
	end)

	Show_Tutorial_Launcher.Event:Connect(function()
		helpButton:select()
	end)

	-- List button on the right side
	local listButton = TopbarPlus.new():setImage("rbxassetid://100127687172105"):align("Right")
	listButton.toggled:Connect(function(isSelected)
		Toggle_Player_List:Fire(isSelected)
	end)


	local visible = true
	Toggle_TopBar.Event:Connect(function(bool)
		if bool == nil then
			visible = not visible
		else
			visible = bool
		end

		inviteButton:setEnabled(visible)
		settingsButton:setEnabled(visible)
		changelogButton:setEnabled(visible)
		helpButton:setEnabled(visible)
		listButton:setEnabled(visible)
	end)

	-- Quand l’UI dailyrewards se ferme
	Close_DailyRewards.Event:Connect(function()
		-- commented until we find a satisfying way to pulse with TopBar plus button
		--highlightButton(changelogButton, 5)
		--highlightButton(helpButton, 5)
	end)
end

]]></ProtectedString>
								<string name="ScriptGuid">{7EF2918E-5340-4446-8515-3EA0DCAEB633}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">BindTopbar.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXCDD8FB75A701460789CB77B5DFE2E1EB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CurrencyIndicators</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX02E37AEED54149AD89C0FBC7CE649BC1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIScale</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXE286B3E4324F463D913532C77ED7793C">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local function getDevice()
	if (uis.TouchEnabled == true and uis.KeyboardEnabled == false) then
		return "Mobile"
	elseif (uis.GamepadEnabled == true) then
		return "Console"
	else
		return "PC"
	end
end

while task.wait(1) do
	local device = getDevice()
	if device ~= "Mobile" then
		script.Parent.Scale = 0.8
	else
		script.Parent.Scale = 1
	end
end]]></ProtectedString>
									<string name="ScriptGuid">{D1813B31-14D0-4E29-9C2C-C61610249535}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalScript.client.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXFB98E7CBA6F34D5398E8251B06525D92">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">HalloweenShop</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX03875FCECC614AF3A0647D9F7AC6D7EE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Entry</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX73B61D50443D42699E5317AE794D32C0">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Button</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBXF8405864F4134C1EAFD26A744817DBF8">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Button</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX86B03139CBBE47149AC6DBFD6CD33EAA">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local gradient = script.Parent.Brush:WaitForChild("UIGradient")

local function tweenTo(offset, callback)
	local tween = TweenService:Create(
		gradient,
		TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
		{ Offset = offset }
	)
	tween.Completed:Connect(callback)
	tween:Play()
end

local function loop()
	tweenTo(Vector2.new(1, 0), function()
		tweenTo(Vector2.new(-1, 0), loop)
	end)
end

loop()
]]></ProtectedString>
												<string name="ScriptGuid">{07DB98AA-6BEB-44A1-A159-1413C9F09AA8}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">AnimateGradient.client.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXD57663309CFC45E29D796E52B9730190">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Tools</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX56B833847B964812A7274F3A282B6273">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIScale</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXAE208FF68F3D4FB79BAB8262265A9468">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local function getDevice()
	if (uis.TouchEnabled == true and uis.KeyboardEnabled == false) then
		return "Mobile"
	elseif (uis.GamepadEnabled == true) then
		return "Console"
	else
		return "PC"
	end
end

while task.wait(1) do
	local device = getDevice()
	if device ~= "Mobile" then
		script.Parent.Scale = 0.6
	else
		script.Parent.Scale = 1
	end
end]]></ProtectedString>
									<string name="ScriptGuid">{4096E94C-CE16-4C69-89E9-163D7E570032}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalScript.client.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX03D6C8DA1FBE45548F04AA33CA834C6D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Menu</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX7B3A81D4F9F44FD9B641AFABBAC166CC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIScale</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX1B14743C3A4244F8B6FD7E9011D69DA8">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local function getDevice()
	if (uis.TouchEnabled == true and uis.KeyboardEnabled == false) then
		return "Mobile"
	elseif (uis.GamepadEnabled == true) then
		return "Console"
	else
		return "PC"
	end
end

while task.wait(1) do
	local device = getDevice()
	if device ~= "Mobile" then
		script.Parent.Scale = 0.8
	else
		script.Parent.Scale = 1
	end
end]]></ProtectedString>
									<string name="ScriptGuid">{7EEE3CA5-2A8C-49D5-AB5B-73B60629AF18}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalScript.client.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX8976C72237A141B8A14B264B88D350E5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Player_Stats_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX7C2E1680E7804B61A8525359D81B9F83">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Cam = game.Workspace.CurrentCamera
local Plr = game.Players.LocalPlayer

-- Modules
local Data_Mods_F 					= RS:WaitForChild("Data_Mods_F")
local Elo_Mod						= require(Data_Mods_F:WaitForChild("Elo_Mod"))
local SE_Mod 						= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Country_Mod 					= require(Data_Mods_F:WaitForChild("Country_Mod"))
local Stats_Manager_Mod 			= require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local MenuButtons_Mod 				= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 			= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Stats 					= Channels.Bindable_Events.Open_Stats
local Open_Appearance 				= Channels.Bindable_Events.Open_Appearance

-- UI References
local Main_F = script.Parent.Main_F
local Stats_Main_F = Main_F.Stats_Main_F
local Exit_B = Main_F.Header.Exit_B
local Player_Display_F = Stats_Main_F.Player_Display_F
local Edit_Info_B = Player_Display_F.Edit_Info_B
local Player_Img = Player_Display_F.Player_Img
local Bio_Txt = Player_Display_F.Bio_Txt
local Player_Info_F = Player_Display_F.Player_Info_F
local Player_Name_Txt = Player_Info_F.P_Name_Txt
local Player_DisplayName_Txt = Player_Info_F.P_DisplayName_Txt
local Current_Elo_F = Player_Display_F.Current_Elo_F
local Elo_Img = Current_Elo_F.Elo_Img
local Elo_Txt = Current_Elo_F.Elo_Txt
local Main_Stats_F = Stats_Main_F.Main_Stats_F

local Debounce_C = false
local Debounce_E = false
local Debounce_UI = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end


local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	task.wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Stats_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Toggle_Side_Buttons:Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Setup_Main(T_Plr)
	if T_Plr.Name == Plr.Name then
		Edit_Info_B.Size = UDim2.new(0.225, 0, 0.15, 0)
		
		table.insert(Cons, Edit_Info_B.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				SE_Mod.PlaySFX(Plr, "Click_SE")
				TS:Create(Edit_Info_B, Tween_Click, {Size = UDim2.new(0.16875, 0, 0.1125, 0)}):Play()
				
				Remove_UI()
				Open_Appearance:Fire()
				
				task.wait(0.25)
				Debounce_C = false
			end
		end))
		
		Edit_Info_B.Visible = true
	else
		Edit_Info_B.Visible = false
	end
	
	local PD = T_Plr:WaitForChild("Player_Data")
	local data = Stats_Manager_Mod.Create_Fight_Data_Structure(T_Plr.Character)
	local Range, Amount = Elo_Mod.Get_Player_Rank_Data(T_Plr)
	local country, img = Country_Mod.Get_Player_Country_Data(T_Plr)
	
	--// Player Info
	Player_Name_Txt.Text = T_Plr.DisplayName
	Player_DisplayName_Txt.Text = "@"..T_Plr.Name
	Player_Info_F.Image = img
	Elo_Img.ImageColor3 = Range['Color']
	Elo_Img.Image = Range["Icon"]
	Elo_Txt.Text = Format_Number(Amount)
	Player_Img.Image = game.Players:GetUserThumbnailAsync(T_Plr.UserId, Enum.ThumbnailType.AvatarThumbnail, Enum.ThumbnailSize.Size420x420)
	
	--// Main Stats
	Main_Stats_F.Strike_Percentage_F.Data_Val_Txt.Text = tostring(math.floor((data["Strikes Landed"]-1)/(data["Total Strikes"]-1) * 100)).."%"
	Main_Stats_F.Dodged_Strikes_F.Data_Val_Txt.Text = Format_Number(data["Dodged Strikes"])
	Main_Stats_F.Total_Takedowns_F.Data_Val_Txt.Text = Format_Number(data["Takedowns Landed"]).."/"..Format_Number(data["Takedowns Attempted"])
	Main_Stats_F.Total_Submissions_F.Data_Val_Txt.Text = Format_Number(data["Submissions Finished"]).."/"..Format_Number(data["Submissions Attempted"])
	Main_Stats_F.Total_Knockouts_F.Data_Val_Txt.Text = Format_Number(data["Leg Knockout Wins"] + data["Punch Knockout Wins"])
	Main_Stats_F.Total_Wins_F.Data_Val_Txt.Text = Format_Number(PD["Total Wins"].Value).."/"..Format_Number(PD["Total Matches"].Value)
	Main_Stats_F.Total_Ranked_Wins_F.Data_Val_Txt.Text = Format_Number(PD["Ranked Wins"].Value).."/"..Format_Number(PD["Ranked Matches"].Value)
	Main_Stats_F.Win_Streak_F.Data_Val_Txt.Text = Format_Number(PD["Win Streak"].Value)
	
	
	if (T_Plr:WaitForChild("Player_Data"):WaitForChild("Bio").Value ~= "") then
		Bio_Txt.Text = T_Plr:WaitForChild("Player_Data"):WaitForChild("Bio").Value
	else
		Bio_Txt.Text = "No Bio"
	end

end

local function Show_UI(T_Plr)
	local function Reset_Display()
		Disconnect_Cons()
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.575, 0)

		local Stats_Blurr = game.Lighting:FindFirstChild("Stats_Blurr")
		if(Stats_Blurr ~= nil)then
			Stats_Blurr:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()
	
	Setup_Main(T_Plr)
	
	MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)

	local function Display_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Stats_Blurr"

		Toggle_Side_Buttons:Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

Open_Stats.Event:Connect(function(T_Plr)
	if(Debounce_UI == false)then
		if(T_Plr == nil)then
			T_Plr = Plr
		end
		
		Show_UI(T_Plr)
	else
		Remove_UI()
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{5DF48F6C-DE35-4D39-80B5-72AC87133A52}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Player_Stats_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX3BCA6363F5854ABAA113505AC524087C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Rewards_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA3E93C06DEB340B2824371FF70DB1394">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local Cam = game.Workspace.CurrentCamera
local PD = Plr:WaitForChild("Player_Data")

-- Modules
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local StartupUIManager	= require(RS:WaitForChild("Modules"):WaitForChild("StartupUIManager"))

local Channels = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
-- Require submodules
local DailyRewards = require(script:WaitForChild("DailyReward"))
local QuestRewards = require(script:WaitForChild("QuestsReward"))
local SessionsRewards = require(script:WaitForChild("SessionReward"))

-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 		= Channels.Bindable_Events.Toggle_Side_Buttons
local Toggle_Tutorial_OK_Button = Channels.Bindable_Events.Toggle_Tutorial_OK_Button
local Open_Daily_Rewards 		= Channels.Bindable_Events.Open_Daily_Rewards
local Open_Session_Rewards 		= Channels.Bindable_Events.Open_Session_Rewards

-- UI References
local Core_UI = script.Parent.Main_F
local Exit_B = Core_UI.Header.Exit_B
local Main_Data_F = Core_UI.Main_Data_F
local Tabs_Buttons_F = Main_Data_F.Tabs_Buttons_F
local Tabs_Data = {
	["daily tab"] = {
		Frame =  Main_Data_F:WaitForChild("DailyRewards_F"),
		Show_Function = DailyRewards.Show
	}, 
	["quest tab"] = {
		Frame =Main_Data_F:WaitForChild("QuestRewards_F"),
		Show_Function = QuestRewards.Show
	},
	["session tab"] = {
		Frame = Main_Data_F:WaitForChild("SessionRewards_F"),
		Show_Function = SessionsRewards.Show
	}
}

-- Debounce variables
local Debounce_UI = false


-- Connections table
local Cons = {}
local function Disconnect_Cons()
    for i = 1, #Cons do
        if Cons[i] ~= nil then
            Cons[i]:Disconnect()
        end
    end
    table.clear(Cons)
end

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)

local function Remove_UI()
    Disconnect_Cons()
    Core_UI:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
    TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

    Core_UI.Visible = false
    Core_UI.Position = UDim2.new(0.5, 0, 0.675, 0)

    local Blur = game.Lighting:FindFirstChild("Rewards_Blurr")
    if Blur ~= nil then
        Blur:Destroy()
    end
    Cam.FieldOfView = 70
    Toggle_Side_Buttons:Fire(true, true)
    Toggle_Tutorial_OK_Button:Fire(true)
	Debounce_UI = false
	
	-- notify StartupUIManager to move to the next UI
	StartupUIManager.notifyClose("StarterGui.Menus.Rewards_UI")
end

local function Set_Init_Cam_Effects()
	Disconnect_Cons()
	Core_UI.Visible = false
	Core_UI.Position = UDim2.new(0.5, 0, 0.575, 0)
	local Inv_Blurr = game.Lighting:FindFirstChild("Rewards_Blurr")
	if Inv_Blurr ~= nil then
		Inv_Blurr:Destroy()
	end
	Cam.FieldOfView = 70
	Core_UI.Visible = true
	Core_UI:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
	local Blur = Instance.new("BlurEffect", game.Lighting)
	Blur.Name = "Rewards_Blurr"
	Toggle_Side_Buttons:Fire(false, true)
	Toggle_Tutorial_OK_Button:Fire(false)
end

-- Build context for submodules
local context = {
	PD = PD,
	 
	DailyRewards_F = Main_Data_F:WaitForChild("DailyRewards_F"), 
	QuestRewards_F = Main_Data_F:WaitForChild("QuestRewards_F"),
	SessionRewards_F =Main_Data_F:WaitForChild("SessionRewards_F")
}

-- Set up combinations and equipment panels
DailyRewards:SetUp(context)
QuestRewards:SetUp(context)
SessionsRewards:SetUp(context)

-- Display UI function
local function Display_UI(open)
    if not Core_UI.Visible then
        
		Set_Init_Cam_Effects()
		
		-- Tabs and Exit buttons handlers based on Tabs table
		for Tab_B_Name, Tab_Data in pairs(Tabs_Data) do
			local Tab_B = Tabs_Buttons_F:FindFirstChild(Tab_B_Name)
			if Tab_B:IsA("ImageButton") then
				MenuButtons_Mod.Setup_Tab_Button(Cons, Tab_B, Tabs_Buttons_F, Tabs_Data)
			end	
		end
		
		MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)
		
		-- Activated the called tab
		if open == "Daily Rewards" then
			MenuButtons_Mod.Activate_Tab("daily tab", Tabs_Buttons_F, Tabs_Data) 
		elseif open == "Session Rewards" then
			MenuButtons_Mod.Activate_Tab("session tab", Tabs_Buttons_F, Tabs_Data)
		elseif open == "Quest Rewards" then
			MenuButtons_Mod.Activate_Tab("quest tab", Tabs_Buttons_F, Tabs_Data)
		end
    end
end

-- Connect open events
Open_Daily_Rewards.Event:Connect(function()
    if Debounce_UI == false then
        Debounce_UI = true
		Display_UI("Daily Rewards")
		
    else
        Remove_UI()
    end
end)

Open_Session_Rewards.Event:Connect(function()
    if Debounce_UI == false then
        Debounce_UI = true
		Display_UI("Session Rewards")
    else
        Remove_UI()
    end
end)]]></ProtectedString>
							<string name="ScriptGuid">{6EDC4660-F9AA-4AFD-8787-C5A771879D4E}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Rewards_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX792E76961DBE498C9AE2447D3487A19F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Rewards_Handle</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX9E503E3468624DF2BF6C8C56FF5451C8">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local DailyReward = {}

--------------------------------------------------------
-- // SERVICES & DEPENDENCIES
--------------------------------------------------------
local TS   = game:GetService("TweenService")
local RS   = game:GetService("ReplicatedStorage")
local Plr  = game.Players.LocalPlayer

--------------------------------------------------------
-- // CHANNELS & EVENTS
--------------------------------------------------------
local Channels              = require(RS.Modules.Channels)

local Display_Data_E 				= Channels.Bindable_Events.Display_Data
local Claim_Daily_Reward			= Channels.CS_Remote_Functions.Claim_Daily_Reward

--------------------------------------------------------
-- // MODULES & DATA
--------------------------------------------------------
local Data_Mods_F   = RS:WaitForChild("Data_Mods_F")

local Rewards_Mod 					= require(Data_Mods_F:WaitForChild("Rewards_Mod"))
local SE_Mod 		= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

--------------------------------------------------------
-- // STATE VARIABLES
--------------------------------------------------------
local context = nil
local tab_cons = {}
local Debounce_E = false
local Debounce_C = false
local Main_Data_F = nil
local D7_Tab = nil

--------------------------------------------------------
-- // UTILITY FUNCTIONS
--------------------------------------------------------

-- Disconnect all event connections
local function DisconnectCons()
	for _, c in ipairs(tab_cons) do
		c:Disconnect()
	end
	table.clear(tab_cons)
end

--------------------------------------------------------
-- // INITIAL SETUP
--------------------------------------------------------

function DailyReward:SetUp(ctx)
	context = ctx
	DisconnectCons()
	-- UI References
	Main_Data_F = context.DailyRewards_F.Data_F.Main_Data_F
	D7_Tab = context.DailyRewards_F.Data_F.Day_7

	local Claimed_Keys = Rewards_Mod.Get_Claimed_Daily_Player_Rewards(Plr)
	local Claim_Streak = Rewards_Mod.Get_Player_Retention_Streak(Plr)

	local function Claim_Reward_Handle(T, Key)
		local Reward_Data = Rewards_Mod.Get_Specific_Daily_Reward(Key)
		local PB = T:FindFirstChild("Claim_B")
		local Status_Txt = PB:FindFirstChildWhichIsA("TextLabel")
		local Reward_Img = T:FindFirstChild("Reward_Img")
		local Claimed_Img = T:FindFirstChild("Claimed_Img")
		local Claimed_Indicator = T:FindFirstChild("ClaimedIndicator")

		local Did_Claim = Claim_Daily_Reward:InvokeServer(Key)
		if(Did_Claim)then
			SE_Mod.PlaySFX(Plr, "Sold_SE")
			Display_Data_E:Fire("🎉 Successfully Claimed & Earned " .. Reward_Data['Name'], Color3.fromRGB(170, 255, 0))
			Claimed_Keys = Rewards_Mod.Get_Claimed_Daily_Player_Rewards(Plr)

			Status_Txt.Text = "Claimed!"
			Reward_Img.ImageColor3 = Color3.fromRGB(100, 100, 100)
			Claimed_Img.Visible = true
			Claimed_Indicator.Visible = true
			PB.Visible = false
		else
			Display_Data_E:Fire("❌ Failed to Claim this Reward!", Color3.new(1, 0, 0))
		end
	end

	local function Init_Tab_Update()
		local function Update_Tab(T)
			local PB = T:FindFirstChild("Claim_B")
			local Status_Txt = PB:FindFirstChildWhichIsA("TextLabel")
			local Selected = T:FindFirstChild("Selected")
			local Reward_Img = T:FindFirstChild("Reward_Img")
			local Claimed_Img = T:FindFirstChild("Claimed_Img")
			local Day_Txt = T:FindFirstChild("Day_Txt")
			local Claimed_Indicator = T:FindFirstChild("ClaimedIndicator")
			local Key = string.gsub(T.Name, "Day_", "")
			Key = tonumber(Key)
			Day_Txt.Text = "Day " .. Key

			if(table.find(Claimed_Keys, Key .. "") ~= nil)then
				Status_Txt.Text = "Claimed!"
				Reward_Img.ImageColor3 = Color3.fromRGB(100, 100, 100)
				Claimed_Img.Visible = true
				Claimed_Indicator.Visible = true
				PB.Visible = false
			else
				Reward_Img.ImageColor3 = Color3.new(1, 1, 1)
				Claimed_Img.Visible = false
				Claimed_Indicator.Visible = false
				PB.Visible = true
				if(Claim_Streak >= Key)then
					Status_Txt.Text = "CLAIM!"
				else
					Status_Txt.Text = "Soon" --"Day " .. Key
				end
			end

			table.insert(tab_cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")
					PB.ImageColor3 = Color3.fromRGB(150, 150, 150)

					Debounce_E = false
				end
			end))

			table.insert(tab_cons, Selected.MouseLeave:Connect(function()
				PB.ImageColor3 = Color3.new(1, 1, 1)
			end))	


			local function Get_Click_Size()
				if(T.Parent == Main_Data_F)then
					return UDim2.new(0.178125, 0, 0.46875, 0)
				else
					return UDim2.new(0.136875, 0, 0.46875, 0)
				end
			end

			table.insert(tab_cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")

					TS:Create(T, Tween_Click, {Size = Get_Click_Size()}):Play()

					if(Status_Txt.Text == "Claimed!")then
						Display_Data_E:Fire("✔️ You've already Claimed this Reward!", Color3.fromRGB(0, 225, 0))
					elseif(Status_Txt.Text ~= "CLAIM!")then
						Display_Data_E:Fire("❌ You can't Claim this Reward yet!", Color3.new(1, 0, 0))
					else
						Claim_Reward_Handle(T, Key)
					end

					task.wait(0.25)
					Debounce_C = false
				end
			end))	
		end

		local Tabs = Main_Data_F:GetChildren()
		for i, v in pairs(Tabs) do
			if v.ClassName == "ImageLabel" then
				Update_Tab(v)
			end
		end
		--Update Day 7 Reward Tab
		Update_Tab(D7_Tab)
	end
	Init_Tab_Update()
end

function DailyReward:Show()
	
end

--------------------------------------------------------
-- // RETURN MODULE
--------------------------------------------------------
return DailyReward
]]></ProtectedString>
								<string name="ScriptGuid">{60B88048-4E8A-4741-9169-BE70A3E95058}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">DailyReward.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXDB68DF66B65640FAA585A5566074D20A">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[

local SessionReward = {}

--------------------------------------------------------
-- // SERVICES & DEPENDENCIES
--------------------------------------------------------
local RS   = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Plr  = game.Players.LocalPlayer

--------------------------------------------------------
-- // CHANNELS & EVENTS
--------------------------------------------------------
local Channels              = require(RS.Modules.Channels)
local ProgressRE     		= Channels.SC_Remote_Events.Session_Reward_Progress
local ClaimRF       		= Channels.CS_Remote_Functions.Claim_Session_Reward
local GetProgressRF  		= Channels.CS_Remote_Functions.Get_Session_Progress

--------------------------------------------------------
-- // MODULES & DATA
--------------------------------------------------------
local Data_Mods_F   = RS:WaitForChild("Data_Mods_F")
local ThemeManager 			= require(game.ReplicatedStorage.Design.ThemeManager)
local SE_Mod 		= require(Data_Mods_F:WaitForChild("Sound_Mod"))


--------------------------------------------------------
-- // STATE VARIABLES
--------------------------------------------------------
local context = nil
local tab_cons = {}
local rows = {}
local thresholds, claimed = {}, {}
local elapsed, lastServerElapsed, lastUpdateTime = 0, 0, 0
local claimsDone, maxClaimsToday = 0, 0
 
--------------------------------------------------------
-- // UTILITY FUNCTIONS
--------------------------------------------------------

-- Disconnect all event connections
local function DisconnectCons()
	for _, c in ipairs(tab_cons) do
		c:Disconnect()
	end
	table.clear(tab_cons)
end

--====================================================
-- Utilities
--====================================================
local function fmt(sec)
	sec = math.floor(tonumber(sec) or 0)
	if sec < 60 then
		return "<1 min"
	end
	return string.format("%d min", math.floor(sec / 60))
end

local function updateButton(row, unlocked, remaining, isClaimed, canClaim)
	local btn = row.btn
	if not btn then return end

	if isClaimed or (maxClaimsToday > 0 and claimsDone >= maxClaimsToday) then
		btn.Text = "Claimed"
		btn.Active = false
		btn.AutoButtonColor = false
		
		btn.BackgroundColor3 =  ThemeManager.getColor("menus", "CallToAction_Disabled_Color") --Color3.fromRGB(56, 33, 9)
	elseif not unlocked then
		btn.Text = "Locked (" .. fmt(remaining) .. ")"
		btn.Active = false
		btn.AutoButtonColor = false
		btn.BackgroundColor3 =   ThemeManager.getColor("menus", "CallToAction_Disabled_Color") --Color3.fromRGB(56, 33, 9)
	else
		btn.Text = "CLAIM!"
		btn.Active = true
		btn.AutoButtonColor = true
		btn.BackgroundColor3 =  ThemeManager.getColor("menus", "CallToAction_Color") -- Color3.fromRGB(35, 244, 68)
	end
end

--====================================================
-- Rendering
--====================================================
local function render()
	for i, th in ipairs(thresholds) do
		local row = rows[i]
		if not row then break end

		local unlocked = elapsed >= th.t
		local remaining = math.max(0, th.t - elapsed)
		local label = row.label
		if label then
			local base = (th.reward and th.reward.label) or tostring(th.t) .. "s"
			label.Text = base
		end

		updateButton(row, unlocked, remaining, claimed[th.t], unlocked)
	end
end

--------------------------------------------------------
-- // INITIAL SETUP
--------------------------------------------------------

function SessionReward:SetUp(ctx)
	context = ctx
	DisconnectCons()
	-- UI References
	local frame = ctx.SessionRewards_F
	local holder = frame.Main_Data_F.Holder
	
	--====================================================
	-- Setup rows
	--====================================================
	for i = 1, 4 do
		local r = holder:FindFirstChild("Row" .. i)
		if r then
			rows[i] = {
				container = r,
				label = r:FindFirstChild("Label") or r:FindFirstChild("TextLabel"),
				btn = r:FindFirstChild("Button") or r:FindFirstChildWhichIsA("TextButton"),
			}
		end
	end

	--====================================================
	-- Claim button handlers
	--====================================================
	for i, row in ipairs(rows) do
		if row.btn then
			row.btn.MouseButton1Click:Connect(function()
				local th = thresholds[i]
				if not th then return end
				if claimed[th.t] or (maxClaimsToday > 0 and claimsDone >= maxClaimsToday) or elapsed < th.t then return end

				local res = ClaimRF:InvokeServer(th.t)
				if res and res.ok then
					claimed[th.t] = true
					claimsDone += 1
					SE_Mod.PlaySFX(Plr, "Sold_SE")
					render()
				end
			end)
		end
	end

	--====================================================
	-- Server progress updates
	--====================================================
	table.insert(tab_cons,ProgressRE.OnClientEvent:Connect(function(payload)
		if not payload then return end

		thresholds = payload.thresholds or thresholds
		lastServerElapsed = payload.elapsed or 0
		lastUpdateTime = os.clock()
		elapsed = lastServerElapsed
		claimsDone = payload.count or 0
		maxClaimsToday = payload.maxClaims or 0

		claimed = {}
		if typeof(payload.claimedTimes) == "string" and payload.claimedTimes ~= "" then
			for _, s in ipairs(string.split(payload.claimedTimes, ",")) do
				local n = tonumber(s)
				if n then claimed[n] = true end
			end
		end

		render()
	end))

	--====================================================
	-- Frame-based update (smoothed)
	--====================================================
	local frameUpdateInterval = 0.5
	local lastRender = 0

	table.insert(tab_cons,RunService.RenderStepped:Connect(function()
		if lastServerElapsed <= 0 then return end
		local now = os.clock()
		elapsed = lastServerElapsed + (now - lastUpdateTime)
		if now - lastRender >= frameUpdateInterval then
			render()
			lastRender = now
		end
	end))
end

function SessionReward:Show()
	-- Refresh state from server
	local payload = GetProgressRF:InvokeServer()
	if payload then
		thresholds = payload.thresholds or thresholds
		lastServerElapsed = payload.elapsed or 0
		lastUpdateTime = os.clock()
		elapsed = lastServerElapsed
		claimsDone = payload.count or 0
		maxClaimsToday = payload.maxClaims or 0

		claimed = {}
		if typeof(payload.claimedTimes) == "string" and payload.claimedTimes ~= "" then
			for _, s in ipairs(string.split(payload.claimedTimes, ",")) do
				local n = tonumber(s)
				if n then claimed[n] = true end
			end
		end
	end

	render()
end

--------------------------------------------------------
-- // RETURN MODULE
--------------------------------------------------------
return SessionReward
]]></ProtectedString>
								<string name="ScriptGuid">{91E169FB-1E76-4CB5-B22E-E7A6056D1F99}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">SessionReward.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX9F93A3CA4A424AF4AC53837D941E3F3C">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local QuestsReward = {}

--------------------------------------------------------
-- // SERVICES & DEPENDENCIES
--------------------------------------------------------
--local TS   = game:GetService("TweenService")
--local RS   = game:GetService("ReplicatedStorage")
--local Plr  = game.Players.LocalPlayer
--local Cam  = game.Workspace.CurrentCamera

--------------------------------------------------------
-- // CHANNELS & EVENTS
--------------------------------------------------------
--local Channels              = require(RS.Modules.Channels)

--------------------------------------------------------
-- // MODULES & DATA
--------------------------------------------------------
--local Data_Mods_F   = RS:WaitForChild("Data_Mods_F")

--------------------------------------------------------
-- // STATE VARIABLES
--------------------------------------------------------
local context = nil
local tab_cons = {}

--------------------------------------------------------
-- // UTILITY FUNCTIONS
--------------------------------------------------------

-- Disconnect all event connections
local function DisconnectCons()
	for _, c in ipairs(tab_cons) do
		c:Disconnect()
	end
	table.clear(tab_cons)
end

--------------------------------------------------------
-- // INITIAL SETUP
--------------------------------------------------------

function QuestsReward:SetUp(ctx)
	context = ctx
	DisconnectCons()

end

function QuestsReward:Show()

end

--------------------------------------------------------
-- // RETURN MODULE
--------------------------------------------------------
return QuestsReward
]]></ProtectedString>
								<string name="ScriptGuid">{5EBD0664-733A-4086-BDC7-4A8CEA8EB169}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">QuestsReward.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX8EFF19475F9E412282543EA8F8F72C21">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Punching_Game_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA99D0096B9E74C24A01383545430D2BA">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--// Services
local TS  = game:GetService("TweenService")
local RS  = game:GetService("ReplicatedStorage")

local Plr = game.Players.LocalPlayer
local character = Plr.Character or Plr.CharacterAdded:Wait()

local Cam = workspace.CurrentCamera

--// Modules (your requires)
local MenuButtons_Mod     = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local Channels            = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local ToggleCameraLock    = require(RS:WaitForChild("Data_Mods_F"):WaitForChild("ToggleCameraLock_Mod"))
local Utils 			  = require(game.ReplicatedStorage.Modules.Utils)
local PM                  = require(script.PowerMeter)
local timmer              = require(script.CountdownTimmer_Mod)
local SlotMachine_Mod	  = require(script.SlotMachine_Mod)
local BlocksPicker 		  = require(script.PowerMeterBlocksPicker)

--// Channels
local Toggle_Side_Buttons = Channels.Bindable_Events.Toggle_Side_Buttons

local PunchingGame_Action = Channels.Server_Client_Events.PunchingGame_Action
local PunchingGame_Result = Channels.Client_Server_Events.PunchingGame_Result

local Display_Data_E      = Channels.Bindable_Events.Display_Data

--// Scene refs

local PunchingGameFolder = Utils.SafePath(workspace, {
	"Main_World_F", "Gameplay", "Objects", "PunchingGame"
})

if not PunchingGameFolder then
	warn("[PunchingGame] Disabled (tournament mode)")
	return
end

local PunchingGames = {}
local punchMachineTimmerTextObjs ={}

for _,Pgame in ipairs(PunchingGameFolder:GetChildren()) do
	if Pgame:IsA("Model") then
		table.insert(PunchingGames,Pgame)
		local PMTO = Pgame:WaitForChild("BillBoardParent"):WaitForChild("BillboardGui"):WaitForChild("TextLabel")
		if PMTO then
			table.insert(punchMachineTimmerTextObjs,PMTO)
		end
		
	end
end

--// UI refs
local ScreenGui     = script.Parent
local Main_Frame    = ScreenGui:WaitForChild("Main_F")
local Main_F_Result = ScreenGui:WaitForChild("Main_F_Result")
local Message_F     = ScreenGui:WaitForChild("Main_F_Message")
local Main_F_InitialMessage = ScreenGui:WaitForChild("Main_F_InitialMessage")

local Exit_B        = Main_Frame.Header:WaitForChild("Exit_B")

local config =  require(RS:WaitForChild("Data_Mods_F"):WaitForChild("Punching_Game_Config_Mod"))

local Tween_Cam   = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

--// Countdown setup (Billboard)

local PanelText = Main_F_InitialMessage.Body.Stroke.Content.ButtonsHolder_F.Free_B.Get.txt_Timmer
table.insert(punchMachineTimmerTextObjs,PanelText)
local TCountdown = timmer.new(punchMachineTimmerTextObjs, "Punchmachine"..Plr.UserId, "FREE PUNCH ", "", "Ready")

--========================================================
-- Connection cleanup
--========================================================

local Cons = {}
local Message_Cons = {}
local claimConn : RBXScriptConnection? = nil
local meter = nil
local CurrentMachine=nil

local function DisconnectList(list)
	for i = 1, #list do
		local c = list[i]
		if c then
			c:Disconnect()
		end
	end
	table.clear(list)
end

local function ClearClaimConn()
	if claimConn then
		claimConn:Disconnect()
		claimConn = nil
	end
end

--========================================================
-- Blur + Camera helpers
--========================================================
local function GetBlur()
	return game.Lighting:FindFirstChild("Starter_Pack_Blurr")
end

local function SetBlur(on: boolean)
	local b = GetBlur()
	if on then
		if not b then
			b = Instance.new("BlurEffect")
			b.Name = "Starter_Pack_Blurr"
			b.Parent = game.Lighting
		end
	else
		if b then b:Destroy() end
	end
end



--========================================================
-- Countdown logic
--========================================================
local function SetText()
	for _, text in ipairs(punchMachineTimmerTextObjs) do
		if text then
			text.Text = "Ready"
		end
	end
end


local function StartCountdown()
	local PD = Plr:WaitForChild("Player_Data")

	local lastTimePunch = PD:FindFirstChild("lastTimePunch")
	if not lastTimePunch then
		SetText()
		return
	end


	local now = os.time()
	local endsAt = lastTimePunch.Value + config.COOLDOWN_SECONDS

	if endsAt > now then
		TCountdown:StartCountdown(endsAt, function()
			SetText()
		end)
	else
		TCountdown:StopCountdown()
		SetText()
	end
end

do
	local PD = Plr:WaitForChild("Player_Data")

	local lastTimePunch = PD:FindFirstChild("lastTimePunch")
	if lastTimePunch then
		lastTimePunch:GetPropertyChangedSignal("Value"):Connect(StartCountdown)
	else
		PD.ChildAdded:Connect(function(ch)
			if ch.Name == "lastTimePunch" then
				ch:GetPropertyChangedSignal("Value"):Connect(StartCountdown)
				StartCountdown()
			end
		end)
	end
end

task.defer(StartCountdown)


--========================================================
-- UI State Machine
--========================================================
local State = "Hidden" -- Hidden | Game | Results | Message

local function HideAllFrames()
	Main_Frame.Visible = false
	Main_F_Result.Visible = false
	Message_F.Visible = false
	Main_F_InitialMessage.Visible=false
end

local function ResetHiddenPositions()
	-- your original "hidden" positions
	Main_F_InitialMessage.Position= UDim2.new(0.5, 0, 0.675, 0)
	Main_Frame.Position    = UDim2.new(0.5, 0, 0.675, 0)
	Main_F_Result.Position = UDim2.new(0.5, 0, 0.675, 0)
end

local function CleanupStateStuff()
	DisconnectList(Cons)
	DisconnectList(Message_Cons)
	ClearClaimConn()

	if meter then
		meter:Destroy()
		meter = nil
	end
end


local function FillBlocks(blocksTable, parentFrame)

	local function CleanUp(Parent)
		for _, ch in ipairs(Parent:GetChildren()) do
			if ch:IsA("Frame") then
				ch:Destroy()
			end
		end
	end
	local LegendParent=Main_Frame.Legend.Data
	local LegendTMP = Main_Frame.Legend.Legend_TMP
	CleanUp(parentFrame)
	CleanUp(LegendParent)
	
	local maxBonus = 0
	for Key, info in pairs(blocksTable) do

		if not LegendParent:FindFirstChild(info.Bonus) then

			local LegendItem = LegendTMP:Clone()
			LegendItem.Parent=LegendParent
			LegendItem.Name=info.Bonus

			local BounsText = LegendItem:FindFirstChild("text")
			local color = LegendItem:FindFirstChild("color")

			if color then
				color.BackgroundColor3 = info.BgColor or Color3.new(1, 1, 1)
				color.BackgroundTransparency = info.Transparency or 0
			end
			maxBonus = math.max(maxBonus, info.Bonus or 0)
			if BounsText then

				BounsText.Text = string.upper(tostring(info.Title)).." +" .. config.RewardsOnPunch[info.Title].."💵"
			end 
			LegendItem.Visible=true
		end


		local f = Instance.new("Frame")
		f.Name = Key

		f.BackgroundColor3 = info.BgColor or Color3.new(1, 1, 1)
		f.BackgroundTransparency = info.Transparency or 0

		local wPct = info.WidthPct
		if wPct then
			f.Size = UDim2.new(wPct/100, 0, 1, 0)
		else
			f.Size = UDim2.new(0.12, 0, 1, 0) -- default
		end
		f.BorderSizePixel = 0
		f.LayoutOrder = (info.SortingIndex ~= nil) and info.SortingIndex or 0

		f.Parent = parentFrame
	end
	for _, ch in ipairs(LegendParent:GetChildren()) do
		if ch:IsA("Frame") then
			local bonus = tonumber(ch.Name) or 0
			ch.LayoutOrder = maxBonus - bonus
		end
	end

end

FillBlocks(config.BonusBlocksInfo, ScreenGui.Main_F.Bar:WaitForChild("BonusBlocks"))

--========================================================
-- SetState (single source of truth)
--========================================================
local function SetState(newState: string, payload)
	if State == newState then return end
	State = newState

	ScreenGui.Enabled = true
	CleanupStateStuff()

	if newState == "Hidden" then
		HideAllFrames()
		ResetHiddenPositions()
		Plr.Character.Name_Tag_UI.Enabled=true
		SetBlur(false)
		TS:Create(Cam, Tween_Cam, { FieldOfView = 70 }):Play()
		--UnlockCamera()
		ToggleCameraLock.UnlockCamera(Cam,Plr)
		Toggle_Side_Buttons:Fire(true, true)

		StartCountdown()
		return
	end

	-- Shared effects for Game/Results/Message (you asked this)
	SetBlur(true)
	TS:Create(Cam, Tween_Cam, { FieldOfView = 40 }):Play()
	Toggle_Side_Buttons:Fire(false, true)

	if newState == "Game" then

		HideAllFrames()
		ResetHiddenPositions()
		local CamPos    = CurrentMachine:WaitForChild("CamPos")

		Plr.Character.Name_Tag_UI.Enabled = false
		--LockCameraAt(0.12, CamPos.CFrame)
		ToggleCameraLock.LockCameraAt(0.12, CamPos.CFrame,Cam)
		Main_Frame.Visible = true
		Main_Frame:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true)

		-- Exit button
		do
			local Def_Size = UDim2.new(0.118, 0, 0.2, 0)
			Exit_B.Size = Def_Size

			table.insert(Cons, Exit_B.MouseEnter:Connect(function()
				Exit_B:TweenSize(UDim2.new(0.09, 0, 0.2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true)
			end))

			table.insert(Cons, Exit_B.MouseLeave:Connect(function()
				Exit_B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true)
			end))

			table.insert(Cons, Exit_B.MouseButton1Click:Connect(function()
				TS:Create(Exit_B, Tween_Click, { Size = UDim2.new(0.09, 0, 0.2, 0) }):Play()
				PunchingGame_Result:FireServer("CloseUI")
				SetState("Hidden")
			end))
		end

		-- Meter
		meter = PM.new(ScreenGui, {
			speedMin = config.needleMinSpeed,
			speedMax = config.needleMaxSpeed,
			perfectCenter = 0.5,
			perfectWidth = 0.1,
			goodWidth = 0.28,
			input = "click",
		})

		-- Stroke helper (creates if missing)
		--local function ensureStroke(fr: Instance): UIStroke
		--	local stroke = fr:FindFirstChildOfClass("UIStroke")
		--	if not stroke then
		--		stroke = Instance.new("UIStroke")
		--		stroke.Name = "SelectStroke"
		--		stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		--		stroke.LineJoinMode = Enum.LineJoinMode.Round
		--		stroke.Thickness = 3
		--		stroke.Transparency = 0
		--		stroke.Color = Color3.new(0.666667, 0, 0) -- dark red
		--		stroke.Enabled = false
		--		stroke.Parent = fr
		--	end
		--	return stroke
		--end

		local blocksContainer = ScreenGui.Main_F.Bar:WaitForChild("BonusBlocks")
		local rng = Random.new()
		blocksContainer.Position = UDim2.new(rng:NextNumber(config.BonusBlocksMinX, config.BonusBlocksMaxX), 0, 0.5, 0)

		-- Collect only the block Frames (ignore UIListLayout)
		local blockFrames = {}
		for _, ch in ipairs(blocksContainer:GetChildren()) do
			if ch:IsA("Frame") then
				table.insert(blockFrames, ch)
			end
		end



		-- Picker (read selected value from selected frame.Name)
		local picker = BlocksPicker.new(blocksContainer, meter.Bar, {
			paddingPx = 6, -- must match PowerMeter.posToPixelX padding

			onSelect = function(frame, idx, value)
				---- disable all strokes
				--for _, fr in ipairs(blockFrames) do
				--	ensureStroke(fr).Enabled = false
				--end

				---- enable only selected (if frame exists)
				--if frame then
				--	local stroke = ensureStroke(frame)
				--	stroke.Transparency = 0
				--	stroke.Enabled = true
				--end
			end,

			onDeselect = function(frame, idx, value)
				-- optional: keep empty (we disable-all on select anyway)
			end,
		})

		meter:Prompt(function(result)
			task.wait(.5)

			local idx, frame = picker:GetIndexFromT(result.value)
			local bonusItemData= config.BonusBlocksInfo[frame.Name]
			local bonus = bonusItemData.Bonus
			-- highlight selection
			--picker:SelectByT(result.value)

			result.bonus = bonus
			--print("Stopped on block:", frame and frame.Name, "idx:", idx, "bonus:", bonus)

			local Blur = game.Lighting:FindFirstChild("Starter_Pack_Blurr")
			if Blur then
				Blur:Destroy()
			end

			Main_Frame.Visible = false
			PunchingGame_Result:FireServer("Result", result)
		end)

		return
	end

	if newState == "Results" then
		HideAllFrames()
		ResetHiddenPositions()
		Plr.Character.Name_Tag_UI.Enabled=false
		

		local camPosResult = CurrentMachine:WaitForChild("CamPosResult")
		
		--LockCameraAt(0.12,camPosResult.CFrame)
		ToggleCameraLock.LockCameraAt(0.12, camPosResult.CFrame,Cam)
		ScreenGui.Enabled = true
		Main_F_Result.Visible = true
		SetBlur(false)
		Main_F_Result.Position = UDim2.new(0.5, 0, 0.675, 0)
		Main_F_Result:TweenPosition(UDim2.new(0.507, 0, 0.49, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true)

		local ok, err = pcall(function()

			local SlotMachine = SlotMachine_Mod.new(Main_F_Result)
			SlotMachine:Fill(payload, function(data)
				--Display_Data_E:Fire("🎉 Reward claimed! +"..tostring(payload.gems) .." 💵 added to your account. ",Color3.fromRGB(0, 170, 0))
				PunchingGame_Result:FireServer("RewardClaimed")
				SetState("Hidden")
			end)

		end)

		if not ok then
			warn("[Punching Results] FillResultsData error:", err)
			-- Still show something usable
			local msg = Main_F_Result:FindFirstChild("Message", true)
			if msg and msg:IsA("TextLabel") then
				msg.Text = "Result UI error (check Output)."
			end
		end


		return
	end
	if newState == "InitialMessage" then
		HideAllFrames()
		ResetHiddenPositions()
	
		local camPosResult = CurrentMachine:WaitForChild("CamPosResult")
		Plr.Character.Name_Tag_UI.Enabled=false
		--LockCameraAt(0.12,camPosResult.CFrame)
		ToggleCameraLock.LockCameraAt(0.12, camPosResult.CFrame,Cam)
		ScreenGui.Enabled = true
		Main_F_InitialMessage.Visible = true
		SetBlur(false)
		Main_F_InitialMessage.Position = UDim2.new(0.5, 0, 0.675, 0)
		Main_F_InitialMessage:TweenPosition(UDim2.new(0.5, 0,.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true)
		local iniExit_B = Main_F_InitialMessage.HeaderHolder.Header.HeaderContent:WaitForChild("Exit_B")


		local PD = Plr:WaitForChild("Player_Data")
		local gems = PD:WaitForChild("Gems")

		local FreePunch_B =  Main_F_InitialMessage.Body.Stroke.Content.ButtonsHolder_F.Free_B
		local Gems_B = Main_F_InitialMessage.Body.Stroke.Content.ButtonsHolder_F.Gems_B

		local ActiveColor = Color3.new(0.137255, 0.956863, 0.266667)
		local DeActiveColor =  Color3.new(0.376471, 0.411765, 0.486275)

		local isFree=false

		if string.lower(PanelText.Text)== "ready" then
			isFree=true
			FreePunch_B.Get.BackgroundColor3 = ActiveColor
			FreePunch_B.Get.txt_Ready.Visible=true
			PanelText.Visible=false
			FreePunch_B.Interactable=true
			MenuButtons_Mod.Setup_Base_Button(Cons,FreePunch_B,function()
				SetState("Game")
			end)
		else
			FreePunch_B.Get.BackgroundColor3 = DeActiveColor
			FreePunch_B.Get.txt_Ready.Visible=false
			PanelText.Visible=true
			FreePunch_B.Interactable=false
		end

		if not isFree then
			Gems_B.Get.BackgroundColor3 = ActiveColor
			Gems_B.Interactable=true
			if gems.Value >= config.BuyPunchPrice then
				MenuButtons_Mod.Setup_Base_Button(Cons,Gems_B,function()
					PunchingGame_Result:FireServer("BuyAPlayWithGems")
				end)
			else
				MenuButtons_Mod.Setup_Base_Button(Cons,Gems_B,function()

					PunchingGame_Result:FireServer("CloseUI")
					SetState("Hidden")

					Display_Data_E:Fire(
						"You don’t have enough Gems. Open the shop to get more",
						Color3.fromRGB(170, 0, 0)
					)

				end)
			end

		else
			Gems_B.Interactable=false
			Gems_B.Get.BackgroundColor3 = DeActiveColor
		end
		MenuButtons_Mod.Setup_Exit_X_Button(Cons,iniExit_B,function()
			SetState("Hidden")
			PunchingGame_Result:FireServer("CloseUI")
		end)
	end

	if newState == "Message" then
		HideAllFrames()

		Message_F.Visible = true

		local MessageTxt   = Message_F:FindFirstChild("Message", true)
		local BtnsHolder_F = Message_F:FindFirstChild("ButtonsHolder_F", true)
		local title		   = Message_F:FindFirstChild("Title", true)

		if title and payload.title  then
			title.Text = tostring(payload.title)
		end

		if BtnsHolder_F then
			if BtnsHolder_F:FindFirstChild("No_B") then BtnsHolder_F.No_B.Visible = false end
			if BtnsHolder_F:FindFirstChild("Yes_B") then BtnsHolder_F.Yes_B.Visible = false end
		end

		if MessageTxt then
			MessageTxt.Text = tostring(payload and payload.message or "")
		end

		if payload and BtnsHolder_F then
			if payload.onNo and BtnsHolder_F:FindFirstChild("No_B") then
				BtnsHolder_F.No_B.Visible = true
				if payload.noBtnText and payload.noBtnText~="" then
					BtnsHolder_F.No_B.Get.txt.Text=payload.noBtnText
				end
				table.insert(Message_Cons, BtnsHolder_F.No_B.MouseButton1Click:Connect(function()
					payload.onNo()
				end))
			end

			if payload.onYes and BtnsHolder_F:FindFirstChild("Yes_B") then
				if payload.yesBtnText and payload.yesBtnText~="" then
					BtnsHolder_F.Yes_B.Get.txt.Text=payload.yesBtnText
				end
				BtnsHolder_F.Yes_B.Visible = true
				table.insert(Message_Cons, BtnsHolder_F.Yes_B.MouseButton1Click:Connect(function()
					payload.onYes()
				end))
			end
		end

		return
	end
end

--========================================================
-- Server actions
--========================================================
PunchingGame_Action.OnClientEvent:Connect(function(action, Data)
	task.wait(0.5)

	if action == "GameUI" then
		SetState("Game")
		return
	end

	if action == "InitialMessage" then
		CurrentMachine = Data
		SetState("InitialMessage")
		return
	end
	if action == "BuyAPlay" then
		local seconds = tonumber(Data) or 0
		local mins = math.floor(seconds / 60)
		local PD = Plr:WaitForChild("Player_Data")
		local gems = PD:WaitForChild("Gems")

		SetState("Message", {
			message = ("Wait for %d minutes to play or buy a punch in %d Gems"):format(mins,config.BuyPunchPrice ),
			title = "BUY PUNCH",
			noBtnText = "MAYBE LATER",
			yesBtnText = "BUY PUNCH",
			onNo = function()
				-- just close message
				SetState("Hidden")
				PunchingGame_Result:FireServer("CloseUI")
			end,

			onYes = function()
				SetState("Hidden")

				if gems.Value >= config.BuyPunchPrice  then
					PunchingGame_Result:FireServer("BuyAPlayWithGems")
				else
					PunchingGame_Result:FireServer("CloseUI")
					Display_Data_E:Fire(
						"You don’t have enough Gems. Open the shop to get more",
						Color3.fromRGB(170, 0, 0)
					)
				end
			end
		})
		return
	end

	if action == "ShowResults" then
		SetState("Results", Data)
		return
	end
end)

-- Start hidden by default
SetState("Hidden")]]></ProtectedString>
							<string name="ScriptGuid">{9AF389F3-88EB-43FF-9C85-30CF4656E326}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_PunchingGame_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX8C2EA14EED0F4CB0841C5D2D3E91F155">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_PunchingGame_Handle</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX50AA5EFB33AC4C24B796BF62D3629C72">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- ReplicatedStorage/Modules/PowerMeter.lua
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local PowerMeter = {}
PowerMeter.__index = PowerMeter

-- cfg:
-- speed: sweep units/sec (units are bar width 0..1)
-- perfectCenter: 0..1 (middle of the bar is 0.5)
-- perfectWidth: fraction of bar for "Perfect" zone (e.g. 0.08 = 8%)
-- goodWidth: outer width for "Great" (beyond perfect) (e.g. 0.22)
-- input: "click" or "space"
function PowerMeter.new(gui, cfg)
	local self = setmetatable({}, PowerMeter)
	self.Gui = gui
	self.Bar = gui:WaitForChild("Main_F"):WaitForChild("Bar")
	self.Needle = gui:WaitForChild("Main_F"):WaitForChild("Needle")
	self.Perfect = gui:WaitForChild("Main_F"):WaitForChild("PerfectZone")
	self.Result = gui:WaitForChild("Main_F"):WaitForChild("ResultText")

	self.speedMin = cfg.speedMin or 1
	self.speedMax = cfg.speedMax or 1
	self.center = math.clamp(cfg.perfectCenter or 0.5, 0, 1)
	self.perfectWidth = cfg.perfectWidth or 0.08
	self.goodWidth = cfg.goodWidth or 0.22
	self.inputMode = cfg.input or "click"
	
	-- position PerfectZone
	local size = self.Perfect.Size
	local pos =  self.Perfect.Position

	self.Perfect.Size = UDim2.new(self.perfectWidth/2, 0, size.Y.Scale, 0) 
	self.Perfect.Position = UDim2.new(self.center, 0, pos.Y.Scale, 0)
	self.Perfect.AnchorPoint = Vector2.new(0.5, 0)

	self._running = false
	self._stopped = false
	self._pos = 0.5 -- normalized 0..1
	self._dir = 1
	return self
end

local function powerFromPos(t, center)
	local dist = math.abs(t - center)
	local maxDist = math.max(center, 1 - center)
	local p = 1 - (dist / maxDist)
	return math.clamp(p, 0, 1)
end

local function percentTextFromT(t, center)
	local p = powerFromPos(t, center)
	return math.round(p * 100), p
end

local function posToPixelX(bar: Frame, t)
	local padding = 6 -- keep needle inside rounded corners
	local w = bar.AbsoluteSize.X - padding*2
	return bar.AbsolutePosition.X + padding + w * t
end

function PowerMeter:_bindStopOnce(onStop)
	local function stop()
		if self._running and not self._stopped then
			self._stopped = true
			onStop()
		end
	end
	self._connections = {}

	if self.inputMode == "space" then
		table.insert(self._connections, UserInputService.InputBegan:Connect(function(io,gp)
			if gp then return end
			if io.KeyCode == Enum.KeyCode.Space then stop() end
		end))
	else
		table.insert(self._connections, UserInputService.InputBegan:Connect(function(io,gp)
			if gp then return end
			if io.UserInputType == Enum.UserInputType.MouseButton1 or io.UserInputType == Enum.UserInputType.Touch then
				stop()
			end
		end))
	end
end

function PowerMeter:_disconnectAll()
	if self._connections then
		for _,c in ipairs(self._connections) do
			pcall(function() c:Disconnect() end)
		end
	end
	self._connections = nil
end

local function grade(center, perfectW, goodW, t)
	local d = math.abs(t - center)
	if d <= perfectW * 0.5 then
		return "Perfect"
	elseif d <= goodW * 0.5 then
		return "Great"
	elseif d <= (goodW * 1) then
		return "Good"
	else
		return "Basic"
	end
end

-- Show the widget, animate until the player stops it.
-- Returns a Promise-like callback style for simplicity: onDone(resultTable)
-- result = { value = t(0..1), rating = "Perfect|Great|Good|Miss" }
function PowerMeter:Prompt(onDone)
	self.Gui.Enabled = true
	self.Result.Text = ""
	self._running, self._stopped = true, false
	self._dir = 1
	self._pos = 0 -- start left

	self:_bindStopOnce(function()
		self._running = false
		self:_disconnectAll()
		local t = self._pos
		local r = grade(self.center, self.perfectWidth, self.goodWidth, t)
		local pct, p01 = percentTextFromT(t, self.center)
		self.Result.Text = r
		if onDone then
			onDone({ value = t, rating = r , percent = p01 })
		end
		-- optional: auto hide after short delay
	--	task.delay(0.8, function() self.Gui.Enabled = false end)
	end)

	-- animate needle
	task.spawn(function()
		local last = os.clock()
		while self._running do
			local now = os.clock()
			local dt = now - last
			last = now

			-- ping-pong motion (linear). For sine, replace with: self._pos = 0.5 + 0.5*math.sin(now*self.speed*math.pi)
			self._pos += self._dir * math.random(self.speedMin,self.speedMax)  * dt
			if self._pos >= 1 then self._pos = 1; self._dir = -1 end
			if self._pos <= 0 then self._pos = 0; self._dir = 1 end

			-- move needle
			local x = posToPixelX(self.Bar, self._pos)
			--local barY = self.Bar.AbsolutePosition.Y + self.Bar.AbsoluteSize.Y/2
			local y = self.Needle.Position.Y
			
			self.Needle.Position =UDim2.new(0, x, y.Scale, y.Offset)-- UDim2.fromOffset(x, barY)
			

			RunService.RenderStepped:Wait()
		end
	end)
end

function PowerMeter:Destroy(alsoDestroyGui: boolean?)
	-- stop the animation loop
	self._running = false
	self._stopped = true

	-- disconnect input events
	self:_disconnectAll()

	-- optionally hide / destroy GUI
	if self.Gui then
		self.Gui.Enabled = false
		if alsoDestroyGui then
			self.Gui:Destroy()
		end
	end

	-- clear references to help GC
	self.Gui = nil
	self.Bar = nil
	self.Needle = nil
	self.Perfect = nil
	self.Result = nil

	self._connections = nil
end

return PowerMeter
]]></ProtectedString>
								<string name="ScriptGuid">{49B2E57E-057C-4361-8CB1-C7F2D1176DE5}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">PowerMeter.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0F7E359FC8AE4E9CBA045D38820801B4">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local Countdown = {}
Countdown.__index = Countdown

function Countdown.new(textObject, id, textPrefix, textSuffix, timerFinishedText,TimeTxtCallBack)
	local self = setmetatable({}, Countdown)
	self.TextObject = textObject or {}
	self.TextPrefix = textPrefix or ""
	self.TextSuffix = textSuffix or ""
	self.ID = id or "Unknown"
	self.TimerFinishedText = timerFinishedText or ""
	self.countdownThread = nil
	self.countdownRev = 0
	self.onExpire = nil
	self.TimeTxtCallBack = TimeTxtCallBack or nil
	return self
end

local function SetText(txtObjs, txt,CallBack)
	for _,txtObj in ipairs(txtObjs) do

		if txtObj then
			txtObj.Text = txt
		end
	end
	if CallBack then
		CallBack(txt)
	end
end

function Countdown:_formatDHMS(rem: number): string
	rem = math.max(0, rem)
	local d = math.floor(rem / 86400)
	local h = math.floor((rem % 86400) / 3600)
	local m = math.floor((rem % 3600) / 60)
	local s = math.floor(rem % 60)

	if d > 0 then
		return string.format("%s \n%dd %dh %dm %s", self.TextPrefix, d, h, m, self.TextSuffix)
	elseif h > 0 then
		return string.format("%s \n%dh %dm %ds %s", self.TextPrefix, h, m, s, self.TextSuffix)
	else
		return string.format("%s \n%dm %ds %s", self.TextPrefix, m, s, self.TextSuffix)
	end
end

function Countdown:StopCountdown()
	self.countdownRev += 1
	self.onExpire = nil
	SetText(self.TextObject, "",self.TimeTxtCallBack)
	self.countdownThread = nil
end

function Countdown:StartCountdown(endsAt: number, onExpire)
	-- stop any previous countdown
	self:StopCountdown()

	self.countdownRev += 1
	local myRev = self.countdownRev
	self.onExpire = onExpire

	self.countdownThread = task.spawn(function()
		while myRev == self.countdownRev do
			local rem = math.max(0, endsAt - os.time())

			if rem <= 0 then
				SetText(self.TextObject, self.TimerFinishedText,self.TimeTxtCallBack)

				if self.onExpire then
					local cb = self.onExpire
					self.onExpire = nil
					-- safer callback
					task.spawn(function()
						cb(self.ID)
					end)
				end

				-- stop this countdown
				if myRev == self.countdownRev then
					self.countdownRev += 1
				end
				break
			end

			SetText(self.TextObject, self:_formatDHMS(rem),self.TimeTxtCallBack)
			task.wait(1)
		end

		-- always clear thread ref if we're the latest thread
		if myRev ~= self.countdownRev then
			-- newer countdown started or stopped; just exit
		end
		if self.countdownThread then
			self.countdownThread = nil
		end
	end)
end

return Countdown
]]></ProtectedString>
								<string name="ScriptGuid">{CBBB16E0-45F1-4FF3-A7DE-ECE45C16054A}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">CountdownTimmer_Mod.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5B2E2AFDFF524789806F8BD4C376BFFD">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[
local SlotMachine_Mod = {}
SlotMachine_Mod.__index = SlotMachine_Mod

function SlotMachine_Mod.new(resultFrame: Frame)
	local self = setmetatable({}, SlotMachine_Mod)
	self.Frame = resultFrame
	self._claimConn = nil
	return self
end

local function safeDisconnect(conn)
	if conn then conn:Disconnect() end
end

function SlotMachine_Mod:Destroy()
	safeDisconnect(self._claimConn)
	self._claimConn = nil
end

function SlotMachine_Mod:Fill(PunchData, onClaim)
	-- cleanup old claim connection (no stacking)
	safeDisconnect(self._claimConn)
	self._claimConn = nil

	local frame = self.Frame

	-- UI refs
	local Slot1 = frame.Body.Stroke.Content.SlotAnimation:WaitForChild("Slot1")
	local Slot2 = frame.Body.Stroke.Content.SlotAnimation:WaitForChild("Slot2")
	local Slot3 = frame.Body.Stroke.Content.SlotAnimation:WaitForChild("Slot3")

	local claimBtn = frame.Body.Stroke.Content.Claim_B
	local claimTxt = claimBtn.Get:WaitForChild("txt")
	local message  = frame.Body.Stroke.Content.Message
	message.Text = ""

	local punchPower = PunchData.punchPower

	-- helpers
	local function split3(n)
		n = math.clamp(math.floor(n or 0), 0, 999)
		local h = math.floor(n / 100) % 10
		local t = math.floor(n / 10)  % 10
		local o = n % 10
		return h, t, o
	end

	local function easeOutQuad(a)
		return 1 - (1 - a) * (1 - a)
	end

	local function spinSlot(label: TextLabel, targetDigit: number, baseCycles: number, minStep, maxStep)
		targetDigit = math.clamp(targetDigit or 0, 0, 9)
		local startDigit = tonumber(label.Text) or math.random(0, 9)

		local stepsToTarget = (targetDigit - startDigit) % 10
		local totalSteps = baseCycles * 10 + stepsToTarget
		if totalSteps < 15 then totalSteps += 20 end

		for i = 1, totalSteps do
			local a = i / totalSteps
			local waitTime = minStep + (maxStep - minStep) * easeOutQuad(a)
			label.Text = tostring((startDigit + i) % 10)
			task.wait(waitTime)
		end

		label.Text = tostring(targetDigit)
	end

	-- run reels
	local h, t, o = split3(punchPower)

	claimBtn.Active = false
	claimBtn.AutoButtonColor = false
	claimBtn.Visible = false
	claimTxt.Text = "Claim " .. tostring(PunchData.gems) .. " 💵"

	local base1, base2, base3 = 3, 2, 1
	local minStep, maxStep = 0.008, 0.04

	task.spawn(function() spinSlot(Slot3, o, base3, minStep, maxStep) end)
	task.spawn(function() spinSlot(Slot2, t, base2, minStep, maxStep) end)
	spinSlot(Slot1, h, base1, minStep, maxStep)

	task.wait(0.15)

	message.Text = tostring(PunchData.rating).." punch"

	claimBtn.Active = true
	claimBtn.AutoButtonColor = true
	claimBtn.Visible = true

	local claimed = false
	self._claimConn = claimBtn.Activated:Connect(function()
		if claimed then return end
		claimed = true
		claimBtn.Active = false
		claimBtn.AutoButtonColor = false
		if onClaim then onClaim(PunchData) end
	end)
end

return SlotMachine_Mod
]]></ProtectedString>
								<string name="ScriptGuid">{3BA6E49A-C093-4CA3-AFAC-0F53F0C79B19}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">SlotMachine_Mod.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3D48035566814CD59000D26CA0DC2EA7">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- ReplicatedStorage/Modules/PowerMeterBlocksPicker.lua
-- Uses your EXISTING 5 UI frames (already designed) and detects which block the needle stopped on.

local BlocksPicker = {}
BlocksPicker.__index = BlocksPicker

-- cfg:
-- paddingPx: should match the padding used in your PowerMeter posToPixelX (default 6)
-- blocks: optional explicit array of frames in left->right order (otherwise auto-detects children frames)
-- onSelect(frame, idx, value): optional callback to highlight/select
-- onDeselect(frame, idx, value): optional callback to unhighlight
function BlocksPicker.new(blocksContainer: Instance, bar: Frame, cfg)
	local self = setmetatable({}, BlocksPicker)

	self.Container = blocksContainer
	self.Bar = bar
	self.PaddingPx = (cfg and cfg.paddingPx) or 6

	self.Values = (cfg and cfg.values) or {1,2,3,2,1}

	self.OnSelect = cfg and cfg.onSelect
	self.OnDeselect = cfg and cfg.onDeselect

	-- Collect block frames
	self.Blocks = {}
	if cfg and cfg.blocks then
		for i,fr in ipairs(cfg.blocks) do
			self.Blocks[i] = fr
		end
	else
		for _,child in ipairs(blocksContainer:GetChildren()) do
			if child:IsA("Frame") then
				table.insert(self.Blocks, child)
			end
		end
		-- sort left->right by AbsolutePosition.X
		table.sort(self.Blocks, function(a,b)
			return a.AbsolutePosition.X < b.AbsolutePosition.X
		end)
	end

	self._lastIdx = nil
	return self
end

local function needleXFromT(bar: Frame, t: number, paddingPx: number)
	-- must match PowerMeter.posToPixelX behavior
	local w = bar.AbsoluteSize.X - paddingPx * 2
	return bar.AbsolutePosition.X + paddingPx + w * math.clamp(t, 0, 1)
end

local function pickBlockByX(blocks: {Frame}, x: number)
	local bestIdx = 1
	local bestDist = math.huge

	for i, fr in ipairs(blocks) do
		local left = fr.AbsolutePosition.X
		local right = left + fr.AbsoluteSize.X
		if x >= left and x <= right then
			return i, fr -- inside
		end

		-- nearest distance to the interval [left,right]
		local clamped = math.clamp(x, left, right)
		local dist = math.abs(x - clamped)
		if dist < bestDist then
			bestDist = dist
			bestIdx = i
		end
	end

	return bestIdx, blocks[bestIdx]
end

function BlocksPicker:GetIndexFromT(t: number)
	local x = needleXFromT(self.Bar, t, self.PaddingPx)
	return pickBlockByX(self.Blocks, x)
end

function BlocksPicker:GetValueFromT(t: number)
	local idx = self:GetIndexFromT(t)
	return self.Values[idx] or 1, idx
end

function BlocksPicker:SelectByT(t: number)
	local idx, fr = self:GetIndexFromT(t)
	if self._lastIdx == idx then
		return idx, fr, self.Values[idx]
	end

	-- deselect old
	if self._lastIdx and self.Blocks[self._lastIdx] and self.OnDeselect then
		self.OnDeselect(self.Blocks[self._lastIdx], self._lastIdx, self.Values[self._lastIdx])
	end

	self._lastIdx = idx

	-- select new
	if self.OnSelect then
		self.OnSelect(fr, idx, self.Values[idx],self.Blocks)
	end

	return idx, fr, self.Values[idx]
end

function BlocksPicker:Destroy()
	self.Container = nil
	self.Bar = nil
	self.Blocks = nil
	self.Values = nil
	self.OnSelect = nil
	self.OnDeselect = nil
end

return BlocksPicker
]]></ProtectedString>
								<string name="ScriptGuid">{DE820EC0-EE06-4CB0-AD57-D00E450F2B64}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">PowerMeterBlocksPicker.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXBCB43097549B495885AE07975CA9AEC5">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Player</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXC5C46802E3FC4D99A802B7EF2B22E266">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Gym_Training_Handle_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXF791AD70554D469F9B5F3943F48EC6FC">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[[
	* Server tells the Client that they are starting to train
	* Make sure the Player is not currently Fighting, Force them out Fight Mode if they are in it
	* Toggle Away Side Button UI's, add a Blurr to make sure you can't open anything up
]]--

-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Animation_Objs_F = game.ReplicatedStorage:WaitForChild("Animation_Objs_F")

local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes

local Toggle_Reset 					= Channels.Bindable_Events.Toggle_Reset
local Toggle_Fight_Mode  	        = Channels.Bindable_Events.Toggle_Fight_Mode
local Set_Fight_Mode_Lock 			= Channels.Bindable_Events.Set_Fight_Mode_Lock
local Toggle_Tools_Buttons 			= Channels.Bindable_Events.Toggle_Tools_Buttons

local Workout_Rep					= Channels.CS_Remote_Events.Workout_Rep
local Exit_Machine					= Channels.CS_Remote_Events.Exit_Machine

local Init_Gym_Training				= Channels.SC_Remote_Events.Init_Gym_Training

local Exit_B = script.Parent.Exit_B
local Selected = Exit_B.Selected
local Data_Txt = Exit_B.Main_Txt
local Stroke = Exit_B.UIStroke

local Debounce_C = false
local Debounce_E = false

local Destructor = nil

local Animations = {
	["Treadmill"] = {
		ID = 116881737461921,
		Looped = true,
		Speed = 1,
	},
	["SquatRack"] = {
		ID = 139820058119859,
		Looped = true,
		Speed = 0.4,
	},
	["Pusher"] = {
		ID = 123283345540993,
		Looped = true,
		Speed = 0.7,
	},
	["Dumbells"] = {
		ID = 129314989044360,
		Looped = true,
		Speed = 0.4,
	},
	["BenchPress"] = {
		ID = 100020893468451,
		Looped = true,
		Speed = 0.4,
	},
	["BenchPress2"] = {
		ID = 100020893468451,
		Looped = true,
		Speed = 0.4,
	},
	["GymFloorMat"] = {
		ID = 128818857460265,
		Looped = true,
		Speed = 0.4,
	},
	--["SquatRack"] = {
	--	ID = 000,
	--	Looped = true,
	--},
}

local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			if typeof(Cons[i]) == "function" then
				Cons[i]()
				Cons[i] = nil
			else
				Cons[i]:Disconnect()
			end
		end
	end
	table.clear(Cons)
end

local function Reset_Char_Animations(Char)
	if(Hum ~= nil)then
		local animator = Hum:WaitForChild("Animator") :: Animator
		local Ani_Tracks = animator:GetPlayingAnimationTracks()
		for i = 1, #Ani_Tracks do
			if(Ani_Tracks[i] ~= nil and string.match(Ani_Tracks[i].Name, "_Gym") == nil)then
				Ani_Tracks[i]:Stop()
				Ani_Tracks[i]:Destroy()
			end
		end
	end
end

local function Remove_UI()
	Plr.Character:WaitForChild("Humanoid").WalkSpeed = 16
	Plr.Character:WaitForChild("Humanoid").JumpPower = 50
	Plr.Character:WaitForChild("HumanoidRootPart").Anchored = false
	Reset_Char_Animations(Plr.Character)
	Disconnect_Cons()
	Exit_B:TweenPosition(UDim2.new(0.5, 0, 1.15, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
	--Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true)
	Toggle_Tools_Buttons:Fire(true)
	Toggle_Reset:Fire(true)
	
	if Destructor ~= nil then
		Destructor()
		Destructor = nil
	end
	
	task.wait(0.75)
	
	local Old_Blur = game.Lighting:FindFirstChild("Gym_Blurr")
	if(Old_Blur ~= nil)then
		Old_Blur:Destroy()
	end
	Exit_B.Position = UDim2.new(0.5, 0, 1.15, 0)
	--Exit_B.Visible = false
	
	Debounce_C = false
	Debounce_E = false
end
Remove_UI()

local function Get_Animation_Track(Name, ID)
	local function Create_Animation_Object()
		local Ani_Obj = Animation_Objs_F:FindFirstChild(Name .. "_Gym")
		if(Ani_Obj == nil)then
			Ani_Obj = Instance.new("Animation", Animation_Objs_F)
			Ani_Obj.Name = Name .. "_Ani"
			Ani_Obj.AnimationId = "rbxassetid://" .. ID
		end
		return Ani_Obj
	end
	local Ani_Obj = Create_Animation_Object()
	return Hum:LoadAnimation(Ani_Obj)
end

local function Preload_Animation_Tracks()
	local Track_Data = {
		
	}
	
	for Anim_Name, Ani_Data in next, Animations do
		local Track = Get_Animation_Track(Anim_Name, Ani_Data['ID'])
		Track.Looped = Ani_Data['Looped']
		Track_Data[Anim_Name] = Track
	end
	
	return Track_Data
end
local Preloaded_Anim_Tracks = Preload_Animation_Tracks()

local function Get_Anim_Track(Ani_Name)
	if(Preloaded_Anim_Tracks[Ani_Name] == nil)then
		local Data = Animations[Ani_Name]
		local Track = Get_Animation_Track(Ani_Name, Data['ID'])
		Track.Looped = Data['Looped']
		Preloaded_Anim_Tracks[Ani_Name] = Track
	end
	
	return Preloaded_Anim_Tracks[Ani_Name]
end

local function Show_UI()
	
	local function Reset_Handle()
		Disconnect_Cons()
		--Exit_B.Visible = false
		Exit_B.Position = UDim2.new(0.5, 0, 1.15, 0)
		
		local Old_Blur = game.Lighting:FindFirstChild("Gym_Blurr")
		if(Old_Blur ~= nil)then
			Old_Blur:Destroy()
		end
	end
	Reset_Handle()
	
	task.spawn(function()
		if (Char:GetAttribute("Is_Fighting")) then
			Toggle_Fight_Mode:Fire()
		end
		--Disable_Fight_Mode:Fire(true)
		--On_Submission_Handle:Fire(true, true)
		Set_Fight_Mode_Lock:Fire(true)
		
		Toggle_Reset:Fire(false)
	end)
	
	local function Setup_Training()
		for _, machine in pairs(workspace.Main_World_F.Gameplay.Objects.GymObjects.Machines:GetChildren()) do
			if (machine ~= nil and machine:FindFirstChild("Stats")) then
				if (machine:FindFirstChild("Stats"):FindFirstChild("Player_Using") ~= nil and machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == Plr.Name) then
					if (Animations[machine.Name]) then
						
						Reset_Char_Animations(Plr.Character)
						task.wait()
						local Anim_Track = Get_Anim_Track(machine.Name)
						if(Anim_Track ~= nil)then
							Anim_Track.Looped = Animations[machine.Name].Looped
							Anim_Track.Priority = Enum.AnimationPriority.Action
							Anim_Track:Play()
							Anim_Track:AdjustSpeed(Animations[machine.Name].Speed)
						end
						
						Cons[#Cons + 1] = function()
							if (Anim_Track ~= nil) then
								Anim_Track:Stop()
								Anim_Track = nil
							end
						end
						
						if (machine:FindFirstChild("Barbell") ~= nil or machine:FindFirstChild("Dumbells") ~= nil or machine.Name == "GymFloorMat") then
							table.insert(Cons, Anim_Track.DidLoop:Connect(function()
								task.wait()
								Workout_Rep:FireServer()
							end))
						end 
						
					end
					
					game:GetService("ProximityPromptService").Enabled = false
					Destructor = function()
						--On_Submission_Handle:Fire(false, false)
						Set_Fight_Mode_Lock:Fire(false)
						game:GetService("ProximityPromptService").Enabled = true
					end
					break
				end
			end
		end
	end
	Setup_Training()
	
	local function Display_Button()
		Exit_B.Visible = true
		Exit_B:TweenPosition(UDim2.new(0.5, 0, 0.925, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Gym_Blurr"
		Blur.Size = 0

		if (Char:GetAttribute("Is_Fighting")) then
			Toggle_Fight_Mode:Fire()
		end
		Toggle_Tools_Buttons:Fire(false)

		SE_Mod.Play_Voice_Over("Training")

		Debounce_C = false
		Debounce_E = false

		Plr.Character:WaitForChild("Humanoid").WalkSpeed = 0
		Plr.Character:WaitForChild("Humanoid").JumpPower = 0
		Plr.Character.PrimaryPart.AssemblyLinearVelocity = Vector3.zero
		Plr.Character.PrimaryPart.Anchored = true

		task.wait(.5)
		Plr.Character:WaitForChild("Humanoid").WalkSpeed = 0
		Plr.Character:WaitForChild("Humanoid").JumpPower = 0
		--Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false)
	end
	Display_Button()
	

	local function Button_Handle()
		local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

		Exit_B.Size = UDim2.new(0.15, 0, 0.0875, 0)
		Stroke.Color = Color3.fromRGB(35, 244, 68)
		Data_Txt.TextColor3 = Color3.new(1, 1, 1)

		table.insert(Cons, Selected.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				SE_Mod.PlaySFX(Plr, "Hover_SE")

				Stroke.Color = Color3.new(1, 0, 0)
				Data_Txt.TextColor3 = Color3.new(1, 0, 0)
				Exit_B:TweenSize(UDim2.new(0.1725, 0, 0.100625, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.25, true, nil)

				Debounce_E = false
			end
		end))

		table.insert(Cons, Selected.MouseLeave:Connect(function()
			Exit_B:TweenSize(UDim2.new(0.15, 0, 0.0875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.25, true, nil)
			Stroke.Color = Color3.fromRGB(35, 244, 68)
			Data_Txt.TextColor3 = Color3.new(1, 1, 1)
		end))

		local activated = function()
			if(Debounce_C == false)then
				Debounce_C = true
				SE_Mod.PlaySFX(Plr, "Click_SE")
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.1125, 0, 0.065625, 0)}):Play()

				task.spawn(function()
					Exit_Machine:FireServer()
				end)

				task.wait(0.25)
				Debounce_C = false
			end
		end

		table.insert(Cons, Selected.Activated:Connect(function()
			activated()
		end))
		table.insert(Cons, game:GetService("UserInputService").InputBegan:Connect(function(inp, bool)
			if bool == true then
				return
			end

			if inp.KeyCode == Enum.KeyCode.ButtonX then
				activated()
			elseif inp.KeyCode == Enum.KeyCode.X then
				activated()
			end
		end))
	end
	Button_Handle()
end


Init_Gym_Training.OnClientEvent:Connect(function(bool)
	if(bool == true)then
		Show_UI()
	else
		Remove_UI()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{452BF495-C647-47BF-B34F-F750B975688A}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Training_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXE4A320E824164A32926923AC85ECD4DD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Exit_B</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX13B8E1B0D49145218F39C9597233FF02">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Xbox</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX9E08013EADC445F5AA2FE8FDCD8D6133">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local updateXbox = function()
	local Mapped_Key = uis:GetStringForKeyCode(Enum.KeyCode.ButtonX)
	if(Mapped_Key == "ButtonX")then
		script.Parent.Image = "rbxassetid://115257536194509"
	else
		--PS5
		script.Parent.Image = "rbxassetid://137985933701432"
	end
	
	script.Parent.Visible = uis.GamepadEnabled
end

if uis.GamepadEnabled then
	updateXbox(true)
else
	updateXbox(false)
end
local conn2 = uis.GamepadConnected:Connect(function()
	if uis.GamepadEnabled then
		updateXbox(true)
	else
		updateXbox(false)
	end
end)
local conn2 = uis.GamepadDisconnected:Connect(function()
	if uis.GamepadEnabled then
		updateXbox(true)
	else
		updateXbox(false)
	end
end)]]></ProtectedString>
									<string name="ScriptGuid">{187A5736-45ED-4040-9B3B-2E36DBFCA248}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalScript.client.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX12809ED1E2814E16A4532FED05D8BB61">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">PC</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX59AA142C22314794AD7EE300E2030B18">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local updatePC = function()
	if uis.KeyboardEnabled == true and uis.GamepadEnabled == false then
		script.Parent.Visible = true
	else
		script.Parent.Visible = false
	end
end

updatePC()
while task.wait(1) do
	updatePC()
end]]></ProtectedString>
									<string name="ScriptGuid">{99CD8BEA-0C9A-4D85-92D4-670198B5D009}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalScript.client.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX6D9A461CE56842C0A8359314E439A050">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Fight</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXDC0AA12D6EBD42B9B8DC53ADDAA8B238">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_Intro_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX608CF8406EDB462DA4300306D7924BE8">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--> Display the Transition, Fight Data, Reset your Fight Handle and Disable it=
--> Force you into Fight Handle

-- Services
local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")

local Cam = game.Workspace.CurrentCamera
local Plr = game.Players.LocalPlayer

local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")

-- Modules
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effects_Mod 		= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Animation_Mod 			= require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Bots_Mod 					= require(game.ReplicatedStorage.Data_Mods_F.Bots_Mod)
local BOTS_FOLDER 				= Bots_Mod.getBotsWorkspaceFolder()
local Utils 					= require(game.ReplicatedStorage.Modules.Utils)
local Elo_Mod 					= require(Data_Mods_F:WaitForChild("Elo_Mod"))

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Toggle_Reset 				= Channels.Bindable_Events.Toggle_Reset

local Set_Fight_Mode_Lock 		= Channels.Bindable_Events.Set_Fight_Mode_Lock
local Disable_Fight_Mode 		= Channels.Bindable_Events.Disable_Fight_Mode
local Close_Fight_Result 		= Channels.Bindable_Events.Close_Fight_Result
local Toggle_Side_Buttons 		= Channels.Bindable_Events.Toggle_Side_Buttons
local Toggle_Tools_Buttons 		= Channels.Bindable_Events.Toggle_Tools_Buttons
local Toggle_TopBar 			= Channels.Bindable_Events.Toggle_TopBar
local Transition_Fade 			= Channels.Bindable_Events.Transition_Fade_UI
local New_Round_Display 		= Channels.Bindable_Events.New_Round_Display
local Toggle_Fight_Mode 		= Channels.Bindable_Events.Toggle_Fight_Mode
local Toggle_Cutscene 			= Channels.Bindable_Events.Toggle_Cutscene


local Fight_Set_Up				= Channels.SC_Remote_Events.Fight_Set_Up
local Fight_Intro_Finished		= Channels.CS_Remote_Events.Fight_Intro_Finished
local Ready_To_Fight			= Channels.CS_Remote_Events.Ready_To_Fight

-- UI References
local Transiton_Tabs_F = script.Parent.Teleport_Transition_F
local Left_F, Right_F = Transiton_Tabs_F.Left_F, Transiton_Tabs_F.Right_F
local Covers_F = script.Parent.Covers_F
local Top_F, Bottom_F = Covers_F.Top_F, Covers_F.Bottom_F
local Player_Fight_Data_F = script.Parent.Main_F
local Top_Fight_Data_F = Player_Fight_Data_F.Top_F
local Rank_Img = Top_Fight_Data_F.Rank_Img
local Stats_Fight_Data_F = Player_Fight_Data_F.Stats_F.Data_Tabs_F

local Debounce_Display = false
local Cons = {}

--local function Disconnect_Cons()
--	for i = 1, #Cons do
--		if(Cons[i] ~= nil)then
--			Cons[i]:Disconnect()
--		end
--	end
--	table.clear(Cons)
--end

local function Set_Up_Fight(Cage_M, isBot, Target_Char, Target_HRP)
	Debounce_Display = true
	Toggle_Reset:Fire(false)

	local Is_Ranked = (Cage_M:GetAttribute("Cage_Type") or "") == "RANKED"
	local Ranked_CS_F =(Is_Ranked and Cage_M:FindFirstChild("Ranked_Cutscene_Parts_F")) or nil
	
	local function Init_Reset()
		Left_F.Visible = false
		Right_F.Visible = false
		Player_Fight_Data_F.Visible = false
		Left_F.Position = UDim2.new(-1, 0, 0, 0)
		Right_F.Position = UDim2.new(1, 0, 0, 0)
		
		Top_F.Visible = false
		Bottom_F.Visible = false
		Top_F.Position = UDim2.new(0, 0, -0.15, 0)
		Bottom_F.Position = UDim2.new(0, 0, 1.15, 0)
		Player_Fight_Data_F.Position = UDim2.new(0.5, 0, 1.5, 0)
		
		Left_F.Visible = true
		Right_F.Visible = true
		Top_F.Visible = true
		Bottom_F.Visible = true
		Player_Fight_Data_F.Visible = true
		
		Set_Fight_Mode_Lock:Fire(true)		
		Disable_Fight_Mode:Fire(true)
		Close_Fight_Result:Fire()
		Toggle_Side_Buttons:Fire(false)
		Toggle_Tools_Buttons:Fire(false)
		Toggle_TopBar:Fire(false)
		
	end
	Init_Reset()
	
	local function Configure_Name_Tag_Handle(C)
		local Name_Tag = C:FindFirstChild("Name_Tag_UI")
		local Toggle_Tabs = {"UIStroke", "Rank_F", "Connection_Img", "Device_Img", "Country_Img", 
			"Player_Name_Txt"}
		
		if(Name_Tag ~= nil and Name_Tag:FindFirstChild("Main_F") ~= nil)then
			local Main_F = Name_Tag:FindFirstChild("Main_F")
			
			for i = 1, #Toggle_Tabs do
				local Tab = Main_F:FindFirstChild(Toggle_Tabs[i])
				if(Tab ~= nil)then
					if(Tab:IsA("UIStroke"))then
						Tab.Enabled = false
					else
						Tab.Visible = false
					end
				end
			end
			
			Main_F.BackgroundTransparency = 1
			
			if(C ~= Char)then
				Name_Tag.StudsOffset = Vector3.new(0, 3, 0)
			end
			
			Name_Tag.Enabled = false
		end
	end
	Configure_Name_Tag_Handle(Char)
	Configure_Name_Tag_Handle(Target_Char)

	
	local function Show_Transition()
		--local Woosh_SE = Sound_Effects_Mod.PlaySFX(Plr, "Transition_Woosh_SE")
		Sound_Effects_Mod.PlaySFX(Plr, "Transition_Woosh_SE")
		--if(Woosh_SE ~= nil)then
		--	Woosh_SE:Play()
		--end
		
		Left_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
		Right_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
		
		wait(1)
		--On_Submission_Handle:Fire(true, true)
		Toggle_Side_Buttons:Fire(false)
		Toggle_Tools_Buttons:Fire(false)
		Toggle_TopBar:Fire(false)
		
		--if(Woosh_SE ~= nil)then
		--	Woosh_SE:Play()
		--end
		Sound_Effects_Mod.PlaySFX(Plr, "Transition_Woosh_SE")
		
		Left_F:TweenPosition(UDim2.new(-1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
		Right_F:TweenPosition(UDim2.new(1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)

		wait(0.375)
		
		Left_F.Visible = false
		Right_F.Visible = false
		Left_F.Position = UDim2.new(-1, 0, 0, 0)
		Right_F.Position = UDim2.new(1, 0, 0, 0)
	end
	Show_Transition()
	
	local function Update_Stats_Display(C)
		local C_Plr = game.Players:GetPlayerFromCharacter(C)
		local Tabs_Txt = Stats_Fight_Data_F:GetChildren()
		
		if(C_Plr ~= nil and C_Plr:FindFirstChild("Player_Data") ~= nil)then
			local PD = C_Plr:FindFirstChild("Player_Data")
			
			local function Get_Values(Key)
				local V = PD:FindFirstChild(Key)
				if(V ~= nil)then
					return V.Value
				end
				return 0
			end
			
			local function Get_Win_Percentage()
				local Wins_V = Get_Values("Total Wins")
				local Matches_V = Get_Values("Total Matches")
				if(Is_Ranked)then
					Wins_V = Get_Values("Ranked Wins")
					Matches_V = Get_Values("Ranked Matches")
				end
				
				local Dif = math.clamp(Wins_V / Matches_V, 0, 1) * 100
				if tostring(Dif) == "nan" then
					return "0%"
				end
				return math.floor(Dif) .. "%"
			end
			
			for i = 1, #Tabs_Txt do	
				local Txt = Tabs_Txt[i]
				if(Txt ~= nil)then
					local Key = Txt.Name
					if(Is_Ranked and Key == "Total Wins")then
						Key = "Ranked Wins"
					end
					
					local Data_V = PD:FindFirstChild(Key)
					if(Data_V ~= nil)then
						Txt.Text = Utils.NumToString(Data_V.Value) .. ""
					else
						Txt.Text = Get_Win_Percentage() 
					end
					
					if(Is_Ranked)then
						Txt.TextColor3 = Color3.fromRGB(255, 170, 0)
					else
						Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					end
				end
			end
			
			local Elo_Data = Elo_Mod.Get_Player_Rank_Data(C_Plr)
			Rank_Img.Image = Elo_Data['Icon'] or "rbxassetid://89194867048049"
			Rank_Img.ImageColor3 = Elo_Data['Color'] or Color3.fromRGB(170, 170, 127)
			Top_Fight_Data_F:FindFirstChild("Plr_Name_Txt").Text = C_Plr.DisplayName .. ""
			
		else
			--Bot
			for i = 1, #Tabs_Txt do	
				local Txt = Tabs_Txt[i]
				if(Txt ~= nil)then
					Txt.Text = "BOT"
					Txt.TextColor3 = Color3.fromRGB(170, 0, 0)
				end
			end
			
			local Elo_Data = Elo_Mod.Get_Player_Rank_Data(Plr)
			Rank_Img.Image = Elo_Data['Icon'] or "rbxassetid://89194867048049"
			Rank_Img.ImageColor3 = Elo_Data['Color'] or Color3.fromRGB(170, 170, 127)
			local displayName = Target_Char:GetAttribute("Display_Name") or "BOT"
			Top_Fight_Data_F:FindFirstChild("Plr_Name_Txt").Text = displayName			
		end
		
		Player_Fight_Data_F:TweenPosition(UDim2.new(0.5, 0, 0.875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.5, true, nil)
	end
	
	local function Intro_Cutscene()
		Top_F:TweenPosition(UDim2.new(0.5, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Bottom_F:TweenPosition(UDim2.new(0.5, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		
		HRP.Anchored = true
		if(Is_Ranked and Ranked_CS_F ~= nil)then
			local function Play_Ranked_Cutscene()
				local Tween_Cam = TweenInfo.new(2.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
				Cam.CameraType = Enum.CameraType.Scriptable
				
				for i = 1, #Ranked_CS_F:GetChildren() do
					local P = Ranked_CS_F:FindFirstChild("P" .. i)
					if(P ~= nil)then
						if(i == 1)then
							Cam.CFrame = P.CFrame
						else
							TS:Create(Cam, Tween_Cam, {CFrame = P.CFrame}):Play()
							if(i == 3)then
								wait(2)
								Transition_Fade:Fire(0.5, 0.5)
								wait(0.5)
							else
								wait(2.5)
							end
						end
					end
				end
				
				-- Add on to this!
				-- Create a whole Walk out Sequence to display Player Stats on
				-- Spawn Players in Tunnels, have them Walk towards the Final Point
					--> Will Display Stats here instead of just having them Flex
					
			end
			Play_Ranked_Cutscene()
			
			if(HRP ~= nil and Hum ~= nil)then
				local function Move_Yourself()
					local Final_Pos = HRP.CFrame.Position + HRP.CFrame.LookVector * 110
					HRP.Anchored = false
					Hum.WalkSpeed = 10

					for i = 1, 2 do
						if(Hum ~= nil)then
							Hum:MoveTo(Final_Pos)
							wait(5)
						end
					end
				end
				task.spawn(Move_Yourself)
			end
			
			--Show yourself
			--Show the other Player
			
			local function Track_Player(T_HRP, T_Char)
				local Tween_Init = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
				local Orig_Pos = T_HRP.CFrame.Position
				local Init_Pos = Orig_Pos + T_HRP.CFrame.LookVector * ((0.75 * 10) + 7)
				local Init_Rot = CFrame.new(Init_Pos, Orig_Pos).Rotation
				local Init_CF = CFrame.new(Init_Pos) * Init_Rot
				
				Cam.CameraType = Enum.CameraType.Scriptable
				TS:Create(Cam, Tween_Init, {CFrame = Init_CF}):Play()
				wait(0.75)
				
				if(T_Char ~= nil and Char ~= nil and T_Char == Char)then
					Sound_Effects_Mod.Play_Voice_Over("Fighter_1_Intro")
				else
					Sound_Effects_Mod.Play_Voice_Over("Fighter_2_Intro")
				end
				
				local RS_Con = RunService.Stepped:Connect(function()
					if(Cam ~= nil and T_HRP ~= nil)then
						local Orig_Pos = T_HRP.CFrame.Position
						local Init_Pos = Orig_Pos + T_HRP.CFrame.LookVector * 7
						local Init_Rot = CFrame.new(Init_Pos, Orig_Pos).Rotation
						
						Cam.CFrame = CFrame.new(Init_Pos) * Init_Rot
					end
				end)
				table.insert(Cons, RS_Con)
			
				Update_Stats_Display(T_Char)
				
				wait(4.25)
				
				if(RS_Con ~= nil)then
					RS_Con:Disconnect()
					RS_Con = nil
				end
			end
			Track_Player(HRP, Char)
			
			if(Target_HRP ~= nil and Target_Char ~= nil)then
				Track_Player(Target_HRP, Target_Char)
			end
			
		else
			--Play Animation
			local Intro_Animation_Key = Plr:FindFirstChild("Player_Data"):FindFirstChild("Fight Intro Key").Value
			Animation_Mod.Play_Emote_Track_From_Key(Plr, Hum, Intro_Animation_Key, true)
			if isBot == true then
				local botHum = Target_Char:FindFirstChild("Humanoid")
				if botHum then
					Animation_Mod.Force_Play_Emote_Track_From_Key(botHum, "A", false)
				end
			end

			local RS_Con = nil
			local Tween_Init = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
			local Init_Pos = HRP.Position + HRP.CFrame.LookVector * 5
			local Look_CF = CFrame.new(Init_Pos, HRP.Position)
			local Follow_P = nil

			RS_Con = RunService.Stepped:Connect(function()
				if(Follow_P ~= nil and Cam ~= nil)then
					Cam.CFrame = CFrame.new(Cam.CFrame.Position, Follow_P.Position)
				end
			end)
			table.insert(Cons, RS_Con)

			Cam.CameraType = Enum.CameraType.Scriptable
			TS:Create(Cam, Tween_Init, {CFrame = CFrame.new(Init_Pos) * Look_CF.Rotation}):Play()
			wait(0.75)
			Follow_P = HRP
			Update_Stats_Display(Char)

			wait(3)

			if(Target_HRP ~= nil)then
				Follow_P = nil
				Init_Pos = Target_HRP.Position + Target_HRP.CFrame.LookVector * 5
				Look_CF = CFrame.new(Init_Pos, Target_HRP.Position)
				TS:Create(Cam, Tween_Init, {CFrame = CFrame.new(Init_Pos) * Look_CF.Rotation}):Play()
				Player_Fight_Data_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.25, true, nil)
				wait(0.75)
				if(Target_HRP ~= nil)then
					Follow_P = Target_HRP
				end

				Update_Stats_Display(Target_Char)

				wait(3)
				Follow_P = nil
			end

			if(RS_Con ~= nil)then
				RS_Con:Disconnect()
				RS_Con = nil
			end
		end
		
		Player_Fight_Data_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 1, true, nil)
		Top_F:TweenPosition(UDim2.new(0.5, 0, -0.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Bottom_F:TweenPosition(UDim2.new(0.5, 0, 1.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		
		Cam.CameraSubject = Hum
		Cam.CameraType = Enum.CameraType.Custom
		Cam.CFrame = Char:FindFirstChild("Head").CFrame
		Cam.FieldOfView = 70
		
		wait(1)

		Top_F.Visible = false
		Bottom_F.Visible = false
		Player_Fight_Data_F.Visible = false
		HRP.Anchored = false
	end
	
	Intro_Cutscene()
	
	New_Round_Display:Fire(1)
	
	wait(1.5) -- Temp Wait
	
	Toggle_Fight_Mode:Fire(Target_HRP, Cage_M, true)
	
	Fight_Intro_Finished:FireServer(Cage_M.Name)
	-- Server will now know we are ready for fight to actually start
	Ready_To_Fight:FireServer(Cage_M.Name)
	
	Debounce_Display = false
end

Fight_Set_Up.OnClientEvent:Connect(function(Cage_M, isBot, ...)
	workspace:SetAttribute("FIGHT_INTRO", true)
	local args = {...}
	local Target_Char, Target_HRP
	if isBot == true then
		local botName = args[1]
		repeat
			Target_Char = BOTS_FOLDER:FindFirstChild(botName)
			if Target_Char == nil then
				task.wait()
				continue
			else
				Target_HRP = Target_Char:FindFirstChild("HumanoidRootPart")
			end
		until Target_Char ~= nil and Target_HRP ~= nil
	else
		Target_Char, Target_HRP = args[1], args[2]
	end
	
	if(Debounce_Display == false) then
		Set_Up_Fight(Cage_M, isBot, Target_Char, Target_HRP)
	end
	workspace:SetAttribute("FIGHT_INTRO", nil)
end)

Toggle_Cutscene.Event:Connect(function(Is_Enabled)
	if(Is_Enabled)then
		Toggle_Side_Buttons:Fire(false)
		Toggle_Tools_Buttons:Fire(false)
		Toggle_TopBar:Fire(false)
		Top_F:TweenPosition(UDim2.new(0.5, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Bottom_F:TweenPosition(UDim2.new(0.5, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
	else
		Top_F:TweenPosition(UDim2.new(0.5, 0, -0.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Bottom_F:TweenPosition(UDim2.new(0.5, 0, 1.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Toggle_Side_Buttons:Fire(true)
		Toggle_Tools_Buttons:Fire(true)
		Toggle_TopBar:Fire(true)
	end
end)

]]></ProtectedString>
							<string name="ScriptGuid">{FC880F19-B4FE-4AC7-915F-6D09B6BEB270}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Fight_Intro_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX076CD4662E2141D3A19F84822CD1A210">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_System_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXE3ACD5DE01024E2FAB0275297F41CB42">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Fight_System/Core/Client_Fight_Handle.client.lua
--
--  Description:
--      Central client controller for the entire Fight System.
--      Coordinates the camera rig, combat input handling, clinch
--      cutscenes, and submission mini-game. Acts as the main entry
--      point for initializing, enabling, and disabling fight mode.
--
--  Author(s): Exclusible, Oriane
--
--  Last Modified: 2025-10-08 by Oriane
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * TweenService
--          * RunService
--          * UserInputService
--          * Players
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events/End_Fight
--          * Channels_F/Bindable_F/Events/Toggle_Fight_Mode
--          * Channels_F/Bindable_F/Events/Disable_Fight_Mode
--          * Channels_F/Bindable_F/Events/Set_Fight_Mode_Lock
--          * Channels_F/Bindable_F/Events/Toggle_Binds
--          * Data_Mods_F/Animation_Mod
--          * Data_Mods_F/Sound_Mod
--      - Workspace:
--          * Main_World_F/Objects/Fight_Cages_F
--
--  Submodules:
--      * Combat_Inputs.lua       – Handles player attack, block, dodge, takedown inputs
--      * Camera_Rig.lua          – Manages camera rotation and player facing
--      * Clinch_Sequence.lua    – Controls cage clinch cinematic sequences
--      * Submission_Minigame.lua – Manages submission phase and tap-speed tracking
--
--  Notes:
--      - Initializes the entire fight logic and environment per round.
--      - Orchestrates the setup and teardown of all fight submodules.
--      - Maintains global state: Is_Hit, Is_Cage_Submission, and camera rig.
--      - Handles clean camera and animation resets after fights.
--      - Syncs client-side state with server fight events.
--      - Core dependency for all client fight interactions and UI updates.
--
--======================================================================
--// Player and Character
local Plr = game.Players.LocalPlayer

--// Character Components
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")

--// Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

--// Required Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

--// Logical Modules (split from this script)
local Combat_Inputs = require(script:WaitForChild("Combat_Inputs"))
local Camera_Rig = require(script:WaitForChild("Camera_Rig"))
local Client_Clinch_Sequence = require(script:WaitForChild("Client_Clinch_Sequence"))
local Client_Submission_Minigame = require(script:WaitForChild("Client_Submission_Minigame"))
local Fight_UI = require(script:WaitForChild("Fight_UI"))

----- REFERENCES -----


-- Events
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local End_Fight			  	= Channels.SC_Remote_Events.End_Fight
local Set_Fight_Mode_Lock 	= Channels.Bindable_Events.Set_Fight_Mode_Lock
local Toggle_Fight_Mode  	= Channels.Bindable_Events.Toggle_Fight_Mode
local Disable_Fight_Mode 	= Channels.Bindable_Events.Disable_Fight_Mode

----- OBJECTS -----
--// Workspace References
local Cam = game.Workspace.CurrentCamera

--// Variables
local Can_Enter_Fight = true
local Locked_In_Fight = false
local Fight_Walkspeed = 10
local Cam_FOV = 45
local Cam_Offset = Vector3.new(4, -3, -5)
local Min_Angle = math.rad(-35) 
local Max_Angle = math.rad(-25)
local Tween_Cam = TweenInfo.new(0.375, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
local RS_Con = nil
local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end

	RunService:UnbindFromRenderStep("UpdateLoop")

	table.clear(Cons)
end

local function Set_Cam_Adjustments(Is_Alone)
	if(Is_Alone)then
		TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
		TS:Create(Hum, Tween_Cam, {CameraOffset = Vector3.new(0, 0, 0)}):Play()
		Cam.CameraType = Enum.CameraType.Custom
	else
		TS:Create(Cam, Tween_Cam, {FieldOfView = Cam_FOV}):Play()
		TS:Create(Hum, Tween_Cam, {CameraOffset = Cam_Offset}):Play()
		Cam.CameraType = Enum.CameraType.Scriptable
	end
end

local function Reset_BG()
	if(RS_Con ~= nil)then
		RS_Con:Disconnect()
		RS_Con = nil
	end
	Disconnect_Cons()

	if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
		HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
	end

	if(Hum ~= nil)then
		Hum.AutoRotate = true
		Hum.WalkSpeed = 16
		Hum.JumpPower = 50

		Animation_Mod.Reset_Character_Animations(Char)

		Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
		Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, true)
		Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
	end

	Plr.CameraMaxZoomDistance = game.StarterPlayer.CameraMaxZoomDistance
	Plr.CameraMinZoomDistance = game.StarterPlayer.CameraMinZoomDistance

	Cam.CameraType = Enum.CameraType.Custom
	UIS.MouseBehavior = Enum.MouseBehavior.Default
	UIS.MouseIconEnabled = true
	UIS.MouseDeltaSensitivity = 1
	Hum.CameraOffset = Vector3.new(0, 0, 0)
	Cam.FieldOfView = 70
	Char:SetAttribute("Is_Fighting", false)
end

Disconnect_Cons()

Reset_BG()

Fight_UI.Update("No_Fight")

local fightInputLocked = false

Set_Fight_Mode_Lock.Event:Connect(function(bool: boolean)
	fightInputLocked = bool
end)


local function Initialize_Fight_System(Target_HRP, Cage_M)
    -- Shared state table used across modules to communicate hit and
    -- submission status.  These replicate the Is_Hit and
    -- Is_Cage_Submission flags from the original script.
    local state = {
        Is_Hit = false,
        Is_Cage_Submission = false,
    }

    -- Build environment with all required services, references and values.
    local env = {
        -- parameters 
        Fight_Walkspeed = Fight_Walkspeed,
        Cam_FOV = Cam_FOV,
        Cam_Offset = Cam_Offset,
        Min_Angle = Min_Angle,
        Max_Angle = Max_Angle,
        Tween_Cam = Tween_Cam,
		Cons = Cons,
		Cage_M = Cage_M,
		-- functions -- 
        Set_Cam_Adjustments = Set_Cam_Adjustments,
		Reset_BG = Reset_BG,
		
        -- Initial target root part can be nil if fighting free‑form
        Target_HRP = Target_HRP,
        state = state,
        RS_Con_ref = {},
    }

    -- Preload movement animation tracks for use in cut‑scenes and submissions.
    if Hum ~= nil then
        env.Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
    end

    -- Initialise camera rig; returns a BodyGyro which we store back in env.
    local bg = Camera_Rig.Setup(env)
    env.BG = bg

    -- Pull stepped connection from camera rig into global RS_Con for cleanup.
    if env.RS_Con_ref and env.RS_Con_ref.con then
        RS_Con = env.RS_Con_ref.con
    end

    -- Register combat input handlers, submission mini‑game and clinch sequence.
    Combat_Inputs.Setup(env)
	Client_Submission_Minigame.Setup(env)
	Client_Clinch_Sequence.Setup(env)
	Fight_UI.Setup(Cage_M)
end

Toggle_Fight_Mode.Event:Connect(function(Target_HRP, cage_M, forced: boolean?)
	if fightInputLocked == true and forced ~= true then
		return
	end

	if(Locked_In_Fight == false)then
		if(Char ~= nil and RS_Con == nil and Can_Enter_Fight == true)then
			Initialize_Fight_System(Target_HRP, cage_M)
			
			if(Target_HRP ~= nil)then
				Locked_In_Fight = true
				Fight_UI.Update("Cage_Fight")
				
			else 
				Fight_UI.Update("Free_Fight")
			end
		else
			Reset_BG()
			Fight_UI.Update("No_Fight_In_Gym")
		end
	end
end)


Disable_Fight_Mode.Event:Connect(function(forced: boolean?)
	if fightInputLocked == true and forced ~= true then
		return
	end

	Can_Enter_Fight = false
	Locked_In_Fight = false
	Reset_BG()
	Fight_UI.Update("No_Fight")

	wait(3)
	Can_Enter_Fight = true
end)

--// Event trigger at the end of a Cage fight
End_Fight.OnClientEvent:Connect(function(Target_Char)
	Reset_BG()

	Fight_UI.Update("No_Fight")
	Fight_UI.Reset_Name_Tag(Char)
	Fight_UI.Reset_Name_Tag(Target_Char)

	SE_Mod.PlaySFX(Plr, "Start_Fight_Bell_SE")

	Locked_In_Fight = false
	fightInputLocked = false
end)
]]></ProtectedString>
							<string name="ScriptGuid">{26717BC8-D9A0-42BC-B46F-5585E28DBB1A}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Fight_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXA98648E268234804B901183E295F1B5B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Fight_Handle</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX73C185F2A7B245D89FE54B15746AA68D">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterGui/Fight_System_UI/Client_Fight_Handle/Combat_Inputs.lua
--
--  Description:
--      Handles all player combat inputs and related client-side logic.
--      Processes strikes, dodges, blocking, and takedowns for both 
--      desktop and mobile players. Manages camera feedback, animations,
--      sound effects, stamina usage, and hit effects for real-time fights.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-10-08 by Oriane
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/CameraShaker
--          * Data_Mods_F/Animation_Mod
--          * Data_Mods_F/Sound_Mod
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Bindable_F/RF
--      - Workspace:
--          * Main_World_F/Objects/Fight_Cages_F
--      - Local_Events_F (script.Parent.Parent.Local_Events_F):
--          * Throwing_Strike
--          * Dodging_Strike
--          * Blocking_Strike
--          * Unblocking_Strike
--          * Release_Mobile_Blocking
--      - Player Instance:
--          * Fight_Data (Health, Block Power, Staminia, Strike Power)
--          * Character (Humanoid, HumanoidRootPart)
--
--  Notes:
--      - Detects player input (keyboard, gamepad, or touch) and translates 
--        them into combat actions.
--      - Syncs animations, stamina drain, and server-side fight events.
--      - Applies camera shakes, woosh effects, and hit feedback.
--      - Automatically adapts to mobile or desktop control schemes.
--      - Works in tandem with Client_Fight_Handle and Fight_UI_Handle.
--
--======================================================================


----- DEPENDENCIES -----

--// Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")

--// Required Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Cam_Shake_Mod = require(Data_Mods_F:WaitForChild("CameraShaker"))
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local Buttons_Mod = require(script.Parent:WaitForChild("Fight_Buttons_Mod"))

local Fight_UI = require(script.Parent:WaitForChild("Fight_UI"))


-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Show_White_Fade			= Channels.Bindable_Events.Show_White_Fade
local Release_Mobile_Blocking_E = Channels.Bindable_Events.Release_Mobile_Blocking
local Get_Mobile_Buttons_BF 	= Channels.CS_Remote_Functions.Get_Mobile_Buttons
local Throwing_Strike_E			= Channels.CS_Remote_Events.Throwing_Strike
local Dodging_Strike_E			= Channels.CS_Remote_Events.Dodging_Strike
local Unblocking_Strike_E 		= Channels.CS_Remote_Events.Unblocking_Strike
local Blocking_Strike_E  		= Channels.CS_Remote_Events.Blocking_Strike
local Is_Chatbox_Typing			= Channels.Bindable_Functions.Is_Chatbox_Typing

----- REFERENCES -----
--// Player and Character
local Plr = game.Players.LocalPlayer

--// Fight Values
local Fight_Data_F = Plr:WaitForChild("Fight_Data")

--// Character Components
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Cam = game.Workspace.CurrentCamera

local Combat_Inputs = {}

-- Main setup function.  This will register all of the connections and
-- initialise state used for combat input handling.  It is intended to be
-- called once per fight session from the main script after the character
-- and camera rig have been prepared.
function Combat_Inputs.Setup(env)
	-- Extract required objects from the environment table for readability
	local Cage_M = env.Cage_M
    local Fight_Walkspeed: number = env.Fight_Walkspeed
    local Cam_FOV: number = env.Cam_FOV
    local Cons: {any} = env.Cons
    local state = env.state
	
	-- Hard Reset Player Blocking Handle
	task.spawn(function()
		Unblocking_Strike_E:FireServer()
	end)

    -- Debounce flags specific to this module
    local Debounce_Striking = false
    local Debounce_Dodge = false
    local Debounce_Blocking = false
    local Debounce_Takedown = false

    -- Helper to build an array from a dictionary of animation tracks
    local function Create_Anim_Arr_Data(animTrackData)
        local arr = {}
        for _, animTrack in next, animTrackData do
            table.insert(arr, animTrack)
        end
        return arr
    end

    -- Retrieve references to the numeric values stored under Fight_Data_F.
    local function Get_Fight_Data_Vals()
        local vals = {}
        for _, v in ipairs(Fight_Data_F:GetChildren()) do
            if v then
                vals[v.Name] = v
            end
        end
        return vals
    end
    local fightDataVals = Get_Fight_Data_Vals()
    local Health_V = fightDataVals["Health"]
    local Blocking_Power_V = fightDataVals["Block Power"]
    local Staminia_V = fightDataVals["Staminia"]
    local Punch_Power_V = fightDataVals["Strike Power"]

    -- Pre-fetch the various animation tracks used for striking, movement and combos
    local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	
	local Combo_Punch_Index = 1
	local Combo_Punch_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(Plr, Hum, "Punch Combo")
	local Combo_Kick_Index = 1
	local Combo_Kick_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(Plr, Hum, "Kick Combo")
	
    local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)
	
	local Current_Move_Direction = Vector3.new(0, 0, 0)

    --[[
        Striking_Movement_Handle

        Handles transitioning between idle and shuffle animations based on
        humanoid movement direction.  It also adjusts the camera FOV to
        accentuate motion when the player is moving.  This behaviour is
        identical to that of the original script.
    ]]--
    local function Striking_Movement_Handle()
        -- Tweens for smoothly adjusting the camera FOV when moving or stopping
        local Cam_Move_Tween = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
        local Reset_Cam_Move_Tween = TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
        local Cam_Tween

        -- Listen for changes to the humanoid MoveDirection property
        table.insert(Cons, Hum:GetPropertyChangedSignal("MoveDirection"):Connect(function()
			local moveDir = Hum.MoveDirection
			Current_Move_Direction = moveDir
            if moveDir.Magnitude > 0 and Anim_Track_Data["Shuffle Forward"].IsPlaying == false then
                Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data["Idle"]})
                Anim_Track_Data["Shuffle Forward"]:Play()
                -- If the player is not being hit, zoom the camera slightly when moving
                if not state.Is_Hit then
                    if Cam_Tween ~= nil then
                        Cam_Tween:Cancel()
                        Cam_Tween = nil
                    end
                    Cam_Tween = TS:Create(Cam, Cam_Move_Tween, {FieldOfView = 55})
                    Cam_Tween:Play()
				end
				Char:SetAttribute("IsMoving", true)
            elseif moveDir.Magnitude <= 0 and (Anim_Track_Data["Shuffle Forward"].IsPlaying or Anim_Track_Data["Shuffle Side"].IsPlaying) then
                Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data["Idle"]})
                if not state.Is_Hit then
                    if Cam_Tween ~= nil then
                        Cam_Tween:Cancel()
                        Cam_Tween = nil
                    end
                    Cam_Tween = TS:Create(Cam, Reset_Cam_Move_Tween, {FieldOfView = Cam_FOV})
                    Cam_Tween:Play()
				end
				Char:SetAttribute("IsMoving", false)
            end
        end))

        -- Always start in the idle animation at half speed
        Anim_Track_Data["Idle"]:Play()
        Anim_Track_Data["Idle"]:AdjustSpeed(0.5)
    end
    Striking_Movement_Handle()

    --[[
        On_Hit_Effects

        Watches for reductions in the player's health and, when damage is
        detected, triggers camera shake, sweat effects and hit animations.  A
        debounce via state.Is_Hit prevents subsequent hits from retriggering
        effects until the current hit animation has finished.
    ]]--
    local function On_Hit_Effects()
        local prevHealth = Health_V.Value
        local hitAnimTrack = Striking_Anim_Tracks["Taking Hit"]

        -- Create a camera shake object on demand
        local function Cam_Shake()
            local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
                Cam.CFrame = Cam.CFrame * shakeCf
            end)
            return CS
        end
        local camShake = Cam_Shake()

        table.insert(Cons, Health_V.Changed:Connect(function()
            local currentVal = Health_V.Value
            if currentVal < prevHealth and not state.Is_Hit then
                state.Is_Hit = true
                camShake:Start()
                camShake:Shake(Cam_Shake_Mod.Presets.Bump)
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Fight_UI.Trigger_Sweat_Effect()
                task.spawn(function()
                    Animation_Mod.Play_Animation_Track(hitAnimTrack)
                    camShake:Stop()
                    -- Only reset the hit flag if the player is not in a submission hold
                    if not state.Is_Cage_Submission then
                        state.Is_Hit = false
                    end
                end)
            end
            prevHealth = currentVal
        end))
    end
    On_Hit_Effects()

    -- Utility to determine whether the targeted opponent is right handed.  This
    -- affects which blocking animation is played when the player successfully
    -- blocks a strike.  Returns true if the opponent is right handed or
    -- defaults to true when no information is available.
    local function Get_Target_Players_Hand()
        local targetHRP = env.Target_HRP
        if targetHRP and targetHRP.Parent and game.Players:GetPlayerFromCharacter(targetHRP.Parent) then
            local targetPlr = game.Players:GetPlayerFromCharacter(targetHRP.Parent)
            local targetPD = targetPlr:FindFirstChild("Player_Data")
            if targetPD and targetPD:FindFirstChild("Right Handed") then
                return targetPD:FindFirstChild("Right Handed").Value
            end
        end
        return true
    end

    -- Play the block loop animation while the player is holding block.  The
    -- original code uses a coroutine to avoid yielding in the main thread.
    local function Play_Blocking_Animation()
        local anim = Striking_Anim_Tracks["Main Block"]
        if anim then
            anim:Play()
            anim:AdjustSpeed(1)
            wait(anim.Length * 0.9)
            if anim and Debounce_Blocking then
                anim:AdjustSpeed(0)
            end
        end
    end

    --[[
        Blocking_Effects

        Listens for reductions in the blocking power value while the player
        maintains a block.  When damage is blocked, the appropriate body
        block animation is played depending on whether the opponent is
        right or left handed.  If the block key is still held down at the
        end of the animation then the block loop animation is restarted.
    ]]--
    local function Blocking_Effects()
        local prevBlocking = Blocking_Power_V.Value
        -- Helper to choose which body block animation to play based on the
        -- opponent's handedness.
        local function Get_Blocking_Animation()
            if Get_Target_Players_Hand() then
                return Striking_Anim_Tracks["Body Block Left"]
            else
                return Striking_Anim_Tracks["Body Block Right"]
            end
        end
        table.insert(Cons, Blocking_Power_V.Changed:Connect(function()
            local currentVal = Blocking_Power_V.Value
            if currentVal > 0 and currentVal < prevBlocking and Debounce_Blocking then
                Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
                Animation_Mod.Play_Animation_Track(Get_Blocking_Animation())
                if Debounce_Blocking then
                    task.spawn(Play_Blocking_Animation)
                end
            end
            prevBlocking = currentVal
        end))
    end
    Blocking_Effects()

    --[[
        Strike_Power_Handle

        Keeps the client side damage bar updated by firing a bindable event
        whenever the player's strike power value changes.  This replicates
        the behaviour of the original script which updated the UI whenever
        Punch_Power_V changed.
    ]]--
    local function Strike_Power_Handle()
		local function updateDamageBar()
			Fight_UI.Update_Damage_Bar(Punch_Power_V)
        end
        updateDamageBar()
        table.insert(Cons, Punch_Power_V.Changed:Connect(function()
            updateDamageBar()
        end))
    end
    Strike_Power_Handle()

    --[[
        Client_Striking_Handle

        Orchestrates all combat actions triggered by player input.  This
        includes striking, dodging, blocking and takedown attempts.  Input is
        processed differently on desktop versus mobile devices, but the
        underlying logic remains the same between platforms.
    ]]--
	local function Client_Striking_Handle()
		local Stamina_Params = Fight_Params_Mod.Stamina
		
		local function incrementIndex(value, max)
			local index = value+1
			if index > max then 
				index = 1 
			end
			return index
		end
		
        --[[
            Strike_Handle

            Handles a single punch.  Plays a random woosh sound, fires the
            server remote to signal a strike, plays the appropriate combo
            animation, and manages the combo index.  This function uses
            Debounce_Striking to prevent repeated strikes while a punch is
            already in progress.
        ]]--
		local function Strike_Handle(Is_Punch)
			if Staminia_V.Value >= Stamina_Params.Min_To_Hit and Punch_Power_V.Value > 0 and not Debounce_Striking then
	            Debounce_Striking = true
			
				SE_Mod.PlaySFX(Plr, "Wooshes_SE")
				
				local function playStrikeAnimation()
					
					local track = nil
					if(Is_Punch) then
						track = Combo_Punch_Anim_Arr[Combo_Punch_Index]
						Combo_Punch_Index = incrementIndex(Combo_Punch_Index,#Combo_Punch_Anim_Arr)
					else
						track = Combo_Kick_Anim_Arr[Combo_Kick_Index]
						Combo_Kick_Index = incrementIndex(Combo_Kick_Index, #Combo_Kick_Anim_Arr)
					end
					
	                local key = track:GetAttribute("Strike_Key") or "A"
	                task.spawn(function()
						Throwing_Strike_E:FireServer(key)
						Char:SetAttribute("LastFightAction", Is_Punch and "Punch" or "Kick")
	                end)

	                Animation_Mod.Stop_Animation_Tracks(Combo_Punch_Anim_Arr, {})
	                Animation_Mod.Play_Animation_Track(track)
				end
				playStrikeAnimation()
	            --task.spawn(playStrikeAnimation)
	            --wait(0.5)
				Debounce_Striking = false
			end
        end

        -- Local references to dodge animations.  These are toggled between
        -- slip and headblock variants after each dodge to replicate the
        -- alternating behaviour of the original code.
        local Left_Dodge_Ani = Striking_Anim_Tracks["Slip Left"]
        local Right_Dodge_Ani = Striking_Anim_Tracks["Slip Right"]
        local Back_Dodge_Ani = Striking_Anim_Tracks["Dodge Back"]

        --[[
            Dodge_Handle

            Executes a dodge manoeuvre of the specified type ("Dodge Left",
            "Dodge Right" or "Dodge Back").  The player is propelled in the
            appropriate direction using ApplyImpulse.  The dodge animation
            toggles between slip and headblock variants to add variation.
        ]]--
		local function Dodge_Handle(dodgeType: string)
			if Staminia_V.Value >= Stamina_Params.Min_To_Dodge  and not Debounce_Dodge then
	            Debounce_Dodge = true
	            -- Apply an impulse in the appropriate direction
	            local function applyForce(dir: Vector3)
	                local force = 68
	                if dodgeType == "Dodge Back" then
	                    force = 90
					end
					
	                HRP:ApplyImpulse(dir * (Fight_Walkspeed * force) * HRP:GetMass())
	            end
	            -- Inform the server that a dodge has occurred so that stamina can be reduced
	            task.spawn(function()
					Dodging_Strike_E:FireServer()
					Char:SetAttribute("LastFightAction", "Dodge")
	            end)
	            Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
	            Show_White_Fade:Fire(Color3.new(1, 1, 1))
	            if dodgeType == "Dodge Left" then
	                applyForce(HRP.CFrame.RightVector * -1)
	                Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
	            elseif dodgeType == "Dodge Right" then
	                applyForce(HRP.CFrame.RightVector)
	                Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
	            else
	                applyForce(HRP.CFrame.LookVector * -1)
	                Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
	            end
	            -- Toggle between slip and headblock variants on each call
	            local function incrementAnim()
	                if dodgeType == "Dodge Left" then
	                    if Left_Dodge_Ani == Striking_Anim_Tracks["Slip Left"] then
	                        Left_Dodge_Ani = Striking_Anim_Tracks["Headblock Left"]
	                    else
	                        Left_Dodge_Ani = Striking_Anim_Tracks["Slip Left"]
	                    end
	                elseif dodgeType == "Dodge Right" then
	                    if Right_Dodge_Ani == Striking_Anim_Tracks["Slip Right"] then
	                        Right_Dodge_Ani = Striking_Anim_Tracks["Headblock Right"]
	                    else
	                        Right_Dodge_Ani = Striking_Anim_Tracks["Slip Right"]
	                    end
	                end
	            end
	            incrementAnim()
				Debounce_Dodge = false
			end
        end

        -- Reference used to monitor blocking power draining to zero while
        -- blocking.  This connection is disconnected when blocking ends.
        local Low_Block_Con: RBXScriptConnection? = nil

        --[[
            Disable_Blocking_Handle

            Stops any blocking effects, resets the player's walk speed, stops
            animations and informs the server that the player has stopped
            blocking.  Also fires a local bindable event to ensure the
            mobile UI is updated appropriately.
        ]]--
        local function Disable_Blocking_Handle()
			if Debounce_Blocking then 
				if Low_Block_Con ~= nil then
	                Low_Block_Con:Disconnect()
	                Low_Block_Con = nil
	            end
	            if Hum then
	                Hum.WalkSpeed = Fight_Walkspeed
	            end
	            Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
	            Unblocking_Strike_E:FireServer()
				Release_Mobile_Blocking_E:Fire()
				Char:SetAttribute("LastFightAction", "Unblock")
				Debounce_Blocking = false
			end
        end

        -- Timestamp of the last block activation to throttle repeated blocks
        local lastBlock = os.clock()

        --[[
            Blocking_Handle

            Initiated when the player presses the block key.  Adjusts the
            player's walk speed, listens for the block power to drain to
            zero, plays the block animation and informs the server of the
            block state.
        ]]--
		local function Blocking_Handle()
			if Blocking_Power_V.Value > 0 and not Debounce_Blocking then
	            if os.clock() - lastBlock <= 0.15 then
	                return
	            end
	            lastBlock = os.clock()
	            Debounce_Blocking = true
	            if Hum then
	                Hum.WalkSpeed = Fight_Walkspeed * 0.2
	            end
	            if Low_Block_Con ~= nil then
	                Low_Block_Con:Disconnect()
	                Low_Block_Con = nil
	            end
	            Low_Block_Con = Blocking_Power_V.Changed:Connect(function()
	                if Blocking_Power_V.Value <= 0 and Debounce_Blocking then
	                    if Low_Block_Con ~= nil then
	                        Low_Block_Con:Disconnect()
	                        Low_Block_Con = nil
	                    end
	                    Disable_Blocking_Handle()
	                end
	            end)
	            table.insert(Cons, Low_Block_Con)
	            task.spawn(Play_Blocking_Animation)
				Blocking_Strike_E:FireServer()
				Char:SetAttribute("LastFightAction","Block")
			end
        end

        --[[
            Takedown_Handle

            Attempts to initiate a takedown manoeuvre.  This is only possible
            when the server indicates a takedown is permitted via values
            stored on the fight cage model.  When a valid takedown event is
            found it is fired and a voice over sound plays.  A short delay
            prevents repeated attempts.
        ]]--
		local function Takedown_Handle()
			if Staminia_V.Value >= Stamina_Params.Min_To_Takedown and not Debounce_Takedown then
				local Fight_Data = Cage_M:FindFirstChild("Fight_Data_F")
				local takedown_Tracker =  Fight_Data:FindFirstChild("Takedown_Track")
				local takedownE = Fight_Data:FindFirstChild("Takedown_E") -- Get_Takedown_Event()
				if takedown_Tracker.Value then
					Debounce_Takedown = true
					SE_Mod.Play_Voice_Over("Submission_Attempt")
					takedownE:FireServer()
					Char:SetAttribute("LastFightAction","Takedown")
					wait(1)
					Debounce_Takedown = false
				end
			end
		end
		
		-- Process Input 
		local function Process_Input(inputType)
			-- Check ability to strike, block, dodge, or takedown
			if Health_V.Value > 0 and not state.Is_Hit then
				if inputType == "Punching" or inputType == "Kicking" then
					task.spawn(Disable_Blocking_Handle)
					Strike_Handle(inputType == "Punching")
				elseif inputType == "Blocking" then
					Blocking_Handle()
				elseif inputType ==  "Dodge" or inputType == "Dodge Left" or inputType == "Dodge Right" or inputType == "Dodge Back" then
					task.spawn(Disable_Blocking_Handle)
					if inputType == "Dodge" then
						if Current_Move_Direction.Magnitude <= 0 then
							-- Random Dodge if the player is not currently moving
							local options = {"Dodge Left", "Dodge Right", "Dodge Back"}
							inputType = options[math.random(#options)]
						else 
							-- Directionnal Dodge if the player is moving
							local forward = Current_Move_Direction:Dot(Char.HumanoidRootPart.CFrame.LookVector)
							local right = Current_Move_Direction:Dot(Char.HumanoidRootPart.CFrame.RightVector)
							if math.abs(forward) > math.abs(right) then
								inputType = "Dodge Back"--f>0 and "Dodge Random" or "Dodge Back"
							else
								inputType = right>0 and "Dodge Right" or "Dodge Left"
							end
						end
					end
					Dodge_Handle(inputType)
				elseif inputType == "Takedown" then
					Takedown_Handle()
				elseif inputType =="Unblocking" then
					Disable_Blocking_Handle()
				end
			end
		end

        if not UIS.TouchEnabled then
			-- Listen for desktop and platforms input events (seeInput_Handle mapping)
			
			-- Input mapping helper for desktop platforms
			local function Input_Mapping(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.KeyCode == Enum.KeyCode.ButtonR2 then
					return "Punching"
				elseif input.UserInputType == Enum.UserInputType.MouseButton2 or input.KeyCode == Enum.KeyCode.ButtonL2 then
					return "Kicking"
				elseif input.KeyCode == Enum.KeyCode.E or input.KeyCode == Enum.KeyCode.ButtonA then
					return "Dodge"
				elseif input.KeyCode == Enum.KeyCode.Space or input.KeyCode == Enum.KeyCode.ButtonB then
					return "Blocking"
				elseif input.KeyCode == Enum.KeyCode.R or input.KeyCode == Enum.KeyCode.ButtonY then
					if (Cage_M) then
						return "Takedown"
					end
				end
				return "None"
			end
			
			table.insert(Cons, UIS.InputBegan:Connect(function(input, GPE)
				if not Is_Chatbox_Typing:Invoke() then
					local inputType = Input_Mapping(input)
					Process_Input(inputType)
				end
			end))
            table.insert(Cons, UIS.InputEnded:Connect(function(input, GPE)
				if not Is_Chatbox_Typing:Invoke() then
					if Input_Mapping(input) == "Blocking" then
						Process_Input("Unblocking")
					end
                end
            end))
        else
			-- Mobile interface support
			local function Click_Striking_Handle(b, inputType)
				Buttons_Mod.Button_Setup_OnClickDown(Cons, b, b:FindFirstChild("Selected"), { b:FindFirstChild("Icon_Img")}, 
					function () Process_Input(inputType) end,-- CallBack
					function () return not Debounce_Striking end -- Avaialble
				)
			end
			
			local function Click_Dodge_Handle(b, inputType)
				Buttons_Mod.Button_Setup_OnClickDown(Cons, b, b:FindFirstChild("Selected"), { b:FindFirstChild("Icon_Img")}, 
					function () Process_Input(inputType) end, -- CallBack	
					function () return not Debounce_Dodge end -- Available
				)
            end
            
			local function Press_Blocking_Handle(b)
				Buttons_Mod.Button_Setup_OnPress(Cons, b, b:FindFirstChild("Selected"), { b:FindFirstChild("Icon_Img")}, 
					function ()	Process_Input("Blocking") end,   -- CallBack Down
					function () Process_Input("Unblocking") end, -- CallBack Up
					Release_Mobile_Blocking_E                    -- Release Event
				)
			end
			
			local function Takedown_Handle_Mobile(b)
				if (Cage_M) then				
					Buttons_Mod.Button_Setup_OnClickDown(Cons, b, b:FindFirstChild("Selected"), { b:FindFirstChild("Icon_Img")}, 
						function () Process_Input("Takedown") end     -- CallBack
					)
					b.Visible  = false
					local Takedown_Tracker = Cage_M:FindFirstChild("Fight_Data_F"):FindFirstChild("Takedown_Track")
					table.insert(Cons,Takedown_Tracker.Changed:Connect(function()
						b.Visible = Takedown_Tracker.Value and Takedown_Tracker:GetAttribute(Plr.Name) > 0
					end))
				else 
					b.Visible = false
				end
			end
			
			local Mobile_Buttons = Get_Mobile_Buttons_BF:Invoke()
			for _, B in ipairs(Mobile_Buttons) do
				if     B.Name == "Punching_B"    then Click_Striking_Handle(B, "Punching")
				elseif B.Name == "Kicking_B"     then Click_Striking_Handle(B, "Kicking")
				elseif B.Name == "Dodge_B"     then Click_Dodge_Handle(B, "Dodge")
				--elseif B.Name == "Dodge_Left_B"  then Click_Dodge_Handle(B, "Dodge Left")
				--elseif B.Name == "Dodge_Right_B" then Click_Dodge_Handle(B, "Dodge Right")
				-- elseif B.Name == "Dodge_Back_B"  then Click_Dodge_Handle(B, "Dodge Back")
				elseif B.Name == "Block_B"       then Press_Blocking_Handle(B)
				elseif B.Name == "Takedown_B"    then Takedown_Handle_Mobile(B)
				--elseif B.Name == "CageControl_B" then return -- Add other minigames buttons here
				end
			end
        end
    end
    Client_Striking_Handle()
end

return Combat_Inputs]]></ProtectedString>
								<string name="ScriptGuid">{5756E3D6-7BA7-45B1-9538-89F20DB67AF8}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Combat_Inputs.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXEB4DD267D5904C23B67AE38F9FD83DC2">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterGui/Fight_System_UI/Client_Fight_Handle/Camera_Rig.lua
--
--  Description:
--      Manages the player's combat camera rig during fight mode.
--      Creates and controls a BodyGyro to orient the player toward
--      their opponent, adjusts camera behavior, and locks mouse 
--      controls for precise third-person combat aiming.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-10-08 by Oriane
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * RunService
--          * UserInputService
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events/Set_Player_Fight_Opponent
--      - Player Instance:
--          * Character (Humanoid, HumanoidRootPart)
--
--  Notes:
--      - Automatically adjusts camera orientation toward the current target.
--      - Locks mouse to center during fights and disables jump/climb states.
--      - Dynamically updates BodyGyro torque based on platform state.
--      - Synchronizes with Client_Fight_Handle via shared environment (env).
--      - Provides smooth rotation, zoom, and angle transitions each frame.
--
--======================================================================


----- DEPENDENCIES -----

--// Services
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

----- REFERENCES -----
--// Player and Character
local Plr = game.Players.LocalPlayer

--// Character Components
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Cam = game.Workspace.CurrentCamera

local Camera_Rig = {}

function Camera_Rig.Setup(env)
	local Fight_Walkspeed: number = env.Fight_Walkspeed
	local Max_Angle: number = env.Max_Angle
    local Set_Cam_Adjustments = env.Set_Cam_Adjustments
    local Reset_BG = env.Reset_BG
    local Cons = env.Cons
    local state = env.state
    local RS_Con_ref = env.RS_Con_ref
    -- Target_HRP is a reference that may be reassigned by this module
    -- We capture it as a local upvalue so that modifications affect the original
    local Target_HRP = env.Target_HRP

    -- Reset any previous rig and create a new BodyGyro
    local function Create_BG()
        Reset_BG()
        -- Destroy any existing BodyGyro on the HRP
        local oldG = HRP:FindFirstChildWhichIsA("BodyGyro")
        if oldG then
            oldG:Destroy()
        end
        local bodyG = Instance.new("BodyGyro", HRP)
        bodyG.P = 1000
        bodyG.MaxTorque = Vector3.new(0, 1000, 0)
        bodyG.D = 10
        -- Configure player camera and input settings for fighting
        Plr.CameraMaxZoomDistance = 18
        Plr.CameraMinZoomDistance = 18
        UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
        UIS.MouseIconEnabled = false
        UIS.MouseDeltaSensitivity = 0.5
        if Hum then
            Hum.AutoRotate = false
            Hum.WalkSpeed = Fight_Walkspeed
            Hum.JumpPower = 0
            Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
            Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
            Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
        end
        Char:SetAttribute("Is_Fighting", true)
        return bodyG
    end
    local BG = Create_BG()
    -- Apply initial camera adjustments depending on whether a target exists
    Set_Cam_Adjustments((Target_HRP == nil))
    --[[EVENT NOT FIRED BY SERVER
    -- Listen for the server instructing us to lock onto a specific opponent
    table.insert(Cons, Set_Player_Fight_Opponent.OnClientEvent:Connect(function(opponentChar)
        if opponentChar and opponentChar:FindFirstChild("HumanoidRootPart") then
            env.Target_HRP = opponentChar:FindFirstChild("HumanoidRootPart")
        else
            env.Target_HRP = nil
        end
        Set_Cam_Adjustments((env.Target_HRP == nil))
    end))]]
    -- When the local player dies, clear the target and reset the camera rig
    table.insert(Cons, Hum.Died:Connect(function()
        env.Target_HRP = nil
        Reset_BG()
    end))
    -- Function to update the BodyGyro’s CFrame each step
    local function Update_BG()
        local lookPos = HRP.Position + (Cam.CFrame.LookVector * 25)
        if env.Target_HRP then
            lookPos = env.Target_HRP.Position
        end
        BG.CFrame = CFrame.new(HRP.Position, lookPos)
    end
    Update_BG()
    -- Stepped connection to continuously update the BodyGyro
	local rsCon = RunService.Stepped:Connect(function()
        if BG and Cam then
            Update_BG()
        end
    end)
    table.insert(Cons, rsCon)
    -- Expose the connection so the main script can disconnect it later
    if RS_Con_ref then
        RS_Con_ref.con = rsCon
    end
    -- Adjust the BodyGyro’s torque when the player enters or exits PlatformStand
    table.insert(Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
        if Hum.PlatformStand then
            BG.P = 0
            BG.MaxTorque = Vector3.new(0, 0, 0)
            BG.D = 0
        else
            BG.P = 1000
            BG.MaxTorque = Vector3.new(0, 1000, 0)
            BG.D = 10
        end
    end))
    -- Bind a RenderStep callback to smoothly rotate the camera towards the target
    local lastCFrame = Cam.CFrame
	RunService:BindToRenderStep("UpdateLoop", Enum.RenderPriority.Camera.Value - 1, function(dt)
        if env.Target_HRP then
            if Hum and Hum.WalkSpeed > 0 and HRP and not HRP.Anchored then
                local vec = (env.Target_HRP.Position - HRP.Position) * Vector3.new(1, 0, 1)
                if vec.Magnitude <= 0.001 then
                    vec = Vector3.zAxis
                end
                vec = vec.Unit
                local lerp = state.Is_Hit and 0.1 or 0.3
                local alpha = 1 - (1 - lerp) ^ (60 * dt)
                local targetCF = CFrame.new(HRP.Position, HRP.Position + vec) * CFrame.Angles(Max_Angle, 0, 0) * CFrame.new(3, 2, 13)
                Cam.CFrame = lastCFrame:Lerp(targetCF, alpha)
                lastCFrame = Cam.CFrame
            end
        end
    end)
    return BG
end

return Camera_Rig]]></ProtectedString>
								<string name="ScriptGuid">{35315935-ED45-46C5-814F-A670ACFF232D}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Camera_Rig.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5A9B25E9BFA84E3A8AF1094CB92E3E19">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterGui/Fight_System_UI/Client_Fight_Handle/Clinch_Sequence.lua
--
--  Description:
--      Handles the Cage Clinch cinematic sequence during fights.
--      Plays synchronized attack/defense animations, manages camera
--      transitions, screen flashes, and camera shakes for impactful
--      close-range combat moments.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-10-08 by Oriane
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * TweenService
--          * RunService
--          * UserInputService
--      - ReplicatedStorage:
--          * Data_Mods_F/CameraShaker
--          * Data_Mods_F/Animation_Mod
--          * Data_Mods_F/Sound_Mod
--          * Channels_F/Server_Client_F/Events/Cage_Clinch_Start
--          * Channels_F/Bindable_F/Events/Show_White_Fade
--      - Player Instance:
--          * Character (Humanoid, HumanoidRootPart)
--
--  Notes:
--      - Freezes player movement and disables inputs during the cut-scene.
--      - Locks the camera to a cinematic CFrame and narrows the FOV.
--      - Alternates between attacking and defending animation sets.
--      - Triggers flashes and camera shakes on each hit impact.
--      - Automatically resets the camera, animations, and fight state
--        once the clinch sequence finishes.
--      - Works in conjunction with Client_Fight_Handle and Combat_Inputs.
--
--======================================================================

----- DEPENDENCIES -----
--// Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")

--// Required Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Cam_Shake_Mod = require(Data_Mods_F:WaitForChild("CameraShaker"))
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Fight_UI = require(script.Parent:WaitForChild("Fight_UI"))

----- REFERENCES -----
--// Player and Character
local Plr = game.Players.LocalPlayer


--// Character Components
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Cam = game.Workspace.CurrentCamera

-- Events
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Cage_Clinch_Start 	= Channels.SC_Remote_Events.Cage_Clinch_Start
local Show_White_Fade 		= Channels.Bindable_Events.Show_White_Fade


local Clinch_Sequence = {}

function Clinch_Sequence.Setup(env)
    local Set_Cam_Adjustments = env.Set_Cam_Adjustments
    local state = env.state
    local BG = env.BG
    local Fight_Walkspeed: number = env.Fight_Walkspeed
    local Cam_FOV: number = env.Cam_FOV
    local Anim_Track_Data = env.Anim_Track_Data
    local Cons = env.Cons
    local Tween_Cam = env.Tween_Cam

    -- Precompute the clinch animation tracks for attacking and non‑attacking states
    local Attack_Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, true)
    local Non_Attack_Clinch_Tracks = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, false)

    -- Handler for the clinch cut‑scene
    local function Cage_Clinch_Handle(Animation_Sequence_Data: {string}, Is_Attacking: boolean, Camera_CF: CFrame)
        -- Freeze the character and hide UI hints
        local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(Char)
			Fight_UI.Update("Cinematic")
            state.Is_Hit = true
            state.Is_Cage_Submission = true
            if BG then
                BG.P = 0
                BG.MaxTorque = Vector3.new(0, 0, 0)
                BG.D = 0
            end
            if Hum then
                Hum.WalkSpeed = 0
            end
        end
        Freeze_Character()
        -- Lock the camera to the provided CFrame and narrow the FOV
        local function Lock_Camera()
            local Cam_Offset = HRP.CFrame:ToObjectSpace(Cam.CFrame)
            local initFOV = Cam.FieldOfView
            Cam.CameraType = Enum.CameraType.Scriptable
            TS:Create(Cam, Tween_Cam, {CFrame = Camera_CF, FieldOfView = 50}):Play()
            return Cam_Offset, initFOV
        end
        local Cam_CF_Offset, Init_Cam_FOV = Lock_Camera()
        -- Create a camera shake object
        local function Cam_Shake()
            local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
                Cam.CFrame = Cam.CFrame * shakeCf
            end)
            return CS
        end
        local camShake = Cam_Shake()
        -- Play the clinch strike animations and camera effects
        local function Play_Strike_Sequences()
            local function Get_Clinch_Tracks_Data()
                if Is_Attacking then
                    return Attack_Clinch_Tracks_Data
                else
                    return Non_Attack_Clinch_Tracks
                end
            end
            local clinchTracks = Get_Clinch_Tracks_Data()
            -- Play the initial clinch and loop animations
            Animation_Mod.Play_Animation_Track(clinchTracks['Init_Clinch'], true)
            task.spawn(Animation_Mod.Play_Animation_Track, clinchTracks['Loop_Clinch'])
            wait(1)
            -- Start camera shake and define flash effect per hit
            camShake:Start()
            local function Play_Clinch_Hit_Effects()
                local col = Color3.new(1, 0, 0)
                if Is_Attacking then
                    col = Color3.new(1, 1, 1)
                end
				Show_White_Fade:Fire(col)
                camShake:Shake(Cam_Shake_Mod.Presets.Bump)
            end
            for i = 1, #Animation_Sequence_Data do
                local strikeKey = Animation_Sequence_Data[i]
                local strikeTrack = clinchTracks[strikeKey]
                if strikeTrack then
                    Play_Clinch_Hit_Effects()
                    Animation_Mod.Play_Animation_Track(strikeTrack)
                end
            end
            camShake:Stop()
        end
        Play_Strike_Sequences()
        -- Reset the player and camera after the clinch sequence completes
        local function Clinch_Reset_Handle()
            local function Reset_Player_Camera()
                local tweenCamClinch = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.In, 0, false, 0)
                local camCF = HRP.CFrame:ToWorldSpace(Cam_CF_Offset)
                Cam.CameraType = Enum.CameraType.Scriptable
                TS:Create(Cam, tweenCamClinch, {CFrame = camCF, FieldOfView = Init_Cam_FOV}):Play()
                wait(0.75)
                Set_Cam_Adjustments((env.Target_HRP == nil))
            end
            task.spawn(Reset_Player_Camera)
			Animation_Mod.Reset_Character_Animations(Char)
			Fight_UI.Update("Cage_Fight")
            state.Is_Hit = false
            state.Is_Cage_Submission = false
            if Hum then
                if BG and not Hum.PlatformStand then
                    BG.P = 1000
                    BG.MaxTorque = Vector3.new(0, 1000, 0)
                    BG.D = 10
                end
                Hum.WalkSpeed = Fight_Walkspeed
                Anim_Track_Data['Idle']:Play()
                Anim_Track_Data['Idle']:AdjustSpeed(0.5)
                Cam.FieldOfView = Cam_FOV
            end
        end
        Clinch_Reset_Handle()
    end
    -- Connect the remote event to initiate the cage clinch cut‑scene
	table.insert(Cons, Cage_Clinch_Start.OnClientEvent:Connect(function(sequenceKeys, isAttacking, cameraCF)
        Cage_Clinch_Handle(sequenceKeys, isAttacking, cameraCF)
    end))
end

return Clinch_Sequence]]></ProtectedString>
								<string name="ScriptGuid">{AA5A6391-C90B-422E-9FD2-14112ECF09B7}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Client_Clinch_Sequence.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX38270D73A44742D6A997009AFB9319F2">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[
--======================================================================
--  File: StarterPlayerScripts/Fight_System/Modules/Submission_Cut_Scene.lua
--
--  Description:
--      Manages the Submission cinematic sequence and minigame.
--      Coordinates attacking and defending animations, camera angles,
--      heartbeat effects, and tap-speed tracking for realistic
--      ground submission phases in fights.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-10-08 by Oriane
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * TweenService
--          * RunService
--          * UserInputService
--      - ReplicatedStorage:
--          * Data_Mods_F/Animation_Mod
--          * Data_Mods_F/Sound_Mod
--          * Channels_F/Server_Client_F/Events/Submission_Minigame
--          * Channels_F/Bindable_F/Events/Show_White_Fade
--          * Channels_F/Bindable_F/Events/Click_Rate_Inc
--          * Channels_F/Bindable_F/Events/Click_Rate_Reset
--          * Channels_F/Bindable_F/Events/Click_Rate_Update
--      - Player Instance:
--          * Character (Humanoid, HumanoidRootPart)
--          * PlayerGui (Submission UI elements)
--
--  Notes:
--      - Starts the submission sequence when triggered by the server.
--      - Plays contextual attack or defense animations based on player role.
--      - Displays click-rate-based progress bar for winning the submission.
--      - Applies heartbeat SFX and camera shake for intensity.
--      - Cleans up all UI and resets fight state on completion or interruption.
--      - Integrates with Client_Fight_Handle and Click_Rate_System.
--
--======================================================================

--// Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local RunService = game:GetService("RunService")

--// Required Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Fight_UI = require(script.Parent:WaitForChild("Fight_UI"))

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local On_Submission_Handle			= Channels.Bindable_Events.On_Submission_Handle
local Unblocking_Strike			= Channels.CS_Remote_Events.Unblocking_Strike

----- REFERENCES -----
--// Player and Character
local Plr = game.Players.LocalPlayer

--// Character Components
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Cam = game.Workspace.CurrentCamera

--// Objects
local Main_World_F = game.Workspace:WaitForChild("Main_World_F")
local Objects = Main_World_F:WaitForChild("Gameplay"):WaitForChild("Objects")
local Fight_Cages_F = Objects:WaitForChild("Fight_Cages_F")

local Submission_Minigame = {}

function Submission_Minigame.Setup(env)
    local Set_Cam_Adjustments = env.Set_Cam_Adjustments
	local Cage_M = env.Cage_M
    local BG = env.BG
    local state = env.state
    local Anim_Track_Data = env.Anim_Track_Data
    local Fight_Walkspeed: number = env.Fight_Walkspeed
    local Cam_FOV: number = env.Cam_FOV
    local Cam_Offset: Vector3 = env.Cam_Offset
    local Tween_Cam: TweenInfo = env.Tween_Cam
    local Cons = env.Cons

    -- Locals to preserve camera offset during submission sequences
    local Prev_Camera_Offset: CFrame? = nil
    local Cam_Tween_Local: TweenInfo = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
    local Cam_RS_Con: RBXScriptConnection? = nil

    -- Event handler for beginning and ending a submission sequence.  This
    -- function mirrors the On_Submission_Handle from the original script,
    -- updating state flags, playing animations and adjusting the camera.
    local function On_Submission_Handler(Is_Attacking: boolean, Is_Starting: boolean)
        -- Reset any current animations and update the UI hints
		Animation_Mod.Reset_Character_Animations(Char)
		Fight_UI.Update(Is_Starting and "Cinematic" or "Cage_Fight")
		Unblocking_Strike:FireServer()

        -- Disconnect any existing camera follow connection
        if Cam_RS_Con ~= nil then
            Cam_RS_Con:Disconnect()
            Cam_RS_Con = nil
        end

		if Is_Starting then
            -- Begin submission: mark hit state and submission state
            state.Is_Hit = true
            state.Is_Cage_Submission = true
            -- Disable body gyro torque so the camera doesn’t fight the animation
            if BG ~= nil then
                BG.P = 0
                BG.MaxTorque = Vector3.new(0, 0, 0)
                BG.D = 0
            end
            -- Prevent the player from moving during the submission
            if Hum ~= nil then
                Hum.WalkSpeed = 0
            end
            -- Slightly raise the defender’s root part when not attacking
            if HRP ~= nil then
                if not Is_Attacking then
                    HRP.CFrame = HRP.CFrame * CFrame.new(0, 0.15, 0)
                end
            end
            -- Helper to obtain the appropriate animation tracks for the
            -- takedown and submission based on who is the attacker
            local function Get_Takedown_Submission_Tracks()
                -- Identify the character that is initiating the submission
                local function Get_Fighting_Character()
                    for _, fm in ipairs(Fight_Cages_F:GetChildren()) do
                        if fm and fm:FindFirstChild("Fight_Data_F") then
                            local fd = fm:FindFirstChild("Fight_Data_F")
                            local char1 = fd:FindFirstChild("Fight_Char_1")
                            local char2 = fd:FindFirstChild("Fight_Char_2")
                            local submissionChar = fd:FindFirstChild("Submission_Hold_Character")
                            if Char and char1 and char2 and submissionChar and
                                (char1.Value == Char or char2.Value == Char) and
                                submissionChar.Value ~= nil then
                                return submissionChar.Value
                            end
                        end
                    end
                    return nil
                end
                local attackingChar = Get_Fighting_Character()
                local takedownData, submissionData = Animation_Mod.Get_Takedown_Submission_Data(attackingChar)
                if Is_Attacking then
                    return Animation_Mod.Get_Takedown_Submission_Tracks(Hum,
                        takedownData["Takedown ID"], submissionData["Submission ID"], submissionData["Submission Loop ID"])
                else
                    return Animation_Mod.Get_Takedown_Submission_Tracks(Hum,
                        takedownData["Receiving ID"], submissionData["Receiving ID"], submissionData["Receiving Loop ID"])
                end
            end
            local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()
            -- Initialise the camera for the submission sequence
            local function Play_Init_Camera_Effects()
                if Prev_Camera_Offset == nil and HRP ~= nil then
                    Prev_Camera_Offset = HRP.CFrame:ToObjectSpace(Cam.CFrame)
                end
                -- Find the humanoid (UpperTorso) of the opponent being submitted to look at
                local function Get_Receiving_HRP()
					if Cage_M and Cage_M:FindFirstChild("Fight_Data_F") then
						local fd = Cage_M:FindFirstChild("Fight_Data_F")
                        local submissionCharV = fd:FindFirstChild("Submission_Hold_Character")
                        local char1V = fd:FindFirstChild("Fight_Char_1")
                        local char2V = fd:FindFirstChild("Fight_Char_2")
                        if submissionCharV and char1V and char2V then
                            if char1V.Value ~= submissionCharV.Value then
                                local tHRP = char1V.Value:FindFirstChild("UpperTorso")
                                if tHRP then
                                    return tHRP
                                end
                            else
                                local tHRP = char2V.Value:FindFirstChild("UpperTorso")
                                if tHRP then
                                    return tHRP
                                end
                            end
                        end
                    end
                    return HRP
                end
                local tHRP = Get_Receiving_HRP()
                -- Compute a fixed offset relative to the target torso
                local offsetCF = CFrame.new(Vector3.new(4.31428, 5.22440, -5.47107))
                local finalPos = tHRP.CFrame:ToWorldSpace(offsetCF).Position
                    local rotCF = CFrame.new(finalPos, tHRP.Position)
                local finalCF = CFrame.new(finalPos) * rotCF.Rotation
                -- Move the camera into position and make it scriptable
                Cam.CameraType = Enum.CameraType.Scriptable
                TS:Create(Cam, Tween_Cam, {CFrame = finalCF}):Play()
                if Cam_RS_Con ~= nil then
                    Cam_RS_Con:Disconnect()
                    Cam_RS_Con = nil
                end
                Cam_RS_Con = RunService.Stepped:Connect(function()
                    if Cam and tHRP and Cam.CameraType == Enum.CameraType.Scriptable then
                        Cam.CFrame = CFrame.new(Cam.CFrame.Position, tHRP.Position)
                    end
                end)
                table.insert(Cons, Cam_RS_Con)
            end
            Play_Init_Camera_Effects()
            -- Play the takedown, then submission and loop animations in sequence
            Takedown_Track.Priority = Enum.AnimationPriority.Action2
            Animation_Mod.Play_Animation_Track(Takedown_Track, true)
            wait(0.25)
            Submission_Track.Priority = Enum.AnimationPriority.Action3
            Animation_Mod.Play_Animation_Track(Submission_Track)
            Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
        else
            -- End submission: reset hit state and submission state
            state.Is_Hit = false
            state.Is_Cage_Submission = false
            if HRP then
                HRP.Anchored = false
                -- Restore the camera to its previous relative offset
                local function Reset_Player_Camera()
                    if Prev_Camera_Offset == nil and HRP ~= nil then
                        Prev_Camera_Offset = CFrame.new() * CFrame.Angles(0, 0, 0)
                    end
                    if HRP then
                        local camCF = HRP.CFrame:ToWorldSpace(Prev_Camera_Offset)
                        Cam.CameraType = Enum.CameraType.Scriptable
                        TS:Create(Cam, Cam_Tween_Local, {CFrame = camCF}):Play()
                        TS:Create(Hum, Tween_Cam, {CameraOffset = Cam_Offset}):Play()
                        wait(0.75)
                        Set_Cam_Adjustments((env.Target_HRP == nil))
                    end
                end
                task.spawn(Reset_Player_Camera)
            end
            if Hum then
                if BG and Hum.PlatformStand == false then
                    BG.P = 1000
                    BG.MaxTorque = Vector3.new(0, 1000, 0)
                    BG.D = 10
                end
                Hum.WalkSpeed = Fight_Walkspeed
                Anim_Track_Data["Idle"]:Play()
                Anim_Track_Data["Idle"]:AdjustSpeed(0.5)
                Cam.FieldOfView = Cam_FOV
			end
			Char:SetAttribute("LastFightAction", "Submission")
        end
    end

    -- Connect the bindable event which triggers submission sequences
	table.insert(Cons, On_Submission_Handle.Event:Connect(function(isAttacking, isStarting)
		On_Submission_Handler(isAttacking, isStarting)
    end))
end

return Submission_Minigame]]></ProtectedString>
								<string name="ScriptGuid">{792A83E0-53E7-4164-A095-B524FBFDCA58}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Client_Submission_Minigame.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX762289AB3C934BBF86F8A83A226C3A78">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local Fight_UI = {}

----- DEPENDENCIES -----

--// Services
local RS = game:GetService("ReplicatedStorage")

--// Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))

----- REFERENCES -----
--// Player and Character
local Plr = script.Parent:FindFirstAncestorWhichIsA("Player")

--// Character Components
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")

--// Fighter UI References
local Inputs_UI = script.Parent.Parent:WaitForChild("Fight_Inputs_UI")
local Damage_Bar_F = Inputs_UI:WaitForChild("Damage_Bar_F")

-- Events
local Channels 					 = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

--// Bindables
local Toggle_Tools_Buttons		   = Channels.Bindable_Events.Toggle_Tools_Buttons
local Toggle_Fight_Button          = Channels.Bindable_Events.Toggle_Fight_Button
local Toggle_TopBar                = Channels.Bindable_Events.Toggle_TopBar
local Toggle_Side_Buttons          = Channels.Bindable_Events.Toggle_Side_Buttons
local Toggle_BG_Volume             = Channels.Bindable_Events.Toggle_BG_Volume
local Toggle_Fight_UI              = Channels.Bindable_Events.Toggle_Fight_UI
local Toggle_Takedown_Tracker      = Channels.Bindable_Events.Toggle_Takedown_Tracker
local Remove_Submission_UI         = Channels.Bindable_Events.Remove_Submission_UI
local Toggle_Key_Labels            = Channels.Bindable_Events.Toggle_Key_Labels

local Show_Shield_UI               = Channels.CS_Remote_Events.Show_Shield_UI
local Toggle_Healing_Effect        = Channels.CS_Remote_Events.Toggle_Healing_Effect

local function Update_Shield_UI(Should_Show)
	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	if Fight_UI then 
		Fight_UI.AlwaysOnTop = true
	end
	task.spawn(function()
		Show_Shield_UI:FireServer(Should_Show)
	end)
end

local function Show_Damage_Bar(Should_Show)
	Damage_Bar_F.Visible = Should_Show
end

local function Update_Damage_Bar_UI(Punch_Power_V)
	local Damage_UIG = Damage_Bar_F:FindFirstChild("Gauge_Filling"):FindFirstChildWhichIsA("UIGradient")
	local Punch_Power = Fight_Params_Mod.Punch_Power
	if(Damage_UIG ~= nil)then
		local Dif =  math.clamp(Punch_Power_V.Value/Punch_Power.Max_Value, 0, 1)
		local Gradient_Offset = 0.9 * Dif -- empirically determined based on filling asset image
		Damage_UIG.Offset = Vector2.new(Gradient_Offset, 0)
	end 
end


---- Name Tag -----
local function Reset_Name_Tag_Handle(C)
	if not C then
		return
	end
	
	local Name_Tag = C:FindFirstChild("Name_Tag_UI")
	local Toggle_Tabs = {"UIStroke", "Rank_F", "Connection_Img", "Device_Img", "Country_Img", 
		"Player_Name_Txt"}

	if(Name_Tag ~= nil and Name_Tag:FindFirstChild("Main_F") ~= nil)then
		local Main_F = Name_Tag:FindFirstChild("Main_F")

		for i = 1, #Toggle_Tabs do
			local Tab = Main_F:FindFirstChild(Toggle_Tabs[i])
			if(Tab ~= nil)then
				if(Tab:IsA("UIStroke"))then
					Tab.Enabled = true
				else
					Tab.Visible = true
				end
			end
		end

		Main_F.BackgroundTransparency = 0.125

		if(C ~= Char)then
			Name_Tag.StudsOffset = Vector3.new(0, -4, 0)
		end

		Name_Tag.Enabled = true
	end
end

----- Healing Effect -----
local function Toggle_Heal_PE(Is_Enabled)
	local All_C = HRP:GetChildren()
	for i = 1, #All_C do
		local C = All_C[i]
		if(C ~= nil and C.Name == "Heal_PE" and C:IsA("ParticleEmitter"))then
			C.Enabled = Is_Enabled
		end
	end
	
	local Fighting_UI = Char:WaitForChild("Fighting_UI")
	local Shield_Img = Fighting_UI:WaitForChild("Main_F"):WaitForChild("Shield_F"):WaitForChild("Shield_Img")

	if(Shield_Img ~= nil)then
		if(Is_Enabled)then
			Shield_Img.Image = "rbxassetid://130871917395731"
		else
			Shield_Img.Image = "rbxassetid://125284121534949"
		end
	end
end

----- Sweat Effect -----
local function Trigger_Sweat_Effect_Handle()
	if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
		local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
		local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
		if(PE ~= nil)then
			PE:Emit(25)
		end
	end
end

----- UI Update -----

function Update_To_Normal_UI(Active_Fight_Button)
	Toggle_Fight_UI:Fire(false)
	Toggle_Takedown_Tracker:Fire(false)
	Remove_Submission_UI:Fire()
	
	Toggle_BG_Volume:Fire(true)
	Toggle_TopBar:Fire(true)
	Toggle_Side_Buttons:Fire(true)
	Toggle_Tools_Buttons:Fire(true)
	Toggle_Fight_Button:Fire(Active_Fight_Button) --only Fight on tools buttons

	Toggle_Key_Labels:Fire(false)

	Show_Damage_Bar(false)
	Update_Shield_UI(false)
end

function Update_To_Free_Fight_UI()
	-- Toggle_Fight_UI:Fire(false)
	-- Toggle_Takedown_Tracker:Fire(false)
	-- Remove_Submission_UI:Fire()

	
	-- Toggle_BG_Volume:Fire(true)
	Toggle_TopBar:Fire(false)
	Toggle_Side_Buttons:Fire(false)
	-- Toggle_Tools_Buttons:Fire(true)
	-- Toggle_Fight_Button:Fire(true)

	Toggle_Key_Labels:Fire(true)

	Show_Damage_Bar(true)
	Update_Shield_UI(true)
end

function Update_To_Cage_Fight_UI(cage_M)
	Toggle_Fight_UI:Fire(true, cage_M)
	Toggle_Takedown_Tracker:Fire(true, cage_M)
	-- Remove_Submission_UI:Fire()

	Toggle_BG_Volume:Fire(false)
	Toggle_TopBar:Fire(false)
	Toggle_Side_Buttons:Fire(false)
	Toggle_Tools_Buttons:Fire(false)
	--Toggle_Fight_Button:Fire(false)

	Toggle_Key_Labels:Fire(true)
	
	Show_Damage_Bar(true)
	Update_Shield_UI(true)
end

function Update_To_Cinematic_UI() 
	
	-- Toggle_Fight_UI:Fire(true)
	Toggle_Takedown_Tracker:Fire(false)
	-- Remove_Submission_UI:Fire()

	-- Toggle_BG_Volume:Fire(false)
	-- Toggle_TopBar:Fire(false)
	-- Toggle_Side_Buttons:Fire(false)
	-- Toggle_Tools_Buttons:Fire(false)
	--Toggle_Fight_Button:Fire(false)
	
	Toggle_Key_Labels:Fire(false)
	
	Show_Damage_Bar(false)
	Update_Shield_UI(false)
end

function Update_To_Submission_UI()
	-- Toggle_Fight_UI:Fire(true)
	Toggle_Takedown_Tracker:Fire(false)
	-- Remove_Submission_UI:Fire()

	-- Toggle_Fight_Button:Fire(false)
	-- Toggle_BG_Volume:Fire(false)
	-- Toggle_TopBar:Fire(false)
	-- Toggle_Side_Buttons:Fire(false)

	Toggle_Key_Labels:Fire(false)

	Show_Damage_Bar(false)
	Update_Shield_UI(false)
end

----- Module Functions -----

local Fight_State = ""
local Cage_M = nil
function Fight_UI.Setup(cage)
	Cage_M = cage
end

function Fight_UI.Update(State)
	-- warn(State)
	if Fight_State == State then
		return
	else
		Fight_State = State 
		if(Fight_State == "No_Fight") then
			Update_To_Normal_UI(false)
		elseif(Fight_State == "No_Fight_In_Gym") then
			Update_To_Normal_UI(true)
		elseif (Fight_State == "Free_Fight") then
			Update_To_Free_Fight_UI()
		elseif (Fight_State == "Cage_Fight") then
			Update_To_Cage_Fight_UI(Cage_M)
		elseif (Fight_State == "Cinematic") then
			Update_To_Cinematic_UI()
		elseif (Fight_State == "Submission")then
			Update_To_Submission_UI()
		end
	end
end

function Fight_UI.Reset_Name_Tag(C)
	Reset_Name_Tag_Handle(C)
end

function Fight_UI.Update_Damage_Bar(Punch_Power_V)
	Update_Damage_Bar_UI(Punch_Power_V)
end

function Fight_UI.Trigger_Sweat_Effect()
	Trigger_Sweat_Effect_Handle()
end

Toggle_Healing_Effect.OnClientEvent:Connect(function(Is_Enabled)
	Toggle_Heal_PE(Is_Enabled)
end)



return Fight_UI]]></ProtectedString>
								<string name="ScriptGuid">{BC4A13AD-610C-47F4-8C7B-11E8EA790F10}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Fight_UI.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXFDD12AD858D34A908FB24AE1146176F9">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Buttons_Mod.lua
--
--  Description:
--      Centralized UI button handler module providing reusable animation
--      and interaction logic for ImageButtons and TextButtons.
--      Supports click, press/hold, and hover behaviors with color tweening
--      and sound feedback via Sound_Mod.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-11-01 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Sound_Mod (for UI click/hover sounds)
--      - Services:
--          * TweenService
--
--  Notes:
--      - Button_Setup_OnClickDown: one-shot click handler (plays click sound + size tween)
--      - Button_Setup_OnPress: press/release logic with optional external release events
--      - Button_Setup_OnHover: placeholder for hover logic extension
--      - Color and tween behavior are defined through constants for easy tuning
--
--======================================================================

local Buttons_Mod = {}

----- DEPENDENCIES -----
--// Services
local TS = game:GetService("TweenService")
--// Required Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

----- REFERENCES -----
--// Player and Character
local Plr = game.Players.LocalPlayer

----- VARIABLES -----
local Icon_Color_Down = Color3.new(0.0941176, 0.0941176, 0.0941176)
local Tween_Length = 0.125
local Reverse_Tween = TweenInfo.new(Tween_Length, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local OneWay_Tween = TweenInfo.new(Tween_Length/2, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Click_Size_Ratio = 0.75

--// Colors
local function Get_Initial_Color(imgs)
	local colors = {}
	for _, img in ipairs(imgs) do
		table.insert(colors, img.ImageColor3)
	end
	return colors
end
local function Apply_Colors(imgs, cols)
	for i, img in ipairs(imgs) do
		img.ImageColor3 = cols[i]
	end
end
local function Apply_Color(imgs, col)
	for i, img in ipairs(imgs) do
		img.ImageColor3 = col
	end
end

--// Tween
local function Get_Initial_Size(b)
	return b.Size
end

local function Get_Ratio_Size(initial_size, ratio)
	return UDim2.fromScale(
		initial_size.X.Scale * ratio,
		initial_size.Y.Scale * ratio
	)
end

local function Apply_Tween(b, Target_Size, Reverse)
	TS:Create(b, Reverse and Reverse_Tween or OneWay_Tween, {Size = Target_Size}):Play()
end

-- Setup Button for simple clicks 
function Buttons_Mod.Button_Setup_OnClickDown(Cons, Button, Selected, Icons, Callback_Down, Available)
	
	if Selected:IsA("TextButton") or Selected:IsA("ImageButton") then
		local Debounce_B = false
		Button.Visible = true
		local Initial_Colors = Get_Initial_Color(Icons)
		local Initial_Size = Get_Initial_Size(Button)
		local Clicked_Size = Get_Ratio_Size(Initial_Size, Click_Size_Ratio)
		
		if Callback_Down~= nil then
			table.insert(Cons, Selected.MouseButton1Down:Connect(function()
				if Available ~= nil and not Available() then 
					return 
				end
				
				if not Debounce_B and Button.Visible then
					Debounce_B = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					Apply_Color(Icons, Icon_Color_Down)
					Apply_Tween(Button, Clicked_Size, true)
					Callback_Down()
					Apply_Colors(Icons, Initial_Colors)
					Button.Size = Initial_Size
					Debounce_B = false
				end
			end))
		end
	end
end

-- Setup Button for pressed buttons
function Buttons_Mod.Button_Setup_OnPress(Cons, Button, Selected, Icons, Callback_Down, Callback_Up, Release_Event)
	if Selected:IsA("TextButton") or Selected:IsA("ImageButton") then
		local Debounce_B = false
		Button.Visible = true
		local Initial_Colors = Get_Initial_Color(Icons)
		local Initial_Size = Get_Initial_Size(Button)
		local Pressed_Size = Get_Ratio_Size(Initial_Size, Click_Size_Ratio)

		if Callback_Down~= nil then
			table.insert(Cons, Selected.MouseButton1Down:Connect(function()
				if not Debounce_B and Button.Visible then
					Debounce_B = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					Apply_Color(Icons, Icon_Color_Down)
					Apply_Tween(Button, Pressed_Size)
					Callback_Down()
				end
			end))
		end
		
		if Callback_Up ~= nil then
			
			local function Release_Handle()
				if Debounce_B then
					SE_Mod.PlaySFX(Plr, "Click_SE")
					Apply_Colors(Icons, Initial_Colors)
					Apply_Tween(Button, Initial_Size)
					Callback_Up()
					Debounce_B = false
				end
			end
			
			table.insert(Cons, Selected.MouseButton1Up:Connect(Release_Handle))
			table.insert(Cons, Selected.MouseLeave:Connect(Release_Handle))
			table.insert(Cons, Selected.InputEnded:Connect(Release_Handle))
			if Release_Event ~= nil then
				table.insert(Cons, Release_Event.Event:Connect(Release_Handle))
			end
		end
	end
end


-- Setup Button for Mouse Hover
function Buttons_Mod.Button_Setup_OnHover(Cons, Button, Selected, Icons)
	
end

return Buttons_Mod]]></ProtectedString>
								<string name="ScriptGuid">{8A011656-3EB1-4FBF-BAA4-3DC00FE731E1}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Fight_Buttons_Mod.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXDBF97316DC434A68AEFC500D636739EA">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Main_Fight_UI/Fight_Actions_Handle.server.lua
--
--  Description:
--      Server-side handler for all real-time combat actions.
--      Manages punches, blocking, dodging, stamina usage, hit-resolution,
--      force application, sounds, animations, and VFX.
--
--      Latest version includes:
--          • Unified hitbox system (players, bots, bags, mannequins)
--          • Factorized region detection & helpers
--          • Consolidated damage logic (block / dodge / direct hit)
--          • Improved regeneration handling (HP, Stamina, Block Power)
--          • Fully SecureRemote-protected strike inputs
--          • No gameplay or timing changes — behavior 100% preserved
--
--  Authors: Exclusible, Oriane, Seb
--  Last Modified: 2025-11-29 by Seb (refactor for optimization)
--  Version: V2025-09-Clean
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Modules: Utils, Channels
--          * Data_Mods_F: Animation_Mod, Sound_Mod,
--                        Stats_Manager_Mod, Fight_Params_Mod, Bots_Mod
--      - Workspace:
--          * Gameplay.Objects (Punching Bags, Manequins)
--          * Bots workspace folder (via Bots_Mod)
--      - Player Instance:
--          * Fight_Data (Health, Stamina, Block Power, Strike Power)
--          * Character (Humanoid, HRP, Head, Reset_Fight_Health_Data)
--
--  Notes:
--      - Clean refactor version (structure improved, no logic changes)
--      - All strike/block/dodge flows validated before execution
--======================================================================

----- SERVICES -----
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")

----- MODULES -----
local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Sound_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local Utils = require(RS.Modules:WaitForChild("Utils"))
local Channels = require(RS.Modules:WaitForChild("Channels"))

----- EVENTS -----
local Overhead_Display_E = Channels.SC_Remote_Events.Overhead_Display
local Punch_Hit_VFX = Channels.SC_Remote_Events.Show_Punch_Effects
local Got_Hit_Effect = Channels.SC_Remote_Events.Got_Hit_Effect
local Equipment_Strike = Channels.Bindable_Events.Equipment_Strike
local Unblocking_Strike = Channels.CS_Remote_Events.Unblocking_Strike
local Blocking_Strike = Channels.CS_Remote_Events.Blocking_Strike
local Dodging_Strike = Channels.CS_Remote_Events.Dodging_Strike
local Throwing_Strike = Channels.CS_Remote_Events.Throwing_Strike
local Toggle_Healing_Effect = Channels.CS_Remote_Events.Toggle_Healing_Effect

----- PLAYER -----
local Plr = script.Parent:FindFirstAncestorWhichIsA("Player")
local FD = Plr:WaitForChild("Fight_Data")

local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Reset_Fight_Health_Data_E = Char:WaitForChild("Reset_Fight_Health_Data")

----- FIGHT VALUES -----
local Health_V = FD:WaitForChild("Health")
local Block_Power_V = FD:WaitForChild("Block Power")
local Stam_V = FD:WaitForChild("Staminia")
local Strike_Power_V = FD:WaitForChild("Strike Power")

----- OBJECTS -----
local GymObjects = Utils.SafePath(workspace, {
	"Main_World_F", "Gameplay", "Objects", "GymObjects"
})
local Boxing_Manequins = GymObjects ~= nil and GymObjects.BoxingManequins:GetChildren() or {}
local Punching_Bags = GymObjects ~= nil and GymObjects.PunchingBags:GetChildren() or {}

local Bots_Mod = require(RS.Data_Mods_F.Bots_Mod)
local BOTS_FOLDER = Bots_Mod.getBotsWorkspaceFolder()

----- FLAGS -----
local ResetOccur = false
local ConnectionToBP = nil
local SpCon = nil
local DAMAGE_COLOR = Color3.fromRGB(170, 85, 255)
local MAX_DAMAGE_COLOR = Color3.fromRGB(244, 244, 244)
local DODGE_COLOR = Color3.fromRGB(35, 244, 68)
local HITBOX_SIZE = Vector3.new(4, 8, 4)
local OVERLAP_PARAMS = OverlapParams.new()


----------------------------------------------------------------------
-- GENERAL HELPERS
----------------------------------------------------------------------

local function Verify_Player(p)
	return p == Plr and Char ~= nil and Hum ~= nil
end

local function Has_Enough_Stam(min)
	if Stam_V.Value >= min then
		Stam_V.Value -= min
		return true
	end
	return false
end

local function ComputeHitCFrame()
	return HRP.CFrame * CFrame.new(0, 0, -3) 
end

local function QueryHitbox(filterList)
	OVERLAP_PARAMS.MaxParts = 1
	OVERLAP_PARAMS.FilterType = Enum.RaycastFilterType.Include
	OVERLAP_PARAMS.FilterDescendantsInstances = filterList

	local region = workspace:GetPartBoundsInBox(ComputeHitCFrame(), HITBOX_SIZE, OVERLAP_PARAMS)
	return (region and region[1]) or nil
end

-- NEW: unified hitbox
local function Get_Any_Hit()
	local whitelist = {}

	-- players
	for _, p in ipairs(game.Players:GetPlayers()) do
		local c = p.Character
		if c and c ~= Char then
			local hum = c:FindFirstChildWhichIsA("Humanoid")
			if hum and hum.Health > 0 then
				table.insert(whitelist, c)
			end
		end
	end

	-- bots
	for _, bot in ipairs(BOTS_FOLDER:GetChildren()) do
		table.insert(whitelist, bot)
	end

	-- bags
	for _, b in ipairs(Punching_Bags) do
		table.insert(whitelist, b)
	end

	-- mannequins
	for _, m in ipairs(Boxing_Manequins) do
		table.insert(whitelist, m)
	end

	local part = QueryHitbox(whitelist)
	if not part then return nil end

	return part:FindFirstAncestorWhichIsA("Model")
end

----------------------------------------------------------------------
-- DAMAGE HELPERS
----------------------------------------------------------------------

local function Get_Damage_Color(v)
	local c0 = Color3.new(0.2, 0.2, 0.2)
	local c1 = Color3.new(1, 0, 0)
	return c0:Lerp(c1, math.clamp(v, 0, 1))
end

local function Play_Damage_Multi_Tween(delay)
	local params = Fight_Params_Mod.Punch_Power
	local info = TweenInfo.new(params.Reload_Time, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, delay)
	Strike_Power_V.Value = params.Min_Value
	TS:Create(Strike_Power_V, info, { Value = params.Max_Value }):Play()
end

local function Get_Target_Fight_Data(c)
	local plr = game.Players:GetPlayerFromCharacter(c)
	return plr and plr:FindFirstChild("Fight_Data") or c:FindFirstChild("Fight_Data")
end

----------------------------------------------------------------------
-- BOXING DUMMY
----------------------------------------------------------------------
local function Apply_Boxing_Dummy_Effects(dummy)
	local controller = dummy:FindFirstChildWhichIsA("AnimationController")
	if not controller then return end

	local aniId = 80256702338294
	local anim = dummy:FindFirstChild(aniId .. "_Ani") or Instance.new("Animation", dummy)
	anim.Name = aniId .. "_Ani"
	anim.AnimationId = "rbxassetid://" .. aniId

	local track = controller:LoadAnimation(anim)
	track.Looped = false
	track:Play()

	Sound_Mod.PlaySFX(HRP, "Punch_Hit_SE")
end

----------------------------------------------------------------------
-- HEALING / BLOCK REGEN
----------------------------------------------------------------------

local function Fight_Data_Growth_Handle()
	repeat task.wait() until Block_Power_V:GetAttribute("Is_Blocking") ~= nil

	local tHealth, tStam, tBlock
	local function ResetTweens()
		if tHealth then tHealth:Cancel(); tHealth = nil end
		if tStam then tStam:Cancel(); tStam = nil end
	end

	local function CreateReloadTween(valueObj, maxVal, factor)
		local delta = maxVal - valueObj.Value
		local t = math.clamp(delta, 0, Fight_Params_Mod.Health.Max_Value) * factor
		local info = TweenInfo.new(t, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
		return TS:Create(valueObj, info, { Value = maxVal })
	end

	local function StartHealing()
		local HP = Fight_Params_Mod.Health
		if HP.Reloading_Active then
			tHealth = CreateReloadTween(Health_V, HP.Max_Value, HP.Reload_Time_Factor)
			tHealth:Play()
		end
		local ST = Fight_Params_Mod.Stamina
		tStam = CreateReloadTween(Stam_V, ST.Max_Value, ST.Reload_Time_Factor)
		tStam:Play()
	end

	Block_Power_V.AttributeChanged:Connect(function(attr)
		if attr == "Is_Blocking" then
			ResetTweens()
			if Block_Power_V:GetAttribute("Is_Blocking") then
				StartHealing()
			end
		end
	end)

	if ResetOccur then
		Block_Power_V.Value = Fight_Params_Mod.Block_Power.Max_Value
		if tBlock then tBlock:Cancel(); tBlock = nil end
		return
	end

	local prev = Block_Power_V.Value
	if ConnectionToBP then
		ConnectionToBP:Disconnect()
	end

	ConnectionToBP = Block_Power_V.Changed:Connect(function()
		local last = prev
		prev = Block_Power_V.Value

		if Block_Power_V.Value < Fight_Params_Mod.Block_Power.Max_Value and Block_Power_V.Value < last then
			if tBlock then tBlock:Cancel(); tBlock = nil end
			if ResetOccur then
				Block_Power_V.Value = Fight_Params_Mod.Block_Power.Max_Value
				return
			end

			if SpCon then
				task.cancel(SpCon)
				Block_Power_V:SetAttribute("Is_Buffering", false)
			end

			Block_Power_V:SetAttribute("Is_Buffering", true)
			SpCon = task.spawn(function()
				task.wait(6)
				Block_Power_V:SetAttribute("Is_Buffering", false)
				local max = Fight_Params_Mod.Block_Power.Max_Value
				local time = math.clamp((max - Block_Power_V.Value) * 0.2667, 0.2667, 8)
				local info = TweenInfo.new(time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)

				tBlock = TS:Create(Block_Power_V, info, { Value = max })
				tBlock:Play()
				tBlock.Completed:Wait()
				tBlock = nil
			end)
		end
	end)

	Reset_Fight_Health_Data_E.Event:Connect(function()
		task.spawn(function()
			task.wait(3)
			ResetOccur = false
		end)

		ResetOccur = true
		if tBlock then tBlock:Cancel(); tBlock = nil end
		ResetTweens()

		Health_V.Value = Fight_Params_Mod.Health.Max_Value
		Stam_V.Value = Fight_Params_Mod.Stamina.Max_Value
		Block_Power_V.Value = Fight_Params_Mod.Block_Power.Max_Value
	end)
end
Fight_Data_Growth_Handle()

----------------------------------------------------------------------
-- DODGE
----------------------------------------------------------------------
Utils.SecureRemote(
	Dodging_Strike,
	function(P)
		local req = Fight_Params_Mod.Stamina.Min_To_Dodge
		if Verify_Player(P) and Has_Enough_Stam(req) then
			Sound_Mod.PlaySFX(HRP, "Missed_SE")
			Stam_V:SetAttribute("Is_Dodging", true)
			task.wait(0.5)
			Stam_V:SetAttribute("Is_Dodging", false)
		end
	end,
	{},
	{ 
		AllowMissingArgs = true, 
		MaxBurst = 5, 
		RateLimit = 10, 
		PunishThreshold = 50 
	}
)

----------------------------------------------------------------------
-- BLOCKING
----------------------------------------------------------------------
Blocking_Strike.OnServerEvent:Connect(function(player)
	if Verify_Player(player) and Block_Power_V.Value > 0 then
		Block_Power_V:SetAttribute("Is_Blocking", true)
		Toggle_Healing_Effect:FireClient(player, true)
	end
end)

Unblocking_Strike.OnServerEvent:Connect(function(P)
	if Verify_Player(P) then
		Block_Power_V:SetAttribute("Is_Blocking", false)
		Toggle_Healing_Effect:FireClient(P, false)
	end
end)

----------------------------------------------------------------------
-- MAIN PUNCH HANDLER
----------------------------------------------------------------------
Utils.SecureRemote(
	Throwing_Strike,

	function(P, Strike_Key, Dir)
		local req = Fight_Params_Mod.Stamina.Min_To_Hit

		if not (Verify_Player(P) and HRP and Animation_Mod.Player_Owns_Strike_Key(P, Strike_Key) and Has_Enough_Stam(req)) then
			return
		end

		-- unified hitbox
		local hitModel = Get_Any_Hit()

		local strikeData = Animation_Mod.Get_Strike_Combo_Data(Strike_Key)
		local dmgMulti = Strike_Power_V.Value
		Play_Damage_Multi_Tween(strikeData["Time Length"])

		local base = strikeData["Damage"]
		local punchPower = math.round(base * dmgMulti)

		Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Strikes", 1)
		Plr:SetAttribute("Did_Punch_Last", strikeData["Punch"])

		-- HIT?
		if hitModel then

			local fd = Get_Target_Fight_Data(hitModel)

			------------------------------------------------------------------
			-- HIT PLAYER
			------------------------------------------------------------------
			if fd then
				local H = fd["Health"]
				local BP = fd["Block Power"]
				local ST = fd["Staminia"]

				local function IsDodging()
					if ST:GetAttribute("Is_Dodging") then
						local tPlr = game.Players:GetPlayerFromCharacter(hitModel)
						if tPlr then
							Stats_Manager_Mod.Add_To_Player_Stats_Data(tPlr, "Dodged Strikes", 1)
						end
						return true
					end
					return false
				end

				local function IsBlocking()
					if BP:GetAttribute("Is_Blocking") then
						BP.Value -= punchPower

						Overhead_Display_E:FireAllClients(hitModel, `-{punchPower}`, DAMAGE_COLOR)

						local tPlr = game.Players:GetPlayerFromCharacter(hitModel)
						if tPlr then Got_Hit_Effect:FireClient(tPlr) end

						if BP.Value < 0 then
							local diff = math.abs(BP.Value)
							H.Value = math.clamp(H.Value - diff, 0, 100)
							BP.Value = 0

							Sound_Mod.PlaySFX(HRP, "Punch_Hit_SE")
							Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
							Overhead_Display_E:FireAllClients(hitModel, `-{diff}`, Get_Damage_Color(dmgMulti))
						else
							Sound_Mod.PlaySFX(HRP, "Blocked_Hit_SE")
						end
						return true
					end
					return false
				end

				if IsDodging() then
					Overhead_Display_E:FireAllClients(hitModel, "Dodged", DODGE_COLOR)

				elseif IsBlocking() then
					-- nothing

				else
					H.Value = math.clamp(H.Value - punchPower, 0, 100)
					Sound_Mod.PlaySFX(HRP, "Punch_Hit_SE")
					Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)

					if dmgMulti == Fight_Params_Mod.Punch_Power.Max_Value then
						Overhead_Display_E:FireAllClients(hitModel, "Max Damage!", MAX_DAMAGE_COLOR)
					end

					Overhead_Display_E:FireAllClients(hitModel, `-{punchPower}`, Get_Damage_Color(dmgMulti))
					Punch_Hit_VFX:FireClient(Plr, hitModel)

					local tPlr = game.Players:GetPlayerFromCharacter(hitModel)
					if tPlr then Got_Hit_Effect:FireClient(tPlr) end

					local tHRP = hitModel:FindFirstChild("HumanoidRootPart")
					if tHRP then
						local force = 625
						tHRP:ApplyImpulse(HRP.CFrame.LookVector * force * tHRP:GetMass())
					end
				end

				------------------------------------------------------------------
				-- HIT BAG / DUMMY
				------------------------------------------------------------------
			else
				-- dummy
				if hitModel:FindFirstChildWhichIsA("AnimationController") then
					Apply_Boxing_Dummy_Effects(hitModel)
					Equipment_Strike:Fire(Plr, hitModel)
					return
				end

				-- punching bag
				local bagHRP = hitModel:FindFirstChild("Handle") or hitModel:FindFirstChildWhichIsA("BasePart")
				if bagHRP then
					local force = 50
					bagHRP:ApplyImpulse(HRP.CFrame.LookVector * force * bagHRP:GetMass())
					Equipment_Strike:Fire(Plr, hitModel)
					Sound_Mod.PlaySFX(HRP, "Punch_Hit_SE")
					return
				end
			end

		end
	end,

	{ "string", "Vector3" },

	{
		AllowMissingArgs = true,
		MaxBurst = 15,
		RateLimit = 20,
		PunishThreshold = 50
	}
)]]></ProtectedString>
							<string name="ScriptGuid">{F54CE85E-74C6-49B0-8763-F9BFB337B9B5}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Fight_Actions_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX286B470691B24FB1A3F8715EABDC158B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Fight_Main_UI</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX0147C6215D00446792A4986C99F85A83">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--// Services
local RS = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Player:Player = Players.LocalPlayer

local Char = Player.Character or Player.CharacterAdded:Wait()

-- Modules
local Data_Mods_F = RS:FindFirstChild("Data_Mods_F")
local Bots_Mod = require(game.ReplicatedStorage.Data_Mods_F.Bots_Mod)
local BOTS_FOLDER = Bots_Mod.getBotsWorkspaceFolder()
local Vendor:Folder = RS:FindFirstChild("Vendor")
local Trove = require(Vendor:FindFirstChild("Trove"))

-- Events
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local New_Round_Display 	= Channels.Bindable_Events.New_Round_Display
local Toggle_Fight_UI 		= Channels.Bindable_Events.Toggle_Fight_UI

local RoundChangeHandler = require(script.RoundChangeHandler)
local BindThumbnail = require(script.BindThumbnail)
local WrapStats = require(script.WrapStats)
local ScoreIndicator = require(script.ScoreIndicator)

local ScreenGui = script:FindFirstAncestorWhichIsA("ScreenGui")
local Fighters_Stats_F = ScreenGui:FindFirstChild("Fighters_Stats_F")

local MainFrame = Fighters_Stats_F:FindFirstChild("Frame")
local LocalUserFrame = MainFrame:FindFirstChild("LocalUser")
local OtherUserFrame = MainFrame:FindFirstChild("OtherUser")
local ScoreFrame = Fighters_Stats_F:FindFirstChild("Scores_F")

local LocalUserThumbnail = LocalUserFrame:FindFirstChild("Thumbnail",true)
local OtherUserThumbnail = OtherUserFrame:FindFirstChild("Thumbnail",true)

local PlayerStats = WrapStats(LocalUserFrame)
local OtherStats = WrapStats(OtherUserFrame)
local ScoreIndicator = ScoreIndicator(ScoreFrame)

BindThumbnail(LocalUserThumbnail,Player)

local Debounce_UI = false
local ActiveTrove = Trove.new()

local function Disconnect_Cons()
	ActiveTrove:Clean()
end

local function Setup_Score_Indicator(Round_Wins_V, Your_Name, Other_Name, Cage_Type)
	ActiveTrove:Connect(Round_Wins_V.Changed, function()
		ScoreIndicator.Update_Score(Round_Wins_V.Value, Your_Name, Other_Name, Cage_Type)
	end)
	ScoreIndicator.Update_Score(Round_Wins_V.Value, Your_Name, Other_Name, Cage_Type)
end

local function Setup_Round_Change_Handle(Round_V)
	ActiveTrove:Connect(Round_V.Changed,function()
		if(Round_V.Value > 1)then
			task.delay(0.5,RoundChangeHandler.load,Round_V.Value)
		end
	end)
end

New_Round_Display.Event:Connect(RoundChangeHandler.load)

local function Get_Fight_Data_Vals(C_Name, root)
	local P_Char
	if root == nil then
		P_Char = game.Workspace:FindFirstChild(C_Name)
	else
		P_Char = root:FindFirstChild(C_Name)
	end
	if(P_Char ~= nil)then
		local Plr_Obj = game.Players:GetPlayerFromCharacter(P_Char)
		if(Plr_Obj ~= nil and Plr_Obj:FindFirstChild("Fight_Data") ~= nil)then
			local FD = Plr_Obj:FindFirstChild("Fight_Data")
			return FD:FindFirstChild("Health"), FD:FindFirstChild("Staminia")

		elseif(P_Char:FindFirstChild("Fight_Data") ~= nil)then
			local FD = P_Char:FindFirstChild("Fight_Data")
			return FD:FindFirstChild("Health"), FD:FindFirstChild("Staminia")
		end
	else
		if root == nil then
			return Get_Fight_Data_Vals(C_Name, BOTS_FOLDER)
		end
	end

	return nil, nil
end

local function Reset_Display()	
	ActiveTrove:Clean()
	ActiveTrove = Trove.new() 
	Fighters_Stats_F.Visible = false
	Debounce_UI = false
end

local function Get_Opponents_Names(fight_data)
	local Fight_Char_1 = fight_data:FindFirstChild("Fight_Char_1")
	local Fight_Char_2 = fight_data:FindFirstChild("Fight_Char_2")
	
	local Your_Name = Char.Name
	local Other_Name = ""
	
	
	local c1 = Fight_Char_1.Value
	local c2 = Fight_Char_2.Value


	if c1 and c2 then
		if c1.Name == Your_Name then
			Other_Name = c2.Name
		else
			Other_Name = c1.Name
		end
	elseif c1 then
		Other_Name = c1.Name
	elseif c2 then
		Other_Name = c2.Name
	else
		Other_Name = nil or ""
	end
	
	--if(Fight_Char_1.Value and Fight_Char_1.Value.Name == Your_Name)then
	--	Other_Name = Fight_Char_2.Value.Name
	--else
	--	Other_Name = Fight_Char_1.Value.Name
	--end
	
	BindThumbnail(OtherUserThumbnail,Other_Name)
	return Your_Name, Other_Name
end

local function Setup_Health_Stam_Handle(Your_Name, Other_Name)
	--Health and Stam display Tracking
	local Your_Health_V, Your_Stam_V = Get_Fight_Data_Vals(Your_Name)
	if(Your_Health_V ~= nil)then
		PlayerStats.UpdateHealth(Your_Health_V.Value)
		ActiveTrove:Connect(Your_Health_V.Changed,function()
			PlayerStats.UpdateHealth(Your_Health_V.Value)
		end)
	end

	if(Your_Stam_V ~= nil)then
		PlayerStats.UpdateStamina(Your_Stam_V.Value)

		ActiveTrove:Connect(Your_Stam_V.Changed,function()
			PlayerStats.UpdateStamina(Your_Stam_V.Value)
		end)
	end

	local Other_Health_V, Other_Stam_V = Get_Fight_Data_Vals(Other_Name)
	if(Other_Health_V ~= nil)then
		OtherStats.UpdateHealth(Other_Health_V.Value)
		ActiveTrove:Connect( Other_Health_V.Changed,function()
			OtherStats.UpdateHealth(Other_Health_V.Value)
		end)
	end

	if(Other_Stam_V ~= nil)then
		OtherStats.UpdateStamina(Other_Stam_V.Value)
		ActiveTrove:Connect( Other_Stam_V.Changed,function()
			OtherStats.UpdateStamina(Other_Stam_V.Value)
		end)
	end

	Fighters_Stats_F.Visible = true
end

Toggle_Fight_UI.Event:Connect(function(Should_Show, cage_M)
	if Should_Show then
		if not Debounce_UI then
			if(cage_M ~= nil) then 
				local Fight_Data_F = cage_M:FindFirstChild("Fight_Data_F")
				
				local Round_Count_V = Fight_Data_F:FindFirstChild("Round_Count") 
				local Your_Name, Other_Name = Get_Opponents_Names(Fight_Data_F)
				local Round_Wins_V = Fight_Data_F:FindFirstChild("Round_Wins")
				local Cage_Type = cage_M:GetAttribute("Cage_Type")
				Disconnect_Cons()
				-- Display Stamina and Health bars
				Setup_Health_Stam_Handle(Your_Name, Other_Name)
				-- Display round number
				Setup_Round_Change_Handle(Round_Count_V)
				-- Display wins
				Setup_Score_Indicator(Round_Wins_V, Your_Name, Other_Name, Cage_Type)
			end
		end
	else
		-- 🔹 Forcer toujours la fermeture
		Reset_Display()
	end
end)

]]></ProtectedString>
								<string name="ScriptGuid">{A7918075-0A8F-447E-A674-24A7DF8CFF42}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Fight_Main_UI_Handle.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX59EB886AC2554F7BABFFDBE9D354C52A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Fight_Main_UI_Handle</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX1F38F43F5D4B4B53BC696B701D39E809">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local ReplicatedStorage:ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players:Players = game:GetService("Players")
local Player:Player = Players.LocalPlayer

local Vendor:Folder = ReplicatedStorage:FindFirstChild("Vendor")


local Data_Mods_F = ReplicatedStorage:FindFirstChild("Data_Mods_F")
local Sound_Mod = require(Data_Mods_F:FindFirstChild("Sound_Mod"))

local Main_World_F = game.Workspace:WaitForChild("Main_World_F")
local Objects = Main_World_F:WaitForChild("Gameplay"):WaitForChild("Objects")
local Fight_Cages_F:Folder = Objects:WaitForChild("Fight_Cages_F")

local ScreenGui:ScreenGui = script:FindFirstAncestorWhichIsA("ScreenGui")

local Round_Change_F = ScreenGui.Round_Change_F
local Bottom_Move_F = Round_Change_F.Bottom_F
local Round_Main_F = Round_Change_F.Main_F
local Round_Main_Txt = Round_Main_F.Main_Txt

local RoundChangeHandler = {}

function RoundChangeHandler.load(Round_Num)
	local Char:Model? = Player.Character or Player.CharacterAdded:Wait()

	Sound_Mod.PlaySFX(Player, "Start_Fight_Bell_SE")
	Sound_Mod.Play_Voice_Over("Round_" .. Round_Num)

	local function Reset_Display()
		local function Get_Max_Rounds()
			local All_Cages_M = Fight_Cages_F:GetChildren()

			local function Is_Main_Cage(Cage_M)
				local FD = Cage_M:FindFirstChild("Fight_Data_F")
				if(FD ~= nil and FD:FindFirstChild("Fight_Char_1") ~= nil and 
					FD:FindFirstChild("Fight_Char_2") ~= nil)then

					local C1_V = FD:FindFirstChild("Fight_Char_1")
					local C2_V = FD:FindFirstChild("Fight_Char_2")
					if(C1_V.Value == Char or C2_V.Value == Char) then
						return true
					end
				end

				return false
			end

			for i = 1, #All_Cages_M do
				local Cage_M = All_Cages_M[i]
				if(Cage_M ~= nil and Is_Main_Cage(Cage_M))then
					local Is_Ranked = (Cage_M:GetAttribute("Cage_Type") or "") == "RANKED"	
					if(Is_Ranked ~= nil and Is_Ranked == true)then
						return 5
					end
				end
			end

			return 3
		end

		Round_Change_F.Visible = false
		Round_Main_F.Position = UDim2.new(1, 0, 0, 0)
		Bottom_Move_F.Position = UDim2.new(-1, 0, 0, 0)
		Round_Main_Txt.Text = "ROUND " .. Round_Num .. " OF " .. Get_Max_Rounds()
		Round_Main_Txt.Visible = true
		Round_Main_Txt.Position = UDim2.new(0.5, 0, 0.5, 0)
	end
	Reset_Display()

	local function Show_Main()
		Round_Change_F.Visible = true
		Bottom_Move_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		Round_Main_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		task.wait(0.25)
	end
	Show_Main()

	local function Slight_Move()
		Bottom_Move_F:TweenPosition(UDim2.new(0.125, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 1, true, nil)
		Round_Main_F:TweenPosition(UDim2.new(-0.125, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 1, true, nil)

		task.wait(1)
	end
	Slight_Move()

	local function Move_Out()
		Bottom_Move_F:TweenPosition(UDim2.new(1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		Round_Main_F:TweenPosition(UDim2.new(-1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		task.wait(0.25)	
	end
	Move_Out()

	Reset_Display()
end

return RoundChangeHandler]]></ProtectedString>
									<string name="ScriptGuid">{E050F7EA-A196-4D9D-B39E-74529F4B4F55}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">RoundChangeHandler.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4F6273C774304F9CBB868035528F68ED">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Spr = require(ReplicatedStorage.Vendor.Spr)

local DEFAULT_SIZE = UDim2.fromScale(1,1)
local DEFAULT_TEXT = "100"

local COLOR_VALUES = {
	ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(135, 255, 154)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(35, 244, 68)),
	}), 
	ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 183, 3)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(251, 133, 0)),
	}), 
	ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 89, 94)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(222, 55, 69)),
	})
}

return function(statsFrame:Frame)
	local healthBar:Frame = statsFrame:FindFirstChild("HealthBar",true)
	local staminaBar:Frame = statsFrame:FindFirstChild("StaminaBar",true)

	local healthBarTxt:TextLabel = healthBar:FindFirstChild("Txt",true)
	local healthBarLoader:ImageLabel = healthBar:FindFirstChild("Loader",true)

	local staminaBarTxt:TextLabel = staminaBar:FindFirstChild("Txt",true)
	local staminaBarLoader:ImageLabel = staminaBar:FindFirstChild("Loader",true)

	local healthGradient = healthBarLoader:FindFirstChildWhichIsA("UIGradient")

	return {
		Reset = function()
			healthBarTxt.Text = DEFAULT_TEXT
			staminaBarTxt.Text = DEFAULT_TEXT
			healthBarLoader.Size = DEFAULT_SIZE
			staminaBarLoader.Size = DEFAULT_SIZE
			if healthGradient then
				healthGradient.Color = COLOR_VALUES[1]
			end
		end,
		UpdateHealth = function(value:number)
			if not (value and type(value) == "number") then
				warn("value param is not valid", value)
				return
			end

			healthBarTxt.Text = tostring(value)
			Spr.target(healthBarLoader, 0.6, 2, {
				Size = UDim2.fromScale(value / 100, 1) 
			})

			if healthGradient then
				if value >= 60 then
					healthGradient.Color = COLOR_VALUES[1]
				elseif value <= 39 then
					healthGradient.Color = COLOR_VALUES[3]
				else
					healthGradient.Color = COLOR_VALUES[2]
				end
			end
		end,

		UpdateStamina = function(value)
			if not (value and type(value) == "number") then
				warn("value param is not valid",value)
				return
			end

			staminaBarTxt.Text = tostring(value)
			Spr.target(staminaBarLoader,0.6,2,{
				Size = UDim2.fromScale(value/100,1)
			})
		end,
	}
end]]></ProtectedString>
									<string name="ScriptGuid">{76FC3D09-C242-4EAC-812F-64E8E22EC76F}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">WrapStats.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4A82C010A8B843FF9EA12B6704894A79">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local Players:Players = game:GetService("Players")


local BOT_DEFAULT_IMG = "rbxassetid://134663290660847"

local function tryGet(player:Player)
	local success,res =  pcall(function()
		return Players:GetUserThumbnailAsync(player.UserId,Enum.ThumbnailType.HeadShot,Enum.ThumbnailSize.Size150x150)
	end)

	if not success then
		return false
	end

	return true,res
end

return function(label:ImageLabel,player:Player|string)
	if not (label and typeof(label) == "Instance" and label:IsA("ImageLabel")) then
		return
	end

	if typeof(player) ~= "Instance" then
		if typeof(player) ~= "string" then
			label.Image = BOT_DEFAULT_IMG
			return
		end
		local foundPlayer = Players:FindFirstChild(player)
		if not foundPlayer then
			label.Image = BOT_DEFAULT_IMG
			return
		end
		
		player = foundPlayer
	end

	local success,thumbnail = tryGet(player)
	local tries = 0
	while (not success and tries < 2) do
		tries += 1
		success,thumbnail = tryGet(player)
		task.wait()
	end 

	if not success then
		label.Image = BOT_DEFAULT_IMG
		return

	end

	label.Image = thumbnail
	
end]]></ProtectedString>
									<string name="ScriptGuid">{FBC89441-AE60-42B3-B585-4AABD5AE0F39}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">BindThumbnail.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6D488FD70427463198DFBA32CDBD3BB9">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local Score_Display_Mod			= require(game.ReplicatedStorage.Design.ScoreDisplay)

return function(scoreFrame:Frame)
	
	local Score_Fighter_Opponent = scoreFrame.Opponent_Wins
	local Score_Fighter_Local = scoreFrame.Local_Wins
	local Score_Total = scoreFrame.Score_Txt
	
	return {
		Update_Score = function(Round_Wins, Local_Name, Opponent_Name, Cage_Type)
			local Opponent_Score_Label, Local_Score_Label, Total_Score_Label = Score_Display_Mod.Get_Wins_Labels(
				Round_Wins, 
				Opponent_Name, 
				Local_Name, 
				Cage_Type
			)
			Score_Fighter_Opponent.Text = Opponent_Score_Label
			Score_Fighter_Local.Text = Local_Score_Label 
			Score_Total.Text = Total_Score_Label
		end,
		}
	
end
]]></ProtectedString>
									<string name="ScriptGuid">{D1E1BF99-385C-4B7A-9747-8A80C8EA7546}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">ScoreIndicator.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX140050560CA74D89AC05E6784CB61167">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Submission_UI</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXBDB2E92AC411462C99CC9A3FB1C7A34A">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--Use to track Client Clicking Speed
	--> On Click Event
		--> Sent Rate Event
	--> Reset Rate Event
	
-- Services
local RS = game:GetService("ReplicatedStorage")

-- Events
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Click_Rate_Reset		= Channels.Bindable_Events.Click_Rate_Reset
local Click_Rate_Inc		= Channels.Bindable_Events.Click_Rate_Inc
local Click_Rate_Update		= Channels.Bindable_Events.Click_Rate_Update

local Start_Time, Total_Clicks = os.time(), 0

local function Round_Rate(Raw_Rate)
	local Boosted_Rate = math.ceil(Raw_Rate * 10)
	return Boosted_Rate / 10
end

Click_Rate_Reset.Event:Connect(function()
	Start_Time, Total_Clicks = os.time(), 0
end)

Click_Rate_Inc.Event:Connect(function()
	local Current_Time = os.time()
	if(Total_Clicks == 0)then
		Start_Time = Current_Time
		Total_Clicks = 1
	else
		Total_Clicks = Total_Clicks + 1
	end
	
	local Rate = Round_Rate(Total_Clicks / (Current_Time - Start_Time))
	Click_Rate_Update:Fire(Rate)
end)]]></ProtectedString>
								<string name="ScriptGuid">{E93D7B4C-4F6F-4180-9716-01EA8C040D38}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Click_Rate_System.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXB697FAE3083148B3B40BF13F604D9451">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TS = game:GetService("TweenService")

local myPlayer = game.Players.LocalPlayer
local Char = myPlayer.Character or myPlayer.CharacterAdded:Wait()
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

-- Events
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Show_White_Fade 		= Channels.Bindable_Events.Show_White_Fade
local Remove_Submission_UI	= Channels.Bindable_Events.Remove_Submission_UI
local Submission_Minigame_Update 	= Channels.SC_Remote_Events.Submission_Minigame_Update
local Click_Rate_Reset		= Channels.Bindable_Events.Click_Rate_Reset
local Click_Rate_Inc		= Channels.Bindable_Events.Click_Rate_Inc
local Click_Rate_Update		= Channels.Bindable_Events.Click_Rate_Update
local On_Submission_Handle	= Channels.Bindable_Events.On_Submission_Handle

--UI Elements
local fightingGui = script.Parent
local mainBarFrame = fightingGui:WaitForChild("Main_Bar_F")
local myPlayerBar = mainBarFrame:WaitForChild("Player_Bar_F")
local Click_Txt = mainBarFrame:WaitForChild("Click_Txt")

local opponentThumbnail = mainBarFrame:WaitForChild("Opponent_F")
local playerThumbnail = mainBarFrame:WaitForChild("Plr_F")

local inGame = false
local clickConnection = nil
local progressConnection = nil


local function StartGame(flip : boolean, clickedEvent, P1, P2, imageIDs)
	local Update_Tween = TweenInfo.new(0.125, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
	TS:Create(Cam, Update_Tween, {FieldOfView = 70}):Play()
	
	clickConnection = UserInputService.InputBegan:Connect(function(input : InputObject, gpe : boolean)
		if gpe then	
			return
		end
		
		if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 or input.KeyCode == Enum.KeyCode.ButtonY then
			clickedEvent:FireServer()
		end
	end)
	
	progressConnection = clickedEvent.OnClientEvent:Connect(function(informationTable)
		Click_Rate_Inc:Fire()
		local range = Fight_Params_Mod.Submission_Minigame.Winning_Score - Fight_Params_Mod.Submission_Minigame.Loosing_Score 
		local progress = informationTable.gameProgress / range
		if flip then
			progress = 1 - progress
		end
		myPlayerBar.Size = UDim2.fromScale(progress, myPlayerBar.Size.Y.Scale)
		
		local FOV = math.clamp(70 - (25 * progress), 45, 70)
		TS:Create(Cam, Update_Tween, {FieldOfView = FOV}):Play()
		
	end)
	inGame = true
	
	local Submission_Char_V = clickedEvent.Parent
	local Is_Attacking = (Submission_Char_V.Value == Char)
	
	On_Submission_Handle:Fire(Is_Attacking, true)
	
	local function Display_Handle()
		Click_Rate_Reset:Fire()
		
		playerThumbnail.Image = P1 == myPlayer and imageIDs[1] or imageIDs[2]
		opponentThumbnail.Image = P1 == myPlayer and imageIDs[2] or imageIDs[1]
		
		mainBarFrame.Visible = false
		mainBarFrame.Position = UDim2.new(0.5, 0, 1.25, 0)
		mainBarFrame:TweenPosition(UDim2.new(0.5, 0, 0.975, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
		mainBarFrame.Visible = true
	end
	
	Display_Handle()
	
	local function Show_Heart_Beat_Effects()
		-- TODO check regression on sound
		while inGame do
			SE_Mod.PlaySFX(Char, "Heartbeat_SE")
			for i = 1, 2 do
				if(inGame)then
					Show_White_Fade:Fire(Color3.fromRGB(255, 75, 75))
					task.wait(0.75)
				end
			end
			task.wait(1)
		end
	end
	task.spawn(Show_Heart_Beat_Effects)
end

local function EndGame()
	if clickConnection then
		clickConnection:Disconnect()
	end

	if progressConnection then
		progressConnection:Disconnect()
	end

	inGame = false

	mainBarFrame:TweenPosition(
		UDim2.new(0.5, 0, 1.25, 0),
		Enum.EasingDirection.In,
		Enum.EasingStyle.Back,
		0.375,
		true,
		function()
			mainBarFrame.Visible = false -- 🔑 force le masquage une fois le tween terminé
		end
	)

	On_Submission_Handle:Fire(false, false)
end


Submission_Minigame_Update.OnClientEvent:Connect(function(command : string, args : {}, clicked_Event)
	if command == "START" then
		if inGame then
			warn("Player in game already")
			return
		end
		
		StartGame(args.flip, clicked_Event, args.P1, args.P2, args.imageIDs)
	elseif command == "STOP" then
		EndGame()
	end
end)


Remove_Submission_UI.Event:Connect(function()
	-- Arrêter le mini-jeu
	EndGame()

	-- Forcer reset du texte et de la barre
	Click_Rate_Reset:Fire()
end)

Click_Rate_Update.Event:Connect(function(Rate)
	Click_Txt.Text = "Start Tapping!"--" (" .. Rate .. "/s)"
end)
]]></ProtectedString>
								<string name="ScriptGuid">{4AFEFF4D-20A3-4F25-84E6-9F36C8DF861E}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Client_Submission_Handle.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXAEC28ED6A0CC4E2D960B19DEFF03CDA3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Fight_Inputs_UI</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX5DB1631D08FB4C9E83EFF9D33D1A8542">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Toggle_Key_Labels_E		= Channels.Bindable_Events.Toggle_Key_Labels
local Get_Fights_Keys			= Channels.Bindable_Functions.Get_Fights_Keys
local Get_Mobile_Buttons 		= Channels.CS_Remote_Functions.Get_Mobile_Buttons

-- UI References
local Inputs_UI = script.Parent

local KeybindsFrames = {
	Mobile = Inputs_UI:WaitForChild("Mobile_Buttons_F"),
	PC = Inputs_UI:WaitForChild("Key_Labels_F"),
	Console = Inputs_UI:WaitForChild("Key_Labels_G"),
	PS5 = Inputs_UI:WaitForChild("Key_Labels_PS5")
}

local bindsState = false

local function Get_Device()
	local device
	if UIS.TouchEnabled then
		device = "Mobile"
	else 
		if UIS.KeyboardEnabled and not UIS.GamepadEnabled then
			device = "PC"
		elseif UIS.GamepadEnabled then
			device = "Console"

			local Mapped_Key = UIS:GetStringForKeyCode(Enum.KeyCode.ButtonX)
			if(Mapped_Key ~= nil and Mapped_Key ~= "ButtonX")then
				device = "PS5"
			end
		else
			device = "Mobile"
		end
	end
	return device
end

local function UpdateKeybindsUI(state)
	if state == bindsState then
		return
	end

	bindsState = state
	local device = Get_Device()

	KeybindsFrames.Mobile.Visible = device == "Mobile" and bindsState == true
	KeybindsFrames.PC.Visible = device == "PC" and bindsState == true
	KeybindsFrames.Console.Visible = device == "Console" and bindsState == true
	KeybindsFrames.PS5.Visible = device == "PS5" and bindsState == true
end

Toggle_Key_Labels_E.Event:Connect(function(Should_Show)
	UpdateKeybindsUI(Should_Show)
end)

Get_Mobile_Buttons.OnInvoke = function()
	return KeybindsFrames.Mobile:GetChildren()
end

Get_Fights_Keys.OnInvoke = function()
	local device = Get_Device()
	
	local isMobile = device == "Mobile"
	local FrameSource = isMobile and KeybindsFrames.Mobile or KeybindsFrames[device]

	return {
		Device = device,
		
		Punch = isMobile and FrameSource:WaitForChild("Punching_B") or FrameSource:WaitForChild("Punch_F"),
		Kick = isMobile and FrameSource:WaitForChild("Kicking_B") or FrameSource:WaitForChild("Kick_F"),
		Block = isMobile and FrameSource:WaitForChild("Block_B") or FrameSource:WaitForChild("Block_F"),
		Dodge = isMobile and FrameSource:WaitForChild("Dodge_B") or FrameSource:WaitForChild("Dodge_F"),
		Takedown = isMobile and FrameSource:WaitForChild("Takedown_B") or FrameSource:WaitForChild("Takedown_F"),
		
		Damage_Bar = script.Parent:WaitForChild("Damage_Bar_F"),
		Damage_Bar_Gauge = script.Parent.Damage_Bar_F:WaitForChild("Gauge"),
		Takedown_Progress = script.Parent:WaitForChild("Takedown_Progress_F").Frame,

		Shield = Plr.Character.Fighting_UI.Main_F.Shield_F,
		Health_Bar = Plr.PlayerGui.Fight.Fight_System_UI:FindFirstChild("LocalUser", true):FindFirstChild("HealthBar", true),
		Stamina_Bar = Plr.PlayerGui.Fight.Fight_System_UI:FindFirstChild("LocalUser", true):FindFirstChild("StaminaBar", true),

		Direction = isMobile and script.Parent:WaitForChild("Mobile_Direction_F") or nil
	}
end]]></ProtectedString>
								<string name="ScriptGuid">{546922C8-545E-4071-B0AD-51D8E5FE6D63}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Inputs_Keys_Handle.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF6CBC0B40CBF4A51B374B9355C2D70CF">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[----- DEPENDENCIES -----

--// Services
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local Players:Players = game:GetService("Players")

--// Modules
local Vendor:Folder = RS:FindFirstChild("Vendor")
local Trove = require(Vendor:FindFirstChild("Trove"))

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Toggle_Takedown_Tracker	= Channels.Bindable_Events.Toggle_Takedown_Tracker

----- REFERENCES -----

--// Player and Character
local Player:Player = Players.LocalPlayer
local Char = Player.Character or Player.CharacterAdded:Wait()

--// Objects and GUI
local ScreenGui = script:FindFirstAncestorWhichIsA("ScreenGui")
local Takedown_Progress_F:Frame = ScreenGui:FindFirstChild("Takedown_Progress_F")
local Per_Data_Txt = Takedown_Progress_F.Frame.Per_Txt
local Key_Label_G = Takedown_Progress_F.Frame.Key_Label_G
local Key_Label_PS5 = Takedown_Progress_F.Frame.Key_Label_PS5
local Key_Label_PC = Takedown_Progress_F.Frame.Key_Label_PC
local Wheel = Takedown_Progress_F.Frame.Wheel
local Wheel_cursor = Takedown_Progress_F.Frame.Wheel_cursor

--// Variables
local Debounce_UI = false
local ActiveTrove = Trove.new()

local Max_Rotation_Wheel = 80
local Min_Rotation_Wheel = -80
local Rotation_Increment = 15

local function Reset_Display()	
	ActiveTrove:Clean()
	ActiveTrove = Trove.new() -- 🔹 recrée un Trove propre
	
	Takedown_Progress_F.Visible = false
	Debounce_UI = false
end


local function Setup_Takedown_Tracking_Handle(Tracking_Val)	

	local function Reset_UI()
		Takedown_Progress_F.Visible = false

		Per_Data_Txt.Text = "-"
		Per_Data_Txt.TextColor3 = Color3.fromRGB(200, 200, 200)

		Key_Label_G.Visible = false -- UserInputService.GamepadEnabled and not UserInputService.TouchEnabled
		Key_Label_PC.Visible = false -- not UserInputService.GamepadEnabled and not UserInputService.TouchEnabled
	end
	Reset_UI()

	Takedown_Progress_F.Visible = true
	
	local function Set_Up_Connections()
		local function Get_Tracker_Values()
			local Value, Your_Val, Other_Val = false, 0, 0

			for Plr_Name, Prog in next, Tracking_Val:GetAttributes() do
				if(Plr_Name == Char.Name)then
					Your_Val = Prog
				else
					Other_Val = Prog
				end
			end

			return Tracking_Val.Value, Your_Val, Other_Val
		end

		local function Update_Prog_Displays()
			local Value, Your_Val, Other_Val = Get_Tracker_Values()
			local Difference = Your_Val - Other_Val
			
			-- Update Text 
			if Difference>0 then
				Per_Data_Txt.TextColor3 = Color3.fromRGB(0, 255, 0)
				Per_Data_Txt.Text = "+"..Your_Val
			elseif Difference < 0 then
				Per_Data_Txt.TextColor3 = Color3.fromRGB(255, 0, 0)
				Per_Data_Txt.Text = "-"..Other_Val
			elseif Difference == 0 then
				Per_Data_Txt.TextColor3 = Color3.fromRGB(255, 255, 255)
				Per_Data_Txt.Text = "="
			end
			
			-- Update Wheel rotation
			
			local Wheel_Rotation = 0
			if Value then
				if Your_Val > 0 then
					Wheel_Rotation = Max_Rotation_Wheel
					local PS5 = false
					local Mapped_Key = UIS:GetStringForKeyCode(Enum.KeyCode.ButtonX)
					if (Mapped_Key ~= nil and Mapped_Key ~= "ButtonX")then
						PS5 = true
					end
					Key_Label_PS5.Visible = not UIS.TouchEnabled and UIS.GamepadEnabled and PS5
					Key_Label_G.Visible = not UIS.TouchEnabled and UIS.GamepadEnabled and not PS5
					Key_Label_PC.Visible = not UIS.TouchEnabled and not UIS.GamepadEnabled
				else 
					Wheel_Rotation = Min_Rotation_Wheel
				end
			else 
				Wheel_Rotation = math.clamp(Rotation_Increment * Difference, Min_Rotation_Wheel, Max_Rotation_Wheel)
				Key_Label_G.Visible = false 
				Key_Label_PS5.Visible = false 
				Key_Label_PC.Visible = false
			end
			Wheel.Rotation = Wheel_Rotation
			Wheel_cursor.Rotation =Wheel_Rotation
		end
		Update_Prog_Displays()

		ActiveTrove:Connect(Tracking_Val.AttributeChanged,function(Attrib_Key)
			Update_Prog_Displays()
		end)
	end
	Set_Up_Connections()

	Takedown_Progress_F.Visible = true
	Debounce_UI = true
end


Toggle_Takedown_Tracker.Event:Connect(function(Should_Show, cage_M)
	if Should_Show then
		if not Debounce_UI then
			if(cage_M ~= nil) then 
				local Fight_Data_F = cage_M:FindFirstChild("Fight_Data_F")
				local Takedown_Tracking_V = Fight_Data_F:FindFirstChild("Takedown_Track") 
				if Takedown_Tracking_V then
					Setup_Takedown_Tracking_Handle(Takedown_Tracking_V)
				end
			end
		end
	else
		-- 🔹 Forcer toujours la fermeture
		Reset_Display()
	end
end)

]]></ProtectedString>
								<string name="ScriptGuid">{1E4C4C19-2ACA-47DC-8B62-14B5F946F201}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Takedown_Tracker_Handle.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX03BB9749CB3944CB9C8EB72812FB2836">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_Teleport_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX30DADB85D53A496290692ABB3DE24A79">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS 						= game:GetService("ReplicatedStorage")
local UIS 						= game:GetService("UserInputService")
local Plr 						= game.Players.LocalPlayer
local Char 						= Plr.Character or Plr.CharacterAdded:Wait()
local PD 						= Plr:WaitForChild("Player_Data")
local Fight_Prompts_V 			= PD:WaitForChild("Fight Prompts")

-- Modules
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod 					= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local PlayerUtils 				= require(game.ReplicatedStorage.Modules.PlayerUtils)
local Fight_Params_Mod 			= require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local MenuButtons_Mod 			= require(RS.Design.MenuButtons)
local Elo_Mod 					= require(Data_Mods_F:WaitForChild("Elo_Mod"))

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Transition_Hole_UI 		= Channels.Bindable_Events.Transition_Hole_UI
local Fight_Spawn_Notification 	= Channels.SC_Remote_Events.Fight_Spawn_Notification

local Hide_B = script.Parent.Hide_B
local Main_F = script.Parent.Main_F
local Fight_B = Main_F.Fight_B
local Player_F = Main_F.Player_F
local Icon_F = Player_F.Icon_F
local Player_Img = Icon_F.Player_Img
local Rank_F = Player_F.Rank_F
local Rank_Img = Rank_F.Rank_Img
local Rank_Txt = Rank_F.Rank_Txt
local Player_Name = Player_F.Player_Name
local Arena_Tag = Main_F.Arena_Tag

local Debounce_UI = false

local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	
	table.clear(Cons)
end

local function Is_Player_Fighting()
	local Is_Fighting = Char:GetAttribute("Is_Fighting")
	local Intro_Running = workspace:GetAttribute("FIGHT_INTRO") 
	if(Is_Fighting ~= nil and Is_Fighting == true) or (Intro_Running ~= nil and Intro_Running == true) then
		return true
	end

	return false
end

local Y_Pos_Data = {
	[true] = {
		[Main_F] = 0.525,
		[Hide_B] = 0.5875
	},
	
	[false] = { -- PC and Console Showing
		[Main_F] = 0.8625,
		[Hide_B] = 0.925
	},
}

local function Get_Y_Pos(B)
	return Y_Pos_Data[UIS.TouchEnabled][B]
end

local function Remove_Fight_Spawn()
	Disconnect_Cons()

	Main_F:TweenPosition(UDim2.new(-0.2, 0, Get_Y_Pos(Main_F), 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.25, true, nil)
	Hide_B:TweenPosition(UDim2.new(-0.15, 0, Get_Y_Pos(Hide_B), 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.25, true, nil)
end

local function Show_Fight_Spawn(Invite_Data)
	local function Reset_Display()
		Disconnect_Cons()
		
		Main_F.Position = UDim2.new(-0.2, 0, Get_Y_Pos(Main_F), 0)
		Hide_B.Position = UDim2.new(-0.15, 0, Get_Y_Pos(Hide_B), 0)
		
		Hide_B.Visible = false
		Main_F.Visible = false
	end
	Reset_Display()
	
	local function Update_Player_Display()
		local Rank_Col = Invite_Data['Rank Color'] or Color3.fromRGB(170, 170, 127)
		
		Player_Img.Image = Invite_Data['Player Icon'] or "rbxassetid://134663290660847"
		Rank_Img.Image = Invite_Data['Rank Icon'] or "rbxassetid://89194867048049"
		Rank_Img.ImageColor3 = Rank_Col
		Rank_Txt.Text = Invite_Data['Rank Value'] or "0"
		Rank_Txt.TextColor3 = Rank_Col
		Player_Name.Text = Invite_Data['Name'] or "Player"
		
		Main_F.UIStroke.Color = Invite_Data['Ranked_Fight'] and Color3.fromRGB(172, 0, 0) or Color3.fromRGB(170, 255, 0)
		Arena_Tag.Visible = Invite_Data['Ranked_Fight']
	end
	Update_Player_Display()
	
	local function Button_Handle()
		SE_Mod.PlaySFX(Plr, "Click_SE")
		
		local function Move_To_Fight_Spawn()
			Transition_Hole_UI:Fire(Color3.fromRGB(50, 50, 50))
			task.wait(0.5)
			
			local Spawn_CF = Invite_Data['Spawn_Location']
			if(Char ~= nil and Spawn_CF ~= nil and Is_Player_Fighting() == false and 
				Char:FindFirstChild("HumanoidRootPart") ~= nil)then
				
				local HRP = Char:FindFirstChild("HumanoidRootPart")
				HRP.CFrame = Spawn_CF
			end
		end
		
		MenuButtons_Mod.Setup_Base_Button(
			Cons, 
			Fight_B, 
			function() 
				Remove_Fight_Spawn()
				Move_To_Fight_Spawn()
			end,  
			Fight_B:FindFirstChild("Selected"))
		
		MenuButtons_Mod.Setup_Colored_Button(
			Cons, 
			Hide_B,
			Color3.new(1, 0, 0),
			Remove_Fight_Spawn , 
			Hide_B:FindFirstChild("Selected"))
	end
	Button_Handle()

	local function Display_UI()
		Main_F:TweenPosition(UDim2.new(0.025, 0, Get_Y_Pos(Main_F), 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.375, true, nil)
		Hide_B:TweenPosition(UDim2.new(0.075, 0, Get_Y_Pos(Hide_B), 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.375, true, nil)
		
		Main_F.Visible = true
		Hide_B.Visible = true
	end
	Display_UI()
	
	local function Removal_Handle()
		--local Char_V1 = Invite_Data['Char_V1']
		--local Main_Char_V = Invite_Data['Main_Char_V'] or Char_V1
		--if(Char_V1 ~= nil)then
		--	table.insert(Cons, Char_V1.Changed:Connect(function()
		--		if((Main_Char_V == Char_V1 and Char_V1.Value == nil) or 
		--			(Main_Char_V ~= Char_V1 and Char_V1.Value ~= nil))then

		--			Remove_Fight_Spawn()
		--		end
		--	end))
		--end

		--local Char_V2 = Invite_Data['Char_V2']
		--if(Char_V2 ~= nil)then
		--	table.insert(Cons, Char_V2.Changed:Connect(function()
		--		if((Main_Char_V == Char_V2 and Char_V2.Value == nil) or 
		--			(Main_Char_V ~= Char_V2 and Char_V2.Value ~= nil))then

		--			Remove_Fight_Spawn()
		--		end
		--	end))
		--end
		
		local Main_Char_V = Invite_Data['Main_Char_V']
		if(Main_Char_V ~= nil) then
			table.insert(Cons, Main_Char_V.Changed:Connect(function()
				if(Main_Char_V.Value==nil) then
					Remove_Fight_Spawn()
				end
			end))
		end

		local Active_V = Invite_Data['Active_V']
		if(Active_V ~= nil)then
			table.insert(Cons, Active_V.Changed:Connect(function()
				if(Active_V.Value == true)then
					Remove_Fight_Spawn()
				end
			end))
		end

		local Char = Plr.Character
		if(Char ~= nil)then
			table.insert(Cons, Char.AttributeChanged:Connect(function(Attrib_Name)
				if(Attrib_Name ~= nil and Attrib_Name == "Is_Fighting" and Is_Player_Fighting())then
					Remove_Fight_Spawn()
				end
			end))
		end
		
		table.insert(Cons, workspace.AttributeChanged:Connect(function(att_name)
			if(att_name == "FIGHT_INTRO" and workspace:GetAttribute("FIGHT_INTRO") == true)then
				Remove_Fight_Spawn()
			end
		end))

	end
	Removal_Handle()
end

Fight_Spawn_Notification.OnClientEvent:Connect(function(Ignore_Plr, Invitation_Data)
	if(Debounce_UI == false and Fight_Prompts_V ~= nil and Fight_Prompts_V.Value == true and 
		Is_Player_Fighting() == false and Ignore_Plr ~= nil and Ignore_Plr ~= Plr)then
		local Total_Wins = PlayerUtils.GetPlayerVal(Plr, "Total Wins")
		if not Invitation_Data['Ranked_Fight'] 
			or (Invitation_Data['Ranked_Fight'] 
				and Total_Wins and Total_Wins.Value >= Fight_Params_Mod.Ranked_Arena_Required_Wins 
				and Elo_Mod.Adjacent_Elo_Ranks(Plr, Ignore_Plr)) then
			
			Debounce_UI = true
			Show_Fight_Spawn(Invitation_Data)

			task.wait(5)

			Debounce_UI = false
		end
	end
	
	
end)]]></ProtectedString>
							<string name="ScriptGuid">{7ADC8090-20D5-426A-B7EA-B72CCAD9F4A1}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Fight_Teleport_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX1724FF36A11F4C4A99BF3253D6A93E85">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Staminia_Down_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX17A92F7877184443B4A4105C8AD922BE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local UIS = game:GetService("UserInputService")
local TS = game:GetService("TweenService")

local Plr = game.Players.LocalPlayer
local FD = Plr:WaitForChild("Fight_Data")
local Stam_V = FD:WaitForChild("Staminia")
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Cam_Shake_Mod = require(Data_Mods_F:WaitForChild("CameraShaker"))
local Sound_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

-- UI References
local Main_F = script.Parent.Damage_F
local Backdrop_F = Main_F.Backdrop_F
local Stam_Txt = Main_F.Stam_Txt
local Key_Txt = Main_F.Key_Txt

local Is_Being_Shown = false
local Tween_Trans = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Out = TweenInfo.new(0.375, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)

local function Special_Txt(text, color)
	return string.format(
		'<font color="rgb(%d, %d, %d)">%s</font>',
		color.R * 255, color.G * 255, color.B * 255, text
	)
end


local function Cam_Shake()
	local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
		Cam.CFrame = Cam.CFrame * shakeCf
	end)
	return CS
end
local CamShake = Cam_Shake()

local function Remove_Display()
	CamShake:StopSustained(0.375)
	
	local Tabs = Backdrop_F:GetChildren()
	for i = 1, #Tabs do
		local T = Tabs[i]
		if(T ~= nil)then
			TS:Create(T, Tween_Out, {BackgroundTransparency = 1}):Play()
		end
	end

	TS:Create(Stam_Txt, Tween_Out, {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
	TS:Create(Key_Txt, Tween_Out, {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
	Is_Being_Shown = false
end

local function Show_Display()
	
	Sound_Mod.Play_Voice_Over("Low_Health")
	
	local function Reset_Handle()		
		Stam_Txt.TextTransparency = 1
		Stam_Txt.TextStrokeTransparency = 1
		Key_Txt.TextTransparency = 1
		Key_Txt.TextStrokeTransparency = 1
		
		if(UIS.GamepadEnabled)then
			Key_Txt.Text = "Press & Hold " .. Special_Txt("L2", Color3.fromRGB(35, 244, 68)) .. " to Heal!"
		elseif(UIS.TouchEnabled)then
			Key_Txt.Text = "Press & Hold the Button to Heal!"
		else
			Key_Txt.Text = "Press & Hold " .. Special_Txt("Space", Color3.fromRGB(35, 244, 68)) .. " to Heal!"
		end
		CamShake:StopSustained(0)
	end
	Reset_Handle()
	
	local function Show_Backdrop()
		local Tabs = Backdrop_F:GetChildren()
		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil)then
				T.BackgroundTransparency = 1
				TS:Create(T, Tween_Trans, {BackgroundTransparency = 0.375}):Play()
			end
		end
		
		TS:Create(Stam_Txt, Tween_Trans, {TextTransparency = 0, TextStrokeTransparency = 0}):Play()
		TS:Create(Key_Txt, Tween_Trans, {TextTransparency = 0, TextStrokeTransparency = 0}):Play()
		
		Sound_Mod.PlaySFX(Plr, "Heartbeat_SE")
		
		CamShake:Start()
		CamShake:ShakeSustain(Cam_Shake_Mod.Presets.RoughDriving)
		Is_Being_Shown = true
	end
	Show_Backdrop()
end

Stam_V.Changed:Connect(function()
	if(Stam_V.Value < 20 and Is_Being_Shown == false)then
		--Show
		Show_Display()
	elseif(Stam_V.Value >= 20 and Is_Being_Shown)then
		--Remove
		Remove_Display()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{20A08885-FB6B-4F4B-8D9E-E73337D670A0}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Staminia_Effect_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXDFC1EF78762B4AD9942F35E9731DD500">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_Result_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXCBC4DCC3C8394D838D845AF878521502">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")

local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local PG = Plr:WaitForChild("PlayerGui")
local PD = Plr:WaitForChild("Player_Data")
local Elo_V = PD:WaitForChild("Elo")
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Utils = require(game.ReplicatedStorage.Modules.Utils)
local Global_Params_Mod = require(game.ReplicatedStorage.Data_Mods_F.Global_Params_Mod)


-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Toggle_Reset 				= Channels.Bindable_Events.Toggle_Reset
local Toggle_Side_Buttons 		= Channels.Bindable_Events.Toggle_Side_Buttons
local Close_Fight_Result 		= Channels.Bindable_Events.Close_Fight_Result
local Is_Chatbox_Typing			= Channels.Bindable_Functions.Is_Chatbox_Typing
local Fight_Data_Result			= Channels.SC_Remote_Events.Fight_Data_Result

-- UI References
local Main_F = script.Parent.Main_F
local Top_Data_F = Main_F.Top_Data_F
local Main_Data_F = Main_F.Data_Results_F
local Elo_Progress_F = Main_F.Elo_Progress_F
local Exit_B = Main_F.Exit_B

local Debounce_UI = false
local Debounce_C = false
local Debounce_E = false

local Tween_Cam = TweenInfo.new(0.75, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local Player_Thumbnail_Data = {
	
}
local function Get_Player_Thumbnail(ID)
	if(Player_Thumbnail_Data[ID] ~= nil)then
		return Player_Thumbnail_Data[ID]
	else
		local Type = Enum.ThumbnailType.HeadShot
		local Size = Enum.ThumbnailSize.Size420x420
		
		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				Data = game.Players:GetUserThumbnailAsync(ID, Type, Size)
			end)
			
			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end
		
		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				Player_Thumbnail_Data[ID] = D
				return D
			end
		end
		
		return "rbxassetid://100127687172105"
	end
end

local function Toggle_UI(Show)
	local UI_Paths = {
		"Fight/Fight_Teleport_UI",
		--"Player/Tool_Select_UI",
		--"Fight/Side_Button_UI",
		"System/Player_List_UI"
	}

	local function getUIByPath(root, path)
		local current = root
		for segment in string.gmatch(path, "[^/]+") do
			current = current:FindFirstChild(segment)
			if not current then return nil end
		end
		return current
	end

	for _, path in ipairs(UI_Paths) do
		local ui = getUIByPath(PG, path)
		if ui then
			ui.Enabled = Show
		else
			warn("[FightResult] UI not found:", path)
		end
	end
end


local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.375, true, nil)
	
	wait(0.375)
	
	local Old_Blur = game.Lighting:FindFirstChild("Result_Blurr")
	if(Old_Blur ~= nil)then
		Old_Blur:Destroy()
	end
	
	if(Cam.FieldOfView == 40)then
		TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	end
	
	Toggle_Side_Buttons:Fire(true)
	Toggle_UI(true)
	Toggle_Reset:Fire(true)
	Main_F.Visible=false
	Debounce_C = false
	Debounce_E = false
	Debounce_UI = false
end

local function Display_UI(Fight_Data)
	local function Reset_Display()
		Disconnect_Cons()
		Cam.FieldOfView = 70
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 1.5, 0)
		
		local Old_Blur = game.Lighting:FindFirstChild("Result_Blurr")
		if(Old_Blur ~= nil)then
			Old_Blur:Destroy()
		end
		
		Toggle_UI(false)
	end
	Reset_Display()
	
	local function Update_Display_Data()
		local function Update_Top_Bar_Info()
			if string.len(Fight_Data['Winner']['DisplayName']) > 30 then
				Fight_Data['Winner']['DisplayName']  = "Bot"
			end
			if string.len(Fight_Data['Winner']['Name']) > 30 then
				Fight_Data['Winner']['Name']  = "Bot"
			end
			Top_Data_F.Winner_Data_F.Player_Name_Txt.Text = Fight_Data['Winner']['DisplayName'] 
			Top_Data_F.Winner_Data_F.Player_Display_Name_Txt.Text = Fight_Data['Winner']['Name'] 
			Top_Data_F.Winner_Data_F.Plr_Img_F.Plr_Img.Image = Get_Player_Thumbnail(Fight_Data['Winner']['ID'])
			
			if string.len(Fight_Data['Loser']['DisplayName']) > 30 then
				Fight_Data['Loser']['DisplayName']  = "Bot"
			end
			if string.len(Fight_Data['Loser']['Name']) > 30 then
				Fight_Data['Loser']['Name']  = "Bot"
			end
			Top_Data_F.Loser_Data_F.Player_Name_Txt.Text = Fight_Data['Loser']['DisplayName'] 
			Top_Data_F.Loser_Data_F.Player_Display_Name_Txt.Text = Fight_Data['Loser']['Name']
			Top_Data_F.Loser_Data_F.Plr_Img_F.Plr_Img.Image = Get_Player_Thumbnail(Fight_Data['Loser']['ID'])
			
			Top_Data_F.Score_Txt.Text = Fight_Data['Winner']['Wins'] .. " - " .. Fight_Data['Loser']['Wins']	
		end
		Update_Top_Bar_Info()
		
		local function Update_Main_Data()
			local function Update_Tab(Tab)
				local Key = string.gsub(Tab.Name, "_F", "")
				Key = string.gsub(Key, "_", " ")
				
				Tab.Winner_Data_Txt.Text = Fight_Data['Winner'][Key] .. "" or "0 / 0"
				Tab.Loser_Data_Txt.Text = Fight_Data['Loser'][Key] .. "" or "0 / 0"
			end 
			
			local Tabs = Main_Data_F:GetChildren()
			for i = 1, #Tabs do
				if(Tabs[i] ~= nil and Tabs[i]:IsA("Frame"))then
					Update_Tab(Tabs[i])
				end
			end
		end
		Update_Main_Data()
	end
	Update_Display_Data()
	
	local function Display_Elo_Data()
		Elo_Progress_F.Visible = true 

		local Current_Elo_Data = Elo_Mod.Get_Player_Rank_Data(Plr)
		local Next_Elo_Data = Elo_Mod.Get_Next_Rank_Data(Current_Elo_Data['Index'])
		local Tween_Prog_Bar = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 1)

		Elo_Progress_F.Current_Elo_F.Elo_Txt.Text = Utils.NumToString(Elo_V.Value) .. ""
		Elo_Progress_F.Current_Elo_F.Elo_Img.Image = Current_Elo_Data['Icon']
		Elo_Progress_F.Current_Elo_F.Elo_Img.ImageColor3 = Current_Elo_Data['Color']

		Elo_Progress_F.Next_Elo_F.Elo_Txt.Text = Utils.NumToString(Next_Elo_Data['Elo Range'].Min) .. ""
		Elo_Progress_F.Next_Elo_F.Elo_Img.Image = Next_Elo_Data['Icon']
		Elo_Progress_F.Next_Elo_F.Elo_Img.ImageColor3 = Next_Elo_Data['Color']

		Elo_Progress_F.Prog_Bar_F.Bar_F.UIGradient.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Next_Elo_Data['Color']),
			ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))
		}
		Elo_Progress_F.Prog_Bar_F.Bar_F.Size = UDim2.new(0, 0, 1, 0)

		local Dif = math.clamp(Elo_V.Value / Next_Elo_Data['Elo Range'].Min, 0, 1)
		TS:Create(Elo_Progress_F.Prog_Bar_F.Bar_F, Tween_Prog_Bar, {Size = UDim2.new(Dif, 0, 1, 0)}):Play()
	end

	Display_Elo_Data()
	
	local function Exit_Handle()
		local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
		Exit_B.Size = UDim2.new(0.075, 0, 0.1, 0)
		
		table.insert(Cons, Exit_B.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				SE_Mod.PlaySFX(Plr, "Hover_SE")
				Debounce_E = false
			end
		end))
		
		table.insert(Cons, Exit_B.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				SE_Mod.PlaySFX(Plr, "Click_SE")
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.05625, 0, 0.075, 0)}):Play()
				
				Remove_UI()
				
				wait(0.25)
				Debounce_C = false
			end
		end))	
		
		table.insert(Cons, UIS.InputBegan:Connect(function(input, GPE)
			if(Debounce_C == false and input.KeyCode == Enum.KeyCode.Space and 
				Is_Chatbox_Typing:Invoke() == false)then
				
				Debounce_C = true
				SE_Mod.PlaySFX(Plr, "Click_SE")
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.05625, 0, 0.075, 0)}):Play()

				Remove_UI()

				wait(0.25)
				Debounce_C = false
			end
		end))	
	end
	Exit_Handle()
	
	local function Display_Main_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.4875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
		
		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Result_Blurr"
		
		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
		SE_Mod.Play_Voice_Over("End_Of_Fight")
		
		Debounce_C = false
		Debounce_E = false
		Debounce_UI = true
	end
	Display_Main_UI()
	
	--Auto Remove after 10 Seconds
	for i = 1, 40 do
		task.wait(0.25)
		if(Debounce_UI == false)then
			return
		end
	end
	
	if(Debounce_UI == true)then
		Remove_UI()
	end
end

local function Display_Tournament_UI(Winner_Char)
	local Main_Tournament_F = script.Parent.Main_Tournament_F
	Main_Tournament_F.Visible = true
	local Text = Main_Tournament_F:FindFirstChild("Winner_Looser_Txt", true)
	local Gradient = Main_Tournament_F:FindFirstChild('UIGradient', true)
	local ColorSeq = Gradient.Color
	local Winner_Col = ColorSeq.Keypoints[1].Value
	local Looser_Col = Color3.new(0.741176, 0.0196078, 0.0196078)
	
	-- TODO: Display UI for tournament

	-- apply Winner or Looser style and wordings (Char == Winning_Char)
	Text.Txt = "WINNER" and Char == Winner_Char or "LOOSER"
	ColorSeq.Keypoints[1] = Winner_Char == Char and Winner_Col or Looser_Col
	Main_Tournament_F:FindFirstChild('UIGradient', true).Color = ColorSeq
	-- apply Blur
	-- connect to close button
	-- get Total League Points and New Ranking and display it
	-- close UI after 10 seconds
	
	task.wait(10)
	Main_Tournament_F.Visible = false
end

local function Play_Winning_Outro(Winner_Char)
	if (Winner_Char == Char) then
		local Intro_Animation_Key = Plr:FindFirstChild("Player_Data"):FindFirstChild("Fight Outro Key").Value
		Animation_Mod.Play_Emote_Track_From_Key(Plr, Hum, Intro_Animation_Key, true)
	end
end


Fight_Data_Result.OnClientEvent:Connect(function(Fight_Data, Winner_Char)
	
	Play_Winning_Outro(Winner_Char)
	
	if(Debounce_UI == false)then
		if Utils.GetServerGameMode() == Global_Params_Mod.Server_Mode.TOURNAMENT then
			Display_Tournament_UI(Winner_Char)
			
		else 
			if not Plr:GetAttribute("IsTutorialRunning") then
				Display_UI(Fight_Data)
			end
		end
	end
end)

Close_Fight_Result.Event:Connect(function()
	if(Debounce_UI)then
		Remove_UI()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{EF42AEC8-4FB6-4A09-A3DD-CB909F82C1C5}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Fight_Result_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX803F1E14B72B443B9EEF0A9F464CACC0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Damage_Effect_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX8682FB4C55754AE789F65D1953665DA6">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Cam_Shake_Mod = require(Data_Mods_F:WaitForChild("CameraShaker"))
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Round_Result_Win 		= Channels.SC_Remote_Events.Round_Result_Win
	
local FD = Plr:WaitForChild("Fight_Data")
local Health_V = FD:WaitForChild("Health")

-- UI References
local Main_F = script.Parent.Damage_F
local Knockout_Tab = script.Parent.Result_F

local Tween_Trans = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0.25)
local Tween_Cons = {}
local function Stop_Tweens()
	for i = 1, #Tween_Cons do
		local T = Tween_Cons[i]
		if(T ~= nil)then
			T:Cancel()
		end
	end
	
	table.clear(Tween_Cons)
end

local function Show_Effect()
	local Tabs = Main_F:GetChildren()
	if(#Tween_Cons > 0)then
		Stop_Tweens()
	end
	
	for i = 1, #Tabs do
		local T = Tabs[i]
		if(T ~= nil)then
			T.BackgroundTransparency = 0.575
			local Tab_T = TS:Create(T, Tween_Trans, {BackgroundTransparency = 1})
			table.insert(Tween_Cons, Tab_T)
			Tab_T:Play()
		end
	end
	
end

local Prev_V = Health_V.Value
Health_V.Changed:Connect(function()
	local Current_V = Health_V.Value
	if(Current_V < Prev_V)then
		Show_Effect()
	end
	
	Prev_V = Current_V
end)

local function Cam_Shake()
	local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
		Cam.CFrame = Cam.CFrame * shakeCf
	end)
	return CS
end
Cam_Shake()


local function Display_Knockout_Effects(Was_Knockout)
	while game.Workspace:GetAttribute("FIGHT_INTRO") ~= nil do
		task.wait()
	end
	
	local function Configure_Display()
		local Img = Knockout_Tab:FindFirstChild("Img")
		local Txt = Knockout_Tab:FindFirstChild("Txt")
		
		Knockout_Tab.Visible = false
		Knockout_Tab.Position = UDim2.new(0.5, 0, -0.5, 0)
		
		if(Was_Knockout)then
			Img.ImageColor3 = Color3.new(1, 0, 0)
			Txt.Text = "Knockout!"
			Txt.TextStrokeColor3 = Color3.new(1, 0, 0)
			
			Sound_Mod.Play_Voice_Over("Knockout")
		else
			Img.ImageColor3 = Color3.fromRGB(0, 170, 255)
			Txt.Text = "Submission KO!"
			Txt.TextStrokeColor3 = Color3.fromRGB(0, 170, 255)
		end
		
		Knockout_Tab.Visible = true
		Knockout_Tab:TweenPosition(UDim2.new(0.5, 0, 0.3, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.375, true, nil)
	end
	Configure_Display()
	
	local function Play_Cash_VFX()
		local Char = Plr.Character
		if(Char ~= nil and Char:FindFirstChild("HumanoidRootPart") ~= nil)then
			local HRP = Char:FindFirstChild("HumanoidRootPart")
			local Cash_VFX = HRP:FindFirstChild("Cash_VFX")
			
			if(Cash_VFX ~= nil)then
				local All_PE = Cash_VFX:GetChildren()
				for i = 1, #All_PE do
					local PE = All_PE[i]
					if(PE ~= nil and PE:IsA("ParticleEmitter"))then
						PE:Emit(10)
					end
				end
			end
		end
	end
	Play_Cash_VFX()
	
	task.wait(3)
	Knockout_Tab:TweenPosition(UDim2.new(0.5, 0, -0.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.25, true, nil)
end

Round_Result_Win.OnClientEvent:Connect(Display_Knockout_Effects)]]></ProtectedString>
							<string name="ScriptGuid">{A3991B6B-C091-43BC-9E40-9962C6B7F366}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Damage_Effect_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX802A3C95C41345A1AB99CF33921DA87C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Tutorial</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXBB8BD2BCDFCC4194A94649E3D1F1BB6C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tour_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX8F8273A6D5514C56B23E40CE3A6FF6F9">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[
--======================================================================
--  File: StarterGui/Tutorial_UI/Tutorial_UI_Handle.client.lua
--
--  Description:
--      Controls the tutorial user interface (UI). Displays tutorial
--      messages with title and text, handles "OK" button interactions
--      to progress through steps, and toggles the tutorial/commands
--      panels based on events received.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-09-30 by Oriane
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/End_Tutorial
--          * Channels_F/Bindable_F/Events/Display_Tuto_Message
--          * Channels_F/Bindable_F/Events/Next_Tutorial_Step
--          * Channels_F/Bindable_F/Events/Toggle_Tutorial_OK_Button
--          * Channels_F/Bindable_F/Events/Toggle_Commands_Panel
--      - StarterGui:
--          * Tuto_Frame
--          * Tuto_Message
--          * Commands_Frame
--          * Tuto_OK (Button inside Tuto_Message)
--      - Roblox Services:
--          * None beyond defaults (UI handling)
--
--  Notes:
--      - Displays dynamic tutorial messages sent from Tutorial_Handle
--      - "OK" button progresses to next step via Next_Tutorial_Step
--      - Commands panel visibility toggles tutorial message display
--      - Cleanly hides UI when tutorial ends
--
--======================================================================

-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer

-- Modules
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes

local Close_Tutorial 			= Channels.Bindable_Events.Close_Tutorial
local Display_Tuto_Message 		= Channels.Bindable_Events.Display_Tuto_Message
local Display_Tuto_Indicator	= Channels.Bindable_Events.Display_Tuto_Indicator
local Next_Tutorial_Step 		= Channels.Bindable_Events.Next_Tutorial_Step
local Toggle_Tutorial_OK_Button = Channels.Bindable_Events.Toggle_Tutorial_OK_Button
local Toggle_Commands_Panel 	= Channels.Bindable_Events.Toggle_Commands_Panel

-- UI References
local Message = script.Parent.Tuto_Message
local OK_Button = Message:FindFirstChild("Tuto_OK",true)
local Hand_Indicator = script.Parent.Main_F.Hand_Indicator
local Commands_Panel = script.Parent.Commands_Frame

local HandIndicatorTween = nil

local function Stop_Hand_Indicator_Tween()
	Hand_Indicator.Visible = false
	if HandIndicatorTween then
		HandIndicatorTween:Cancel()
		HandIndicatorTween = nil
	end	
end

local function Start_Hand_Indicator_Tween(min_Pos,Max_Pos)

	local minPos  = min_Pos-- UDim2.new(1.048, 0, yScale, yOffset)
	local maxPos = Max_Pos-- UDim2.new(1.082, 0, yScale, yOffset)

	-- start from left
	Hand_Indicator.Position = minPos

	local tweenInfo = TweenInfo.new(
		0.4,                         -- time
		Enum.EasingStyle.Sine,
		Enum.EasingDirection.InOut,
		-1,                          -- repeat forever
		true,                        -- reverse: goes left <-> right
		0
	)

	HandIndicatorTween = TS:Create(Hand_Indicator, tweenInfo, { Position = maxPos })
	HandIndicatorTween:Play()
end

Close_Tutorial.Event:Connect(function()
	Message.Visible = false
end)

Display_Tuto_Message.Event:Connect(function(title, message)
	Message:FindFirstChild("Tuto_Title",true).Text = title
	Message:FindFirstChild("Tuto_Message",true).Text = message
	Message.Visible = true
end)

Display_Tuto_Indicator.Event:Connect(function(Should_Show, Data)
	if(Data ~= nil) then
		Hand_Indicator.Rotation = Data.Rotation
		Hand_Indicator.Size = Data.Size
		Start_Hand_Indicator_Tween(Data.InitialPos,Data.FinalPos)
	else
		Stop_Hand_Indicator_Tween()
	end
	
	Hand_Indicator.Visible = Should_Show
end)

OK_Button.MouseButton1Click:Connect(function()
	Message.Visible = false
	Next_Tutorial_Step:Fire()
end)

local Next_KeyCode = Enum.KeyCode.Return
UIS.InputEnded:Connect(function(input)
	if(Plr:GetAttribute("IsTutorialRunning")) then
		if (OK_Button.Visible and Message.Visible) then 
			if input.KeyCode == Next_KeyCode then
				Message.Visible = false
				Next_Tutorial_Step:Fire()
			end
		end
	end
end)

Toggle_Tutorial_OK_Button.Event:Connect(function(Should_Show)	
	OK_Button.Visible = Should_Show
	if Should_Show then
		Hand_Indicator.Visible = false
	end
end)

Toggle_Commands_Panel.Event:Connect(function(Should_Show)
	if Should_Show == nil then
		Should_Show = not Commands_Panel.Visible
	end
	
	Commands_Panel.Visible = Should_Show
	Message.Visible = not Should_Show
end)

]]></ProtectedString>
							<string name="ScriptGuid">{764F6402-EB6C-46AD-81B9-2EF8D6432814}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Tour_UI_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXA853AD2B019B4FB08848BE9C4A657560">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Cage_Tutorial_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXBE9DB7A1C94249CEBEAB9F0591410014">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Client/Tutorial/Mini_Tutorial_Controller.client.lua
--
--  Description:
--      Full client-side controller for the Mini Tutorial system.
--      Handles UI prompts, guided steps, typewriter effects, hand
--      indicators, highlight strokes, image-based tutorial messages,
--      navigation buttons, and cleanup/reset logic.
--
--      Features:
--          • Typewriter text animation for tutorial messages
--          • Dynamic hand indicator with tweened movement
--          • UI highlight strokes (UIStroke & ImageStroke effects)
--          • Step progression (Next / OK buttons)
--          • Support for two display modes:
--                - Classic message box (title + text)
--                - Image-based “NewMessageBox” with tip area
--          • Position presets (TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT)
--          • Full cleanup: stroke blinking, indicators, tweens
--          • Mini-tutorial prompt (“Want to take a short tutorial?”)
--          • Integration with server tutorial state
--
--  Last Modified: 2025-11-29 by Darkzeb
--  Version: V2025-11
--
--  Dependencies:
--      Services:
--          - TweenService
--          - UserInputService (indirect via buttons)
--
--      ReplicatedStorage Modules:
--          - Channels (BindableEvents + RemoteEvents)
--
--      UI:
--          - Tuto_Frame, Tuto_Message, MessageBox, Tuto_Prompt
--          - Hand_Indicator template (Temps.Hand_Indicator)
--          - Stroke templates (Temps/*)
--
--  Notes:
--      • This script does all animation logic locally for smooth UX.
--      • Hand indicator & strokes auto-reset when switching steps.
--      • New tutorial steps must fire BindableEvents defined in Channels.
--======================================================================
-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer

-- Modules
local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Close_Tutorial 				= Channels.Bindable_Events.Close_Tutorial

local Display_InCage_Message	 	= Channels.Bindable_Events.Display_InCage_Message
local Next_Tutorial_Step 			= Channels.Bindable_Events.Next_Tutorial_Step

local Display_InCage_UIStroke  		= Channels.Bindable_Events.Display_InCage_UIStroke
local Display_InCage_ImageStroke  	= Channels.Bindable_Events.Display_InCage_ImageStroke
local Display_InCage_Indicator     	= Channels.Bindable_Events.Display_InCage_Indicator

-- UI References
local Message_F = script.Parent.MessageBox
local Next_Button_F = Message_F.ButtonBox
local Next_B = Next_Button_F.Next_B
local Keybind_F = Next_Button_F.Keybind
local Title = Message_F.Box.Text_F.Tuto_Title
local Text = Message_F.Box.Text_F.Tuto_Message
local TipBox = Message_F.Box_Tip
local Tips = TipBox.Tuto_Message
local Image = Message_F.Box.ImageLabel
local NextButton_initial_Size = Next_B.Size

local oldStroke={}
local oldImageStroke={}
local UIStroke_Image_Blink_Con=nil
local UIStroke_Blink_Con=nil

local Next_Button_OnTween=nil
local TypeWriter_Con=nil
local Stop_Hand_Indicator_Tween=nil

local Next_KeyCode = nil
local Current_Device= nil

local function ApplyDeviceInputNextKey()

	local Next_KeyHint = ""
	if UIS.TouchEnabled then
		Current_Device = "Mobile"
	else 
		if UIS.KeyboardEnabled and not UIS.GamepadEnabled then
			Current_Device = "PC"
			Next_KeyCode =  Enum.KeyCode.Return
			Next_KeyHint = Next_KeyCode.Name
		elseif UIS.GamepadEnabled then
			Current_Device = "Console"
			Next_KeyCode = Enum.KeyCode.ButtonX
			local Mapped_Key = UIS:GetStringForKeyCode(Enum.KeyCode.ButtonX)
			Next_KeyHint = Mapped_Key~= nil and Mapped_Key or Next_KeyCode.Name 
		else
			Current_Device = "Mobile"
		end
	end

	if Next_KeyHint ~= "" then
		Keybind_F.Holder.Txt.Text = "["..Next_KeyHint.."]"
		Keybind_F.Visible=true
	end
end
ApplyDeviceInputNextKey()

local Tip_Prefix = "<b><font color='rgb(0, 215, 0)'>TIP:</font></b> "

local function Typewrite(label, fullText, showNextButton, duration)
	if Next_Button_OnTween then
		task.cancel(Next_Button_OnTween)
		Next_Button_OnTween=nil
	end
	label.Text = fullText
	label.MaxVisibleGraphemes = 0
	Next_Button_F.Visible=false
	local count = utf8.len(fullText) or #fullText
	if count == 0 then
		label.MaxVisibleGraphemes = -1
		return
	end

	local step = duration / count
	for i = 1, count do
		label.MaxVisibleGraphemes = i
		task.wait(step)
	end
	label.MaxVisibleGraphemes = -1 -- show all
	
	if showNextButton then
		Next_Button_F.Visible=true
		local Tween_Show = TweenInfo.new(.5, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
		task.wait(1)
		Next_Button_OnTween=task.spawn(function()
			while true do
				--TS:Create(Next_Button_F,Tween_Show,{ Position = UDim2.new(currentPos.X.Scale+.02,0,currentPos.Y.Scale,0)}):Play()
				TS:Create(Next_B,Tween_Show,{ Size = UDim2.new(NextButton_initial_Size.X.Scale+0.1,0,NextButton_initial_Size.Y.Scale+0.1,0)}):Play()
				task.wait(.5)
				--TS:Create(Next_Button_F,Tween_Show,{ Position = UDim2.new(currentPos.X.Scale,0,currentPos.Y.Scale,0)}):Play()
				TS:Create(Next_B,Tween_Show,{ Size = UDim2.new(NextButton_initial_Size.X.Scale,0,NextButton_initial_Size.Y.Scale,0)}):Play()
				task.wait(.5)	
			end
		end)
	end
	
	if Tips.Text~="" then
		TipBox.Visible=true
	end
	
	if Next_B.Visible and Next_Button_F.Visible then
		Keybind_F.Visible= Current_Device~="Mobile"
		
		--Mini_Tutorial_Hand_Toggle:Fire(Message_F)
		--Stop_Hand_Indicator_Tween()
	end
end

Stop_Hand_Indicator_Tween= function ()
	if HandIndicatorTween then
		HandIndicatorTween:Cancel()
		HandIndicatorTween = nil
	end

	if Hand_Indicator_OnTween then
		Hand_Indicator_OnTween:Destroy()
	end
end

local function Start_Hand_Indicator_Tween(hand,min_Pos,Max_Pos)

	Stop_Hand_Indicator_Tween()

	local leftPos  =min_Pos-- UDim2.new(1.048, 0, yScale, yOffset)
	local rightPos =Max_Pos-- UDim2.new(1.082, 0, yScale, yOffset)

	-- start from left
	hand.Position = leftPos

	local tweenInfo = TweenInfo.new(
		0.4,                         -- time
		Enum.EasingStyle.Sine,
		Enum.EasingDirection.InOut,
		-1,                          -- repeat forever
		true,                        -- reverse: goes left <-> right
		0
	)

	HandIndicatorTween = TS:Create(hand, tweenInfo, { Position = rightPos })
	HandIndicatorTween:Play()
	Hand_Indicator_OnTween=hand
end

Display_InCage_Indicator.Event:Connect(function(Parent, Hand_Indicator_Data)
	
	if Parent ~= nil and Hand_Indicator_Data~= nil then
		local Hand_Indicator = script.Parent:FindFirstChild("Highlight_Templates"):FindFirstChild("Hand_Indicator"):Clone()
		Hand_Indicator.Rotation = Hand_Indicator_Data.Rotation
		Hand_Indicator.Size = Hand_Indicator_Data.Size
		Hand_Indicator.Position = Hand_Indicator_Data.InitialPos
		Hand_Indicator.Parent = Parent
		Hand_Indicator.Visible = true
		task.wait(.1)
		--print(Hand_Indicator)
		Start_Hand_Indicator_Tween(Hand_Indicator,Hand_Indicator_Data.InitialPos,Hand_Indicator_Data.FinalPos)
	else 
		Stop_Hand_Indicator_Tween()
	end
end)

local function PlayEffectOnImage(Stroke)

	local Tween_Show = TweenInfo.new(1, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)

	local currentSize = Stroke.Size
	local XOffset=0.2
	local YOffset=0.2

	while(true) do

		TS:Create(Stroke,Tween_Show,{ Size = UDim2.new(currentSize.X.Scale+XOffset,0,currentSize.Y.Scale+YOffset,0)
			,ImageTransparency=0
		}):Play()

		task.wait(1)
		TS:Create(Stroke,Tween_Show,{ Size = UDim2.new(currentSize.X.Scale+(XOffset+XOffset/4),0,currentSize.Y.Scale+(YOffset+YOffset/4),0),
			ImageTransparency=1
		}):Play()
		task.wait(.25)

		Stroke.Size = currentSize
	end

end


Close_Tutorial.Event:Connect(function()
	Message_F.Visible=false
	TipBox.Visible=false
end)

Display_InCage_Message.Event:Connect(function(messageData)
	
	ApplyDeviceInputNextKey()
	
	local _Title = messageData.title
	local _Message = messageData.txt
	local _TipText = messageData.tips
	local _Next_button = messageData.next_button

	Text.Text = ""
	Tips.Text= ""
	
	Image=Image~=nil and Image or ""
	Title.Visible = _Title ~= nil
	if _Title then
		Title.Text = _Title
	end
	
	if TypeWriter_Con then
		task.cancel(TypeWriter_Con)
		TypeWriter_Con=nil
	end
	if _TipText then
		Tips.Text =Tip_Prefix.._TipText
	end
	TipBox.Visible=false
	Next_Button_F.Visible = _Next_button
	Message_F.Visible=true

	TypeWriter_Con = task.spawn(function()
		Typewrite(Text, _Message, _Next_button, 0.75)
	end)
end)

local function Next_Handle()
	Message_F.Visible=false
	Keybind_F.Visible= false
	Next_Tutorial_Step:Fire()
end

Next_B.MouseButton1Click:Connect(function()
	Next_Handle()
end)

UIS.InputEnded:Connect(function(input)
	if(Plr:GetAttribute("IsTutorialRunning")) then
		if (Next_Button_F.Visible and Message_F.Visible) then 
			if input.KeyCode == Next_KeyCode then
				Next_Handle()
			end
		end
	end
end)

local function DestroyBlink()
	for _,UIS in ipairs(oldImageStroke) do
		UIS:Destroy()
	end
	oldImageStroke={}
	for _,UIS in ipairs(oldStroke) do
		UIS:Destroy()
	end
	oldStroke={}
	if UIStroke_Blink_Con then

		UIStroke_Blink_Con:Disconnect()
		UIStroke_Blink_Con=nil
	end
	if UIStroke_Image_Blink_Con then

		UIStroke_Image_Blink_Con:Disconnect()
		UIStroke_Image_Blink_Con=nil
	end
	Stop_Hand_Indicator_Tween()
end

local function BlinkEffect(StrokeTable)
	while #StrokeTable>0 do
		for _,item in ipairs(StrokeTable) do
			if item:IsA("UIStroke") then
				item.Enabled=not item.Enabled
			elseif item:IsA("ImageLabel") then
				item.Visible=not item.Visible
			end
		end
		task.wait(.5)
	end
end

local function Add_Image_Stroke(Parent,Stroke_Image,Y_Offset, color)

	if not color then
		color=Color3.new(0, 1, 0)
	end

	local stroke = script.Parent:FindFirstChild("Highlight_Templates"):FindFirstChild(Stroke_Image):Clone()
	stroke.ImageColor3=color
	stroke.Parent=Parent
	stroke.Visible=true
	stroke.Position=UDim2.new(0.5,0, not Y_Offset and .5 or Y_Offset,0)
	table.insert(oldImageStroke,stroke)

	if #oldImageStroke>0 and UIStroke_Image_Blink_Con==nil then

		UIStroke_Image_Blink_Con=task.spawn(PlayEffectOnImage(stroke))
		--UIStroke_Image_Blink_Con=task.spawn(BlinkEffect(oldImageStroke))
	end
end



local function Add_Blinking_Stroke(Frames_List, Thickness, Color)
	
	if not Thickness then
		Thickness=2
	end
	if not Color then
		Color=Color3.new(0, 1, 0)
	end
	for _,parent in ipairs(Frames_List) do
		local stroke = Instance.new("UIStroke",parent)
		stroke.Color=Color
		stroke.Thickness=Thickness 
		table.insert(oldStroke,stroke)
	end
	if #oldStroke>0 and UIStroke_Blink_Con ==nil then
		UIStroke_Blink_Con =task.spawn(BlinkEffect(oldStroke))
	end
end

Display_InCage_ImageStroke.Event:Connect(function(Parent, Image, Y_Offset)
	DestroyBlink()
	if Parent ~= nil then
		Add_Image_Stroke(Parent,Image, Y_Offset)
	end
end)

Display_InCage_UIStroke.Event:Connect(function(Targets)
	DestroyBlink()
	if Targets~=nil then
		Add_Blinking_Stroke(Targets)
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{ADE45FBB-0D94-41BA-8D1D-FB12D62869BF}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Cage_Tutorial_UI_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX4C8A6F7DDC7E423D847AF842279DA276">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tutorial_Launcher</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXDF783997C684442B8A6BC22E5B51BAAD">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local CS = game:GetService("CollectionService")
local UIS = game:GetService("UserInputService")
local Players		= game:GetService("Players")
local player 		= Players.LocalPlayer
local character 	= player.Character 

-- Modules
local MenuButtons_Mod 	= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local Channels 		= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes

local Show_Tutorial_Launcher 			= Channels.Bindable_Events.Show_Tutorial_Launcher

local Toggle_Side_Buttons 			= Channels.Bindable_Events.Toggle_Side_Buttons
local Toggle_TopBar 				= Channels.Bindable_Events.Toggle_TopBar
local Toggle_Tools_Buttons 			= Channels.Bindable_Events.Toggle_Tools_Buttons
local Close_Tutorial 				= Channels.Bindable_Events.Close_Tutorial

local Start_Tour 					= Channels.Bindable_Events.Start_Tour
local Start_Cage_Tutorial			= Channels.Bindable_Events.Start_Cage_Tutorial
local Blinking_ImageStroke  		= Channels.Bindable_Events.Display_InCage_ImageStroke
local Display_InCage_Indicator  	= Channels.Bindable_Events.Display_InCage_Indicator


local Prompt_F = script.Parent.Tuto_Prompt
local Frame_F = script.Parent.Tuto_Frame
local Hint_F = script.Parent.Tuto_Hint

local No_Btn = Prompt_F:FindFirstChild("No_B",true)
local Tour_Btn = Prompt_F:FindFirstChild("Tour_B",true)
local Yes_Btn = Prompt_F:FindFirstChild("Yes_B",true)
local Exit_B = Frame_F:FindFirstChild("Exit_B",true)
local Exit_Keybind_Hint = Exit_B:FindFirstChild("Keybind")
local Hint_OK_B = Hint_F:FindFirstChild("OK_B",true)

local Exit_Keycode = nil
local Cons={}

-- Buttons Setup 

MenuButtons_Mod.Setup_Base_Button(Cons, Yes_Btn, function() 
	Prompt_F.Visible=false
	player:SetAttribute("IsTutorialRunning", true)
	Start_Cage_Tutorial:Fire()
end)

MenuButtons_Mod.Setup_Base_Button(Cons, Tour_Btn, function() 
	Prompt_F.Visible=false
	player:SetAttribute("IsTutorialRunning", true)
	Start_Tour:Fire()
end)

MenuButtons_Mod.Setup_Colored_Button(Cons, No_Btn, Color3.new(0.392157, 0, 0.00784314), function() 
	Close_Tutorial:Fire()
end)

MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, function()
	Close_Tutorial:Fire()
end)

MenuButtons_Mod.Setup_Base_Button(Cons, Hint_OK_B, function()
	Hint_F.Visible = false
	Blinking_ImageStroke:Fire(nil,nil)
	player:SetAttribute("IsTutorialRunning", false)
	Toggle_TopBar:Fire(true)
	Toggle_Side_Buttons:Fire(true)
	Toggle_Tools_Buttons:Fire(true)
end)

-- Prompt And Frae Visibility
local function Display_Tutorial_Launcher(Should_Show)
	Prompt_F.Visible=Should_Show
	Frame_F.Visible=Should_Show
	Hint_F.Visible=not Should_Show
	Toggle_TopBar:Fire(not Should_Show)
	Toggle_Side_Buttons:Fire(not Should_Show)
	Toggle_Tools_Buttons:Fire(not Should_Show)
	
	if not Should_Show then
		local Tuto_Widget = CS:GetTagged("TutorialButton")[1]
		wait(0.1)
		Blinking_ImageStroke:Fire(Tuto_Widget,"Round_Stroke")
		Display_InCage_Indicator:Fire(Tuto_Widget, {
			InitialPos =UDim2.new(0.5, 0, 0.9, 0) ,
			FinalPos = 	UDim2.new(0.5, 0, 1.2, 0) ,
			Size = 		UDim2.new(0.9, 0, 0.9, 0) ,
			Rotation = 0,
		})
	end
end

Show_Tutorial_Launcher.Event:Connect(function()
	Display_Tutorial_Launcher(true)
end)

Close_Tutorial.Event:Connect(function()
	Display_Tutorial_Launcher(false)
end)


-- Frame Visibility
Start_Tour.Event:Connect(function()
	Frame_F.Visible = true
end)

Start_Cage_Tutorial.Event:Connect(function()
	Frame_F.Visible = true
end)

workspace.AttributeChanged:Connect(function(attr)
	if player:GetAttribute("IsTutorialRunning") and attr == "FIGHT_INTRO" then
		Frame_F.Visible=not workspace:GetAttribute("FIGHT_INTRO")
	end
end)

-- Other than mobile keybinds
local function Apply_Exit_KeyBind(Should_Show)
	local device = nil
	local Exit_KeyHint = ""
	if UIS.TouchEnabled then
		device = "Mobile"
	else 
		if UIS.KeyboardEnabled and not UIS.GamepadEnabled then
			device = "PC"
			Exit_Keycode =  Enum.KeyCode.X
			Exit_KeyHint = Exit_Keycode.Name
		elseif UIS.GamepadEnabled then
			device = "Console"
			Exit_Keycode = Enum.KeyCode.ButtonSelect
			Exit_KeyHint = Exit_Keycode.Name 
		else
			device = "Mobile"
		end
	end

	if Exit_KeyHint ~= "" then
		Exit_Keybind_Hint.Holder.Txt.Text = "["..Exit_KeyHint.."]"
		Exit_Keybind_Hint.Visible=Should_Show
	end
end

character.AttributeChanged:Connect(function(attr)
	if attr == "Is_Fighting" then
		Apply_Exit_KeyBind(character:GetAttribute(attr))
	end
end)

UIS.InputEnded:Connect(function(input)
	if(player:GetAttribute("IsTutorialRunning")) then
		if (Exit_Keybind_Hint.Visible) then 
			if input.KeyCode == Exit_Keycode then
				Close_Tutorial:Fire()
			end
		end
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{21C67CAA-372D-4F13-8E8C-579CD41078A0}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Tutorial_Launcher_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXDC2B2D40C4F548028FE2A6AC74ADC37C">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ReplicatedStorage</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX54810CE20FCF4A22B2F236F3468D50F4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Data_Mods_F</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX04C765A486B045CE807B2244DB83BD1B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Monetization_Mod.lua
--
--  Description:
--      Defines monetization data for Gamepasses and Developer Products.
--      Provides mappings for product IDs, names, icons, types, and
--      optional amounts. Exposed functions allow retrieval of product
--      metadata and integration with MarketplaceService.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * MarketplaceService
--
--  Notes:
--      - GP_Data: Gamepasses with Name, ID, Icon, Price
--          * Examples: VIP, x2 ELO, x2 Cash, Exclusive Emotes, x3 Luck
--      - Dev_Data: Developer Products
--          * Cash Packs (Tiny → Mega Huge)
--          * Gems Packs (Tiny → Mega Huge)
--          * Starter Pack
--      - Used by Monetization_Handle, Codes_Handle, Shop_Handle
--      - Designed to centralize monetization configuration
--
--======================================================================

local MPS = game:GetService("MarketplaceService")

local Monetization_Mod = {}

local GP_Data = {
	['A'] = {
		['Name'] = "VIP!",
		['ID'] = 1258867472,
		['Icon'] = "rbxassetid://116997996978018",
		['Price'] = 49,
	},

	['B'] = {
		['Name'] = "x2 ELO!",
		['ID'] = 1259176869,
		['Icon'] = "rbxassetid://140028327825184",
		['Price'] = 349,
	},

	['C'] = {
		['Name'] = "x2 Cash!",
		['ID'] = 1258959116,
		['Icon'] = "rbxassetid://111390267501817",
		['Price'] = 199,
	},

	['D'] = {
		['Name'] = "Exclusive Emotes!",
		['ID'] = 1259220957,
		['Icon'] = "rbxassetid://140138999956473",
		['Price'] = 249,
	},

	['E'] = {
		['Name'] = "x3 Luck!",
		['ID'] = 1259133027,
		['Icon'] = "rbxassetid://111648715389151",
		['Price'] = 149,
	},

	['F'] = {
		['Name'] = "x2 Luck!",
		['ID'] = 1259086900,
		['Icon'] = "rbxassetid://113302080319391",
		['Price'] = 99,
	},

}

local Dev_Data = {
	['A'] = {
		['Name'] = "Tiny Cash Pack!",
		['ID'] = 3306903850,
		['Type'] = "Cash", 
		['Amount'] = 480,
		['Price'] = 29
	},

	['B'] = {
		['Name'] = "Small Cash Pack!",
		['ID'] = 3306904087,
		['Type'] = "Cash", 
		['Amount'] = 1680,
		['Price'] = 79
	},

	['C'] = {
		['Name'] = "Large Cash Pack!",
		['ID'] = 3306907044,
		['Type'] = "Cash",
		['Amount'] = 4800,
		['Price'] = 199
	},

	['D'] = {
		['Name'] = "Huge Cash Pack!",
		['ID'] = 3306907389,
		['Type'] = "Cash",
		['Amount'] = 21600, 
		['Price'] = 799
	},

	['E'] = {
		['Name'] = "Mega Huge Cash Pack!",
		['ID'] = 3306908329,
		['Type'] = "Cash",
		['Amount'] = 43200,
		['Price'] = 1499
	},

	['F'] = {
		['Name'] = "Tiny Gems Pack!",
		['ID'] = 3306909205,
		['Type'] = "Gems",
		['Amount'] = 20,
		['Price'] = 29
	},

	['G'] = {
		['Name'] = "Small Gems Pack!",
		['ID'] = 3306909447,
		['Type'] = "Gems",
		['Amount'] = 70,
		['Price'] = 79
	},

	['H'] = {
		['Name'] = "Large Gems Pack!",
		['ID'] = 3306909752,
		['Type'] = "Gems",
		['Amount'] = 200,
		['Price'] = 199
	},

	['I'] = {
		['Name'] = "Huge Gems Pack!",
		['ID'] = 3306910019,
		['Type'] = "Gems",
		['Amount'] = 900,
		['Price'] = 799
	},

	['J'] = {
		['Name'] = "Mega Huge Gems Pack!",
		['ID'] = 3306910278,
		['Type'] = "Gems",
		['Amount'] = 1800,
		['Price'] = 1499
	},

	['K'] = {
		['Name'] = "Starter Pack!",
		['ID'] = 3324331165,
		['Type'] = "StarterPack",
	},
	
	['L'] = {
		['Name'] = "Special Gloves",
		['ID'] = 3393273546,
		['Type'] = "Special Gloves",
	},
}

local UGC_Data = {
	
	["T1"] = { Name = "Big Metal Chain", ID = 114922634621014, Price = 50, Thumbnail = "rbxthumb://type=Asset&Id=114922634621014&w=150&h=150" },
	["L"] = { Name = "Fighter Crown - Black White", ID = 82139183698439, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=82139183698439&w=150&h=150" },
	["C1"] = { Name = "Nerd Glasses - Green", ID = 77949725271695, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=77949725271695&w=150&h=150" },
	["B1"] = { Name = "Nerd Glasses - Red", ID = 74735903599213, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=74735903599213&w=150&h=150" },
	["A1"] = { Name = "Nerd Glasses", ID = 114623808048803, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=114623808048803&w=150&h=150" },
	["O"] = { Name = "Motorcycle Helmet - Black", ID = 96818536482215, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=96818536482215&w=150&h=150" },
	["D2"] = { Name = "Sport Bag Black", ID = 87378104044885, Price = 135, Thumbnail = "rbxthumb://type=Asset&Id=87378104044885&w=150&h=150" },
	["E2"] = { Name = "Bape Black Bagpack", ID = 125834338933624, Price = 135, Thumbnail = "rbxthumb://type=Asset&Id=125834338933624&w=150&h=150" },
	["F2"] = { Name = "Dragon Horn Glasses", ID = 120115448345902, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=120115448345902&w=150&h=150" },
	["G2"] = { Name = "Black Angel Wings", ID = 104789977385309, Price = 135, Thumbnail = "rbxthumb://type=Asset&Id=104789977385309&w=150&h=150" },
	["H2"] = { Name = "Inferno aura", ID = 122976837251185, Price = 135, Thumbnail = "rbxthumb://type=Asset&Id=122976837251185&w=150&h=150" },
	["N"] = { Name = "Motorcycle Helmet - Black Red", ID = 97647774814364, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=97647774814364&w=150&h=150" },
	["L1"] = { Name = "Snake Glasses Y2K - Red", ID = 138002585775905, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=138002585775905&w=150&h=150" },
	["G1"] = { Name = "Training Helmet", ID = 81877496476783, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=81877496476783&w=150&h=150" },
	["N1"] = { Name = "Snake Glasses Y2K - Gray", ID = 81653947431590, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=81653947431590&w=150&h=150" },
	["O1"] = { Name = "Snake Glasses Y2K - Orange", ID = 79643861023078, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=79643861023078&w=150&h=150" },
	["H1"] = { Name = "Training Helmet", ID = 107974793938990, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=107974793938990&w=150&h=150" },
	["I1"] = { Name = "Snake Glasses Y2K - Purple", ID = 130235233159644, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=130235233159644&w=150&h=150" },
	["J1"] = { Name = "Snake Glasses Y2K - Pink", ID = 130898687489564, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=130898687489564&w=150&h=150" },
	["K1"] = { Name = "Snake Glasses Y2K - Yellow", ID = 85537731341001, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=85537731341001&w=150&h=150" },
	["D1"] = { Name = "Nerd Glasses - Black", ID = 85169596622861, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=85169596622861&w=150&h=150" },
	["E1"] = { Name = "Training Helmet", ID = 100104438861007, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=100104438861007&w=150&h=150" },
	["A"] = { Name = "Colorful Dreads Breads", ID = 83795788626582, Price = 60, Thumbnail = "rbxthumb://type=Asset&Id=83795788626582&w=150&h=150" },
	["F1"] = { Name = "Training Helmet", ID = 99713943487010, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=99713943487010&w=150&h=150" },
	["C"] = { Name = "Colorful Dreads Breads", ID = 98302594802885, Price = 60, Thumbnail = "rbxthumb://type=Asset&Id=98302594802885&w=150&h=150" },
	["B"] = { Name = "Dreads Breads", ID = 113738030334375, Price = 60, Thumbnail = "rbxthumb://type=Asset&Id=113738030334375&w=150&h=150" },
	["E"] = { Name = "Cowboy Hat", ID = 101474119058173, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=101474119058173&w=150&h=150" },
	["D"] = { Name = "Dreads Breads", ID = 101251472607139, Price = 60, Thumbnail = "rbxthumb://type=Asset&Id=101251472607139&w=150&h=150" },
	["G"] = { Name = "Cowboy Hat", ID = 75114177921975, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=75114177921975&w=150&h=150" },
	["F"] = { Name = "Cowboy Hat", ID = 75995119815868, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=75995119815868&w=150&h=150" },
	["I"] = { Name = "Fighter Crown - Black Green", ID = 113747837981544, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=113747837981544&w=150&h=150" },
	["H"] = { Name = "Cowboy Hat", ID = 101562313582313, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=101562313582313&w=150&h=150" },
	["K"] = { Name = "Fighter Crown - Red White", ID = 114656167427986, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=114656167427986&w=150&h=150" },
	["J"] = { Name = "Fighter Crown - White Green", ID = 76373498147951, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=76373498147951&w=150&h=150" },
	["M"] = { Name = "Motorcycle Helmet - White Red", ID = 100504804713142, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=100504804713142&w=150&h=150" },
	["A2"] = { Name = "Punk Spiked Hair – Black & Red Riot Style", ID = 102119948007614, Price = 60, Thumbnail = "rbxthumb://type=Asset&Id=102119948007614&w=150&h=150" },
	["B2"] = { Name = "Dark Grey Scarf Hood", ID = 136178678394338, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=136178678394338&w=150&h=150" },
	["C2"] = { Name = "Black balaclava", ID = 106805937500041, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=106805937500041&w=150&h=150" },
	["Q"] = { Name = "Protein Shaker - White", ID = 122071796353410, Price = 50, Thumbnail = "rbxthumb://type=Asset&Id=122071796353410&w=150&h=150" },
	["P"] = { Name = "Motorcycle Helmet", ID = 82603511834308, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=82603511834308&w=150&h=150" },
	["S"] = { Name = "Protein Shaker - Black", ID = 87085165668528, Price = 50, Thumbnail = "rbxthumb://type=Asset&Id=87085165668528&w=150&h=150" },
	["R"] = { Name = "Protein Shaker - Red", ID = 98181442625165, Price = 50, Thumbnail = "rbxthumb://type=Asset&Id=98181442625165&w=150&h=150" },
	["U"] = { Name = "Face Bandages", ID = 120067224049421, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=120067224049421&w=150&h=150" },
	["T"] = { Name = "Protein Shaker - Yellow", ID = 102642333841802, Price = 50, Thumbnail = "rbxthumb://type=Asset&Id=102642333841802&w=150&h=150" },
	["W"] = { Name = "Face Bandages", ID = 112600507634369, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=112600507634369&w=150&h=150" },
	["V"] = { Name = "Face Bandages", ID = 119243634001553, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=119243634001553&w=150&h=150" },
	["Y"] = { Name = "Eye Bandage", ID = 84887382195802, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=84887382195802&w=150&h=150" },
	["X"] = { Name = "Face Bandages", ID = 91774845227721, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=91774845227721&w=150&h=150" },
	["M1"] = { Name = "Snake Glasses Y2K - Black", ID = 70454931418771, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=70454931418771&w=150&h=150" },
	["Z"] = { Name = "Eye Bandage", ID = 138705825312307, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=138705825312307&w=150&h=150" },
	["S1"] = { Name = "Black Gold VVS Chain Diamonds", ID = 138617591743408, Price = 50, Thumbnail = "rbxthumb://type=Asset&Id=138617591743408&w=150&h=150" },
	["R1"] = { Name = "Snake Glasses Y2K - Green", ID = 95997013721520, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=95997013721520&w=150&h=150" },
	["Q1"] = { Name = "Snake Glasses Y2K - Blue", ID = 108225068022205, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=108225068022205&w=150&h=150" },
	["P1"] = { Name = "Snake Glasses Y2K - Light Blue", ID = 91544116053373, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=91544116053373&w=150&h=150" },
}


-- Conversion parameters for cash → gems
local Conversion_Settings = {
	RATE = 1 / 20,    -- 1 gem = 20 cash
	FEE = 0.15,       -- 15% commission
}

function Monetization_Mod.Get_Conversion_Settings()
	return Conversion_Settings
end

local function Get_Player_Data(Plr, Key)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		return PD:FindFirstChild(Key).Value
	end
	return nil
end

local function Get_Data(Is_GP)
	if(Is_GP)then
		return GP_Data
	end
	return Dev_Data
end

local function Get_ID_From_Name(Is_GP, Name)
	local Data = Get_Data(Is_GP)

	for Key, Item_Data in next, Data do
		if(Item_Data ~= nil and Item_Data['Name'] ~= nil and Item_Data['Name'] == Name 
			and Item_Data['ID'] ~= nil)then

			return Item_Data['ID']
		end
	end

	return nil
end

local function Get_Key_From_Name(Is_GP, Name)
	local Data = Get_Data(Is_GP)

	for Key, Item_Data in next, Data do
		if(Item_Data ~= nil and Item_Data['Name'] ~= nil and Item_Data['Name'] == Name)then
			return Key
		end
	end

	return nil
end

local function Get_Player_Owned_Gamepasses_Keys(Plr)
	local Owned_GP_Keys = Get_Player_Data(Plr, "Owned Gamepasses") or ""
	return string.split(Owned_GP_Keys, ",")
end

local function Player_Owns_Gamepass(Plr, Key)
	local Owned_Keys = Get_Player_Owned_Gamepasses_Keys(Plr)
	if(Owned_Keys ~= nil and #Owned_Keys > 0 and table.find(Owned_Keys, Key) ~= nil)then
		return true
	end

	return false
end


function Monetization_Mod.Get_Player_Owned_Gamepasses_Keys(Plr)
	return Get_Player_Owned_Gamepasses_Keys(Plr)
end

function Monetization_Mod.Get_All_Gamepass_Data()
	return GP_Data
end

function Monetization_Mod.Get_All_Dev_Product_Data()
	return Dev_Data
end

function Monetization_Mod.Get_All_UGC_Data()
	return UGC_Data
end

function Monetization_Mod.Get_ID_From_Name(Is_GP, Name)
	return Get_ID_From_Name(Is_GP, Name)
end

function Monetization_Mod.Get_ID_From_Key(Is_GP, Key)
	if(Is_GP)then
		local Data_V = GP_Data[Key]
		if(Data_V ~= nil and Data_V['ID'] ~= nil)then
			return Data_V['ID']
		end
	else
		local Data_V = Dev_Data[Key]
		if(Data_V ~= nil and Data_V['ID'] ~= nil)then
			return Data_V['ID']
		end
	end

	return -1
end


function Monetization_Mod.Get_Key_From_Name(Is_GP, Name)
	return Get_Key_From_Name(Is_GP, Name)
end

function Monetization_Mod.Get_Key_From_ID(Is_GP, ID)
	local Data = Get_Data(Is_GP)

	for Key, Item_Data in next, Data do
		if(Item_Data ~= nil and Item_Data['ID'] ~= nil and Item_Data['ID'] == ID)then
			return Key
		end
	end

	return nil
end

function Monetization_Mod.Get_Data_From_Key(Is_GP, Key)
	if(Is_GP)then
		return GP_Data[Key]
	end
	return Dev_Data[Key]
end

function Monetization_Mod.Does_Player_Own_Gamepass(Plr, Name)
	local GP_Key = Get_Key_From_Name(true, Name)
	return Player_Owns_Gamepass(Plr, GP_Key)
end

function Monetization_Mod.Does_Player_Own_Gamepass_Key(Plr, Key)
	return Player_Owns_Gamepass(Plr, Key)
end

function Monetization_Mod.Hard_Gamepass_Check(Plr, GP_ID)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = MPS:UserOwnsGamePassAsync(Plr.UserId, GP_ID)
		end)

		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end

	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end

	return false
end

local function Compile_Cash_Boost_Amounts(Plr)
	local Vals = {
		['A'] = Dev_Data['A']['Amount'],
		['B'] = Dev_Data['B']['Amount'],
		['C'] = Dev_Data['C']['Amount'],
		['D'] = Dev_Data['D']['Amount'],
		['E'] = Dev_Data['E']['Amount']
	}
	return Vals
end

function Monetization_Mod.Get_Cash_Boost_Amount(Plr)
	return Compile_Cash_Boost_Amounts(Plr)
end

function Monetization_Mod.Prompt_Suggested_Cash_Boost(Plr, Needed_Amount)
	local Boost_Data = Compile_Cash_Boost_Amounts(Plr)
	local Boost_Key = "A"
	local Current_Dif, Current_Max = math.huge, -1

	for Key, Amount in next, Boost_Data do
		local Dif = math.abs(Amount - Needed_Amount)
		if((Amount >= Needed_Amount or Amount >= Current_Max) and Dif < Current_Dif)then
			Boost_Key = Key
			Current_Dif = Dif
			Current_Max = Amount
		end
	end

	return Dev_Data[Boost_Key]
end

function Monetization_Mod.Get_Cash_Pack_Amount(Key)
	local Cash_Data = Dev_Data[Key]
	if(Cash_Data ~= nil and Cash_Data['Amount'] ~= nil)then
		return Cash_Data['Amount']
	end
	return 0
end

function Monetization_Mod.Get_Gems_Pack_Amount(Key)
	local Gems_Data = Dev_Data[Key]
	if(Gems_Data ~= nil and Gems_Data['Amount'] ~= nil)then
		return Gems_Data['Amount']
	end
	return 0
end

function Monetization_Mod.Get_Cash_Pack_Price(Key)
	local Cash_Data = Dev_Data[Key]
	if(Cash_Data ~= nil and Cash_Data['Amount'] ~= nil)then
		return Cash_Data['Price']
	end
	return 0
end

function Monetization_Mod.Get_Gems_Pack_Price(Key)
	local Gems_Data = Dev_Data[Key]
	if(Gems_Data ~= nil and Gems_Data['Amount'] ~= nil)then
		return Gems_Data['Price']
	end
	return 0
end


function Monetization_Mod.Get_Cash_Multi(Plr)
	local Multi = 1

	local Owned_x2_Cash = Player_Owns_Gamepass(Plr, "C") or (Plr.Player_Data.Cash2x.Value == true)
	if(Owned_x2_Cash)then
		Multi += 1
	end

	local Owned_VIP = Player_Owns_Gamepass(Plr, "A") or (Plr.Player_Data.Vip.Value == true)
	if(Owned_VIP)then
		Multi += 0.1
	end

	return Multi
end

function Monetization_Mod.Get_Elo_Multi(Plr)
	local Multi = 1

	local Owned_x2_Elo = Player_Owns_Gamepass(Plr, "B")
	if(Owned_x2_Elo)then
		Multi += 1
	end

	return Multi
end

function Monetization_Mod.Get_Luck_Multi(Plr)
	local Multi = 1

	local Owned_x2_Luck = Player_Owns_Gamepass(Plr, "F")
	if(Owned_x2_Luck)then
		Multi += 1
	end

	local Owned_x3_Luck = Player_Owns_Gamepass(Plr, "E")
	if(Owned_x3_Luck)then
		Multi += 2
	end

	local Friends_Count = Plr:GetAttribute("Friends_Count") or 0
	Multi += Friends_Count * 0.1

	return Multi
end

function Monetization_Mod.Get_ID_From_Key_UGC( Key)------------By Adnan
	local Data_V = UGC_Data[Key]
	if(Data_V ~= nil and Data_V['ID'] ~= nil)then
		return Data_V['ID']
	end
	return -1
end

function Monetization_Mod.Get_UGC_Key_From_ID_UGC(ID)----------By Adnan
	for key, item in pairs(UGC_Data) do
		if item.ID == ID then
			return key
		end
	end
	return nil
end

return Monetization_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{4B5B0954-4365-4B7E-86C2-E96743C048DE}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Monetization_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX685C71983659440AB45AC8BE5C834AEC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/CameraShaker.lua
--
--  Description:
--      Camera shake utility library (ported from EZ Camera Shake, Unity3D).
--      Provides API to apply one-time or sustained shakes with configurable
--      magnitude, roughness, fade times, and positional/rotational influence.
--
--  Author(s): Stephen Leitnick (port), Road Turtle Games (original Unity asset)
--  Integrated by: Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage/Data_Mods_F:
--          * CameraShakeInstance
--          * CameraShakePresets
--      - Roblox Services:
--          * RunService (BindToRenderStep)
--
--  Notes:
--      - Based on EZ Camera Shake (Unity asset) with permission from author
--      - Provides presets (Explosion, Earthquake, etc.)
--      - Supports ShakeOnce, ShakeSustain, and StopSustained
--      - Callback function must apply the shake CFrame to camera
--
--======================================================================



-- Camera Shaker
-- Stephen Leitnick
-- February 26, 2018

--[[
	
	CameraShaker.CameraShakeInstance
	
	cameraShaker = CameraShaker.new(renderPriority, callbackFunction)
	
	CameraShaker:Start()
	CameraShaker:Stop()
	CameraShaker:StopSustained([fadeOutTime])
	CameraShaker:Shake(shakeInstance)
	CameraShaker:ShakeSustain(shakeInstance)
	CameraShaker:ShakeOnce(magnitude, roughness [, fadeInTime, fadeOutTime, posInfluence, rotInfluence])
	CameraShaker:StartShake(magnitude, roughness [, fadeInTime, posInfluence, rotInfluence])
	
	
	
	EXAMPLE:
	
		local camShake = CameraShaker.new(Enum.RenderPriority.Camera.Value, function(shakeCFrame)
			camera.CFrame = playerCFrame * shakeCFrame
		end)
		
		camShake:Start()
		
		-- Explosion shake:
		camShake:Shake(CameraShaker.Presets.Explosion)
		
		wait(1)
		
		-- Custom shake:
		camShake:ShakeOnce(3, 1, 0.2, 1.5)

		-- Sustained shake:
		camShake:ShakeSustain(CameraShaker.Presets.Earthquake)

		-- Stop all sustained shakes:
		camShake:StopSustained(1) -- Argument is the fadeout time (defaults to the same as fadein time if not supplied)

		-- Stop only one sustained shake:
		shakeInstance = camShake:ShakeSustain(CameraShaker.Presets.Earthquake)
		wait(2)
		shakeInstance:StartFadeOut(1) -- Argument is the fadeout time
	
	
	NOTE:
	
		This was based entirely on the EZ Camera Shake asset for Unity3D. I was given written
		permission by the developer, Road Turtle Games, to port this to Roblox.
		
		Original asset link: https://assetstore.unity.com/packages/tools/camera/ez-camera-shake-33148

		GitHub repository: https://github.com/Sleitnick/RbxCameraShaker
	
	
--]]



local CameraShaker = {}
CameraShaker.__index = CameraShaker

local profileBegin = debug.profilebegin
local profileEnd = debug.profileend
local profileTag = "CameraShakerUpdate"

local V3 = Vector3.new
local CF = CFrame.new
local ANG = CFrame.Angles
local RAD = math.rad
local v3Zero = V3()

local CameraShakeInstance = require(script.CameraShakeInstance)
local CameraShakeState = CameraShakeInstance.CameraShakeState

local defaultPosInfluence = V3(0.15, 0.15, 0.15)
local defaultRotInfluence = V3(1, 1, 1)


CameraShaker.CameraShakeInstance = CameraShakeInstance
CameraShaker.Presets = require(script.CameraShakePresets)


function CameraShaker.new(renderPriority, callback)
	
	assert(type(renderPriority) == "number", "RenderPriority must be a number (e.g.: Enum.RenderPriority.Camera.Value)")
	assert(type(callback) == "function", "Callback must be a function")
	
	local self = setmetatable({
		_running = false;
		_renderName = "CameraShaker";
		_renderPriority = renderPriority;
		_posAddShake = v3Zero;
		_rotAddShake = v3Zero;
		_camShakeInstances = {};
		_removeInstances = {};
		_callback = callback;
	}, CameraShaker)
	
	return self
	
end


function CameraShaker:Start()
	if (self._running) then return end
	self._running = true
	local callback = self._callback
	game:GetService("RunService"):BindToRenderStep(self._renderName, self._renderPriority, function(dt)
		profileBegin(profileTag)
		local cf = self:Update(dt)
		profileEnd()
		callback(cf)
	end)
end


function CameraShaker:Stop()
	if (not self._running) then return end
	game:GetService("RunService"):UnbindFromRenderStep(self._renderName)
	self._running = false
end


function CameraShaker:StopSustained(duration)
	for _,c in pairs(self._camShakeInstances) do
		if (c.fadeOutDuration == 0) then
			c:StartFadeOut(duration or c.fadeInDuration)
		end
	end
end


function CameraShaker:Update(dt)
	
	local posAddShake = v3Zero
	local rotAddShake = v3Zero
	
	local instances = self._camShakeInstances
	
	-- Update all instances:
	for i = 1,#instances do
		
		local c = instances[i]
		local state = c:GetState()
		
		if (state == CameraShakeState.Inactive and c.DeleteOnInactive) then
			self._removeInstances[#self._removeInstances + 1] = i
		elseif (state ~= CameraShakeState.Inactive) then
			local shake = c:UpdateShake(dt)
			posAddShake = posAddShake + (shake * c.PositionInfluence)
			rotAddShake = rotAddShake + (shake * c.RotationInfluence)
		end
		
	end
	
	-- Remove dead instances:
	for i = #self._removeInstances,1,-1 do
		local instIndex = self._removeInstances[i]
		table.remove(instances, instIndex)
		self._removeInstances[i] = nil
	end
	
	return CF(posAddShake) *
			ANG(0, RAD(rotAddShake.Y), 0) *
			ANG(RAD(rotAddShake.X), 0, RAD(rotAddShake.Z))
	
end


function CameraShaker:Shake(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance, "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:ShakeSustain(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance, "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	shakeInstance:StartFadeIn(shakeInstance.fadeInDuration)
	return shakeInstance
end


function CameraShaker:ShakeOnce(magnitude, roughness, fadeInTime, fadeOutTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:StartShake(magnitude, roughness, fadeInTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	shakeInstance:StartFadeIn(fadeInTime)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


return CameraShaker]]></ProtectedString>
						<string name="ScriptGuid">{7FBEEF21-B5AF-4B7B-ACE2-4AE1661AE4A4}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CameraShaker.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX97C39D995DA74DE2A56DDB9E7C06734C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CameraShaker</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXD1B06412AB5A49B99E362544FB310BB2">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/CameraShaker/CameraShakeInstance.lua
--
--  Description:
--      Represents a single camera shake instance. Stores configuration
--      for magnitude, roughness, fade in/out, and positional/rotational
--      influence. Provides methods to update, fade, and scale shake.
--
--  Author(s): Stephen Leitnick
--  Integrated by: Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox:
--          * Vector3
--          * math.noise
--          * Random
--      - Local Modules:
--          * Used by CameraShaker.lua and CameraShakePresets.lua
--
--  Notes:
--      - States: FadingIn, FadingOut, Sustained, Inactive
--      - UpdateShake(dt) returns current offset Vector3
--      - Supports runtime fade in/out adjustments
--      - PositionInfluence and RotationInfluence vectors apply shake
--      - DeleteOnInactive auto-cleans instance after fade
--
--======================================================================



local CameraShakeInstance = {}
CameraShakeInstance.__index = CameraShakeInstance

local V3 = Vector3.new
local NOISE = math.noise


CameraShakeInstance.CameraShakeState = {
	FadingIn = 0;
	FadingOut = 1;
	Sustained = 2;
	Inactive = 3;
}


function CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	
	if (fadeInTime == nil) then fadeInTime = 0 end
	if (fadeOutTime == nil) then fadeOutTime = 0 end
	
	assert(type(magnitude) == "number", "Magnitude must be a number")
	assert(type(roughness) == "number", "Roughness must be a number")
	assert(type(fadeInTime) == "number", "FadeInTime must be a number")
	assert(type(fadeOutTime) == "number", "FadeOutTime must be a number")
	
	local self = setmetatable({
		Magnitude = magnitude;
		Roughness = roughness;
		PositionInfluence = V3();
		RotationInfluence = V3();
		DeleteOnInactive = true;
		roughMod = 1;
		magnMod = 1;
		fadeOutDuration = fadeOutTime;
		fadeInDuration = fadeInTime;
		sustain = (fadeInTime > 0);
		currentFadeTime = (fadeInTime > 0 and 0 or 1);
		tick = Random.new():NextNumber(-100, 100);
		_camShakeInstance = true;
	}, CameraShakeInstance)
	
	return self
	
end


function CameraShakeInstance:UpdateShake(dt)
	
	local _tick = self.tick
	local currentFadeTime = self.currentFadeTime
	
	local offset = V3(
		NOISE(_tick, 0) * 0.5,
		NOISE(0, _tick) * 0.5,
		NOISE(_tick, _tick) * 0.5
	)
	
	if (self.fadeInDuration > 0 and self.sustain) then
		if (currentFadeTime < 1) then
			currentFadeTime = currentFadeTime + (dt / self.fadeInDuration)
		elseif (self.fadeOutDuration > 0) then
			self.sustain = false
		end
	end
	
	if (not self.sustain) then
		currentFadeTime = currentFadeTime - (dt / self.fadeOutDuration)
	end
	
	if (self.sustain) then
		self.tick = _tick + (dt * self.Roughness * self.roughMod)
	else
		self.tick = _tick + (dt * self.Roughness * self.roughMod * currentFadeTime)
	end
	
	self.currentFadeTime = currentFadeTime
	
	return offset * self.Magnitude * self.magnMod * currentFadeTime
	
end


function CameraShakeInstance:StartFadeOut(fadeOutTime)
	if (fadeOutTime == 0) then
		self.currentFadeTime = 0
	end
	self.fadeOutDuration = fadeOutTime
	self.fadeInDuration = 0
	self.sustain = false
end


function CameraShakeInstance:StartFadeIn(fadeInTime)
	if (fadeInTime == 0) then
		self.currentFadeTime = 1
	end
	self.fadeInDuration = fadeInTime or self.fadeInDuration
	self.fadeOutDuration = 0
	self.sustain = true
end


function CameraShakeInstance:GetScaleRoughness()
	return self.roughMod
end


function CameraShakeInstance:SetScaleRoughness(v)
	self.roughMod = v
end


function CameraShakeInstance:GetScaleMagnitude()
	return self.magnMod
end


function CameraShakeInstance:SetScaleMagnitude(v)
	self.magnMod = v
end


function CameraShakeInstance:GetNormalizedFadeTime()
	return self.currentFadeTime
end


function CameraShakeInstance:IsShaking()
	return (self.currentFadeTime > 0 or self.sustain)
end


function CameraShakeInstance:IsFadingOut()
	return ((not self.sustain) and self.currentFadeTime > 0)
end


function CameraShakeInstance:IsFadingIn()
	return (self.currentFadeTime < 1 and self.sustain and self.fadeInDuration > 0)
end


function CameraShakeInstance:GetState()
	if (self:IsFadingIn()) then
		return CameraShakeInstance.CameraShakeState.FadingIn
	elseif (self:IsFadingOut()) then
		return CameraShakeInstance.CameraShakeState.FadingOut
	elseif (self:IsShaking()) then
		return CameraShakeInstance.CameraShakeState.Sustained
	else
		return CameraShakeInstance.CameraShakeState.Inactive
	end
end


return CameraShakeInstance]]></ProtectedString>
							<string name="ScriptGuid">{C5D285D9-4FCD-46CD-A6C6-C59AF61624E9}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CameraShakeInstance.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6CE5B4B3CFDA4368AA4ADB34D6C2596B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/CameraShaker/CameraShakePresets.lua
--
--  Description:
--      Defines preset camera shake configurations (e.g. Explosion,
--      Earthquake, HandheldCamera). Each preset returns a new
--      CameraShakeInstance with predefined magnitude, roughness,
--      fade times, and positional/rotational influences.
--
--  Author(s): Stephen Leitnick
--  Integrated by: Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Local Modules:
--          * CameraShakeInstance
--      - Roblox:
--          * Vector3
--
--  Notes:
--      - Presets include: Bump, Explosion, Earthquake, BadTrip,
--        HandheldCamera, Vibration, RoughDriving
--      - Each call returns a fresh CameraShakeInstance
--      - Designed for use with CameraShaker.lua
--
--======================================================================


-- Camera Shake Presets
-- Stephen Leitnick
-- February 26, 2018

--[[
	
	CameraShakePresets.Bump
	CameraShakePresets.Explosion
	CameraShakePresets.Earthquake
	CameraShakePresets.BadTrip
	CameraShakePresets.HandheldCamera
	CameraShakePresets.Vibration
	CameraShakePresets.RoughDriving
	
--]]



local CameraShakeInstance = require(script.Parent.CameraShakeInstance)

local CameraShakePresets = {


	-- A high-magnitude, short, yet smooth shake.
	-- Should happen once.
	Bump = function()
		local c = CameraShakeInstance.new(2.5, 4, 0.1, 0.75)
		c.PositionInfluence = Vector3.new(0.15, 0.15, 0.15)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;


	-- An intense and rough shake.
	-- Should happen once.
	Explosion = function()
		local c = CameraShakeInstance.new(5, 10, 0, 1.5)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(4, 1, 1)
		return c
	end;


	-- A continuous, rough shake
	-- Sustained.
	Earthquake = function()
		local c = CameraShakeInstance.new(0.6, 3.5, 2, 10)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(1, 1, 4)
		return c
	end;


	-- A bizarre shake with a very high magnitude and low roughness.
	-- Sustained.
	BadTrip = function()
		local c = CameraShakeInstance.new(10, 0.15, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0.15)
		c.RotationInfluence = Vector3.new(2, 1, 4)
		return c
	end;

	-- A subtle, slow shake.
	-- Sustained.
	HandheldCamera = function()
		local c = CameraShakeInstance.new(1, 0.25, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 0.5, 0.5)
		return c
	end;

	-- A very rough, yet low magnitude shake.
	-- Sustained.
	Vibration = function()
		local c = CameraShakeInstance.new(0.4, 20, 2, 2)
		c.PositionInfluence = Vector3.new(0, 0.15, 0)
		c.RotationInfluence = Vector3.new(1.25, 0, 4)
		return c
	end;

	-- A slightly rough, medium magnitude shake.
	-- Sustained.
	RoughDriving = function()
		local c = CameraShakeInstance.new(1, 2, 1, 1)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;
}

return setmetatable({}, {
	__index = function(t, i)
		local f = CameraShakePresets[i]
		if (type(f) == "function") then
			return f()
		end
		error("No preset found with index \"" .. i .. "\"")
	end;
})]]></ProtectedString>
							<string name="ScriptGuid">{F61F40E0-1537-4D1A-8995-F089967F8DD9}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CameraShakePresets.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX1B7D809A8677422C9CB01C3CE7F83150">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/UI_LeagueTournament_Handler.lua
--
--  Description:
--      Client-side handler for League + Weekly Tournament UI.
--      Reflects new weekly league rules:
--        - Tournament starts every Saturday 18:00 UTC
--        - One-week duration
--        - No teleport, local tournament mode
--        - Waiting / Active / Ended states
--
--======================================================================

local ReplicatedStorage			= game:GetService("ReplicatedStorage")
local Utils 					= require(game.ReplicatedStorage.Modules.Utils)

local Channels 					= require(game.ReplicatedStorage.Modules.Channels)

-- RemoteEvents
local LeagueUpdate 				= Channels.SC_Remote_Events.League_DivisionUpdate
local TournamentUpdate 			= Channels.SC_Remote_Events.Tournament_Update
local TournamentResults 		= Channels.SC_Remote_Events.Tournament_Results

local UI_Handler = {}

-- ==========================================================
-- INTERNAL STATE
-- ==========================================================

UI_Handler.boundUIs = {}
UI_Handler.CurrentLeague = {}
UI_Handler.CurrentTournament = {}

UI_Handler.IsRegistered = false
UI_Handler._nextStartTime = nil
UI_Handler._countdownTask = nil

local function isSameDay(ts)
	local now = os.date("*t")
	local target = os.date("*t", ts)
	return now.year == target.year
		and now.month == target.month
		and now.day == target.day
end

local function stopCountdown(self)
	if self._countdownTask then
		task.cancel(self._countdownTask)
		self._countdownTask = nil
	end
end

-- ==========================================================
-- COUNTDOWN
-- ==========================================================

function UI_Handler:startCountdown(statusLabel, registerButton)
	stopCountdown(self)

	self._countdownTask = task.spawn(function()
		while self._nextStartTime do
			local remaining = self._nextStartTime - os.time()

			if remaining <= 0 then
				statusLabel.Text = "🔥 Tournament starting..."
				if registerButton then
					registerButton.Active = false
					registerButton.AutoButtonColor = false
				end
				break
			elseif remaining <= 3600 then
				statusLabel.Text = "⏳ Starts in " .. Utils.formatMMSS(remaining)
			else
				if isSameDay(self._nextStartTime) then
					statusLabel.Text = "📅 Today at " .. os.date("%H:%M", self._nextStartTime)
				else
					statusLabel.Text = "📅 " .. os.date("%a %d %b %H:%M", self._nextStartTime)
				end
			end

			if registerButton then
				registerButton.Active = not self.IsRegistered
				registerButton.AutoButtonColor = not self.IsRegistered
			end

			task.wait(1)
		end
	end)
end

-- ==========================================================
-- BINDING
-- ==========================================================
function UI_Handler:BindUI(uiType, frame)
	self.boundUIs = self.boundUIs or {}
	self.boundUIs[uiType] = frame

	if self.CurrentTournament and uiType == "LeagueTournament" then
		self:SetTournamentStats(self.CurrentTournament)
	end
end

-- ==========================================================
-- UPDATE FUNCTIONS
-- ==========================================================
function UI_Handler:SetTournamentStats(data)
	self.CurrentTournament = data

	local ui = self.boundUIs["LeagueTournament"] or self.boundUIs["Tournament"]
	if not ui then return end

	local body = ui.Main_F.Body.Stroke.Content
	local section = body.Tournament_Section

	local statusLabel = section:FindFirstChild("StatusLabel")
	local scoreLabel = section:FindFirstChild("ScoreLabel")
	local registerButton = section:FindFirstChild("Register_B")
	local leaveButton = section:FindFirstChild("Leave_B")

	if data.NextStartTime then
		self._nextStartTime = data.NextStartTime
	end

	if data.Status == "Registered" then
		self.IsRegistered = true
	elseif data.Status == "Unregistered" then
		self.IsRegistered = false
	end

	if registerButton then
		registerButton.Active = not self.IsRegistered
		registerButton.AutoButtonColor = not self.IsRegistered
	end
	if leaveButton then
		leaveButton.Active = self.IsRegistered
		leaveButton.AutoButtonColor = self.IsRegistered
	end

	if not data.IsActive and not self.IsRegistered and self._nextStartTime and statusLabel then
		self:startCountdown(statusLabel, registerButton)
		return
	end

	stopCountdown(self)

	if statusLabel then
		if data.IsActive then
			statusLabel.Text = "🔥 Tournament running"
		elseif self.IsRegistered then
			statusLabel.Text = "🕒 Registered – waiting for start"
		else
			statusLabel.Text = "❌ Not registered"
		end
	end

	if scoreLabel and data.Score ~= nil then
		scoreLabel.Text = string.format("Score: %d", data.Score)
	end
end

function UI_Handler:SetLeagueStats(stats)
	local ui = self.boundUIs["LeagueTournament"] or self.boundUIs["League"]
	if not ui then return end

	local body = ui.Main_F.Body.Stroke.Content
	local section = body.League_Section

	local leagueLabel = section.LeagueLabel
	local rankLabel = section.RankLabel
	local winsLabel = section.WinsLabel

	if leagueLabel then
		leagueLabel.Text = "Division: " .. (stats.Division or "?")
	end
	if rankLabel then
		rankLabel.Text = "Rank: " .. (stats.Rank or "?")
	end
	if winsLabel then
		winsLabel.Text = string.format("Wins: %d", stats.Wins or 0)
	end
end

-- ==========================================================
-- EVENT CONNECTIONS
-- ==========================================================
LeagueUpdate.OnClientEvent:Connect(function(stats)
	UI_Handler.CurrentLeague = stats
	UI_Handler:SetLeagueStats(stats)
end)

TournamentUpdate.OnClientEvent:Connect(function(data)
	UI_Handler.CurrentTournament = data
	UI_Handler:SetTournamentStats(data)
end)

TournamentResults.OnClientEvent:Connect(function(result)
	local ui = UI_Handler.boundUIs["LeagueTournament"]
	if not ui then return end

	local body = ui.Main_F.Body.Stroke.Content
	local section = body.Tournament_Section
	local frame = section:FindFirstChild("ResultFrame")
	if not frame then return end

	frame.Visible = true
	local label = frame:FindFirstChild("TextLabel")
	if not label then return end

	local rankings = result.Rankings or {}
	table.sort(rankings, function(a, b) return a.Score > b.Score end)

	local out = "Final Results - " .. (result.Division or "?") .. "\n"
	for i, r in ipairs(rankings) do
		out ..= string.format("%d. %s - %d pts\n", i, r.Name, r.Score)
	end

	label.Text = out
end)

-- ==========================================================
-- PUBLIC API
-- ==========================================================
function UI_Handler:GetCurrentLeague()
	return self.CurrentLeague
end

function UI_Handler:GetCurrentTournament()
	return self.CurrentTournament
end

return UI_Handler
]]></ProtectedString>
						<string name="ScriptGuid">{F4F277C7-3B0C-4A24-A16A-446E312986C6}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UI_LeagueTournament_Handler.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0644BDB0C919466E953D9B2EDB790B0E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Elo_Mod.lua
--
--  Description:
--      Elo ranking module. Defines rank tiers (Bronze → Platinum) with
--      icon, color, and Elo ranges. Handles Elo computation, soft caps,
--      and helper utilities to retrieve rank-related data.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-12-14 by Darkzeb
--
--  Version: V2025-12
--
--  Dependencies:
--      - Roblox:
--          * NumberRange
--          * Color3
--          * Player.Player_Data.Elo
--
--  Notes:
--      - Players start at 400 Elo by default
--      - Elo can go below 400 but is capped at 3000
--      - Strong soft cap applied after 2500 Elo
--      - Rank_Data:
--          * Bronze   (0–550 Elo)
--          * Silver   (550–800 Elo)
--          * Gold     (800–1150 Elo)
--          * Emerald  (1150–1600 Elo)
--          * Diamond  (1600–2150 Elo)
--          * Platinum (2150+ Elo)
--
--======================================================================

local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

local Elo_Mod = {}

-- Elo bounds
Elo_Mod.ELO_DIFF_UNIT = 400
Elo_Mod.ELO_MIN = 400  -- Default starting Elo
Elo_Mod.ELO_MAX = 3000 -- Absolute maximum Elo (hard cap)
Elo_Mod.SOFT_CAP_ELO = 2500 

-- Elo modes with different K-factors
Elo_Mod.EloMode = {
	Standard   = { Name = "Standard",   K = 8 },
	League     = { Name = "League",     K = 24 },
	Tournament = { Name = "Tournament", K = 1 },
	Ranked     = { Name = "Ranked",     K = 40 },
}

-- Rank definitions and Elo ranges
local Rank_Data = {
	['Bronze'] = {
		['Index'] = 1,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(0, 550),
		['Color'] = Color3.fromRGB(170, 170, 127)
	},
	
	['Silver'] = {
		['Index'] = 2,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(550, 800),
		['Color'] = Color3.new(1, 1, 1)
	},
	
	['Gold'] = {
		['Index'] = 3,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(800, 1150),
		['Color'] = Color3.fromRGB(255, 170, 0)
	},
	
	['Emerald'] = {
		['Index'] = 4,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(1150, 1600),
		['Color'] = Color3.fromRGB(170, 255, 0)
	},
	
	['Diamond'] = {
		['Index'] = 5, 
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(1600, 2150),
		['Color'] = Color3.new(0, 1, 1)
	},
	
	['Platinum'] = {
		['Index'] = 6,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(2150, math.huge),
		['Color'] = Color3.fromRGB(170, 85, 255)
	},
}

--======================================================================
-- Soft cap logic
-- Strongly reduces Elo gains after 2500, reaching near-zero at 3000
--======================================================================
local function getSoftCappedK(elo, baseK)
	
	-- No reduction below or equal to 2500
	if elo <= Elo_Mod.SOFT_CAP_ELO then
		return baseK
	end

	-- Minimal gain at max Elo
	if elo >= Elo_Mod.ELO_MAX then
		return 1
	end

	-- Linear reduction between 2500 and 3000
	local factor = 1 - ((elo - Elo_Mod.SOFT_CAP_ELO) / (Elo_Mod.ELO_MAX - Elo_Mod.SOFT_CAP_ELO))
	return math.max(1, math.floor(baseK * factor))
end

-- Expected score formula (classic Elo)
local function expectedScore(eloA, eloB)
	return 1 / (1 + 10 ^ ((eloB - eloA) / Elo_Mod.ELO_DIFF_UNIT))
end

-- Computes updated Elo with soft cap and hard max cap
local function getUpdatedElo(oldElo, opponentElo, result, kFactor)
	local effectiveK = getSoftCappedK(oldElo, kFactor)

	local e = expectedScore(oldElo, opponentElo)
	local rawDelta = effectiveK * (result - e)

	-- Ensure minimum absolute Elo change of 1
	local delta
	if rawDelta > 0 then
		delta = math.max(1, math.floor(rawDelta))
	elseif rawDelta < 0 then
		delta = math.min(-1, math.ceil(rawDelta))
	else
		delta = 0
	end

	local newElo = oldElo + delta

	-- Hard cap at max only
	if newElo > Elo_Mod.ELO_MAX then
		newElo = Elo_Mod.ELO_MAX
	end

	return newElo
end

--======================================================================
-- Public API
--======================================================================

-- Returns rank data and Elo value for a player
function Elo_Mod.Get_Player_Rank_Data(Plr)
	if(Plr ~= nil)then
		local Elo_Val = PlayerUtils.GetPlayerVal(Plr, "Elo")
		local Ret_Data = Rank_Data['Bronze']
		Ret_Data['Key'] = "Bronze"

		if(Elo_Val ~= nil)then
			local Elo_Amount = Elo_Val.Value
			for Key, Data in next, Rank_Data do
				local Range = Data['Elo Range']
				if(Range.Min <= Elo_Amount and Range.Max > Elo_Amount)then
					Data['Key'] = Key
					return Data, Elo_Amount
				end
			end
		end
	end
	
	local Ret_Data = Rank_Data['Bronze']
	Ret_Data['Key'] = "Bronze"
	return Ret_Data, Elo_Mod.ELO_MIN
end

-- Returns the next rank based on index
function Elo_Mod.Get_Next_Rank_Data(Current_Index)
	for Key, Data in next, Rank_Data do
		if(Current_Index + 1 == Data['Index'])then
			return Data
		end
	end
	
	return Rank_Data['Platinum']
end

-- Returns rank key and data from an Elo value
function Elo_Mod.Get_Elo_Data_From_Val(Val)
	for Key, Data in next, Rank_Data do
		local Range = Data['Elo Range']
		local Min, Max = Range.Min, Range.Max
		
		if(Val >= Min and Val <= Max)then
			return Key, Data
		end
	end
	
	return "Bronze", Rank_Data['Bronze']
end

-- Computes new Elo values for winner and loser
function Elo_Mod.Compute_Elo(winnerElo, loserElo, mode)
	if not mode then
		mode = Elo_Mod.EloMode.Standard
	end

	local K_Factor = mode.K or Elo_Mod.EloMode.Standard.K

	local newWinnerElo = getUpdatedElo(winnerElo, loserElo, 1, K_Factor)
	local newLoserElo  = getUpdatedElo(loserElo, winnerElo, 0, K_Factor)

	return newWinnerElo, newLoserElo
end

-- Scaling factor for rewards based on Elo difference
function Elo_Mod.Get_Elo_Reward_Scaling(player, opponent)
	local pData = player:FindFirstChild("Player_Data")
	local oData = opponent:FindFirstChild("Player_Data")
	if not pData or not oData then return 1 end

	local pElo = pData:FindFirstChild("Elo") and pData.Elo.Value or 0
	local oElo = oData:FindFirstChild("Elo") and oData.Elo.Value or 0

	local diff = oElo - pElo
	local scaling = 1 + (diff / Elo_Mod.ELO_DIFF_UNIT)
	if scaling < 0.5 then scaling = 0.5 end

	return scaling
end

-- Returns raw Elo difference between two players
function Elo_Mod.Get_Elo_Diff(player, opponent)
	local pData = player:FindFirstChild("Player_Data")
	local oData = opponent:FindFirstChild("Player_Data")
	if not pData or not oData then return 0 end

	local pElo = pData:FindFirstChild("Elo") and pData.Elo.Value or 0
	local oElo = oData:FindFirstChild("Elo") and oData.Elo.Value or 0

	return oElo - pElo
end

-- Returns true if two players are in same or adjacent ranges
function Elo_Mod.Adjacent_Elo_Ranks(player, opponent)
	local p_rank, p_elo = Elo_Mod.Get_Player_Rank_Data(player)
	local o_rank, o_elo = Elo_Mod.Get_Player_Rank_Data(opponent)
	
	local p_rank_idx = p_rank['Index']
	local o_rank_idx = o_rank['Index']
	
	return (p_rank_idx == o_rank_idx) or (p_rank_idx == o_rank_idx + 1) or (p_rank_idx + 1 == o_rank_idx)
end


return Elo_Mod]]></ProtectedString>
						<string name="ScriptGuid">{90CDE4C9-2A22-4120-AFC0-369EC630A85B}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Elo_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2336F3CA895C42AF9B812B944449C58A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Sound_Mod.lua
--
--  Description:
--      Utility module for handling sound effects and voice overs.
--      Provides functions to fetch sounds from PlayerGui, play global
--      server sounds, and manage randomized voice overs with chance
--      and enable/disable settings.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * Debris (cleanup cloned sounds)
--          * Players
--          * ServerStorage.Global_Sounds_F
--      - Player Instances:
--          * PlayerGui.Sound_Effects_F
--          * PlayerGui.Sound_Effects_F.Voice_Over_F
--          * Player.Player_Data["Voice Over"]
--
--  Notes:
--      - funcs API:
--          * PlaySFX(Obj, SE_Name): plays server global sound
--          * Play_Voice_Over(Action_Key): plays random voice clip
--      - Voice Over system:
--          * Controlled by Player_Data["Voice Over"].Value
--          * Chance attribute (%) on Audio_F determines probability
--          * Did_Play attribute avoids replaying same clip
--      - Supports folders of variant sounds (random selection)
--      - Sounds auto-cleaned with Debris after TimeLength + 1s
--
--======================================================================

local Sound_Mod = {}
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")

local AUDIO = ReplicatedStorage:WaitForChild("Audio")

local SFX_FOLDER = AUDIO:WaitForChild("SFX")
local MUSIC_FOLDER = AUDIO:WaitForChild("Music")
local VOICE_FOLDER = AUDIO:WaitForChild("Voice_Over")

---------------------------------------------------------------------
-- SETTINGS
---------------------------------------------------------------------
function Sound_Mod.SFX_Enabled()
	return SoundService:GetAttribute("SFX_Enabled") ~= false
end

function Sound_Mod.Music_Enabled()
	return SoundService:GetAttribute("Music_Enabled") ~= false
end

---------------------------------------------------------------------
-- HELPERS
---------------------------------------------------------------------
local function chooseVariant(obj)
	if obj:IsA("Folder") then
		local list = obj:GetChildren()
		if #list == 0 then
			warn("[SoundEffectMod] Empty folder:", obj.Name)
			return nil
		end
		return list[math.random(1, #list)]
	end
	return obj
end

local function findIn(folder, name)
	local obj = folder:FindFirstChild(name)
	if not obj then
		warn("[SoundEffectMod] Missing sound:", name)
		return nil
	end
	return chooseVariant(obj)
end

function Sound_Mod.PlaySFX(parent, soundName)
	if not Sound_Mod.SFX_Enabled() then return end

	local template = findIn(SFX_FOLDER, soundName)
	if not template then return end

	local c = template:Clone()
	c.Parent = parent or SoundService
	c:Play()

	Debris:AddItem(c, c.TimeLength + 1)
end

local CurrentMusic = nil

function Sound_Mod.PlayMusic(parent, soundName)
	if not Sound_Mod.Music_Enabled() then return end
	
	if CurrentMusic then
		CurrentMusic:Stop()
		CurrentMusic:Destroy()
		CurrentMusic = nil
	end

	local template = findIn(MUSIC_FOLDER, soundName)
	if not template then return end

	local m = template:Clone()
	m.Looped = true
	m.Parent = parent or SoundService
	m:Play()

	CurrentMusic = m
end

function Sound_Mod.StopMusic()
	if CurrentMusic then
		CurrentMusic:Stop()
		CurrentMusic:Destroy()
		CurrentMusic = nil
	end
end

function Sound_Mod.Play_Voice_Over(actionName)
	local plr = Players.LocalPlayer
	if not plr then return end

	local PD = plr:FindFirstChild("Player_Data")
	if not (PD and PD:FindFirstChild("Voice Over") and PD["Voice Over"].Value) then
		return
	end

	local actionFolder = VOICE_FOLDER:FindFirstChild(actionName)
	if not actionFolder then
		warn("[SoundEffectMod] Missing Voice Over action:", actionName)
		return
	end

	local clips = actionFolder:GetChildren()
	if #clips == 0 then return end

	local selected = clips[math.random(1, #clips)]
	local chance = selected:GetAttribute("Chance") or 100

	if selected:GetAttribute("Did_Play") then return end

	if math.random(1, 100) <= chance then
		selected:SetAttribute("Did_Play", true)
		selected:Play()
	end
end

return Sound_Mod]]></ProtectedString>
						<string name="ScriptGuid">{4A812842-3E64-48DC-BE12-80040F5321B5}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Sound_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6934506381114D36931E6DAFDD6FAD81">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Animation_Mod.lua
--
--  Description:
--      Centralized module for all animation data. Defines movement,
--      striking, and combination moves with associated metadata such as
--      asset IDs, power multipliers, reversibility, and purchase cost.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Animation_Objs_F (container for Animation instances)
--
--  Notes:
--      - Movement_Animations: Idle and shuffle moves
--      - Striking_Data: defensive animations (blocks, slips, dodge, etc.)
--      - Combination_Move_Data: offensive moves (punches, kicks) with fight/purchase metadata
--      - Each entry stores Asset ID, reversibility, and fight-related multipliers
--      - Designed for use by Combination_Handle, Core_Fight_Handle, etc.
--
--======================================================================


local Animation_Mod = {}
local Animation_Objs_F = game.ReplicatedStorage:WaitForChild("Animation_Objs_F")

local Movement_Animations = {
	['Idle'] = 108077631566601,
	['Shuffle Side'] = 79375297609893,
	['Shuffle Forward'] = 136948432130840,
	
	--['Shuffle Forward'] = 109207253924129,
	
	--['Shuffle Side'] = 89602830994683,
	--['Shuffle Forward'] = 139861313294402,
}

local Striking_Data = {
	['Taking Hit'] = {
		['ID'] = 87073445720365,
		['Reverses'] = false
	},
	
	['Body Block Left'] = {
		['ID'] = 104895699142546,
		['Reverses'] = true
	},
	
	['Body Block Right'] = {
		['ID'] = 99944482960873,
		['Reverses'] = true
	},
	
	['Slip Left'] = {
		['ID'] = 136849218895282,
		['Reverses'] = true
	},

	['Slip Right'] = {
		['ID'] = 122220718204244,
		['Reverses'] = true
	},
	
	['Dodge Back'] = {
		['ID'] = 94177011723049,
		['Reverses'] = false
	},
	
	['Headblock Left'] = {
		['ID'] = 110779732594817,
		['Reverses'] = true
	},

	['Headblock Right'] = {
		['ID'] = 121662213274181,
		['Reverses'] = true
	},
	
	['Main Block'] = {
		['ID'] = 94238142478294,
		['Reverses'] = true
	},
	
}
--//
-- Punch (8): A,B,C,G,L,M,N,O
-- Kick (10) : D,E,F,H,I,J,K,P,Q,R
local Combination_Move_Data = {
	['A'] = {
		['Name'] = "Cross Punch",
		['Punch'] = true,
		['ID'] = 100227999129843,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://118407716580363",
		['Power Multi'] = 0,
		['Damage'] = 6,
		['Time Length'] = 0.333,
		['Duration'] = "SHORT",
		['Price'] = 0
	},

	['B'] = {
		['Name'] = "Hook Punch",
		['ID'] = 81561131125346,
		['Punch'] = true,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://122669512309567",
		['Power Multi'] = 0.2,
		['Damage'] = 7,
		['Time Length'] = 0.500,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['C'] = {
		['Name'] = "Jab",
		['ID'] = 134317457381878,
		['Punch'] = true,
		['Reverses'] = false,
		['Icon'] = "rbxassetid://100517302134415",
		['Power Multi'] = 0.2,
		['Damage'] = 6,
		['Time Length'] = 0.370,
		['Duration'] = "SHORT",
		['Price'] = 0
	},

	['D'] = {
		['Name'] = "Body Kick",
		['ID'] = 125520199895947,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://94521634377382",
		['Power Multi'] = 0.2,
		['Damage'] = 7,
		['Time Length'] = 0.550,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['E'] = {
		['Name'] = "Head Kick",
		['ID'] = 132422928966701,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://77784698400276",
		['Power Multi'] = 0.1,
		['Damage'] = 8,
		['Time Length'] = 0.600,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['F'] = {
		['Name'] = "Leg Kick",
		['ID'] = 110461738059355,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://102937129099083",
		['Power Multi'] = 0.1,
		['Damage'] = 6,
		['Time Length'] = 0.467,
		['Duration'] = "SHORT",
		['Price'] = 0
	},

	['G'] = {
		['Name'] = "Overhand Punch",
		['ID'] = 131610958973209,
		['Punch'] = true,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://137155984605073",
		['Power Multi'] = 0.4,
		['Damage'] = 8,
		['Time Length'] = 0.767,
		['Duration'] = "LONG",
		['Price'] = 0
	},

	['H'] = {
		['Name'] = "Push Kick",
		['ID'] = 77338767921527,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://120516884574158",
		['Power Multi'] = 0.1,
		['Damage'] = 6,
		['Time Length'] = 0.433,
		['Duration'] = "SHORT",
		['Price'] = 0
	},

	['I'] = {
		['Name'] = "Roundhouse Body Kick",
		['ID'] = 81721721853423,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://133772978433824",
		['Power Multi'] = 0.3,
		['Damage'] = 8,
		['Time Length'] = 0.617,
		['Duration'] = "LONG",
		['Price'] = 0
	},

	['J'] = {
		['Name'] = "Roundhouse Head Kick",
		['ID'] = 79766698080686,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://104985491295539",
		['Power Multi'] = 0.3,
		['Damage'] = 8,
		['Time Length'] = 0.650,
		['Duration'] = "LONG",
		['Price'] = 0
	},

	['K'] = {
		['Name'] = "Roundhouse Leg Kick",
		['ID'] = 138214621139428,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://136613070075301",
		['Power Multi'] = 0.2,
		['Damage'] = 7,
		['Time Length'] = 0.567,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['L'] = {
		['Name'] = "Spinning Backfist",
		['ID'] = 96399865414625,
		['Punch'] = true,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://136613070075301",
		['Power Multi'] = 0.4,
		['Damage'] = 8,
		['Time Length'] = 0.717,
		['Duration'] = "LONG",
		['Price'] = 0
	},

	['M'] = {
		['Name'] = "Uppercut Punch",
		['ID'] = 71389736066050,
		['Punch'] = true,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://83706181409186",
		['Power Multi'] = 0.2,
		['Damage'] = 7,
		['Time Length'] = 0.583,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['N'] = {
		['Name'] = "Elbow Strike",
		['ID'] = 132635065254903,
		['Punch'] = true,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://138866086874937",
		['Power Multi'] = 0.2,
		['Damage'] = 7,
		['Time Length'] = 0.550,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['O'] = {
		['Name'] = "Spinning Elbow Strike",
		['ID'] = 111369637414564,
		['Punch'] = true,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://101103585275656",
		['Power Multi'] = 0.2,
		['Damage'] = 8,
		['Time Length'] = 0.550,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['P'] = {
		['Name'] = "Flying Knee Strike",
		['ID'] = 130784737248262,
		['Punch'] = false,
		['Reverses'] = false,
		['Icon'] = "rbxassetid://105034123942809",
		['Power Multi'] = 0.5,
		['Damage'] = 9,
		['Time Length'] = 0.817,
		['Duration'] = "LONG",
		['Price'] = 0
	},

	['Q'] = {
		['Name'] = "Knee Clinch",
		['ID'] = 81137097576975,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://100038500073272",
		['Power Multi'] = 0,
		['Damage'] = 6,
		['Time Length'] = 0.350,
		['Duration'] = "SHORT",
		['Price'] = 0
	},

	['R'] = {
		['Name'] = "Knee Strike",
		['ID'] = 108737295565365,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://136052094451802",
		['Power Multi'] = 0.2,
		['Damage'] = 7,
		['Time Length'] = 0.517,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},
}



local Takedown_Move_Data = {
	['A'] = {
		['Name'] = "Takedown",
		['Takedown ID'] = 90000582035319,
		['Receiving ID'] = 137215852579263,
		['CF Offset'] = CFrame.new(Vector3.new(0.4881000518798828, 0.00011396408081054688, -3.292452335357666)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Time Length'] = 1.02,
		['Price'] = 0
	},
	
	['B'] = {
		['Name'] = "Suplex",
		['Takedown ID'] = 96292674087311,
		['Receiving ID'] = 124116836479443,
		['CF Offset'] = CFrame.new(Vector3.new(0.4881000518798828, 0.00011396408081054688, -3.292452335357666)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Time Length'] = 2.07,
		['Price'] = -1
	},
}

local Submission_Hold_Data = {
	['A'] = {
		['Name'] = "Armbar",
		['Submission ID'] = 77995795549949,
		['Submission Loop ID'] = 131555693143885,
		['Receiving ID'] = 135512944211258,
		['Receiving Loop ID'] = 114826200035426,
		['CF Offset'] = CFrame.new(Vector3.new(-0.2868995666503906, 0.00011396408081054688, -3.292452335357666)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = 0
	},
	
	['B'] = {
		['Name'] = "Bow + Arrow Choke",
		['Submission ID'] = 75355863213565,
		['Submission Loop ID'] = 85715488163612,
		['Receiving ID'] = 82374638588189,
		['Receiving Loop ID'] = 123114250253699,
		['CF Offset'] = CFrame.new(Vector3.new(-0.116668701171875, 0.25331592559814453, 1.6584720611572266)) * CFrame.Angles(-0, 0, -0),
		['Price'] = 0
	},
	
	['C'] = {
		['Name'] = "Rear Choke",
		['Submission ID'] = 132773296535203,
		['Submission Loop ID'] = 125823752907571,
		['Receiving ID'] = 124306025776879,
		['Receiving Loop ID'] = 77790217013197,
		['CF Offset'] = CFrame.new(Vector3.new(-0.0677032470703125, 0.16611409187316895, 0.8032341003417969)) * CFrame.Angles(-0, 0, -0),
		['Price'] = -1
	},
	
	['D'] = {
		['Name'] = "D'Acre Choke",
		['Submission ID'] = 119311130373519,
		['Submission Loop ID'] = 125304925445976,
		['Receiving ID'] = 80700787386082,
		['Receiving Loop ID'] = 120536455540110,
		['CF Offset'] = CFrame.new(Vector3.new(0.3773040771484375, 0.00011396408081054688, -7.310765266418457)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},

	['E'] = {
		['Name'] = "Peruvian Necktie",
		['Submission ID'] = 80067783627585,
		['Submission Loop ID'] = 122521525908433,
		['Receiving ID'] = 92103429555208,
		['Receiving Loop ID'] = 83941364350231,
		['CF Offset'] = CFrame.new(Vector3.new(-1.8148994445800781, 0.00011396408081054688, -5.270452499389648)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
	
	['F'] = {
		['Name'] = "Crucifix Choke",
		['Submission ID'] = 136852003392692,
		['Submission Loop ID'] = 138253407435423,
		['Receiving ID'] = 84266203794329,
		['Receiving Loop ID'] = 133824539813558,
		['CF Offset'] = CFrame.new(Vector3.new(-2.4148998260498047, 0.00011396408081054688, -0.8284523487091064)) * CFrame.Angles(-0, math.rad(-90), 0),
		['Price'] = -1
	},
	
	['G'] = {
		['Name'] = "Ezekiel Choke",
		['Submission ID'] = 138151382939604,
		['Submission Loop ID'] = 87342228644616,
		['Receiving ID'] = 130331156841132,
		['Receiving Loop ID'] = 130320679529339,
		['CF Offset'] = CFrame.new(Vector3.new(-0.009899139404296875, 0.00011396408081054688, 2.3495476245880127)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
	
	['H'] = {
		['Name'] = "North-South Choke",
		['Submission ID'] = 120276704304047,
		['Submission Loop ID'] = 101002039631767,
		['Receiving ID'] = 93330579903894,
		['Receiving Loop ID'] = 139785195887722,
		['CF Offset'] = CFrame.new(Vector3.new(4.597099304199219, 0.00011396408081054688, 4.539547920227051)) * CFrame.Angles(0, math.rad(90), 0),
		['Price'] = -1
	},
	
	['I'] = {
		['Name'] = "Anaconda Choke",
		['Submission ID'] = 139254908975474,
		['Submission Loop ID'] = 123395024978060,
		['Receiving ID'] = 107198374601193,
		['Receiving Loop ID'] = 108362674273214,
		['CF Offset'] = CFrame.new(Vector3.new(0.1930999755859375, 0.00011396408081054688, -4.3244524002075195)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
	
	['J'] = {
		['Name'] = "Guillotine Choke",
		['Submission ID'] = 125216184549242,
		['Submission Loop ID'] = 140031549975052,
		['Receiving ID'] = 122205044713456,
		['Receiving Loop ID'] = 135121330657191,
		['CF Offset'] = CFrame.new(Vector3.new(-0.189697265625, 0.00011396408081054688, 0.0002346038818359375)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
	
	['K'] = {
		['Name'] = "Triangle Choke",
		['Submission ID'] = 89703608283013,
		['Submission Loop ID'] = 124327589301499,
		['Receiving ID'] = 73462023202758,
		['Receiving Loop ID'] = 94751838108470,
		['CF Offset'] = CFrame.new(Vector3.new(-0.5547027587890625, 0.00011396408081054688, -0.09476470947265625)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
}

local Cage_Clinch_Data = {
	['A'] = {
		['Name'] = "Clinch Init",
		['ID'] = 80784815674908,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = true,
		['Link Key'] = "F",
	},
	
	['B'] = {
		['Name'] = "Clinch Loop",
		['ID'] = 87962198986708,
		['Reverses'] = false,
		['Looped'] = true,
		['Attacking'] = true,
		['Link Key'] = "G",
	},
	
	['C'] = {
		['Name'] = "High Knee",
		['ID'] = 132795144177389,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = true,
		['Link Key'] = "H",
	},
	
	['D'] = {
		['Name'] = "Low Knee",
		['ID'] = 93673806124998,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = true,
		['Link Key'] = "I",
	},
	
	['E'] = {
		['Name'] = "Uppercut",
		['ID'] = 99286997711377,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = true,
		['Link Key'] = "J",
	},


	['F'] = {
		['Name'] = "Clinch Init Target",
		['ID'] = 139067262581330,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = false,
		['Link Key'] = "A",
	},

	['G'] = {
		['Name'] = "Clinch Loop Target",
		['ID'] = 99857009954124,
		['Reverses'] = false,
		['Looped'] = true,
		['Attacking'] = false,
		['Link Key'] = "B",
	},

	['H'] = {
		['Name'] = "High Knee Target",
		['ID'] = 136345233529547,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = false,
		['Link Key'] = "C",
	},

	['I'] = {
		['Name'] = "Low Knee Target",
		['ID'] = 126512754019218,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = false,
		['Link Key'] = "D",
	},

	['J'] = {
		['Name'] = "Uppercut Target",
		['ID'] = 71592715011713,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = false,
		['Link Key'] = "E",
	},
}

local Emote_Data = {
	['A'] = {
		['Name'] = "Flexing",
		['ID'] = 10713990381,
		['Icon'] = "rbxassetid://129785468776058",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['B'] = {
		['Name'] = "Dolphin Dance",
		['ID'] = 10714068222,
		['Icon'] = "rbxassetid://110318046103048",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['C'] = {
		['Name'] = "1-2 Combo",
		['ID'] = 10717116749,
		['Icon'] = "rbxassetid://129775502633259",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['D'] = {
		['Name'] = "Flossing",
		['ID'] = 10714340543,
		['Icon'] = "rbxassetid://117551617182244",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['E'] = {
		['Name'] = "Break Dance",
		['ID'] = 18526288497,
		['Icon'] = "rbxassetid://109576668333205",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['F'] = {
		['Name'] = "Backflip",
		['ID'] = 15693621070,
		['Icon'] = "rbxassetid://113129464009404",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['G'] = {
		['Name'] = "Monkey",
		['ID'] = 10714388352,
		['Icon'] = "rbxassetid://140702511165691",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['H'] = {
		['Name'] = "Frosty Flair",
		['ID'] = 10214311282,
		['Icon'] = "rbxassetid://111762236681762",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['I'] = {
		['Name'] = "Wild Stuff",
		['ID'] = 18665811005,
		['Icon'] = "rbxassetid://76044186658278",
		['Price'] = 10,
		['Reverses'] = false
	},
	
	['J'] = {
		['Name'] = "Zab",
		['ID'] = 129470135909814,
		['Icon'] = "rbxassetid://116534530149694",
		['Price'] = 10,
		['Reverses'] = false
	},
	
	['K'] = {
		['Name'] = "Robot",
		['ID'] = 10714392151,
		['Icon'] = "rbxassetid://108233046384117",
		['Price'] = 10,
		['Reverses'] = false
	},
}

local function Get_Player_Val(Plr, Key, Get_Object)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		local V = PD:FindFirstChild(Key)
		if(Get_Object)then
			return V
		else
			return V.Value
		end
		
	end
	
	return nil
end

local function Get_Animation_Track(Hum, Name, ID)
	local function Create_Animation_Object()
		local Ani_Obj = Animation_Objs_F:FindFirstChild(Name .. "_Ani")
		if(Ani_Obj == nil)then
			Ani_Obj = Instance.new("Animation", Animation_Objs_F)
			Ani_Obj.Name = Name .. "_Ani"
			Ani_Obj.AnimationId = "rbxassetid://" .. ID
		end
		return Ani_Obj
	end
	local Ani_Obj = Create_Animation_Object()
	return Hum:LoadAnimation(Ani_Obj)
end

function Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Tack_Data = {
		
	}
	
	for Key, ID in next, Movement_Animations do
		Anim_Tack_Data[Key] = Get_Animation_Track(Hum, Key, ID)
	end
	
	return Anim_Tack_Data
end

function Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Anim_Tack_Data = {

	}

	for Key, Anim_Data in next, Striking_Data do
		local Anim_T = Get_Animation_Track(Hum, Key, Anim_Data['ID'])
		local Is_Reversing = Anim_Data['Reverses'] or false
		Anim_T:SetAttribute("Reverses", Is_Reversing)
		
		Anim_Tack_Data[Key] = Anim_T
	end

	return Anim_Tack_Data
end

function Animation_Mod.Get_Strike_Combo_Data(Strike_Key)
	if(Combination_Move_Data[Strike_Key] ~= nil)then
		return Combination_Move_Data[Strike_Key]
	end
	return Combination_Move_Data['A']
end

function Animation_Mod.Get_Takedown_Action_Data(Key)
	if Takedown_Move_Data[Key] ~=nil then 
		return Takedown_Move_Data[Key]
	end
	return Takedown_Move_Data['A']
end

function Animation_Mod.Get_Submission_Action_Data(Key)
	if Submission_Hold_Data[Key] ~=nil then 
		return Submission_Hold_Data[Key]
	end
	return Submission_Hold_Data['A']
end



local function Player_Owns_Strike_Key_Check(Plr, Strike_Key)
	local Strike_Data = Combination_Move_Data[Strike_Key]
	if(Strike_Data ~= nil and Strike_Data['Price'] ~= nil and Strike_Data['Price'] > 0)then
		local Owned_Strikes_V = Get_Player_Val(Plr, "Owned Special Strikes", false) or ""
		local Owned_Strikes_Keys = string.split(Owned_Strikes_V, ",")

		if(Owned_Strikes_Keys ~= nil and table.find(Owned_Strikes_Keys, Strike_Key) == nil)then
			return false
		end
	end

	return true
end

function Animation_Mod.Player_Owns_Strike_Key(Plr, Strike_Key)
	return Player_Owns_Strike_Key_Check(Plr, Strike_Key)
end


function Animation_Mod.Get_Striking_Combination_Tracks(Plr, Hum, Combo_Name)
	local Owned_Strikes_V = Get_Player_Val(Plr, "Owned Special Strikes", false) or ""
	local Owned_Strikes_Keys = string.split(Owned_Strikes_V, ",")
	
	local function Player_Owns_Combo(C_Data, Key)
		if(C_Data['Price'] ~= nil and C_Data['Price'] > 0 and 
			table.find(Owned_Strikes_Keys, Key) == nil)then

			return false
		end
		return true
	end
	
	local Combo_String = ""
	if Combo_Name == "Bot Combo"  then
		Combo_String = "C,A,E,C,A,H"
	else 
		Combo_String= Get_Player_Val(Plr, Combo_Name, false)
	end
	
	local Ani_Tracks = {}
	if(Combo_String ~= nil)then
		local Clean_Combo_Str = string.gsub(Combo_String, " ", "")
		local Str_Split = string.split(Clean_Combo_Str, ",")

		for i = 1, #Str_Split do
			local Ani_Key = Str_Split[i]
			if(Combination_Move_Data[Ani_Key] ~= nil)then
				local C_Data = Combination_Move_Data[Ani_Key]
				local Ani_Name, Ani_ID = C_Data['Name'], C_Data['ID']

				if(Ani_Name ~= nil and Ani_ID ~= nil and Player_Owns_Combo(C_Data, Ani_Key))then
					local Ani_T = Get_Animation_Track(Hum, Ani_Name, Ani_ID)
					local Is_Reversing = C_Data['Reverses']
					Ani_T:SetAttribute("Reverses", Is_Reversing)
					Ani_T:SetAttribute("Strike_Key", Ani_Key)

					table.insert(Ani_Tracks, Ani_T)
				end
			end
		end
	end
	
	return Ani_Tracks
end

local function Get_Punch_Data(Is_Punch)
	local moves = {}
	for key, data in pairs(Combination_Move_Data) do
		if data.Punch == Is_Punch then
			moves[key] = data
		end
	end
	return moves
end

function Animation_Mod.Get_Combinations(Tble)
	if Tble == "Combination" then
		return Combination_Move_Data
	elseif Tble == "Punch" then
		return Get_Punch_Data(true)
	elseif Tble == "Kick" then
		return Get_Punch_Data(false)
	elseif Tble == "Submission" then
		return Submission_Hold_Data
	elseif Tble == "Takedown" then
		return Takedown_Move_Data
	elseif Tble == "Emotes" then
		return Emote_Data
	end
	return nil
end

function Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_ID, Submission_ID, Submission_Loop_ID)
	local function Create_Track_To_Return(ID)
		local Track = Get_Animation_Track(Hum, ID, ID)
		if(Track ~= nil)then
			Track:SetAttribute("Reverses", false)
			return Track
		end
		return nil
	end
	local Takedown_Track = Create_Track_To_Return(Takedown_ID)
	local Submission_Track = Create_Track_To_Return(Submission_ID)
	
	local Submission_Loop_Track = Create_Track_To_Return(Submission_Loop_ID)
	if(Submission_Loop_Track ~= nil)then
		Submission_Loop_Track.Looped = true
	end
	
	return Takedown_Track, Submission_Track, Submission_Loop_Track
end

function Animation_Mod.Player_Owns_Submission_Key_Check(Plr, Strike_Key)
	local Submission_Data = Submission_Hold_Data[Strike_Key]
	
	if (Submission_Data ~= nil and Submission_Data['Price'] and Submission_Data['Price'] == 0) then 
		return true 
	end
	
	if(Submission_Data ~= nil and Submission_Data['Price'] ~= nil and Submission_Data['Price'] ~= 0)then
		local Owned_Submission_V = Get_Player_Val(Plr, "Owned Special Submissions", false) or ""
		local Owned_Submission_Keys = string.split(Owned_Submission_V, ",")
		
		if (Owned_Submission_Keys == nil) then return false end

		if(Owned_Submission_Keys ~= nil and table.find(Owned_Submission_Keys, Strike_Key) == nil) then
			return false
		end
		
	end

	return true
end

function Animation_Mod.Player_Owns_Takedown_Key_Check(Plr, Strike_Key)
	local Takedown_Data = Takedown_Move_Data[Strike_Key]

	if (Takedown_Data ~= nil and Takedown_Data['Price'] and Takedown_Data['Price'] == 0) then 
		return true 
	end

	if(Takedown_Data ~= nil and Takedown_Data['Price'] ~= nil and Takedown_Data['Price'] ~= 0)then
		local Owned_Submission_V = Get_Player_Val(Plr, "Owned Special Takedowns", false) or ""
		local Owned_Submission_Keys = string.split(Owned_Submission_V, ",")

		if (Owned_Submission_Keys == nil) then return false end

		if(Owned_Submission_Keys ~= nil and table.find(Owned_Submission_Keys, Strike_Key) == nil) then
			return false
		end

	end

	return true
end

function Animation_Mod.Get_Unlockable_Submission_Keys(Plr)
	local Keys = {}
	if(Plr ~= nil)then
		--Takedowns
		for T_Keys, T_Data in next, Takedown_Move_Data do
			if(Animation_Mod.Player_Owns_Submission_Key_Check(Plr, T_Keys) == false)then
				table.insert(Keys, T_Keys)
			end
		end
		
		--Submissions
		for S_Keys, S_Data in next, Submission_Hold_Data do
			if(Animation_Mod.Player_Owns_Submission_Key_Check(Plr, S_Keys) == false)then
				table.insert(Keys, S_Keys)
			end
		end
	end
	
	return Keys
end

function Animation_Mod.Get_Unlockable_Strike_Keys(Plr)
	local Keys = {}
	if(Plr ~= nil)then
		for S_Key, S_Data in next, Combination_Move_Data do
			if(Player_Owns_Strike_Key_Check(Plr, S_Key) == false)then
				table.insert(Keys, S_Key)
			end
		end
	end
	
	return Keys
end

function Animation_Mod.Get_Special_Submission_Data(Key)
	--Either Takedown or Submission
	if(Takedown_Move_Data[Key] ~= nil and Takedown_Move_Data[Key]['Price'] ~= nil 
		and Takedown_Move_Data[Key]['Price'] ~= 0)then
		
		return Takedown_Move_Data[Key]
		
	elseif(Submission_Hold_Data[Key] ~= nil and Submission_Hold_Data[Key]['Price'] ~= nil
		and Submission_Hold_Data[Key]['Price'] ~= 0)then
		
		return Submission_Hold_Data[Key]
	end
	
	return nil
end

local function Player_Owns_Emote(Plr, Key)
	local Owned_Keys = Get_Player_Val(Plr, "Owned Emotes", false)
	if(Owned_Keys ~= nil)then
		local Keys = string.split(Owned_Keys, ",")
		if(Emote_Data[Key]["Price"] <= 0) then
			return true
		elseif(Keys ~= nil and #Keys > 0 and table.find(Keys, Key) ~= nil)then
			return true
		end
	end
	
	return false -- replace to False after Demo Testing
end

function Animation_Mod.Player_Owns_Emote_Key(Plr, Key)
	return Player_Owns_Emote(Plr,Key)
end

function Animation_Mod.Get_Unlockable_Emotes(Plr)
	local Keys = {}
	if(Plr ~= nil)then
		local Ignore_Keys_Due_To_Gamepass = {"I", "J", "K"}
		for E_Key, E_Data in next, Emote_Data do
			if(table.find(Ignore_Keys_Due_To_Gamepass, E_Key) == nil and 
				Player_Owns_Emote(Plr, E_Key) == false)then
				
				table.insert(Keys, E_Key)
			end
		end
	end
	
	return Keys
end

function Animation_Mod.Get_Emote_Data_From_Key(Key)
	return Emote_Data[Key]
end

function Animation_Mod.Play_Emote_Track_From_Key(Plr, Hum, Key, Is_Looped)
	if(Plr ~= nil and Hum ~= nil and Emote_Data[Key] ~= nil and Emote_Data[Key]['ID'] ~= nil and 
		Emote_Data[Key]['Name'] ~= nil and Player_Owns_Emote(Plr, Key))then
		
		local E_Data = Emote_Data[Key]
		local Track = Get_Animation_Track(Hum, E_Data['Name'], E_Data['ID'])
		if(Track ~= nil)then
			Track.Looped = Is_Looped
			Track.Priority = Enum.AnimationPriority.Action
			Track:Play()
		end
		
	end
end

function Animation_Mod.Force_Play_Emote_Track_From_Key(Hum, Key, Is_Looped)
	local E_Data = Emote_Data[Key]
	local Track = Get_Animation_Track(Hum, E_Data['Name'], E_Data['ID'])
	if(Track ~= nil)then
		Track.Looped = Is_Looped
		Track.Priority = Enum.AnimationPriority.Action
		Track:Play()
	end
end

local function Get_Takedown_Submission_Keys(Attacking_Char)
	if(Attacking_Char ~= nil and game.Players:GetPlayerFromCharacter(Attacking_Char) ~= nil)then
		local A_Plr = game.Players:GetPlayerFromCharacter(Attacking_Char)
		local Takedown_Key = Get_Player_Val(A_Plr, "Takedown Key", false)
		local Submission_Key = Get_Player_Val(A_Plr, "Submission Key", false)

		if(Takedown_Key ~= nil and Submission_Key ~= nil)then
			return Takedown_Key, Submission_Key
		end
	end

	return "A", "A"
end

function Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)
	local Takedown_Key, Submission_Key = Get_Takedown_Submission_Keys(Attacking_Char)
	return Takedown_Move_Data[Takedown_Key], Submission_Hold_Data[Submission_Key]
end

function Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
	local function Get_Specific_Clinch_Track(Key)
		local Data = Cage_Clinch_Data[Key]
		if(Data ~= nil and Data['ID'] ~= nil and Data['Name'] ~= nil)then
			if(Is_Attacking == false and Data['Link Key'] ~= nil)then
				local New_Data_Key = Data['Link Key']
				local New_Data = Cage_Clinch_Data[New_Data_Key]
				if(New_Data ~= nil and New_Data['ID'] ~= nil and New_Data['Name'] ~= nil)then
					Data = New_Data
				end
			end
			
			return Get_Animation_Track(Hum, Data['Name'], Data['ID'])
		end
		
		return nil
	end
	
	return {
		['Init_Clinch'] = Get_Specific_Clinch_Track("A"),
		['Loop_Clinch'] = Get_Specific_Clinch_Track("B"),
		
		['C'] = Get_Specific_Clinch_Track("C"),
		['D'] = Get_Specific_Clinch_Track("D"),
		['E'] = Get_Specific_Clinch_Track("E")
	}
end

function Animation_Mod.Generate_Clinch_Attack_Keys()
	local Can_Use_Keys = {"C", "D", "E"}
	local Key_Data = {}
	
	for i = 1, 5 do
		local Picked_Key = Can_Use_Keys[math.random(1, #Can_Use_Keys)]
		table.insert(Key_Data, Picked_Key)
	end
	
	return Key_Data
end

function Animation_Mod.Stop_Animation_Tracks(Anim_Tracks, Ignore_List)
	for i = 1, #Anim_Tracks do
		local Ani_T = Anim_Tracks[i]
		if(Ani_T ~= nil and Ani_T.IsPlaying == true and table.find(Ignore_List, Ani_T) == nil)then
			Ani_T:Stop()
		end
	end
end

function Animation_Mod.Play_Animation_Track(Anim_Track, Should_Pause)
	local Is_Reverse = Anim_Track:GetAttribute("Reverses")
	Anim_Track:Play()
	Anim_Track:AdjustSpeed(1)
	
	if(Is_Reverse ~= nil and Is_Reverse == true)then
		wait(Anim_Track.Length * 0.99)

		Anim_Track:Play(0.100000001, 1, -1)
		Anim_Track:AdjustSpeed(-1)
	end
	
	if(Should_Pause ~= nil and Should_Pause)then
		wait(Anim_Track.Length * 0.95)
		Anim_Track:AdjustSpeed(0)
	else
		wait(Anim_Track.Length)
	end
	
end

function Animation_Mod.Play_Blocking_Track(Anim_Track)
	Anim_Track:Play()
	Anim_Track:AdjustSpeed(1)
	wait(Anim_Track.Length * 0.99)
	Anim_Track:AdjustSpeed(0)
end

local function Reset_Char_Animations(Char)
	local Hum = Char:FindFirstChild("Humanoid")
	if(Hum ~= nil)then
		local Ani_Tracks = Hum:GetPlayingAnimationTracks()
		for i = 1, #Ani_Tracks do
			if(Ani_Tracks[i] ~= nil and string.match(Ani_Tracks[i].Name, "Anim") == nil)then
				Ani_Tracks[i]:Stop()
				Ani_Tracks[i]:Destroy()
			end
		end
	end
end

function Animation_Mod.Reset_Character_Animations(Char)
	Reset_Char_Animations(Char)
end

function Animation_Mod.Player_Owns_Action(Plr, Action_Type, Action_Key)
	if Action_Type == "Submission" then
		return Animation_Mod.Player_Owns_Submission_Key_Check(Plr, Action_Key)
	elseif Action_Type == "Takedown" then
		return Animation_Mod.Player_Owns_Takedown_Key_Check(Plr, Action_Key)
	elseif Action_Type == "Emote" then
		return Animation_Mod.Player_Owns_Emote_Key(Plr, Action_Key)
	else
		return Animation_Mod.Player_Owns_Strike_Key(Plr, Action_Key)
	end
	
end

return Animation_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{96ACA647-A4CD-48F3-B204-409FE041C325}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Animation_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX30C85FF6697441D59E8F10FF9116B6AD">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Stats_Manager_Mod.lua
--
--  Description:
--      Utility module for managing player stats and compiling fight
--      recap data. Provides functions to read/write Player_Data stats,
--      initialize fight data structures, and generate match summaries.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * Players
--      - Player Instances:
--          * Player.Player_Data (contains stat values)
--
--  Notes:
--      - funcs API:
--          * Add_To_Player_Stats_Data(Plr, Key, Inc)
--          * Set_Player_Stats_Data(Plr, Key, Val)
--          * Create_Fight_Data_Structure(Char): returns dict of stats
--          * Compile_Fight_Recap_Data(Init, Final, Win): returns diff recap
--      - Stats tracked include:
--          * Total Strikes, Strikes Landed, Dodged Strikes
--          * Takedowns Landed/Attempted
--          * Submissions Finished/Attempted
--          * Punch Knockout Wins, Leg Knockout Wins
--      - Fight recap computes differences and win count per fighter
--
--======================================================================


local Stats_Manager_Mod = {}

local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

local function Add_To_Player_Data(Plr, Key, Inc)
	local Val = PlayerUtils.GetPlayerVal(Plr, Key)
	if(Val ~= nil)then
		Val.Value += Inc
		
		if(Val.Value < 0)then
			Val.Value = 0
		end
	end
end

local function Set_To_Player_Data(Plr, Key, V)
	local Val = PlayerUtils.GetPlayerVal(Plr, Key)
	if(Val ~= nil)then
		Val.Value = V
	end
end

local function Compile_Fight_Recap_Data(Init_Data, Final_Data, Win_Data)	
	local function Get_Difference(Key)
		local F_Val = Final_Data[Key] or 0
		local I_Val = Init_Data[Key] or 0
		local Dif = F_Val - I_Val

		if(Dif < 0)then
			Dif = 0
		end

		return Dif
	end

	local function Count_Wins()
		local fighterName:string = Init_Data['Name']:gsub("@","")
		if(Win_Data ~= nil and #Win_Data > 0)then
			local Count = 0

			for _,thisName in Win_Data do
				if thisName == fighterName then
					Count += 1
				end
			end

			return Count
		end

		return 0
	end

	return {
		['ID'] = Init_Data['ID'],
		['Name'] = Init_Data['Name'],
		['DisplayName'] = Init_Data['DisplayName'],
		['Wins'] = Count_Wins(),
		['Total Strikes'] = Get_Difference("Strikes Landed") .. " / " .. Get_Difference("Total Strikes"),
		['Total Dodges'] = Get_Difference("Dodged Strikes"),
		['Knockouts'] = Get_Difference("Punch Knockout Wins") + Get_Difference("Leg Knockout Wins"),
		['Takedowns'] = Get_Difference("Takedowns Landed") .. " / " .. Get_Difference("Takedowns Attempted"),
		['Submissions'] = Get_Difference("Submissions Finished") .. " / " .. Get_Difference("Submissions Attempted"),
	}
end

function Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, Key, Inc)
	if(game.Players.LocalPlayer == nil and Plr ~= nil)then
		task.spawn(Add_To_Player_Data, Plr, Key, Inc)
	end
end

function Stats_Manager_Mod.Set_Player_Stats_Data(Plr, Key, Val)
	if(game.Players.LocalPlayer == nil and Plr ~= nil)then
		task.spawn(Set_To_Player_Data, Plr, Key, Val)
	end
end

function Stats_Manager_Mod.Create_Fight_Data_Structure(Char)
	local charName = "Player"
	
	if not Char then
		warn("Char param required")
	else
		if 	Char:GetAttribute("IsBot") then
			charName = Char:GetAttribute("Display_Name")
		else	
			charName = Char.Name
		end
	end
	
	local Data = {
		['ID'] = -1,
		['Name'] = `{charName}`,
		['DisplayName'] =`{charName}`,
		['Total Strikes'] = 0,
		['Strikes Landed'] = 0,
		['Dodged Strikes'] = 0,
		['Takedowns Landed'] = 0,
		['Takedowns Attempted'] = 0,
		['Submissions Finished'] = 0,
		['Submissions Attempted'] = 0,
		['Punch Knockout Wins'] = 0,
		['Leg Knockout Wins'] = 0
	}
	
	-- TODO retrieve bot stats (need to be added into behaviors ...)
	
	if(Char ~= nil and game.Players:GetPlayerFromCharacter(Char) ~= nil)then
		local Plr = game.Players:GetPlayerFromCharacter(Char)
		for Key, Init_V in Data do
			local P_Val = PlayerUtils.GetPlayerVal(Plr, Key)
			if not P_Val then
				continue
			end
			
			if(P_Val ~= nil)then
				Data[Key] = P_Val.Value
			end
		end
		
		Data['Name'] = "@" .. Plr.Name
		Data['DisplayName'] = Plr.DisplayName
		Data['ID'] = Plr.UserId
	end
	
	return Data
end

function Stats_Manager_Mod.Create_Fight_Result_Data(Init_C1, Init_C2, Final_C1, Final_C2, Round_Result_Arr, C1_Won)
	if(C1_Won)then
		return {
			['Winner'] = Compile_Fight_Recap_Data(Init_C1, Final_C1, Round_Result_Arr),
			['Loser'] = Compile_Fight_Recap_Data(Init_C2, Final_C2, Round_Result_Arr)
		}
	else
		return {
			['Loser'] = Compile_Fight_Recap_Data(Init_C1, Final_C1, Round_Result_Arr),
			['Winner'] = Compile_Fight_Recap_Data(Init_C2, Final_C2, Round_Result_Arr)
		}
	end
end

return Stats_Manager_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{588D64EC-9496-4A69-A082-6A3649049A09}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Stats_Manager_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0D6770042BCB434C8AE998C0BAEECAC4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Clothing_Mod.lua
--
--  Description:
--      Defines cosmetic item data for gloves and shorts. Provides
--      mappings between item keys and display names, grouped by crates
--      (Tape, Country, Urban, Fury, Underground, Chromatic, etc.).
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Models/Clothing_F/Shorts_F
--          * Models/Clothing_F/Gloves_F
--
--  Notes:
--      - Gloves_Data maps keys to glove names
--      - Shorts_Data maps keys to shorts names
--      - Utility function Get_Data_Keys() returns CSV of all keys
--      - Used by Shop_Handle, Combination_Handle, Core_Character_Handle, etc.
--
--======================================================================


local Clothing_Mod = {}

local PlayerUtils	= require(game.ReplicatedStorage.Modules.PlayerUtils)

local Clothing_F 	= game.ReplicatedStorage:WaitForChild("Models"):WaitForChild("Clothing_F")
local Shorts_F 		= Clothing_F:WaitForChild("Shorts_F")
local Gloves_F 		= Clothing_F:WaitForChild("Gloves_F")

local Gloves_Data = {
	--// Default
	['A'] = "MMA Gloves",
	--// Tape Crate
	['B'] = "Black Tape",
	['C'] = "Blue Tape",
	['D'] = "Green Tape",
	['E'] = "Red Tape",
	['F'] = "Tan Tape",
	['G'] = "White Tape",
	['H'] = "Purple Tape",
	
	--// Gloves Crate 
	['I'] = "Blue Gloves",
	['J'] = "Green Gloves",
	['K'] = "Mystic Gloves",
	['L'] = "Purple Gloves",
	
	--// Country Crate #1
	['M'] = "Argentinian Gloves",
	['N'] = "Australian Gloves",
	['O'] = "Brazilian Gloves",
	['P'] = "Canadian Gloves",
	['Q'] = "Chilean Gloves",
	['R'] = "Chinese Gloves",
	['S'] = "English Gloves",
	--// Country Crate #2
	['T'] = "French Gloves",
	['U'] = "Georgian Gloves",
	['V'] = "Italian Gloves",
	['W'] = "Jamacian Gloves",
	['X'] = "Japanese Gloves",
	['Y'] = "Mexican Gloves",
	['Z'] = "Moldovan Gloves",

	--// Country Crate #3
	['A1'] = "Nigerian Gloves",
	['B1'] = "Polish Gloves",
	['C1'] = "New Zealand Gloves",
	['D1'] = "Russian Gloves",
	['E1'] = "Spanish Gloves",
	['F1'] = "USA Gloves",
	
	['G1'] = "Orange Gloves",
	['H1'] = "White Gloves",
	
	-- Urban Gloves
	['I1'] = "Graffiti Gloves",
	['J1'] = "Iron Gloves",
	['K1'] = "Gold Gloves",
	['L1'] = "Corrupted Purple Gloves",
	['M1'] = "Corrupted Green Gloves",
	['N1'] = "Corrupted Black Gloves",
	
	-- Fury Crate 1
	['O1'] = "Plastic Green Tape",
	['P1'] = "Plastic Blue Tape",
	['Q1'] = "Plastic Pink Tape",
	['R1'] = "Frozen Chain Tape",
	['S1'] = "Molten Chain Tape",
	['T1'] = "Carbon Chain Tape",

	-- Underground Crate 1
	['U1'] = "Plastic Green Gloves",
	['V1'] = "Plastic Blue Gloves",
	['W1'] = "Plastic Pink Gloves",
	['X1'] = "Blue Flame Gloves",
	['Y1'] = "Lava Gloves",
	['Z1'] = "Carbon Gloves",
	

	['A2'] = "Chromatic Green Gloves",
	['B2'] = "Chromatic Blue Gloves",
	['C2'] = "Chromatic Pink Gloves",
	
	['D2'] = "Chromatic Green Tape",
	['E2'] = "Chromatic Blue Tape",
	['F2'] = "Chromatic Pink Tape",

	['G2'] = "Fury Gloves",
	
	-- New Gloves
	['H2'] = "Spiderman Red Blue",
	['I2'] = "Spiderman Blue Red",
	['J2'] = "Spiderman Red Black",
	['K2'] = "Spiderman Black Red",
	['L2'] = "Hungary Gloves",
	['M2'] = "Thailand Gloves",
	
	
}

-- Unified rarity color table 
local RARITY_COLORS = {
	Platinum = Color3.fromRGB(255,170,255),
	Special  = Color3.fromRGB(255,170,255),
	Diamond  = Color3.fromRGB(150,255,255),
	Gold     = Color3.fromRGB(255,215,0),
	Silver   = Color3.fromRGB(217,217,217),
	Bronze   = Color3.fromRGB(196,124,57),
	Default  = Color3.fromRGB(255,255,255),
	Common   = Color3.fromRGB(255,255,255)
}

local RARITY_ORDER = {
	Platinum = 1,
	Diamond  = 2,
	Gold     = 3,
	Silver   = 4,
	Bronze   = 5,
	Common   = 6,
	Default  = 7,
	Special  = 1, -- même rang que Platinum
}

function Clothing_Mod.Get_Rarity_Order(rarity)
	return RARITY_ORDER[rarity] or 99
end

function Clothing_Mod.Get_Rarity_Color(rarity)
	return RARITY_COLORS[rarity] or RARITY_COLORS.Default
end

local Shorts_Data = {
	['A'] = "MMA Shorts",
	['B'] = "Karate Shorts",
	['C'] = "Denim",
	['D'] = "Dragon Gold",
	['E'] = "Black Champs",
	--// Country Crate #1
	['F'] = "Argentinian Shorts",
	['G'] = "Australian Shorts",
	['H'] = "Brazilian Shorts",
	['I'] = "Canadian Shorts",
	['J'] = "Chilean Shorts",
	['K'] = "Chinese Shorts",
	['L'] = "England Shorts",
	--// Country Crate #2
	['M'] = "French Shorts",
	['N'] = "Georgian Shorts",
	['O'] = "Italian Shorts",
	['P'] = "Jamaican Shorts",
	['Q'] = "Japanese Shorts",
	['R'] = "Mexican Shorts",
	['S'] = "Moldovan Shorts",
	--// Country Crate #3
	['T'] = "Mystic Shorts",
	['U'] = "New Zealand Shorts",
	['V'] = "Nigerian Shorts",
	['W'] = "Polish Shorts",
	['X'] = "Russian Shorts",
	['Y'] = "Spanish Shorts",
	['Z'] = "USA Shorts",
	
	-- New Shorts
	['A1'] = "Spiderman Black Shorts",
	['B1'] = "Spiderman Blue Shorts",
	['C1'] = "Thailand Shorts",
	['D1'] = "Hungary Shorts",
}

function Clothing_Mod.Get_All_Gloves_Data()
	return Gloves_Data
end

function Clothing_Mod.Get_All_Shorts_Data()
	return Shorts_Data
end

function Clothing_Mod.Get_Gloves_Data(Key)
	if(Key == nil or Gloves_Data[Key] == nil)then
		return Gloves_Data
	else
		return Gloves_Data[Key]
	end
end

function Clothing_Mod.Get_Shorts_Data(Key)
	if(Key == nil or Shorts_Data[Key] == nil)then
		return Shorts_Data
	else
		return Shorts_Data[Key]
	end
end

function Clothing_Mod.Player_Owns_Gloves_Key(Plr, Key)
	local Owned_Gloves_V = PlayerUtils.GetPlayerVal(Plr, "Owned Gloves")
	if(Owned_Gloves_V ~= nil)then
		local Owned_Gloves_Keys = string.split(Owned_Gloves_V.Value, ",")
		if(Owned_Gloves_Keys ~= nil and table.find(Owned_Gloves_Keys, Key) ~= nil)then
			return true
		end
	end

	return false
end

function Clothing_Mod.Player_Owns_Shorts_Key(Plr, Key)
	local Owned_Shorts_V = PlayerUtils.GetPlayerVal(Plr, "Owned Shorts")
	if(Owned_Shorts_V ~= nil)then
		local Owned_Shorts_Keys = string.split(Owned_Shorts_V.Value, ",")
		if(Owned_Shorts_Keys ~= nil and table.find(Owned_Shorts_Keys, Key) ~= nil)then
			return true
		end
	end

	return false
end

function Clothing_Mod.Give_Player_Gloves(Plr, Key)
	if Gloves_Data[Key] == nil then
		return false
	end
	if Clothing_Mod.Player_Owns_Gloves_Key(Plr, Key) == true then
		return false
	end
	
	local Owned_Gloves_V = PlayerUtils.GetPlayerVal(Plr, "Owned Gloves")
	if(Owned_Gloves_V ~= nil)then
		local Keys = string.split(Owned_Gloves_V.Value, ",")
		Keys[#Keys + 1] = Key
		Owned_Gloves_V.Value = table.concat(Keys, ",")
	end
end

function Clothing_Mod.Give_Player_Shorts(Plr, Key)
	if Shorts_Data[Key] == nil then
		return false
	end
	if Clothing_Mod.Player_Owns_Shorts_Key(Plr, Key) == true then
		return false
	end

	local Owned_Shorts_V = PlayerUtils.GetPlayerVal(Plr, "Owned Shorts")
	if(Owned_Shorts_V ~= nil)then
		local Keys = string.split(Owned_Shorts_V.Value, ",")
		Keys[#Keys + 1] = Key
		Owned_Shorts_V.Value = table.concat(Keys, ",")
	end
end

function Clothing_Mod.Get_Player_Current_Shorts(Plr)
	local Current_Shorts_V = PlayerUtils.GetPlayerVal(Plr, "Current Shorts")
	if(Current_Shorts_V ~= nil)then
		local Key = Current_Shorts_V.Value
		if(Key ~= nil and Shorts_Data[Key] ~= nil and Shorts_F:FindFirstChild(Shorts_Data[Key]) ~= nil)then
			return Key, Shorts_F:FindFirstChild(Shorts_Data[Key])
		end
	end
	
	return "A", Shorts_F:FindFirstChild(Shorts_Data['A'])
end

function Clothing_Mod.Get_Player_Current_Gloves(Plr)
	local Current_Gloves_V = PlayerUtils.GetPlayerVal(Plr, "Current Gloves")
	if(Current_Gloves_V ~= nil)then
		local Key = Current_Gloves_V.Value
		if(Key ~= nil and Gloves_Data[Key] ~= nil and Gloves_F:FindFirstChild(Gloves_Data[Key]) ~= nil)then
			return Key, Gloves_F:FindFirstChild(Gloves_Data[Key])
		end
	end

	return "A", Gloves_F:FindFirstChild(Gloves_Data['A'])
end

return Clothing_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{821B23C8-1C40-4813-9C35-A032EFEBF003}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Clothing_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8788FF347432486FBBC60492C5FD6994">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Country_Mod.lua
--
--  Description:
--      Provides country and flag data for players. Maps country names
--      to flag asset IDs and numerical indices, with helper functions
--      for retrieving player flag data and performing conversions.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Script children:
--          * Flags (contains Decals with Texture & Map_Index attribute)
--      - Player Instances:
--          * Player.Player_Data.Country
--
--  Notes:
--      - Hardcoded asset IDs for several countries (USA, France, Japan, etc.)
--      - Additional countries loaded dynamically from Flags folder
--      - Provides conversion functions between country names and indices
--      - Defaults to "United States" if invalid country key
--
--======================================================================


local Country_Mod = {}

local Country_Data = {
	--['USA'] = "rbxassetid://14010864446",
	--['Canada'] = "rbxassetid://12503880000",
	--['Mexico'] = "rbxassetid://116338470092166",
	--['France'] = "rbxassetid://12690378646",
	--['Brazil'] = "rbxassetid://17220320205",
	--['Japan'] = "rbxassetid://17041741932",
	--['Poland'] = "rbxassetid://7412759429",
	--['New Zealand'] = "rbxassetid://17357309517",
	--['Moldova'] = "rbxassetid://12895193469",
	--['Georgia'] = "rbxassetid://128636032248868",
	--['Russia'] = "rbxassetid://6514161028",
	--['China'] = "rbxassetid://9110900644",
	--['UK'] = "rbxassetid://119841021475023",
	--['Australia'] = "rbxassetid://18386599365",
	--['Nigeria'] = "rbxassetid://11858119964",
	--['Jamaica'] = "rbxassetid://128621555589394",
	--['Italy'] = "rbxassetid://10333104535",
	--['Spain'] = "rbxassetid://6600099878",
	--['Argentina'] = "rbxassetid://119836429792081",
	--['Chile'] = "rbxassetid://17366784440",
	--['Portugal'] = "rbxassetid://13721042005",
	--['Ireland'] = "rbxassetid://12511955654"
}
local Country_Number_Map = {}

local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

for i, v in pairs(script.Flags:GetChildren()) do
	Country_Data[v.Name] = v.Texture
	Country_Number_Map[v.Name] = tonumber(v:GetAttribute("Map_Index"))
	if v:GetAttribute("Map_Index") == nil then
		error("No Map_Index property assigned")
	end
end

local function Get_Flag_ID(Country_Key)
	local Img = Country_Data[Country_Key]
	if(Img ~= nil)then
		return Img
	end
	
	return Country_Data['United States']
end

function Country_Mod.Get_Player_Country_Data(Plr)
	local Flag_Key = PlayerUtils.GetPlayerVal(Plr, "Country")
	if(Flag_Key ~= nil and Country_Data[Flag_Key.Value] ~= nil)then
		local Key = Flag_Key.Value
		return Key, Country_Data[Key]
	end
	
	return "United States", Country_Data['United States']
end

function Country_Mod.Get_Flag_ID(Country_Key)
	if(Country_Data[Country_Key] ~= nil) then
		return Country_Data[Country_Key]
	end
	return Country_Data['United States']
end

function Country_Mod.Get_Country_Data()
	return Country_Data
end

function Country_Mod.Get_Country_Number_From_Index(index)
	return Country_Number_Map[index]
end

function Country_Mod.Get_Country_Index_From_Number(number)
	for i, v in pairs(Country_Number_Map) do
		if v == number then
			return i
		end
	end
end

return Country_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{2B06C65F-C02D-4DB4-A80D-D269DD00E922}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Country_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE27C29DB116C4F2A9D6240C851DD032D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Crate_Mod.lua
--
--  Description:
--      Defines crate data for the in-game shop. Each crate specifies
--      its name, reward type, price, UI color, and contained items
--      with rarity and links to Clothing_Mod keys.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Clothing_Mod (for ItemKey references)
--
--  Notes:
--      - Crate_Data maps crate IDs ("Crate 1", "Crate 2", etc.)
--      - Each crate has:
--          * Name (display name)
--          * RewardType ("Gloves" or "Shorts")
--          * PriceCoins / PriceGems
--          * Color_BG (UI background color)
--          * Items (Name, Rarity, ItemKey from Clothing_Mod)
--      - Rarities follow scheme: Bronze (7/10), Silver (3/20),
--        Gold (1/10), Diamond (1/100), Platinum (1/1000)
--      - Used by Shop_Handle to validate and roll crate rewards
--
--======================================================================


local Crate_Mod = {}

-- Unified rarity color table 
local RARITY_COLORS = {
	Platinum = Color3.fromRGB(255,170,255),
	Special  = Color3.fromRGB(255,170,255),
	Diamond  = Color3.fromRGB(150,255,255),
	Gold     = Color3.fromRGB(255,215,0),
	Silver   = Color3.fromRGB(217,217,217),
	Bronze   = Color3.fromRGB(196,124,57),
	Default  = Color3.fromRGB(255,255,255),
	Common   = Color3.fromRGB(255,255,255)
}

local Crate_Data = {
	--// rarity: Bronze = 7/10, Silver = 3/20, Gold = 1/10, Diamond = 1/100, Platinum = 1,1000
	
	['Crate 1'] = {
		['Name'] = "Basic Gloves Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 800, 
		['PriceGems'] = 40,
		["Color_BG"] = RARITY_COLORS.Gold, 
		['Items'] = {
			["A"] = {
				["Name"] = "Blue Gloves", 
				["Rarity"] = 7/10,

				["ItemKey"] = "I"
			},
			["B"] = {
				["Name"] = "Green Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "J"
			},
			["C"] = {
				["Name"] = "White Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "H1"
			},
			["D"] = {
				["Name"] = "Purple Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "L"
			},
			["E"] = {
				["Name"] = "Orange Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "G1"
			},
			["F"] = {
				["Name"] = "Chromatic Green Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "A2"
			},
			["G"] = {
				["Name"] = "Chromatic Blue Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "B2"
			},
			["H"] = {
				["Name"] = "Chromatic Pink Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "C2"
			},
		}
	},
	
	['Crate 2'] = {
		['Name'] = "Basic Shorts Crate",
		['RewardType'] = "Shorts",

		['PriceCoins'] = 1000, 
		['PriceGems'] = 50,
		["Color_BG"] = RARITY_COLORS.Diamond, 
		['Items'] = {
			["A"] = {
				["Name"] = "Karate Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "B"
			},
			["B"] = {
				["Name"] = "Denim",
				["Rarity"] = 0.15,

				["ItemKey"] = "C"
			},
			["C"] = {
				["Name"] = "Dragon Gold",
				["Rarity"] = 1/100,

				["ItemKey"] = "D"
			},
			["D"] = {
				["Name"] = "Black Champs",
				["Rarity"] = 7/10,

				["ItemKey"] = "E"
			},
			["E"] = {
				["Name"] = "Mystic Shorts",
				["Rarity"] = 1/10,

				["ItemKey"] = "T"
			},
		}
	},
	
	['Crate 3'] = {
		['Name'] = "Underground Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 2000, 
		['PriceGems'] = 100,
		["Color_BG"] = RARITY_COLORS.Platinum, 
		['Items'] = {
			["A"] = {
				["Name"] = "Plastic Green Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "U1"
			},
			["B"] = {
				["Name"] = "Plastic Blue Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "V1"
			},
			["C"] = {
				["Name"] = "Plastic Pink Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "W1"
			},
			["D"] = {
				["Name"] = "Blue Flame Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "X1"
			},
			["E"] = {
				["Name"] = "Lava Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "Y1"
			},
			["F"] = {
				["Name"] = "Carbon Gloves",
				["Rarity"] = 1/10000,

				["ItemKey"] = "Z1"
			},
			["G"] = {
				["Name"] = "Chromatic Green Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "A2"
			},
			["H"] = {
				["Name"] = "Chromatic Blue Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "B2"
			},
		}
	},
	
	['Crate 4'] = {
		['Name'] = "Tape Crate", --// Crates Name
		['RewardType'] = "Gloves",

		['PriceCoins'] = 600, -- Price in cash
		['PriceGems'] = 30, -- Price in gems
		["Color_BG"] = RARITY_COLORS.Common, -- background color for the crate display UI 
		['Items'] = { --// Only 8 items Per Crate Max
			["A"] = {
				["Name"] = "Black Tape", --// Item name same as listed in Clothing_Mod
				["Rarity"] = 7/10, --// Item Rarity

				["ItemKey"] = "B"
			},
			["B"] = {
				["Name"] = "Blue Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "C"
			},
			["C"] = {
				["Name"] = "Green Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "D"
			},
			["D"] = {
				["Name"] = "Red Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "E"
			},
			["E"] = {
				["Name"] = "Tan Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "F"
			},
			["F"] = {
				["Name"] = "White Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "G"
			},
			["G"] = {
				["Name"] = "Purple Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "H"
			},
			["H"] = {
				["Name"] = "Plastic Green Tape",
				["Rarity"] = 7/10,
				["ItemKey"] = "O1"
			}
		}
	},
	
	['Crate 5'] = {
		['Name'] = "Urban Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 1000, 
		['PriceGems'] = 50,
		["Color_BG"] = RARITY_COLORS.Diamond, 
		['Items'] = {
			["A"] = {
				["Name"] = "Graffiti Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "I1"
			},
			["B"] = {
				["Name"] = "Iron Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "J1"
			},
			["C"] = {
				["Name"] = "Gold Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "K1"
			},
			["D"] = {
				["Name"] = "Corrupted Purple Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "L1"
			},
			["E"] = {
				["Name"] = "Corrupted Green Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "M1"
			},
			["F"] = {
				["Name"] = "Corrupted Black Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "N1"
			},
		}
	},

	['Crate 6'] = {
		['Name'] = "Fury Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 2000, 
		['PriceGems'] = 100,
		["Color_BG"] = RARITY_COLORS.Platinum, 
		['Items'] = {
			["A"] = {
				["Name"] = "Fury Gloves",
				["Rarity"] = 1/10000,
				["ItemKey"] = "G2"
			},
			["B"] = {
				["Name"] = "Plastic Blue Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "P1"
			},
			["C"] = {
				["Name"] = "Plastic Pink Tape",
				["Rarity"] = 1/10,

				["ItemKey"] = "Q1"
			},
			["D"] = {
				["Name"] = "Frozen Chain Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "R1"
			},
			["E"] = {
				["Name"] = "Molten Chain Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "S1"
			},
			["F"] = {
				["Name"] = "Carbon Chain Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "T1"
			},
			["H"] = {
				["Name"] = "Chromatic Pink Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "F2"
			},
		}
	},
	
	['Crate 7'] = {
		['Name'] = "Prime Gloves Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 800,
		['PriceGems'] = 40,
		["Color_BG"] = RARITY_COLORS.Gold,

		['Items'] = {
			["A"] = { ["Name"] = "Blue Gloves",              ["Rarity"] = 7/10,  ["ItemKey"] = "I" },
			["B"] = { ["Name"] = "Green Gloves",             ["Rarity"] = 7/10,  ["ItemKey"] = "J" },
			["C"] = { ["Name"] = "White Gloves",             ["Rarity"] = 7/10,  ["ItemKey"] = "H1" },
			["D"] = { ["Name"] = "Purple Gloves",            ["Rarity"] = 7/10,  ["ItemKey"] = "L" },
			["E"] = { ["Name"] = "Orange Gloves",            ["Rarity"] = 7/10,  ["ItemKey"] = "G1" },
			["F"] = { ["Name"] = "Gold Gloves",              ["Rarity"] = 1/10,  ["ItemKey"] = "K1" },
			["G"] = { ["Name"] = "Chromatic Green Gloves",   ["Rarity"] = 1/10,  ["ItemKey"] = "A2" },
			["H"] = { ["Name"] = "Chromatic Blue Gloves",    ["Rarity"] = 1/10,  ["ItemKey"] = "B2" },
		}
	},
	
	
	['Crate 8'] = {
		['Name'] = "Vanguard Crate",
		['RewardType'] = "Shorts",

		['PriceCoins'] = 1000,
		['PriceGems'] = 50,
		["Color_BG"] = RARITY_COLORS.Diamond,

		['Items'] = {
			["A"] = { ["Name"] = "Dragon Gold",      ["Rarity"] = 1/100,   ["ItemKey"] = "D" },
			["B"] = { ["Name"] = "Corrupted Purple Gloves", ["Rarity"] = 1/100, ["ItemKey"] = "L1"},
			["C"] = { ["Name"] = "Corrupted Green Gloves", ["Rarity"] = 1/100,["ItemKey"] = "M1"},
			["D"] = { ["Name"] = "Corrupted Black Gloves", ["Rarity"] = 1/100,["ItemKey"] = "N1"},
			["E"] = { ["Name"] = "Plastic Pink Tape", ["Rarity"] = 1/10, ["ItemKey"] = "Q1"},
			["F"] = { ["Name"] = "Mystic Shorts",    ["Rarity"] = 1/10,    ["ItemKey"] = "T" },
			["G"] = { ["Name"] = "Plastic Blue Tape", ["Rarity"] = 7/10, ["ItemKey"] = "P1"	},
			["H"] = { ["Name"] = "Graffiti Gloves", ["Rarity"] = 7/10, ["ItemKey"] = "I1"},
		}
	},

	['Crate 9'] = {
		['Name'] = "Blaze Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 2000,
		['PriceGems'] = 100,
		["Color_BG"] = RARITY_COLORS.Platinum,

		['Items'] = {
			["A"] = { ["Name"] = "Iron Gloves",               ["Rarity"] = 7/10,     ["ItemKey"] = "J1" },
			["B"] = { ["Name"] = "Graffiti Gloves",           ["Rarity"] = 7/10,     ["ItemKey"] = "I1" },
			["C"] = { ["Name"] = "Purple Gloves",             ["Rarity"] = 7/10,     ["ItemKey"] = "L" },
			["D"] = { ["Name"] = "Corrupted Green Gloves",    ["Rarity"] = 1/10,     ["ItemKey"] = "M1" },
			["E"] = { ["Name"] = "Corrupted Black Gloves",    ["Rarity"] = 1/10,     ["ItemKey"] = "N1" },
			["F"] = { ["Name"] = "Carbon Gloves",             ["Rarity"] = 1/10000,  ["ItemKey"] = "Z1" },
			["G"] = { ["Name"] = "Blue Flame Gloves",         ["Rarity"] = 1/100,    ["ItemKey"] = "X1" },
			["H"] = { ["Name"] = "Lava Gloves",               ["Rarity"] = 1/100,    ["ItemKey"] = "Y1" },
		}
	}
}

function Crate_Mod.GetCrates()
	return Crate_Data
end

function Crate_Mod.Get_Crate_Data_Arr()
	local Arr = {}
	
	for Crate_Key, Data in next, Crate_Data do
		local D = Data
		local Index_Str = string.gsub(Crate_Key, "Crate ", "")
		D['Index'] = tonumber(Index_Str)
		
		table.insert(Arr, D)
	end
	
	table.sort(Arr, function(A, B)
		return A['Index'] < B['Index']
	end)
	
	return Arr
end

return Crate_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{3E38F2AB-5120-4F1C-9F80-F092BA51CA2A}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Crate_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBA21004160EF44718E8C2CC90C7EDEF1">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Rewards_Mod.lua
--
--  Description:
--      Centralized reward system. Handles both:
--        * Daily retention rewards (7-day cycle)
--        * Session playtime rewards (time thresholds)
--      Provides helper functions to query reward data, player streaks,
--      and claimed rewards. Designed for use in reward UIs and server
--      handles (Codes_Handle, Session_Reward_Handle, etc.).
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Player Instances:
--          * Player.Player_Data.Retention Streak
--          * Player.Player_Data.Redeemed Rewards
--          * Player.Player_Data.SR_Day
--          * Player.Player_Data.SR_Count
--          * Player.Player_Data.SR_ClaimedTimes
--
--  Notes:
--      - Daily_Rewards_Data (7-day cycle):
--          * Day 1: +100 Cash
--          * Day 2: +10 Gems
--          * Day 3: Free Crate 1
--          * Day 4: +300 Cash
--          * Day 5: +25 Gems
--          * Day 6: +450 Cash
--          * Day 7: VIP Gamepass (Key "A")
--        funcs:
--          * Get_Specific_Daily_Reward(Key)
--          * Get_Player_Retention_Streak(Plr)
--          * Get_Claimed_Daily_Player_Rewards(Plr)
--          * Get_Total_Reward_Amount()
--
--      - Session_Rewards_Data (time thresholds):
--          * 10 min: +200 Coins
--          * 15 min: +350 Coins
--          * 21 min: +20 Gems
--          * 30 min: +40 Gems
--        funcs:
--          * Get_Max_Session_Claims()
--          * Get_Session_Reward(Index)
--
--      - Used by:
--          * Codes_Handle (daily codes integration)
--          * Session_Reward_Handle (session playtime tracking)
--          * Reward UIs (Daily / Session)
--
--======================================================================

local Rewards_Mod = {}

local Daily_Rewards_Data = {
	[1] = {
		['Name'] = "+100 Cash!",
		['Type'] = "Cash",
		['Amount'] = 100
	},
	
	[2] = {
		['Name'] = "+10 Gems!",
		['Type'] = "Gems",
		['Amount'] = 10
	},
	
	[3] = {
		['Name'] = "FREE Crate!",
		['Type'] = "Crate",
		['Amount'] = "Crate 1"
	},
	
	[4] = {
		['Name'] = "+300 Cash!",
		['Type'] = "Cash",
		['Amount'] = 300
	},
	
	[5] = {
		['Name'] = "+25 Gems!",
		['Type'] = "Gems",
		['Amount'] = 25
	},
	
	[6] = {
		['Name'] = "+450 Cash!",
		['Type'] = "Cash",
		['Amount'] = 450
	},
	
	[7] = {
		['Name'] = "VIP!",
		['Type'] = "Gamepass",
		['Amount'] = "A"
	},
	
	
	
}

local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

function Rewards_Mod.Get_Specific_Daily_Reward(Key)
	return Daily_Rewards_Data[Key]
end

function Rewards_Mod.Get_Player_Retention_Streak(Plr)
	local Streak = PlayerUtils.GetPlayerVal(Plr, "Retention Streak")
	if(Streak ~= nil) then
		return Streak.Value
	end
	return 0
end

function Rewards_Mod.Get_Claimed_Daily_Player_Rewards(Plr)
	local Keys_Str = PlayerUtils.GetPlayerVal(Plr, "Redeemed Rewards")
	if(Keys_Str ~= nil)then
		return string.split(Keys_Str.Value, ",")
	end
	return {}
end

function Rewards_Mod.Get_Total_Reward_Amount()
	local Data_Arr = {}
	for Key, Reward_Data in next, Daily_Rewards_Data do
		table.insert(Data_Arr, Reward_Data)
	end
	return #Data_Arr
end

----------------------------------------------------------------------
-- Session Rewards
----------------------------------------------------------------------

local UNIT = 60 -- seconds in one minute

Rewards_Mod.Session_SeasonId = 1
Rewards_Mod.Session_Rewards_Data = {
	--{ t = 15, reward = { type="Coins", amount=666, label="Test" } },
	{ t = 10*UNIT, reward = { type="Coins", amount=200, label="Stay 10 minutes: +200 💵" } },
	{ t = 15*UNIT, reward = { type="Coins", amount=350, label="Stay 15 minutes: +350 💵" } },
	{ t = 21*UNIT, reward = { type="Coins", amount=450, label="Stay 21 minutes: +450 💵" } },
	{ t = 30*UNIT, reward = { type="Coins", amount=1000, label="Stay 30 minutes: +1000 💵" } },
}

function Rewards_Mod.Get_Max_Session_Claims()
	return #Rewards_Mod.Session_Rewards_Data
end

function Rewards_Mod.Get_Session_Reward(Index)
	if Index >= 1 and Index <= #Rewards_Mod.Session_Rewards_Data then
		return Rewards_Mod.Session_Rewards_Data[Index].reward
	end
	return nil
end

----------------------------------------------------------------------
-- Gym Reward Event Config
----------------------------------------------------------------------

Rewards_Mod.Gym_Rewards_Messages_Color = Color3.fromRGB(255, 208, 21)
Rewards_Mod.Gym_Rewards_TimeFrame = 5 -- 5 minutes
Rewards_Mod.Gym_Rewards_Duration = 15 -- 15 secondes
Rewards_Mod.Gym_Rewards_Data = {
	{Event_Start_Hour =  18  , reward = { type="Coins", amount=500, label="+500 💵" }},
	{Event_Start_Hour =  19  , reward = { type="Coins", amount=500, label="+500 💵" }},
	{Event_Start_Hour =  20  , reward = { type="Coins", amount=500, label="+500 💵" }},
	{Event_Start_Hour =  21  , reward = { type="Coins", amount=500, label="+500 💵" }},
	{Event_Start_Hour =  22  , reward = { type="Coins", amount=500, label="+500 💵" }}
}

return Rewards_Mod]]></ProtectedString>
						<string name="ScriptGuid">{0F196BE2-407F-4046-8594-F45EE8677482}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Rewards_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4FF0A953E5F043028AC50CFB5CEDE134">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[
--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Skin_Tone_Mod.lua
--
--  Description:
--      Defines available skin tone colors and provides helper functions
--      to convert between Color3 and string representations ("R,G,B").
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox:
--          * Color3
--          * math.clamp
--          * string.split
--
--  Notes:
--      - Skin_Tone_Data includes:
--          * Dark taupe, Brown, Linen, Nougat, Light orange,
--            Medium brown, Reddish brown, Cork, Burlap, Brick yellow
--      - funcs API:
--          * Get_Skin_Tone_Data(): returns full tone table
--          * Configure_Skin_Tone(Color3): to "R,G,B" string
--          * Configure_To_Color("R,G,B"): back to Color3
--      - Invalid strings fallback to Color3.fromRGB(255,255,255)
--
--======================================================================


local Skin_Tone_Mod = {}

local Skin_Tone_Data = {
	['Dark taupe'] = Color3.fromRGB(90, 76, 66),
	['Brown'] = Color3.fromRGB(124, 92, 70),
	['Linen'] = Color3.fromRGB(175, 148, 131),
	['Nougat'] = Color3.fromRGB(204, 142, 105),
	['Light orange'] = Color3.fromRGB(234, 184, 146),
	['Medium brown'] = Color3.fromRGB(86, 66, 54),
	['Reddish brown'] = Color3.fromRGB(105, 64, 40),
	['Cork'] = Color3.fromRGB(188, 155, 93),
	['Burlap'] = Color3.fromRGB(199, 172, 120),
	['Brick yellow'] = Color3.fromRGB(215, 197, 154),
}

function Skin_Tone_Mod.Get_Skin_Tone_Data()
	return Skin_Tone_Data
end

function Skin_Tone_Mod.Configure_Skin_Tone(Col)
	local R, G, B = Col.R, Col.G, Col.B
	R = math.clamp(R, 0, 255)
	G = math.clamp(G, 0, 255)
	B = math.clamp(B, 0, 255)
	
	return R .. "," .. G .. "," .. B
end

function Skin_Tone_Mod.Configure_To_Color(Col_Str)
	local Str_Data = string.split(Col_Str, ",")
	if(Str_Data ~= nil and #Str_Data >= 3)then
		local R = tonumber(Str_Data[1])
		local G = tonumber(Str_Data[2])
		local B = tonumber(Str_Data[3])
		
		R = math.clamp(R, 0, 255)
		G = math.clamp(G, 0, 255)
		B = math.clamp(B, 0, 255)
		
		return Color3.fromRGB(R, G, B)
	end
	
	return Color3.fromRGB(255, 255, 255)
end

return Skin_Tone_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{1DEAA580-0C3E-4A45-82F3-C156A02222C2}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Skin_Tone_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1D6AE8EACF344B888F0E91EE83FF5866">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Skill_Tree_Mod.lua
--
--  Description:
--      Defines milestone-based rewards linked to player progression
--      stats such as wins, knockouts, submissions, and total playtime.
--      Provides structured reward tables consumed by progression and
--      achievement systems.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage/Data_Mods_F:
--          * Crate_Mod (for crate rewards)
--          * Monetization_Mod (for Cash Pack rewards)
--      - Core_Fight_Handle (for Ranked Move unlocks)
--
--  Notes:
--      - Key_Index: {"Total Wins", "Ranked Wins", "Punch Knockout Wins",
--                   "Leg Knockout Wins", "Submissions Wins", "Total Playtime"}
--      - Rewards_Data categories:
--          * Wins: Cash, Gems, Crates, Cash Packs, Ranked Moves
--          * Knockouts: Gems, Cash, Crates, Cash Packs, Ranked Moves
--          * Submissions: Gems, Crates, Ranked Moves, Packs
--          * Playtime: Cash, Gems, Crates
--      - Each reward entry includes:
--          * Reward (type)
--          * Amount (number or key string)
--          * Text (UI message string)
--      - Used by progression/achievement systems to grant milestone rewards
--
--======================================================================

local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

local Skill_Tree_Mod = {}

--[[
	- Cash, Gems, Cash, Gems, Cash Pack, Gems Pack, Crate, Cash Pack, Crate, Gems Pack
	- Gems, Cash, Crate, Cash Pack, Ranked Move, Gems Pack, Ranked Move, Crate 
	
	* General Wins
	- 1 Win | 5 Wins | 10 Wins | 25 Wins | 50 Wins | 100 Wins | 250 Wins | 500 Wins | 1,000 Wins | 2,500 Wins
	
	* Ranked Wins
	- 1 Win | 3 Wins | 5 Wins | 10 Wins | 15 Wins | 25 Wins | 35 Wins | 50 Wins | 75 Wins | 100 Wins
	
	* Punch Knockouts
	- 5 KO's | 10 KO's | 15 KO's | 25 KO's | 50 KO's | 75 KO's | 125 KO's | 250 KO's 
	
	* Leg Knockouts
	- 5 KO's | 10 KO's | 15 KO's | 25 KO's | 50 KO's | 75 KO's | 125 KO's | 250 KO's 
	
	* Submission KOs
	- 1 KO's | 3 KO's | 5 KO's | 10 KO's | 15 KO's | 25 KO's | 50 KO's | 100 KO's
]]--

local Key_Index = {"Total Wins", "Ranked Wins", "Punch Knockout Wins", "Leg Knockout Wins", "Submissions Wins", "Total Playtime"}

local Rewards_Data = {
	['Wins'] = {
		{
			['Reward'] = "Cash",
			['Amount'] = 25,
			['Text'] = "💸 Successfully Earned +25 Cash!"
		},

		{
			['Reward'] = "Gems",
			['Amount'] = 10,
			['Text'] = "💎 Successfully Earned +10 Gems!"
		},

		{
			['Reward'] = "Cash",
			['Amount'] = 100,
			['Text'] = "💸 Successfully Earned +100 Cash!"
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "I",
			['Text'] = "💪 Successfully Earned an Exclusive Takedown & Submission Combo!" -- Replace with Strike
		},

		{
			['Reward'] = "Cash Pack",
			['Amount'] = "A",
			['Text'] = "💸 Successfully Earned a Tiny Cash Pack!"
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "",
			['Text'] = "💪 Successfully Earned an Exclusive Takedown & Submission Combo!" -- Replace with Submission
		},

		{
			['Reward'] = "Crate",
			['Amount'] = "Crate 1",
			['Text'] = "🎁 Successfully Earned a FREE Crate!"
		},

		{
			['Reward'] = "Cash Pack",
			['Amount'] = "C",
			['Text'] = "💸 Successfully Earned a Large Cash Pack!"
		},

		{
			['Reward'] = "Crate",
			['Amount'] = "Crate 2",
			['Text'] = "🎁 Successfully Earned a FREE Crate!" 
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "J",
			['Text'] = "💪 Successfully Earned an Exclusive Takedown & Submission Combo!" -- Replace with Strike
		},
	},

	['Knockouts'] = {
		{
			['Reward'] = "Gems",
			['Amount'] = 5,
			['Text'] = "💎 Successfully Earned +5 Gems!"
		},

		{
			['Reward'] = "Cash",
			['Amount'] = 25,
			['Text'] = "💸 Successfully Earned +25 Cash!"
		},

		{
			['Reward'] = "Crate",
			['Amount'] = "Crate 1",
			['Text'] = "🎁 Successfully Earned a FREE Crate!"
		},

		{
			['Reward'] = "Cash Pack",
			['Amount'] = "B",
			['Text'] = "💸 Successfully Earned a Small Cash Pack!"
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "E",
			['Text'] = "💪 Successfully Earned an Exclusive Takedown & Submission Combo!"
		},

		{
			['Reward'] = "Gems",
			['Amount'] = 50,
			['Text'] = "💎 Successfully Earned +50 Gems!"
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "D",
			['Text'] = "💪 Successfully Earned an Exclusive Takedown & Submission Combo!"
		},

		{
			['Reward'] = "Crate",
			['Amount'] = "Crate 2",
			['Text'] = "🎁 Successfully Earned a FREE Crate!"
		},
	}
}

local Skill_Tree_Data = {
	['Total Wins'] = {1, 5, 10, 25, 50, 100, 250, 500, 1000, 2500},
	['Ranked Wins'] = {1, 3, 5, 10, 15, 25, 35, 50, 75, 100},
	['Punch Knockout Wins'] = {5, 10, 15, 25, 50, 75, 125, 250},
	['Leg Knockout Wins'] = {5, 10, 15, 25, 50, 75, 125, 250},
	['Submissions Wins'] = {1, 3, 5, 10, 15, 25, 50, 100},
	['Total Playtime'] = {3600, 7200, 18000, 36000, 180000, 360000, 1800000, 3600000}
}

local function Compile_Skill_Tree_Plr_Data(Plr)
	local Skill_Tree_V = PlayerUtils.GetPlayerVal(Plr, "Redeemed Skill Tree")
	local Owned_Keys = {
		['Total Wins'] = {},
		['Ranked Wins'] = {},
		['Punch Knockout Wins'] = {},
		['Leg Knockout Wins'] = {},
		['Submissions Wins'] = {},
		['Total Playtime'] = {}
	}

	if(Skill_Tree_V ~= nil)then
		local Data_Str = string.split(Skill_Tree_V.Value, ",")

		local function Process_String_Data(Str)
			local Core_Data = string.split(Str, "|")
			if(Core_Data ~= nil and #Core_Data >= 2)then
				local K_Index = tonumber(Core_Data[1])
				local Key = Key_Index[K_Index]
				local Index = tonumber(Core_Data[2])

				table.insert(Owned_Keys[Key], Index)
			end
		end

		for i = 1, #Data_Str do
			local Data = Data_Str[i]
			if(Data ~= nil)then
				Process_String_Data(Data)
			end
		end
	end

	return Owned_Keys
end

function Skill_Tree_Mod.Get_All_Skill_Tree_Data()
	return Skill_Tree_Data, Rewards_Data
end

function Skill_Tree_Mod.Compile_Skill_Tree_Data(Plr)
	return Compile_Skill_Tree_Plr_Data(Plr)
end

function Skill_Tree_Mod.Get_Reward_Data_Arr(Tree_Key)
	if(Skill_Tree_Data[Tree_Key] ~= nil and #Skill_Tree_Data[Tree_Key] == 8) then
		return Rewards_Data['Knockouts']
	else
		return Rewards_Data['Wins']
	end
end

function Skill_Tree_Mod.Verify_Tree_Index(Key, Tree_Index)
	if(Skill_Tree_Data[Key] ~= nil and Skill_Tree_Data[Key][Tree_Index] ~= nil) then
		return true
	end
	return false
end

function Skill_Tree_Mod.Has_Player_Can_Redeemed_Reward(Plr, Key, Tree_Index)
	local Owned_Rewards_Data = Compile_Skill_Tree_Plr_Data(Plr)
	if(Plr ~= nil and Owned_Rewards_Data ~= nil and 
		(#Owned_Rewards_Data <= 0 or table.find(Owned_Rewards_Data, Tree_Index) == nil)) then

		return true
	end
	return false
end

function Skill_Tree_Mod.Player_Has_Met_Requirement(Plr, Key, Tree_Index)
	local Data_Val = PlayerUtils.GetPlayerVal(Plr, Key)
	if(Plr ~= nil and Data_Val ~= nil and Skill_Tree_Data[Key] ~= nil and Skill_Tree_Data[Key][Tree_Index] ~= nil) then
		local Max_Val = tonumber(Skill_Tree_Data[Key][Tree_Index])
		if(Data_Val.Value >= Max_Val)then
			return true
		end
	end

	return false
end

function Skill_Tree_Mod.Get_Redeem_Data_Entry(Key, Tree_Index)
	local Key_Index_Val = table.find(Key_Index, Key) or 1
	return Key_Index_Val .. "|" .. Tree_Index
end

function Skill_Tree_Mod.Get_Reward_Data(Key, Tree_Index)
	if(Key == "Total Wins" or Key == "Ranked Wins") then
		return Rewards_Data["Wins"][Tree_Index]
	else
		return Rewards_Data["Knockouts"][Tree_Index]
	end
end

return Skill_Tree_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{3B6E64FF-44B7-440D-BF62-E27D21C860C3}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Skill_Tree_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX27A39EB69A8C4D63B78BCC633423006B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Changelog_Mod.lua
--
--  Description:
--      Static changelog module containing version history and feature
--      updates. Provides a list of changes for display in UI elements.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-10-17 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - None
--
--  Notes:
--      - Returns an array of changelog entries
--      - Each entry contains:
--          * version: string identifier (e.g. "CHANGELOG V2025-09-26.X")
--          	* X correspond to the current patch of this version 
--          * changes: array of string bullet points (maximum 8)
--      - Designed for Changelog UI display in-game
--
--======================================================================


return {
	{
		version = "CHANGELOG V2026-01-06.2",
		changes = {
			"👧 Female body now available!",
			"🥊 New fun punching machine game with rewards",
			"🏆 Leaderboards are now reset each week & month",
			"🇯🇲 New country flags available",
			"🐞 Bug Fixes – smoother and more secure gameplay"
		}
	},
	{
		version = "CHANGELOG V2025-12-15",
		changes = {
			"❓ Crazy new Fight Tutorial – jump in and learn faster than ever",
			"🥊 New ELO System – earn few ELO points in standard cages too",
			"⚙️ Fight Outro Customization – personalize your victory animations",
			"🩳 New Gloves & Shorts – Thailand 🇹🇭 / Hungary 🇭🇺 / Spiderman 🕷️",
			"🐞 Bug Fixes – smoother and more secure gameplay"
		}
	},
	{
		version = "CHANGELOG V2025-11-21",
		changes = {
			"🌟 Huge Fight Gameplay enhancement & upgrades",
			"🥊 Now combos strikes have real damage differences",
			"🥊 You can now strike with punch or kick !",
			"⚙️ Customize your fight entrance animations",
			"🩳 Shop UI new look : now you can buy all shorts & gloves"
		}
	},
	{
		version = "CHANGELOG V2025-HALLOWEEN",
		changes = {
			"🎃 Halloween theme 👻",
			"👻 Halloween UGCs : 21 crazy items 🎃",
			"🥊 Fight against 3 Halloween bots 👹",
			"👗 Halloween UGCs Packs ",
			"🏅 Special podium for Top 3 players!",
			"✅ Halloween Champion 2025 badge"
		}
	},
	{
		version = "CHANGELOG V2025-10-17.1",
		changes = {
			"🧑 Bundle UGCs Title Display",
			"🧑 Podium UGCs are now purchasable through Gems",
			"💎 Exchange in Shop menu to convert Cash to Gems",
			"🎲 Updated animations & Colors for all Podiums",
			"🚀 New Bulk Purchase system with 4 mannequins",
			"🐞 Bug fixes(Autoclicker)" 
		}
	},
	{
		version = "CHANGELOG V2025-10-12",
		changes = {
			"💎 10MILLIONS code to celebrate 10M visits",
			"🙏 THANK YOU ALL, KEEP FIGHTING!!!",
			"🐞 Bug fixes" 
		}
	},
	{
		version = "CHANGELOG V2025-10-04.5",
		changes = {
			"🎲 New Gym Reward x5 per day",
			"🚀 New teleported to Ranked Arena",
			"📖 New Changelog UI with version history",
			"🐞 Bug fixes (takedown bug)",
			"🧑 Podium UGCs are now renewed",
			"🏅 Special chat tag for Top 3 players",
			"🎨 Brand new UI and menus completed"
		}
	},
	{
		version = "CHANGELOG V2025-09-22",
		changes = {
			"📖 New tutorial use ? top menu button",
			"🎁 New daily rewards system ",
			"💸 Limited time offers at startup",
			"🧑 New UGCs to customize your avatar",
			"🎨 Brand new UI and menus",
			"⚡ Enhanced loading time",
			"🏟 Fight mode only in Gym now",
			"🎙 Voice chat is now available"
			
		}
	}
}]]></ProtectedString>
						<string name="ScriptGuid">{95B23F1D-5D1E-4B62-AEC3-F5B11928F603}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Changelog_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX867A95025EC948E98CDE640C348315D4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/DiscoLights_Mod.lua
--
--  Description:
--      Module handling dynamic disco lighting effects with two modes:
--      - "classic": cycling through vibrant disco colors
--      - "gradient": smooth oscillation between theme-based start/end colors
--      The module supports both MeshPart, SpotLight, and Beam instances,
--      using TweenService for smooth transitions.
--
--  Author(s): Adnan, Darkzeb
--
--  Last Modified: 2025-11-01 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Design/ThemeManager (for color theming)
--      - Services:
--          * TweenService
--
--  Notes:
--      - Automatically falls back to default purple/orange colors if ThemeManager is unavailable
--      - Gradient mode uses sine-based oscillation for continuous color blending
--      - Classic mode cycles through preset hues with optional cyan filtering
--      - Used for visual ambiance in themed environments or event maps
--
--======================================================================


local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DiscoLights_Mod = {}
local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
DiscoLights_Mod.__index = DiscoLights_Mod

-- Default fallback colors
local DEFAULT_START = Color3.fromHex("#6B0FCF")
local DEFAULT_END   = Color3.fromHex("#FE7919")

local COLOR_START, COLOR_END

-- Try loading ThemeManager colors
local success, themeManager = pcall(function()
	return require(ReplicatedStorage:WaitForChild("Design"):WaitForChild("ThemeManager"))
end)

if success and themeManager then
	local startHex = themeManager.getValue("shop", "Shop_Color_Start")
	local endHex = themeManager.getValue("shop", "Shop_Color_End")

	if type(startHex) == "string" then
		COLOR_START = Color3.fromHex(startHex)
	else
		warn("[DiscoLights_Mod] Invalid or missing Shop_Color_Start, using default.")
		COLOR_START = DEFAULT_START
	end

	if type(endHex) == "string" then
		COLOR_END = Color3.fromHex(endHex)
	else
		warn("[DiscoLights_Mod] Invalid or missing Shop_Color_End, using default.")
		COLOR_END = DEFAULT_END
	end
else
	warn("[DiscoLights_Mod] Could not load ThemeManager, using defaults.")
	COLOR_START = DEFAULT_START
	COLOR_END = DEFAULT_END
end

function DiscoLights_Mod.new(Objects, mode)
	local self = setmetatable({}, DiscoLights_Mod)
	self.LightableObjects = Objects
	self.IsLightsRunning = false
	self.Mode = mode or "gradient"
	return self
end

----------------------------------------------------------------------
-- Classic mode (unchanged)
----------------------------------------------------------------------
local isSingleLight = false
local selectiveColors = true
local listOfColors1 = {
	Color3.fromHSV(0.33,1,1),Color3.fromHSV(0.36,1,1),Color3.fromHSV(0.39,1,1),
	Color3.fromHSV(0.42,1,1),Color3.fromHSV(0.45,1,1),Color3.fromHSV(0.48,1,1),
	Color3.fromHSV(0.51,1,1),Color3.fromHSV(0.54,1,1),Color3.fromHSV(0.57,1,1)
}
local rng = Random.new()
local colorIndex = 0
local CYAN_HUE, EXCLUDE_CYAN_HALF_WIDTH = 0.5, 0.04
local function hueInBand(h, center, half)
	local d = math.abs(((h - center + 0.5) % 1) - 0.5)
	return d <= half
end
local function randomDiscoColor()
	if isSingleLight then return Color3.fromHSV(0, 1, 1) end
	if selectiveColors then
		colorIndex = (colorIndex % #listOfColors1) + 1
		return listOfColors1[colorIndex]
	end
	local h
	repeat h = rng:NextNumber(0, 1)
	until not hueInBand(h, CYAN_HUE, EXCLUDE_CYAN_HALF_WIDTH)
	return Color3.fromHSV(h, 1, 1)
end

----------------------------------------------------------------------
-- Smooth gradient mode (continuous wave)
----------------------------------------------------------------------
-- Compute interpolated color between start and end
local function lerpColor(a: Color3, b: Color3, t: number): Color3
	return Color3.new(
		a.R + (b.R - a.R) * t,
		a.G + (b.G - a.G) * t,
		a.B + (b.B - a.B) * t
	)
end

-- Continuous smooth interpolation using sine
local function getSmoothGradientColor(time)
	local t = (math.sin(time) + 1) / 2 -- oscillates 0 → 1 → 0
	return lerpColor(COLOR_START, COLOR_END, t)
end

----------------------------------------------------------------------
-- Beam tween helper
----------------------------------------------------------------------
local function tweenBeamColor(beam, tweenInfo, toColor)
	local fromColor = beam.Color.Keypoints[1] and beam.Color.Keypoints[1].Value or Color3.new(1,1,1)
	local proxy = Instance.new("Color3Value")
	proxy.Value = fromColor

	local conn
	conn = proxy.Changed:Connect(function(c: Color3)
		beam.Color = ColorSequence.new(c)
	end)

	local tween = TweenService:Create(proxy, tweenInfo, {Value = toColor})
	tween.Completed:Connect(function()
		conn:Disconnect()
		proxy:Destroy()
	end)
	tween:Play()
end

----------------------------------------------------------------------
-- Main loop
----------------------------------------------------------------------
function DiscoLights_Mod:StartLights()
	if self.IsLightsRunning then return end
	self.IsLightsRunning = true

	local t0 = os.clock()

	while self.IsLightsRunning do
		local color
		if self.Mode == "gradient" then
			local elapsed = os.clock() - t0
			color = getSmoothGradientColor(elapsed * 0.5) -- speed factor
		else
			color = randomDiscoColor()
			task.wait(3)
		end

		local goal = {Color = color}
		for _, obj in ipairs(self.LightableObjects) do
			if obj:IsA("MeshPart") or obj:IsA("SpotLight") then
				TweenService:Create(obj, tweenInfo, goal):Play()
			elseif obj:IsA("Beam") then
				tweenBeamColor(obj, tweenInfo, color)
			end
		end

		if self.Mode == "gradient" then
			task.wait(0.1) -- update ~10 FPS for smooth fade
		end
	end
end

function DiscoLights_Mod:StopLights()
	self.IsLightsRunning = false
end

return DiscoLights_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{80958C4E-FA9B-4570-851E-9D3C78F125BA}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">DiscoLights_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX86C1FE5F304F42E78A301EA821B7C41C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Offers_Config.lua
--
--  Description:
--      Defines configuration for special in-game offers (discounted
--      Gamepasses, DevProducts, and UGC items). Integrates with
--      Monetization_Mod and DataStoreService to manage limited-time
--      promotions and player offer states.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-3 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage/Data_Mods_F:
--          * Monetization_Mod
--          * Clothing_Mod
--      - Local Modules:
--          * GetPrice_Icon
--          * UGCItemHelper (provides UGCItemsConfig)
--      - Roblox Services:
--          * MarketplaceService
--          * DataStoreService ("PlayerOfferState")
--
--  Notes:
--      - Offers table entries:
--          * Key: link to Monetization_Mod (Gamepass/DevProduct)
--          * Kind: "Gamepass" or "DevProduct"
--          * Title, Icon, OldPrice, NewPrice
--          * IsOfferActive: whether offer is currently valid
--          * EndsAt: expiration timestamp (os.time format)
--          * Priority: display priority
--          * HideIfOwned: hides if player already owns gamepass
--      - Includes UGCItemsConfig from UGCItemHelper
--      - Functions:
--          * loadOfferState(plr, Prekey): loads/saves offer state per player
--
--======================================================================

-- Services
local RunService = game:GetService("RunService")

local IS_SERVER = RunService:IsServer()

local MPS = game:GetService("MarketplaceService")
local RS = game:GetService("ReplicatedStorage")


-- Modules
local Data_Mods_F      = RS:WaitForChild("Data_Mods_F")
local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Monetization_Mod = require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Item_Price_Icon = require(script:WaitForChild("GetPrice_Icon"))

local UGCOffers_Config = require(script.UGCItemHelper)

local Offers_SavedData=nil
local DSS=nil
local OfferStore=nil
if IS_SERVER then
	Offers_SavedData = require(script:WaitForChild("OfferStorageData_Mod"))
	DSS = game:GetService("DataStoreService")
	OfferStore = DSS:GetDataStore("PlayerOfferState")
end


local Offers_Config = {}
local coinsLimit = 5000 -- Not valide now

-- Legit offer kinds (server-authoritative)
Offers_Config.OFFER_KIND = {
	Gamepass   = true,
	DevProduct = true,
	UGC        = true,
	Gloves     = true,
	Shorts     = true,
}

-- one schema for all offers
Offers_Config.UGCItemsConfig = UGCOffers_Config.UGCItemsConfig

Offers_Config.Podiums = {
	LeftPodium = {
		prompt = "Open Discount Offer"

	},
	CenterPodium = {
		prompt = "Open Avatar Item Offer"

	},
	RightPodium = {
		prompt = "Get new equipment"
	}
}

Offers_Config.Offers = {
	-- DevProduct: 6k Cash (consumable → always eligible)
	{
		Key        = "D",                      -- Monetization_Mod.Dev_Data key
		Kind       = "DevProduct",
		Title      = "Special Cash Bundle",
		Icon       = "rbxassetid://15365698744",
		Amount     = "6000",
		OldPrice   = 799,
		NewPrice   = 399,
		IsOfferActive=false,
		EndsAt     = os.time({year=2025, month=9, day=17, hour=23, min=59, sec=59}),
		Priority   = 100,                      -- higher = more likely to be chosen
		-- Consumable = true,                  -- optional override; inferred if omitted
	},

	-- Gamepass: VIP (non-consumable; hide if owned)
	{
		Key        = "A",                      -- Monetization_Mod.GP_Data key
		Kind       = "Gamepass",
		Title      = "VIP Access",
		Icon       = "rbxassetid://116997996978018",
		OldPrice   = 99,
		NewPrice   = 49,
		IsOfferActive=false,
		EndsAt     = os.time({year=2025, month=12, day=28, hour=23, min=59, sec=59}),
		Priority   = 100,
		HideIfOwned = true,                    -- shorthand for Ownership.Kind="Gamepass"
	},
	-- x2 ELO!
	{
		Key         = "B",   -- Monetization_Mod.Gamepass_Data key
		Kind        = "Gamepass",
		Title       = "x2 ELO!",
		Icon        = "rbxassetid://140028327825184",
		OldPrice    = 500,
		NewPrice    = 249, -- discounted
		IsOfferActive = false,
		EndsAt      = os.time({year=2025, month=12, day=30, hour=23, min=59, sec=59}),
		Priority    = 98,
		HideIfOwned = true,
	},

	-- x2 Cash!
	{
		Key         = "C",
		Kind        = "Gamepass",
		Title       = "x2 Cash!",
		Icon        = "rbxassetid://111390267501817",
		OldPrice    = 250,
		NewPrice    = 149,
		IsOfferActive = false,
		EndsAt      = os.time({year=2025, month=12, day=30, hour=23, min=59, sec=59}),
		Priority    = 97,
		HideIfOwned = true,
	},

	-- Exclusive Emotes!
	{
		Key         = "D",
		Kind        = "Gamepass",
		Title       = "Exclusive Emotes!",
		Icon        = "rbxassetid://140138999956473",
		OldPrice    = 300,
		NewPrice    = 199,
		IsOfferActive = false,
		EndsAt      = os.time({year=2025, month=12, day=30, hour=23, min=59, sec=59}),
		Priority    = 96,
		HideIfOwned = true,
	},

	-- x3 Luck!
	{
		Key         = "E",
		Kind        = "Gamepass",
		Title       = "x3 Luck!",
		Icon        = "rbxassetid://111648715389151",
		OldPrice    = 200,
		NewPrice    = 119,
		IsOfferActive = false,
		EndsAt      = os.time({year=2025, month=12, day=30, hour=23, min=59, sec=59}),
		Priority    = 99,
		HideIfOwned = true,
	},

	-- x2 Luck!
	{
		Key         = "F",
		Kind        = "Gamepass",
		Title       = "x2 Luck!",
		Icon        = "rbxassetid://113302080319391",
		OldPrice    = 99,
		NewPrice    = 75,
		IsOfferActive = false,
		EndsAt      = os.time({year=2025, month=12, day=30, hour=23, min=59, sec=59}),
		Priority    = 94,
		HideIfOwned = true,
	},
}

-- Price configuration by rarity
local RARITY_GEM_PRICE = {
	Default = {
		price = 0,
		discount = 0,  -- 50% off 
	},
	Bronze = {
		price = 30,
		discount = 0.50,  -- 50% off 
	},
	Silver = {
		price = 50,
		discount = 0.30,
	},
	Gold = {
		price = 100,
		discount = 0.10,
	},
	Diamond = {
		price = 500,
		discount = 0.05,
	},
	Platinum = {
		price = 1000,
		discount = 0.01,
	},
	Special = {
		price = 0,
		discount = 0, 
	}
}

local Gloves_Prices_Data = {
	-- Default
	['A']  = {Name="MMA Gloves",                Rarity="Default"},

	-- Tape Crate (Bronze)
	['B']  = {Name="Black Tape",                Rarity="Bronze"},
	['C']  = {Name="Blue Tape",                 Rarity="Bronze"},
	['D']  = {Name="Green Tape",                Rarity="Bronze"},
	['E']  = {Name="Red Tape",                  Rarity="Bronze"},
	['F']  = {Name="Tan Tape",                  Rarity="Bronze"},
	['G']  = {Name="White Tape",                Rarity="Bronze"},
	['H']  = {Name="Purple Tape",               Rarity="Bronze"},

	-- Gloves Crate (Bronze except Mystic → Special)
	['I']  = {Name="Blue Gloves",               Rarity="Bronze"},
	['J']  = {Name="Green Gloves",              Rarity="Bronze"},
	['K']  = {Name="Mystic Gloves",             Rarity="Special"},
	['L']  = {Name="Purple Gloves",             Rarity="Bronze"},

	-- Country Crate #1 (Bronze)
	['M']  = {Name="Argentinian Gloves",        Rarity="Bronze"},
	['N']  = {Name="Australian Gloves",         Rarity="Bronze"},
	['O']  = {Name="Brazilian Gloves",          Rarity="Bronze"},
	['P']  = {Name="Canadian Gloves",           Rarity="Bronze"},
	['Q']  = {Name="Chilean Gloves",            Rarity="Bronze"},
	['R']  = {Name="Chinese Gloves",            Rarity="Bronze"},
	['S']  = {Name="English Gloves",            Rarity="Bronze"},

	-- Country Crate #2 (Bronze)
	['T']  = {Name="French Gloves",             Rarity="Bronze"},
	['U']  = {Name="Georgian Gloves",           Rarity="Bronze"},
	['V']  = {Name="Italian Gloves",            Rarity="Bronze"},
	['W']  = {Name="Jamacian Gloves",           Rarity="Bronze"},
	['X']  = {Name="Japanese Gloves",           Rarity="Bronze"},
	['Y']  = {Name="Mexican Gloves",            Rarity="Bronze"},
	['Z']  = {Name="Moldovan Gloves",           Rarity="Bronze"},

	-- Country Crate #3 (Bronze)
	['A1'] = {Name="Nigerian Gloves",           Rarity="Bronze"},
	['B1'] = {Name="Polish Gloves",             Rarity="Bronze"},
	['C1'] = {Name="New Zealand Gloves",        Rarity="Bronze"},
	['D1'] = {Name="Russian Gloves",            Rarity="Bronze"},
	['E1'] = {Name="Spanish Gloves",            Rarity="Bronze"},
	['F1'] = {Name="USA Gloves",                Rarity="Bronze"},
	['G1'] = {Name="Orange Gloves",             Rarity="Bronze"},
	['H1'] = {Name="White Gloves",              Rarity="Bronze"},

	-- Urban Gloves
	['I1'] = {Name="Graffiti Gloves",           Rarity="Bronze"},
	['J1'] = {Name="Iron Gloves",               Rarity="Bronze"},
	['K1'] = {Name="Gold Gloves",               Rarity="Gold"},
	['L1'] = {Name="Corrupted Purple Gloves",   Rarity="Diamond"},
	['M1'] = {Name="Corrupted Green Gloves",    Rarity="Diamond"},
	['N1'] = {Name="Corrupted Black Gloves",    Rarity="Diamond"},

	-- Fury Crate 1
	['O1'] = {Name="Plastic Green Tape",        Rarity="Bronze"},
	['P1'] = {Name="Plastic Blue Tape",         Rarity="Bronze"},
	['Q1'] = {Name="Plastic Pink Tape",         Rarity="Gold"},
	['R1'] = {Name="Frozen Chain Tape",         Rarity="Diamond"},
	['S1'] = {Name="Molten Chain Tape",         Rarity="Diamond"},
	['T1'] = {Name="Carbon Chain Tape",         Rarity="Diamond"},

	-- Underground Crate 1
	['U1'] = {Name="Plastic Green Gloves",      Rarity="Bronze"},
	['V1'] = {Name="Plastic Blue Gloves",       Rarity="Bronze"},
	['W1'] = {Name="Plastic Pink Gloves",       Rarity="Gold"},
	['X1'] = {Name="Blue Flame Gloves",         Rarity="Diamond"},
	['Y1'] = {Name="Lava Gloves",               Rarity="Diamond"},
	['Z1'] = {Name="Carbon Gloves",             Rarity="Platinum",},

	-- Chromatic
	['A2'] = {Name="Chromatic Green Gloves",    Rarity="Gold"},
	['B2'] = {Name="Chromatic Blue Gloves",     Rarity="Gold"},
	['C2'] = {Name="Chromatic Pink Gloves",     Rarity="Gold"},
	['D2'] = {Name="Chromatic Green Tape",      Rarity="Diamond"},
	['E2'] = {Name="Chromatic Blue Tape",       Rarity="Diamond"},
	['F2'] = {Name="Chromatic Pink Tape",       Rarity="Diamond"},
	['G2'] = {Name="Fury Gloves",               Rarity="Platinum"},

	-- New Gloves
	['H2']  = {Name="Spiderman Red Blue",    	Rarity="Platinum"},
	['I2']  = {Name="Spiderman Blue Red",     Rarity="Platinum"},
	['J2']  = {Name="Spiderman Red Black",    Rarity="Platinum"},
	['K2']  = {Name="Spiderman Black Red",    Rarity="Platinum"},
	['L2']  = {Name="Hungary Gloves",    			Rarity="Bronze"},
	['M2']  = {Name="Thailand Gloves",   			Rarity="Bronze"},
}

local Shorts_Prices_Data = {
	['A']  = {Name="MMA Shorts",         Rarity="Default"},
	['B']  = {Name="Karate Shorts",      Rarity="Bronze"},
	['C']  = {Name="Denim",              Rarity="Silver"},
	['D']  = {Name="Dragon Gold",        Rarity="Diamond"},
	['E']  = {Name="Black Champs",       Rarity="Bronze"},

	-- Country Crate #1 
	['F']  = {Name="Argentinian Shorts", Rarity="Bronze"},
	['G']  = {Name="Australian Shorts",  Rarity="Bronze"},
	['H']  = {Name="Brazilian Shorts",   Rarity="Bronze"},
	['I']  = {Name="Canadian Shorts",    Rarity="Bronze"},
	['J']  = {Name="Chilean Shorts",     Rarity="Bronze"},
	['K']  = {Name="Chinese Shorts",     Rarity="Bronze"},
	['L']  = {Name="England Shorts",     Rarity="Bronze"},

	-- Country Crate #2 
	['M']  = {Name="French Shorts",      Rarity="Bronze"},
	['N']  = {Name="Georgian Shorts",    Rarity="Bronze"},
	['O']  = {Name="Italian Shorts",     Rarity="Bronze"},
	['P']  = {Name="Jamaican Shorts",    Rarity="Bronze"},
	['Q']  = {Name="Japanese Shorts",    Rarity="Bronze"},
	['R']  = {Name="Mexican Shorts",     Rarity="Bronze"},
	['S']  = {Name="Moldovan Shorts",    Rarity="Bronze"},

	-- Country Crate #3
	['T']  = {Name="Mystic Shorts",      Rarity="Gold" },
	['U']  = {Name="New Zealand Shorts", Rarity="Bronze"},
	['V']  = {Name="Nigerian Shorts",    Rarity="Bronze"},
	['W']  = {Name="Polish Shorts",      Rarity="Bronze"},
	['X']  = {Name="Russian Shorts",     Rarity="Bronze"},
	['Y']  = {Name="Spanish Shorts",     Rarity="Bronze"},
	['Z']  = {Name="USA Shorts",         Rarity="Bronze"},

	-- New Shorts
	['A1']  = {Name="Spiderman Black Shorts",   Rarity="Platinum"},
	['B1']  = {Name="Spiderman Blue Shorts",    Rarity="Platinum"},
	['C1']  = {Name="Thailand Shorts",       	Rarity="Bronze"},
	['D1']  = {Name="Hungary Shorts",       	Rarity="Bronze"},

}

local function IsItemExcludedFromOffer(Rarity)
	if not Rarity then
		return true
	end
	if Rarity=="Special" or Rarity=="Default" then
		return true
	end
	if RARITY_GEM_PRICE[Rarity].price<=0 then
		return true
	end
	return false
end

local function playerDataBool(plr, name)
	local PD = plr:FindFirstChild("Player_Data")
	local v = PD and PD:FindFirstChild(name)
	return v and (v.Value == true) or false
end

local function Get_Player_Val(Plr, Val)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Val) ~= nil) then
		return PD:FindFirstChild(Val)
	end

	return nil
end

local function IsGamepass_Owned(Plr, Key)
	local Owned_Gamepass_Val = Get_Player_Val(Plr, "Owned Gamepasses")
	if(Owned_Gamepass_Val ~= nil) then
		local Owned_Keys = string.split(Owned_Gamepass_Val.Value, ",")
		if(table.find(Owned_Keys, Key) == nil)then
			return false
		end
		return true
	end
end

local function ownsByDescriptor(plr, def)
	local kind = def.Ownership and def.Ownership.Kind
	if not kind then
		-- fallback shorthand for gamepasses
		if def.Kind == "Gamepass" and def.HideIfOwned then
			--	local gp = Monetization_Mod.Get_All_Gamepass_Data()[def.Key]
			return IsGamepass_Owned(plr, def.Key) or false
		end
		return false
	end

	if kind == "Gamepass" then
		--local gp = Monetization_Mod.Get_All_Gamepass_Data()[def.Key]
		return IsGamepass_Owned(plr, def.Key) or false

	elseif kind == "GlovesKey" then
		local k = def.Ownership.Key
		if type(Clothing_Mod.Player_Owns_Gloves_Key) == "function" then
			return Clothing_Mod.Player_Owns_Gloves_Key(plr, k) == true
		end
		return false

	elseif kind == "ShortsKey" then
		local k = def.Ownership.Key
		if type(Clothing_Mod.Player_Owns_Shorts_Key) == "function" then
			return Clothing_Mod.Player_Owns_Shorts_Key(plr, k) == true
		end
		return false

	elseif kind == "AccessoryKey" then
		local k = def.Ownership.Key
		if type(Clothing_Mod.Player_Owns_Accessory) == "function" then
			return Clothing_Mod.Player_Owns_Accessory(plr, k) == true
		end
		-- fallback string list
		local PD = plr:FindFirstChild("Player_Data")
		local ownedV = PD and PD:FindFirstChild("Owned Accessories")
		if ownedV then
			local arr = string.split(ownedV.Value, ",")
			return table.find(arr, k) ~= nil
		end
		return false

	elseif kind == "UGCKey" then
		local k = def.Ownership.Key -- FIX: use Ownership.Key, not def.Key
		return Player_Owns_Item_UGC(plr, k)

	elseif kind == "PlayerDataFlag" then
		return playerDataBool(plr, def.Ownership.Flag) == (def.Ownership.Value ~= false)
	end

	return false
end

local function applyPriceRules(dataTable)
	for key, item in pairs(dataTable) do
		local rarity = item.Rarity
		local cfg = RARITY_GEM_PRICE[rarity]

		if cfg then
			item.Gems = cfg.price
			item.DiscountedGems = math.floor(cfg.price * (1 - cfg.discount))
		end
	end
end

local function computeItemPrices()
	applyPriceRules(Gloves_Prices_Data)
	applyPriceRules(Shorts_Prices_Data)
end

-- Apply dynamic gem pricing at module load
computeItemPrices()


function Offers_Config.GetClothDataByKey(key, isGloves)
	if isGloves then
		return Gloves_Prices_Data[key]

	else
		return Shorts_Prices_Data[key]
	end
end

function Offers_Config.InsertOffer(Offer)
	table.insert(Offers_Config.Offers,Offer)
end


function Offers_Config.GetAndCreateClothOfferOnKey(plr,OKey,OKind,EndsAt)

	local offer=Offers_Config.getOfferDataByKey(OKind,OKey)


	if offer then
		return offer
	end
	local FOUR_DAYS = 4 * 24 * 60 * 60
	local data
	local newTime =  os.time()+FOUR_DAYS
	if EndsAt then
		newTime =EndsAt 
	end

	if OKind == "Gloves" then

		data = Gloves_Prices_Data[OKey]

	else
		data = Shorts_Prices_Data[OKey]

	end
	if IsItemExcludedFromOffer(Gloves_Prices_Data[OKey].Rarity) then
		newTime = 300
	end

	 offer={
		Key         = OKey,
		Kind        = OKind,
		Title       = data.Name,
		Icon        = "", 
		OldPrice    = data.Gems,
		NewPrice    = data.DiscountedGems,
		EndsAt      = newTime,
		Priority    = 1,
		Consumable  = false,
		HideIfOwned = true,
		IsOfferActive = true,
		Ownership   = { Kind = OKind.."Key", Key = OKey }
	}
	local isOwn = ownsByDescriptor(plr,offer)
	if not isOwn then
		Offers_Config.InsertOffer(offer)
		return offer
	end
	return nil
end

function Offers_Config.GetAndCreateClothOffer(plr)
	local FOUR_DAYS = 4 * 24 * 60 * 60
	local number = math.random(1, 50)
	local itemKind="Gloves"
	local itemIndex=1
	local ItemData
	local ItemKey
	local keys = {}
	local price
	local OldPrice
	local PP = Offers_SavedData.LoadOfferState("ClothOffer_",plr)
	task.wait()
	local expiredSet = {}
	if PP and PP.expiredItems then
		for _, v in ipairs(PP.expiredItems) do
			if type(v) == "string" then
				expiredSet[v] = true
			elseif type(v) == "table" then
				local k = v.Key or v.RefName
				if type(k) == "string" then
					expiredSet[k] = true
				end
			end
		end
	end
	if number % 2 == 0 then
		itemKind="Shorts"

		local List=Clothing_Mod.Get_All_Shorts_Data()
		for k in pairs(List) do
			table.insert(keys, k)
		end
		table.sort(keys) 
		local isOwned=true
		local attempts=0
		local maxAttempts = #keys
		while isOwned and attempts < maxAttempts do
			attempts += 1
			--itemIndex = math.random(1, 15)
			ItemKey=keys[itemIndex]
			isOwned=Clothing_Mod.Player_Owns_Shorts_Key(plr,ItemKey)
			--	print("Shorts_",ItemKey,isOwned)
			if expiredSet[ItemKey.."_"..itemKind] or  IsItemExcludedFromOffer(Shorts_Prices_Data[ItemKey].Rarity) then
				isOwned=true
			end
			itemIndex+=1
		end
		OldPrice = Shorts_Prices_Data[ItemKey].Gems
		price = Shorts_Prices_Data[ItemKey].DiscountedGems
		ItemData=List[ItemKey]
	else

		local List=Clothing_Mod.Get_All_Gloves_Data()
		for k in pairs(List) do
			table.insert(keys, k)
		end
		table.sort(keys) 
		local isOwned=true

		local attempts=0
		local maxAttempts = #keys
		while isOwned and attempts < maxAttempts do
			attempts += 1
			--	itemIndex = math.random(1, 30)
			ItemKey=keys[itemIndex]
			isOwned=Clothing_Mod.Player_Owns_Gloves_Key(plr,ItemKey)
			--	print("Gloves_",ItemKey,isOwned)

			if expiredSet[ItemKey.."_"..itemKind] or  IsItemExcludedFromOffer(Gloves_Prices_Data[ItemKey].Rarity) then
				isOwned=true
			end
			itemIndex+=1
		end
		OldPrice = Gloves_Prices_Data[ItemKey].Gems
		price = Gloves_Prices_Data[ItemKey].DiscountedGems
		ItemData=List[ItemKey]
	end
	local offer={

		Key         = ItemKey,
		Kind        = itemKind,
		Title       = ItemData,
		Icon        = "", 
		OldPrice    = OldPrice,
		NewPrice    = price,
		EndsAt      = os.time()+FOUR_DAYS,
		Priority    = 1,
		Consumable  = false,
		HideIfOwned = true,
		IsOfferActive = true,
		Ownership   = { Kind = itemKind.."Key", Key = ItemKey }
	}
	

	Offers_Config.InsertOffer(offer)
	return offer
end


-- --- helpers ---
function Offers_Config.parseName(name)
	local prio, key, title = string.match(name, "^(%d+)%s*/%s*(%d+)%s*/%s*(.+)$")
	if not prio then return end
	return tonumber(prio), tostring(key), title
end
local function FindUGCFromListByKey(key)
	local list = UGCOffers_Config.UGCItemsConfig or {}
	for _,item in pairs(list) do
		if tostring(item.Key)==tostring(key) then
			return item
		end
	end
	return nil
end
function Offers_Config.GenerateUGCSavedOffer (name)
	local prio, key, title = Offers_Config.parseName(name)
	local _item = FindUGCFromListByKey(key)
	if _item then
		return _item
	end
	local item={
		Key = key,
		Kind = "UGC",
		Title = title,
		RefName=name,
		Priority = prio,
		EndsAt = 0,     
	}
	return item
end

function Offers_Config.GetUGCItemNew(plr)
	local profile = Offers_SavedData.LoadOfferState("offer_1_",plr)
	local expiredSet = {}
	if profile and profile.expiredItems then
		for _, v in ipairs(profile.expiredItems) do
			if type(v) == "string" then
				expiredSet[v] = true
			elseif type(v) == "table" then
				local k = v.Key or v.RefName
				if type(k) == "string" then
					expiredSet[k] = true
				end
			end
		end
	end

	local function isActive(item)
		-- Treat missing flags as active by default
		if item.IsOfferActive == false then
			return false
		end

		-- Resolve the canonical key we’ll use everywhere
		local key= item.RefName
		if type(key) ~= "string" or key == "" then
			return false
		end

		if expiredSet[key] then
			return false
		end
		return true
	end

	local list = UGCOffers_Config.UGCItemsConfig or {}
	local best = nil
	local allActiveOffers={}
	for _, item in ipairs(list) do
		local key = item.Key or item.RefName
		if type(key) == "string" and key ~= "" then
			if isActive(item) and not Player_Owns_Item_UGC_ServerCheck(plr, key) then

				local pri    = tonumber(item.Priority) or 0
				local title  = tostring(item.Title or "")

				if not best
					or pri > (tonumber(best.Priority) or 0)
					or (pri == (tonumber(best.Priority) or 0) and title < tostring(best.Title or "")) then
					best = item
				end
				table.insert(allActiveOffers,item)
				if #allActiveOffers>20 then
					break
				end
			end
		end
	end

	return best ,allActiveOffers -- may be nil if everything is owned/inactive/expired
end






local function getPlayerCoins(plr)
	local PD = plr:FindFirstChild("Player_Data")
	local v = PD and PD:FindFirstChild("Coins")
	return (v and tonumber(v.Value)) or 0
end


local function getDevType(key)
	local t = Monetization_Mod.Get_All_Dev_Product_Data()[key]
	return t and t.Type or nil
end

-- default consumable inference from Dev Type
local TypeConsumableDefault = {
	Cash = true,
	Gems = true,
	["StarterPack"] = false,
	["Special Gloves"] = false,
	Bundle = false,
}

local function isConsumable(def)
	if def.Consumable ~= nil then return def.Consumable end
	if def.Kind == "Gamepass" then return false end
	-- DevProduct: infer from type
	local t = getDevType(def.Key)
	if not t then return false end
	local v = TypeConsumableDefault[t]
	if v == nil then
		-- unknown types treated as non-consumable by default (safer)
		return false
	end
	return v
end

function Player_Owns_Item_UGC(Plr, Key)
	local ID = Monetization_Mod.Get_All_UGC_Data()[Key].ID
	return Player_Owns_Item_UGC_ServerCheck(Plr,ID)
end

function Player_Owns_Item_UGC_ServerCheck(Plr, ID)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = MPS:PlayerOwnsAsset(Plr, ID)
		end)

		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end

	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end

	return false
end



local function discountText(oldP, newP)
	oldP, newP = tonumber(oldP), tonumber(newP)
	if not oldP or not newP or oldP <= 0 or newP <= 0 then return "" end
	local pct = math.floor(((oldP - newP) / oldP) * 100)
	if pct < 0 then pct = 0 end
	return pct > 0 and ("-" .. pct .. "%") or ""
end




-- one row → UI payload (preformatted)
function Offers_Config.rowForClient(plr, def)
	-- Guard: offer inactive
	if not def.IsOfferActive then
		return nil
	end

	-- Expiry check
	local endsAt = tonumber(def.EndsAt) or 0
	if endsAt > 0 and os.time() > endsAt then
		return nil
	end

	-- Resolve catalog entry
	local entry, data
	if def.Kind == "DevProduct" then
		entry = Monetization_Mod.Get_All_Dev_Product_Data()[def.Key]
		if not entry then return nil end
		data = Item_Price_Icon.getPriceInfo(def.Kind, entry.ID)

	elseif def.Kind == "UGC" then
		entry = Monetization_Mod.Get_All_UGC_Data()[def.Key]
		if not entry then return nil end
		data = Item_Price_Icon.getPriceInfo(def.Kind, entry.ID)

	elseif def.Kind == "Gamepass" then
		entry = Monetization_Mod.Get_All_Gamepass_Data()[def.Key]
		if not entry then return nil end
		data = Item_Price_Icon.getPriceInfo(def.Kind, entry.ID)

	elseif def.Kind == "Gloves" or def.Kind == "Shorts" then
		-- These aren’t Roblox catalog items, only internal Clothing_Mod keys
		entry = {
			Name = def.Title,
			Icon = def.Icon,
			ID   = def.Key,
		}
		data = { price = def.NewPrice } -- manual, no Marketplace lookup

	else
		return nil -- unsupported type
	end

	-- Ownership check (skip if already owned and non-consumable)
	local consumable = isConsumable(def)
	if not consumable then
		if ownsByDescriptor(plr, def) then
			return nil
		end
	end

	-- Final payload for client UI
	return {
		ProductKey   = def.Key,
		Kind         = def.Kind,                               -- "DevProduct" | "Gamepass" | "UGC" | "Gloves" | "Shorts"
		Title        = def.Title or (entry and entry.Name) or "Offer",
		ItemIcon     = def.Icon or (entry and entry.Icon) or "",
		Amount       = def.Amount or "",
		OldPrice     = def.OldPrice,
		NewPrice     = data and data.price or def.NewPrice,
		DiscountText = discountText(def.OldPrice, def.NewPrice),
		EndsAt       = endsAt,
		ShowAfter    = tonumber(def.ShowAfter) or 0,
		_Priority    = tonumber(def.Priority) or 0,            -- internal sort key
		Ownership    = def.Ownership or nil
	}
end

function Offers_Config.getOfferDataByKey(Kind,key)
	for _, def in ipairs(Offers_Config.Offers) do
		if def.Key == key and def.Kind==Kind then
			return def
		end
	end
	return nil
end

function Offers_Config.IsItemOwned(plr,Kind, Key)
	local def = Offers_Config.getOfferDataByKey(Kind,Key)
	if not def then return true end
	return ownsByDescriptor(plr, def)
end

function Offers_Config.getOfferByKey(plr,Kind, key)
	local def = Offers_Config.getOfferDataByKey(Kind,key)
	if not def then return nil end
	return Offers_Config.rowForClient(plr, def)
end

-- Build ALL eligible rows
function Offers_Config.buildPayload(plr)
	local out = {}
	for _, def in ipairs(Offers_Config.Offers) do
		local row = Offers_Config.rowForClient(plr, def)
		if row then
			table.insert(out, row)
		end
	end
	return out
end
-- Dynamic eligibility rules at pick time (after rows are built)
function Offers_Config.isRowEligibleNow(plr, row)

	if row.Kind == "Gloves" then
		local data = Gloves_Prices_Data[row.ProductKey]

		if data and  IsItemExcludedFromOffer(data.Rarity) then
			return false
		end
	elseif row.Kind == "Shorts" then
		local data = Shorts_Prices_Data[row.ProductKey]
		if data and IsItemExcludedFromOffer(data.Rarity) then
			return false
		end
	end

	-- Guard: expired rows shouldn’t be picked
	if row.EndsAt and row.EndsAt > 0 and os.time() > row.EndsAt and row.IsOfferActive then
		return false
	end

	-- Rule A: If player has >coinsLimit Coins, skip Cash DevProduct offers
	if row.Kind == "DevProduct" then
		local dev = Monetization_Mod.Get_All_Dev_Product_Data()[row.ProductKey]
		if dev and dev.Type == "Cash" then
			if getPlayerCoins(plr) > coinsLimit then 
				return false
			end
		end
	end

	-- Rule B: If it’s a gamepass and the player already owns it, skip
	if row.Kind == "Gamepass" then
		return (not IsGamepass_Owned(plr, row.ProductKey)) or true
	end

	return true
end

function Offers_Config.pickTopOffer(plr)
	local rows = Offers_Config.buildPayload(plr)

	-- Filter by dynamic eligibility
	local eligible = {}
	for _, r in ipairs(rows) do
		if Offers_Config.isRowEligibleNow(plr, r) then
			table.insert(eligible, r)
		end
	end

	-- Nothing left? return nil so server sends no offer
	if #eligible == 0 then
		return nil
	end

	-- Sort by Priority (desc), then EndsAt (earliest first)
	table.sort(eligible, function(a, b)
		local ap = tonumber(a._Priority) or 0
		local bp = tonumber(b._Priority) or 0
		if ap ~= bp then
			return ap > bp
		end
		local ae = tonumber(a.EndsAt) or math.huge
		local be = tonumber(b.EndsAt) or math.huge
		return ae < be
	end)

	return eligible[1]
end
return Offers_Config
]]></ProtectedString>
						<string name="ScriptGuid">{FF5F1B62-020A-486F-932C-BAF43585DFC8}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Offers_Config.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX71F5F2E7553E4432AAC3C096994B7555">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Offers_Config</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXAFB830983ACD4DC49A991FDDA5091E57">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Offers_Config/GetPrice_Icon.lua
--
--  Description:
--      Utility to fetch price and icon metadata for Gamepasses, UGC
--      items, and Developer Products. Uses MarketplaceService and
--      AvatarEditorService with caching to reduce request overhead.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * MarketplaceService
--          * AvatarEditorService
--
--  Notes:
--      - Functions:
--          * thumbUrl(kind, id, w, h): builds thumbnail URL
--          * getPriceInfo(kind, id): returns {price, isForSale, name, iconImage}
--      - Supports:
--          * Gamepasses (via MPS.GetProductInfo, InfoType.GamePass)
--          * UGC/Assets (via AES.GetItemDetails, fallback to MPS)
--          * DevProducts (via MPS.GetProductInfo, InfoType.Product)
--      - Internal cache (TTL = 5s) avoids spamming API calls
--
--======================================================================



local MPS = game:GetService("MarketplaceService")
local AES = game:GetService("AvatarEditorService")

local GetPrice_Icon = {}

GetPrice_Icon.CACHE = {}    -- [cacheKey] = { t = os.clock(), data = ... }
GetPrice_Icon.TTL   = 5

function GetPrice_Icon.thumbUrl(kind: string, id: number, w: number, h: number): string?
	if kind == "Gamepass" then
		return string.format("rbxassetid://"..id)
	elseif kind == "UGC" then
		return string.format("rbxassetid://"..id)
	end
	return nil -- DevProduct: supply custom icon
end

function GetPrice_Icon.getPriceInfo(kind: string, idIn: number | string)
	kind = string.lower(kind)
	local id = tonumber(idIn)
	if not id then return nil end

	local cacheKey = kind .. ":" .. id
	local now = os.clock()
	local c = GetPrice_Icon.CACHE[cacheKey]
	if c and (now - c.t) < GetPrice_Icon.TTL then
		return c.data
	end

	local data = { price = nil, isForSale = nil, name = nil, iconImage = nil }

	if kind == "gamepass" then
		local ok, info = pcall(MPS.GetProductInfo, MPS, id, Enum.InfoType.GamePass)
		if ok and info then
			data.price = info.PriceInRobux
			data.isForSale = info.IsForSale
			data.name = info.Name
			data.iconImage = GetPrice_Icon.thumbUrl("Gamepass", id, 150, 150)
		end

	elseif kind == "ugc" or kind == "asset" then
		-- Primary: AES for accurate current pricing (incl. limiteds/resales)
		local ok1, details = pcall(AES.GetItemDetails, AES, id, Enum.AvatarItemType.Asset)
		if ok1 and details then
			data.price = details.Price or details.LowestResalePrice
			data.isForSale = details.IsForSale
			data.name = details.Name or details.ItemName
			data.iconImage = GetPrice_Icon.thumbUrl("UGC", id, 150, 150)
		else
			-- Fallback: MPS
			local ok2, info = pcall(MPS.GetProductInfo, MPS, id, Enum.InfoType.Asset)
			if ok2 and info then
				data.price = info.PriceInRobux
				data.isForSale = info.IsForSale
				data.name = info.Name
				data.iconImage = GetPrice_Icon.thumbUrl("UGC", id, 150, 150)
			end
		end

	elseif kind == "devproduct" or kind == "product" then
		local ok, info = pcall(MPS.GetProductInfo, MPS, id, Enum.InfoType.Product)
		if ok and info then
			data.price = info.PriceInRobux
			data.isForSale = true -- purchasable via prompt
			data.name = info.Name
			-- DevProduct: no official icon
		end
	end

	-- Only cache if we actually got something meaningful
	if data.name or data.price or data.isForSale ~= nil then
		GetPrice_Icon.CACHE[cacheKey] = { t = now, data = data }
	end
	return data
end

return GetPrice_Icon
]]></ProtectedString>
							<string name="ScriptGuid">{7381D68E-A784-4524-B5CB-265750021B50}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">GetPrice_Icon.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX608BA5A1C3BA4668A8862508EABA7A09">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Offers_Config/UGCItemHelper.lua
--
--  Description:
--      Builds dynamic configuration of UGC items from
--      ReplicatedStorage/OfferItems/UGCItems. Parses instance names
--      into Priority/Key/Title and maintains a sorted list with live
--      updates on folder changes.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Models/UGC/OfferItems/UGCItems (instances representing UGC items)
--
--  Notes:
--      - Expected instance name format: "Priority/Key/Title"
--      - Each item entry includes:
--          * Key, Kind="UGC", Title, RefName
--          * Priority (higher = shown first)
--          * EndsAt (0 = no expiration)
--          * IsOfferActive (default true)
--          * _ref (reference to original instance)
--      - Items are sorted by Priority (desc) then Title (asc)
--      - Hooks folder changes (add/remove/rename/attribute change)
--        to auto-refresh UGCItemsConfig
--
--======================================================================




local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UGC_FOLDER = ReplicatedStorage:WaitForChild("Models"):WaitForChild("UGC"):WaitForChild("OfferItems"):WaitForChild("UGCItems")
local Monetization_Mod = require(ReplicatedStorage:WaitForChild("Data_Mods_F"):WaitForChild("Monetization_Mod"))
local M = {}
M.UGCItemsConfig = {}
--["C1"] = { Name = "Nerd Glasses - Green", ID = 77949725271695, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=77949725271695&w=150&h=150" },
local AllUGCs = Monetization_Mod.Get_All_UGC_Data()

local function FindItemByIDKeyMatch(key)
	for	indexkey,item in pairs(AllUGCs) do
	--	print(indexkey,item)
		if tostring(item.ID)==tostring(key) then
			--print(item.Name ," Matched ")
			return indexkey,item
		end
	end
	return nil,nil
end

-- parse "Priority/Key/Title"

local function parseName(name) 
	local prio, key, title = string.match(name, "^(%d+)%s*/%s*(%d+)%s*/%s*(.+)$")
	if not prio then return end
	return tonumber(prio), tostring(key), title
end

local function rebuild()
	local items = {}
	for _, inst in ipairs(UGC_FOLDER:GetChildren()) do
		local prio, key, title = parseName(inst.Name)
		local _MontizationUGCKey,Item= FindItemByIDKeyMatch(key)
		local title2 = title:gsub("-", " ")
		local newTitle =Item and Item.Name or title2
	--	print(newTitle,title,Item,_MontizationUGCKey)
		
		
		if prio then
			table.insert(items, {
				Key = key,
				Kind = "UGC",
				Title = newTitle,
				RefName=inst.Name,
				Priority = prio,
				EndsAt =  0,           -- 0 = no end
				IsOfferActive = true, -- default true
				_ref = inst,
				MontizationUGCKey = _MontizationUGCKey
			})
		else
			warn("[UGCItemHelper] Bad item name (expected 'Priority/Key/Title'):", inst:GetFullName())
		end
	end
	table.sort(items, function(a,b)
		if a.Priority ~= b.Priority then return a.Priority > b.Priority end
		return a.Title < b.Title
	end)
	M.UGCItemsConfig = items
	--print(("[UGCItemHelper] Refreshed. Items: %d"):format(#items))
end

-- hook signals on a single child to catch rename/attribute edits
local function hookChild(inst)
	inst:GetPropertyChangedSignal("Name"):Connect(rebuild)
	inst.AttributeChanged:Connect(rebuild)
end

-- initial build + hooks
rebuild()
for _, c in ipairs(UGC_FOLDER:GetChildren()) do
	hookChild(c)
end

-- folder-level add/remove hooks
UGC_FOLDER.ChildAdded:Connect(function(c)
	hookChild(c)
	rebuild()
end)

UGC_FOLDER.ChildRemoved:Connect(function()
	rebuild()
end)

return M
]]></ProtectedString>
							<string name="ScriptGuid">{E4E895E8-6B4A-4863-8435-FE40DFDDEDC8}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UGCItemHelper.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX2375ACDA75BE49ABAB87E77568FA8BF0">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Offers_Config/OfferStorageData_Mod.lua
--
--  Description:
--      Provides utility functions to manage player offer states in
--      DataStoreService. Supports loading and saving both cloth and
--      UGC offer data, handling active and expired offers.
--
--      Key features:
--        - Load a player’s offer state from DataStore
--        - Save cloth-based offers with tracking of expired items
--        - Save UGC-based offers with podium-specific tracking
--        - Automatically limits the number of stored expired offers
--        - Ensures unique keys per player and per offer/podium
--
--  Author(s): Adnan
--
--  Last Modified: 2025-09-30 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * DataStoreService (PlayerOfferState DataStore)
--      - ReplicatedStorage:
--          * Models/UGC/OfferItems.UGCItems (for counting UGC items)
--      - Player Instances:
--          * UserId used for unique DataStore keys
--
--  Notes:
--      - Uses pcall to safely access DataStore
--      - Maintains a maximum of 30 expired items for cloth offers
--      - UGC expired items limit is determined dynamically based on
--        the number of UGCItems in ReplicatedStorage
--      - Functions are stateless and can be called from server scripts
--======================================================================

local DSS 			= game:GetService("DataStoreService")
local OfferStore	= DSS:GetDataStore("PlayerOfferState")

local OSData = {}

function OSData.LoadOfferState(DataKey,plr)
	local key = DataKey .. plr.UserId
	local ok, Data = pcall(function()
		return OfferStore:GetAsync(key)
	end)
	if ok and Data then
		return Data
	else
		--print("Failed to load offer state for", plr.UserId, err)
	end
	return nil
end

function OSData.SaveClothOfferState(DataKey,plr, offerAC)
	local key = DataKey.. plr.UserId
	local now=os.time() 
	local ok, err = pcall(function()
		OfferStore:UpdateAsync(key, function(old)
			old = old or {}
			old.expiredItems = old.expiredItems or {}
			local prev = old.ActiveOffer

			if prev then
				local expCount = #old.expiredItems
				if expCount == 30 then
					old.expiredItems={}
				else
					table.insert(old.expiredItems, {
						Key = prev.CurrentKey,
						EndedAt = now,
						EndReason ="expired",
					})
				end
			end

			old.ActiveOffer = {
				CurrentKey =offerAC.Key.."_"..offerAC.Kind,
				offer = offerAC
			}
			return old
		end)
	end)

	if not ok then
		warn("Failed to save offer state:", err)
	end
end


local function IsSameDay(t1, t2)
	-- Compare by year + day-of-year to avoid timezone/date string issues
	local d1 = os.date("!*t", t1)
	local d2 = os.date("!*t", t2)
	return d1.year == d2.year and d1.yday == d2.yday
end

function OSData.SaveOfferPurchaseCount(DataKey, plr)
	local key = DataKey .. plr.UserId
	local now = os.time()

	local ok, err = pcall(function()
		OfferStore:UpdateAsync(key, function(old)
			old = old or {}

			old.PurchasedCount = old.PurchasedCount or 0
			local prev = old["LastPurchasedDate"]

			if prev then
				if not IsSameDay(prev, now) then
					old.PurchasedCount = 0
				end
			end

			old.PurchasedCount += 1
			old.LastPurchasedDate = now

			return old
		end)
	end)

	if not ok then
		warn("Failed to save offer state:", err)
	end
end


function OSData.SaveUGCOfferState(DataKey,PodiumID,plr, itemName, endTime)
	--	local key = "offer_1_" .. plr.UserId
	local key = DataKey .. plr.UserId
	local now = os.time()

	local ok, err = pcall(function()
		OfferStore:UpdateAsync(key, function(old)
			old = old or {}
			old.expiredItems = old.expiredItems or {}
			local prev 

			if old.ActiveOffer then

				prev= old.ActiveOffer[PodiumID] or {}
			else
				old.ActiveOffer={}
			end
			if prev then
				local expCount = #old.expiredItems
				local folderCount=#game.ReplicatedStorage.Models.UGC.OfferItems.UGCItems:GetChildren()
				if expCount >= (folderCount-1) then
					old.expiredItems={}
				end
				table.insert(old.expiredItems, {
					Key = prev.CurrentKey,
					EndedAt = now,
					EndReason ="expired",
				})
			end
			old.ActiveOffer[PodiumID] = {
				CurrentKey = itemName,
				EndsAt     = endTime,
				StartedAt  = now,
			}
			return old
		end)
	end)

	if not ok then
		warn("Failed to save offer state:", err)
	end
end

return OSData
]]></ProtectedString>
							<string name="ScriptGuid">{AE1EC8F5-C6CE-456E-8711-645EEC203C5C}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">OfferStorageData_Mod.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX1113936E6E4C4547864B1E2BB0BC321A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/UGC_Pack_Config.lua
--
--  Description:
--      Configuration module defining all available UGC (User Generated Content)
--      packs and their associated avatar assets. Each pack contains a list of
--      accessories with Roblox asset IDs and human-readable titles.
--      Used by UGC_Pack_Handle.lua for accessory application, ownership checks,
--      and purchase setup.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-11-14 by Adnan
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * None (data-only module)
--
--  Exports:
--      - UGCPC.UGCPacks : table
--          Structure:
--              {
--                  ["PackName"] = {
--                      items = {
--                          { id = "AssetId", Title = "Display Name" },
--                          ...
--                      }
--                  }
--              }
--
--  Features:
--      - Centralized configuration for all UGC item packs
--      - Supports dynamic loading via require()
--      - Easily extendable with new packs or assets
--      - Read-only data table to be consumed by server scripts
--
--  Notes:
--      - Intended for use under ReplicatedStorage/Data_Mods_F/
--      - Ensure all listed AssetIds are valid published Roblox assets
--      - Avoid direct modification at runtime; treat as static data
--
--======================================================================

local UGCPC = {}--UGC_Pack_Config

local packs = {




	["Pack1"]={
		items={
			{
				id = "115157954314498",
				Title="MMA Gloves around Neck"
			},
			{
				id = "112667835660803",
				Title="VVS-Double-Chain-MMA-Fighter"
			},
			{
				id = "84934153889096",
				Title="MMA-FIGHTERS-CHAMPIONS-BELT"
			},
			{
				id = "87085165668528",
				Title="Protein-Shaker-Black"
			},
			{
				id = "101251472607139",
				Title="Dreads-Breads"
			},
		},
	},
	["Pack2"]={

		items={
			{
				id = "114922634621014",
				Title="Big Metal Chain"
			},
			{
				id = "99505840765729",
				Title="MMA FIGHTERS CHAMPION'S BELT"
			},
			{
				id = "135859105132166",
				Title="Realistic Gym Towel on Shoulders"
			},
			{
				id = "98181442625165",
				Title="Protein-Shaker-Red"
			},
			{
				id = "95343467130849",
				Title="Trendy Motorcycle Helmet"
			},
		},
	},
	["Pack3"]={

		items={
			{
				id = "75078885992255",
				Title="Boxing Gloves Around Neck"
			},
			{
				id = "81219496918209",
				Title="Black Gold VVS Chain Diamonds"
			},
			{
				id = "102642333841802",
				Title="Protein Shaker - Yellow"
			},
			{
				id = "79643861023078",
				Title="Snake Glasses Y2K - Orange"
			},
			{
				id = "75995119815868",
				Title="Cowboy Hat"
			},
		},
	},
	["Pack4"]={

		items={
			{
				id = "85169596622861",
				Title="Nerd Glasses"
			},
			{
				id = "81877496476783",
				Title="MMA Fighter Training Helmet - Blue"
			},
			{
				id = "140183743497109",
				Title="Big Black Chain"
			},
			{
				id = "139123166526936",
				Title="MMA Gloves around Neck"
			},
			{
				id = "84934153889096",
				Title="MMA FIGHTERS CHAMPION'S BELT"
			},
		},
	},
}

UGCPC.UGCPacks = packs

return UGCPC]]></ProtectedString>
						<string name="ScriptGuid">{E2C35D76-36A2-49AD-9392-851E67B2F9B4}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UGC_Pack_Config.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF8C7595FFA7E4D0DAFA0A4C2C3139F84">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/PodiumColors_Mod.lua
--
--  Description:
--      Provides a flexible system for defining and applying color schemes
--      across various UI elements, 3D objects, and particle effects.
--      Supports TextLabels, Buttons, Images, BaseParts, Beams, Trails,
--      ParticleEmitters, and UIGradient objects with gradient and 
--      transparency control.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-16 by Adnan
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * None explicitly required; uses standard classes (GuiObject, 
--            BasePart, ParticleEmitter, Beam, Trail)
--
--  Notes:
--      - ColorSchemes table:
--          * Key: scheme name ("S1", "S2", etc.)
--          * NeonEffectColor: Color3
--          * TextColors: Color3
--          * RibbonGradient: table with _1.._5 keys (Color3), 
--            optional gradient_rotation (number) and gradient_transparency (table)
--      - Functions:
--          * ApplyColors(Parent, SchemeName, Specs, TextInfo): applies 
--            a scheme to specified targets under a parent instance
--          * GetScheme(name): returns the color scheme table
--          * SetScheme(name, t): sets or updates a color scheme
--      - Helpers:
--          * toColorSequence(val): converts Color3 or table to ColorSequence
--          * toNumberSequence(tbl): converts table to NumberSequence
--          * ensureUIGradient(gui): ensures a UIGradient exists on GUI
--          * applyValue(obj, schemeVal, TextInfo): internal application logic
--          * findOne(root, pathOrName): resolves single target by path or name
--          * resolveTargets(root, nameField): resolves one or more targets
--
--======================================================================

local Color_Mod = {}

Color_Mod.__index = Color_Mod

function Color_Mod.new(Parent, SchemeName, Specs,TextInfo)
	local self = setmetatable({}, Color_Mod)
	self.Parent=Parent
	self.SchemeName=SchemeName
	self.Specs=Specs
	self.TextInfo=TextInfo
	self:ApplyColors(Parent, SchemeName, Specs,TextInfo)
	return self
end
-- =========================
-- Define schemes (simple)
-- =========================
local ColorSchemes = {
	["S1"] = {
		NeonEffectColor = Color3.fromRGB(218, 164, 40),
		RibbonGradient  = {
			_1 = Color3.fromRGB(255, 255, 0),
			_2 = Color3.fromRGB(170, 0, 0),
	
			gradient_rotation = 90, -- UI only
			gradient_transparency = { {t=0, v=0}, {t=1, v=0} },
			gradient_offset       = { x = 0, y = 0}, -- UI only (Vector2-ish)
		},
	},
	["S2"] = {
		NeonEffectColor = Color3.fromRGB(255, 0, 0),
		RibbonGradient  = {
			_1 = Color3.fromRGB(170, 0, 127),
			_2 = Color3.fromRGB(255, 159, 90),
			gradient_rotation = 90, -- UI only
			gradient_transparency = { {t=0, v=0}, {t=1, v=0} },
			gradient_offset       = { x =0, y = 0.05}, -- UI only (Vector2-ish)
		},
	},
	["S3"] = {
		NeonEffectColor = Color3.fromRGB(0, 176, 199),
		RibbonGradient  = {
			_1 = Color3.fromRGB(0, 255, 255),
			_2 = Color3.fromRGB(248, 255, 105),
			gradient_rotation = 90, -- UI only
			
			gradient_transparency = { {t=0, v=0}, {t=1, v=0} },
			gradient_offset       = { x = 0, y = .15}, -- UI only (Vector2-ish)
		},
		
	}
}

-- =========================
-- Small helpers
-- =========================
local function toColorSequence(val)
	if typeof(val) == "ColorSequence" then return val end
	if typeof(val) == "Color3" then
		return ColorSequence.new{
			ColorSequenceKeypoint.new(0, val),
			ColorSequenceKeypoint.new(1, val),
		}
	end
	if typeof(val) == "table" then
		local stops = {}
		for k,v in pairs(val) do
			local n = tonumber(k:match("^_(%d+)$") or "")
			if n then table.insert(stops, {n=n, c=v}) end
		end
		table.sort(stops, function(a,b) return a.n < b.n end)
		if #stops > 0 then
			local keys = {}
			for i, s in ipairs(stops) do
				local t = (#stops == 1) and 0 or (i-1)/(#stops-1)
				table.insert(keys, ColorSequenceKeypoint.new(t, s.c))
			end
			return ColorSequence.new(keys)
		end
	end
	return nil
end

local function toNumberSequence(tbl)
	if typeof(tbl) == "NumberSequence" then return tbl end
	if typeof(tbl) == "table" then
		local pts = {}
		for _,p in ipairs(tbl) do
			if typeof(p) == "table" and p.t and p.v then
				table.insert(pts, NumberSequenceKeypoint.new(p.t, p.v))
			end
		end
		if #pts > 0 then
			table.sort(pts, function(a,b) return a.Time < b.Time end)
			return NumberSequence.new(pts)
		end
	end
	return nil
end

local function ensureUIGradient(gui)
	local g = gui:FindFirstChildOfClass("UIGradient")
	if g then return g end
	g = Instance.new("UIGradient")
	g.Name = "AutoGradient"
	g.Parent = gui
	return g
end

local function isGui(obj) return obj:IsA("GuiObject") end

local function applyValue(obj, schemeVal,textInfo)

	if obj:IsA("TextLabel") and textInfo.CanSetText and obj.Name == textInfo.TextObjName then
		obj.Text = textInfo.Text or ""
	end

	-- UI: use / create UIGradient, support rotation + transparency
	if isGui(obj) then
		local seq = toColorSequence(schemeVal)
		if seq then
			local grad = ensureUIGradient(obj)
			grad.Color = seq
			local off = schemeVal.gradient_offset
			if off then
				if typeof(off) == "Vector2" then
					grad.Offset = off
				elseif type(off) == "table" then
					local x = off.x or off[1] or 0
					local y = off.y or off[2] or 0
					grad.Offset = Vector2.new(x, y)
				end
			else
				grad.Offset = Vector2.new(0, 0)
			end
			
			if typeof(schemeVal) == "table" and schemeVal.gradient_rotation then
				grad.Rotation = math.clamp(tonumber(schemeVal.gradient_rotation) or 0, 0, 360)
			end
			if typeof(schemeVal) == "table" and schemeVal.gradient_transparency then
				local ns = toNumberSequence(schemeVal.gradient_transparency)
				if ns then grad.Transparency = ns end
			end
			return true
		end
	end

	-- Direct UIGradient target
	if obj:IsA("UIGradient") then
		local seq = toColorSequence(schemeVal)
		if seq then
			obj.Color = seq
			if typeof(schemeVal) == "table" and schemeVal.gradient_rotation then
				obj.Rotation = math.clamp(tonumber(schemeVal.gradient_rotation) or 0, 0, 360)
			end
			if typeof(schemeVal) == "table" and schemeVal.gradient_transparency then
				local ns = toNumberSequence(schemeVal.gradient_transparency)
				if ns then obj.Transparency = ns end
			end
			return true
		end
	end

	-- Beam / Trail / ParticleEmitter: gradient sequence (no rotation prop)
	if obj:IsA("Beam") or obj:IsA("Trail") or obj:IsA("ParticleEmitter") then
		local seq = toColorSequence(schemeVal)
		if seq then
			obj.Color = seq
			if obj:IsA("ParticleEmitter") and typeof(schemeVal) == "table" and schemeVal.gradient_transparency then
				local ns = toNumberSequence(schemeVal.gradient_transparency)
				if ns then obj.Transparency = ns end
			end
			return true
		end
	end

	-- Single-color fallbacks (Color3 only)
	if typeof(schemeVal) == "Color3" then
		if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then

			obj.TextColor3 = schemeVal; return true
		end
		if obj:IsA("ImageLabel") or obj:IsA("ImageButton") then
			obj.ImageColor3 = schemeVal; return true
		end
		if obj:IsA("Decal") or obj:IsA("Texture") then
			obj.Color3 = schemeVal; return true
		end
		if obj:IsA("BasePart") then
			obj.Color = schemeVal; return true
		end
		if obj:IsA("Beam") or obj:IsA("Trail") or obj:IsA("ParticleEmitter") then
			obj.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, schemeVal),
				ColorSequenceKeypoint.new(1, schemeVal),
			}
			return true
		end
		-- generic attempts
		if pcall(function() obj.Color = schemeVal end) then return true end
		if pcall(function() obj.Color3 = schemeVal end) then return true end
		if pcall(function() obj.TextColor3 = schemeVal end) then return true end
		if pcall(function() obj.ImageColor3 = schemeVal end) then return true end
	end

	return false
end

local function findOne(root, pathOrName)
	-- supports "A/B/C" path (relative to root), or deep find by Name
	local current = root
	if string.find(pathOrName, "/") then
		for seg in string.gmatch(pathOrName, "([^/]+)") do
			current = current and current:FindFirstChild(seg) or nil
		end
		return current
	else
		local direct = root:FindFirstChild(pathOrName)
		if direct then return direct end
		for _,d in ipairs(root:GetDescendants()) do
			if d.Name == pathOrName then return d end
		end
	end
	return nil
end

local function resolveTargets(root, nameField)
	-- nameField can be "string" or { "A/B", "C/D", "PlainName" }
	local out = {}
	if type(nameField) == "string" then
		local t = findOne(root, nameField)
		if t then table.insert(out, t) end
	elseif type(nameField) == "table" then
		for _, s in ipairs(nameField) do
			local t = findOne(root, s)
			if t then table.insert(out, t) end
		end
	end
	return out
end


function Color_Mod:ApplyColors(Parent, SchemeName, Specs,TextInfo)
	assert(typeof(Parent) == "Instance", "Parent must be an Instance")
	local scheme = ColorSchemes[SchemeName]
	if not scheme then
		warn(("Color_Mod: scheme '%s' not found"):format(tostring(SchemeName)))
		return
	end
	TextInfo = TextInfo or {CanSetText=false,TextObjName="",Text=""}

	for _, spec in ipairs(Specs or {}) do
		local targets = resolveTargets(Parent, spec.Name)
		if #targets == 0 then
			warn(("Color_Mod: target(s) not found for %s"):format(typeof(spec.Name)=="table" and table.concat(spec.Name,", ") or tostring(spec.Name)))
		else

			local val = scheme[spec.Use]
			if val == nil then
				warn(("Color_Mod: scheme key '%s' missing in '%s'"):format(tostring(spec.Use), SchemeName))
			else
				for _, obj in ipairs(targets) do
					local ok = applyValue(obj, val,TextInfo)
					if not ok then
						warn(("Color_Mod: could not apply '%s' to %s (%s)"):format(tostring(spec.Use), obj.Name, obj.ClassName))
					end
				end
			end
		end
	end
end

-- optional getters if you want to tweak at runtime
function Color_Mod.GetScheme(name) return ColorSchemes[name] end
function Color_Mod.SetScheme(name, t) ColorSchemes[name] = t end

return Color_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{55359D0C-D1EC-4B29-A9CA-F10AA21D23A6}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">PodiumColors_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1C71466F30B043DA836AB99D0EC8867C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Models/UGC/Hallowen_UGCs_Config.lua
--
--  Description:
--      Configuration module for all Halloween UGC (User Generated Content) items.
--      It automatically parses and indexes UGC models located in
--      ReplicatedStorage.Models.UGC.Halloween_Models, extracting key metadata
--      from their names (index, title, detail, and asset key).
--      Also includes a helper function to verify UGC ownership on the server.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-11-01 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Models/UGC/Halloween_Models (container for UGC item models)
--      - Services:
--          * MarketplaceService
--
--  Notes:
--      - Item names must follow the pattern: "<index> / <title> / <detail> / <assetId>"
--      - Player_Owns_Item_UGC_ServerCheck retries up to 3 times for reliability
--      - Items are stored in HUC.HUGCItems, sorted by index and title
--      - Used for in-game validation and presentation of Halloween UGCs
--
--======================================================================

local MPS = game:GetService("MarketplaceService")
local RS = game:GetService("ReplicatedStorage")
local UGC_FOLDER = RS:WaitForChild("Models"):WaitForChild("UGC"):WaitForChild("Halloween_Models")


local HUC= {}
HUC.HUGCItems = {}

function HUC.Player_Owns_Item_UGC_ServerCheck(Plr, ID)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = MPS:PlayerOwnsAsset(Plr, ID)
		end)

		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end

	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end

	return false
end

local function parseName(name: string)
	-- title / detail / key
	local index,title, detail, key =  name:match("^(%d+)%s*/%s*([^/]+)%s*/%s*([^/]+)%s*/%s*(%d+)%s*$")
	return index,title, detail, key
end

local function rebuild()

	for _, inst in ipairs(UGC_FOLDER:GetChildren()) do
		local index, title, detail, key = parseName(inst.Name)

		table.insert(HUC.HUGCItems,{
			Index = tonumber(index),
			Key = key,
			Kind = "HallowenUGC",
			Title = title,
			RefName=inst.Name,
		})
	end
		table.sort(HUC.HUGCItems, function(a, b)
			local ia = a.Index or math.huge
			local ib = b.Index or math.huge
			if ia ~= ib then return ia < ib end
			return (a.Title or "") < (b.Title or "")
		end)
end

rebuild()

return HUC]]></ProtectedString>
						<string name="ScriptGuid">{3D694538-204A-4F2E-9362-44A24F538706}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Hallowen_UGCs_Config.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF6647B80E7854EAA8A7775BAF7245AA7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/League_Mod.lua
--
--  Description:
--      Central configuration module for all league-related data,
--      including progression order, point thresholds, colors, and
--      visual identifiers. Also defines promotion/demotion logic and
--      utility functions for retrieving league attributes.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-11-01 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - None (pure configuration module)
--
--  Notes:
--      - League_Mod.Order defines the progression from Bronze to Legend
--      - League_Mod.Config stores per-league metadata (color, emoji, LP)
--      - PromotionConfig controls tournament and promotion mechanics:
--          * TopPromotionCount, BottomDemotionCount
--          * LP rewards and duration of each cycle
--      - Utility functions provide safe access to league data and helpers
--        for determining next/previous ranks
--
--======================================================================

local League_Mod = {}

-- Ordered progression of leagues
League_Mod.Order = {
	"Bronze",
	"Silver",
	"Gold",
	"Emerald",
	"Diamond",
	"Platinum",
	"Legend",
}


-- Core configuration per league
League_Mod.Config = {
	Global = {
		LP_Win = 1,
		LP_Loss = 0,
		Streak_Bonus_Factor = 1,
		TournamentDuration = 7 * 24 * 60 * 60 -- one week
	},

	Bronze = {
		color = Color3.fromRGB(205, 127, 50),
		displayName = "Bronze",
		promotionRate = 0.25,
		demotionRate  = 0.00
	},
	Silver = {
		color = Color3.fromRGB(180, 180, 180),
		displayName = "Silver",
		promotionRate = 0.22,
		demotionRate  = 0.25
	},
	Gold = {
		color = Color3.fromRGB(255, 215, 0),
		displayName = "Gold",
		promotionRate = 0.18,
		demotionRate  = 0.20
	},
	Emerald = {
		color = Color3.fromRGB(0, 220, 100),
		displayName = "Emerald",
		promotionRate = 0.15,
		demotionRate  = 0.17
	},
	Diamond = {
		color = Color3.fromRGB(0, 180, 255),
		displayName = "Diamond",
		promotionRate = 0.12,
		demotionRate  = 0.14
	},
	Platinum = {
		color = Color3.fromRGB(120, 150, 255),
		displayName = "Platinum",
		promotionRate = 0.08,
		demotionRate  = 0.10
	},
	Legend = {
		color = Color3.fromRGB(255, 80, 180),
		displayName = "Legend",
		promotionRate = 0.00,
		demotionRate  = 0.08
	},
}


-- TODO reupload into PUBLIC (badge are per experience)
League_Mod.Participant_Badges = {
	Bronze   = { id = 1496810602843888, name = "Bronze Division Participant" },
	Silver   = { id = 2473121602313974, name = "Silver Division Participant" },
	Gold     = { id = 2680162856874675, name = "Gold Division Participant" },
	Emerald  = { id = 1396025015948588, name = "Emerald Division Participant" },
	Diamond  = { id = 2010347884399875, name = "Diamond Division Participant" },
	Platinum = { id = 3160901083853497, name = "Platinum Division Participant" },
	Legend      = { id = 3160901083853497, name = "UFC Division Participant" },
}

League_Mod.Winner_Badges = {
	Bronze   = { id = 1703788356684347, name = "Bronze Division Champion" },
	Silver   = { id = 1703788356684347, name = "Silver Division Champion" },
	Gold     = { id = 1703788356684347, name = "Gold Division Champion" },
	Emerald  = { id = 1703788356684347, name = "Emerald Division Champion" },
	Diamond  = { id = 1703788356684347, name = "Diamond Division Champion" },
	Platinum = { id = 1703788356684347, name = "Platinum Division Champion" },
	Legend      = { id = 1703788356684347, name = "UFC Division Champion" },
}

--========================================================
-- Utility Functions
--========================================================

-- Get color safely
function League_Mod.GetColor(leagueName)
	local cfg = League_Mod.Config[leagueName]
	if cfg and cfg.color then
		return cfg.color
	end
	return Color3.fromRGB(80, 80, 80)
end

-- Get display name safely
function League_Mod.GetDisplayName(leagueName)
	local cfg = League_Mod.Config[leagueName]
	if cfg and cfg.displayName then
		return cfg.displayName
	end
	return "Unknown"
end

-- Get index of a league in the progression
function League_Mod.GetRankIndex(leagueName)
	for i, name in ipairs(League_Mod.Order) do
		if name == leagueName then
			return i
		end
	end
	return 1 -- default to Bronze
end

-- Get next league name
function League_Mod.GetNextLeague(current)
	local idx = League_Mod.GetRankIndex(current)
	return League_Mod.Order[idx + 1]
end

-- Get previous league name
function League_Mod.GetPreviousLeague(current)
	local idx = League_Mod.GetRankIndex(current)
	return League_Mod.Order[idx - 1]
end


return League_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{5F6AE1C0-6EE0-42B7-97C8-A04C9979CF87}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">League_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0EC8D094262443D9909468D0E1AA8418">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Bots_Mod.lua
--
--  Description:
--      Centralized module for all bot configuration data used in fight cages.
--      Each entry maps a cage identifier to a bot template and difficulty level.
--      The module also provides helper functions to retrieve the correct
--      bot folders in ServerStorage and Workspace, adapting to current themes.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-11-01 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Design/ThemeManager (for theme-based folder selection)
--      - ServerStorage:
--          * Training_Bots (contains bot template folders)
--      - Workspace:
--          * Main_World_F/Gameplay/Objects/Bots (workspace container)
--
--  Notes:
--      - Each Fight_Cage_X can define a unique bot setup (template, difficulty)
--      - ThemeManager determines which template folder ("Standard", "Halloween", etc.) to use
--      - Bots_Mod is used primarily by Bots_Manager for spawning and management
--
--======================================================================

local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)

local Bots_Mod = {

	cages = {
		["Fight_Cage_0"] = { Profile = "NORMAL" },
		["Fight_Cage_1"] = { Profile = "NORMAL" },
		["Fight_Cage_2"] = { Profile = "NORMAL" },
		["Fight_Cage_3"] = { Profile = "NORMAL" },
		["Fight_Cage_4"] = { Profile = "NORMAL" },
		["Fight_Cage_5"] = { Profile = "NORMAL" },
		["Fight_Cage_6"] = { Profile = "NORMAL" },
		["Fight_Cage_7"] = { Profile = "NORMAL" },
		["Fight_Cage_8"] = { Profile = "NORMAL" }
	},

	-- Define reusable profiles
	profiles = {
		NORMAL = {
			Template = "Training_Bot",
			DisplayName = "Greg Jackson",
			Behavior = "NORMAL"
		},
		COACH = {
			Template = "Coach_Bot",
			DisplayName = "George Saint-Pierre",
			Behavior = "COACH"
		},
		FEMALE = {
			Template = "Female_Bot",
			DisplayName = "Amanda Nunes",
			Behavior = "NORMAL"
		}
	}
}

function Bots_Mod.getProfileForCage(cageName)
	local cage = Bots_Mod.cages[cageName]
	if not cage then
		return Bots_Mod.getProfile("NORMAL")
	end
	return Bots_Mod.getProfile(cage.Profile)
end

function Bots_Mod.getProfile(profileName) 
	return Bots_Mod.profiles[profileName] or Bots_Mod.profiles["NORMAL"] 
end

-- Get the bots template folder according to the current theme
function Bots_Mod.getBotsTemplateFolder()
	if ThemeManager.getCurrentTheme() == "Halloween" then
		return game.ServerStorage:WaitForChild("Training_Bots"):WaitForChild("Halloween")
	else
		return game.ServerStorage:WaitForChild("Training_Bots"):WaitForChild("Standard")
	end

end

-- Get the bots workspace folder (where cloned bots are instantiated)
function Bots_Mod.getBotsWorkspaceFolder()
	local Main_World_F = game.Workspace:WaitForChild("Main_World_F")
	local Gameplay = Main_World_F:WaitForChild("Gameplay")
	local Objects = Gameplay:WaitForChild("Objects")
	return Objects:WaitForChild("Bots")
end

return Bots_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{3507D518-D21D-4AB0-BDE3-2B8785683410}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Bots_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC0A8693912A6415AB7070768A1DAE67C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Fight_Params_Mod.lua
--
--  Description:
--      Central configuration module defining all fight-related
--      gameplay parameters: health, stamina, punch power, block mechanics,
--      takedown rules, submission minigame settings, rewards, and cage types.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-05-12 by Darkzeb
--
--  Version: V2025-12
--
--  Used By:
--      - Fight_Service
--      - Cage_Factory
--      - Tournament_Manager
--      - Any system needing combat parameters
--
--  Notes:
--      - Pure configuration module (no functions).
--      - All values grouped by gameplay domain for clarity.
--      - CageType acts as an enum to prevent string errors.
--
--======================================================================

local Fight_Params_Mod = {

	------ PARAMETERS (WIP) -------
	Health = {
		Max_Value = 100,
		Reloading_Active = true,
		Reload_Time_Factor = 1.8 
	},

	Stamina = {
		Max_Value = 100,
		Reload_Time_Factor = 0.1,
		Min_To_Dodge = 7, 
		Min_To_Hit = 3,
		Min_To_Takedown = 15,
		Attempted_Takedown = 25
	},

	Block_Power = {
		Max_Value = 30, 
		Reload_Time_Factor = 0.2667,
		Reload_Delay = 6
	},

	Punch_Power={
		Max_Value = 1.5, 
		Min_Value = 0,
		Reload_Time = 2, 
		--Reload_Delay = 0.75
	},

	Takedown ={
		Min_Difference=5
	},

	Submission_Minigame = {
		Initial_Score = 25,
		Winning_Score = 50,
		Loosing_Score = 0,
		Bot_ClickDelay = 0.2,
		Coach_Bot_ClickDelay = 0.4,
	},

	CageClinch = {
		Active= false
	},

	-- every win fight rewards the player with cash
	Reward = {
		Standard_Win_Cash = 20,
		Ranked_Win_Cash = 25
	},

	CageType = {
		STANDARD = "STANDARD",
		RANKED   = "RANKED",
		TUTORIAL = "TUTORIAL",
		LEAGUE   = "LEAGUE"
	},

	Ranked_Arena_Required_Wins = 5, 

	Needed_Winning_Rounds = {
		STANDARD = 2,
		RANKED   = 3
	}
}

return Fight_Params_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{451A4687-2E6C-46C4-B51D-A09357BA54FE}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_Params_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB1F1FF31E56D4CD2997F7FF1EB7CA6BD">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local Workspace = game:GetService("Workspace")

local Tutorial_Mod = {
	Tour_Steps = {
		{
			title = "⭐ QUICK TOUR",
			txt = "Let's discover the <b>MMA Fighters</b> room 🥊! "
		},
		{
			title = "🏋️‍♂️ GYM",
			txt = "Go to the <b>Gym</b> 💪 to earn <b>Cash 💵</b>.",
			camera_key = "Gym_Cam_P"
		},
		{
			title = "👊 FIGHT",
			txt = "Enter a <b>Cage</b> 🦁 and fight a <b>bot 🤖</b> or a <b>player 🥊</b>.",
			camera_key = "Cages_Cam_P"
		},
		{
			title = "🏆 RANKED ARENA",
			txt = "Enter the <b>Ranked Arena</b> 🥇 and battle through <b>5 intense rounds</b> to climb your <b>Elo 📈</b>.",
			camera_key = "Arena_Cam_P"
		},
		{
			title = "⭐ LEADERBOARD",
			txt = "Check the <b>Global Leaderboard</b> 🌍 and climb to the top 🏅!",
			camera_key = "LB_Cam_P"
		},
		{
			title = "🛒 SHOP",
			txt = "Use <b>Cash 💵</b> and <b>Gems 💎</b> to buy items.",
			camera_key = "Shop_Cam_P"
		}
	},
	Menus_Tour_Steps = {
		{
			title = "🥊 COMBOS",
			txt = "Choose and equip your <b>combos</b> 🔥. Unlock more as you grow ⚡.",
			open_panel_event = "Open_Combos",
			hint = {
				InitialPos = UDim2.new(0.81,0,.03,0) ,
				FinalPos = UDim2.new(0.85,0,.03,0) ,
				Size = UDim2.new(.07,0,0.07,0) ,
				Rotation = -90,
			}
		},
		{
			title = "👤 AVATAR",
			txt = "Customize your fighter with <b>skins & outfits</b> ✨.",
			open_panel_event = "Open_Equipment",
			hint = {
				InitialPos = UDim2.new(0.81,0,.03,0) ,
				FinalPos = UDim2.new(0.85,0,.03,0) ,
				Size = UDim2.new(.07,0,0.07,0) ,
				Rotation = -90,
			}
		},
		{
			title = "🎁 SHOP ITEMS",
			txt = "Browse items and open <b>crates</b> 🎉 for rare rewards ⚡.",
			open_panel_event = "Open_Shop_UI",
			hint = {
				InitialPos = UDim2.new(.91,0,.03,0) ,
				FinalPos = UDim2.new(.95,0,.03,0) ,
				Size = UDim2.new(.07,0,0.07,0) ,
				Rotation = -90,
			}
		}
	},
	
	Basic_Fight_Steps = {
		{
			title = "WELCOME TO THE OCTOGON!";
			txt = "You’re about to fight your opponent: coach George Saint-Pierre.",
			image = "rbxassetid://105736152900143",
			next_button = true,
			visible_keys = {
				Punch =  false,
				Kick =  false, 
				Damage_Bar  = false,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		}, 
		{
			txt = "Move inside the cage with the joystick or the arrow keys.",
			next_button = false,
			next_condition = {
				Delay = 2,
				CharAttribute = "IsMoving",
				ExpectedValue = true
			},
			highlight = {
				Direction = {
					Mobile = {
						Stroke_Template = "Square_Stroke"
					}
				}
			},
			visible_keys = {
				Punch =  false,
				Kick =  false, 
				Damage_Bar  = false,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		},
		{
			title = "STRIKES",
			txt = "Punch your opponent to lower their health points.",
			image= "rbxassetid://139942312851229",
			next_button = false,
			next_condition = {
				Delay = 3,
				CharAttribute = "LastFightAction",
				ExpectedValue = "Punch"
			},
			highlight = { 
				Punch = {
					Mobile = {
						Stroke_Template = "Punching_B_Stroke",
						Hand_Indicator = {
							InitialPos =UDim2.new(.5,0,-0.147,0) ,
							FinalPos = UDim2.new(.5,0,-0.247,0) ,
							Size = UDim2.new(.347,0,0.5,0) ,
							Rotation = 180,
						}
					},
					Other = {
						Stroke_Template = "Square_Stroke"
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  false, 
				Damage_Bar  = false,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		},
		{
			txt = "You can also use kicks and knee strikes for more damages!",
			image= "rbxassetid://70645081883201",
			next_button = false,
			next_condition = {
				Delay = 2,
				CharAttribute = "LastFightAction",
				ExpectedValue = "Kick"
			},
			highlight = {
				Kick = {
					Mobile = {
						Stroke_Template = "Kicking_B_Stroke", 
						Hand_Indicator = {
							InitialPos =UDim2.new(0.5, 0,-0.094, 0) ,
							FinalPos = UDim2.new(.5,0,-0.194,0) ,
							Size = UDim2.new(.347,0,0.5,0) ,
							Rotation = 180,
						}
					},
					Other = {
						Stroke_Template = "Square_Stroke"

					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = false,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		},
		{
			txt = "The amount of health lost depends on the Damage bar. Try to hit at the perfect timing!",
			image= "rbxassetid://75029345195737",
			next_button = true,
			highlight = {
				Damage_Bar_Gauge = { 
					Stroke_Template = "Damage_Bar_Stroke",
					Y_Offset = .45,
					Hand_Indicator = {
						InitialPos =UDim2.new(0.595, 0,0.118, 0) ,
						FinalPos = UDim2.new(0.595, 0,0.018, 0) ,
						Size = UDim2.new(0.254, 0,0.5,0) ,
						Rotation = 180,
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		},
		{
			title = "HEALTH",
			txt = "Your health points are shown at the top in green. \nThe first one to reach zero loses the round.",
			next_button = true,
			highlight = {
				Health_Bar = {
					Stroke_Template = "Square_Stroke", 
					Hand_Indicator = {
						InitialPos =UDim2.new(0.734, 0,1.511, 0) ,
						FinalPos = UDim2.new(0.734, 0,1.711, 0) ,
						Size = UDim2.new(1.5, 0,1.5, 0) ,
						Rotation = 0,
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		},
		{
			title = "STAMINA",
			txt = "You lose stamina every time you strike, be careful not to exhaust yourself!",
			image= "rbxassetid://75029345195737",
			next_button = true,
			highlight = {
				Stamina_Bar = {
					Stroke_Template = "Square_Stroke",
					Y_Offset = 0.53,
					Hand_Indicator = {
						InitialPos =UDim2.new(0.734, 0,1.511, 0) ,
						FinalPos = UDim2.new(0.734, 0,1.711, 0) ,
						Size = UDim2.new(1.5, 0,1.5, 0) ,
						Rotation = 0,
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		},
		{
			txt = "To recharge your stamina and block the incoming attacks, hold the blocking shield.",
			tips = "the shield recharges after a few seconds.",
			image= "rbxassetid://80173980511775",
			next_button = false,
			next_condition = {
				Delay = 3,
				CharAttribute = "LastFightAction",
				ExpectedValue = "Block"
			},
			highlight = {
				Block = {
					Mobile = {
						Stroke_Template = "Round_Stroke",
						Y_Offset = 0.46,
						Hand_Indicator= {
							InitialPos =UDim2.new(-0.271, 0,0.491, 0) ,
							FinalPos = UDim2.new(-0.371, 0,0.491, 0) ,
							Size = UDim2.new(0.533, 0,0.803, 0) ,
							Rotation = 90,
						}
					},
					Other = {
						Stroke_Template = "Square_Stroke"
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = true,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = true
			}
		},
		{
			title= "DODGE",
			txt = "You can also avoid your opponent’s attacks by dodging.",
			tips = "you dodge in the direction you’re moving (or randomly if you're standing still).",
			image= "rbxassetid://88026216056179",
			next_button = false,
			next_condition = {
				Delay = 2,
				CharAttribute = "LastFightAction",
				ExpectedValue = "Dodge"
			},
			highlight = {
				Dodge = {
					Mobile = {
						Stroke_Template = "Round_Stroke",
						Y_Offset = 0.46,
						Hand_Indicator= {
							InitialPos =UDim2.new(-0.271, 0,0.491,0 ) ,
							FinalPos = UDim2.new(-0.371, 0,0.491, 0) ,
							Size = UDim2.new(0.533, 0,0.803, 0) ,
							Rotation = 90,
						}
					},
					Other = {
						Stroke_Template = "Square_Stroke"
					}
				},
				Direction = {
					Mobile = {
						Stroke_Template = "Square_Stroke"
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = true,
				Dodge = true,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = true
			}
		},
		{
			title = "TAKEDOWN",
			txt = "Try to take the advantage over your opponent. ",
			tips="you can try for a Takedown when you have more than 5 hits ahead of him.",
			image= "rbxassetid://123246640429196",
			next_button = false,
			next_condition = "TakedownAvailable",
			highlight = {
				Takedown_Progress = {
					Stroke_Template = "Round_Stroke",
					Y_Offset = 0.46,
					Hand_Indicator= { 
						InitialPos =UDim2.new(0.498, 0, 0, 0) ,
						FinalPos = UDim2.new(0.498, 0,0.1, 0) ,
						Size = UDim2.new(0.533, 0,0.803, 0) ,
						Rotation = 0,
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = true,
				Dodge = true,
				Takedown_Progress = true,
				Takedown  = false,
				Shield = true
			}
		},
		{
			txt = "Go ahead, you can attempt a submission!",
			image= "rbxassetid://93493048884345",
			next_button = false,
			next_condition = {
				Delay = 0,
				CharAttribute = "LastFightAction",
				ExpectedValue = "Takedown"
			},
			highlight = {
				Takedown = {
					Mobile = {
						Stroke_Template = "Round_Stroke",
						Y_Offset = 0.46,
						Hand_Indicator= {
							InitialPos =UDim2.new(0.498, 0,-0.4, 0) ,
							FinalPos = UDim2.new(0.498, 0,-0.5, 0) ,
							Size = UDim2.new(0.533, 0,0.803, 0) ,
							Rotation = 180,
						}
					},
					Other = {
						Stroke_Template = "Square_Stroke"
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = true,
				Dodge = true,
				Takedown_Progress = true,
				Takedown  = true,
				Shield = true
			}
		},
		{
			title = "SUBMISSION",
			txt = "Tap as fast as you can to win the submission! You will instantly win the round!",
			image= "rbxassetid://93493048884345",
			next_button = false,
			next_condition = {
				Delay = 0,
				CharAttribute = "LastFightAction",
				ExpectedValue = "Submission"
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = true,
				Dodge = true,
				Takedown_Progress = true,
				Takedown  = true,
				Shield = true
			}
		},
		{
			title = "CONGRATS",
			txt = "You've learned all the secrets of combat. Now, you're ready to fight!",
			next_button = true
		}
	}
}

function Tutorial_Mod:GetTutorialPartsFolder()
	return game.Workspace.Main_World_F.Gameplay.Objects.Tutorial_Parts_F
end


return Tutorial_Mod]]></ProtectedString>
						<string name="ScriptGuid">{C8D623D5-2ED6-47BB-9FBC-AAE1CB56BD03}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tutorial_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3832650BDB01465AA2406EE7A304E896">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Cage_Factory.lua
--
--  Description:
--      Factory module responsible for creating, allocating, stacking,
--      and cleaning up temporary fight cages (tutorial, league, standard).
--      Handles vertical slot management to avoid collisions, timed
--      automatic cleanup, and cage-type routing.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-05-12 by Darkzeb
--
--  Version: V2025-12
--
--  Dependencies:
--      - Roblox Services:
--          * ReplicatedStorage
--          * Players
--          * Workspace
--          * Debris
--      - Modules:
--          * Fight_Params_Mod (cageType enum)
--
--  Used By:
--      - Tournament_Manager
--      - Fight_Service
--
--  Notes:
--      - Vertical slot allocator prevents cage overlap.
--      - Cages auto-despawn after MaxDuration (Debris).
--      - Slot is automatically released when a cage is removed.
--      - Supports: Tutorial, League, Standard cages.
--
--======================================================================


local RS = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")

local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))

local Cage_Factory = {
	Standard_Cage_Folder = game.Workspace.Main_World_F.Gameplay.Objects.Fight_Cages_F,

	Tournament_TemplateFolder = RS:WaitForChild("Models"):WaitForChild("Tournaments"),
	Tournament_Template = "TournamentCage", 

	Tutorial_TemplateFolder = RS:WaitForChild("Models"):WaitForChild("Tutorial"),
	Tutorial_Cages_Folder = game.Workspace.Main_World_F.Gameplay.Objects.Tutorial_Parts_F.Tutorial_Cages,
	Tutorial_Template = "TutorialCage", 

	SLOTS_FREE = {},             -- free slot stack
	SLOTS_NEXT = 0,              -- next new slot index
	MaxDuration = 10 * 60 -- 10 minutes max per fight (safety cleanup)
}

-- ==========================================================
-- UTILS
-- ==========================================================
--------------------------------------------------------------------
-- Slot allocator: ensures no collision and reused vertical slots ---
--------------------------------------------------------------------
function Cage_Factory:GetFreeSlot()
	if #self.SLOTS_FREE > 0 then
		-- reuse a previously freed slot
		local slot = table.remove(self.SLOTS_FREE) -- pop last
		return slot
	end

	-- allocate new slot if no free slot available
	self.SLOTS_NEXT += 1
	return self.SLOTS_NEXT
end

function Cage_Factory:ReleaseSlot(slot)
	table.insert(self.SLOTS_FREE, slot)
end

-- Creates a new arena instance for a fight
function Cage_Factory:CreateCage(cageType)
	local template = nil
	local parent = nil
	if cageType == Fight_Params_Mod.CageType.TUTORIAL then
		local folder = Cage_Factory.Tutorial_TemplateFolder
		template = folder:FindFirstChild(Cage_Factory.Tutorial_Template)
		parent = Cage_Factory.Tutorial_Cages_Folder
	else
		-- TODO
	end

	if not template then
		warn("[Cage_Factory] Missing cage template for type:", cageType)
		return nil
	end

	local cage = template:Clone()
	cage.Parent = parent
	cage.Name = ("%s_%d"):format(cageType, math.random(1000, 9999))
	cage:SetAttribute("Is_Tournament", cageType == Fight_Params_Mod.CageType.LEAGUE)

	-- allocate vertical slot
	local slot = self:GetFreeSlot()
	cage:SetAttribute("Slot", slot)

	local baseHeight = 0
	local stackOffset = 100
	local y = baseHeight + (slot * stackOffset)

	cage:SetPrimaryPartCFrame(CFrame.new(0, y, 0))

	-- cleanup after timeout
	Debris:AddItem(cage, Cage_Factory.MaxDuration)

	-- when cage is removed, free its slot
	cage.AncestryChanged:Connect(function(_, parent)
		if not parent then
			local usedSlot = cage:GetAttribute("Slot")
			if usedSlot then
				self:ReleaseSlot(usedSlot)
			end
		end
	end)

	return cage
end

-- Destroys the arena when the fight is over
function Cage_Factory:DestroyArena(arenaName)

	local arena = Cage_Factory.Tutorial_TemplateFolder:FindFirstChild(arenaName)
	if not arena or not arena.Parent then
		warn("[ARENA] No valid arena found for cleanup.")
		return
	end

	-- Nettoyage défensif
	pcall(function()
		arena:Destroy()
	end)
end

function Cage_Factory:getCageFolder(cageType)
	if cageType == Fight_Params_Mod.CageType.TUTORIAL then
		return Cage_Factory.Tutorial_Cages_Folder
	elseif cageType == Fight_Params_Mod.CageType.STANDARD then
		return Cage_Factory.Standard_Cage_Folder
	else
		warn("Unsupported cageType: "..tostring(cageType))
	end
end

function Cage_Factory:getAvailableCages(cageType)
	local folder = Cage_Factory:getCageFolder(cageType)
	if not folder then return {} end
	
	local Empty_Cages = {}
	
	for _, cage in pairs(folder:GetChildren()) do
		local Fight_Data_F = cage:FindFirstChild("Fight_Data_F")
		if Fight_Data_F ~= nil then
			local active = Fight_Data_F:FindFirstChild("Active_Fight")
			if active ~= nil then 
				if not active.Value then
					table.insert(Empty_Cages, cage)
				end
			end
		end
	end
	
	return Empty_Cages
end



return Cage_Factory]]></ProtectedString>
						<string name="ScriptGuid">{CD17ED93-7638-465B-B2EC-4A7FB7C31B8F}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Cage_Factory.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4073B69535D54428B08EC8D3DCE05554">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ServerScriptService/AnimationSlowMo.lua  (ModuleScript)

local SlowMo = {}

-- Per-character state
local state = {} -- [Character] = { originals = {}, conn = nil, token = 0 }

local function getHumanoid(character)
	for _, c in ipairs(character:GetChildren()) do
		if c:IsA("Humanoid") then return c end
	end
end

local function getAnimator(humanoid)
	-- Prefer an existing Animator; if missing, try to find one shortly
	local animator = humanoid:FindFirstChildOfClass("Animator")
	if animator then return animator end
	-- Animator usually exists on live characters; WaitForChild to be safe
	return humanoid:WaitForChild("Animator", 2)
end

local function applyTrackSpeed(track, scale, originals)
	if not originals[track] then
		originals[track] = track.Speed
		track.Stopped:Connect(function()
			originals[track] = nil
		end)
	end
	local base = originals[track] or 1
	track:AdjustSpeed(math.max(0.01, base * scale))
end

local function scaleAllPlaying(animator, scale, originals)
	if not animator then return end
	for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
		applyTrackSpeed(track, scale, originals)
	end
end

 function SlowMo.clearAndRestore(character)
	local st = state[character]
	if not st then return end
	if st.conn then st.conn:Disconnect() end
	for track, base in pairs(st.originals) do
		if track and track.IsPlaying then
			track:AdjustSpeed(base or 1)
		end
	end
	state[character] = nil
end

-- Public API
function SlowMo.SlowPlayerAnimations(player, timescale, durationSec)
	if not player or not player.Character then return end
	local humanoid = getHumanoid(player.Character)
	if not humanoid then return end
	local animator = getAnimator(humanoid)
	if not animator then return end

	-- Ensure state
	local st = state[player.Character]
	if not st then
		st = { originals = {}, conn = nil, token = 0 }
		state[player.Character] = st
		-- Auto-clean if character is removed
		player.Character.AncestryChanged:Connect(function(_, parent)
			if not parent then SlowMo.clearAndRestore(player.Character) end
		end)
	end

	st.token += 1
	local myToken = st.token
	local scale = math.clamp(timescale or 1, 0.05, 2)
	local restoreAt = os.clock() + math.max(0, durationSec or 0)

	-- 1) Slow all currently playing tracks (Animator API)
	scaleAllPlaying(animator, scale, st.originals)

	-- 2) Slow any new tracks that begin during the window
	if st.conn then st.conn:Disconnect() end
	st.conn = humanoid.AnimationPlayed:Connect(function(newTrack)
		-- Guard against stale state
		if state[player.Character] ~= st then return end
		applyTrackSpeed(newTrack, scale, st.originals)
	end)

	-- 3) Restore after the window (debounced by token)
	task.spawn(function()
		local waitTime = restoreAt - os.clock()
		if waitTime > 0 then task.wait(waitTime) end
		if state[player.Character] == st and st.token == myToken then
			SlowMo.clearAndRestore(player.Character)
		end
	end)
end

return SlowMo
]]></ProtectedString>
						<string name="ScriptGuid">{622F9398-9CAA-4699-8BE1-99F677772F34}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">AnimationSlowmo.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX85CB159414084D448B5C0F18779DA1D8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- Punching_Machine_Config_Mod.lua
local Config = {}

local Animation_Data = require(game.ReplicatedStorage.Data_Mods_F.Animation_Mod)
local AD=Animation_Data.Get_Combinations("Emotes")

Config.COOLDOWN_SECONDS = 3600

Config.RewardsOnPunch = {
	Perfect = 300,
	Great   = 200,
	Good    = 100,
	Basic   = 50,
}

Config.BonusBlocksInfo = {

	["ZeroL"]=	{  	Title="Basic", 	 Bonus=0, BgColor=Color3.fromRGB(255,255,0), WidthPct=0.001, Transparency=1,SortingIndex=0 },
	
	["GoodL"]=	{   Title="Good",    Bonus=1, BgColor=Color3.fromRGB(255, 85,  0), WidthPct=9,  Transparency=0,SortingIndex=1 },
	["GreatL"]=	{   Title="Great",   Bonus=2, BgColor=Color3.fromRGB(255,255,0), WidthPct=6,  Transparency=0 ,SortingIndex=2},
	["Perfect"]={ 	Title="Perfect", Bonus=3, BgColor=Color3.fromRGB(0,255,0),   WidthPct=4,  Transparency=0 ,SortingIndex=3},
	["GreatR"]=	{  	Title="Great",   Bonus=2, BgColor=Color3.fromRGB(255,255,0), WidthPct=6,  Transparency=0 ,SortingIndex=4},
	["GoodR"]=	{  	Title="Good",    Bonus=1, BgColor=Color3.fromRGB(255, 85,  0), WidthPct=9,  Transparency=0 ,SortingIndex=5},
	
	["ZeroR"]=	{  	Title="Basic", 	 Bonus=0, BgColor=Color3.fromRGB(255,255,0), WidthPct=0.001, Transparency=1 ,SortingIndex=6},
}
Config.BonusBlocksMinX = .2 -- 0 to 1
Config.BonusBlocksMaxX = .8 -- 0 to 1

Config.PunchAnimations = {
	Perfect = "rbxassetid://96980900853709",
	Great   = "rbxassetid://127323434624294",
	Good    = "rbxassetid://83539596227550",
	Basic   = "rbxassetid://106460454763763",
}
Config.EffectAnimations = {
	Perfect = "rbxassetid://"..AD["A"]["ID"],
	Great   = "rbxassetid://"..AD["B"]["ID"],
	Good    = "rbxassetid://"..AD["C"]["ID"],
	Basic   = "rbxassetid://"..AD["D"]["ID"],
}

Config.needleMinSpeed = 2 -- 1 is minimum --> previous 1
Config.needleMaxSpeed = 3 -- integer only --> previous 4
-- Animation marker names
Config.MarkerCharge = "Charge"
Config.MarkerHit    = "Hit"


Config.BallMinHitTime  = 0.10
Config.BallMaxHitTime  = 0.60   -- time when percent is low
Config.BallResetTime   = 0.25

-- Power mapping (percent -> displayed power)
Config.PowerScale = 1000
Config.BuyPunchPrice= 10

-- Rating thresholds computed on SERVER (do not trust client rating)
function Config.GetRatingFromPercent(percent01: number): string
	local p = math.clamp(percent01 or 0, 0, 1)
	if p >= 0.90 then return "Perfect" end
	if p >= 0.75 then return "Great" end
	if p >= 0.55 then return "Good" end
	return "Basic"
end

function Config.GetRatingAndPercentByNumber(bounsIndex)

	local percent = 0
	local Rating = "Basic"

	if bounsIndex == 3 then
		percent= math.random(94,100)/100
		Rating = "Perfect"
	elseif bounsIndex == 2 then
		percent= math.random(84,94)/100
		Rating = "Great"
	elseif  bounsIndex == 1 then
		percent= math.random(66,84)/100
		Rating = "Good"
	else
		percent= math.random(1,40)/100
		Rating = "Basic"
	end

	return percent,Rating
end

function Config.GetBallHitTime(percent01: number): number
	local p = math.clamp(percent01 or 0, 0, 1)
	-- high power => faster hit time
	return (1 - p) * (Config.BallMaxHitTime - Config.BallMinHitTime) + Config.BallMinHitTime
end

return Config
]]></ProtectedString>
						<string name="ScriptGuid">{6882D2C5-071B-44F5-88F9-22C6C581A5D2}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Punching_Game_Config_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1AF6B43CC7DB4C91BA74D3AF360263BB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- Punching_Machine_Controller_Mod.lua
local Players 					= game:GetService("Players")
local TweenService 				= game:GetService("TweenService")

-- Modules
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod 					= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local PlayerUtils 				= require(game.ReplicatedStorage.Modules.PlayerUtils)


local Controller = {}
Controller.__index = Controller



local function RotateModelRelativeToParent(model: Model, parentModel: Model, rotVecDeg: Vector3, duration: number)
	if not model or not parentModel then return end

	local parentCF = parentModel:GetPivot()
	local startCF  = model:GetPivot()

	-- model transform in parent space
	local localCF = parentCF:ToObjectSpace(startCF)

	-- apply delta rotation in parent space (keeps parent-relative behavior)
	local rx, ry, rz = math.rad(rotVecDeg.X), math.rad(rotVecDeg.Y), math.rad(rotVecDeg.Z)
	local targetLocal = localCF * CFrame.fromEulerAnglesXYZ(rx, ry, rz)

	-- back to world
	local targetCF = parentCF * targetLocal

	if (duration or 0) <= 0 then
		model:PivotTo(targetCF)
		return
	end

	local proxy = Instance.new("CFrameValue")
	proxy.Value = startCF

	local conn = proxy:GetPropertyChangedSignal("Value"):Connect(function()
		if model.Parent then model:PivotTo(proxy.Value) end
	end)

	local tw = TweenService:Create(proxy, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Value = targetCF
	})

	tw.Completed:Connect(function()
		if conn.Connected then conn:Disconnect() end
		proxy:Destroy()
	end)

	tw:Play()
end


local function getOrMakeNumberValue(parent: Instance, name: string, defaultValue: number)
	local v = parent:FindFirstChild(name)
	if not v then
		v = Instance.new("NumberValue")
		v.Name = name
		v.Value = defaultValue
		v.Parent = parent
	end
	return v
end

function Controller.new(machineModel: Model, ChannelsModule, Config, slowMoModule)
	local self = setmetatable({}, Controller)

	self.Model = machineModel
	self.Channels = ChannelsModule
	self.Config = Config
	self.SlowMo = slowMoModule
	self.IsPlayingFree=false
	-- Parts/values expected under the machine model
	self.PlayerPos = machineModel:WaitForChild("Player_Pos")
	self.PlayerUsing = machineModel:WaitForChild("PlayerUsing") -- ObjectValue
	self.Prompt = machineModel.Attachment:WaitForChild("ProximityPrompt")  -- ProximityPrompt
	self.PunchBall = machineModel:WaitForChild("PunchBall")     -- Model
	self.isPunchHappen=false
	self.EffectsFolder = machineModel:FindFirstChild("Effects") -- optional

	-- Remotes
	self.PunchingGame_Action = ChannelsModule.Server_Client_Events.PunchingGame_Action
	self.PunchingGame_Result = ChannelsModule.Client_Server_Events.PunchingGame_Result
	self.RunningTrack=nil
	-- Connections
	self.Conns = {}
	self.DiedConnsByUserId = {}

	-- Pending result (server-truth)
	self.PendingByUserId = {}   -- [userId] = punchData
	self.ClaimedByUserId = {}   -- [userId] = boolean

	return self
end

function Controller:Destroy()
	for _, c in ipairs(self.Conns) do
		if c and c.Connected then c:Disconnect() end
	end
	table.clear(self.Conns)

	for _, c in pairs(self.DiedConnsByUserId) do
		if c and c.Connected then c:Disconnect() end
	end
	table.clear(self.DiedConnsByUserId)

	self.PlayerUsing.Value = nil
	self.Prompt.Enabled = true
end

function Controller:IsPlayerCanPlay(player: Player): (boolean, number)
	
	local PD = player:WaitForChild("Player_Data")
	local lastTimePunch = getOrMakeNumberValue(PD, "lastTimePunch", os.time() - (self.Config.COOLDOWN_SECONDS + 100))
	local now = os.time()
	local elapsed = now - lastTimePunch.Value
	if elapsed >= self.Config.COOLDOWN_SECONDS then
		return true, 0
	end
	return false, (self.Config.COOLDOWN_SECONDS - elapsed)

	--return true
end

function Controller:LockPlayer(player: Player)
	local char = player.Character
	if not char then return end
	local hum = char:FindFirstChildOfClass("Humanoid")
	local hrp = char:FindFirstChild("HumanoidRootPart")

	if hum then
		if hum:GetAttribute("OrigWalkSpeed") == nil then
			hum:SetAttribute("OrigWalkSpeed", hum.WalkSpeed)
		end
		if hum:GetAttribute("OrigJumpPower") == nil then
			hum:SetAttribute("OrigJumpPower", hum.JumpPower)
		end
		hum.WalkSpeed = 0
		hum.JumpPower = 0

		if not self.DiedConnsByUserId[player.UserId] then
			self.DiedConnsByUserId[player.UserId] = hum.Died:Connect(function()
				if self.PlayerUsing.Value == player then
					self.PlayerUsing.Value = nil
					self.Prompt.Enabled = true
				end
			end)
		end
	end
	if hrp and self.PlayerPos then
		hrp.AssemblyLinearVelocity = Vector3.zero
		hrp.AssemblyAngularVelocity = Vector3.zero
		hrp.Anchored = true

		local pos = self.PlayerPos.Position
		pos = Vector3.new(pos.X, hrp.Position.Y, pos.Z) -- keep HRP Y

		hrp.CFrame =
			CFrame.new(pos)
			* CFrame.Angles(0, math.rad(self.PlayerPos.Orientation.Y + 180), 0)
	end

end

function Controller:UnlockPlayer(player: Player)

	local track = self.RunningTrack
	if track then
		track:Stop(0.1)     
		track:Destroy()
		self.RunningTrack = nil
	end

	local char = player.Character
	if not char then return end
	local hum = char:FindFirstChildOfClass("Humanoid")
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if hum then
		local ws = hum:GetAttribute("OrigWalkSpeed")
		local jp = hum:GetAttribute("OrigJumpPower")
		if typeof(ws) == "number" then hum.WalkSpeed = ws end
		if typeof(jp) == "number" then hum.JumpPower = jp end
	end
	hrp.Anchored = false
	local dc = self.DiedConnsByUserId[player.UserId]
	if dc then
		if dc.Connected then dc:Disconnect() end
		self.DiedConnsByUserId[player.UserId] = nil
	end

	if self.isPunchHappen==true then
		
		RotateModelRelativeToParent(self.PunchBall,self.Model, Vector3.new(-90, 0, 0),  self.Config.BallResetTime)
	end
end


local function PlayAnimation(player, animId,isLoop)

	local char = player.Character
	if not char then return end
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hum then return end

	local animator = hum:FindFirstChildOfClass("Animator")
	if not animator then
		animator = Instance.new("Animator")
		animator.Parent = hum
	end
	if not animId then return end

	local anim = Instance.new("Animation")
	anim.AnimationId = animId

	local ok, track = pcall(function()
		return animator:LoadAnimation(anim)
	end)
	if not ok or not track then
		anim:Destroy()
		return
	end

	track:Play(0.05, 1, 1.0)
	track.Looped = isLoop and true or false
	return track
end

function Controller:SendResults(player: Player)
	local data = self.PendingByUserId[player.UserId]
	if data then

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		local target = self.Model:FindFirstChild("CamPosResult")

		if hrp and target then
			local pos = hrp.Position

			-- base facing = object forward direction (flattened on Y)
			local forward = target.CFrame.LookVector
			forward = Vector3.new(forward.X, 0, forward.Z).Unit

			-- apply extra yaw offset relative to target (degrees)
			local yawOffsetDeg =180
			local offsetCF = CFrame.Angles(0, math.rad(yawOffsetDeg), 0)

			-- build facing CFrame from direction
			local baseCF = CFrame.lookAt(pos, pos + forward)
			hrp.CFrame = baseCF * offsetCF
		end
		

		local PD = player:WaitForChild("Player_Data")
		local PunchCount = getOrMakeNumberValue(PD, "TotalPunchCount", 0)
		local punchScore = PD:WaitForChild("Punch Score")
		local oldScore = punchScore.Value*PunchCount.Value
		local AVGScore=(oldScore+data["punchPower"])/(PunchCount.Value+1)
		punchScore.Value =math.floor(AVGScore)
		PunchCount.Value +=1
		
		
		
	
		self.PunchingGame_Action:FireClient(player, "ShowResults", data)
	end
end



function Controller:PlayPunchAnim(player: Player, percent01: number, rating: string)

	local char = player.Character
	if not char then return end
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hum then return end

	local animId = self.Config.PunchAnimations[rating]
	local track =   PlayAnimation(player, animId,false)
	-- slow motion module is optional
	if self.SlowMo and self.SlowMo.SlowPlayerAnimations then
		self.SlowMo.SlowPlayerAnimations(player, 0.35, 50)
	end

	-- Optional effects clone (auto-clean with Debris)
	local function ensureEffect(hand: Instance)
		if not self.EffectsFolder then return end
		if hand:FindFirstChild(rating) then return end
		local template = self.EffectsFolder:FindFirstChild(rating)
		if not template then return end
		local att = template:Clone()
		att.Parent = hand

	end

	local leftHand = char:FindFirstChild("LeftHand")
	local rightHand = char:FindFirstChild("RightHand")
	if leftHand then ensureEffect(leftHand) end
	if rightHand then ensureEffect(rightHand) end

	local function getPE0(hand: Instance)
		local folder = hand:FindFirstChild(rating)
		if folder and folder:FindFirstChild("pe0") then
			return folder.pe0
		end
		return nil
	end

	local leftEffect = leftHand and getPE0(leftHand) or nil
	local rightEffect = rightHand and getPE0(rightHand) or nil

	track:GetMarkerReachedSignal(self.Config.MarkerCharge):Once(function()
		if leftEffect then leftEffect.Enabled = true end
		if rightEffect then rightEffect.Enabled = true end
	end)

	track:GetMarkerReachedSignal(self.Config.MarkerHit):Once(function()
		local hitTime = self.Config.GetBallHitTime(percent01)
		
		RotateModelRelativeToParent(self.PunchBall,self.Model, Vector3.new(90, 0, 0), hitTime)
		
		if self.SlowMo and self.SlowMo.clearAndRestore then
			self.SlowMo.clearAndRestore(player.Character)
		end
		local hitEffect = nil

		if self.PunchBall then 
			hitEffect = self.PunchBall:FindFirstChild("Hit",true) 
		end
		
		if hitEffect then  
			hitEffect.Enabled = true 
			hitEffect:Emit(1) 
		end

		if leftEffect then 
			leftEffect.Enabled = false
		end
		
		if rightEffect then 
			rightEffect.Enabled = false 
		end
		
		SE_Mod.PlaySFX(player, "Punch_Hit_SE")
		task.delay(.5, function()
			if hitEffect then hitEffect.Enabled = false end
		end)
		
		task.delay(1, function()
			if self.PlayerUsing.Value == player then
				self:SendResults(player)

				self.RunningTrack=PlayAnimation(player,self.Config.EffectAnimations[rating],true)

			end
		end)
	end)
end



function Controller:HandlePrompt(player: Player)


	self.IsPlayingFree=true
	if self.PlayerUsing.Value ~= nil then return end

	local canPlay, remaining = self:IsPlayerCanPlay(player)
	self.PlayerUsing.Value = player
	self.Prompt.Enabled = false
	self:LockPlayer(player)
	self.isPunchHappen=false
	self.PunchingGame_Action:FireClient(player, "InitialMessage",self.Model)
	--if canPlay then
	--	self.PunchingGame_Action:FireClient(player, "GameUI")
	--else
	--	self.PunchingGame_Action:FireClient(player, "BuyAPlay", remaining)
	--end
end

function Controller:HandleRemote(player: Player, action: string, payload)
	if self.PlayerUsing.Value ~= player then
		return -- ignore spoofed events
	end
	if action=="BuyAPlayWithGems" then

		local PD = player:WaitForChild("Player_Data")
		local gems = PD:WaitForChild("Gems")

		if gems.Value>=self.Config.BuyPunchPrice then
			gems.Value-=self.Config.BuyPunchPrice 
			self.IsPlayingFree=false
			--	PD:WaitForChild("lastTimePunch").Value = 0
		end
		self:LockPlayer(player)
		self.PunchingGame_Action:FireClient(player, "GameUI")


	end
	if action == "CloseUI" or action == "RewardClaimed" then
		-- Here you will later grant gems on RewardClaimed (server-truth only)
		if action == "RewardClaimed" then
			local uid = player.UserId
			if self.PendingByUserId[uid] and not self.ClaimedByUserId[uid] then
				self.ClaimedByUserId[uid] = true

				PlayerUtils.RewardPlayer(player, "Coins", self.PendingByUserId[uid].gems)

				--local PD = player:WaitForChild("Player_Data")
				--local gems = PD:WaitForChild("Gems")
				--gems.Value += self.PendingByUserId[uid].gems
			end
		end

		self:UnlockPlayer(player)
		self.PlayerUsing.Value = nil
		self.Prompt.Enabled = true
		return
	end

	if action == "Result" then
		payload = payload or {}

		local percent,Rating= self.Config.GetRatingAndPercentByNumber(payload.bonus)


		-- COOLDOWN write (server)
		if self.IsPlayingFree then

			local PD = player:WaitForChild("Player_Data")
			local lastTimePunch = getOrMakeNumberValue(PD, "lastTimePunch", 0)
			lastTimePunch.Value = os.time()
		end

		-- IMPORTANT: do not trust client rating
		local percent01 = math.clamp(tonumber(percent) or 0, 0, 1)
		--	local rating = self.Config.GetRatingFromPercent(percent01)

		local punchPower = math.floor(percent01 * self.Config.PowerScale)
		local gems = self.Config.RewardsOnPunch[Rating] or 0

		local punchData = {
			value = tonumber(payload.value) or 0, -- optional, safe
			rating = Rating,
			percent = percent01,
			gems = gems,
			punchPower = punchPower,
		}

		self.PendingByUserId[player.UserId] = punchData
		self.ClaimedByUserId[player.UserId] = false
		self.isPunchHappen=true
		self:PlayPunchAnim(player, percent01, Rating)
	end
end

function Controller:HandlePlayerRemoving(plr: Player)
	if self.PlayerUsing.Value == plr then
		self.PlayerUsing.Value = nil
		self.Prompt.Enabled = true
	end

	local dc = self.DiedConnsByUserId[plr.UserId]
	if dc then
		if dc.Connected then dc:Disconnect() end
		self.DiedConnsByUserId[plr.UserId] = nil
	end

	self.PendingByUserId[plr.UserId] = nil
	self.ClaimedByUserId[plr.UserId] = nil
end

function Controller:Init()
	table.insert(self.Conns, self.Prompt.Triggered:Connect(function(player)
		self:HandlePrompt(player)
	end))

	table.insert(self.Conns, self.PunchingGame_Result.OnServerEvent:Connect(function(player, action, payload)
		self:HandleRemote(player, action, payload)
	end))

	-- NOTE: if you have many machines, you might want ONE global PlayerRemoving hook.
	-- This is fine for a few machines.
	table.insert(self.Conns, Players.PlayerRemoving:Connect(function(plr)
		self:HandlePlayerRemoving(plr)
	end))
end

return Controller
]]></ProtectedString>
						<string name="ScriptGuid">{4595FF74-2148-4E94-8A4F-7A88F7E673DA}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Punching_Game_Controller_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3E24CF675E874272B17E187B4CD11FA7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local TS  = game:GetService("TweenService")
local TCL = {}
function TCL.LockCameraAt(tweenTime: number?,  camPos: CFrame,Cam:Camera  )
	
	Cam.CameraType = Enum.CameraType.Scriptable
	local tween = TS:Create(
		Cam,
		TweenInfo.new(tweenTime or 0.15, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
		{ CFrame = camPos}
	)
	tween:Play()
end

function TCL.UnlockCamera(Cam:Camera , Plr:Player)
	Cam.CameraType = Enum.CameraType.Custom
	local char = Plr.Character or Plr.CharacterAdded:Wait()
	local hum = char:FindFirstChildOfClass("Humanoid")
	if hum then
		Cam.CameraSubject = hum
	end
end

return TCL
]]></ProtectedString>
						<string name="ScriptGuid">{AA4E00E0-C3E4-48B4-9F5B-DFCFC63444A3}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ToggleCameraLock_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4592497902114687B820A1E438794C21">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Global_Params_Mod.lua
--
--  Description:
--      Central configuration module defining all game global settings
--
--  Author(s): Darkzeb
--
--  Last Modified: 2026-01-13 by Darkzeb
--
--  Version: V2026-01
--
--
--  Notes:
--      - Pure configuration module (no functions).
--
--======================================================================

local Global_Params_Mod = {

	Server_Mode = {
		STANDARD = "Standard",
		TOURNAMENT = "Tournament"
	},

	League = {
		MMA_FIGHTERS = "MMA_FIGHTERS",
		UFC = "UFC"
	},

	-- Maximum number of players per Tournament server
	Tournament_Server_Capacity = 2,
	-- TTL applied to each MemoryStore entry (seconds)
	-- If no update happens, the entry disappears automatically
	Tournament_Server_TTL = 30,
	-- A server is considered dead if it hasn't heartbeated within this time
	Tournament_Server_Heartbeat_Interval = 10
}
return Global_Params_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{4162B7A6-4733-4F53-9DCF-C933A3943D06}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Global_Params_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD9DBBA18951C4EB6BC0937C2F1CA1C11">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ReplicatedStorage/Data_Mods_F/Tournament_Rules_Text_Mod.lua
-- Simple text presets for Tournament + League UI

local Rules = {}

-- =========
-- TITLES
-- =========
Rules.Titles = {
	Tournament = "WEEKLY TOURNAMENT 🏆",
	Divisions  = "DIVISIONS 🥇",
	Rewards    = "REWARDS 🎁",
}

-- =========
-- SHORT (panel)
-- =========
Rules.Tournament_Short = table.concat({
	"⏰ Starts every Monday 00:00 UTC and lasts 7 days\n",
	"🥊 Fight players in your Division (Bronze → UFC)\n",
	"📈 Win fights to earn Tournament LP\n",
	"🚫 No Elo changes in Tournament fights\n",
	"⬆️ Top players get Promoted\n⬇️ Bottom players get Demoted\n",
	"🎁 Rewards are given at the end of the week\n",
}, "\n")

-- =========
-- REWARDS / MULTIPLIERS (edit these numbers anytime)
-- =========
Rules.RewardMultipliers = {
	Bronze   = 1.0,
	Silver   = 1.1,
	Gold     = 1.2,
	Emerald  = 1.3,
	Diamond  = 1.4,
	Platinum = 1.5,
	UFC      = 1.6,
}

local function formatMultipliers(mult)
	local order = { "Bronze", "Silver", "Gold", "Emerald", "Diamond", "Platinum", "UFC" }
	local out = {
		"🎁 End-of-week rewards go to the top ranks\n",
		"📈 Higher divisions give bigger rewards\n",
		"<font size=\"60\">⭐ Multipliers:</font>",
	}

	local icons = {
		Bronze   = "🥉",
		Silver   = "🥈",
		Gold     = "🥇",
		Emerald  = "💚",
		Diamond  = "💎",
		Platinum = "🔷",
		UFC      = "👑",
	}

	for _, div in ipairs(order) do
		local v = mult[div]
		if v then
			table.insert(out, string.format("<font size=\"55\">%s %s  x%.1f</font>", icons[div] or "•", div, v))
		end
	end

	return table.concat(out, "\n")
end

Rules.Rewards_Text = formatMultipliers(Rules.RewardMultipliers)

-- =========
-- DIVISIONS TEXT
-- =========
Rules.Divisions_Text = table.concat({
	"Bronze → Silver → Gold → Emerald → Diamond → Platinum → UFC",
	"Climb divisions by placing in the Top ranks each week.",
}, "\n")

-- =========
-- MOBILE ULTRA SHORT
-- =========
Rules.Tournament_Mobile = table.concat({
	"Weekly Tournament",
	"Win fights → earn LP → rank up",
	"No Elo changes",
	"Top promote, bottom demote",
}, "\n")

-- =========
-- TOAST / NOTIFICATIONS
-- =========
Rules.Toasts = {
	Registered       = "✅ Registered! You’re ready for the weekly tournament.",
	Unregistered     = "❌ Unregistered. You can join again anytime before it ends.",
	TournamentLive   = "🔥 Tournament is live! Get in the queue to fight.",
	StartsSoon       = "⏳ Starts soon… Tournament begins at the scheduled time.",
	NotActive        = "🕒 Tournament is not active yet.",
}

return Rules
]]></ProtectedString>
						<string name="ScriptGuid">{B4193A9B-AE5E-49F0-A800-B24716E9D404}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tournament_Rules_Text_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXEA85DA4D7991447E85C17894D7016CF1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Bot_Behaviors</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXE7248E893A354C9C8289506BDD30AD4B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Modules/Behaviors/NORMAL.lua
--
--  Description:
--      Behavior module defining the "NORMAL" AI used for training fights.
--      Provides full combat behavior logic including:
--          • Movement & player tracking
--          • Striking, blocking, dodging
--          • Hit reactions, stamina/health handling
--          • Submission logic & cage clinch interactions
--          • Animation orchestration and damage application
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-12-05 by Darkzeb
--
--  Version: V2025-12
--
--  Dependencies:
--      - Roblox Services:
--          * RunService
--          * TweenService
--          * ReplicatedStorage
--          * Debris
--
--      - Modules:
--          * Utils
--          * Channels (RemoteEvents & Bindables)
--          * Animation_Mod
--          * Sound_Mod
--          * Stats_Manager_Mod
--          * Fight_Params_Mod
--
--  Used By:
--      - Bots_Manager (injects this behavior when spawning training bots)
--      - Fight_Service
--
--  Notes:
--      - AI maintains its own registry (_registry) for instance tracking.
--      - Fully autonomous decision-making:
--          ✔ dodges based on raycast distance
--          ✔ reacts to player attacks
--          ✔ manages strike combos, block logic, stamina regen
--      - Submission & clinch sequences use specialized animation tracks.
--      - Large module: logic is intentionally server-side for determinism.
--
--======================================================================
local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")

local Channels = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Overhead_Display = Channels.SC_Remote_Events.Overhead_Display
local Got_Hit_Effect = Channels.SC_Remote_Events.Got_Hit_Effect
local AI_Training_Cage_Clinch = Channels.Bindable_Events.AI_Training_Cage_Clinch
local AI_Training_Submission = Channels.Bindable_Events.AI_Training_Submission
local Ragdoll_Player = Channels.Bindable_Events.Ragdoll_Player

local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))

local NORMAL_Behavior = {}
NORMAL_Behavior.__index = NORMAL_Behavior
NORMAL_Behavior._registry = {}


function NORMAL_Behavior.new()
	local self = setmetatable({}, NORMAL_Behavior)
	self.Cons = {}
	return self
end

function NORMAL_Behavior:Init(_plr, _botModel)
	self.player = _plr
	self.Bot = _botModel
	NORMAL_Behavior._registry[_botModel] = self
end

function NORMAL_Behavior:StartFight()
	local HRP = nil
	local Hum = nil
	local Head =nil
	local Fight_Data_F = nil
	local Stamina_V = nil
	local Fight_UI = nil
	local Health_V =nil
	local Stam_V = nil
	local Block_Power_V = nil
	local Strike_Power_V = nil
	local Fight_Walkspeed = 12
	local Is_Active = false

	if self.Bot and self.Bot:IsA("Model") then
		-- set body parts
		HRP = self.Bot:FindFirstChild("HumanoidRootPart")
		Hum = self.Bot:FindFirstChildWhichIsA("Humanoid")
		Head = self.Bot:FindFirstChild("Head")
		-- fight data folder
		Fight_Data_F = self.Bot:FindFirstChild("Fight_Data")
		if Fight_Data_F ~= nil then
			Health_V = Fight_Data_F:FindFirstChild("Health")
			Stam_V = Fight_Data_F:FindFirstChild("Staminia")
			Block_Power_V = Fight_Data_F:FindFirstChild("Block Power")
			Strike_Power_V = Fight_Data_F:FindFirstChild("Strike Power")
			-- use Stam_V for stamina regen logic
			Stamina_V = Stam_V
		end
		-- store current fight UI if present
		Fight_UI = self.Bot:FindFirstChild("Fighting_UI")
	end
	
	-- Direct stamina regeneration for bot (server-side)
	local function Reload_Stamina()
		while Stamina_V.Value < 40 do
			Stamina_V.Value = math.min(Stamina_V.Value + 1, 100) -- regen step, adjust as needed
			task.wait(0.1)
		end
	end

	local function Disconnect_Cons()
		for i = 1, #self.Cons do
			if(self.Cons[i] ~= nil)then
				self.Cons[i]:Disconnect()
			end
		end
		table.clear(self.Cons)
	end

	local function Get_Fighting_UI()
		local Fight_UI = self.Bot:FindFirstChild("Fighting_UI")
		if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
			local Main_F = Fight_UI:FindFirstChild("Main_F") 
			local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
			if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
				return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
			end
		end
		return nil, nil
	end

	local function Reset_AI()
		Disconnect_Cons()

		Health_V.Value = Fight_Params_Mod.Health.Max_Value
		Stam_V.Value = Fight_Params_Mod.Stamina.Max_Value
		Block_Power_V.Value = Fight_Params_Mod.Block_Power.Max_Value
		Strike_Power_V.Value = Fight_Params_Mod.Punch_Power.Max_Value

		if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
			HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
		end

		if(Hum ~= nil)then
			Hum.AutoRotate = false
			Hum.WalkSpeed = 12
			Hum.JumpPower = 0

			Animation_Mod.Reset_Character_Animations(self.Bot)

			Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
			Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
			Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
		end

		self.Bot:SetAttribute("Is_Fighting", false)
		Is_Active = false
	end
	
	-- determine which player and character to fight
	-- prefer explicit arguments, fall back to stored values
	local T_Plr = self.player 
	if not T_Plr then return end
	local T_Char =  self.player.Character
	if not T_Char then return end
	-- cache parts from the opponent
	local T_HRP = T_Char:WaitForChild("HumanoidRootPart")
	local T_Fight_Data = T_Plr:FindFirstChild("Fight_Data")
	if not T_Fight_Data then return end
	local T_Health_V = T_Fight_Data:WaitForChild("Health")
	--local T_Stam_V = T_Fight_Data:WaitForChild("Staminia")
	--local T_Block_Power_V = T_Fight_Data:WaitForChild("Block Power")
	local T_Strike_Power_V = T_Fight_Data:WaitForChild("Strike Power")
	local Is_Submission = false

	self.Bot:SetAttribute("Is_Fighting", true)
	Reset_AI()
	Is_Active = true

	--Fight Data Changes
	table.insert(self.Cons, Health_V.Changed:Connect(function()
		if(self.Bot ~= nil and Health_V.Value <= 0)then
			Ragdoll_Player:Fire(self.Bot)
		end
	end))

	local function Create_BG()
		local OldG = HRP:FindFirstChildWhichIsA("BodyGyro")
		if(OldG ~= nil)then
			OldG:Destroy()
		end

		local bodyG = Instance.new("BodyGyro", HRP)
		bodyG.P = 1000
		bodyG.MaxTorque = Vector3.new(0, 1000, 0)
		bodyG.D = 10

		return bodyG
	end
	local BG = Create_BG()

	local function Movement_Handle()
		local function Update_Player_Movement()
			local function Get_Target_Position()
				if(T_HRP ~= nil)then
					local Move_Speed = T_HRP.Velocity
					local Def_Pos = T_HRP.Position + T_HRP.CFrame.LookVector * 3.5

					if(math.floor(Move_Speed.Magnitude) <= 0)then
						return Def_Pos, T_HRP.Position
					else
						local Ping = T_Plr:GetNetworkPing()
						local Dir = Move_Speed.Unit
						local Speed = Move_Speed.Magnitude
						local Extrapolated_Pos = Def_Pos + Dir * (Speed * Ping)
						local Travel_Time = ((Extrapolated_Pos - HRP.Position).Magnitude) / Hum.WalkSpeed
						return Extrapolated_Pos + Dir * (Hum.WalkSpeed * Travel_Time), Extrapolated_Pos
					end
				end

				return HRP.Position, HRP.Position + HRP.CFrame.LookVector * 3
			end
			local Move_Pos, Look_Pos = Get_Target_Position()

			BG.CFrame = CFrame.new(HRP.Position, Look_Pos)
			Hum:MoveTo(Move_Pos)
		end

		table.insert(self.Cons, RunService.Stepped:Connect(function()
			if(BG ~= nil and HRP ~= nil and Hum ~= nil and Hum.PlatformStand == false and T_Plr ~= nil and T_HRP ~= nil)then
				if(T_Health_V ~= nil and T_Health_V.Value > 0 and Is_Submission == false)then
					Update_Player_Movement()
				else
					Hum:MoveTo(HRP.Position)
				end
			end
		end))

		table.insert(self.Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
			if(Hum.PlatformStand == true)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			else
				BG.P = 1000
				BG.MaxTorque = Vector3.new(0, 1000, 0)
				BG.D = 10
			end
		end))
	end
	Movement_Handle()

	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
		Damage_UIG.Offset = Vector2.new(0, -0.5)
		Damage_Bar_Img.Visible = false
	end

	local function Create_Anim_Arr_Data(Anim_Track_Data)
		local D = {}
		for Key, Anim_Track in next, Anim_Track_Data do
			table.insert(D, Anim_Track)
		end
		return D
	end

	local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	local Combo_Strike_Index = 1
	local Combo_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(T_Plr, Hum, "Bot Combo")
	local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)

	local Debounce_Striking = false
	local Debounce_Dodge = false
	local Debounce_Blocking = false
	--local Debounce_Takedown = false
	local Is_Hit = false

	local function Striking_Movement_Handle()
		--> Update Movement, Moving Forward or Backwards | Moving Left to Right | Standing Idle
		--> Track Humanoid MoveDirection
		table.insert(self.Cons, Hum:GetPropertyChangedSignal("WalkToPoint"):Connect(function()
			local Move_Speed = math.floor(HRP.Velocity.Magnitude)
			if(Move_Speed > 3 and Anim_Track_Data['Shuffle Forward'].IsPlaying == false)then
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				Anim_Track_Data['Shuffle Forward']:Play()
				Anim_Track_Data['Shuffle Forward']:AdjustSpeed(-1)

			elseif(Move_Speed <= 3 and 
				(Anim_Track_Data['Shuffle Forward'].IsPlaying == true or 
					Anim_Track_Data['Shuffle Side'].IsPlaying == true))then

				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
			end
		end))

		Anim_Track_Data['Idle']:Play()
		Anim_Track_Data['Idle']:AdjustSpeed(0.5)
	end
	Striking_Movement_Handle()

	local function On_Hit_Effects()
		--[[
			* When Health goes Down!
				> Camera Shake Effects
					-> Quick Shake
				> Apply Hit Effects
					-> Reset all Animations, Play the Hit One
				> Set Debounce till Hit Effect goes Away
		]]--

		local Prev_Health = Health_V.Value
		local Hit_Anim_Track = Striking_Anim_Tracks['Taking Hit']

		local function Show_Sweat_Effects()
			if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
				local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
				local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
				if(PE ~= nil)then
					PE:Emit(25)
				end
			end
		end

		table.insert(self.Cons, Health_V.Changed:Connect(function()
			local Current_V = Health_V.Value
			if(Current_V < Prev_Health and Is_Hit == false)then
				Is_Hit = true

				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Show_Sweat_Effects()

				task.spawn(function()
					Animation_Mod.Play_Animation_Track(Hit_Anim_Track)
					Is_Hit = false
				end)
			end

			Prev_Health = Current_V
		end))
	end
	On_Hit_Effects()

	local function Blocking_Effects()
		--[[
			* On Sheild Blocking Power goes down (Greater than 0) and Debounce_Blocking == true
			* Get the Opponent Handed Type
				> Play the Coresponding Animation
		]]--

		local Prev_Blocking = Block_Power_V.Value
		local Tween_Health_Con = nil
		local Tween_Stam_Con = nil
		local Tween_Block_Con = nil
		Block_Power_V:SetAttribute("Is_Blocking", false)

		local function Reset_Healing_Cons()
			if(Tween_Health_Con ~= nil)then
				Tween_Health_Con:Cancel()
				Tween_Health_Con = nil
			end

			if(Tween_Stam_Con ~= nil)then
				Tween_Stam_Con:Cancel()
				Tween_Stam_Con = nil
			end
		end

		local function Create_Reload_Tween (Value, Max, Speed)
			local Delta = Max - Value.Value
			local Reload_Time = math.clamp(Delta, 1, Fight_Params_Mod.Health.Max_Value) * Speed
			local Tween = TweenInfo.new(Reload_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
			return TS:Create(Value, Tween, {Value = Max})
		end

		local function Set_Healing_Cons()
			local Health_Params = Fight_Params_Mod.Health
			if Health_Params.Reloading_Active then
				Tween_Health_Con = Create_Reload_Tween(Health_V, Health_Params.Max_Value, Health_Params.Reload_Time_Factor)
				Tween_Health_Con:Play()
			end

			local Stam_Params = Fight_Params_Mod.Stamina
			Tween_Stam_Con = Create_Reload_Tween(Stam_V, Stam_Params.Max_Value, Stam_Params.Reload_Time_Factor)
			Tween_Stam_Con:Play()
		end

		table.insert(self.Cons, Block_Power_V.AttributeChanged:Connect(function(Attrib_Key)
			if(Attrib_Key == "Is_Blocking" and Block_Power_V:GetAttribute("Is_Blocking") ~= nil)then
				Reset_Healing_Cons()
				if(Block_Power_V:GetAttribute("Is_Blocking") == true)then
					Set_Healing_Cons()
				end
			end
		end))


		local function Update_Fight_Block_UI()
			if(Fight_UI ~= nil and Block_Power_V ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil and 
				Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then

				local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
				local Img = Sheild_F:FindFirstChild("Shield_Img")
				local Txt = Sheild_F:FindFirstChild("Shield_Txt")

				if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
					local UIG = Img:FindFirstChildWhichIsA("UIGradient")
					local Block_Power = Block_Power_V.Value
					local Dif =  math.clamp(Block_Power / 30, 0, 1)
					local Offset_Pos_Y = (1 - Dif) - 0.5

					UIG.Offset = Vector2.new(0, Offset_Pos_Y)
					Txt.Text = Block_Power .. ""
					if(Dif <= 0.25)then
						Txt.TextColor3 = Color3.new(1, 0, 0)
					else
						Txt.TextColor3 = Color3.new(1, 1, 1)
					end

				end
			end

		end

		table.insert(self.Cons, Block_Power_V.Changed:Connect(function()
			local Current_V = Block_Power_V.Value
			if(Current_V > 0 and Current_V < Prev_Blocking and Debounce_Blocking == true)then
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Striking_Anim_Tracks['Body Block Left'])

				if(Block_Power_V.Value < 30)then
					if(Tween_Block_Con ~= nil)then
						Tween_Block_Con:Cancel()
						Tween_Block_Con = nil
					end

					local Block_Time = math.clamp((30 - Block_Power_V.Value) * 0.2667, 0.2667, 8)
					local Tween_Block_Power = TweenInfo.new(Block_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 6)
					Tween_Block_Con = TS:Create(Block_Power_V, Tween_Block_Power, {Value = 30})
					Tween_Block_Con:Play()
					Tween_Block_Con.Completed:Wait()
					Tween_Block_Con = nil
				end
			end

			Update_Fight_Block_UI()
			Prev_Blocking = Current_V

		end))

	end
	Blocking_Effects()

	local function Get_Core_Strike_Handles()
		local Funcs = {}
		SE_Mod.PlaySFX(T_Plr, "Punch_Woosh_SE")

		local function Has_Enough_Stam(Min_V)
			if(Stam_V ~= nil and Stam_V.Value >= Min_V)then
				Stam_V.Value -= Min_V
				return true
			end
			return false
		end

		local function Get_Player_To_Hit()
			local Whitelist_Chars = {T_Char}
			local Overlap_P = OverlapParams.new()
			Overlap_P.MaxParts = 1
			Overlap_P.FilterType = Enum.RaycastFilterType.Include
			Overlap_P.FilterDescendantsInstances = {Whitelist_Chars}

			local function Create_Region_CF()
				local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
				local Distance = (Speed + 3)
				--local Head_Dir = Head.CFrame.LookVector
				--local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

				local cframe = HRP.CFrame * CFrame.new(0, 0, -3)
				return cframe
			end
			local Spawn_CF = Create_Region_CF()
			local Hitbox_Size = Vector3.new(4, 8, 4)

			--local function Create_Hitbox_Part()
			--	local P = Instance.new("Part", game.Workspace)
			--	P.Name = "Hitbox_Part"
			--	P.Anchored = true
			--	P.CanCollide = false
			--	P.Transparency = 0.5
			--	P.Color = Color3.new(1, 0, 0)
			--	P.Material = Enum.Material.SmoothPlastic
			--	P.Size = Hitbox_Size
			--	P.CFrame = Spawn_CF

			--	Debris:AddItem(P, 5)
			--end
			--Create_Hitbox_Part()

			local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
			if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
				local function Get_Char_From_BP()
					for i = 1, #Whitelist_Chars do
						local C = Whitelist_Chars[i]
						if(C ~= nil and Region_Data[1]:IsDescendantOf(C))then
							return C
						end
					end

					return Whitelist_Chars[1]
				end

				return Get_Char_From_BP()
			end

			return nil
		end

		local function Get_Punch_Power(delay)
			local Params = Fight_Params_Mod.Punch_Power

			local Tween_Punch_Power_Back = TweenInfo.new(Params.Reload_Time, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, delay)
			local Strike_Power = Strike_Power_V.Value
			Strike_Power_V.Value = Params.Min_Value
			TS:Create(Strike_Power_V, Tween_Punch_Power_Back, {Value = Params.Max_Value}):Play()
			return Strike_Power
		end

		local function Get_Target_Fight_Data(Hit_Char)
			local Hit_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
			if(Hit_Plr ~= nil)then
				return Hit_Plr:FindFirstChild("Fight_Data")
			else
				return Hit_Char:FindFirstChild("Fight_Data")
			end
		end

		function Funcs.Strike_Handle()
			if Stamina_V.Value < 20 then Reload_Stamina() end
			--[[
				* Play Woosh Sound Effect locally
				* Play Animation
				* Tell the Server that you are Striking
			]]--

			Debounce_Striking = true
			-- AI is Striking!
			SE_Mod.PlaySFX(T_Plr, "Punch_Woosh_SE")

			local function Play_Strike_Animation()
				local Track = Combo_Anim_Arr[Combo_Strike_Index]
				local Key = Track:GetAttribute("Strike_Key") or "A"

				task.spawn(function()
					if(HRP ~= nil and Has_Enough_Stam(10))then

						local Hit_Char = Get_Player_To_Hit()
						local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Key)

						local Damage_Multi = Get_Punch_Power(Strike_Data['Time Length'])
						local Strike_Damage = Strike_Data['Damage']
						local Punch_Power = math.round(Strike_Damage * Damage_Multi)

						if(Hit_Char ~= nil)then
							local Hit_Fight_Data = Get_Target_Fight_Data(Hit_Char)
							if(Hit_Fight_Data ~= nil and Hit_Fight_Data:FindFirstChild("Health") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Block Power") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Staminia") ~= nil)then

								local T_Health = Hit_Fight_Data:FindFirstChild("Health")
								local T_Block_Power = Hit_Fight_Data:FindFirstChild("Block Power")
								local T_Staminia = Hit_Fight_Data:FindFirstChild("Staminia")

								local function Is_Dodging_Check()
									local Is_Dodging = T_Staminia:GetAttribute("Is_Dodging")
									if(Is_Dodging ~= nil and Is_Dodging == true)then
										local Target_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if(Target_Plr ~= nil)then
											Stats_Manager_Mod.Add_To_Player_Stats_Data(Target_Plr, "Dodged Strikes", 1)
										end

										return true
									end
									return false
								end

								local function Is_Blocking_Check()
									local Is_Block = T_Block_Power:GetAttribute("Is_Blocking")
									if(Is_Block ~= nil and Is_Block == true)then
										T_Block_Power.Value -= Punch_Power
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.fromRGB(170, 85, 255))

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										if(T_Block_Power.Value < 0)then
											local Dif = math.abs(T_Block_Power.Value)
											T_Health.Value = math.clamp(T_Health.Value - Dif, 0, 100)
											T_Block_Power.Value = 0

											SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
											--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)

											Overhead_Display:FireAllClients(Hit_Char, "-" .. Dif, Color3.new(1, 0, 0))

										else
											SE_Mod.PlaySFX(HRP, "Blocked_Hit_SE")	
										end

										return true
									end

									return false
								end

								if(Is_Dodging_Check())then
									--Play Dodging Text
									Overhead_Display:FireAllClients(Hit_Char, "Dodged", Color3.fromRGB(35, 244, 68))
								elseif(Is_Blocking_Check())then
									--Play Blocking 
								else
									--Apply the Hit
									local function Apply_Strike()
										T_Health.Value = math.clamp(T_Health.Value - Punch_Power, 0, 100)
										SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
										--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.new(1, 0, 0))
										--Punch_Hit_VFX:FireClient(Plr, Hit_Char)
										--Play Damage Val Show

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										local T_HRP = Hit_Char:FindFirstChild("HumanoidRootPart")
										if(T_HRP ~= nil)then
											local Hit_Force = 625 -- Was 350 then 500
											local Dir = HRP.CFrame.LookVector 
											T_HRP:ApplyImpulse(Dir * Hit_Force * T_HRP:GetMass())
										end
									end
									Apply_Strike()
								end
							end

						end
					end
				end)

				Combo_Strike_Index += 1
				if(Combo_Strike_Index > #Combo_Anim_Arr)then
					Combo_Strike_Index = 1
				end

				Animation_Mod.Stop_Animation_Tracks(Combo_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Track)
			end
			task.spawn(Play_Strike_Animation)
			task.wait(0.5)

			Debounce_Striking = false
		end

		local Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left']
		local Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		local Back_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		function Funcs.Dodge_Handle(Dodge_Type)
			--[[
				* Get the Type First
					-> First Index? Just play the Slip Animation
					-> 2nd Index? Play the Dodge Animation AND apply Force to the Player in the direction
				
					-> Tell the Server that you are Dodging and should reduce Staminia Value
			]]--

			Debounce_Dodge = true
			-- AI is Dodging

			local function Apply_Force(Dir)
				HRP:ApplyImpulse(Dir * (Fight_Walkspeed * 65) * HRP:GetMass())
			end

			task.spawn(function()
				if(Has_Enough_Stam(5))then
					--Play the Sound Effect
					--Toggle Value
					SE_Mod.PlaySFX(HRP, "Missed_SE")
					Stam_V:SetAttribute("Is_Dodging", true)
					task.wait(0.5)
					Stam_V:SetAttribute("Is_Dodging", false)
				end
			end)
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})

			local function Increment_Anim()
				if(Dodge_Type == "Dodge Left")then
					if(Left_Dodge_Ani == Striking_Anim_Tracks['Slip Left'])then
						Left_Dodge_Ani = Striking_Anim_Tracks['Headblock Left']
					else
						Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left'] 
					end
				else
					--Right
					if(Right_Dodge_Ani == Striking_Anim_Tracks['Slip Right'])then
						Right_Dodge_Ani = Striking_Anim_Tracks['Headblock Right']
					else
						Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right'] 
					end
				end
			end

			if(Dodge_Type == "Dodge Left")then
				--Left
				if(Left_Dodge_Ani == Striking_Anim_Tracks['Headblock Left'])then
					--Apply_Force(HRP.CFrame.RightVector * -1)
				end
				Apply_Force(HRP.CFrame.RightVector * -1)
				Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Right")then
				--Right
				if(Right_Dodge_Ani == Striking_Anim_Tracks['Headblock Right'])then
					--Apply_Force(HRP.CFrame.RightVector)
				end
				Apply_Force(HRP.CFrame.RightVector)
				Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Back")then
				Apply_Force(HRP.CFrame.LookVector * -1)
				Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
			end

			Debounce_Dodge = false
		end

		local function Toggle_Sheild_Icon(Is_Enabled)
			local Main_F =  Fight_UI:FindFirstChild("Main_F")
			if(Main_F ~= nil and Main_F:FindFirstChild("Shield_F") ~= nil)then
				local SF = Main_F:FindFirstChild("Shield_F")
				SF.Visible = true

				local Img = SF:FindFirstChild("Shield_Img")
				if(Img ~= nil)then
					if(Is_Enabled)then
						Img.Image = "rbxassetid://130871917395731"
					else
						Img.Image = "rbxassetid://125284121534949"
					end
				end
			end
		end

		local function Toggle_Heal_PE(Is_Enabled)
			local PE = HRP:GetChildren()
			for i = 1, #PE do
				if(PE[i] ~= nil and PE[i].Name == "Heal_PE" and PE[i]:IsA("ParticleEmitter"))then
					PE[i].Enabled = Is_Enabled
				end
			end

			Toggle_Sheild_Icon(Is_Enabled)
		end

		local Low_Block_Con = nil
		local function Disable_Blocking_Handle()
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed
			end

			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Block_Power_V:SetAttribute("Is_Blocking", false)
			Toggle_Heal_PE(false)

			Debounce_Blocking = false
		end

		local function Play_Blocking_Animation()
			local Anim_Track = Striking_Anim_Tracks['Main Block']
			if(Anim_Track ~= nil)then
				Anim_Track:Play()
				Anim_Track:AdjustSpeed(1)
				task.wait(Anim_Track.Length * 0.9)

				if(Anim_Track ~= nil and Debounce_Blocking == true)then
					Anim_Track:AdjustSpeed(0)
				end
			end
		end

		function Funcs.Disable_Blocking_Handle()
			-- AI is turning off Blocking
			Disable_Blocking_Handle()
		end

		function Funcs.Blocking_Handle()
			Debounce_Blocking = true
			-- AI Is Blocking

			if(Hum ~= nil)then
				Hum.WalkSpeed = 8
			end

			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			Low_Block_Con = Block_Power_V.Changed:Connect(function()
				if(Block_Power_V.Value <= 0 and Debounce_Blocking == true)then
					if(Low_Block_Con ~= nil)then
						Low_Block_Con:Disconnect()
						Low_Block_Con = nil
					end

					Disable_Blocking_Handle()
				end
			end)
			table.insert(self.Cons, Low_Block_Con)
			task.spawn(Play_Blocking_Animation)

			if(Block_Power_V ~= nil and Block_Power_V.Value > 0)then
				Block_Power_V:SetAttribute("Is_Blocking", true)
				Toggle_Heal_PE(true)
			end
		end

		function Funcs.Get_Hitbox_Res()
			return (Get_Player_To_Hit() ~= nil)
		end		

		function Funcs.Get_Dodge_Type()
			local function Get_Ray_Distance_Data()
				local Origin = HRP.Position
				local Ray_Parm = RaycastParams.new()
				Ray_Parm.FilterType = Enum.RaycastFilterType.Exclude
				Ray_Parm.FilterDescendantsInstances = {self.Bot, T_Char}

				local function Get_Ray_Dist(Dir)
					local Ray_Res = game.Workspace:Raycast(Origin, Dir * 10, Ray_Parm)
					if(Ray_Res ~= nil and Ray_Res.Distance ~= nil)then
						return Ray_Res.Distance
					end
					return 15
				end

				return {
					{
						['Type'] = "Dodge Back",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.LookVector * -1)
					},

					{
						['Type'] = "Dodge Left",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector * -1)
					},

					{
						['Type'] = "Dodge Right",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector)
					},

				}
			end
			local Ray_Dist_Arr = Get_Ray_Distance_Data()

			table.sort(Ray_Dist_Arr, function(A, B)
				return A['Distance'] > B['Distance']
			end)

			return Ray_Dist_Arr[1]['Type']
		end

		function Funcs.Is_Player_Striking_You()
			if(T_Strike_Power_V ~= nil and T_Strike_Power_V.Value < Fight_Params_Mod.Punch_Power.Max_Value * 0.5)then
				return true
			end
			return false
		end

		return Funcs
	end
	local Core_Strike_Funcs = Get_Core_Strike_Handles()

	--[[
		Core AI Decision Making goes here
		
		* If within Striking Distance ~ 5 Studs
			* If Player is Striking too, Dodge Left Right or Back (Max 2 Dodges)
			* Has to Strike (Max 3 Strikes)
				* Dodge Back if Strike (or left or Right)
		* Default to Blocking Handle
	]]--

	local function Submission_Handle(Is_Submitting, Attacking_Char)
		Animation_Mod.Reset_Character_Animations(self.Bot)
		if(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end

		if(Is_Submitting)then
			Is_Submission = true
			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end

			if(HRP ~= nil)then
				--HRP.Anchored = true
				--HRP.CFrame *= CFrame.new(Vector3.new(0, 0.15, 0))
				HRP.CFrame = HRP.CFrame * CFrame.new(0, 0.15, 0)
			end

			--> Play Animation
			--> Get Submission Character & Player
			--> Get their Takedown and Submission Data

			--> If Attacking Player, Set HRP CFrame Position
			--> Play Take Down Animation

			--> Play Submission Animation
			--> Play Submission Loop Animation

			local function Get_Takedown_Submission_Tracks()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)
				return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Receiving ID'], Submission_Data['Receiving ID'], Submission_Data['Receiving Loop ID'])
			end
			local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()

			Takedown_Track.Priority = Enum.AnimationPriority.Action2
			Animation_Mod.Play_Animation_Track(Takedown_Track, true)

			task.wait(0.25)

			Submission_Track.Priority = Enum.AnimationPriority.Action3
			Animation_Mod.Play_Animation_Track(Submission_Track)

			Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
		else
			Is_Hit = false

			if(HRP ~= nil)then
				HRP.Anchored = false
			end

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
			Is_Submission = false
		end
	end

	table.insert(self.Cons, AI_Training_Submission.Event:Connect(function(AI_Char, Attacking_Char, Is_Submitting)
		if(AI_Char == self.Bot)then
			Submission_Handle(Is_Submitting, Attacking_Char)
		end
	end))


	local function Clinch_Handle(Animation_Sequence_Data, Is_Attacking)
		local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(self.Bot)

			if(Debounce_Blocking == true)then
				task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
			end

			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
		end
		Freeze_Character()

		local function Play_Strike_Sequences()
			local Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
			Animation_Mod.Play_Animation_Track(Clinch_Tracks_Data['Init_Clinch'], true)
			task.spawn(Animation_Mod.Play_Animation_Track, Clinch_Tracks_Data['Loop_Clinch'])
			task.wait(1)

			for i = 1, #Animation_Sequence_Data do
				local Strike_Key = Animation_Sequence_Data[i]
				local Strike_Track = Clinch_Tracks_Data[Strike_Key]

				if(Strike_Track ~= nil)then
					--Play Flash, Play Hit Sound Effect, Quick Camera Shake
					Animation_Mod.Play_Animation_Track(Strike_Track)
					--wait(0.5)
				end
			end

		end
		Play_Strike_Sequences()

		local function Clinch_Reset_Handle()
			Animation_Mod.Reset_Character_Animations(self.Bot)
			Is_Hit = false

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
		end	
		Clinch_Reset_Handle()
	end

	table.insert(self.Cons, AI_Training_Cage_Clinch.Event:Connect(function(AI_Char, Sequence_Keys, Is_Attacking)
		if(AI_Char == self.Bot)then
			Clinch_Handle(Sequence_Keys, Is_Attacking)
		end
	end))


	local Strike_Count, Dodge_Count = 0, 0
	local function Main_AI_Logic_Gate()
		if(Health_V.Value > 0 and Is_Hit == false and T_Health_V ~= nil and T_Health_V.Value > 0)then
			if(Core_Strike_Funcs.Get_Hitbox_Res())then -- Within Strike Zone
				local Is_Player_Hitting_You = Core_Strike_Funcs.Is_Player_Striking_You()
				if(Is_Player_Hitting_You)then
					--Take the HIts until you're below 20 Block Power
					-- Dodge? or Strike
					if(Block_Power_V.Value > 10)then
						if(Dodge_Count < 2 or Strike_Count >= 3)then
							--Dodge
							if(Debounce_Dodge == false and Stam_V.Value >= 5)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								local Dodge_Type = Core_Strike_Funcs.Get_Dodge_Type()
								Core_Strike_Funcs.Dodge_Handle(Dodge_Type)

								Dodge_Count += 1
								if(Strike_Count >= 3)then
									Strike_Count = 0
								end
							end

						else
							--Strike
							if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								Core_Strike_Funcs.Strike_Handle()
								Strike_Count += 1
								if(Dodge_Count >= 2)then
									Dodge_Count = 0
								end
							else
								Core_Strike_Funcs.Blocking_Handle()
							end
						end
					elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
						--Not within Strike Zone, resort to Blocking
						Core_Strike_Funcs.Blocking_Handle()
					end
				else
					--Strike
					if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
						if(Debounce_Blocking == true)then
							task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
						end

						Core_Strike_Funcs.Strike_Handle()
						Strike_Count += 1
						if(Dodge_Count >= 2)then
							Dodge_Count = 0
						end
					else 
						Core_Strike_Funcs.Blocking_Handle()
					end
				end
			elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
				--Not within Strike Zone, resort to Blocking
				Core_Strike_Funcs.Blocking_Handle()
			end

		elseif(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end
	end

	while Is_Active do
		if(Is_Submission == false)then
			Main_AI_Logic_Gate()
		end
		task.wait(0.5)
	end
end

return NORMAL_Behavior]]></ProtectedString>
							<string name="ScriptGuid">{F65631B7-D9B0-45C7-83CB-75573F22039E}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">NORMAL.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0799E86DC81E4D07ACD5EB6D8C948757">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Modules/Behaviors/COACH.lua
--
--  Description:
--      Behavior module defining the "NORMAL" AI used for training fights.
--      Provides full combat behavior logic including:
--          • Movement & player tracking
--          • Striking, blocking, dodging
--          • Hit reactions, stamina/health handling
--          • Submission logic & cage clinch interactions
--          • Animation orchestration and damage application
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-12-05 by Darkzeb
--
--  Version: V2025-12
--
--  Dependencies:
--      - Roblox Services:
--          * RunService
--          * TweenService
--          * ReplicatedStorage
--          * Debris
--
--      - Modules:
--          * Utils
--          * Channels (RemoteEvents & Bindables)
--          * Animation_Mod
--          * Sound_Mod
--          * Stats_Manager_Mod
--          * Fight_Params_Mod
--
--  Used By:
--      - Bots_Manager (injects this behavior when spawning training bots)
--      - Fight_Service
--
--  Notes:
--      - AI maintains its own registry (_registry) for instance tracking.
--      - Fully autonomous decision-making:
--          ✔ dodges based on raycast distance
--          ✔ reacts to player attacks
--          ✔ manages strike combos, block logic, stamina regen
--      - Submission & clinch sequences use specialized animation tracks.
--      - Large module: logic is intentionally server-side for determinism.
--
--======================================================================
local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")

local Channels = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Overhead_Display = Channels.SC_Remote_Events.Overhead_Display
local Got_Hit_Effect = Channels.SC_Remote_Events.Got_Hit_Effect
local AI_Training_Cage_Clinch = Channels.Bindable_Events.AI_Training_Cage_Clinch
local AI_Training_Submission = Channels.Bindable_Events.AI_Training_Submission
local Ragdoll_Player = Channels.Bindable_Events.Ragdoll_Player

local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))

local COACH_Behavior = {}
COACH_Behavior.__index = COACH_Behavior
COACH_Behavior._registry = {}


function COACH_Behavior.new()
	local self = setmetatable({}, COACH_Behavior)
	self.Cons = {}
	return self
end

function COACH_Behavior:Init(_plr, _botModel)
	self.player = _plr
	self.Bot = _botModel
	COACH_Behavior._registry[_botModel] = self
end

function COACH_Behavior:StartFight()
	local HRP = nil
	local Hum = nil
	local Head =nil
	local Fight_Data_F = nil
	local Stamina_V = nil
	local Fight_UI = nil
	local Health_V =nil
	local Stam_V = nil
	local Block_Power_V = nil
	local Strike_Power_V = nil
	local Fight_Walkspeed = 12
	local Is_Active = false

	if self.Bot and self.Bot:IsA("Model") then
		-- set body parts
		HRP = self.Bot:FindFirstChild("HumanoidRootPart")
		Hum = self.Bot:FindFirstChildWhichIsA("Humanoid")
		Head = self.Bot:FindFirstChild("Head")
		-- fight data folder
		Fight_Data_F = self.Bot:FindFirstChild("Fight_Data")
		if Fight_Data_F ~= nil then
			Health_V = Fight_Data_F:FindFirstChild("Health")
			Stam_V = Fight_Data_F:FindFirstChild("Staminia")
			Block_Power_V = Fight_Data_F:FindFirstChild("Block Power")
			Strike_Power_V = Fight_Data_F:FindFirstChild("Strike Power")
			-- use Stam_V for stamina regen logic
			Stamina_V = Stam_V
		end
		-- store current fight UI if present
		Fight_UI = self.Bot:FindFirstChild("Fighting_UI")
	end
	
	-- Direct stamina regeneration for bot (server-side)
	local function Reload_Stamina()
		while Stamina_V.Value < 40 do
			Stamina_V.Value = math.min(Stamina_V.Value + 1, 100) -- regen step, adjust as needed
			task.wait(0.1)
		end
	end

	local function Disconnect_Cons()
		for i = 1, #self.Cons do
			if(self.Cons[i] ~= nil)then
				self.Cons[i]:Disconnect()
			end
		end
		table.clear(self.Cons)
	end

	local function Get_Fighting_UI()
		local Fight_UI = self.Bot:FindFirstChild("Fighting_UI")
		if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
			local Main_F = Fight_UI:FindFirstChild("Main_F") 
			local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
			if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
				return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
			end
		end
		return nil, nil
	end

	local function Reset_AI()
		Disconnect_Cons()

		Health_V.Value = Fight_Params_Mod.Health.Max_Value
		Stam_V.Value = Fight_Params_Mod.Stamina.Max_Value
		Block_Power_V.Value = Fight_Params_Mod.Block_Power.Max_Value
		Strike_Power_V.Value = Fight_Params_Mod.Punch_Power.Max_Value

		if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
			HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
		end

		if(Hum ~= nil)then
			Hum.AutoRotate = false
			Hum.WalkSpeed = 12
			Hum.JumpPower = 0

			Animation_Mod.Reset_Character_Animations(self.Bot)

			Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
			Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
			Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
		end

		self.Bot:SetAttribute("Is_Fighting", false)
		Is_Active = false
	end
	
	-- determine which player and character to fight
	-- prefer explicit arguments, fall back to stored values
	local T_Plr = self.player 
	if not T_Plr then return end
	local T_Char =  self.player.Character
	if not T_Char then return end
	-- cache parts from the opponent
	local T_HRP = T_Char:WaitForChild("HumanoidRootPart")
	local T_Fight_Data = T_Plr:FindFirstChild("Fight_Data")
	if not T_Fight_Data then return end
	local T_Health_V = T_Fight_Data:WaitForChild("Health")
	--local T_Stam_V = T_Fight_Data:WaitForChild("Staminia")
	--local T_Block_Power_V = T_Fight_Data:WaitForChild("Block Power")
	local T_Strike_Power_V = T_Fight_Data:WaitForChild("Strike Power")
	local Is_Submission = false

	self.Bot:SetAttribute("Is_Fighting", true)
	Reset_AI()
	Is_Active = true

	--Fight Data Changes
	table.insert(self.Cons, Health_V.Changed:Connect(function()
		if(self.Bot ~= nil and Health_V.Value <= 0)then
			Ragdoll_Player:Fire(self.Bot)
		end
	end))

	local function Create_BG()
		local OldG = HRP:FindFirstChildWhichIsA("BodyGyro")
		if(OldG ~= nil)then
			OldG:Destroy()
		end

		local bodyG = Instance.new("BodyGyro", HRP)
		bodyG.P = 1000
		bodyG.MaxTorque = Vector3.new(0, 1000, 0)
		bodyG.D = 10

		return bodyG
	end
	local BG = Create_BG()

	local function Movement_Handle()
		local function Update_Player_Movement()
			local function Get_Target_Position()
				if(T_HRP ~= nil)then
					local Move_Speed = T_HRP.Velocity
					local Def_Pos = T_HRP.Position + T_HRP.CFrame.LookVector * 3.5

					if(math.floor(Move_Speed.Magnitude) <= 0)then
						return Def_Pos, T_HRP.Position
					else
						local Ping = T_Plr:GetNetworkPing()
						local Dir = Move_Speed.Unit
						local Speed = Move_Speed.Magnitude
						local Extrapolated_Pos = Def_Pos + Dir * (Speed * Ping)
						local Travel_Time = ((Extrapolated_Pos - HRP.Position).Magnitude) / Hum.WalkSpeed
						return Extrapolated_Pos + Dir * (Hum.WalkSpeed * Travel_Time), Extrapolated_Pos
					end
				end

				return HRP.Position, HRP.Position + HRP.CFrame.LookVector * 3
			end
			local Move_Pos, Look_Pos = Get_Target_Position()

			BG.CFrame = CFrame.new(HRP.Position, Look_Pos)
			Hum:MoveTo(Move_Pos)
		end

		table.insert(self.Cons, RunService.Stepped:Connect(function()
			if(BG ~= nil and HRP ~= nil and Hum ~= nil and Hum.PlatformStand == false and T_Plr ~= nil and T_HRP ~= nil)then
				if(T_Health_V ~= nil and T_Health_V.Value > 0 and Is_Submission == false)then
					Update_Player_Movement()
				else
					Hum:MoveTo(HRP.Position)
				end
			end
		end))

		table.insert(self.Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
			if(Hum.PlatformStand == true)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			else
				BG.P = 1000
				BG.MaxTorque = Vector3.new(0, 1000, 0)
				BG.D = 10
			end
		end))
	end
	Movement_Handle()

	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
		Damage_UIG.Offset = Vector2.new(0, -0.5)
		Damage_Bar_Img.Visible = false
	end

	local function Create_Anim_Arr_Data(Anim_Track_Data)
		local D = {}
		for Key, Anim_Track in next, Anim_Track_Data do
			table.insert(D, Anim_Track)
		end
		return D
	end

	local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	local Combo_Strike_Index = 1
	local Combo_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(T_Plr, Hum, "Bot Combo")
	local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)

	local Debounce_Striking = false
	local Debounce_Dodge = false
	local Debounce_Blocking = false
	--local Debounce_Takedown = false
	local Is_Hit = false

	local function Striking_Movement_Handle()
		--> Update Movement, Moving Forward or Backwards | Moving Left to Right | Standing Idle
		--> Track Humanoid MoveDirection
		table.insert(self.Cons, Hum:GetPropertyChangedSignal("WalkToPoint"):Connect(function()
			local Move_Speed = math.floor(HRP.Velocity.Magnitude)
			if(Move_Speed > 3 and Anim_Track_Data['Shuffle Forward'].IsPlaying == false)then
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				Anim_Track_Data['Shuffle Forward']:Play()
				Anim_Track_Data['Shuffle Forward']:AdjustSpeed(-1)

			elseif(Move_Speed <= 3 and 
				(Anim_Track_Data['Shuffle Forward'].IsPlaying == true or 
					Anim_Track_Data['Shuffle Side'].IsPlaying == true))then

				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
			end
		end))

		Anim_Track_Data['Idle']:Play()
		Anim_Track_Data['Idle']:AdjustSpeed(0.5)
	end
	Striking_Movement_Handle()

	local function On_Hit_Effects()
		--[[
			* When Health goes Down!
				> Camera Shake Effects
					-> Quick Shake
				> Apply Hit Effects
					-> Reset all Animations, Play the Hit One
				> Set Debounce till Hit Effect goes Away
		]]--

		local Prev_Health = Health_V.Value
		local Hit_Anim_Track = Striking_Anim_Tracks['Taking Hit']

		local function Show_Sweat_Effects()
			if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
				local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
				local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
				if(PE ~= nil)then
					PE:Emit(25)
				end
			end
		end

		table.insert(self.Cons, Health_V.Changed:Connect(function()
			local Current_V = Health_V.Value
			if(Current_V < Prev_Health and Is_Hit == false)then
				Is_Hit = true

				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Show_Sweat_Effects()

				task.spawn(function()
					Animation_Mod.Play_Animation_Track(Hit_Anim_Track)
					Is_Hit = false
				end)
			end

			Prev_Health = Current_V
		end))
	end
	On_Hit_Effects()

	local function Blocking_Effects()
		--[[
			* On Sheild Blocking Power goes down (Greater than 0) and Debounce_Blocking == true
			* Get the Opponent Handed Type
				> Play the Coresponding Animation
		]]--

		local Prev_Blocking = Block_Power_V.Value
		local Tween_Health_Con = nil
		local Tween_Stam_Con = nil
		local Tween_Block_Con = nil
		Block_Power_V:SetAttribute("Is_Blocking", false)

		local function Reset_Healing_Cons()
			if(Tween_Health_Con ~= nil)then
				Tween_Health_Con:Cancel()
				Tween_Health_Con = nil
			end

			if(Tween_Stam_Con ~= nil)then
				Tween_Stam_Con:Cancel()
				Tween_Stam_Con = nil
			end
		end

		local function Create_Reload_Tween (Value, Max, Speed)
			local Delta = Max - Value.Value
			local Reload_Time = math.clamp(Delta, 1, Fight_Params_Mod.Health.Max_Value) * Speed
			local Tween = TweenInfo.new(Reload_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
			return TS:Create(Value, Tween, {Value = Max})
		end

		local function Set_Healing_Cons()
			local Health_Params = Fight_Params_Mod.Health
			if Health_Params.Reloading_Active then
				Tween_Health_Con = Create_Reload_Tween(Health_V, Health_Params.Max_Value, Health_Params.Reload_Time_Factor)
				Tween_Health_Con:Play()
			end

			local Stam_Params = Fight_Params_Mod.Stamina
			Tween_Stam_Con = Create_Reload_Tween(Stam_V, Stam_Params.Max_Value, Stam_Params.Reload_Time_Factor)
			Tween_Stam_Con:Play()
		end

		table.insert(self.Cons, Block_Power_V.AttributeChanged:Connect(function(Attrib_Key)
			if(Attrib_Key == "Is_Blocking" and Block_Power_V:GetAttribute("Is_Blocking") ~= nil)then
				Reset_Healing_Cons()
				if(Block_Power_V:GetAttribute("Is_Blocking") == true)then
					Set_Healing_Cons()
				end
			end
		end))


		local function Update_Fight_Block_UI()
			if(Fight_UI ~= nil and Block_Power_V ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil and 
				Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then

				local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
				local Img = Sheild_F:FindFirstChild("Shield_Img")
				local Txt = Sheild_F:FindFirstChild("Shield_Txt")

				if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
					local UIG = Img:FindFirstChildWhichIsA("UIGradient")
					local Block_Power = Block_Power_V.Value
					local Dif =  math.clamp(Block_Power / 30, 0, 1)
					local Offset_Pos_Y = (1 - Dif) - 0.5

					UIG.Offset = Vector2.new(0, Offset_Pos_Y)
					Txt.Text = Block_Power .. ""
					if(Dif <= 0.25)then
						Txt.TextColor3 = Color3.new(1, 0, 0)
					else
						Txt.TextColor3 = Color3.new(1, 1, 1)
					end

				end
			end

		end

		table.insert(self.Cons, Block_Power_V.Changed:Connect(function()
			local Current_V = Block_Power_V.Value
			if(Current_V > 0 and Current_V < Prev_Blocking and Debounce_Blocking == true)then
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Striking_Anim_Tracks['Body Block Left'])

				if(Block_Power_V.Value < 30)then
					if(Tween_Block_Con ~= nil)then
						Tween_Block_Con:Cancel()
						Tween_Block_Con = nil
					end

					local Block_Time = math.clamp((30 - Block_Power_V.Value) * 0.2667, 0.2667, 8)
					local Tween_Block_Power = TweenInfo.new(Block_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 6)
					Tween_Block_Con = TS:Create(Block_Power_V, Tween_Block_Power, {Value = 30})
					Tween_Block_Con:Play()
					Tween_Block_Con.Completed:Wait()
					Tween_Block_Con = nil
				end
			end

			Update_Fight_Block_UI()
			Prev_Blocking = Current_V

		end))

	end
	Blocking_Effects()

	local function Get_Core_Strike_Handles()
		local Funcs = {}
		SE_Mod.PlaySFX(T_Plr, "Punch_Woosh_SE")

		local function Has_Enough_Stam(Min_V)
			if(Stam_V ~= nil and Stam_V.Value >= Min_V)then
				Stam_V.Value -= Min_V
				return true
			end
			return false
		end

		local function Get_Player_To_Hit()
			local Whitelist_Chars = {T_Char}
			local Overlap_P = OverlapParams.new()
			Overlap_P.MaxParts = 1
			Overlap_P.FilterType = Enum.RaycastFilterType.Include
			Overlap_P.FilterDescendantsInstances = {Whitelist_Chars}

			local function Create_Region_CF()
				local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
				local Distance = (Speed + 3)
				--local Head_Dir = Head.CFrame.LookVector
				--local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

				local cframe = HRP.CFrame * CFrame.new(0, 0, -3)
				return cframe
			end
			local Spawn_CF = Create_Region_CF()
			local Hitbox_Size = Vector3.new(4, 8, 4)

			--local function Create_Hitbox_Part()
			--	local P = Instance.new("Part", game.Workspace)
			--	P.Name = "Hitbox_Part"
			--	P.Anchored = true
			--	P.CanCollide = false
			--	P.Transparency = 0.5
			--	P.Color = Color3.new(1, 0, 0)
			--	P.Material = Enum.Material.SmoothPlastic
			--	P.Size = Hitbox_Size
			--	P.CFrame = Spawn_CF

			--	Debris:AddItem(P, 5)
			--end
			--Create_Hitbox_Part()

			local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
			if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
				local function Get_Char_From_BP()
					for i = 1, #Whitelist_Chars do
						local C = Whitelist_Chars[i]
						if(C ~= nil and Region_Data[1]:IsDescendantOf(C))then
							return C
						end
					end

					return Whitelist_Chars[1]
				end

				return Get_Char_From_BP()
			end

			return nil
		end

		local function Get_Punch_Power(delay)
			local Params = Fight_Params_Mod.Punch_Power

			local Tween_Punch_Power_Back = TweenInfo.new(Params.Reload_Time, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, delay)
			local Strike_Power = Strike_Power_V.Value
			Strike_Power_V.Value = Params.Min_Value
			TS:Create(Strike_Power_V, Tween_Punch_Power_Back, {Value = Params.Max_Value}):Play()
			return Strike_Power
		end

		local function Get_Target_Fight_Data(Hit_Char)
			local Hit_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
			if(Hit_Plr ~= nil)then
				return Hit_Plr:FindFirstChild("Fight_Data")
			else
				return Hit_Char:FindFirstChild("Fight_Data")
			end
		end

		function Funcs.Strike_Handle()
			if Stamina_V.Value < 20 then Reload_Stamina() end
			--[[
				* Play Woosh Sound Effect locally
				* Play Animation
				* Tell the Server that you are Striking
			]]--

			Debounce_Striking = true
			-- AI is Striking!
			SE_Mod.PlaySFX(T_Plr, "Punch_Woosh_SE")

			local function Play_Strike_Animation()
				local Track = Combo_Anim_Arr[Combo_Strike_Index]
				local Key = Track:GetAttribute("Strike_Key") or "A"

				task.spawn(function()
					if(HRP ~= nil and Has_Enough_Stam(10))then

						local Hit_Char = Get_Player_To_Hit()
						local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Key)

						local Damage_Multi = Get_Punch_Power(Strike_Data['Time Length'])
						local Strike_Damage = Strike_Data['Damage']
						local Punch_Power = math.round(Strike_Damage * Damage_Multi)

						if(Hit_Char ~= nil)then
							local Hit_Fight_Data = Get_Target_Fight_Data(Hit_Char)
							if(Hit_Fight_Data ~= nil and Hit_Fight_Data:FindFirstChild("Health") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Block Power") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Staminia") ~= nil)then

								local T_Health = Hit_Fight_Data:FindFirstChild("Health")
								local T_Block_Power = Hit_Fight_Data:FindFirstChild("Block Power")
								local T_Staminia = Hit_Fight_Data:FindFirstChild("Staminia")

								local function Is_Dodging_Check()
									local Is_Dodging = T_Staminia:GetAttribute("Is_Dodging")
									if(Is_Dodging ~= nil and Is_Dodging == true)then
										local Target_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if(Target_Plr ~= nil)then
											Stats_Manager_Mod.Add_To_Player_Stats_Data(Target_Plr, "Dodged Strikes", 1)
										end

										return true
									end
									return false
								end

								local function Is_Blocking_Check()
									local Is_Block = T_Block_Power:GetAttribute("Is_Blocking")
									if(Is_Block ~= nil and Is_Block == true)then
										T_Block_Power.Value -= Punch_Power
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.fromRGB(170, 85, 255))

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										if(T_Block_Power.Value < 0)then
											local Dif = math.abs(T_Block_Power.Value)
											T_Health.Value = math.clamp(T_Health.Value - Dif, 0, 100)
											T_Block_Power.Value = 0

											SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
											--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)

											Overhead_Display:FireAllClients(Hit_Char, "-" .. Dif, Color3.new(1, 0, 0))

										else
											SE_Mod.PlaySFX(HRP, "Blocked_Hit_SE")	
										end

										return true
									end

									return false
								end

								if(Is_Dodging_Check())then
									--Play Dodging Text
									Overhead_Display:FireAllClients(Hit_Char, "Dodged", Color3.fromRGB(35, 244, 68))
								elseif(Is_Blocking_Check())then
									--Play Blocking 
								else
									--Apply the Hit
									local function Apply_Strike()
										T_Health.Value = math.clamp(T_Health.Value - Punch_Power, 0, 100)
										SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
										--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.new(1, 0, 0))
										--Punch_Hit_VFX:FireClient(Plr, Hit_Char)
										--Play Damage Val Show

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										local T_HRP = Hit_Char:FindFirstChild("HumanoidRootPart")
										if(T_HRP ~= nil)then
											local Hit_Force = 625 -- Was 350 then 500
											local Dir = HRP.CFrame.LookVector 
											T_HRP:ApplyImpulse(Dir * Hit_Force * T_HRP:GetMass())
										end
									end
									Apply_Strike()
								end
							end

						end
					end
				end)

				Combo_Strike_Index += 1
				if(Combo_Strike_Index > #Combo_Anim_Arr)then
					Combo_Strike_Index = 1
				end

				Animation_Mod.Stop_Animation_Tracks(Combo_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Track)
			end
			task.spawn(Play_Strike_Animation)
			
			-- waiting time for the next strike (2 instead of 0.5)
			task.wait(2)

			Debounce_Striking = false
		end

		local Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left']
		local Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		local Back_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		function Funcs.Dodge_Handle(Dodge_Type)
			--[[
				* Get the Type First
					-> First Index? Just play the Slip Animation
					-> 2nd Index? Play the Dodge Animation AND apply Force to the Player in the direction
				
					-> Tell the Server that you are Dodging and should reduce Staminia Value
			]]--

			Debounce_Dodge = true
			-- AI is Dodging

			local function Apply_Force(Dir)
				HRP:ApplyImpulse(Dir * (Fight_Walkspeed * 65) * HRP:GetMass())
			end

			task.spawn(function()
				if(Has_Enough_Stam(5))then
					--Play the Sound Effect
					--Toggle Value
					SE_Mod.PlaySFX(HRP, "Missed_SE")
					Stam_V:SetAttribute("Is_Dodging", true)
					task.wait(0.5)
					Stam_V:SetAttribute("Is_Dodging", false)
				end
			end)
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})

			local function Increment_Anim()
				if(Dodge_Type == "Dodge Left")then
					if(Left_Dodge_Ani == Striking_Anim_Tracks['Slip Left'])then
						Left_Dodge_Ani = Striking_Anim_Tracks['Headblock Left']
					else
						Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left'] 
					end
				else
					--Right
					if(Right_Dodge_Ani == Striking_Anim_Tracks['Slip Right'])then
						Right_Dodge_Ani = Striking_Anim_Tracks['Headblock Right']
					else
						Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right'] 
					end
				end
			end

			if(Dodge_Type == "Dodge Left")then
				--Left
				if(Left_Dodge_Ani == Striking_Anim_Tracks['Headblock Left'])then
					--Apply_Force(HRP.CFrame.RightVector * -1)
				end
				Apply_Force(HRP.CFrame.RightVector * -1)
				Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Right")then
				--Right
				if(Right_Dodge_Ani == Striking_Anim_Tracks['Headblock Right'])then
					--Apply_Force(HRP.CFrame.RightVector)
				end
				Apply_Force(HRP.CFrame.RightVector)
				Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Back")then
				Apply_Force(HRP.CFrame.LookVector * -1)
				Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
			end

			Debounce_Dodge = false
		end

		local function Toggle_Sheild_Icon(Is_Enabled)
			local Main_F =  Fight_UI:FindFirstChild("Main_F")
			if(Main_F ~= nil and Main_F:FindFirstChild("Shield_F") ~= nil)then
				local SF = Main_F:FindFirstChild("Shield_F")
				SF.Visible = true

				local Img = SF:FindFirstChild("Shield_Img")
				if(Img ~= nil)then
					if(Is_Enabled)then
						Img.Image = "rbxassetid://130871917395731"
					else
						Img.Image = "rbxassetid://125284121534949"
					end
				end
			end
		end

		local function Toggle_Heal_PE(Is_Enabled)
			local PE = HRP:GetChildren()
			for i = 1, #PE do
				if(PE[i] ~= nil and PE[i].Name == "Heal_PE" and PE[i]:IsA("ParticleEmitter"))then
					PE[i].Enabled = Is_Enabled
				end
			end

			Toggle_Sheild_Icon(Is_Enabled)
		end

		local Low_Block_Con = nil
		local function Disable_Blocking_Handle()
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed
			end

			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Block_Power_V:SetAttribute("Is_Blocking", false)
			Toggle_Heal_PE(false)

			Debounce_Blocking = false
		end

		local function Play_Blocking_Animation()
			local Anim_Track = Striking_Anim_Tracks['Main Block']
			if(Anim_Track ~= nil)then
				Anim_Track:Play()
				Anim_Track:AdjustSpeed(1)
				task.wait(Anim_Track.Length * 0.9)

				if(Anim_Track ~= nil and Debounce_Blocking == true)then
					Anim_Track:AdjustSpeed(0)
				end
			end
		end

		function Funcs.Disable_Blocking_Handle()
			-- AI is turning off Blocking
			Disable_Blocking_Handle()
		end

		function Funcs.Blocking_Handle()
			Debounce_Blocking = true
			-- AI Is Blocking

			if(Hum ~= nil)then
				Hum.WalkSpeed = 8
			end

			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			Low_Block_Con = Block_Power_V.Changed:Connect(function()
				if(Block_Power_V.Value <= 0 and Debounce_Blocking == true)then
					if(Low_Block_Con ~= nil)then
						Low_Block_Con:Disconnect()
						Low_Block_Con = nil
					end

					Disable_Blocking_Handle()
				end
			end)
			table.insert(self.Cons, Low_Block_Con)
			task.spawn(Play_Blocking_Animation)

			if(Block_Power_V ~= nil and Block_Power_V.Value > 0)then
				Block_Power_V:SetAttribute("Is_Blocking", true)
				Toggle_Heal_PE(true)
			end
		end

		function Funcs.Get_Hitbox_Res()
			return (Get_Player_To_Hit() ~= nil)
		end		

		function Funcs.Get_Dodge_Type()
			local function Get_Ray_Distance_Data()
				local Origin = HRP.Position
				local Ray_Parm = RaycastParams.new()
				Ray_Parm.FilterType = Enum.RaycastFilterType.Exclude
				Ray_Parm.FilterDescendantsInstances = {self.Bot, T_Char}

				local function Get_Ray_Dist(Dir)
					local Ray_Res = game.Workspace:Raycast(Origin, Dir * 10, Ray_Parm)
					if(Ray_Res ~= nil and Ray_Res.Distance ~= nil)then
						return Ray_Res.Distance
					end
					return 15
				end

				return {
					{
						['Type'] = "Dodge Back",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.LookVector * -1)
					},

					{
						['Type'] = "Dodge Left",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector * -1)
					},

					{
						['Type'] = "Dodge Right",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector)
					},

				}
			end
			local Ray_Dist_Arr = Get_Ray_Distance_Data()

			table.sort(Ray_Dist_Arr, function(A, B)
				return A['Distance'] > B['Distance']
			end)

			return Ray_Dist_Arr[1]['Type']
		end

		function Funcs.Is_Player_Striking_You()
			if(T_Strike_Power_V ~= nil and T_Strike_Power_V.Value < Fight_Params_Mod.Punch_Power.Max_Value * 0.5)then
				return true
			end
			return false
		end

		return Funcs
	end
	local Core_Strike_Funcs = Get_Core_Strike_Handles()

	--[[
		Core AI Decision Making goes here
		
		* If within Striking Distance ~ 5 Studs
			* If Player is Striking too, Dodge Left Right or Back (Max 2 Dodges)
			* Has to Strike (Max 3 Strikes)
				* Dodge Back if Strike (or left or Right)
		* Default to Blocking Handle
	]]--

	local function Submission_Handle(Is_Submitting, Attacking_Char)
		Animation_Mod.Reset_Character_Animations(self.Bot)
		if(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end

		if(Is_Submitting)then
			Is_Submission = true
			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end

			if(HRP ~= nil)then
				--HRP.Anchored = true
				--HRP.CFrame *= CFrame.new(Vector3.new(0, 0.15, 0))
				HRP.CFrame = HRP.CFrame * CFrame.new(0, 0.15, 0)
			end

			--> Play Animation
			--> Get Submission Character & Player
			--> Get their Takedown and Submission Data

			--> If Attacking Player, Set HRP CFrame Position
			--> Play Take Down Animation

			--> Play Submission Animation
			--> Play Submission Loop Animation

			local function Get_Takedown_Submission_Tracks()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)
				return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Receiving ID'], Submission_Data['Receiving ID'], Submission_Data['Receiving Loop ID'])
			end
			local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()

			Takedown_Track.Priority = Enum.AnimationPriority.Action2
			Animation_Mod.Play_Animation_Track(Takedown_Track, true)

			task.wait(0.25)

			Submission_Track.Priority = Enum.AnimationPriority.Action3
			Animation_Mod.Play_Animation_Track(Submission_Track)

			Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
		else
			Is_Hit = false

			if(HRP ~= nil)then
				HRP.Anchored = false
			end

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
			Is_Submission = false
		end
	end

	table.insert(self.Cons, AI_Training_Submission.Event:Connect(function(AI_Char, Attacking_Char, Is_Submitting)
		if(AI_Char == self.Bot)then
			Submission_Handle(Is_Submitting, Attacking_Char)
		end
	end))


	local function Clinch_Handle(Animation_Sequence_Data, Is_Attacking)
		local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(self.Bot)

			if(Debounce_Blocking == true)then
				task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
			end

			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
		end
		Freeze_Character()

		local function Play_Strike_Sequences()
			local Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
			Animation_Mod.Play_Animation_Track(Clinch_Tracks_Data['Init_Clinch'], true)
			task.spawn(Animation_Mod.Play_Animation_Track, Clinch_Tracks_Data['Loop_Clinch'])
			task.wait(1)

			for i = 1, #Animation_Sequence_Data do
				local Strike_Key = Animation_Sequence_Data[i]
				local Strike_Track = Clinch_Tracks_Data[Strike_Key]

				if(Strike_Track ~= nil)then
					--Play Flash, Play Hit Sound Effect, Quick Camera Shake
					Animation_Mod.Play_Animation_Track(Strike_Track)
					--wait(0.5)
				end
			end

		end
		Play_Strike_Sequences()

		local function Clinch_Reset_Handle()
			Animation_Mod.Reset_Character_Animations(self.Bot)
			Is_Hit = false

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
		end	
		Clinch_Reset_Handle()
	end

	table.insert(self.Cons, AI_Training_Cage_Clinch.Event:Connect(function(AI_Char, Sequence_Keys, Is_Attacking)
		if(AI_Char == self.Bot)then
			Clinch_Handle(Sequence_Keys, Is_Attacking)
		end
	end))

	local MIN_T_HEALTH = 80
	local Strike_Count, Dodge_Count = 0, 0
	local function Main_AI_Logic_Gate()
		if(Health_V.Value > 0 and Is_Hit == false and T_Health_V ~= nil and T_Health_V.Value > 0)then
			if(Core_Strike_Funcs.Get_Hitbox_Res())then -- Within Strike Zone
				local Is_Player_Hitting_You = Core_Strike_Funcs.Is_Player_Striking_You()
				if(Is_Player_Hitting_You)then
					--Take the HIts until you're below 20 Block Power
					-- Dodge? or Strike
					if(Block_Power_V.Value > 10)then
						if(Dodge_Count < 2 or Strike_Count >= 3)then
							--Dodge
							if(Debounce_Dodge == false and Stam_V.Value >= 5)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								local Dodge_Type = Core_Strike_Funcs.Get_Dodge_Type()
								Core_Strike_Funcs.Dodge_Handle(Dodge_Type)

								Dodge_Count += 1
								if(Strike_Count >= 3)then
									Strike_Count = 0
								end
							end

						else
							--Strike (MODIFIED to only strike 15%)
							if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0 and math.random() < 0.15)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end
								
								if (T_Health_V.Value > MIN_T_HEALTH) then
									Core_Strike_Funcs.Strike_Handle()
									Strike_Count += 1
									if(Dodge_Count >= 2)then
										Dodge_Count = 0
									end
								end
							else
								Core_Strike_Funcs.Blocking_Handle()
							end
						end
					elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
						--Not within Strike Zone, resort to Blocking
						Core_Strike_Funcs.Blocking_Handle()
					end
				else
					--Strike (MODIFIED to reduce strike to 30%)
					if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0 and math.random() < 0.3)then
						if(Debounce_Blocking == true)then
							task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
						end

						if (T_Health_V.Value > MIN_T_HEALTH) then
							Core_Strike_Funcs.Strike_Handle()
							Strike_Count += 1
							if(Dodge_Count >= 2)then
								Dodge_Count = 0
							end
						end
					else 
						Core_Strike_Funcs.Blocking_Handle()
					end
				end
			elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
				--Not within Strike Zone, resort to Blocking
				Core_Strike_Funcs.Blocking_Handle()
			end

		elseif(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end
	end

	while Is_Active do
		if(Is_Submission == false)then
			Main_AI_Logic_Gate()
		end
		task.wait(0.5)
	end
end

return COACH_Behavior]]></ProtectedString>
							<string name="ScriptGuid">{BE1E7050-0FF7-4497-8278-128E850632E0}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">COACH.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXA6DFE6951BC54F2891B1503C056EA622">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Debug</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX5689BEB9CFDF499C8168565154966F11">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--[[ 📘 CHANNEL SIGNATURE INSPECTOR v3
===========================================================
📍 Module path:
local CSI = require(game.ReplicatedStorage.Debug.ChannelSignatureInspector)
CSI.scan()
===========================================================
Features:
✅ Ignores commented lines
✅ Merges all Channel sections (no duplicate confusion)
✅ Context-aware (client/server)
✅ Recognizes .OnClientEvent / .OnServerEvent / .Event:Connect
✅ Clean grouped output: ❌ invalid → ⚠ warning → ✅ ok
--]]

local ChannelSignatureInspector = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local StarterPlayer = game:GetService("StarterPlayer")
local StarterGui = game:GetService("StarterGui")
local StarterPack = game:GetService("StarterPack")

local Channels = require(ReplicatedStorage.Modules.Channels)

-------------------------------------------------------
-- CHANNEL SECTIONS
-------------------------------------------------------
local CHANNEL_SECTIONS = {
	"Bindable_Events",
	"Bindable_Functions",
	"CS_Remote_Functions",
	"CS_Remote_Events",
	"SC_Remote_Events",
}

-------------------------------------------------------
-- SCAN TARGETS
-------------------------------------------------------
local SCAN_CONTAINERS = {
	ServerScriptService,
	ReplicatedStorage,
	Workspace,
	StarterPlayer:FindFirstChild("StarterPlayerScripts"),
	StarterPlayer:FindFirstChild("StarterCharacterScripts"),
	StarterGui,
	StarterPack,
}

-------------------------------------------------------
-- HELPERS
-------------------------------------------------------
local function fullPath(inst)
	local parts = {}
	while inst do
		table.insert(parts, 1, inst.Name or "?")
		inst = inst.Parent
	end
	return table.concat(parts, "/")
end

local function isSource(inst)
	return inst:IsA("ModuleScript") or inst:IsA("Script") or inst:IsA("LocalScript")
end

local function getSource(src)
	local ok, code = pcall(function() return src.Source end)
	return ok and code or ""
end

local function isClientScript(src)
	return src:IsA("LocalScript")
		or (src.Parent and src.Parent:IsDescendantOf(StarterPlayer))
		or (src.Parent and src.Parent:IsDescendantOf(StarterGui))
		or (src.Parent and src.Parent:IsDescendantOf(StarterPack))
end

local function getTypeString(obj)
	if typeof(obj) ~= "Instance" then return nil end
	if obj:IsA("BindableEvent") then return "BindableEvent" end
	if obj:IsA("BindableFunction") then return "BindableFunction" end
	if obj:IsA("RemoteEvent") then return "RemoteEvent" end
	if obj:IsA("RemoteFunction") then return "RemoteFunction" end
	return nil
end

-------------------------------------------------------
-- EXPECTED SIGNATURES
-------------------------------------------------------
local EXPECTED = {
	BindableEvent = {
		client = { allowed = { "Fire" }, alsoValid = { "Event" } },
		server = { allowed = { "Fire" }, alsoValid = { "Event" } },
	},
	BindableFunction = {
		client = { allowed = { "OnInvoke" } },
		server = { allowed = { "OnInvoke" } },
	},
	RemoteEvent = {
		client = { allowed = { "FireServer", "OnClientEvent" }, alsoValid = { "Event" } },
		server = { allowed = { "FireClient", "FireAllClients", "OnServerEvent" } },
	},
	RemoteFunction = {
		client = { allowed = { "InvokeServer" } },
		server = { allowed = { "OnServerInvoke" } },
	},
}

-------------------------------------------------------
-- MAIN FUNCTION
-------------------------------------------------------
function ChannelSignatureInspector.scan()
	print("== Channel Signature Inspector v3 started ==")

	local invalids, warnings, oks = {}, {}, {}
	local total = 0

	-- 🔄 Merge all Channels.* into a single unique map
	local allChannels = {}
	for _, sectionName in ipairs(CHANNEL_SECTIONS) do
		local section = Channels[sectionName]
		if type(section) == "table" then
			for name, obj in pairs(section) do
				if typeof(obj) == "Instance" and not allChannels[name] then
					allChannels[name] = obj
				end
			end
		end
	end

	-- 🧩 Gather all Lua sources
	local sources = {}
	for _, container in ipairs(SCAN_CONTAINERS) do
		if container then
			for _, d in ipairs(container:GetDescendants()) do
				if isSource(d) then
					table.insert(sources, d)
				end
			end
		end
	end

	-- 🔍 Analyze usage
	for name, obj in pairs(allChannels) do
		local t = getTypeString(obj)
		if not t then continue end
		total += 1

		local patternName = name:gsub("([^%w_])", "%%%1")
		local foundCorrect, foundInvalid = false, false

		for _, src in ipairs(sources) do
			local code = getSource(src)
			if code == "" then continue end
			local lines = string.split(code, "\n")
			local path = fullPath(src)
			local ctx = isClientScript(src) and "client" or "server"

			local expected = EXPECTED[t]
			local ctxExp = expected and expected[ctx]
			if not ctxExp then continue end

			for lineNum, line in ipairs(lines) do
				local trimmed = line:match("^%s*(.-)%s*$")
				-- 🚫 skip comment lines
				if trimmed:find("^%-%-") or trimmed:find("^%[%[%s*%-%-") then
					continue
				end

				local call = trimmed:match(patternName .. "%s*[:%.]%s*([%w_]+)")
				if call then
					local ok = false
					if table.find(ctxExp.allowed, call) or table.find(ctxExp.alsoValid or {}, call) then
						ok = true
					end

					if ok then
						foundCorrect = true
						table.insert(oks, {
							obj = name, objType = t, ctx = ctx,
							call = call, path = path, line = lineNum,
						})
					else
						foundInvalid = true
						table.insert(invalids, {
							obj = name, objType = t, ctx = ctx,
							found = call, path = path, line = lineNum,
							expected = table.concat(ctxExp.allowed, " / "),
						})
					end
				end
			end
		end

		if not foundCorrect and not foundInvalid then
			table.insert(warnings, {
				obj = name,
				objType = t,
				path = fullPath(obj),
				expected = table.concat(EXPECTED[t]["client"].allowed, " / "),
			})
		end
	end

	-------------------------------------------------------
	-- 📊 REPORT OUTPUT
	-------------------------------------------------------
	print("\n== Channel Signature Inspector Report ==")

	-- ❌ INVALIDS
	if #invalids > 0 then
		print("\n❌ INVALID USAGES:")
		table.sort(invalids, function(a,b) return a.obj < b.obj end)
		for _, e in ipairs(invalids) do
			print(("[%s][%s] %s → invalid call '%s' (expected %s) in %s : line %d")
				:format(e.objType, e.ctx, e.obj, e.found, e.expected, e.path, e.line))
		end
	else
		print("\n❌ INVALID USAGES: none ✅")
	end

	-- ⚠ WARNINGS
	if #warnings > 0 then
		print("\n⚠ WARNINGS (never used):")
		table.sort(warnings, function(a,b) return a.obj < b.obj end)
		for _, w in ipairs(warnings) do
			print(("[%s] %s expected usage: %s (defined at %s)")
				:format(w.objType, w.obj, w.expected, w.path))
		end
	else
		print("\n⚠ WARNINGS: none ✅")
	end

	-- ✅ OKS
	if #oks > 0 then
		print("\n✅ VALID USAGES:")
		table.sort(oks, function(a,b)
			return a.obj == b.obj and a.path < b.path or a.obj < b.obj
		end)
		for _, o in ipairs(oks) do
			print(("[%s][%s] %s used correctly (%s) in %s : line %d")
				:format(o.objType, o.ctx, o.obj, o.call, o.path, o.line))
		end
	else
		print("\n✅ VALID USAGES: none found")
	end

	print(("\n== Scan finished (%d items checked) =="):format(total))
end

return ChannelSignatureInspector
]]></ProtectedString>
						<string name="ScriptGuid">{7CEE4972-C155-403A-8E90-8E832BAF110D}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ChannelSignatureInspector.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4A2895D01CEC4F25B6147059067F311B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--[[ 📘 REMOTE FUNCTION INSPECTOR COMMANDS (Studio Console)
===========================================================
🔹 MODULE PATH:
local Inspector = require(game.ReplicatedStorage.Debug.RemoteFunctionInspector)
Inspector.scan()
===========================================================
Description:
Scans all RemoteFunctions under Channels.CS_Remote_Functions
and finds where they are invoked in client scripts or shared
modules (ReplicatedStorage, StarterGui, StarterPack, etc).

Supports:
  ✅ Direct calls (MyRemote:InvokeServer())
  ✅ Aliases (local rf = Channels.CS_Remote_Functions.MyRemote)
  ✅ Deduplicated logging
  ✅ "No callers found" summary at the end
--]]

local RemoteFunctionInspector = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterPlayer = game:GetService("StarterPlayer")
local StarterGui = game:GetService("StarterGui")
local StarterPack = game:GetService("StarterPack")

local Channels = require(ReplicatedStorage.Modules.Channels)
local CS_Remote_Functions = Channels.CS_Remote_Functions

local SCAN_CONTAINERS = {
	ReplicatedStorage,
	StarterPlayer:FindFirstChild("StarterPlayerScripts"),
	StarterGui,
	StarterPack,
}

-- Helpers
local function fullPath(inst)
	local parts = {}
	while inst do
		table.insert(parts, 1, inst.Name or "<nil>")
		inst = inst.Parent
	end
	return table.concat(parts, "/")
end

local function isSourceContainer(inst)
	return inst:IsA("ModuleScript") or inst:IsA("LocalScript") or inst:IsA("Script")
end

local function getSource(src)
	local ok, code = pcall(function() return src.Source end)
	return ok and code or nil
end

local function getSourceLines(src)
	local code = getSource(src)
	if not code then return {} end
	local lines = {}
	for line in code:gmatch("([^\n]*)\n?") do
		table.insert(lines, line)
	end
	return lines
end

local function buildPatterns(remoteName)
	local escaped = remoteName:gsub("([^%w_])", "%%%1")
	local pattDirect = "%f[%w_]" .. escaped .. "%f[%W]%s*:%s*InvokeServer%s*%("
	local pattFull = "Channels%s*%.%s*CS_Remote_Functions%s*%.%s*" .. escaped .. "%s*:%s*InvokeServer%s*%("
	return pattDirect, pattFull
end

local function findAliases(srcText, remoteName)
	local pattern = "local%s+([%w_]+)%s*=%s*Channels%s*%.%s*CS_Remote_Functions%s*%.%s*" .. remoteName
	local aliases = {}
	for alias in srcText:gmatch(pattern) do
		table.insert(aliases, alias)
	end
	return aliases
end

-- =========================
-- 🔍 MAIN SCAN FUNCTION
-- =========================
function RemoteFunctionInspector.scan()
	if type(CS_Remote_Functions) ~= "table" then
		warn("[RemoteFunctionInspector] Channels.CS_Remote_Functions is not a table or nil.")
		return
	end

	print("== RemoteFunction caller analysis started ==")

	-- Collect scripts/modules once
	local sources = {}
	for _, container in ipairs(SCAN_CONTAINERS) do
		if container then
			for _, desc in ipairs(container:GetDescendants()) do
				if isSourceContainer(desc) then
					table.insert(sources, desc)
				end
			end
		end
	end

	local noCallers = {}

	for remoteName, remote in pairs(CS_Remote_Functions) do
		if typeof(remote) == "Instance" and remote:IsA("RemoteFunction") then
			local pattDirect, pattFull = buildPatterns(remoteName)
			local found = false
			local loggedFiles = {} -- avoid duplicate logging per script
			local fullRemotePath = fullPath(remote)

			for _, src in ipairs(sources) do
				local code = getSource(src)
				if not code then continue end

				local lines = getSourceLines(src)
				local filePath = fullPath(src)

				-- direct calls
				for i, line in ipairs(lines) do
					if line:find(pattDirect) or line:find(pattFull) then
						if not found then
							print(("--- RemoteFunction: %s  (path: %s)"):format(remoteName, fullRemotePath))
							print("  callers:")
							found = true
						end
						if not loggedFiles[filePath] then
							print(("    - %s : line %d (direct match)"):format(filePath, i))
							loggedFiles[filePath] = true
						end
					end
				end

				-- alias detection
				local aliases = findAliases(code, remoteName)
				for _, alias in ipairs(aliases) do
					-- avoid redundant alias logging if alias == remoteName
					if alias ~= remoteName then
						local aliasPattern = alias .. "%s*:%s*InvokeServer%s*%("
						for i, line in ipairs(lines) do
							if line:find(aliasPattern) then
								if not found then
									print(("--- RemoteFunction: %s  (path: %s)"):format(remoteName, fullRemotePath))
									print("  callers:")
									found = true
								end
								if not loggedFiles[filePath] then
									print(("    - %s : line %d (alias '%s')"):format(filePath, i, alias))
									loggedFiles[filePath] = true
								end
							end
						end
					end
				end
			end

			if not found then
				table.insert(noCallers, remoteName)
			end
		end
	end

	-- Print summary for remotes without callers
	if #noCallers > 0 then
		print("\n== No callers found for these RemoteFunctions ==")
		table.sort(noCallers)
		for _, name in ipairs(noCallers) do
			print("  - " .. name)
		end
	end

	print("\n== RemoteFunction caller analysis finished ==")
end

return RemoteFunctionInspector
]]></ProtectedString>
						<string name="ScriptGuid">{34AFC778-703F-4394-B814-452046225F09}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">RemoteFunctionInspector.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXE4F29801FDA74F1A87F1476F68923F16">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Design</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX43453E05447F449DBDDBB7E5F0793363">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- 🔒 LockManager.lua
-- Gestion centralisée du verrouillage / déverrouillage des objets d'un Workspace
-- Auteur : toi 😎
-- Compatible avec dossiers tagués ("Locked") ou avec attribut Locked = true

--[[
local LockManager = require(game.ReplicatedStorage.Design.LockManager)
LockManager.lock(workspace.Main_World_F)

local LockManager = require(game.ReplicatedStorage.Design.LockManager)
LockManager.unlock(workspace.Main_World_F)
]]

local CollectionService = game:GetService("CollectionService")

local LockManager = {}

---------------------------------------------------------------------
-- 🔍 UTILITAIRES
---------------------------------------------------------------------

-- Renvoie le chemin complet d'un objet
local function getFullNameSafe(obj)
	local success, result = pcall(function() return obj:GetFullName() end)
	return success and result or "(unknown)"
end

-- Verrouille / déverrouille tous les BasePart descendants d’un dossier donné
local function setLockState(folder, state)
	for _, descendant in ipairs(folder:GetDescendants()) do
		if descendant:IsA("BasePart") then
			descendant.Locked = state
		end
	end
end

-- Vérifie si un dossier est marqué Locked (via tag ou attribut)
local function isLockedFolder(folder)
	if CollectionService:HasTag(folder, "Locked") then
		return true
	end
	if folder:GetAttribute("Locked") == true then
		return true
	end
	return false
end

---------------------------------------------------------------------
-- 🔒 LOCK
---------------------------------------------------------------------

function LockManager.lock(root)
	if not root then
		warn("⚠️ No root element provided to LockManager.lock()")
		return
	end

	local lockedFolders = {}
	for _, descendant in ipairs(root:GetDescendants()) do
		if descendant:IsA("Folder") and isLockedFolder(descendant) then
			table.insert(lockedFolders, descendant)
		end
	end

	for _, folder in ipairs(lockedFolders) do
		setLockState(folder, true)
		print("🔒 Locked :", getFullNameSafe(folder))
	end

	print("✅ LockManager : " .. tostring(#lockedFolders) .. " folder(s) locked.")
end

---------------------------------------------------------------------
-- 🔓 UNLOCK
---------------------------------------------------------------------

function LockManager.unlock(root)
	if not root then
		warn("⚠️ No root element provided to LockManager.unlock()")
		return
	end

	local unlockedFolders = {}
	for _, descendant in ipairs(root:GetDescendants()) do
		if descendant:IsA("Folder") and isLockedFolder(descendant) then
			table.insert(unlockedFolders, descendant)
		end
	end

	for _, folder in ipairs(unlockedFolders) do
		setLockState(folder, false)
		print("🔓 Unlocked :", getFullNameSafe(folder))
	end

	print("✅ LockManager : " .. tostring(#unlockedFolders) .. "  folder(s) unlocked.")
end

---------------------------------------------------------------------
-- ✅ EXPORT
---------------------------------------------------------------------
return LockManager
]]></ProtectedString>
						<string name="ScriptGuid">{39E9322B-D0A3-4AFE-8207-AF234E827303}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">LockManager.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBA4C6635D7D64DF4AD6E55909D7530EC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Design/MenuButtons.lua
--
--  Description:
--      Utility module providing standardized interactive button behaviors
--      for UI elements:
--          • Hover animations
--          • Click animations
--          • Color transitions
--          • Tab activation logic
--          • Custom callbacks
--
--      Designed to give consistent UX across all menus and panels.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-02-10 by Darkzeb
--
--  Version: V2025-02
--
--  Dependencies:
--      - Roblox Services:
--          * TweenService
--
--      - Modules:
--          * Sound_Mod (UI sound effects)
--          * ThemeManager (UI theme colors)
--
--  Used By:
--      - All UI screens using interactive buttons
--      - Menus with tabs, exit buttons, and stylized hover/click effects
--
--  Notes:
--      - Setup_Button is the core helper used by all exposed functions.
--      - Tween scaling uses configurable ratios for click & hover.
--      - Supports arbitrary button shapes and independently scaled axes.
--      - Debounce system prevents spam interactions.
--
--======================================================================


local MenuButtons = {}

----- DEPENDENCIES -----
--// Services
local TS = game:GetService("TweenService")
--// Required Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local ThemeManager = require(game.ReplicatedStorage:WaitForChild("Design"):WaitForChild("ThemeManager"))

----- REFERENCES -----
--// Player and Character
local Plr = game.Players.LocalPlayer

----- VARIABLES -----
local Tween_Length = 0.125
local Debounce_length = 0.25
local Click_Size_Ratio = 0.9
local Over_Size_Ratio = 1.1
local Over_Bg_Color = ThemeManager.getColor("menus", "CallToAction_Over_Color")
local Reverse_Tween = TweenInfo.new(Tween_Length, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

local function Get_Scale_Size(Normal, Ratio, X_Scale, Y_Scale)
	local X_Scaled_Size = X_Scale and Normal.X.Scale * Ratio or Normal.X.Scale
	local Y_Scaled_Size = Y_Scale and Normal.Y.Scale * Ratio or Normal.Y.Scale
	return UDim2.new(X_Scaled_Size, 0, Y_Scaled_Size, 0)	
end


local function Setup_Button(Cons, B, Selected, X_Scale, Y_Scale, Over_Color, Exit_Callback)	
	local Normal_Size = B.Size
	local Normal_Bg_Color = B.BackgroundColor3
	
	local Over_Size = Get_Scale_Size(Normal_Size, Over_Size_Ratio, X_Scale, Y_Scale) 
	local Click_Size = Get_Scale_Size(Normal_Size, Click_Size_Ratio, X_Scale, Y_Scale) 
	local Debounce_E = false
	local Debounce = false

	table.insert(Cons, Selected.MouseEnter:Connect(function()
		if(Debounce_E == false)then
			Debounce_E = true
			SE_Mod.PlaySFX(Plr, "Hover_SE")
			B:TweenSize(Over_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, Tween_Length, true, nil)
			B.BackgroundColor3 = Over_Color ~=nil and Over_Color or Over_Bg_Color
			Debounce_E = false
		end
	end))
	
	
	table.insert(Cons, Selected.MouseLeave:Connect(function()
		B:TweenSize(Normal_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, Tween_Length, true, nil)
		B.BackgroundColor3 = Normal_Bg_Color
	end))
	
	
	table.insert(Cons, Selected.MouseButton1Click:Connect(function()
		if(Debounce == false)then
			Debounce = true
			SE_Mod.PlaySFX(Plr, "Click_SE")
			TS:Create(B, Reverse_Tween, {Size = Click_Size}):Play()
			
			Exit_Callback()
			
			task.wait(Debounce_length)
			Debounce = false
			B.Size = Normal_Size
		end
	end))
end

local function Activate_Tab(Tab_B_Name, Tabs_Container_F, Tabs_Data, Before_Show_Function)
	
	if Before_Show_Function ~= nil then Before_Show_Function() end
	
	for Tab_Name, Tab_Data in pairs(Tabs_Data) do 
		local Tab_Panel_F = Tab_Data["Frame"]
		local Tab_Show_Function = Tab_Data["Show_Function"]
		local Tab_B = Tabs_Container_F:FindFirstChild(Tab_Name)
		
		if Tab_Name == Tab_B_Name then
			Tab_B.BackgroundTransparency = 0
			Tab_Panel_F.Visible = true
			if Tab_Show_Function ~= nil then Tab_Show_Function() end
		else
			Tab_B.BackgroundTransparency = 1
			Tab_Panel_F.Visible = false
		end	
	end
end

function MenuButtons.Setup_Exit_X_Button(Cons, B, Exit_Callback)
	Setup_Button(Cons, B, B, false, true, nil, Exit_Callback)
end

function MenuButtons.Activate_Tab(Tab_B_Name, Tabs_Container_F, Tabs_Data, Before_Show_Function)
	Activate_Tab(Tab_B_Name, Tabs_Container_F, Tabs_Data, Before_Show_Function)
end

function MenuButtons.Setup_Tab_Button(Cons, Tab_B, Tabs_Container_F, Tabs_Data, Before_Show_Function)
	Setup_Button(Cons, Tab_B, Tab_B, true, true, nil, function()
		MenuButtons.Activate_Tab(Tab_B.Name, Tabs_Container_F, Tabs_Data, Before_Show_Function)
	end)
end

function MenuButtons.Setup_Colored_Button(Cons, B, Over_Color, Callback, Selected)
	if Selected == nil then Selected = B end
	Setup_Button(Cons, B, Selected, true, true, Over_Color, Callback)
end

-- Selected is optional if Button container and Buttton sleection frame are different
function MenuButtons.Setup_Base_Button(Cons, B, Callback, Selected)
	if Selected == nil then Selected = B end
	Setup_Button(Cons, B, Selected, true, true, nil, Callback)
end

return MenuButtons
]]></ProtectedString>
						<string name="ScriptGuid">{D3DEABF7-B4F4-467D-B896-C55839D011A6}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">MenuButtons.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7A004C8DB7C141839226F9BDEBF888BC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local Fight_Params_Mod			= require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)

local ICONS = {
	WIN   = " 🟢 ",
	LOSS  = " 🔴 ",
	EMPTY = " ⚫ "
}

local function Get_Max_Rounds(Needed_Wins)
	return (Needed_Wins - 1) * 2 + 1
end


local function Get_Needed_Wins(Cage_Type)
	return (Cage_Type == "STANDARD" and Fight_Params_Mod.Needed_Winning_Rounds.STANDARD)
		or (Cage_Type == "RANKED" and Fight_Params_Mod.Needed_Winning_Rounds.RANKED) 
		or 0
end

local ScoreDisplay = {
	Get_Wins_Labels = function(Round_Wins, Name_L,Name_R, Cage_Type)
		local wins_L, wins_R = 0, 0
		local score_L, score_R = "", ""
		local Needed_Wins = Get_Needed_Wins(Cage_Type)
		local Max_Rounds = Get_Max_Rounds(Needed_Wins)

		local Round_Winners = string.split(Round_Wins, ",")
		
		for i = 1, Max_Rounds do
			local winner = Round_Winners[i] or ""
			if(winner == Name_R)then
				wins_R +=1
				score_R = ICONS.WIN..score_R
				score_L = score_L..ICONS.LOSS
			elseif(winner == Name_L)then
				wins_L +=1
				score_R = ICONS.LOSS..score_R
				score_L = score_L..ICONS.WIN
			else
				score_R = ICONS.EMPTY..score_R
				score_L = score_L..ICONS.EMPTY
			end	
		end

		local score_label = Max_Rounds > 0 and wins_L.." VS "..wins_R  or ""

		return score_L, score_R, score_label
	end,
}

return ScoreDisplay
]]></ProtectedString>
						<string name="ScriptGuid">{5660A866-1994-4261-8990-5FBEA50E4B27}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ScoreDisplay.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX80D4069446DE49638FE87494D6E629FE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--[[ 🎨 THEME MANAGER COMMANDS (Studio Console)
======================================================
📦 MODULE PATH
local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)
ThemeManager.applyTheme("Standard")

------------------------------------------------------
Apply existing theme (Studio)
------------------------------------------------------
-- Standard
local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)
ThemeManager.applyTheme("Standard")

-- Halloween
local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)
ThemeManager.applyTheme("Halloween")

-- Tournament
local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)
ThemeManager.applyTheme("Tournament")

]]


local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local CommonTheme = require(game.ReplicatedStorage.Design.Themes.CommonTheme)
local ThemesRoot = script.Parent:WaitForChild("Themes")

local ThemeManager = {}
local LoadedThemes = {}
local currentThemeName = "Standard"

---------------------------------------------------------
-- Internal helper
---------------------------------------------------------
local function getTheme(name)
	return LoadedThemes[name]
end

local function getCurrentThemeTable()
	if not currentThemeName then return nil end
	local theme = LoadedThemes[currentThemeName]
	if not theme then return nil end
	return theme.config
end

---------------------------------------------------------
-- Semantic API (recommended)
---------------------------------------------------------
function ThemeManager.getValue(section, key)
	local theme = getCurrentThemeTable()
	if not theme then return nil end

	local block = theme[section]
	if type(block) ~= "table" then return nil end

	return block[key]
end

function ThemeManager.getColor(section, key, fallback)
	local v = ThemeManager.getValue(section, key)
	if type(v) == "string" then
		return CommonTheme.hexToColor3(v)
	end
	return fallback
end

---------------------------------------------------------
-- Generic table-path API (optional)
-- For cases like: "cages.UIGradient.Colors"
---------------------------------------------------------
function ThemeManager.getPath(path)
	local theme = getCurrentThemeTable()
	if not theme then return nil end
	if not path or path == "" then return theme end

	local current = theme
	for key in string.gmatch(path, "[^%.]+") do
		if type(current) ~= "table" then
			return nil
		end
		current = current[key]
	end

	return current
end

---------------------------------------------------------
-- Load themes (auto-discovery)
---------------------------------------------------------
for _, child in ipairs(ThemesRoot:GetChildren()) do
	if child:IsA("Folder") then
		local entry = child:FindFirstChild("Theme")
		if entry and entry:IsA("ModuleScript") then
			LoadedThemes[child.Name] = require(entry)
		end
	end
end

-- After loading all themes
if not currentThemeName then
	if LoadedThemes.Standard then
		currentThemeName = "Standard"
	else
		-- Pick first available theme as fallback
		for name in pairs(LoadedThemes) do
			currentThemeName = name
			break
		end
	end
end

function ThemeManager.applyTheme(themeName, options)
	local theme = LoadedThemes[themeName]
	assert(theme, "Unknown theme: " .. tostring(themeName))

	if theme.applyTheme then
		theme.applyTheme(options)
	else
		warn("[ThemeManager] Theme has no applyTheme():", themeName)
	end

	currentThemeName = themeName
end

---------------------------------------------------------
-- API
---------------------------------------------------------
function ThemeManager.getCurrentTheme()
	return currentThemeName
end

return ThemeManager
]]></ProtectedString>
						<string name="ScriptGuid">{F2EB3340-9574-4F33-866A-1728F8B375B3}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ThemeManager.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX474D2B58577F45A0979134D48B7AE0F9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Themes</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX127CA9B34AFA4D2FA0A14890F7C85EC3">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Design/Themes/CommonTheme.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Modules 			= ReplicatedStorage:WaitForChild("Modules")
local Utils 			= require(Modules:WaitForChild("Utils"))

local CommonTheme 		= {}

---------------------------------------------------------
-- World resolvers (stream-safe)
---------------------------------------------------------
local function getMainWorld()
	return workspace:WaitForChild("Main_World_F")
end

local function getThemesFolder()
	return getMainWorld():WaitForChild("Themes")
end

local function getEnvironment()
	return getMainWorld():WaitForChild("Environment")
end

local function getGameplay()
	return getMainWorld():WaitForChild("Gameplay")
end

local function getArt()
	return getEnvironment():WaitForChild("Art")
end

local function getSpawns()
	return getEnvironment():WaitForChild("Spawns")
end

local function getFightCages()
	return getGameplay()
		:WaitForChild("Objects")
		:WaitForChild("Fight_Cages_F")
end

---------------------------------------------------------
-- Color helpers
---------------------------------------------------------
function CommonTheme.rgbToHex(color3)
	local r = math.floor(color3.R * 255)
	local g = math.floor(color3.G * 255)
	local b = math.floor(color3.B * 255)
	return string.format("#%02X%02X%02X", r, g, b)
end

function CommonTheme.hexToColor3(hex)
	hex = hex:gsub("#", "")
	local r = tonumber(hex:sub(1, 2), 16)
	local g = tonumber(hex:sub(3, 4), 16)
	local b = tonumber(hex:sub(5, 6), 16)
	return Color3.fromRGB(r, g, b)
end

function CommonTheme.colorSequenceToTable(sequence)
	local t = {}
	for _, keypoint in ipairs(sequence.Keypoints) do
		table.insert(t, {
			Time = keypoint.Time,
			Color = CommonTheme.rgbToHex(keypoint.Value)
		})
	end
	return t
end

function CommonTheme.tableToColorSequence(tbl)
	local keypoints = {}
	for _, v in ipairs(tbl) do
		table.insert(
			keypoints,
			ColorSequenceKeypoint.new(v.Time, CommonTheme.hexToColor3(v.Color))
		)
	end
	return ColorSequence.new(keypoints)
end

---------------------------------------------------------
-- Parking helpers
---------------------------------------------------------
function CommonTheme.getParking()
	local ServerStorage = game:GetService("ServerStorage")
	local folder = ServerStorage:FindFirstChild("_ThemeParking")
	if not folder then
		folder = Instance.new("Folder")
		folder.Name = "_ThemeParking"
		folder.Parent = ServerStorage
	end
	return folder
end

function CommonTheme.detachByTags(tags)
	local CollectionService = game:GetService("CollectionService")
	local parking = CommonTheme.getParking()

	for _, tag in ipairs(tags) do
		local tagged = CollectionService:GetTagged(tag)
		if #tagged == 0 then
			continue
		end

		local tagFolder = parking:FindFirstChild(tag)
		if not tagFolder then
			tagFolder = Instance.new("Folder")
			tagFolder.Name = tag
			tagFolder.Parent = parking
		end

		for _, obj in ipairs(tagged) do
			if not obj:FindFirstChild("__OrigParent") then
				local v = Instance.new("ObjectValue")
				v.Name = "__OrigParent"
				v.Value = obj.Parent
				v.Parent = obj
			end
			obj.Parent = tagFolder
		end
	end
end

function CommonTheme.restoreDetached()
	local ServerStorage = game:GetService("ServerStorage")
	local parking = ServerStorage:FindFirstChild("_ThemeParking")
	if not parking then return end

	for _, tagFolder in ipairs(parking:GetChildren()) do
		for _, obj in ipairs(tagFolder:GetChildren()) do
			local marker = obj:FindFirstChild("__OrigParent")
			if marker and marker.Value then
				obj.Parent = marker.Value
				marker:Destroy()
			end
		end

		if #tagFolder:GetChildren() == 0 then
			tagFolder:Destroy()
		end
	end

	if #parking:GetChildren() == 0 then
		parking:Destroy()
	end
end

---------------------------------------------------------
-- Workspace helpers
---------------------------------------------------------
function CommonTheme.getFightCagesFolder()
	return getFightCages()
end

function CommonTheme.findUIGradient(fighter)
	local mainP = fighter:FindFirstChild("Main_P")
	if not mainP then return nil end

	local playerDisplay = mainP:FindFirstChild("Player_Display_UI")
	if not playerDisplay then return nil end

	local emptyTxt = playerDisplay:FindFirstChild("Empty_Txt", true)
	if not emptyTxt then return nil end

	return emptyTxt:FindFirstChildOfClass("UIGradient")
end

---------------------------------------------------------
-- Material helpers
---------------------------------------------------------
function CommonTheme.getFirstChildMaterial(folder)
	local child = folder:GetChildren()[1]
	if not child then return nil end

	return {
		BaseMaterial = child.Material.Name,
		MaterialVariant = child.MaterialVariant,
		Color = CommonTheme.rgbToHex(child.Color)
	}
end

function CommonTheme.applyMaterialToChildren(folder, mat)
	for _, obj in ipairs(folder:GetChildren()) do
		obj.Material = Enum.Material[mat.BaseMaterial]
		obj.MaterialVariant = mat.MaterialVariant
		obj.Color = CommonTheme.hexToColor3(mat.Color)
	end
end

---------------------------------------------------------
-- Theme actions
---------------------------------------------------------
function CommonTheme.reset()
	CommonTheme.restoreDetached()

	local themesFolder = getThemesFolder()
	if not themesFolder then return end

	for _, folder in ipairs(themesFolder:GetChildren()) do
		if folder:IsA("Folder") then
			folder:Destroy()
		end
	end
end

function CommonTheme.applySpawn(spawnConfig)
	local spawns = getSpawns()
	local main_spawn = spawns:WaitForChild("SpawnLocation")
	if main_spawn then
		local SpawnPosition = spawnConfig.Position
		main_spawn.CFrame = CFrame.new(SpawnPosition.X, SpawnPosition.Y, SpawnPosition.Z,-1, 0, 0, 0, 1, 0, 0, 0, -1) 
	end
end

function CommonTheme.applyCages(cageConfig)
	local FightCagesFolder = getFightCages()
	if not FightCagesFolder then return end

	for _, cage in ipairs(FightCagesFolder:GetChildren()) do
		if cage:GetAttribute("Cage_Type") ~= "RANKED" then
			local mmaCage = cage:FindFirstChild("MMA_Cage")
			if not mmaCage then continue end

			for partName, settings in pairs(cageConfig) do
				local part = mmaCage:FindFirstChild(partName, true)
				if part and part:IsA("BasePart") then
					if settings.Color then
						part.Color = CommonTheme.hexToColor3(settings.Color)
					end
					if settings.TextureId then
						local surface = part:FindFirstChildOfClass("Texture") or Instance.new("Texture")
						surface.Texture = settings.TextureId
						surface.Parent = part
					end
				end
			end

			if cageConfig.LogoDecalId then
				local logo = mmaCage:FindFirstChild("Logo")
				if logo then
					local decal = logo:FindFirstChildOfClass("Decal")
					if decal then
						decal.Texture = cageConfig.LogoDecalId
					end
				end
			end
		end
	end

	if cageConfig.UIGradient and cageConfig.UIGradient.Colors then
		local colorSeq = CommonTheme.tableToColorSequence(cageConfig.UIGradient.Colors)
		for _, handle in ipairs(FightCagesFolder:GetChildren()) do
			if handle:IsA("Model") and string.match(handle.Name, "^Fight_Cage_%d+$") then
				for _, fighterName in ipairs({ "Fighter_1", "Fighter_2" }) do
					local fighter = handle:FindFirstChild(fighterName)
					if fighter then
						local gradient = CommonTheme.findUIGradient(fighter)
						if gradient then
							gradient.Color = colorSeq
						end
					end
				end
			end
		end
	end
end

function CommonTheme.applyLights(lightsConfig)
	if not lightsConfig then return end

	if lightsConfig.Neon_LED_Roof_Color or lightsConfig.Neon_LED_Roof_Beam_Color then
		for _, obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("BasePart") and obj.Name:match("^Neon") then
				if lightsConfig.Neon_LED_Roof_Color then
					obj.Color = CommonTheme.hexToColor3(lightsConfig.Neon_LED_Roof_Color)
				end
				local beam = obj:FindFirstChildOfClass("Beam")
				if beam and lightsConfig.Neon_LED_Roof_Beam_Color then
					local col = CommonTheme.hexToColor3(lightsConfig.Neon_LED_Roof_Beam_Color)
					beam.Color = ColorSequence.new(col)
				end
			end
		end
	end

	if lightsConfig.BaseFloor_LED_Color then
		local baseColor = CommonTheme.hexToColor3(lightsConfig.BaseFloor_LED_Color)
		local trimsFolder = getArt()
			:WaitForChild("Lights")
			:FindFirstChild("CageFloorTrims")

		if trimsFolder then
			for _, cageTrim in ipairs(trimsFolder:GetChildren()) do
				local baseLED = cageTrim:FindFirstChild("BaseFloor_LED")
				if baseLED and baseLED:IsA("BasePart") then
					baseLED.Color = baseColor
				end
			end
		end
	end
end

function CommonTheme.applyAtmosphere(atmo)
	if not atmo then return end
	local a = game.Lighting:FindFirstChild("Atmosphere_Day")
	if not a then return end
	if atmo.Density then a.Density = atmo.Density end
	if atmo.Color then a.Color = CommonTheme.hexToColor3(atmo.Color) end
	if atmo.Decay then a.Decay = CommonTheme.hexToColor3(atmo.Decay) end
	if atmo.Glare then a.Glare = atmo.Glare end
	if atmo.Haze then a.Haze = atmo.Haze end
end

function CommonTheme.applyRoom(roomConfig)
	local art = getArt():WaitForChild("Structure")

	if roomConfig.Floor_Material then
		CommonTheme.applyMaterialToChildren(art:WaitForChild("Floor_Main"), roomConfig.Floor_Material)
	end
	if roomConfig.Leaderboard_Floor_Material then
		CommonTheme.applyMaterialToChildren(art:WaitForChild("Floor_Leaderboard"), roomConfig.Leaderboard_Floor_Material)
	end
	if roomConfig.Stairs_Material then
		CommonTheme.applyMaterialToChildren(art:WaitForChild("Stairs_Spawn"), roomConfig.Stairs_Material)
	end

	local PunchingBags = Utils.SafePath(workspace, {
		"Main_World_F", "Gameplay", "Objects", "GymObjects", "PunchingBags"
	})

	if PunchingBags then
		for _, obj in ipairs(PunchingBags:GetChildren()) do
			if obj.Name == "PunchingBag" then
				local bag = obj:FindFirstChild("PunchingBag")
				if bag and roomConfig.PunchingBag_Texture then
					bag.TextureID = roomConfig.PunchingBag_Texture
				end
			end
		end
	end
end

function CommonTheme.applyShop(shopConfig)
	if shopConfig.Shop_Color_Start then
		script:SetAttribute("Shop_Color_Start", CommonTheme.hexToColor3(shopConfig.Shop_Color_Start))
	end
	if shopConfig.Shop_Color_End then
		script:SetAttribute("Shop_Color_End", CommonTheme.hexToColor3(shopConfig.Shop_Color_End))
	end
end

function CommonTheme.applyMenus(menusConfig)
	local CollectionService = game:GetService("CollectionService")
	local root = game.StarterGui
	local spawns = getSpawns()

	if menusConfig.Text_Main_Color then
		local c = CommonTheme.hexToColor3(menusConfig.Text_Main_Color)

		local home = spawns:WaitForChild("TeleportSign_ToHome")
		if home and home:FindFirstChild("SurfaceGui") then
			home.SurfaceGui.TextLabel.TextColor3 = c
		end

		local rank = spawns:WaitForChild("TeleportSign_ToRank")
		if rank and rank:FindFirstChild("SurfaceGui") then
			rank.SurfaceGui.TextLabel.TextColor3 = c
		end
	end

	if menusConfig.Header_Color then
		local Header_Color = CommonTheme.hexToColor3(menusConfig.Header_Color)
		for _, header in ipairs(CollectionService:GetTagged("Header_Background")) do
			if header:IsDescendantOf(root) and (header:IsA("ImageLabel") or header:IsA("ImageButton")) then
				header.ImageColor3 = Header_Color
			end
		end
	end

	if menusConfig.Header_Font_Color then
		for _, header in ipairs(CollectionService:GetTagged("Header_Title")) do
			if header:IsDescendantOf(root) and header:IsA("TextLabel") then
				header.TextColor3 = CommonTheme.hexToColor3(menusConfig.Header_Font_Color)
			end
		end
	end

	if menusConfig.Highlight_Font_Color then
		for _, txt in ipairs(CollectionService:GetTagged("Highlight_Text")) do
			if txt:IsDescendantOf(root) and txt:IsA("TextLabel") then
				txt.TextColor3 = CommonTheme.hexToColor3(menusConfig.Highlight_Font_Color)
			end
		end
	end

	if menusConfig.UIStroke_Color then
		for _, header in ipairs(CollectionService:GetTagged("UIStroke_Theme")) do
			if header:IsDescendantOf(root) and header:IsA("UIStroke") then
				header.Color = CommonTheme.hexToColor3(menusConfig.UIStroke_Color)
			end
		end
	end

	if menusConfig.UIStroke_Color then
		for _, outline in ipairs(CollectionService:GetTagged("Outline_Image")) do
			if outline:IsDescendantOf(root) and outline:IsA("ImageLabel") then
				outline.ImageColor3 = CommonTheme.hexToColor3(menusConfig.UIStroke_Color)
			end
		end
	end

	if menusConfig.CallToAction_Color then
		for _, cta in ipairs(CollectionService:GetTagged("CTA_Button")) do
			if cta:IsDescendantOf(root) then
				cta.BackgroundColor3 = CommonTheme.hexToColor3(menusConfig.CallToAction_Color)
			end
		end
	end
end


function CommonTheme.activate(themeName)
	local replicatedThemes = game.ReplicatedStorage.Design.Themes
	
	local themesFolder = getThemesFolder()
	
	if not themesFolder then
		themesFolder = Instance.new("Folder")
		themesFolder.Name = "Themes"
		themesFolder.Parent = getMainWorld()
	end

	for _, child in ipairs(themesFolder:GetChildren()) do
		child:Destroy()
	end

	local themeFolder = replicatedThemes:FindFirstChild(themeName)
	if not themeFolder then
		warn("[ThemeAssets] Unknown theme:", themeName)
		return
	end

	local clone = themeFolder:Clone()
	clone.Parent = themesFolder
end

return CommonTheme
]]></ProtectedString>
							<string name="ScriptGuid">{C54BC872-F720-4C72-81E7-40D5D4E39424}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CommonTheme.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX4570AEEF270B42BF9C1DE1A1246F1A97">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Standard</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXF5FA82DA42C64EFFAC65A736CE993963">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Themes/Standard/Theme.lua
local Theme = {}

local config = require(script.Parent.Config)
local CommonTheme = require(game.ReplicatedStorage.Design.Themes.CommonTheme)

Theme.config = config

function Theme.applyTheme(options)
	-- reset global state
	CommonTheme.reset()

	-- apply visuals
	CommonTheme.applySpawn(config.spawn)
	CommonTheme.applyCages(config.cages)
	CommonTheme.applyLights(config.lights)
	CommonTheme.applyAtmosphere(config.atmosphere)
	CommonTheme.applyRoom(config.room)
	CommonTheme.applyShop(config.shop)
	CommonTheme.applyMenus(config.menus)

	-- special UI
	game.StarterGui.Menus.HUD.CurrencyIndicators.HalloweenShop.Visible = false
end

return Theme]]></ProtectedString>
								<string name="ScriptGuid">{CB74509B-619D-43B3-A5B1-18B1E0DAC583}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Theme.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA96977CA8B07439E871E2CD82AE7A2DE">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Standard theme configuration
return {
	spawn = {
		Position = {
			X=-311.844727, 
			Y=90.7034454, 
			Z=-373.267456
		}
	},
	cages = {
		PaddingCorner = { Color = "#4CE573" },
		FenceDoor = { Color = "#4C4B4D" },
		UIGradient = {
			Colors = {
				{ Time = 0, Color = "#23F444" },
				{ Time = 1, Color = "#FFFFFF" }
			}
		},
		LogoDecalId = "rbxassetid://98568379999069",
		PaddingFence = { Color = "#3B3D46" },
		PaddingFenceDoor = { Color = "#3B3D46" },
		FenceFrame = { Color = "#4C4B4D" },
		CornerTrim = { Color = "#3B3D46" },
		PlayerSpawnGlowColor = { Color = "#00ff00" }
	},

	lights = {
		Neon_LED_Roof_Beam_Color = "#65b554",
		Neon_LED_Roof_Color = "#87f474",
		BaseFloor_LED_Color = "#87f474"
	},

	atmosphere = {
		Density = 0.3,
		Color = "#60fa6d",
		Decay = "#a0c9e2",
		Glare = 0.8,
		Haze = 2.11
	},

	menus = {
		Header_Color = "#23F444",
		Header_Font_Color = "#000000",
		Highlight_Font_Color = "#23F444",
		UIStroke_Color = "#23f444",
		CallToAction_Color = "#23f444",
		CallToAction_Over_Color = "#006200",
		CallToAction_Disabled_Color = "#09380E",
		Text_Main_Color = "#23F444",
		Selection_Color = "#FFFFFF"
	},

	room = {
		Floor_Material = {
			BaseMaterial = "Concrete",
			Color = "#474544",
			MaterialVariant = "Concrete_Tiles"
		},
		Leaderboard_Floor_Material = {
			BaseMaterial = "Metal",
			Color = "#2F2F2F",
			MaterialVariant = "MetalPanels"
		},
		Stairs_Material = {
			BaseMaterial = "WoodPlanks",
			Color = "#3F3C39",
			MaterialVariant = "WoodPlanks"
		},
		PunchingBag_Texture = "rbxassetid://70954748798604"
	},

	shop = {
		Shop_Color_Start = "#6B0FCF",
		Shop_Color_End = "#00ffff"
	},

	splashscreens = {
		"rbxassetid://133655844729939",
		"rbxassetid://77228773105758",
		"rbxassetid://82383919298361",
		"rbxassetid://127946909806988"
	}
}
]]></ProtectedString>
								<string name="ScriptGuid">{1C85A75F-C269-4E58-BD1F-FC9A5FEE4414}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Config.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX8C6AB0E185204C7798DA1EB45663761A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Halloween</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXAB0E098B69914E528B1C0380058E45BC">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Halloween theme configuration

return {
	spawn = {
		Position = {
			X=-311.844727, 
			Y=90.7034454, 
			Z=-373.267456
		}
	},
	cages = {
		PaddingCorner = { Color = "#E85D04" },
		FenceDoor = { Color = "#14213D" },
		UIGradient = {
			Colors = {
				{ Time = 0, Color = "#8B0000" },
				{ Time = 1, Color = "#FF7518" }
			}
		},
		LogoDecalId = "rbxassetid://137441062081064",
		PaddingFence = { Color = "#370617" },
		PaddingFenceDoor = { Color = "#9D0208" },
		FenceFrame = { Color = "#000000" },
		CornerTrim = { Color = "#FCA311" },
		PlayerSpawnGlowColor = { Color = "#e85d04" }
	},

	lights = {
		Neon_LED_Roof_Beam_Color = "#9933FF",
		Neon_LED_Roof_Color = "#FF6600",
		BaseFloor_LED_Color = "#FF6600"
	},

	atmosphere = {
		Density = 0.5,
		Color = "#FF0000",
		Decay = "#0000FF",
		Glare = 0.1,
		Haze = 0.5
	},

	menus = {
		Header_Color = "#340859",
		Header_Font_Color = "#FE7919",
		Highlight_Font_Color = "#FE7919",
		UIStroke_Color = "#FE7919",
		CallToAction_Color = "#FE7919",
		CallToAction_Over_Color = "#FE7919",
		CallToAction_Disabled_Color = "#382109",
		Text_Main_Color = "#FE7919",
		Selection_Color = "#FFFFFF"
	},

	room = {
		Floor_Material = {
			Color = "#cacbd1",
			MaterialVariant = "FloorHalloween",
			BaseMaterial = "Plastic"
		},
		Leaderboard_Floor_Material = {
			Color = "#cacbd1",
			MaterialVariant = "FloorHalloween",
			BaseMaterial = "Plastic"
		},
		Stairs_Material = {
			Color = "#cacbd1",
			MaterialVariant = "FloorHalloween",
			BaseMaterial = "Plastic"
		},
		PunchingBag_Texture = "rbxassetid://73607057486777"
	},

	shop = {
		Shop_Color_Start = "#6B0FCF",
		Shop_Color_End = "#FE7919"
	},

	splashscreens = {
		"rbxassetid://110276208829998",
		"rbxassetid://128056827804876",
		"rbxassetid://123256769506474",
		"rbxassetid://90729050354125",
		"rbxassetid://126480358779298"
	}
}
]]></ProtectedString>
								<string name="ScriptGuid">{4605FF7A-B9BB-4A0A-AE71-D501956652C9}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Config.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX12F4D759980644019A5E43B497853A3C">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Themes/Halloween/Theme.lua
local Theme = {}
local config = require(script.Parent.Config)
local CommonTheme = require(game.ReplicatedStorage.Design.Themes.CommonTheme)

Theme.config = config

function Theme.applyTheme(options)
	-- reset global state
	CommonTheme.reset()

	-- apply visuals
	CommonTheme.applySpawn(config.spawn)
	CommonTheme.applyCages(config.cages)
	CommonTheme.applyLights(config.lights)
	CommonTheme.applyAtmosphere(config.atmosphere)
	CommonTheme.applyRoom(config.room)
	CommonTheme.applyShop(config.shop)
	CommonTheme.applyMenus(config.menus)
	CommonTheme.applyVisibility(config.visibility)
	
	-- activate assets
	CommonTheme.activate("Halloween")

	-- special UI
	game.StarterGui.Menus.HUD.CurrencyIndicators.HalloweenShop.Visible = true
end

return Theme
]]></ProtectedString>
								<string name="ScriptGuid">{22AC333F-B08B-43AE-970C-819030B02AB2}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Theme.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX6A078BCA6759449A818C7A1FC3021B9A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Tournament</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX736587AF56AD4A26AA83D93466D3E4CE">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Tournament theme configuration
return {
	Divisions = {
		Bronze = {
			cages = {
				PaddingCorner = { Color = "#8B1E1E" },
				FenceDoor = { Color = "#614e1a" },
				PaddingFence = { Color = "#614e1a" },
				PaddingFenceDoor = { Color = "#614e1a" },
				FenceFrame = { Color = "#4A3B14" },
				CornerTrim = { Color = "#1A1206" },
				PlayerSpawnGlowColor = { Color = "#8B1E1E" },
				UIGradient = {
					Colors = {
						{ Time = 0, Color = "#614e1a" },
						{ Time = 1, Color = "#8B1E1E" }
					}
				}
			},
			floorColor = "#3A2C10"
		},

		Silver = {
			cages = {
				PaddingCorner = { Color = "#5A6A7A" },
				FenceDoor = { Color = "#C6C8CC" },
				PaddingFence = { Color = "#C6C8CC" },
				PaddingFenceDoor = { Color = "#C6C8CC" },
				FenceFrame = { Color = "#9FA3A8" },
				CornerTrim = { Color = "#2A2D30" },
				PlayerSpawnGlowColor = { Color = "#C6C8CC" },
				UIGradient = {
					Colors = {
						{ Time = 0, Color = "#9FA3A8" },
						{ Time = 1, Color = "#FFFFFF" }
					}
				}
			},
			floorColor = "#7A7F86"
		},
		
		Gold = {
			cages = {
				PaddingCorner = { Color = "#8B1E1E" },
				FenceDoor = { Color = "#D4AF37" },
				PaddingFence = { Color = "#D4AF37" },
				PaddingFenceDoor = { Color = "#D4AF37" },
				FenceFrame = { Color = "#FFD86A" },
				CornerTrim = { Color = "#3A2A00" },
				PlayerSpawnGlowColor = { Color = "#FFD86A" },
				UIGradient = {
					Colors = {
						{ Time = 0, Color = "#D4AF37" },
						{ Time = 1, Color = "#FFF2B0" }
					}
				}
			},
			floorColor = "#B8962E"
		},

		-- Emerald, Diamond, Platinum, UFC follow the same pattern
	},

	spawn = {
		Position = {
			X=-311.844727, 
			Y=78.1902542, 
			Z=-279.755524
		}
	},
	
	lights = {
		Neon_LED_Roof_Beam_Color = "#65b554",
		Neon_LED_Roof_Color = "#87f474",
		BaseFloor_LED_Color = "#87f474"
	},

	atmosphere = {
		Density = 0.3,
		Color = "#60fa6d",
		Decay = "#a0c9e2",
		Glare = 0.8,
		Haze = 2.11
	},

	menus = {
		Header_Color = "#23F444",
		Header_Font_Color = "#000000",
		Highlight_Font_Color = "#23F444",
		UIStroke_Color = "#23f444",
		CallToAction_Color = "#23f444",
		CallToAction_Over_Color = "#006200",
		CallToAction_Disabled_Color = "#09380E",
		Text_Main_Color = "#23F444",
		Selection_Color = "#FFFFFF"
	},

	room = {
		Floor_Material = {
			BaseMaterial = "Concrete",
			Color = "#474544",
			MaterialVariant = "Concrete_Tiles"
		},
		Leaderboard_Floor_Material = {
			BaseMaterial = "Metal",
			Color = "#2F2F2F",
			MaterialVariant = "MetalPanels"
		},
		Stairs_Material = {
			BaseMaterial = "WoodPlanks",
			Color = "#3F3C39",
			MaterialVariant = "WoodPlanks"
		},
		PunchingBag_Texture = "rbxassetid://70954748798604"
	},

	shop = {
		Shop_Color_Start = "#6B0FCF",
		Shop_Color_End = "#00ffff"
	},

	splashscreens = {
		"rbxassetid://133655844729939",
		"rbxassetid://77228773105758",
		"rbxassetid://82383919298361",
		"rbxassetid://127946909806988"
	},
	
	visibility = {
		HideTags = {
			"Hide_In_Tournament"
		}
	},
}
]]></ProtectedString>
								<string name="ScriptGuid">{5ECD9EA9-8714-434C-A15C-6515717281EC}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Config.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA03A58F4A0C94A7C90AD9A3135D64E2E">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Themes/Tournament/Theme.lua
local Theme = {}

local config = require(script.Parent.Config)
local CommonTheme = require(game.ReplicatedStorage.Design.Themes.CommonTheme)

Theme.config = config

function Theme.applyTheme(options)
	-- 1. Restore previous theme state
	CommonTheme.reset()

	-- 2. Activate theme assets (runtime clone)
	CommonTheme.activate("Tournament")

	-- 3. Apply visuals
	--CommonTheme.applyCages(config.cages)
	CommonTheme.applySpawn(config.spawn)
	CommonTheme.applyLights(config.lights)
	CommonTheme.applyAtmosphere(config.atmosphere)
	CommonTheme.applyRoom(config.room)
	CommonTheme.applyShop(config.shop)
	CommonTheme.applyMenus(config.menus)

	-- 4. Apply visibility rules LAST
	if config.visibility and config.visibility.HideTags then
		CommonTheme.detachByTags(config.visibility.HideTags)
	end

	game.StarterGui.Menus.HUD.CurrencyIndicators.HalloweenShop.Visible = false
	
	if options and options.division then
		local division = options.division
		local divConfig = config.Divisions[division]
		if divConfig and divConfig.cages then
			CommonTheme.applyCages(divConfig.cages)
			-- Division floor color 
			-- TODO : handle better the reference
			local floor = workspace.Main_World_F.Themes.Tournament.Division:FindFirstChild("DivisionFloor", true)
			if floor and divConfig.floorColor then
				floor.Color = Color3.fromHex(divConfig.floorColor)
			end
		end
	end
end

return Theme]]></ProtectedString>
								<string name="ScriptGuid">{C3D59106-90D5-4701-BFE4-3EF1C3A8E66F}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Theme.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX54D2FFB4B97846169DFA40CB7E6E2F4F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Division</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX7202CCB71BD64EFBBF3A80A2D2C7CB05">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LobbyPortal</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX483F29D89D6C4714A26942E5E9748C29">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Union</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX8F09AF127CB34E3A8B0F3C872CF0F092">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[while true do
	script.Parent.CFrame = script.Parent.CFrame * CFrame.fromEulerAnglesXYZ(0.07,0,0)
	wait(0.01)
end
]]></ProtectedString>
											<string name="ScriptGuid">{2325AAB6-083E-471E-AE6F-44B1BAEE0A8D}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Rotation.server.lua</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX2F459C99B46242CE8870DF7E616F8173">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">MatchMaking</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXFABFB5FBF0774536BA8FDEF4033B6A64">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">WaitingZone</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX7FFE65690519440B977072BA37548C7C">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- Services 
local ServerScriptService 		= game:GetService("ServerScriptService")

-- Modules
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Cage_Factory 				= require(Data_Mods_F:WaitForChild("Cage_Factory"))
local Fight_Params_Mod 			= require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local MatchMakingTouchZone 		= require(ServerScriptService.League_Service:WaitForChild("MatchMakingTouchZone"))

local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Start_Core_Fight = Channels.Bindable_Events.Start_Core_Fight

local CHECK_INTERVAL = 5
local MAX_CHECKS_BEFORE_TP = 5

local Checks_Count = 0
local Priority_Players = {}

MatchMakingTouchZone.RegisterTouchZone(script.Parent.Touch_P)

local function StartMatch(cage, player1, player2)
	print("Match : " .. player1.Name .. " VS " .. player2.Name)
	local Data_F = cage:WaitForChild("Fight_Data_F")
	local Active_Fight_V = Data_F:WaitForChild("Active_Fight")
	local Fight_Char_1_V = Data_F:WaitForChild("Fight_Char_1")
	local Fight_Char_2_V = Data_F:WaitForChild("Fight_Char_2")
	
	Fight_Char_1_V.Value = player1.Character
	Fight_Char_2_V.Value = player2.Character
	Start_Core_Fight:Fire(cage, Fight_Char_1_V.Value, Fight_Char_2_V.Value)
end


local function FisherYates_Shuffle(input)
	for i = #input, 2, -1 do
		local j = math.random(i)
		input[i], input[j] = input[j], input[i]
	end
end

local function Process_Matches(Queue, Cages)
	while #Queue >= 2 and #Cages > 0 do
		local P1 = table.remove(Queue, 1)
		local P2 = table.remove(Queue, 1)
		local Cage = table.remove(Cages)
		StartMatch(Cage, P1, P2)
	end
end

local function Matchmaking()
	local Waiting_Players = MatchMakingTouchZone.GetPlayersInside() or {}
	local Count = #Waiting_Players

	if Count == 0 then
		Priority_Players = {}
		Checks_Count = 0

	elseif Count == 1 then
		print("Waiting for other players")
		local Waiting_Player = Waiting_Players[1]

		if table.find(Priority_Players, Waiting_Player) then
			Checks_Count += 1
		else
			Priority_Players = {Waiting_Player}
			Checks_Count = 0
		end

		if Checks_Count >= MAX_CHECKS_BEFORE_TP then
			Checks_Count = 0
			print("TODO : Teleport to another server "..Waiting_Player.Name)
		end

	elseif Count >= 2 then
		Checks_Count = 0

		local Final_Queue = {}
		local New_Players = {}

		-- Put Priority player first in the queue
		for _, P in ipairs(Priority_Players) do
			if table.find(Waiting_Players, P) then
				table.insert(Final_Queue, P)
			end
		end

		-- Get new player in separate list
		for _, P in ipairs(Waiting_Players) do
			if not table.find(Final_Queue, P) then
				table.insert(New_Players, P)
			end
		end

		-- Shuffle the new players only
		FisherYates_Shuffle(New_Players)

		-- Put them back in the queue
		for _, P in ipairs(New_Players) do
			table.insert(Final_Queue, P)
		end

		-- Matchmaking
		local Available_Cages = Cage_Factory:getAvailableCages(Fight_Params_Mod.CageType.STANDARD)
		Process_Matches(Final_Queue, Available_Cages)

		-- If remaining players in queue (no cage or no opponent available) they are now Priority
		Priority_Players = Final_Queue
		if #Priority_Players > 0 then
			local names = {}
			for _, p in ipairs(Priority_Players) do table.insert(names, p.Name) end
			print("Remaining players in priority queue : " .. table.concat(names, ", "))
		end
	end
end

task.spawn(function()
	while true do
		Matchmaking()
		task.wait(CHECK_INTERVAL)
	end
end)]]></ProtectedString>
										<string name="ScriptGuid">{4DBE2965-2752-4CBA-B4BC-DB3160B39B39}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Tournament_WaitingZone.server.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXD39214E6A6504AA9898C5BD2DFFB49FF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Tournament_Info</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXF1596EB9B6FB472D847F01250D6F23CF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Rewards</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX790DC34A8E2A493389D49509AE624300">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[
local Rewards = require(game.ReplicatedStorage.Data_Mods_F.Tournament_Rules_Text_Mod)
local TextLabel  = script.Parent.Board.SurfaceGui.RewardsText.TextLabel
TextLabel.Text = Rewards.Rewards_Text]]></ProtectedString>
										<string name="ScriptGuid">{5E4597D4-0F24-4BD6-B150-6CF4C1F098F3}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Rewards_ShowText.server.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX5D813BF02CDA4D97A9F2B1ED54DCDDD1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Rules</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX8169CA1D0A684C66A31BF2E7E9D576D9">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[
local Rules = require(game.ReplicatedStorage.Data_Mods_F.Tournament_Rules_Text_Mod)
local TextLabel  = script.Parent.Board.SurfaceGui.RulesText.TextLabel
TextLabel.Text = Rules.Tournament_Short]]></ProtectedString>
										<string name="ScriptGuid">{366A12BB-F1E6-4073-90B2-A2BA7FC10559}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Rules_Short_ShowText.server.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXD44A9879A0754B27984DBD0E434657A5">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Models</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXDDFFE8F456A543A59B84E2C45F02A56C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GymEventAssets</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXAD3DFC38CAF94DF8B6CCE8551079DE51">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Highlight</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXAC196A4712A2496996149FA0CC56962B">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local RS 					= game:GetService("ReplicatedStorage")
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local Gym_Reward_Update 	= Channels.Bindable_Events.Gym_Reward_Update

local Count_Down_L = script.Parent:FindFirstChild("Countdown_L", true)

Gym_Reward_Update.Event:Connect(function(i)
	if i>0 then
		Count_Down_L.Visible = true
		Count_Down_L.Text = i .. "s"
	else
		Count_Down_L.Visible = false
	end
end)
]]></ProtectedString>
								<string name="ScriptGuid">{66E398D0-019B-41EC-A728-5B0A0A29127F}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Highlight_Handle.server.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX7A54BF166CB44FBC8108A29A4703657D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Base</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX8FAC2A9CFA9D4ED08E7C23BCD4EFA454">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
									<string name="ScriptGuid">{918F9F18-7C38-4A83-8BB2-E3AC43CA0A4C}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Rotate.server.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX14845733E5824F10828A369306AF82D7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">RingAlpha</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX5DBC41C3C4AA435ABE945187622F3E20">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
									<string name="ScriptGuid">{6D565EEA-8A56-4046-B470-A6C9C15E4CBC}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Rotate.server.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXA2A4CC2C906843C8B14B6216DA01E7A2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UGC</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX1369785CAB094BCC9A22F6300AF8F54E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">OfferItems</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX5A5B0E047F40433DB44DAB130067A76E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UGCPacks</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX382857AB318D45428A8FDBB4369BC4B2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Guy_Pack1</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX333DA2F831EB419CAB3754E8A326BB2A">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
										<string name="ScriptGuid">{BDC2236A-870A-4CDC-98FA-8BB9529BA754}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Animate.client.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX16A1CE11999C4CBF8CDB23A15D3D6780">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Guy_Pack2</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX9C9E8080B4BF43B7B001156F2A90FB31">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
										<string name="ScriptGuid">{4E7BBDF3-0473-49A8-BCED-297851D3C728}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Animate.client.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXA677ACA06DC849EF920680A74FDBD462">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Guy_Pack3</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXE61931825840486AAC3D0949FF263F81">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
										<string name="ScriptGuid">{9D89AD03-4CE6-4612-A119-18D526628907}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Animate.client.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX6BA46D914DC1403399DE9B5EE8095C49">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Guy_Pack4</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX39D4196A8A6B4AC094DFDBCE2A7DF9DD">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
										<string name="ScriptGuid">{953CB1A7-96F7-4515-88E1-BD909E6B55DE}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Animate.client.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX2ABD43CA0B7F4B6EAEBDDDE2D8A8EDFC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Modules</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX7E792B9893584FA9B6EC671AA5195D1B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Modules/Utils.lua
--
--  Description:
--      Comprehensive utility module providing helper functions for
--      formatting, math/string processing, player lookup, UI/model
--      utilities, glove alignment, server metadata, and secure remote
--      validation. Designed to be required broadly across the project.
--
--      Main Features:
--          • CSV encode/decode utilities
--          • Number formatting & large number abbreviation system
--          • Time conversion (HH:MM:SS)
--          • Safe character resolution anywhere in workspace
--          • Hover rotation + continuous rotation for 3D previews
--          • Glove alignment helpers (front & top view)
--          • Server info (server type, JobId, group/badge ids)
--
--          • SecureRemote (RemoteEvent wrapper):
--                - Type validation
--                - Missing-arg protection
--                - Per-player anti-spam & burst/lifetime rate limits
--                - Exploit detection & kick threshold
--
--          • SecureFunction (RemoteFunction wrapper):
--                - Type validation
--                - Rate limiting
--                - Safe pcall execution
--
--  Last Modified: 2025-11-29 by Darkzeb
--  Version: V2025-11
--
--  Dependencies:
--      Services:
--          - Players
--
--  Notes:
--      • SecureRemote / SecureFunction are core security primitives
--        used across the fight system and UI interactions.
--      • Rotation helpers use global-axis orientation for consistency.
--      • Number abbreviation supports extended notation (K → Qd → Ot…).
--======================================================================


local Utils = {}

local Players = game:GetService("Players")

function Utils.CsvToList(csv)
	if not csv or csv == "" then return {} end
	local t = {}
	for _, v in ipairs(string.split(csv, ",")) do
		local s = v:gsub("%s+", "")
		if s ~= "" then table.insert(t, s) end
	end
	return t
end

function Utils.ListToCsv(list)
	if not list or #list == 0 then return "" end
	return table.concat(list, ",")
end

function Utils.AddToCsv(csv, value)
	local list = Utils.CsvToList(csv)
	if not table.find(list, value) then
		table.insert(list, value)
	end
	return Utils.ListToCsv(list)
end

function Utils.Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

function Utils.GetWeekKey(now)
	return os.date("%Y_%U")
end

function Utils.Time_Conversion(Raw_S)
	local Hrs, Min_Secs = math.floor(Raw_S / 3600), Raw_S % 3600
	local Min, Sec = math.floor(Min_Secs / 60), Min_Secs % 60
	if Min < 10 then Min = "0" .. Min end
	if Sec < 10 then Sec = "0" .. Sec end
	if Hrs > 0 then return Utils.Format_Number(Hrs) .. ":" .. Min .. ":" .. Sec end
	return Min .. ":" .. Sec
end

function Utils.StartsWith(str, prefix)
	return typeof(str) == "string"
		and typeof(prefix) == "string"
		and string.sub(str, 1, #prefix) == prefix
end

function Utils.todayUTC()
	local d = os.date("!*t")
	return string.format("%04d-%02d-%02d", d.year, d.month, d.day)
end

function Utils.formatTime(seconds)
	seconds = math.max(0, seconds)
	local m = math.floor(seconds / 60)
	local s = seconds % 60
	return string.format("%02d:%02d", m, s)
end

function Utils.formatMMSS(seconds)
	seconds = math.max(0, seconds)
	local m = math.floor(seconds / 60)
	local s = seconds % 60
	return string.format("%02d:%02d", m, s)
end

function Utils.formatDate(ts)
	return os.date("%H:%M", ts)
end

function Utils.NumToString(Num)

	local function ToRomanNums(Num)
		local RomanNums1 = {
			"I", "II", "III", "IV", "V", "VI", "VII", "IIX", "IX", "X"
		}
		local RomanNums2 = {
			"I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"
		}
		local RomanNums3 = {
			"X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "C",
			"CX", "CXX", "CXXX", "CXL", "CL", "CLX", "CLXX", "CLXXX", "CXC", "CC"
		}
		local RomanNum = ""
		local Tens = math.floor(Num/10)
		local Ones = Num - (Tens * 10)
		if Tens > 0 then
			RomanNum = RomanNum .. RomanNums3[Tens]
			if Ones > 0 then
				RomanNum = RomanNum .. RomanNums2[Ones]
			end
		else
			if Ones > 0 then
				RomanNum = RomanNums1[Ones]
			end
		end
		return RomanNum
	end

	local UNITS = {"K","M","B","T","Qa","Qi","Sx","Sp","Oc","N","Dc","U","Dd","Td","Qt","Qd","Sd","St","Ot","Nv","V","C"}
	Num = tonumber(Num)
	
	----------------------------------------------------------------------
	-- NEW RULE: For numbers >= 10K → NO DECIMALS (e.g. "143K", "2M")
	----------------------------------------------------------------------
	if Num >= 10000 then
		local str = tostring(math.floor(Num))
		local len = math.floor((#str - 1) / 3)
		local suffix = UNITS[len]

		if suffix then
			local base = math.floor(Num / (1000 ^ len))
			return tostring(base) .. suffix
		end
	end
	
	if Num >= 1000 then
		local Div
		local Char
		if tostring(Num):split('e+')[2] then
			Div = math.floor(tonumber(tostring(Num):split('e+')[2])/3)
			local Rest = tonumber(tostring(Num):split('e+')[2])%3
			Char = UNITS[Div]
			if not Char then
				if math.floor(Div/#UNITS) <= 209 then
					Char = UNITS[Div%#UNITS + 1] .. ToRomanNums(math.floor(Div/#UNITS))
					local NewNum = tostring(tonumber(tostring(Num):split('e')[1]) * 10^Rest)
					local AfterFasila = ''
					if NewNum:split('.')[2] then
						for i = 1, string.len(NewNum:split('.')[2]) do
							if i > 2 then
								break
							elseif tonumber(NewNum:split('.')[2]:split('')[i]) == 0 then
								break
							else
								AfterFasila = AfterFasila .. tonumber(NewNum:split('.')[2]:split('')[i])
							end
						end
						NewNum = NewNum:split('.')[1] .. "." .. AfterFasila
					end
					Num = NewNum .. Char
				else
					Num = "Inf"
				end 
			else
				local NewNum = tostring(tonumber(tostring(Num):split('e')[1]) * 10^Rest)
				local AfterFasila = ''
				if NewNum:split('.')[2] then
					for i = 1, string.len(NewNum:split('.')[2]) do
						if i > 2 then
							break
						elseif tonumber(NewNum:split('.')[2]:split('')[i]) == 0 then
							break
						else
							AfterFasila = AfterFasila .. tonumber(NewNum:split('.')[2]:split('')[i])
						end
					end
					NewNum = NewNum:split('.')[1] .. "." .. AfterFasila
				end
				Num = NewNum .. Char
			end
		elseif tostring(Num) == "inf" then
			Num = "Inf"
		else
			Num = tostring(math.floor(Num))
			local Div = math.floor((string.len(Num)-1)/3)
			local Char = UNITS[Div]
			local Rest = string.len(Num) - 3*Div
			local NewNum = ""
			for i = 1, Rest do
				NewNum = NewNum .. Num:split('')[i]
			end
			if Num:split('')[Rest + 1] ~= "0" then
				NewNum = NewNum .. "." 
			end
			
			for i = 1, 2 do
				if Num:split('')[Rest + i] == "0" then
					break
				else
					NewNum = NewNum .. Num:split('')[Rest + i]
				end
			end
			NewNum = NewNum .. Char
			Num = NewNum
		end
	elseif Num <= 1000 then
		Num = tostring(Num)
		if Num:split('.')[2] then
			Num = Num:split('.')[1] .. "." .. Num:split('.')[2]:split('')[1]
		end
	end
	return Num
end

function Utils.getGroupId()
	return 35784641
end

function Utils.getServerId()
	return game.JobId
end

function Utils.getWelcomeBadgeId()
	return 1326039894106761
end

function Utils.GetServerType()
	if game.PrivateServerId ~= "" then
		if game.PrivateServerOwnerId ~= 0 then
			return "Private" -- VIP / Reserved server
		else
			return "PrivateReserved" -- Serveur privé non-VIP
		end
	else
		return "Public"
	end
end

function Utils.GetServerGameMode()
	local Game_Mode = game.Workspace:WaitForChild("Server_Context"):WaitForChild("Mode")
	return Game_Mode.Value
end

-- Utility: find any model safely by name anywhere in workspace
function Utils.ResolveCharacter(name)
	if not name then return nil end
	local c = workspace:FindFirstChild(name)
	if c and c:FindFirstChild("HumanoidRootPart") then
		return c
	end

	for _, descendant in ipairs(workspace:GetDescendants()) do
		if descendant:IsA("Model") and descendant.Name == name and descendant:FindFirstChild("HumanoidRootPart") then
			return descendant
		end
	end
	return nil
end

function Utils.SetupHoverRotation(button, model, speed)
	local primary = model:FindFirstChildWhichIsA("BasePart")
	if not primary then return end

	primary.Anchored = true
	model.PrimaryPart = primary

	local rotating = false

	button.MouseEnter:Connect(function()
		if rotating then return end
		rotating = true
		task.spawn(function()
			while rotating do
				-- GLOBAL AXIS rotation (not relative to current orientation)
				primary.CFrame = CFrame.fromMatrix(
					primary.Position,
					primary.CFrame.RightVector,
					primary.CFrame.UpVector
				) * CFrame.Angles(0, math.rad(speed), 0)

				task.wait(1/60)
			end
		end)
	end)

	button.MouseLeave:Connect(function()
		rotating = false
	end)
end

function Utils.SetupRotation(model, speed)
	local primary = model:FindFirstChildWhichIsA("BasePart")
	if not primary then return end
	primary.Anchored = true
	model.PrimaryPart = primary
	
	task.spawn(function()
		while true do
			-- GLOBAL AXIS rotation (not relative to current orientation)
			primary.CFrame = CFrame.fromMatrix(
				primary.Position,
				primary.CFrame.RightVector,
				primary.CFrame.UpVector
			) * CFrame.Angles(0, math.rad(speed), 0)

			task.wait(1/60)
		end
	end)
end

function Utils.AlignGloves(leftModel, rightModel, offset)
	offset = offset or 0.5

	if leftModel then
		leftModel:PivotTo(CFrame.new(-offset, 0, 0))
	end

	if rightModel then
		rightModel:PivotTo(CFrame.new(offset, 0, 0))
	end
end

function Utils.AlignGlovesTopView(leftModel, rightModel)
	local LEFT_ORIENTATION = CFrame.Angles(math.rad(-90), math.rad(20), 0)
	local RIGHT_ORIENTATION = CFrame.Angles(math.rad(-90), math.rad(-20), 0)

	if leftModel then
		leftModel:PivotTo(CFrame.new(-0.5, 0, 0) * LEFT_ORIENTATION)
	end
	if rightModel then
		rightModel:PivotTo(CFrame.new(0.5, 0, 0) * RIGHT_ORIENTATION)
	end
end

-- Internal: tracks spam per player per remote
local callHistory = {}

-- Cleanup when player leaves
Players.PlayerRemoving:Connect(function(player)
	callHistory[player] = nil
end)

-- Disconnect all remotes for a player (optional use)
function Utils.ClearPlayer(player)
	callHistory[player] = nil
end

function Utils.SecureRemote(remote, callback, expectedArgs, options)
	assert(remote and remote:IsA("RemoteEvent"), "Expected a RemoteEvent")
	assert(type(callback) == "function", "Callback must be a function")

	expectedArgs = expectedArgs or {}
	options = options or {}

	-- Defaults
	options.MaxBurst = options.MaxBurst or 8       -- Max calls within 1 sec before suspicious
	options.RateLimit = options.RateLimit or 10    -- Hard limit (ignored for legit spam)
	options.PunishThreshold = options.PunishThreshold or 20 -- Only kick if absolutely malicious

	-- Per-player stats
	local history = {}

	remote.OnServerEvent:Connect(function(player, ...)
		if not player or not player:IsA("Player") then return end

		local args = {...}
		local argCount = #args

		---------------------------------------
		-- 1. Secure argument validation
		---------------------------------------
		if type(expectedArgs) == "table" then
			local expectedCount = #expectedArgs

			if not options.AllowMissingArgs and argCount ~= expectedCount then
				return -- soft fail
			end

			if argCount > expectedCount then
				return -- too many args → safe ignore
			end

			for i = 1, math.min(argCount, expectedCount) do
				local expected = expectedArgs[i]
				local value = args[i]
				local actualType = typeof(value)

				if actualType ~= expected then
					-- Special case: Instance class check
					if actualType == "Instance" and value:IsA(expected) then
						continue
					end
					return -- bad type → ignore only
				end
			end
		end

		---------------------------------------
		-- 2. Anti-spam & exploit detector
		---------------------------------------
		local now = os.clock()

		history[player] = history[player] or {
			last = 0,
			burst = 0,
			total = 0,
		}

		local h = history[player]

		-- Burst counter (per second)
		if now - h.last < 1 then
			h.burst += 1
		else
			h.burst = 1
		end
		h.last = now

		h.total += 1

		-- Legit players may spam 10–20/s → OK
		if h.burst > options.MaxBurst then
			-- Suspicious player → ignore but do NOT kick
			if h.burst > options.PunishThreshold then
				-- Only kick obvious exploiters
				
				-- TODO remove that trace in production
				-- ⭐ Trace the RemoteEvent that triggered the kick
				warn(string.format(
					"[SecureRemote] Kicking player '%s' for malicious spam on RemoteEvent '%s' | burst=%d | total=%d",
					player.Name,
					remote.Name,
					h.burst,
					h.total
					))
				
				player:Kick("Malicious RemoteEvent spam detected.")
				return
			end
			return -- ignore spam
		end

		---------------------------------------
		-- 3. Execute callback safely
		---------------------------------------
		local ok, err = pcall(callback, player, table.unpack(args))
		if not ok then
			warn("[SecureRemote] Callback error:", err)
		end
	end)
end


function Utils.SecureFunction(remote, callback, expectedArgs, options)
	assert(remote and remote:IsA("RemoteFunction"), "Expected a RemoteFunction")
	assert(type(callback) == "function", "Callback must be a function")

	expectedArgs = expectedArgs or {}
	options = options or {}

	options.RateLimit = options.RateLimit or 10
	options.MaxBurst = options.MaxBurst or 5
	options.PunishThreshold = options.PunishThreshold or 20

	local history = {}

	remote.OnServerInvoke = function(player, ...)
		if not player or not player:IsA("Player") then
			return nil
		end

		local args = {...}
		local argCount = #args

		---------------------------
		-- Arg validation
		---------------------------
		if type(expectedArgs) == "table" then
			if argCount ~= #expectedArgs then
				return nil
			end

			for i, expected in ipairs(expectedArgs) do
				local value = args[i]
				local actualType = typeof(value)

				if actualType ~= expected then
					if actualType == "Instance" and value:IsA(expected) then
						continue
					end
					return nil
				end
			end
		elseif type(expectedArgs) == "number" then
			if argCount ~= expectedArgs then
				return nil
			end
		end

		---------------------------
		-- Anti spam
		---------------------------
		local now = os.clock()

		history[player] = history[player] or {
			last = 0,
			burst = 0,
			total = 0,
		}

		local h = history[player]

		if now - h.last < 1 then
			h.burst += 1
		else
			h.burst = 1
		end
		h.last = now
		h.total += 1

		if h.burst > options.MaxBurst then
			if h.burst > options.PunishThreshold then
				-- TODO remove that trace in production
				-- ⭐ Trace the RemoteEvent that triggered the kick
				warn(string.format(
					"[SecureRemote] Kicking player '%s' for malicious spam on RemoteFunction '%s' | burst=%d | total=%d",
					player.Name,
					remote.Name,
					h.burst,
					h.total
					))
				player:Kick("RemoteFunction exploit detected.")
			end
			return nil -- soft ignore
		end

		---------------------------
		-- Execute function safely
		---------------------------
		local results = {pcall(callback, player, table.unpack(args))}
		local ok = table.remove(results, 1)
		if not ok then
			warn("[SecureFunction] Error:", results[1])
			return nil
		end

		return table.unpack(results)
	end
end

-- Utils.WaitForAttribute(instance, attrName, timeout, cancelFn)
-- instance   : Instance Roblox
-- attrName   : string (nom de l'attribut)
-- timeout    : number ou nil (en secondes)
-- cancelFn   : function() -> bool (optionnel) si tu veux stopper l'attente
--
-- Retourne :
--   true  → attribut trouvé avant timeout/annulation
--   false → timeout ou cancel demandé
function Utils.WaitForAttribute(instance, attrName, timeout, cancelFn)
	local elapsed = 0
	local dt = 0.1

	while not instance:GetAttribute(attrName) do
		task.wait(dt)
		elapsed += dt

		-- Si une fonction d'annulation est fournie :
		if cancelFn and cancelFn() then
			return false
		end

		-- Timeout atteint ?
		if timeout and elapsed >= timeout then
			warn(("Utils.WaitForAttribute timeout waiting for '%s' on %s")
				:format(attrName, instance:GetFullName()))
			return false
		end
	end

	return true
end

function Utils.SafePath(root, path)
    local cur = root
    for _, name in ipairs(path) do
        if not cur then return nil end
        cur = cur:FindFirstChild(name)
    end
    return cur
end

return Utils]]></ProtectedString>
						<string name="ScriptGuid">{C7A0ACCF-D7C4-43E9-B4BA-766B399CC747}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Utils.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX50A5824553CE4DDD91FF79EBEED4E3F2">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Channels.lua
--
--  Description:
--      Centralized communication registry providing structured access
--      to all RemoteEvents, RemoteFunctions, and Bindables used for
--      client-server and server-client communication. Ensures consistent
--      access paths and initialization order across the experience.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-11-29 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/
--              - Server_Client_F
--              - Client_Server_F
--              - Bindable_F (Events / RF)
--
--  Notes:
--      - Channels.Bindable_Events: internal signals (UI, gameplay sync)
--      - Channels.Bindable_Functions: internal function remotes (group/badge checks)
--      - Channels.CS_Remote_Functions: client→server requests (rewards, crates, data)
--      - Channels.CS_Remote_Events: client→server fire events (UI, settings, actions)
--      - Channels.SC_Remote_Events: server→client communication (fight flow, UI, data)
--      - Serves as the unified import point for any module needing networked communication
--
--======================================================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Channels = {}

Channels_F 						= ReplicatedStorage:WaitForChild("Channels_F")
Channels.Server_Client 			= Channels_F:WaitForChild("Server_Client_F")
Channels.Client_Server 			= Channels_F:WaitForChild("Client_Server_F")
Channels.Bindable 				= Channels_F:WaitForChild("Bindable_F")
Channels.Bindable_RF_F     		= Channels.Bindable:WaitForChild("RF")
Channels.Bindable_Events_F     	= Channels.Bindable:WaitForChild("Events")
Channels.Client_Server_RF    	= Channels.Client_Server:WaitForChild("RF")
Channels.Client_Server_Events 	= Channels.Client_Server:WaitForChild("Events")
Channels.Server_Client_Events 	= Channels.Server_Client:WaitForChild("Events")
Channels.Offers_F 				= Channels_F:WaitForChild("Offers")
Channels.UGC_Pack_F			 	= Channels_F:WaitForChild("UGC_Pack")

-- Centralized remotes events & function registry

Channels.Bindable_Events = {
	AI_Training_Submission		= Channels.Bindable_Events_F:WaitForChild("AI_Training_Submission"),
	Award_Badge					= Channels.Bindable_Events_F:WaitForChild("Award_Badge"),
	AI_Training_Cage_Clinch		= Channels.Bindable_Events_F:WaitForChild("AI_Training_Cage_Clinch"),
	Click_Rate_Inc				= Channels.Bindable_Events_F:WaitForChild("Click_Rate_Inc"),
	Click_Rate_Reset			= Channels.Bindable_Events_F:WaitForChild("Click_Rate_Reset"),
	Click_Rate_Update			= Channels.Bindable_Events_F:WaitForChild("Click_Rate_Update"),
	Close_Changelog				= Channels.Bindable_Events_F:WaitForChild("Close_Changelog"),
	Close_DailyRewards			= Channels.Bindable_Events_F:WaitForChild("Close_DailyRewards"),
	Close_Fight_Result			= Channels.Bindable_Events_F:WaitForChild("Close_Fight_Result"),
	Close_Settings				= Channels.Bindable_Events_F:WaitForChild("Close_Settings"),
	Show_Tutorial_Launcher		= Channels.Bindable_Events_F:FindFirstChild("Show_Tutorial_Launcher"),
	Close_Tutorial				= Channels.Bindable_Events_F:WaitForChild("Close_Tutorial"),
	Disable_Fight_Mode			= Channels.Bindable_Events_F:WaitForChild("Disable_Fight_Mode"),
	Display_Data				= Channels.Bindable_Events_F:WaitForChild("Display_Data"),
	Display_Tuto_Message		= Channels.Bindable_Events_F:WaitForChild("Display_Tuto_Message"),
	Display_Tuto_Indicator		= Channels.Bindable_Events_F:WaitForChild("Display_Tuto_Indicator"),
	Equipment_Strike			= Channels.Bindable_Events_F:WaitForChild("Equipment_Strike"),
	Grant_Gamepass_Perks		= Channels.Bindable_Events_F:WaitForChild("Grant_Gamepass_Perks"),
	Gym_Reward_Update			= Channels.Bindable_Events_F:WaitForChild("Gym_Reward_Update"),
	Hallowen_UGCs				= Channels.Bindable_Events_F:WaitForChild("Hallowen_UGCs"),
	MTX_Finished				= Channels.Bindable_Events_F:WaitForChild("MTX_Finished"),
	MTX_Prompted				= Channels.Bindable_Events_F:WaitForChild("MTX_Prompted"),
	New_Round_Display			= Channels.Bindable_Events_F:WaitForChild("New_Round_Display"),
	Next_Tutorial_Step			= Channels.Bindable_Events_F:WaitForChild("Next_Tutorial_Step"),
	On_Submission_Handle		= Channels.Bindable_Events_F:WaitForChild("On_Submission_Handle"),
	Open_Appearance				= Channels.Bindable_Events_F:WaitForChild("Open_Appearance"),
	Open_Equipment				= Channels.Bindable_Events_F:WaitForChild("Open_Equipment"),
	Open_Changelog				= Channels.Bindable_Events_F:WaitForChild("Open_Changelog"),
	Open_Codes					= Channels.Bindable_Events_F:WaitForChild("Open_Codes"),
	Open_Combos					= Channels.Bindable_Events_F:WaitForChild("Open_Combos"),
	Open_Daily_Rewards			= Channels.Bindable_Events_F:WaitForChild("Open_Daily_Rewards"),
	Open_Emotes_UI				= Channels.Bindable_Events_F:WaitForChild("Open_Emotes_UI"),
	Open_InsufficientFunds_UI	= Channels.Bindable_Events_F:WaitForChild("Open_InsufficientFunds_UI"),
	Open_Leagues				= Channels.Bindable_Events_F:WaitForChild("Open_Leagues"),
	Open_Servers				= Channels.Bindable_Events_F:WaitForChild("Open_Servers"),
	Open_Session_Rewards		= Channels.Bindable_Events_F:WaitForChild("Open_Session_Rewards"),
	Open_Settings				= Channels.Bindable_Events_F:WaitForChild("Open_Settings"),
	Open_Shop_UI				= Channels.Bindable_Events_F:WaitForChild("Open_Shop_UI"),
	Open_Skill_Tree				= Channels.Bindable_Events_F:WaitForChild("Open_Skill_Tree"),
	Open_Starter_Pack			= Channels.Bindable_Events_F:WaitForChild("Open_Starter_Pack"),
	Open_Stats					= Channels.Bindable_Events_F:WaitForChild("Open_Stats"),
	Open_Leaderboards_Filter	= Channels.Bindable_Events_F:WaitForChild("Open_Leaderboards_Filter"),
	Player_Leaderboard_Data		= Channels.Bindable_Events_F:WaitForChild("Player_Leaderboard_Data"),
	Prompt_Invite				= Channels.Bindable_Events_F:WaitForChild("Prompt_Invite"),
	Ragdoll_Player				= Channels.Bindable_Events_F:WaitForChild("Ragdoll_Player"),
	Remove_Submission_UI		= Channels.Bindable_Events_F:WaitForChild("Remove_Submission_UI"),
	Remove_Trail				= Channels.Bindable_Events_F:WaitForChild("Remove_Trail"),
	Set_Fight_Mode_Lock			= Channels.Bindable_Events_F:WaitForChild("Set_Fight_Mode_Lock"),
	Set_Trail					= Channels.Bindable_Events_F:WaitForChild("Set_Trail"),
	
	Show_White_Fade				= Channels.Bindable_Events_F:WaitForChild("Show_White_Fade"),
	Start_Core_Fight			= Channels.Bindable_Events_F:WaitForChild("Start_Core_Fight"),
	Toggle_BG_Volume			= Channels.Bindable_Events_F:WaitForChild("Toggle_BG_Volume"),
	Toggle_Commands_Panel		= Channels.Bindable_Events_F:WaitForChild("Toggle_Commands_Panel"),
	Toggle_Cutscene				= Channels.Bindable_Events_F:WaitForChild("Toggle_Cutscene"),
	Toggle_Fight_Button			= Channels.Bindable_Events_F:WaitForChild("Toggle_Fight_Button"),
	Toggle_Tools_Buttons		= Channels.Bindable_Events_F:WaitForChild("Toggle_Tools_Buttons"),
	Toggle_Fight_Mode			= Channels.Bindable_Events_F:WaitForChild("Toggle_Fight_Mode"),
	Toggle_Fight_UI				= Channels.Bindable_Events_F:WaitForChild("Toggle_Fight_UI"),
	Toggle_Player_List			= Channels.Bindable_Events_F:WaitForChild("Toggle_Player_List"),
	Toggle_Reset				= Channels.Bindable_Events_F:WaitForChild("Toggle_Reset"),
	Toggle_Side_Buttons			= Channels.Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"),
	Toggle_Takedown_Tracker		= Channels.Bindable_Events_F:WaitForChild("Toggle_Takedown_Tracker"),
	Toggle_TopBar				= Channels.Bindable_Events_F:WaitForChild("Toggle_TopBar"),
	Toggle_Tutorial_OK_Button	= Channels.Bindable_Events_F:WaitForChild("Toggle_Tutorial_OK_Button"),
	Tournament_Score_Updated	= Channels.Bindable_Events_F:WaitForChild("Tournament_Score_Updated"),
	Tournament_Fight_Ended		= Channels.Bindable_Events_F:WaitForChild("Tournament_Fight_Ended"),
	Transition_Fade_UI			= Channels.Bindable_Events_F:WaitForChild("Transition_Fade_UI"),
	Transition_Hole_UI			= Channels.Bindable_Events_F:WaitForChild("Transition_Hole_UI"),
	Update_Server_Data			= Channels.Bindable_Events_F:WaitForChild("Update_Server_Data"),
	Voice_Chat_Prompt			= Channels.Bindable_Events_F:WaitForChild("Voice_Chat_Prompt"),
	Release_Mobile_Blocking    	= Channels.Bindable_Events_F:WaitForChild("Release_Mobile_Blocking"),
	Toggle_Key_Labels          	= Channels.Bindable_Events_F:WaitForChild("Toggle_Key_Labels"),
	
	Start_Tour					= Channels.Bindable_Events_F:WaitForChild("Start_Tour"),
	Start_Cage_Tutorial			= Channels.Bindable_Events_F:WaitForChild("Start_Cage_Tutorial"),
	Display_InCage_Message		= Channels.Bindable_Events_F:WaitForChild("Display_InCage_Message"),
	Display_InCage_ImageStroke  = Channels.Bindable_Events_F:WaitForChild("Display_InCage_ImageStroke"),
	Display_InCage_UIStroke		= Channels.Bindable_Events_F:WaitForChild("Display_InCage_UIStroke"),
	Display_InCage_Indicator    = Channels.Bindable_Events_F:WaitForChild("Display_InCage_Indicator"),
	
	
	Change_Shop_UIFrames		= Channels.Bindable_Events_F:WaitForChild("Change_Shop_UIFrames"),
	Game_Loading_Finished		= Channels.Bindable_Events_F:WaitForChild("Game_Loading_Finished"),

}

Channels.Bindable_Functions = {
	Is_Chatbox_Typing 			= Channels.Bindable_RF_F:WaitForChild("Is_Chatbox_Typing"),
	Player_Can_Access_Arena 	= Channels.Bindable_RF_F:WaitForChild("Player_Can_Access_Arena"),
	Player_In_Group 			= Channels.Bindable_RF_F:WaitForChild("Player_In_Group"),
	Player_Owns_Badge 			= Channels.Bindable_RF_F:WaitForChild("Player_Owns_Badge"),
	Get_Fights_Keys				= Channels.Bindable_RF_F:WaitForChild("Get_Fights_Keys"),
}

Channels.CS_Remote_Functions = {
	Avatar_Clothing_Request		= Channels.Client_Server_RF:WaitForChild("Avatar_Clothing_Request"),
	Claim_Daily_Reward 			= Channels.Client_Server_RF:WaitForChild("Claim_Daily_Reward"),
	Claim_Session_Reward 		= Channels.Client_Server_RF:WaitForChild("Claim_Session_Reward"),
	Combo_Action_Request 		= Channels.Client_Server_RF:WaitForChild("Combo_Action_Request"),
	Crate_Action_Request 		= Channels.Client_Server_RF:WaitForChild("Crate_Action_Request"),
	Create_Training_Bot 		= Channels.Client_Server_RF:WaitForChild("Create_Training_Bot"),
	Destroy_Training_Bot 		= Channels.Client_Server_RF:WaitForChild("Destroy_Training_Bot"),
	Send_Invite_Notification    = Channels.Client_Server_RF:WaitForChild("Send_Invite_Notification"),
	Emote_Slot_Request 			= Channels.Client_Server_RF:WaitForChild("Emote_Slot_Request"),
	Get_All_Server_Data 		= Channels.Client_Server_RF:WaitForChild("Get_All_Server_Data"),
	Get_Session_Progress 		= Channels.Client_Server_RF:WaitForChild("Get_Session_Progress"),
	Player_In_Group 			= Channels.Client_Server_RF:WaitForChild("Player_In_Group"),
	Player_Owns_Badge			= Channels.Client_Server_RF:WaitForChild("Player_Owns_Badge"),
	Redeem_Code 				= Channels.Client_Server_RF:WaitForChild("Redeem_Code"),
	Redeem_Skill_Tree_Reward 	= Channels.Client_Server_RF:WaitForChild("Redeem_Skill_Tree_Reward"),
	Teleport_To_Server 			= Channels.Client_Server_RF:WaitForChild("Teleport_To_Server"),
	Get_Mobile_Buttons          = Channels.Client_Server_RF:WaitForChild("Get_Mobile_Buttons"),
	
	Find_Cage_Mini_Tutorial  	= Channels.Client_Server_RF:WaitForChild("Find_Cage_Mini_Tutorial")
}

Channels.CS_Remote_Events = {
	Convert_Cash_To_Gems 		= Channels.Client_Server_Events:WaitForChild("Convert_Cash_To_Gems"),
	Crate_Display 				= Channels.Client_Server_Events:WaitForChild("Crate_Display"),
	Exit_Machine 				= Channels.Client_Server_Events:WaitForChild("Exit_Machine"),
	Gym_Reward_Testing 			= Channels.Client_Server_Events:WaitForChild("Gym_Reward_Testing"),
	Ready_To_Fight				= Channels.Client_Server_Events:WaitForChild("Ready_To_Fight"),
	Reset_Sequence 				= Channels.Client_Server_Events:WaitForChild("Reset_Sequence"),
	Save_Appearance 			= Channels.Client_Server_Events:WaitForChild("Save_Appearance"),
	Set_Body_Preset 			= Channels.Client_Server_Events:WaitForChild("Set_Body_Preset"),
	Save_Settings 				= Channels.Client_Server_Events:WaitForChild("Save_Settings"),
	Server_Message_Crate 		= Channels.Client_Server_Events:WaitForChild("Server_Message_Crate"),
	Set_Creator_Reward_Code 	= Channels.Client_Server_Events:WaitForChild("Set_Creator_Reward_Code"),
	Set_Player_Device 			= Channels.Client_Server_Events:WaitForChild("Set_Player_Device"),
	Show_Shield_UI 				= Channels.Client_Server_Events:WaitForChild("Show_Shield_UI"),
	Tournament_Register 		= Channels.Client_Server_Events:WaitForChild("Tournament_Register"),
	Workout_Rep 				= Channels.Client_Server_Events:WaitForChild("Workout_Rep"),

	Blocking_Strike           	= Channels.Client_Server_Events:WaitForChild("Blocking_Strike"),
	Dodging_Strike              = Channels.Client_Server_Events:WaitForChild("Dodging_Strike"),
	Throwing_Strike             = Channels.Client_Server_Events:WaitForChild("Throwing_Strike"),
	Toggle_Healing_Effect       = Channels.Client_Server_Events:WaitForChild("Toggle_Healing_Effect"),
	Unblocking_Strike           = Channels.Client_Server_Events:WaitForChild("Unblocking_Strike"),
	
	Purchase_Cloth_Item		    = Channels.Client_Server_Events:WaitForChild("Purchase_Cloth_Item"),
	
	End_Mini_Tutorial_Match		= Channels.Client_Server_Events:WaitForChild("End_Mini_Tutorial_Match"),
	Set_TakeDown_Mini_Tutorial	= Channels.Client_Server_Events:WaitForChild("Set_TakeDown_Mini_Tutorial"),
	
	Reset_Player_Profile		= Channels.Client_Server_Events:WaitForChild("Reset_Player_Profile"),
	Fight_Intro_Finished		= Channels.Client_Server_Events:WaitForChild("Fight_Intro_Finished"),
	
	PunchingGame_Result			= Channels.Client_Server_Events:WaitForChild("PunchingGame_Result"),
	
	Leaderboard_Mode_Changed    = Channels.Client_Server_Events:WaitForChild("Leaderboard_Mode_Changed"),
	League_Portal_Teleport		= Channels.Client_Server_Events:WaitForChild("League_Portal_Teleport")
}

Channels.SC_Remote_Events = {
	Admin_Notification			= Channels.Server_Client_Events:WaitForChild("Admin_Notification"),
	Cage_Clinch_Start 			= Channels.Server_Client_Events:WaitForChild("Cage_Clinch_Start"),
	Convert_Feedback 			= Channels.Server_Client_Events:WaitForChild("Convert_Feedback"),
	Display_Data 				= Channels.Server_Client_Events:WaitForChild("Display_Data"),
	Elo_Rank_Dif 				= Channels.Server_Client_Events:WaitForChild("Elo_Rank_Dif"),
	End_Fight 					= Channels.Server_Client_Events:WaitForChild("End_Fight"),
	Fight_Data_Result 			= Channels.Server_Client_Events:WaitForChild("Fight_Data_Result"),
	Fight_Set_Up 				= Channels.Server_Client_Events:WaitForChild("Fight_Set_Up"),
	Fight_Spawn_Notification 	= Channels.Server_Client_Events:WaitForChild("Fight_Spawn_Notification"),
	Got_Hit_Effect 				= Channels.Server_Client_Events:WaitForChild("Got_Hit_Effect"),
	Grant_Free_Crate 			= Channels.Server_Client_Events:WaitForChild("Grant_Free_Crate"),
	Hide_Special_Gloves_Frame 	= Channels.Server_Client_Events:WaitForChild("Hide_Special_Gloves_Frame"),
	Init_Gym_Training 			= Channels.Server_Client_Events:WaitForChild("Init_Gym_Training"),
	Open_InsufficientFunds 		= Channels.Server_Client_Events:WaitForChild("Open_InsufficientFunds"),
	League_DivisionUpdate 		= Channels.Server_Client_Events:WaitForChild("League_DivisionUpdate"),
	Open_Emotes 				= Channels.Server_Client_Events:WaitForChild("Open_Emotes"),
	Open_Shop 					= Channels.Server_Client_Events:WaitForChild("Open_Shop"),
	Overhead_Display 			= Channels.Server_Client_Events:WaitForChild("Overhead_Display"),
	Round_Result_Win 			= Channels.Server_Client_Events:WaitForChild("Round_Result_Win"),
	Server_Chat 				= Channels.Server_Client_Events:WaitForChild("Server_Chat"),
	Session_Reward_Claim_Result = Channels.Server_Client_Events:WaitForChild("Session_Reward_Claim_Result"),
	Session_Reward_Progress 	= Channels.Server_Client_Events:WaitForChild("Session_Reward_Progress"),
	Show_Crate_Effects 			= Channels.Server_Client_Events:WaitForChild("Show_Crate_Effects"),
	Show_Punch_Effects 			= Channels.Server_Client_Events:WaitForChild("Show_Punch_Effects"),
	Submission_Minigame_Update	= Channels.Server_Client_Events:WaitForChild("Submission_Minigame_Update"),
	Top3_Players_Updated 		= Channels.Server_Client_Events:WaitForChild("Top3_Players_Updated"),
	Tournament_Results 			= Channels.Server_Client_Events:WaitForChild("Tournament_Results"),
	Tournament_Update 			= Channels.Server_Client_Events:WaitForChild("Tournament_Update"),
	Transition_Fade 			= Channels.Server_Client_Events:WaitForChild("Transition_Fade"),
	Transition_Hole 			= Channels.Server_Client_Events:WaitForChild("Transition_Hole"),
	Update_All_Server_Data 		= Channels.Server_Client_Events:WaitForChild("Update_All_Server_Data"),
	Update_Player_Device 		= Channels.Server_Client_Events:WaitForChild("Update_Player_Device"),
	Update_Player_List 			= Channels.Server_Client_Events:WaitForChild("Update_Player_List"),
	Shop_Item_Purchased			= Channels.Server_Client_Events:WaitForChild("Shop_Item_Purchased"),
	Shop_Purchase_Rejected		= Channels.Server_Client_Events:WaitForChild("Shop_Purchase_Rejected"),
	Game_Startup_Ready			= Channels.Server_Client_Events:WaitForChild("Game_Startup_Ready"),
	
	PunchingGame_Action			= Channels.Server_Client_Events:WaitForChild("PunchingGame_Action"),
	League_Portal_Init			= Channels.Server_Client_Events:WaitForChild("League_Portal_Init"),
}

Channels.Offers = {
	GetActiveOffers = Channels.Offers_F:WaitForChild("GetActiveOffers"),
	GetCurrentClothOffer = Channels.Offers_F:WaitForChild("GetCurrentClothOffer"),
	GetNewClothOffer = Channels.Offers_F:WaitForChild("GetNewClothOffer"),
	ClothItemIdSignal = Channels.Offers_F:WaitForChild("ClothItemIdSignal"),
	RequestPurchase = Channels.Offers_F:WaitForChild("RequestPurchase"),
	SendOfferToClient = Channels.Offers_F:WaitForChild("SendOfferToClient"),
	ShowMessage = Channels.Offers_F:WaitForChild("ShowMessage"),
	Open_InsufficientFunds =  Channels.Offers_F:WaitForChild("Open_InsufficientFunds"),
	SendUGCOfferToClient = Channels.Offers_F:WaitForChild("SendUGCOfferToClient"),
	ShowOfferSignalBind = Channels.Offers_F:WaitForChild("ShowOfferSignalBind")

}
	
Channels.UGC_Pack = {
	ApplyAccessoriesRE = Channels.UGC_Pack_F:WaitForChild("ApplyAccessoriesRE"),
	ShowAvatarAndGetTriggerRE = Channels.UGC_Pack_F:WaitForChild("ShowAvatarAndGetTriggerRE")
}

return Channels]]></ProtectedString>
						<string name="ScriptGuid">{64A0A67D-2984-4C2E-A842-DF074AD93EBD}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Channels.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX88E667AC240140B99E63793B70CE3D43">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Modules/CreatorCodes.lua
--
--  Description:
--      Static table of creator codes used for attribution,
--      partnerships, or in-game rewards. Each entry maps a creator
--      identifier (Creator_1, Creator_2, …) to a Name string.
--
--  Author(s): Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - None (standalone static data)
--
--  Notes:
--      - Current creators:
--          * bye
--          * AEBID
--          * NM
--          * SkiluaOnYTB
--          * Akamuro
--          * JkChimera
--          * Kayzarox
--          * Unchained
--      - Can be expanded with additional Creator_N entries
--      - Likely used in attribution systems or special code redemption
--
--======================================================================

return {
	Creator_1 = {
		Name = "bye",
	},
	Creator_2 = {
		Name = "AEBID",
	},
	Creator_3 = {
		Name = "NM",
	},
	Creator_4 = {
		Name = "SkiluaOnYTB",
	},
	Creator_5 = {
		Name = "Akamuro",
	},
	Creator_6 = {
		Name = "JkChimera",
	},
	Creator_7 = {
		Name = "Kayzarox",
	},
	Creator_8 = {
		Name = "Unchained",
	},
}]]></ProtectedString>
						<string name="ScriptGuid">{F381145D-88BE-4977-8E34-3FFE73522816}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CreatorCodes.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXAA77036581D74633807BB8DC53021812">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/GameAnalytics.lua
--
--  Description:
--      Proxy module for GameAnalytics. Automatically loads the
--      appropriate implementation depending on context:
--          * GameAnalytics (server)
--          * GameAnalyticsClient (client)
--
--  Author(s): Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * RunService
--      - Local Modules:
--          * script.GameAnalytics (server-side implementation)
--          * script.GameAnalyticsClient (client-side implementation)
--
--  Notes:
--      - Usage: require(ReplicatedStorage.GameAnalytics)
--        Will return server or client version transparently
--      - Ensures consistent API entrypoint across environments
--
--======================================================================

local RunService = game:GetService("RunService")

if RunService:IsServer() then
	return require(script.GameAnalytics)
else
	return require(script.GameAnalyticsClient)
end]]></ProtectedString>
						<string name="ScriptGuid">{B1C14997-4C01-4FD3-9F7B-A63DAB13697B}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GameAnalytics.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXEF8C0BBFFE054767AC2E89C8A750152D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GameAnalytics</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXC445B12C85744551BDB15CA528DBBB2F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local GAResourceFlowType = require(script.GAResourceFlowType)
local GAProgressionStatus = require(script.GAProgressionStatus)
local GAErrorSeverity = require(script.GAErrorSeverity)

local ga = {
	EGAResourceFlowType = GAResourceFlowType,
	EGAProgressionStatus = GAProgressionStatus,
	EGAErrorSeverity = GAErrorSeverity,
}

local types = require(script.Types)
local logger = require(script.Logger)
local threading = require(script.Threading)
local state = require(script.State)
local validation = require(script.Validation)
local store = require(script.Store)
local events = require(script.Events)
local utilities = require(script.Utilities)
local Players = game:GetService("Players")
local MKT = game:GetService("MarketplaceService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalizationService = game:GetService("LocalizationService")
local ScriptContext = game:GetService("ScriptContext")
local Postie = require(script.Postie)
local OnPlayerReadyEvent
local ProductCache = {}
local ONE_HOUR_IN_SECONDS = 3600
local MaxErrorsPerHour = 10
local ErrorDS = {}
local errorCountCache = {}
local errorCountCacheKeys = {}

local InitializationQueue = {}
local InitializationQueueByUserId = {}

type BusinessEventOptions = types.BusinessEventOptions
type ResourceEventOptions = types.ResourceEventOptions
type ProgressionEventOptions = types.ProgressionEventOptions
type DesignEventOptions = types.DesignEventOptions
type ErrorEventOptions = types.ErrorEventOptions
type CustomDimension = types.CustomDimension
type ProductInfo = types.ProductInfo
type ProcessReceiptInfo = types.ProcessReceiptInfo
type TeleportData = types.TeleportData
type RemoteConfigs = types.RemoteConfigs
type GameAnalyticsOptions = types.GameAnalyticsOptions

local function addToInitializationQueue(func, ...)
	if InitializationQueue ~= nil then
		table.insert(InitializationQueue, {
			Func = func,
			Args = { ... },
		})

		logger:i("Added event to initialization queue")
	else
		--This should never happen
		logger:w("Initialization queue already cleared.")
	end
end

local function addToInitializationQueueByUserId(userId, func, ...)
	if not ga:isPlayerReady(userId) then
		if InitializationQueueByUserId[userId] == nil then
			InitializationQueueByUserId[userId] = {}
		end

		table.insert(InitializationQueueByUserId[userId], {
			Func = func,
			Args = { ... },
		})

		logger:i("Added event to player initialization queue")
	else
		--This should never happen
		logger:w("Player initialization queue already cleared.")
	end
end

-- local functions
local function isSdkReady(options)
	local playerId = options["playerId"] or nil
	local needsInitialized = options["needsInitialized"] or true
	local shouldWarn = options["shouldWarn"] or false
	local message = options["message"] or ""

	-- Is SDK initialized
	if needsInitialized and not state.Initialized then
		if shouldWarn then
			logger:w(message .. " SDK is not initialized")
		end

		return false
	end

	-- Is SDK enabled
	if needsInitialized and playerId and not state:isEnabled(playerId) then
		if shouldWarn then
			logger:w(message .. " SDK is disabled")
		end

		return false
	end

	-- Is session started
	if needsInitialized and playerId and not state:sessionIsStarted(playerId) then
		if shouldWarn then
			logger:w(message .. " Session has not started yet")
		end

		return false
	end

	return true
end

function ga:configureAvailableCustomDimensions01(customDimensions: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available custom dimensions must be set before SDK is initialized")
		return
	end

	state:setAvailableCustomDimensions01(customDimensions)
end

function ga:configureAvailableCustomDimensions02(customDimensions: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available custom dimensions must be set before SDK is initialized")
		return
	end

	state:setAvailableCustomDimensions02(customDimensions)
end

function ga:configureAvailableCustomDimensions03(customDimensions: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available custom dimensions must be set before SDK is initialized")
		return
	end

	state:setAvailableCustomDimensions03(customDimensions)
end

function ga:configureAvailableResourceCurrencies(resourceCurrencies: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available resource currencies must be set before SDK is initialized")
		return
	end

	events:setAvailableResourceCurrencies(resourceCurrencies)
end

function ga:configureAvailableResourceItemTypes(resourceItemTypes: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available resource item types must be set before SDK is initialized")
		return
	end

	events:setAvailableResourceItemTypes(resourceItemTypes)
end

function ga:configureBuild(build: string)
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Build version must be set before SDK is initialized.")
		return
	end

	events:setBuild(build)
end

function ga:configureAvailableGamepasses(availableGamepasses: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available gamepasses must be set before SDK is initialized.")
		return
	end

	state:setAvailableGamepasses(availableGamepasses)
end

function ga:startNewSession(player: Player, gaData)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end

		if not state.Initialized then
			logger:w("Cannot start new session. SDK is not initialized yet.")
			return
		end

		state:startNewSession(player, gaData)
	end)
end

function ga:endSession(playerId: number)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		state:endSession(playerId)
	end)
end

function ga:filterForBusinessEvent(text: string)
	return string.gsub(text, "[^A-Za-z0-9%s%-_%.%(%)!%?]", "")
end

function ga:addBusinessEvent(playerId: number | BusinessEventOptions, options: BusinessEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add business event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addBusinessEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addBusinessEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local amount = options["amount"] or 0
		local itemType = options["itemType"] or ""
		local itemId = options["itemId"] or ""
		local cartType = options["cartType"] or ""
		local USDSpent = math.floor((amount * 0.7) * 0.35)
		local gamepassId = options["gamepassId"] or nil
		local customFields = options["customFields"]

		events:addBusinessEvent(playerId, "USD", USDSpent, itemType, itemId, cartType, customFields)

		if itemType == "Gamepass" and cartType ~= "Website" then
			local player = Players:GetPlayerByUserId(playerId)
			local playerData = store:GetPlayerDataFromCache(playerId)
			if not playerData.OwnedGamepasses then
				playerData.OwnedGamepasses = {}
			end
			table.insert(playerData.OwnedGamepasses, gamepassId)
			store.PlayerCache[playerId] = playerData
			store:SavePlayerData(player)
		end
	end)
end

function ga:addResourceEvent(playerId: number | ResourceEventOptions, options: ResourceEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add resource event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addResourceEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addResourceEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local flowType = options["flowType"] or 0
		local currency = options["currency"] or ""
		local amount = options["amount"] or 0
		local itemType = options["itemType"] or ""
		local itemId = options["itemId"] or ""
		local customFields = options["customFields"]

		events:addResourceEvent(playerId, flowType, currency, amount, itemType, itemId, customFields)
	end)
end

function ga:addProgressionEvent(playerId: number | ProgressionEventOptions, options: ProgressionEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add progression event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addProgressionEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addProgressionEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local progressionStatus = options["progressionStatus"] or 0
		local progression01 = options["progression01"] or ""
		local progression02 = options["progression02"] or nil
		local progression03 = options["progression03"] or nil
		local score = options["score"] or nil
		local customFields = options["customFields"]

		events:addProgressionEvent(
			playerId,
			progressionStatus,
			progression01,
			progression02,
			progression03,
			score,
			customFields
		)
	end)
end

function ga:addDesignEvent(playerId: number | DesignEventOptions, options: DesignEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add design event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addDesignEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addDesignEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local eventId = options["eventId"] or ""
		local value = options["value"] or nil
		local customFields = options["customFields"]

		events:addDesignEvent(playerId, eventId, value, customFields)
	end)
end

function ga:addErrorEvent(playerId: number | ErrorEventOptions, options: ErrorEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add error event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addErrorEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addErrorEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local severity = options["severity"] or 0
		local message = options["message"] or ""
		local customFields = options["customFields"]

		events:addErrorEvent(playerId, severity, message, customFields)
	end)
end

function ga:setEnabledDebugLog(flag: boolean)
	if RunService:IsStudio() then
		if flag then
			logger:setDebugLog(flag)
			logger:i("Debug logging enabled")
		else
			logger:i("Debug logging disabled")
			logger:setDebugLog(flag)
		end
	else
		logger:i("setEnabledDebugLog can only be used in studio")
	end
end

function ga:setEnabledInfoLog(flag: boolean)
	if flag then
		logger:setInfoLog(flag)
		logger:i("Info logging enabled")
	else
		logger:i("Info logging disabled")
		logger:setInfoLog(flag)
	end
end

function ga:setEnabledVerboseLog(flag: boolean)
	if flag then
		logger:setVerboseLog(flag)
		logger:ii("Verbose logging enabled")
	else
		logger:ii("Verbose logging disabled")
		logger:setVerboseLog(flag)
	end
end

function ga:setEnabledEventSubmission(flag: boolean)
	threading:performTaskOnGAThread(function()
		if flag then
			state:setEventSubmission(flag)
			logger:i("Event submission enabled")
		else
			logger:i("Event submission disabled")
			state:setEventSubmission(flag)
		end
	end)
end

function ga:setCustomDimension01(playerId: number | CustomDimension, dimension: CustomDimension?)
	threading:performTaskOnGAThread(function()
		if not validation:validateDimension(state._availableCustomDimensions01, dimension) then
			logger:w(
				"Could not set custom01 dimension value to '"
					.. (dimension or "")
					.. "'. Value not found in available custom01 dimension values"
			)
			return
		end

		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = true,
				message = "Could not set custom01 dimension",
			})
		then
			return
		end

		state:setCustomDimension01(playerId, dimension)
	end)
end

function ga:setCustomDimension02(playerId: number | CustomDimension, dimension: CustomDimension?)
	threading:performTaskOnGAThread(function()
		if not validation:validateDimension(state._availableCustomDimensions02, dimension) then
			logger:w(
				"Could not set custom02 dimension value to '"
					.. (dimension or "")
					.. "'. Value not found in available custom02 dimension values"
			)
			return
		end

		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = true,
				message = "Could not set custom02 dimension",
			})
		then
			return
		end

		state:setCustomDimension02(playerId, dimension)
	end)
end

function ga:setCustomDimension03(playerId: number | CustomDimension, dimension: CustomDimension?)
	threading:performTaskOnGAThread(function()
		if not validation:validateDimension(state._availableCustomDimensions03, dimension) then
			logger:w(
				"Could not set custom03 dimension value to '"
					.. (dimension or "")
					.. "'. Value not found in available custom03 dimension values"
			)
			return
		end

		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = true,
				message = "Could not set custom03 dimension",
			})
		then
			return
		end

		state:setCustomDimension03(playerId, dimension)
	end)
end

function ga:setEnabledReportErrors(flag: boolean)
	threading:performTaskOnGAThread(function()
		state.ReportErrors = flag
	end)
end

function ga:setEnabledCustomUserId(flag: boolean)
	threading:performTaskOnGAThread(function()
		state.UseCustomUserId = flag
	end)
end

function ga:setEnabledAutomaticSendBusinessEvents(flag: boolean)
	threading:performTaskOnGAThread(function()
		state.AutomaticSendBusinessEvents = flag
	end)
end

function ga:addGameAnalyticsTeleportData(playerIds: { number }, teleportData: TeleportData)
	local gameAnalyticsTeleportData = {}
	for _, playerId in ipairs(playerIds) do
		local PlayerData = store:GetPlayerDataFromCache(playerId)
		PlayerData.PlayerTeleporting = true
		local data = {
			["SessionID"] = PlayerData.SessionID,
			["Sessions"] = PlayerData.Sessions,
			["SessionStart"] = PlayerData.SessionStart,
		}

		gameAnalyticsTeleportData[tostring(playerId)] = data
	end

	teleportData["gameanalyticsData"] = gameAnalyticsTeleportData

	return teleportData
end

function ga:getRemoteConfigsValueAsString(playerId: number | RemoteConfigs, options: RemoteConfigs)
	local key = options["key"] or ""
	local defaultValue = options["defaultValue"] or nil
	return state:getRemoteConfigsStringValue(playerId, key, defaultValue)
end

function ga:isRemoteConfigsReady(playerId: number)
	return state:isRemoteConfigsReady(playerId)
end

function ga:getRemoteConfigsContentAsString(playerId: number)
	return state:getRemoteConfigsContentAsString(playerId)
end

function ga:PlayerJoined(Player: Player)
	local joinData = Player:GetJoinData()
	local teleportData = joinData.TeleportData
	local gaData = nil

	--Variables
	local PlayerData = store:GetPlayerData(Player)

	if teleportData and typeof(teleportData) == "table" then
		gaData = teleportData.gameanalyticsData and teleportData.gameanalyticsData[tostring(Player.UserId)]
	end

	local pd = store:GetPlayerDataFromCache(Player.UserId)
	if pd then
		if gaData then
			pd.SessionID = gaData.SessionID
			pd.SessionStart = gaData.SessionStart
		end
		pd.PlayerTeleporting = false
		return
	end

	local PlayerPlatform = "unknown"
	local isGetPlatformSuccessful, platform = Postie.invokeClient("getPlatform", Player, 5)
	if isGetPlatformSuccessful then
		PlayerPlatform = platform
	end

	--Fill Data
	for key, value in pairs(store.BasePlayerData) do
		if PlayerData[key] then
			continue
		end

		if typeof(value) == "table" then
			PlayerData[key] = utilities:copyTable(value)
		else
			PlayerData[key] = value
		end
	end

	local countryCodeResult, countryCode = pcall(function()
		return LocalizationService:GetCountryRegionForPlayerAsync(Player)
	end)

	if countryCodeResult then
		PlayerData.CountryCode = countryCode
	end

	store.PlayerCache[Player.UserId] = PlayerData

	PlayerData.Platform = (PlayerPlatform == "Console" and "uwp_console")
		or (PlayerPlatform == "Mobile" and "uwp_mobile")
		or (PlayerPlatform == "Desktop" and "uwp_desktop")
		or "uwp_desktop"
	PlayerData.OS = PlayerData.Platform .. " 0.0.0"

	if not countryCodeResult then
		events:addSdkErrorEvent(
			Player.UserId,
			"event_validation",
			"player_joined",
			"string_empty_or_null",
			"country_code",
			""
		)
	end

	local PlayerCustomUserId = ""
	if state.UseCustomUserId then
		local isGetCustomUserIdSuccessful, customUserId = Postie.invokeClient("getCustomUserId", Player, 5)
		if isGetCustomUserIdSuccessful then
			PlayerCustomUserId = customUserId
		end
	end

	if not utilities:isStringNullOrEmpty(PlayerCustomUserId) then
		logger:i("Using custom id: " .. PlayerCustomUserId)
		PlayerData.CustomUserId = PlayerCustomUserId
	end

	ga:startNewSession(Player, gaData)

	OnPlayerReadyEvent = OnPlayerReadyEvent or ReplicatedStorage:WaitForChild("OnPlayerReadyEvent")
	OnPlayerReadyEvent:Fire(Player)

	--Validate
	if state.AutomaticSendBusinessEvents then
		--Website gamepasses
		if PlayerData.OwnedGamepasses == nil then --player is new (or is playing after SDK update)
			PlayerData.OwnedGamepasses = {}
			for _, id in ipairs(state._availableGamepasses) do
				if MKT:UserOwnsGamePassAsync(Player.UserId, id) then
					table.insert(PlayerData.OwnedGamepasses, id)
				end
			end
			--Player's data is now up to date. gamepass purchases on website can now be tracked in future visits
			store.PlayerCache[Player.UserId] = PlayerData
			store:SavePlayerData(Player)
		else
			--build a list of the game passes a user owns
			local currentlyOwned = {}
			for _, id in ipairs(state._availableGamepasses) do
				if MKT:UserOwnsGamePassAsync(Player.UserId, id) then
					table.insert(currentlyOwned, id)
				end
			end

			--make a table so it's easier to compare to stored game passes
			local storedGamepassesTable = {}
			for _, id in ipairs(PlayerData.OwnedGamepasses) do
				storedGamepassesTable[id] = true
			end

			--compare stored game passes to currently owned game passses
			for _, id in ipairs(currentlyOwned) do
				if not storedGamepassesTable[id] then
					table.insert(PlayerData.OwnedGamepasses, id)

					local gamepassInfo = ProductCache[id]

					--Cache
					if not gamepassInfo then
						--Get
						gamepassInfo = MKT:GetProductInfo(id, Enum.InfoType.GamePass)
						ProductCache[id] = gamepassInfo
					end

					ga:addBusinessEvent(Player.UserId, {
						amount = gamepassInfo.PriceInRobux,
						itemType = "Gamepass",
						itemId = ga:filterForBusinessEvent(gamepassInfo.Name),
						cartType = "Website",
					})
				end
			end

			store.PlayerCache[Player.UserId] = PlayerData

			store:SavePlayerData(Player)
		end
	end

	local playerEventQueue = InitializationQueueByUserId[Player.UserId]
	if playerEventQueue then
		InitializationQueueByUserId[Player.UserId] = nil
		for _, queuedFunction in ipairs(playerEventQueue) do
			queuedFunction.Func(unpack(queuedFunction.Args))
		end

		logger:i("Player initialization queue called #" .. #playerEventQueue .. " events")
	end
end

function ga:PlayerRemoved(Player: Player)
	--Save
	store:SavePlayerData(Player)

	local PlayerData = store:GetPlayerDataFromCache(Player.UserId)
	if PlayerData then
		if not PlayerData.PlayerTeleporting then
			ga:endSession(Player.UserId)
		else
			store.PlayerCache[Player.UserId] = nil
			store.DataStoreQueue.RemoveKey(Player.UserId)
		end
	end
end

function ga:isPlayerReady(playerId: number)
	if store:GetPlayerDataFromCache(playerId) then
		return true
	else
		return false
	end
end

function ga:ProcessReceiptCallback(Info: ProcessReceiptInfo)
	--Variables
	local ProductInfo = ProductCache[Info.ProductId] :: ProductInfo?

	--Cache
	if not ProductInfo then
		pcall(function()
			ProductInfo = MKT:GetProductInfo(Info.ProductId, Enum.InfoType.Product)
			ProductCache[Info.ProductId] = ProductInfo
		end)
	end

	if ProductInfo then
		ga:addBusinessEvent(Info.PlayerId, {
			amount = Info.CurrencySpent,
			itemType = "DeveloperProduct",
			itemId = ga:filterForBusinessEvent(ProductInfo.Name),
		})
	end
end

--customGamepassInfo argument to optinaly provide our own name or price
function ga:GamepassPurchased(player: Player, id: number, customGamepassInfo: ProductInfo?)
	local gamepassInfo = ProductCache[id]

	--Cache
	if not gamepassInfo then
		--Get
		gamepassInfo = MKT:GetProductInfo(id, Enum.InfoType.GamePass)
		ProductCache[id] = gamepassInfo
	end

	local amount = 0
	local itemId = "GamePass"
	if customGamepassInfo then
		amount = customGamepassInfo.PriceInRobux
		itemId = customGamepassInfo.Name
	elseif gamepassInfo then
		amount = gamepassInfo.PriceInRobux
		itemId = gamepassInfo.Name
	end

	ga:addBusinessEvent(player.UserId, {
		amount = amount or 0,
		itemType = "Gamepass",
		itemId = ga:filterForBusinessEvent(itemId),
		gamepassId = id,
	})
end

local requiredInitializationOptions = { "gameKey", "secretKey" }

function ga:initServer(gameKey: string, secretKey: string)
	ga:initialize({
		gameKey = gameKey,
		secretKey = secretKey,
	})
end

function ga:initialize(options: GameAnalyticsOptions)
	threading:performTaskOnGAThread(function()
		for _, option in ipairs(requiredInitializationOptions) do
			if options[option] == nil then
				logger:e("Initialize '" .. option .. "' option missing")
				return
			end
		end
		if options.enableInfoLog ~= nil and options.enableInfoLog then
			ga:setEnabledInfoLog(options.enableInfoLog)
		end
		if options.enableVerboseLog ~= nil and options.enableVerboseLog then
			ga:setEnabledVerboseLog(options.enableVerboseLog)
		end
		if options.availableCustomDimensions01 ~= nil and #options.availableCustomDimensions01 > 0 then
			ga:configureAvailableCustomDimensions01(options.availableCustomDimensions01)
		end
		if options.availableCustomDimensions02 ~= nil and #options.availableCustomDimensions02 > 0 then
			ga:configureAvailableCustomDimensions02(options.availableCustomDimensions02)
		end
		if options.availableCustomDimensions03 ~= nil and #options.availableCustomDimensions03 > 0 then
			ga:configureAvailableCustomDimensions03(options.availableCustomDimensions03)
		end
		if options.availableResourceCurrencies ~= nil and #options.availableResourceCurrencies > 0 then
			ga:configureAvailableResourceCurrencies(options.availableResourceCurrencies)
		end
		if options.availableResourceItemTypes ~= nil and #options.availableResourceItemTypes > 0 then
			ga:configureAvailableResourceItemTypes(options.availableResourceItemTypes)
		end
		if options.build ~= nil and #options.build > 0 then
			ga:configureBuild(options.build)
		end
		if options.availableGamepasses ~= nil and #options.availableGamepasses > 0 then
			ga:configureAvailableGamepasses(options.availableGamepasses)
		end
		if options.enableDebugLog ~= nil then
			ga:setEnabledDebugLog(options.enableDebugLog)
		end

		if options.automaticSendBusinessEvents ~= nil then
			ga:setEnabledAutomaticSendBusinessEvents(options.automaticSendBusinessEvents)
		end
		if options.reportErrors ~= nil then
			ga:setEnabledReportErrors(options.reportErrors)
		end

		if options.useCustomUserId ~= nil then
			ga:setEnabledCustomUserId(options.useCustomUserId)
		end

		if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
			logger:w("SDK already initialized. Can only be called once.")
			return
		end

		local gameKey = options["gameKey"]
		local secretKey = options["secretKey"]

		if not validation:validateKeys(gameKey, secretKey) then
			logger:w(
				"SDK failed initialize. Game key or secret key is invalid. Can only contain characters A-z 0-9, gameKey is 32 length, secretKey is 40 length. Failed keys - gameKey: "
					.. gameKey
					.. ", secretKey: "
					.. secretKey
			)
			return
		end

		events.GameKey = gameKey
		events.SecretKey = secretKey

		state.Initialized = true

		-- New Players
		Players.PlayerAdded:Connect(function(Player)
			ga:PlayerJoined(Player)
		end)

		-- Players leaving
		Players.PlayerRemoving:Connect(function(Player)
			ga:PlayerRemoved(Player)
		end)

		-- Fire for players already in game
		for _, Player in ipairs(Players:GetPlayers()) do
			coroutine.wrap(ga.PlayerJoined)(ga, Player)
		end

		for _, queuedFunction in ipairs(InitializationQueue) do
			task.spawn(queuedFunction.Func, unpack(queuedFunction.Args))
		end
		logger:i("Server initialization queue called #" .. #InitializationQueue .. " events")
		InitializationQueue = {}

		events:processEventQueue()
	end)
end

if not ReplicatedStorage:FindFirstChild("GameAnalyticsRemoteConfigs") then
	--Create
	local f = Instance.new("RemoteEvent")
	f.Name = "GameAnalyticsRemoteConfigs"
	f.Parent = ReplicatedStorage
end

if not ReplicatedStorage:FindFirstChild("OnPlayerReadyEvent") then
	--Create
	local f = Instance.new("BindableEvent")
	f.Name = "OnPlayerReadyEvent"
	f.Parent = ReplicatedStorage
end

task.spawn(function()
	local currentHour = math.floor(os.time() / 3600)
	ErrorDS = store:GetErrorDataStore(currentHour)

	while task.wait(ONE_HOUR_IN_SECONDS) do
		currentHour = math.floor(os.time() / 3600)
		ErrorDS = store:GetErrorDataStore(currentHour)
		errorCountCache = {}
		errorCountCacheKeys = {}
	end
end)

task.spawn(function()
	while task.wait(store.AutoSaveData) do
		for _, key in pairs(errorCountCacheKeys) do
			local errorCount = errorCountCache[key]
			local step = errorCount.currentCount - errorCount.countInDS
			errorCountCache[key].countInDS = store:IncrementErrorCount(ErrorDS, key, step)
			errorCountCache[key].currentCount = errorCountCache[key].countInDS
		end
	end
end)

local function ErrorHandler(message, trace, scriptName, player)
	local scriptNameTmp = "(null)"
	if scriptName ~= nil then
		scriptNameTmp = scriptName
	end
	local messageTmp = "(null)"
	if message ~= nil then
		messageTmp = message
	end
	local traceTmp = "(null)"
	if trace ~= nil then
		traceTmp = trace
	end
	local m = scriptNameTmp .. ": message=" .. messageTmp .. ", trace=" .. traceTmp
	if #m > 8192 then
		m = string.sub(m, 1, 8192)
	end

	local userId = nil
	if player then
		userId = player.UserId
		m = m:gsub(player.Name, "[LocalPlayer]") -- so we don't flood the same errors with different player names
	end

	local key = m
	if #key > 50 then
		key = string.sub(key, 1, 50)
	end

	if errorCountCache[key] == nil then
		errorCountCacheKeys[#errorCountCacheKeys + 1] = key
		errorCountCache[key] = {}
		errorCountCache[key].countInDS = 0
		errorCountCache[key].currentCount = 0
	end

	-- don't report error if limit has been exceeded
	if errorCountCache[key].currentCount > MaxErrorsPerHour then
		return
	end

	ga:addErrorEvent(userId, {
		severity = ga.EGAErrorSeverity.error,
		message = m,
	})

	-- increment error count
	errorCountCache[key].currentCount = errorCountCache[key].currentCount + 1
end

local function ErrorHandlerFromServer(message, trace, Script)
	--Validate
	if not state.ReportErrors then
		return
	end

	if not Script then -- don't remember if this check is necessary but must have added it for a reason
		return
	end

	local scriptName = nil
	local ok, _ = pcall(function()
		scriptName = Script:GetFullName() -- CoreGui.RobloxGui.Modules.PlayerList error, can't get name because of security permission
	end)
	if not ok then
		return
	end

	return ErrorHandler(message, trace, scriptName)
end

local function ErrorHandlerFromClient(message, trace, scriptName, player)
	--Validate
	if not state.ReportErrors then
		return
	end

	return ErrorHandler(message, trace, scriptName, player)
end

--Error Logging
ScriptContext.Error:Connect(ErrorHandlerFromServer)
if not ReplicatedStorage:FindFirstChild("GameAnalyticsError") then
	--Create
	local f = Instance.new("RemoteEvent")
	f.Name = "GameAnalyticsError"
	f.Parent = ReplicatedStorage
end

ReplicatedStorage.GameAnalyticsError.OnServerEvent:Connect(function(player, message, trace, scriptName)
	ErrorHandlerFromClient(message, trace, scriptName, player)
end)

--Record Gamepasses.
MKT.PromptGamePassPurchaseFinished:Connect(function(Player, ID, Purchased)
	--Validate
	if not state.AutomaticSendBusinessEvents or not Purchased then
		return
	end

	ga:GamepassPurchased(Player, ID)
end)

return ga]]></ProtectedString>
							<string name="ScriptGuid">{A7DF1804-49EB-4EA7-B0E3-21E965BBD6BB}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">GameAnalytics.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX040639C8F2E144E6BA162D926F1087E3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">GameAnalytics</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX2A41581BA68045A3AFB019393AB6A0B0">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local events = {
	ProcessEventsInterval = 8,
	GameKey = "",
	SecretKey = "",
	Build = "",
	_availableResourceCurrencies = {},
	_availableResourceItemTypes = {},
}

local store = require(script.Parent.Store)
local logger = require(script.Parent.Logger)
local version = require(script.Parent.Version)
local validation = require(script.Parent.Validation)
local threading = require(script.Parent.Threading)
local http_api = require(script.Parent.HttpApi)
local utilities = require(script.Parent.Utilities)
local GAResourceFlowType = require(script.Parent.GAResourceFlowType)
local GAProgressionStatus = require(script.Parent.GAProgressionStatus)
local GAErrorSeverity = require(script.Parent.GAErrorSeverity)
local HTTP = game:GetService("HttpService")

local CategorySessionStart = "user"
local CategorySessionEnd = "session_end"
local CategoryBusiness = "business"
local CategoryResource = "resource"
local CategoryProgression = "progression"
local CategoryDesign = "design"
local CategoryError = "error"
local CategorySdkError = "sdk_error"
local MAX_EVENTS_TO_SEND_IN_ONE_BATCH = 500
local MAX_AGGREGATED_EVENTS = 2000

local function addCustomFieldsToEvent(eventData, customFields)
	if not (eventData and customFields) then
		return
	end

	local fields = {}

	for key, value in pairs(customFields) do
		local v = tostring(value)
		if #v > 256 then
			logger:w("Custom field value is too long. Max length is 256 characters. Field: " .. key)
			v = string.sub(v, 1, 256)
		end

		fields[key] = v
	end

	if fields and next(fields) then
		eventData["custom_fields"] = fields
	end
end

local function addDimensionsToEvent(playerId, eventData)
	if not eventData or not playerId then
		return
	end

	local PlayerData = store:GetPlayerDataFromCache(playerId)

	-- add to dict (if not nil)
	if PlayerData and PlayerData.CurrentCustomDimension01 and #PlayerData.CurrentCustomDimension01 > 0 then
		eventData["custom_01"] = PlayerData.CurrentCustomDimension01
	end

	if PlayerData and PlayerData.CurrentCustomDimension02 and #PlayerData.CurrentCustomDimension02 > 0 then
		eventData["custom_02"] = PlayerData.CurrentCustomDimension02
	end

	if PlayerData and PlayerData.CurrentCustomDimension03 and #PlayerData.CurrentCustomDimension03 > 0 then
		eventData["custom_03"] = PlayerData.CurrentCustomDimension03
	end
end

local function getClientTsAdjusted(playerId)
	if not playerId then
		return os.time()
	end

	local PlayerData = store:GetPlayerDataFromCache(playerId)
	local clientTs = os.time()
	local clientTsAdjustedInteger = clientTs + PlayerData.ClientServerTimeOffset
	if validation:validateClientTs(clientTsAdjustedInteger) then
		return clientTsAdjustedInteger
	else
		return clientTs
	end
end

local DUMMY_SESSION_ID = HTTP:GenerateGUID(false):lower()

local function Length(Table)
	local counter = 0
	for _, _ in pairs(Table) do
		counter += 1
	end
	return counter
end

local function getEventAnnotations(playerId)
	local PlayerData
	local id

	if playerId then
		id = playerId
		PlayerData = store:GetPlayerDataFromCache(playerId)
	else
		id = "DummyId"
		PlayerData = {
			OS = "uwp_desktop 0.0.0",
			Platform = "uwp_desktop",
			SessionID = DUMMY_SESSION_ID,
			Sessions = 1,
			CustomUserId = "Server",
		}
	end

	local annotations = {
		-- ---- REQUIRED ----
		-- collector event API version
		["v"] = 2,
		-- User identifier
		["user_id"] = tostring(id) .. PlayerData.CustomUserId,
		-- Client Timestamp (the adjusted timestamp)
		["client_ts"] = getClientTsAdjusted(playerId),
		-- SDK version
		["sdk_version"] = "roblox " .. version.SdkVersion,
		-- Operation system version
		["os_version"] = PlayerData.OS,
		-- Device make (hardcoded to apple)
		["manufacturer"] = "unknown",
		-- Device version
		["device"] = "unknown",
		-- Platform (operating system)
		["platform"] = PlayerData.Platform,
		-- Session identifier
		["session_id"] = PlayerData.SessionID,
		-- Session number
		["session_num"] = PlayerData.Sessions,
	}

	if not utilities:isStringNullOrEmpty(PlayerData.CountryCode) then
		annotations["country_code"] = PlayerData.CountryCode
	else
		annotations["country_code"] = "unknown"
	end

	if validation:validateBuild(events.Build) then
		annotations["build"] = events.Build
	end

	if PlayerData.Configurations and Length(PlayerData.Configurations) > 0 then
		annotations["configurations"] = PlayerData.Configurations
	end

	if not utilities:isStringNullOrEmpty(PlayerData.AbId) then
		annotations["ab_id"] = PlayerData.AbId
	end

	if not utilities:isStringNullOrEmpty(PlayerData.AbVariantId) then
		annotations["ab_variant_id"] = PlayerData.AbVariantId
	end

	return annotations
end

local function addEventToStore(playerId, eventData)
	-- Get default annotations
	local ev = getEventAnnotations(playerId)

	-- Merge with eventData
	for k in pairs(eventData) do
		ev[k] = eventData[k]
	end

	-- Create json string representation
	local json = HTTP:JSONEncode(ev)

	-- output if VERBOSE LOG enabled
	logger:ii("Event added to queue: " .. json)

	-- Add to store
	store.EventsQueue[#store.EventsQueue + 1] = ev
end

local function dequeueMaxEvents()
	if #store.EventsQueue <= MAX_EVENTS_TO_SEND_IN_ONE_BATCH then
		local eventsQueue = store.EventsQueue
		store.EventsQueue = {}
		return eventsQueue
	else
		logger:w(
			("More than %d events queued! Sending %d."):format(
				MAX_EVENTS_TO_SEND_IN_ONE_BATCH,
				MAX_EVENTS_TO_SEND_IN_ONE_BATCH
			)
		)

		if #store.EventsQueue > MAX_AGGREGATED_EVENTS then
			logger:w(("DROPPING EVENTS: More than %d events queued!"):format(MAX_AGGREGATED_EVENTS))
		end

		-- Expensive operation to get ordered events cleared out (O(n))
		local eventsQueue = table.create(MAX_EVENTS_TO_SEND_IN_ONE_BATCH)
		for i = 1, MAX_EVENTS_TO_SEND_IN_ONE_BATCH do
			eventsQueue[i] = store.EventsQueue[i]
		end

		-- Shift everything down and overwrite old events
		local eventCount = #store.EventsQueue
		for i = 1, math.min(MAX_AGGREGATED_EVENTS, eventCount) do
			store.EventsQueue[i] = store.EventsQueue[i + MAX_EVENTS_TO_SEND_IN_ONE_BATCH]
		end

		-- Clear additional events
		for i = MAX_AGGREGATED_EVENTS + 1, eventCount do
			store.EventsQueue[i] = nil
		end

		return eventsQueue
	end
end

local function processEvents()
	local queue = dequeueMaxEvents()

	if #queue == 0 then
		logger:i("Event queue: No events to send")
		return
	end

	-- Log
	logger:i("Event queue: Sending " .. tostring(#queue) .. " events.")

	local eventsResult = http_api:sendEventsInArray(events.GameKey, events.SecretKey, queue)
	local statusCode = eventsResult.statusCode
	local responseBody = eventsResult.body

	if statusCode == http_api.EGAHTTPApiResponse.Ok and responseBody then
		logger:i("Event queue: " .. tostring(#queue) .. " events sent.")
	else
		if statusCode == http_api.EGAHTTPApiResponse.NoResponse then
			logger:w("Event queue: Failed to send events to collector - Retrying next time")
			for _, e in pairs(queue) do
				if #store.EventsQueue < MAX_AGGREGATED_EVENTS then
					store.EventsQueue[#store.EventsQueue + 1] = e
				else
					break
				end
			end
		else
			if statusCode == http_api.EGAHTTPApiResponse.BadRequest and responseBody then
				logger:w(
					"Event queue: "
						.. tostring(#queue)
						.. " events sent. "
						.. tostring(#responseBody)
						.. " events failed GA server validation."
				)
			else
				logger:w("Event queue: Failed to send events.")
			end
		end
	end
end

function events:processEventQueue()
	processEvents()
	threading:scheduleTimer(events.ProcessEventsInterval, function()
		events:processEventQueue()
	end)
end

function events:setBuild(build)
	if not validation:validateBuild(build) then
		logger:w("Validation fail - configure build: Cannot be null, empty or above 32 length. String: " .. build)
		return
	end

	self.Build = build
	logger:i("Set build version: " .. build)
end

function events:setAvailableResourceCurrencies(availableResourceCurrencies)
	if not validation:validateResourceCurrencies(availableResourceCurrencies) then
		return
	end

	self._availableResourceCurrencies = availableResourceCurrencies
	logger:i("Set available resource currencies: (" .. table.concat(availableResourceCurrencies, ", ") .. ")")
end

function events:setAvailableResourceItemTypes(availableResourceItemTypes)
	if not validation:validateResourceCurrencies(availableResourceItemTypes) then
		return
	end

	self._availableResourceItemTypes = availableResourceItemTypes
	logger:i("Set available resource item types: (" .. table.concat(availableResourceItemTypes, ", ") .. ")")
end

function events:addSessionStartEvent(playerId, teleportData, customFields)
	local PlayerData = store:GetPlayerDataFromCache(playerId)

	if teleportData then
		PlayerData.Sessions = teleportData.Sessions
	else
		local eventDict = {}

		-- Event specific data
		eventDict["category"] = CategorySessionStart

		-- Increment session number  and persist
		PlayerData.Sessions = PlayerData.Sessions + 1

		--  Add custom dimensions
		addDimensionsToEvent(playerId, eventDict)

		-- Add to store
		addEventToStore(playerId, eventDict)
		addCustomFieldsToEvent(eventDict, customFields)

		logger:i("Add SESSION START event")

		processEvents()
	end
end

function events:addSessionEndEvent(playerId, customFields)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	local session_start_ts = PlayerData.SessionStart
	local client_ts_adjusted = getClientTsAdjusted(playerId)
	local sessionLength = 0

	if client_ts_adjusted ~= nil and session_start_ts ~= nil then
		sessionLength = client_ts_adjusted - session_start_ts
	end

	if sessionLength < 0 then
		-- Should never happen.
		-- Could be because of edge cases regarding time altering on device.
		logger:w("Session length was calculated to be less then 0. Should not be possible. Resetting to 0.")
		sessionLength = 0
	end

	-- Event specific data
	local eventDict = {}
	eventDict["category"] = CategorySessionEnd
	eventDict["length"] = sessionLength

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventDict)
	addCustomFieldsToEvent(eventDict, customFields)

	-- Add to store
	addEventToStore(playerId, eventDict)
	PlayerData.SessionStart = 0

	logger:i("Add SESSION END event.")

	processEvents()
end

function events:addBusinessEvent(playerId, currency, amount, itemType, itemId, cartType, customFields)
	-- Validate event params
	if not validation:validateBusinessEvent(currency, amount, cartType, itemType, itemId) then
		-- TODO: add sdk error event
		return
	end

	-- Create empty eventData
	local eventDict = {}

	-- Increment transaction number and persist
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	PlayerData.Transactions = PlayerData.Transactions + 1

	-- Required
	eventDict["event_id"] = itemType .. ":" .. itemId
	eventDict["category"] = CategoryBusiness
	eventDict["currency"] = currency
	eventDict["amount"] = amount
	eventDict["transaction_num"] = PlayerData.Transactions

	-- Optional
	if not utilities:isStringNullOrEmpty(cartType) then
		eventDict["cart_type"] = cartType
	end

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventDict)
	addCustomFieldsToEvent(eventDict, customFields)

	logger:i(
		"Add BUSINESS event: {currency:"
			.. currency
			.. ", amount:"
			.. tostring(amount)
			.. ", itemType:"
			.. itemType
			.. ", itemId:"
			.. itemId
			.. ", cartType:"
			.. cartType
			.. "}"
	)

	-- Send to store
	addEventToStore(playerId, eventDict)
end

function events:addResourceEvent(playerId, flowType, currency, amount, itemType, itemId, customFields)
	-- Validate event params
	if
		not validation:validateResourceEvent(
			GAResourceFlowType,
			flowType,
			currency,
			amount,
			itemType,
			itemId,
			self._availableResourceCurrencies,
			self._availableResourceItemTypes
		)
	then
		-- TODO: add sdk error event
		return
	end

	-- If flow type is sink reverse amount
	if flowType == GAResourceFlowType.Sink then
		amount = (-1 * amount)
	end

	-- Create empty eventData
	local eventDict = {}

	-- insert event specific values
	local flowTypeString = GAResourceFlowType[flowType]
	eventDict["event_id"] = flowTypeString .. ":" .. currency .. ":" .. itemType .. ":" .. itemId
	eventDict["category"] = CategoryResource
	eventDict["amount"] = amount

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventDict)
	addCustomFieldsToEvent(eventDict, customFields)

	logger:i(
		"Add RESOURCE event: {currency:"
			.. currency
			.. ", amount:"
			.. tostring(amount)
			.. ", itemType:"
			.. itemType
			.. ", itemId:"
			.. itemId
			.. "}"
	)

	-- Send to store
	addEventToStore(playerId, eventDict)
end

function events:addProgressionEvent(
	playerId,
	progressionStatus,
	progression01,
	progression02,
	progression03,
	score,
	customFields
)
	-- Validate event params
	if
		not validation:validateProgressionEvent(
			GAProgressionStatus,
			progressionStatus,
			progression01,
			progression02,
			progression03
		)
	then
		-- TODO: add sdk error event
		return
	end

	-- Create empty eventData
	local eventDict = {}

	-- Progression identifier
	local progressionIdentifier
	if utilities:isStringNullOrEmpty(progression02) then
		progressionIdentifier = progression01
	elseif utilities:isStringNullOrEmpty(progression03) then
		progressionIdentifier = progression01 .. ":" .. progression02
	else
		progressionIdentifier = progression01 .. ":" .. progression02 .. ":" .. progression03
	end

	local statusString = GAProgressionStatus[progressionStatus]

	-- Append event specifics
	eventDict["category"] = CategoryProgression
	eventDict["event_id"] = statusString .. ":" .. progressionIdentifier

	-- Attempt
	local attempt_num = 0

	-- Add score if specified and status is not start
	if score ~= nil and progressionStatus ~= GAProgressionStatus.Start then
		eventDict["score"] = score
	end

	local PlayerData = store:GetPlayerDataFromCache(playerId)

	-- Count attempts on each progression fail and persist
	if progressionStatus == GAProgressionStatus.Fail then
		-- Increment attempt number
		local progressionTries = PlayerData.ProgressionTries[progressionIdentifier] or 0
		PlayerData.ProgressionTries[progressionIdentifier] = progressionTries + 1
	end

	-- increment and add attempt_num on complete and delete persisted
	if progressionStatus == GAProgressionStatus.Complete then
		-- Increment attempt number
		local progressionTries = PlayerData.ProgressionTries[progressionIdentifier] or 0
		PlayerData.ProgressionTries[progressionIdentifier] = progressionTries + 1

		-- Add to event
		attempt_num = PlayerData.ProgressionTries[progressionIdentifier]
		eventDict["attempt_num"] = attempt_num

		-- Clear
		PlayerData.ProgressionTries[progressionIdentifier] = 0
	end

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventDict)
	addCustomFieldsToEvent(eventDict, customFields)

	local progression02String = ""
	if not utilities:isStringNullOrEmpty(progression02) then
		progression02String = progression02
	end

	local progression03String = ""
	if not utilities:isStringNullOrEmpty(progression03) then
		progression03String = progression03
	end

	logger:i(
		"Add PROGRESSION event: {status:"
			.. statusString
			.. ", progression01:"
			.. progression01
			.. ", progression02:"
			.. progression02String
			.. ", progression03:"
			.. progression03String
			.. ", score:"
			.. tostring(score)
			.. ", attempt:"
			.. tostring(attempt_num)
			.. "}"
	)

	-- Send to store
	addEventToStore(playerId, eventDict)
end

function events:addDesignEvent(playerId, eventId, value, customFields)
	-- Validate
	if not validation:validateDesignEvent(eventId) then
		-- TODO: add sdk error event
		return
	end

	-- Create empty eventData
	local eventData = {}

	-- Append event specifics
	eventData["category"] = CategoryDesign
	eventData["event_id"] = eventId

	if value ~= nil then
		eventData["value"] = value
	end

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventData)
	addCustomFieldsToEvent(eventData, customFields)

	logger:i("Add DESIGN event: {eventId:" .. eventId .. ", value:" .. tostring(value) .. "}")

	-- Send to store
	addEventToStore(playerId, eventData)
end

function events:addErrorEvent(playerId, severity, message, customFields)
	-- Validate
	if not validation:validateErrorEvent(GAErrorSeverity, severity, message) then
		-- TODO: add sdk error event
		return
	end

	-- Create empty eventData
	local eventData = {}

	local severityString = GAErrorSeverity[severity]

	eventData["category"] = CategoryError
	eventData["severity"] = severityString
	eventData["message"] = message

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventData)
	addCustomFieldsToEvent(eventData, customFields)

	local messageString = ""
	if not utilities:isStringNullOrEmpty(message) then
		messageString = message
	end

	logger:i("Add ERROR event: {severity:" .. severityString .. ", message:" .. messageString .. "}")

	-- Send to store
	addEventToStore(playerId, eventData)
end

function events:addSdkErrorEvent(playerId, category, area, action, parameter, reason)
	-- Create empty eventData
	local eventData = {}

	eventData["category"] = CategorySdkError
	eventData["error_category"] = category
	eventData["error_area"] = area
	eventData["error_action"] = action

	if not utilities:isStringNullOrEmpty(parameter) then
		eventData["error_parameter"] = parameter
	end

	if not utilities:isStringNullOrEmpty(reason) then
		eventData["reason"] = reason
	end

	logger:i(
		"Add SDK ERROR event: {error_category:"
			.. category
			.. ", error_area:"
			.. area
			.. ", error_action:"
			.. action
			.. "}"
	)

	-- Send to store
	addEventToStore(playerId, eventData)
end

return events]]></ProtectedString>
								<string name="ScriptGuid">{C8144202-7BDF-411B-BB07-22435A6375EC}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Events.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX28B1C5844C954D89B29AD5004E7EEB73">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local function readonlytable(table)
	return setmetatable({}, {
		__index = table,
		__metatable = false,
		__newindex = function(t, k, v)
			error("Attempt to modify read-only table: " .. t .. ", key=" .. k .. ", value=" .. v)
		end,
	})
end

return readonlytable({
	debug = "debug",
	info = "info",
	warning = "warning",
	error = "error",
	critical = "critical",
})]]></ProtectedString>
								<string name="ScriptGuid">{AABABE3B-1132-4A1F-B2D2-93F1C6878DC2}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">GAErrorSeverity.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX05B6BF36674943A0A7C1BB83B470A509">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local function readonlytable(table)
	return setmetatable({}, {
		__index = table,
		__metatable = false,
		__newindex = function(t, k, v)
			error("Attempt to modify read-only table: " .. t .. ", key=" .. k .. ", value=" .. v)
		end,
	})
end

return readonlytable({
	Start = "Start",
	Complete = "Complete",
	Fail = "Fail",
})]]></ProtectedString>
								<string name="ScriptGuid">{D500DAA0-B91B-4F82-A76D-577DE6CFA918}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">GAProgressionStatus.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF806C6DE71AA4353A43BD81A5F87B84C">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local function readonlytable(table)
	return setmetatable({}, {
		__index = table,
		__metatable = false,
		__newindex = function(t, k, v)
			error("Attempt to modify read-only table: " .. t .. ", key=" .. k .. ", value=" .. v)
		end,
	})
end

return readonlytable({
	Source = "Source",
	Sink = "Sink",
})]]></ProtectedString>
								<string name="ScriptGuid">{6D81D566-2FFB-4B18-98B8-EDC77F882A06}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">GAResourceFlowType.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2B57696C1ECD4776BCC00D417B621131">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local validation = require(script.Parent.Validation)
local version = require(script.Parent.Version)

local HashLib = require(script.HashLib)

local http_api = {
	protocol = "https",
	hostName = "api.gameanalytics.com",
	version = "v2",
	remoteConfigsVersion = "v1",
	initializeUrlPath = "init",
	eventsUrlPath = "events",
	EGAHTTPApiResponse = {
		NoResponse = 0,
		BadResponse = 1,
		RequestTimeout = 2,
		JsonEncodeFailed = 3,
		JsonDecodeFailed = 4,
		InternalServerError = 5,
		BadRequest = 6,
		Unauthorized = 7,
		UnknownResponseCode = 8,
		Ok = 9,
		Created = 10,
	},
}

local HTTP = game:GetService("HttpService")
local logger = require(script.Parent.Logger)
local baseUrl = (RunService:IsStudio() and "https" or http_api.protocol)
	.. "://"
	.. (RunService:IsStudio() and "sandbox-" or "")
	.. http_api.hostName
	.. "/"
	.. http_api.version
local remoteConfigsBaseUrl = (RunService:IsStudio() and "https" or http_api.protocol)
	.. "://"
	.. (RunService:IsStudio() and "sandbox-" or "")
	.. http_api.hostName
	.. "/remote_configs/"
	.. http_api.remoteConfigsVersion

local function getInitAnnotations(build, playerData, playerId)
	local initAnnotations = {
		["user_id"] = tostring(playerId) .. playerData.CustomUserId,
		["sdk_version"] = "roblox " .. version.SdkVersion,
		["os_version"] = playerData.OS,
		["platform"] = playerData.Platform,
		["build"] = build,
		["session_num"] = playerData.Sessions,
		["random_salt"] = playerData.Sessions,
	}

	return initAnnotations
end

local function encode(payload, secretKey)
	--Validate
	if not secretKey then
		logger:w("Error encoding, invalid SecretKey")
		return
	end

	--Encode
	local payloadHmac = HashLib.hmac(
		HashLib.sha256,
		RunService:IsStudio() and "16813a12f718bc5c620f56944e1abc3ea13ccbac" or secretKey,
		payload,
		true
	)

	return HashLib.base64_encode(payloadHmac)
end

local function processRequestResponse(response, requestId)
	local statusCode = response.StatusCode
	local body = response.Body

	if not body or #body == 0 then
		logger:d(requestId .. " request. failed. Might be no connection. Status code: " .. tostring(statusCode))
		return http_api.EGAHTTPApiResponse.NoResponse
	end

	if statusCode == 200 then
		return http_api.EGAHTTPApiResponse.Ok
	elseif statusCode == 201 then
		return http_api.EGAHTTPApiResponse.Created
	elseif statusCode == 0 or statusCode == 401 then
		logger:d(requestId .. " request. 401 - Unauthorized.")
		return http_api.EGAHTTPApiResponse.Unauthorized
	elseif statusCode == 400 then
		logger:d(requestId .. " request. 400 - Bad Request.")
		return http_api.EGAHTTPApiResponse.BadRequest
	elseif statusCode == 500 then
		logger:d(requestId .. " request. 500 - Internal Server Error.")
		return http_api.EGAHTTPApiResponse.InternalServerError
	else
		return http_api.EGAHTTPApiResponse.UnknownResponseCode
	end
end

function http_api:initRequest(gameKey, secretKey, build, playerData, playerId)
	local url = remoteConfigsBaseUrl
		.. "/"
		.. http_api.initializeUrlPath
		.. "?game_key="
		.. gameKey
		.. "&interval_seconds=0&configs_hash="
		.. (playerData.ConfigsHash or "")
	if RunService:IsStudio() then
		url = baseUrl .. "/5c6bcb5402204249437fb5a7a80a4959/" .. self.initializeUrlPath
	end

	logger:d("Sending 'init' URL: " .. url)

	local payload = HTTP:JSONEncode(getInitAnnotations(build, playerData, playerId))
	payload = payload:gsub('"country_code":"unknown"', '"country_code":null')
	local authorization = encode(payload, secretKey)

	logger:d("init payload: " .. payload)

	local res
	local success, err = pcall(function()
		res = HTTP:RequestAsync({
			Url = url,
			Method = "POST",
			Headers = {
				["Authorization"] = authorization,
				["Content-Type"] = "application/json",
			},
			Body = payload,
		})
	end)

	if not success then
		logger:d("Failed Init Call. error: " .. err)
		return {
			statusCode = http_api.EGAHTTPApiResponse.UnknownResponseCode,
			body = nil,
		}
	end
	logger:d("init request content: " .. res.Body)

	local requestResponseEnum = processRequestResponse(res, "Init")

	-- if not 200 result
	if
		requestResponseEnum ~= http_api.EGAHTTPApiResponse.Ok
		and requestResponseEnum ~= http_api.EGAHTTPApiResponse.Created
		and requestResponseEnum ~= http_api.EGAHTTPApiResponse.BadRequest
	then
		logger:d(
			"Failed Init Call. URL: " .. url .. ", JSONString: " .. payload .. ", Authorization: " .. authorization
		)
		return {
			statusCode = requestResponseEnum,
			body = nil,
		}
	end

	--Response
	local responseBody
	success = pcall(function()
		responseBody = HTTP:JSONDecode(res.Body)
	end)

	if not success then
		logger:d("Failed Init Call. Json decoding failed: " .. err)
		return {
			statusCode = http_api.EGAHTTPApiResponse.JsonDecodeFailed,
			body = nil,
		}
	end

	-- print reason if bad request
	if requestResponseEnum == http_api.EGAHTTPApiResponse.BadRequest then
		logger:d("Failed Init Call. Bad request. Response: " .. res.Body)
		return {
			statusCode = requestResponseEnum,
			body = nil,
		}
	end

	-- validate Init call values
	local validatedInitValues = validation:validateAndCleanInitRequestResponse(
		responseBody,
		requestResponseEnum == http_api.EGAHTTPApiResponse.Created
	)

	if not validatedInitValues then
		return {
			statusCode = http_api.EGAHTTPApiResponse.BadResponse,
			body = nil,
		}
	end

	-- all ok
	return {
		statusCode = requestResponseEnum,
		body = responseBody,
	}
end

function http_api:sendEventsInArray(gameKey, secretKey, eventArray)
	if not eventArray or #eventArray == 0 then
		logger:d("sendEventsInArray called with missing eventArray")
		return
	end

	-- Generate URL
	local url = baseUrl .. "/" .. gameKey .. "/" .. self.eventsUrlPath
	if RunService:IsStudio() then
		url = baseUrl .. "/5c6bcb5402204249437fb5a7a80a4959/" .. self.eventsUrlPath
	end

	logger:d("Sending 'events' URL: " .. url)

	-- make JSON string from data
	local payload = HTTP:JSONEncode(eventArray)
	payload = payload:gsub('"country_code":"unknown"', '"country_code":null')
	local authorization = encode(payload, secretKey)

	local res
	local success, err = pcall(function()
		res = HTTP:RequestAsync({
			Url = url,
			Method = "POST",
			Headers = {
				["Authorization"] = authorization,
				["Content-Type"] = "application/json",
			},
			Body = payload,
		})
	end)

	if not success then
		logger:d("Failed Events Call. error: " .. err)
		return {
			statusCode = http_api.EGAHTTPApiResponse.UnknownResponseCode,
			body = nil,
		}
	end

	logger:d("body: " .. res.Body)
	local requestResponseEnum = processRequestResponse(res, "Events")

	-- if not 200 result
	if
		requestResponseEnum ~= http_api.EGAHTTPApiResponse.Ok
		and requestResponseEnum ~= http_api.EGAHTTPApiResponse.Created
		and requestResponseEnum ~= http_api.EGAHTTPApiResponse.BadRequest
	then
		logger:d(
			"Failed Events Call. URL: " .. url .. ", JSONString: " .. payload .. ", Authorization: " .. authorization
		)
		return {
			statusCode = requestResponseEnum,
			body = nil,
		}
	end

	local responseBody
	pcall(function()
		responseBody = HTTP:JSONDecode(res.Body)
	end)

	if not responseBody then
		logger:d("Failed Events Call. Json decoding failed")
		return {
			statusCode = http_api.EGAHTTPApiResponse.JsonDecodeFailed,
			body = nil,
		}
	end

	-- print reason if bad request
	if requestResponseEnum == http_api.EGAHTTPApiResponse.BadRequest then
		logger:d("Failed Events Call. Bad request. Response: " .. res.Body)
		return {
			statusCode = requestResponseEnum,
			body = nil,
		}
	end

	-- all ok
	return {
		statusCode = http_api.EGAHTTPApiResponse.Ok,
		body = responseBody,
	}
end

return http_api]]></ProtectedString>
								<string name="ScriptGuid">{97F8DB85-A36D-47C9-B2DE-245365EDABDA}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">HttpApi.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX9E79A34DC672465E83EB1ED0FBA29112">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">HttpApi</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX44E96927B9D744DB98A3F9E8F492A773">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[=[------------------------------------------------------------------------------------------------------------------------
-- HashLib by Egor Skriptunoff, boatbomber, and howmanysmall

Documentation here: https://devforum.roblox.com/t/open-source-hashlib/416732/1

--------------------------------------------------------------------------------------------------------------------------

Module was originally written by Egor Skriptunoff and distributed under an MIT license.
It can be found here: https://github.com/Egor-Skriptunoff/pure_lua_SHA/blob/master/sha2.lua

That version was around 3000 lines long, and supported Lua versions 5.1, 5.2, 5.3, and 5.4, and LuaJIT.
Although that is super cool, Roblox only uses Lua 5.1, so that was extreme overkill.

I, boatbomber, worked (with howmanysmall's guidance) to port it to Roblox in a way that
doesn't overcomplicate it with support of unreachable cases. Then, howmanysmall did some final optimizations
that really squeeze out all the performance possible.

After quite a bit of work and benchmarking, this is what we were left with.
Enjoy!

--------------------------------------------------------------------------------------------------------------------------

DESCRIPTION:
	This module contains functions to calculate SHA digest:
		MD5, SHA-1,
		SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,
		SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,
		HMAC
	Additionally, it has a few extra utility functions:
		hex_to_bin
		base64_to_bin
		bin_to_base64
	Written in pure Lua.
USAGE:
	Input data should be a string
	Result (SHA digest) is returned in hexadecimal representation as a string of lowercase hex digits.
	Simplest usage example:
		local HashLib = require(script.HashLib)
		local your_hash = HashLib.sha256("your string")
API:
		HashLib.md5
		HashLib.sha1
	SHA2 hash functions:
		HashLib.sha224
		HashLib.sha256
		HashLib.sha512_224
		HashLib.sha512_256
		HashLib.sha384
		HashLib.sha512
	SHA3 hash functions:
		HashLib.sha3_224
		HashLib.sha3_256
		HashLib.sha3_384
		HashLib.sha3_512
		HashLib.shake128
		HashLib.shake256
	Misc utilities:
		HashLib.hmac (Applicable to any hash function from this module except SHAKE*)
		HashLib.hex_to_bin
		HashLib.base64_to_bin
		HashLib.bin_to_base64

--]=]
---------------------------------------------------------------------------

local Base64 = require(script.Base64)

--------------------------------------------------------------------------------
-- LOCALIZATION FOR VM OPTIMIZATIONS
--------------------------------------------------------------------------------

local ipairs = ipairs

--------------------------------------------------------------------------------
-- 32-BIT BITWISE FUNCTIONS
--------------------------------------------------------------------------------
-- Only low 32 bits of function arguments matter, high bits are ignored
-- The result of all functions (except HEX) is an integer inside "correct range":
-- for "bit" library:    (-TWO_POW_31)..(TWO_POW_31-1)
-- for "bit32" library:        0..(TWO_POW_32-1)
local bit32_band = bit32.band -- 2 arguments
local bit32_bor = bit32.bor -- 2 arguments
local bit32_bxor = bit32.bxor -- 2..5 arguments
local bit32_lshift = bit32.lshift -- second argument is integer 0..31
local bit32_rshift = bit32.rshift -- second argument is integer 0..31
local bit32_lrotate = bit32.lrotate -- second argument is integer 0..31
local bit32_rrotate = bit32.rrotate -- second argument is integer 0..31

--------------------------------------------------------------------------------
-- CREATING OPTIMIZED INNER LOOP
--------------------------------------------------------------------------------
-- Arrays of SHA2 "magic numbers" (in "INT64" and "FFI" branches "*_lo" arrays contain 64-bit values)
local sha2_K_lo, sha2_K_hi, sha2_H_lo, sha2_H_hi, sha3_RC_lo, sha3_RC_hi = {}, {}, {}, {}, {}, {}
local sha2_H_ext256 = {
	[224] = {},
	[256] = sha2_H_hi,
}

local sha2_H_ext512_lo, sha2_H_ext512_hi = {
	[384] = {},
	[512] = sha2_H_lo,
}, {
	[384] = {},
	[512] = sha2_H_hi,
}

local md5_K, md5_sha1_H = {}, { 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0 }
local md5_next_shift =
	{ 0, 0, 0, 0, 0, 0, 0, 0, 28, 25, 26, 27, 0, 0, 10, 9, 11, 12, 0, 15, 16, 17, 18, 0, 20, 22, 23, 21 }
local HEX64, XOR64A5, lanes_index_base -- defined only for branches that internally use 64-bit integers: "INT64" and "FFI"
local common_W = {} -- temporary table shared between all calculations (to avoid creating new temporary table every time)
local K_lo_modulo, hi_factor, hi_factor_keccak = 4294967296, 0, 0

local TWO_POW_NEG_56 = 2 ^ -56
local TWO_POW_NEG_17 = 2 ^ -17

local TWO_POW_2 = 2 ^ 2
local TWO_POW_3 = 2 ^ 3
local TWO_POW_4 = 2 ^ 4
local TWO_POW_5 = 2 ^ 5
local TWO_POW_6 = 2 ^ 6
local TWO_POW_7 = 2 ^ 7
local TWO_POW_8 = 2 ^ 8
local TWO_POW_9 = 2 ^ 9
local TWO_POW_10 = 2 ^ 10
local TWO_POW_11 = 2 ^ 11
local TWO_POW_12 = 2 ^ 12
local TWO_POW_13 = 2 ^ 13
local TWO_POW_14 = 2 ^ 14
local TWO_POW_15 = 2 ^ 15
local TWO_POW_16 = 2 ^ 16
local TWO_POW_17 = 2 ^ 17
local TWO_POW_18 = 2 ^ 18
local TWO_POW_19 = 2 ^ 19
local TWO_POW_20 = 2 ^ 20
local TWO_POW_21 = 2 ^ 21
local TWO_POW_22 = 2 ^ 22
local TWO_POW_23 = 2 ^ 23
local TWO_POW_24 = 2 ^ 24
local TWO_POW_25 = 2 ^ 25
local TWO_POW_26 = 2 ^ 26
local TWO_POW_27 = 2 ^ 27
local TWO_POW_28 = 2 ^ 28
local TWO_POW_29 = 2 ^ 29
local TWO_POW_30 = 2 ^ 30
local TWO_POW_31 = 2 ^ 31
local TWO_POW_32 = 2 ^ 32
local TWO_POW_40 = 2 ^ 40

local TWO56_POW_7 = 256 ^ 7

-- Implementation for Lua 5.1/5.2 (with or without bitwise library available)
local function sha256_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K = common_W, sha2_K_hi
	local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 64 do
			local a, b = W[j - 15], W[j - 2]
			W[j] = bit32_bxor(bit32_rrotate(a, 7), bit32_lrotate(a, 14), bit32_rshift(a, 3))
				+ bit32_bxor(bit32_lrotate(b, 15), bit32_lrotate(b, 13), bit32_rshift(b, 10))
				+ W[j - 7]
				+ W[j - 16]
		end

		local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8
		for j = 1, 64 do
			local z = bit32_bxor(bit32_rrotate(e, 6), bit32_rrotate(e, 11), bit32_lrotate(e, 7))
				+ bit32_band(e, f)
				+ bit32_band(-1 - e, g)
				+ h
				+ K[j]
				+ W[j]
			h = g
			g = f
			f = e
			e = z + d
			d = c
			c = b
			b = a
			a = z
				+ bit32_band(d, c)
				+ bit32_band(a, bit32_bxor(d, c))
				+ bit32_bxor(bit32_rrotate(a, 2), bit32_rrotate(a, 13), bit32_lrotate(a, 10))
		end

		h1, h2, h3, h4 = (a + h1) % 4294967296, (b + h2) % 4294967296, (c + h3) % 4294967296, (d + h4) % 4294967296
		h5, h6, h7, h8 = (e + h5) % 4294967296, (f + h6) % 4294967296, (g + h7) % 4294967296, (h + h8) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8
end

local function sha512_feed_128(H_lo, H_hi, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 128
	-- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]
	local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi
	local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo =
		H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]
	local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi =
		H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]
	for pos = offs, offs + size - 1, 128 do
		for j = 1, 16 * 2 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for jj = 17 * 2, 80 * 2, 2 do
			local a_lo, a_hi, b_lo, b_hi = W[jj - 30], W[jj - 31], W[jj - 4], W[jj - 5]
			local tmp1 = bit32_bxor(
				bit32_rshift(a_lo, 1) + bit32_lshift(a_hi, 31),
				bit32_rshift(a_lo, 8) + bit32_lshift(a_hi, 24),
				bit32_rshift(a_lo, 7) + bit32_lshift(a_hi, 25)
			) % 4294967296 + bit32_bxor(
				bit32_rshift(b_lo, 19) + bit32_lshift(b_hi, 13),
				bit32_lshift(b_lo, 3) + bit32_rshift(b_hi, 29),
				bit32_rshift(b_lo, 6) + bit32_lshift(b_hi, 26)
			) % 4294967296 + W[jj - 14] + W[jj - 32]

			local tmp2 = tmp1 % 4294967296
			W[jj - 1] = bit32_bxor(
				bit32_rshift(a_hi, 1) + bit32_lshift(a_lo, 31),
				bit32_rshift(a_hi, 8) + bit32_lshift(a_lo, 24),
				bit32_rshift(a_hi, 7)
			) + bit32_bxor(
				bit32_rshift(b_hi, 19) + bit32_lshift(b_lo, 13),
				bit32_lshift(b_hi, 3) + bit32_rshift(b_lo, 29),
				bit32_rshift(b_hi, 6)
			) + W[jj - 15] + W[jj - 33] + (tmp1 - tmp2) / 4294967296

			W[jj] = tmp2
		end

		local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
		local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
		for j = 1, 80 do
			local jj = 2 * j
			local tmp1 = bit32_bxor(
				bit32_rshift(e_lo, 14) + bit32_lshift(e_hi, 18),
				bit32_rshift(e_lo, 18) + bit32_lshift(e_hi, 14),
				bit32_lshift(e_lo, 23) + bit32_rshift(e_hi, 9)
			) % 4294967296 + (bit32_band(e_lo, f_lo) + bit32_band(-1 - e_lo, g_lo)) % 4294967296 + h_lo + K_lo[j] + W[jj]

			local z_lo = tmp1 % 4294967296
			local z_hi = bit32_bxor(
				bit32_rshift(e_hi, 14) + bit32_lshift(e_lo, 18),
				bit32_rshift(e_hi, 18) + bit32_lshift(e_lo, 14),
				bit32_lshift(e_hi, 23) + bit32_rshift(e_lo, 9)
			) + bit32_band(e_hi, f_hi) + bit32_band(-1 - e_hi, g_hi) + h_hi + K_hi[j] + W[jj - 1] + (tmp1 - z_lo) / 4294967296

			h_lo = g_lo
			h_hi = g_hi
			g_lo = f_lo
			g_hi = f_hi
			f_lo = e_lo
			f_hi = e_hi
			tmp1 = z_lo + d_lo
			e_lo = tmp1 % 4294967296
			e_hi = z_hi + d_hi + (tmp1 - e_lo) / 4294967296
			d_lo = c_lo
			d_hi = c_hi
			c_lo = b_lo
			c_hi = b_hi
			b_lo = a_lo
			b_hi = a_hi
			tmp1 = z_lo
				+ (bit32_band(d_lo, c_lo) + bit32_band(b_lo, bit32_bxor(d_lo, c_lo))) % 4294967296
				+ bit32_bxor(
						bit32_rshift(b_lo, 28) + bit32_lshift(b_hi, 4),
						bit32_lshift(b_lo, 30) + bit32_rshift(b_hi, 2),
						bit32_lshift(b_lo, 25) + bit32_rshift(b_hi, 7)
					)
					% 4294967296
			a_lo = tmp1 % 4294967296
			a_hi = z_hi
				+ (bit32_band(d_hi, c_hi) + bit32_band(b_hi, bit32_bxor(d_hi, c_hi)))
				+ bit32_bxor(
					bit32_rshift(b_hi, 28) + bit32_lshift(b_lo, 4),
					bit32_lshift(b_hi, 30) + bit32_rshift(b_lo, 2),
					bit32_lshift(b_hi, 25) + bit32_rshift(b_lo, 7)
				)
				+ (tmp1 - a_lo) / 4294967296
		end

		a_lo = h1_lo + a_lo
		h1_lo = a_lo % 4294967296
		h1_hi = (h1_hi + a_hi + (a_lo - h1_lo) / 4294967296) % 4294967296
		a_lo = h2_lo + b_lo
		h2_lo = a_lo % 4294967296
		h2_hi = (h2_hi + b_hi + (a_lo - h2_lo) / 4294967296) % 4294967296
		a_lo = h3_lo + c_lo
		h3_lo = a_lo % 4294967296
		h3_hi = (h3_hi + c_hi + (a_lo - h3_lo) / 4294967296) % 4294967296
		a_lo = h4_lo + d_lo
		h4_lo = a_lo % 4294967296
		h4_hi = (h4_hi + d_hi + (a_lo - h4_lo) / 4294967296) % 4294967296
		a_lo = h5_lo + e_lo
		h5_lo = a_lo % 4294967296
		h5_hi = (h5_hi + e_hi + (a_lo - h5_lo) / 4294967296) % 4294967296
		a_lo = h6_lo + f_lo
		h6_lo = a_lo % 4294967296
		h6_hi = (h6_hi + f_hi + (a_lo - h6_lo) / 4294967296) % 4294967296
		a_lo = h7_lo + g_lo
		h7_lo = a_lo % 4294967296
		h7_hi = (h7_hi + g_hi + (a_lo - h7_lo) / 4294967296) % 4294967296
		a_lo = h8_lo + h_lo
		h8_lo = a_lo % 4294967296
		h8_hi = (h8_hi + h_hi + (a_lo - h8_lo) / 4294967296) % 4294967296
	end

	H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] =
		h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
	H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] =
		h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
end

local function md5_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K, md5_next_shift = common_W, md5_K, md5_next_shift
	local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((d * 256 + c) * 256 + b) * 256 + a
		end

		local a, b, c, d = h1, h2, h3, h4
		local s = 32 - 7
		for j = 1, 16 do
			local F = bit32_rrotate(bit32_band(b, c) + bit32_band(-1 - b, d) + a + K[j] + W[j], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 32 - 5
		for j = 17, 32 do
			local F = bit32_rrotate(bit32_band(d, b) + bit32_band(-1 - d, c) + a + K[j] + W[(5 * j - 4) % 16 + 1], s)
				+ b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 32 - 4
		for j = 33, 48 do
			local F = bit32_rrotate(bit32_bxor(bit32_bxor(b, c), d) + a + K[j] + W[(3 * j + 2) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 32 - 6
		for j = 49, 64 do
			local F = bit32_rrotate(bit32_bxor(c, bit32_bor(b, -1 - d)) + a + K[j] + W[(j * 7 - 7) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
	end

	H[1], H[2], H[3], H[4] = h1, h2, h3, h4
end

local function sha1_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W = common_W
	local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 80 do
			W[j] = bit32_lrotate(bit32_bxor(W[j - 3], W[j - 8], W[j - 14], W[j - 16]), 1)
		end

		local a, b, c, d, e = h1, h2, h3, h4, h5
		for j = 1, 20 do
			local z = bit32_lrotate(a, 5) + bit32_band(b, c) + bit32_band(-1 - b, d) + 0x5A827999 + W[j] + e -- constant = math.floor(TWO_POW_30 * sqrt(2))
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 21, 40 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0x6ED9EBA1 + W[j] + e -- TWO_POW_30 * sqrt(3)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 41, 60 do
			local z = bit32_lrotate(a, 5) + bit32_band(d, c) + bit32_band(b, bit32_bxor(d, c)) + 0x8F1BBCDC + W[j] + e -- TWO_POW_30 * sqrt(5)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 61, 80 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0xCA62C1D6 + W[j] + e -- TWO_POW_30 * sqrt(10)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
		h5 = (e + h5) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5
end

local function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)
	-- This is an example of a Lua function having 79 local variables :-)
	-- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8
	local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi
	local qwords_qty = block_size_in_bytes / 8
	for pos = offs, offs + size - 1, block_size_in_bytes do
		for j = 1, qwords_qty do
			local a, b, c, d = string.byte(str, pos + 1, pos + 4)
			lanes_lo[j] = bit32_bxor(lanes_lo[j], ((d * 256 + c) * 256 + b) * 256 + a)
			pos = pos + 8
			a, b, c, d = string.byte(str, pos - 3, pos)
			lanes_hi[j] = bit32_bxor(lanes_hi[j], ((d * 256 + c) * 256 + b) * 256 + a)
		end

		local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi, L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi, L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi =
			lanes_lo[1],
			lanes_hi[1],
			lanes_lo[2],
			lanes_hi[2],
			lanes_lo[3],
			lanes_hi[3],
			lanes_lo[4],
			lanes_hi[4],
			lanes_lo[5],
			lanes_hi[5],
			lanes_lo[6],
			lanes_hi[6],
			lanes_lo[7],
			lanes_hi[7],
			lanes_lo[8],
			lanes_hi[8],
			lanes_lo[9],
			lanes_hi[9],
			lanes_lo[10],
			lanes_hi[10],
			lanes_lo[11],
			lanes_hi[11],
			lanes_lo[12],
			lanes_hi[12],
			lanes_lo[13],
			lanes_hi[13],
			lanes_lo[14],
			lanes_hi[14],
			lanes_lo[15],
			lanes_hi[15],
			lanes_lo[16],
			lanes_hi[16],
			lanes_lo[17],
			lanes_hi[17],
			lanes_lo[18],
			lanes_hi[18],
			lanes_lo[19],
			lanes_hi[19],
			lanes_lo[20],
			lanes_hi[20],
			lanes_lo[21],
			lanes_hi[21],
			lanes_lo[22],
			lanes_hi[22],
			lanes_lo[23],
			lanes_hi[23],
			lanes_lo[24],
			lanes_hi[24],
			lanes_lo[25],
			lanes_hi[25]

		for round_idx = 1, 24 do
			local C1_lo = bit32_bxor(L01_lo, L06_lo, L11_lo, L16_lo, L21_lo)
			local C1_hi = bit32_bxor(L01_hi, L06_hi, L11_hi, L16_hi, L21_hi)
			local C2_lo = bit32_bxor(L02_lo, L07_lo, L12_lo, L17_lo, L22_lo)
			local C2_hi = bit32_bxor(L02_hi, L07_hi, L12_hi, L17_hi, L22_hi)
			local C3_lo = bit32_bxor(L03_lo, L08_lo, L13_lo, L18_lo, L23_lo)
			local C3_hi = bit32_bxor(L03_hi, L08_hi, L13_hi, L18_hi, L23_hi)
			local C4_lo = bit32_bxor(L04_lo, L09_lo, L14_lo, L19_lo, L24_lo)
			local C4_hi = bit32_bxor(L04_hi, L09_hi, L14_hi, L19_hi, L24_hi)
			local C5_lo = bit32_bxor(L05_lo, L10_lo, L15_lo, L20_lo, L25_lo)
			local C5_hi = bit32_bxor(L05_hi, L10_hi, L15_hi, L20_hi, L25_hi)

			local D_lo = bit32_bxor(C1_lo, C3_lo * 2 + (C3_hi % TWO_POW_32 - C3_hi % TWO_POW_31) / TWO_POW_31)
			local D_hi = bit32_bxor(C1_hi, C3_hi * 2 + (C3_lo % TWO_POW_32 - C3_lo % TWO_POW_31) / TWO_POW_31)

			local T0_lo = bit32_bxor(D_lo, L02_lo)
			local T0_hi = bit32_bxor(D_hi, L02_hi)
			local T1_lo = bit32_bxor(D_lo, L07_lo)
			local T1_hi = bit32_bxor(D_hi, L07_hi)
			local T2_lo = bit32_bxor(D_lo, L12_lo)
			local T2_hi = bit32_bxor(D_hi, L12_hi)
			local T3_lo = bit32_bxor(D_lo, L17_lo)
			local T3_hi = bit32_bxor(D_hi, L17_hi)
			local T4_lo = bit32_bxor(D_lo, L22_lo)
			local T4_hi = bit32_bxor(D_hi, L22_hi)

			L02_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_20) / TWO_POW_20 + T1_hi * TWO_POW_12
			L02_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_20) / TWO_POW_20 + T1_lo * TWO_POW_12
			L07_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_19) / TWO_POW_19 + T3_hi * TWO_POW_13
			L07_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_19) / TWO_POW_19 + T3_lo * TWO_POW_13
			L12_lo = T0_lo * 2 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_31) / TWO_POW_31
			L12_hi = T0_hi * 2 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_31) / TWO_POW_31
			L17_lo = T2_lo * TWO_POW_10 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_22) / TWO_POW_22
			L17_hi = T2_hi * TWO_POW_10 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_22) / TWO_POW_22
			L22_lo = T4_lo * TWO_POW_2 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_30) / TWO_POW_30
			L22_hi = T4_hi * TWO_POW_2 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_30) / TWO_POW_30

			D_lo = bit32_bxor(C2_lo, C4_lo * 2 + (C4_hi % TWO_POW_32 - C4_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C2_hi, C4_hi * 2 + (C4_lo % TWO_POW_32 - C4_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L03_lo)
			T0_hi = bit32_bxor(D_hi, L03_hi)
			T1_lo = bit32_bxor(D_lo, L08_lo)
			T1_hi = bit32_bxor(D_hi, L08_hi)
			T2_lo = bit32_bxor(D_lo, L13_lo)
			T2_hi = bit32_bxor(D_hi, L13_hi)
			T3_lo = bit32_bxor(D_lo, L18_lo)
			T3_hi = bit32_bxor(D_hi, L18_hi)
			T4_lo = bit32_bxor(D_lo, L23_lo)
			T4_hi = bit32_bxor(D_hi, L23_hi)

			L03_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_21) / TWO_POW_21 + T2_hi * TWO_POW_11
			L03_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_21) / TWO_POW_21 + T2_lo * TWO_POW_11
			L08_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_3) / TWO_POW_3 + T4_hi * TWO_POW_29 % TWO_POW_32
			L08_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_3) / TWO_POW_3 + T4_lo * TWO_POW_29 % TWO_POW_32
			L13_lo = T1_lo * TWO_POW_6 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_26) / TWO_POW_26
			L13_hi = T1_hi * TWO_POW_6 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_26) / TWO_POW_26
			L18_lo = T3_lo * TWO_POW_15 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_17) / TWO_POW_17
			L18_hi = T3_hi * TWO_POW_15 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_17) / TWO_POW_17
			L23_lo = (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_2) / TWO_POW_2 + T0_hi * TWO_POW_30 % TWO_POW_32
			L23_hi = (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_2) / TWO_POW_2 + T0_lo * TWO_POW_30 % TWO_POW_32

			D_lo = bit32_bxor(C3_lo, C5_lo * 2 + (C5_hi % TWO_POW_32 - C5_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C3_hi, C5_hi * 2 + (C5_lo % TWO_POW_32 - C5_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L04_lo)
			T0_hi = bit32_bxor(D_hi, L04_hi)
			T1_lo = bit32_bxor(D_lo, L09_lo)
			T1_hi = bit32_bxor(D_hi, L09_hi)
			T2_lo = bit32_bxor(D_lo, L14_lo)
			T2_hi = bit32_bxor(D_hi, L14_hi)
			T3_lo = bit32_bxor(D_lo, L19_lo)
			T3_hi = bit32_bxor(D_hi, L19_hi)
			T4_lo = bit32_bxor(D_lo, L24_lo)
			T4_hi = bit32_bxor(D_hi, L24_hi)

			L04_lo = T3_lo * TWO_POW_21 % TWO_POW_32 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_11) / TWO_POW_11
			L04_hi = T3_hi * TWO_POW_21 % TWO_POW_32 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_11) / TWO_POW_11
			L09_lo = T0_lo * TWO_POW_28 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_4) / TWO_POW_4
			L09_hi = T0_hi * TWO_POW_28 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_4) / TWO_POW_4
			L14_lo = T2_lo * TWO_POW_25 % TWO_POW_32 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_7) / TWO_POW_7
			L14_hi = T2_hi * TWO_POW_25 % TWO_POW_32 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_7) / TWO_POW_7
			L19_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_8) / TWO_POW_8 + T4_hi * TWO_POW_24 % TWO_POW_32
			L19_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_8) / TWO_POW_8 + T4_lo * TWO_POW_24 % TWO_POW_32
			L24_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_9) / TWO_POW_9 + T1_hi * TWO_POW_23 % TWO_POW_32
			L24_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_9) / TWO_POW_9 + T1_lo * TWO_POW_23 % TWO_POW_32

			D_lo = bit32_bxor(C4_lo, C1_lo * 2 + (C1_hi % TWO_POW_32 - C1_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C4_hi, C1_hi * 2 + (C1_lo % TWO_POW_32 - C1_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L05_lo)
			T0_hi = bit32_bxor(D_hi, L05_hi)
			T1_lo = bit32_bxor(D_lo, L10_lo)
			T1_hi = bit32_bxor(D_hi, L10_hi)
			T2_lo = bit32_bxor(D_lo, L15_lo)
			T2_hi = bit32_bxor(D_hi, L15_hi)
			T3_lo = bit32_bxor(D_lo, L20_lo)
			T3_hi = bit32_bxor(D_hi, L20_hi)
			T4_lo = bit32_bxor(D_lo, L25_lo)
			T4_hi = bit32_bxor(D_hi, L25_hi)

			L05_lo = T4_lo * TWO_POW_14 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_18) / TWO_POW_18
			L05_hi = T4_hi * TWO_POW_14 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_18) / TWO_POW_18
			L10_lo = T1_lo * TWO_POW_20 % TWO_POW_32 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_12) / TWO_POW_12
			L10_hi = T1_hi * TWO_POW_20 % TWO_POW_32 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_12) / TWO_POW_12
			L15_lo = T3_lo * TWO_POW_8 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_24) / TWO_POW_24
			L15_hi = T3_hi * TWO_POW_8 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_24) / TWO_POW_24
			L20_lo = T0_lo * TWO_POW_27 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_5) / TWO_POW_5
			L20_hi = T0_hi * TWO_POW_27 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_5) / TWO_POW_5
			L25_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_25) / TWO_POW_25 + T2_hi * TWO_POW_7
			L25_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_25) / TWO_POW_25 + T2_lo * TWO_POW_7

			D_lo = bit32_bxor(C5_lo, C2_lo * 2 + (C2_hi % TWO_POW_32 - C2_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C5_hi, C2_hi * 2 + (C2_lo % TWO_POW_32 - C2_lo % TWO_POW_31) / TWO_POW_31)

			T1_lo = bit32_bxor(D_lo, L06_lo)
			T1_hi = bit32_bxor(D_hi, L06_hi)
			T2_lo = bit32_bxor(D_lo, L11_lo)
			T2_hi = bit32_bxor(D_hi, L11_hi)
			T3_lo = bit32_bxor(D_lo, L16_lo)
			T3_hi = bit32_bxor(D_hi, L16_hi)
			T4_lo = bit32_bxor(D_lo, L21_lo)
			T4_hi = bit32_bxor(D_hi, L21_hi)

			L06_lo = T2_lo * TWO_POW_3 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_29) / TWO_POW_29
			L06_hi = T2_hi * TWO_POW_3 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_29) / TWO_POW_29
			L11_lo = T4_lo * TWO_POW_18 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_14) / TWO_POW_14
			L11_hi = T4_hi * TWO_POW_18 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_14) / TWO_POW_14
			L16_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_28) / TWO_POW_28 + T1_hi * TWO_POW_4
			L16_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_28) / TWO_POW_28 + T1_lo * TWO_POW_4
			L21_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_23) / TWO_POW_23 + T3_hi * TWO_POW_9
			L21_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_23) / TWO_POW_23 + T3_lo * TWO_POW_9

			L01_lo = bit32_bxor(D_lo, L01_lo)
			L01_hi = bit32_bxor(D_hi, L01_hi)
			L01_lo, L02_lo, L03_lo, L04_lo, L05_lo =
				bit32_bxor(L01_lo, bit32_band(-1 - L02_lo, L03_lo)),
				bit32_bxor(L02_lo, bit32_band(-1 - L03_lo, L04_lo)),
				bit32_bxor(L03_lo, bit32_band(-1 - L04_lo, L05_lo)),
				bit32_bxor(L04_lo, bit32_band(-1 - L05_lo, L01_lo)),
				bit32_bxor(L05_lo, bit32_band(-1 - L01_lo, L02_lo))
			L01_hi, L02_hi, L03_hi, L04_hi, L05_hi =
				bit32_bxor(L01_hi, bit32_band(-1 - L02_hi, L03_hi)),
				bit32_bxor(L02_hi, bit32_band(-1 - L03_hi, L04_hi)),
				bit32_bxor(L03_hi, bit32_band(-1 - L04_hi, L05_hi)),
				bit32_bxor(L04_hi, bit32_band(-1 - L05_hi, L01_hi)),
				bit32_bxor(L05_hi, bit32_band(-1 - L01_hi, L02_hi))
			L06_lo, L07_lo, L08_lo, L09_lo, L10_lo =
				bit32_bxor(L09_lo, bit32_band(-1 - L10_lo, L06_lo)),
				bit32_bxor(L10_lo, bit32_band(-1 - L06_lo, L07_lo)),
				bit32_bxor(L06_lo, bit32_band(-1 - L07_lo, L08_lo)),
				bit32_bxor(L07_lo, bit32_band(-1 - L08_lo, L09_lo)),
				bit32_bxor(L08_lo, bit32_band(-1 - L09_lo, L10_lo))
			L06_hi, L07_hi, L08_hi, L09_hi, L10_hi =
				bit32_bxor(L09_hi, bit32_band(-1 - L10_hi, L06_hi)),
				bit32_bxor(L10_hi, bit32_band(-1 - L06_hi, L07_hi)),
				bit32_bxor(L06_hi, bit32_band(-1 - L07_hi, L08_hi)),
				bit32_bxor(L07_hi, bit32_band(-1 - L08_hi, L09_hi)),
				bit32_bxor(L08_hi, bit32_band(-1 - L09_hi, L10_hi))
			L11_lo, L12_lo, L13_lo, L14_lo, L15_lo =
				bit32_bxor(L12_lo, bit32_band(-1 - L13_lo, L14_lo)),
				bit32_bxor(L13_lo, bit32_band(-1 - L14_lo, L15_lo)),
				bit32_bxor(L14_lo, bit32_band(-1 - L15_lo, L11_lo)),
				bit32_bxor(L15_lo, bit32_band(-1 - L11_lo, L12_lo)),
				bit32_bxor(L11_lo, bit32_band(-1 - L12_lo, L13_lo))
			L11_hi, L12_hi, L13_hi, L14_hi, L15_hi =
				bit32_bxor(L12_hi, bit32_band(-1 - L13_hi, L14_hi)),
				bit32_bxor(L13_hi, bit32_band(-1 - L14_hi, L15_hi)),
				bit32_bxor(L14_hi, bit32_band(-1 - L15_hi, L11_hi)),
				bit32_bxor(L15_hi, bit32_band(-1 - L11_hi, L12_hi)),
				bit32_bxor(L11_hi, bit32_band(-1 - L12_hi, L13_hi))
			L16_lo, L17_lo, L18_lo, L19_lo, L20_lo =
				bit32_bxor(L20_lo, bit32_band(-1 - L16_lo, L17_lo)),
				bit32_bxor(L16_lo, bit32_band(-1 - L17_lo, L18_lo)),
				bit32_bxor(L17_lo, bit32_band(-1 - L18_lo, L19_lo)),
				bit32_bxor(L18_lo, bit32_band(-1 - L19_lo, L20_lo)),
				bit32_bxor(L19_lo, bit32_band(-1 - L20_lo, L16_lo))
			L16_hi, L17_hi, L18_hi, L19_hi, L20_hi =
				bit32_bxor(L20_hi, bit32_band(-1 - L16_hi, L17_hi)),
				bit32_bxor(L16_hi, bit32_band(-1 - L17_hi, L18_hi)),
				bit32_bxor(L17_hi, bit32_band(-1 - L18_hi, L19_hi)),
				bit32_bxor(L18_hi, bit32_band(-1 - L19_hi, L20_hi)),
				bit32_bxor(L19_hi, bit32_band(-1 - L20_hi, L16_hi))
			L21_lo, L22_lo, L23_lo, L24_lo, L25_lo =
				bit32_bxor(L23_lo, bit32_band(-1 - L24_lo, L25_lo)),
				bit32_bxor(L24_lo, bit32_band(-1 - L25_lo, L21_lo)),
				bit32_bxor(L25_lo, bit32_band(-1 - L21_lo, L22_lo)),
				bit32_bxor(L21_lo, bit32_band(-1 - L22_lo, L23_lo)),
				bit32_bxor(L22_lo, bit32_band(-1 - L23_lo, L24_lo))
			L21_hi, L22_hi, L23_hi, L24_hi, L25_hi =
				bit32_bxor(L23_hi, bit32_band(-1 - L24_hi, L25_hi)),
				bit32_bxor(L24_hi, bit32_band(-1 - L25_hi, L21_hi)),
				bit32_bxor(L25_hi, bit32_band(-1 - L21_hi, L22_hi)),
				bit32_bxor(L21_hi, bit32_band(-1 - L22_hi, L23_hi)),
				bit32_bxor(L22_hi, bit32_band(-1 - L23_hi, L24_hi))
			L01_lo = bit32_bxor(L01_lo, RC_lo[round_idx])
			L01_hi = L01_hi + RC_hi[round_idx] -- RC_hi[] is either 0 or 0x80000000, so we could use fast addition instead of slow XOR
		end

		lanes_lo[1] = L01_lo
		lanes_hi[1] = L01_hi
		lanes_lo[2] = L02_lo
		lanes_hi[2] = L02_hi
		lanes_lo[3] = L03_lo
		lanes_hi[3] = L03_hi
		lanes_lo[4] = L04_lo
		lanes_hi[4] = L04_hi
		lanes_lo[5] = L05_lo
		lanes_hi[5] = L05_hi
		lanes_lo[6] = L06_lo
		lanes_hi[6] = L06_hi
		lanes_lo[7] = L07_lo
		lanes_hi[7] = L07_hi
		lanes_lo[8] = L08_lo
		lanes_hi[8] = L08_hi
		lanes_lo[9] = L09_lo
		lanes_hi[9] = L09_hi
		lanes_lo[10] = L10_lo
		lanes_hi[10] = L10_hi
		lanes_lo[11] = L11_lo
		lanes_hi[11] = L11_hi
		lanes_lo[12] = L12_lo
		lanes_hi[12] = L12_hi
		lanes_lo[13] = L13_lo
		lanes_hi[13] = L13_hi
		lanes_lo[14] = L14_lo
		lanes_hi[14] = L14_hi
		lanes_lo[15] = L15_lo
		lanes_hi[15] = L15_hi
		lanes_lo[16] = L16_lo
		lanes_hi[16] = L16_hi
		lanes_lo[17] = L17_lo
		lanes_hi[17] = L17_hi
		lanes_lo[18] = L18_lo
		lanes_hi[18] = L18_hi
		lanes_lo[19] = L19_lo
		lanes_hi[19] = L19_hi
		lanes_lo[20] = L20_lo
		lanes_hi[20] = L20_hi
		lanes_lo[21] = L21_lo
		lanes_hi[21] = L21_hi
		lanes_lo[22] = L22_lo
		lanes_hi[22] = L22_hi
		lanes_lo[23] = L23_lo
		lanes_hi[23] = L23_hi
		lanes_lo[24] = L24_lo
		lanes_hi[24] = L24_hi
		lanes_lo[25] = L25_lo
		lanes_hi[25] = L25_hi
	end
end

--------------------------------------------------------------------------------
-- MAGIC NUMBERS CALCULATOR
--------------------------------------------------------------------------------
-- Q:
--    Is 53-bit "double" math enough to calculate square roots and cube roots of primes with 64 correct bits after decimal point?
-- A:
--    Yes, 53-bit "double" arithmetic is enough.
--    We could obtain first 40 bits by direct calculation of p^(1/3) and next 40 bits by one step of Newton's method.
do
	local function mul(src1, src2, factor, result_length)
		-- src1, src2 - long integers (arrays of digits in base TWO_POW_24)
		-- factor - small integer
		-- returns long integer result (src1 * src2 * factor) and its floating point approximation
		local result, carry, value, weight = table.create(result_length), 0.0, 0.0, 1.0
		for j = 1, result_length do
			for k = math.max(1, j + 1 - #src2), math.min(j, #src1) do
				carry = carry + factor * src1[k] * src2[j + 1 - k] -- "int32" is not enough for multiplication result, that's why "factor" must be of type "double"
			end

			local digit = carry % TWO_POW_24
			result[j] = math.floor(digit)
			carry = (carry - digit) / TWO_POW_24
			value = value + digit * weight
			weight = weight * TWO_POW_24
		end

		return result, value
	end

	local idx, step, p, one, sqrt_hi, sqrt_lo = 0, { 4, 1, 2, -2, 2 }, 4, { 1 }, sha2_H_hi, sha2_H_lo
	repeat
		p = p + step[p % 6]
		local d = 1
		repeat
			d = d + step[d % 6]
			if d * d > p then
				-- next prime number is found
				local root = p ^ (1 / 3)
				local R = root * TWO_POW_40
				R = mul(table.create(1, math.floor(R)), one, 1.0, 2)
				local _, delta = mul(R, mul(R, R, 1.0, 4), -1.0, 4)
				local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
				local lo = R[1] % 256 * 16777216 + math.floor(delta * (TWO_POW_NEG_56 / 3) * root / p)

				if idx < 16 then
					root = math.sqrt(p)
					R = root * TWO_POW_40
					R = mul(table.create(1, math.floor(R)), one, 1.0, 2)
					_, delta = mul(R, R, -1.0, 2)

					local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
					local lo = R[1] % 256 * 16777216 + math.floor(delta * TWO_POW_NEG_17 / root)
					local idx = idx % 8 + 1
					sha2_H_ext256[224][idx] = lo
					sqrt_hi[idx], sqrt_lo[idx] = hi, lo + hi * hi_factor

					if idx > 7 then
						sqrt_hi, sqrt_lo = sha2_H_ext512_hi[384], sha2_H_ext512_lo[384]
					end
				end

				idx = idx + 1
				sha2_K_hi[idx], sha2_K_lo[idx] = hi, lo % K_lo_modulo + hi * hi_factor
				break
			end
		until p % d == 0
	until idx > 79
end

-- Calculating IVs for SHA512/224 and SHA512/256
for width = 224, 256, 32 do
	local H_lo, H_hi = {}, nil
	if XOR64A5 then
		for j = 1, 8 do
			H_lo[j] = XOR64A5(sha2_H_lo[j])
		end
	else
		H_hi = {}
		for j = 1, 8 do
			H_lo[j] = bit32_bxor(sha2_H_lo[j], 0xA5A5A5A5) % 4294967296
			H_hi[j] = bit32_bxor(sha2_H_hi[j], 0xA5A5A5A5) % 4294967296
		end
	end

	sha512_feed_128(H_lo, H_hi, "SHA-512/" .. tostring(width) .. "\128" .. string.rep("\0", 115) .. "\88", 0, 128)
	sha2_H_ext512_lo[width] = H_lo
	sha2_H_ext512_hi[width] = H_hi
end

-- Constants for MD5
do
	for idx = 1, 64 do
		-- we can't use formula math.floor(abs(sin(idx))*TWO_POW_32) because its result may be beyond integer range on Lua built with 32-bit integers
		local hi, lo = math.modf(math.abs(math.sin(idx)) * TWO_POW_16)
		md5_K[idx] = hi * 65536 + math.floor(lo * TWO_POW_16)
	end
end

-- Constants for SHA3
do
	local sh_reg = 29
	local function next_bit()
		local r = sh_reg % 2
		sh_reg = bit32_bxor((sh_reg - r) / 2, 142 * r)
		return r
	end

	for idx = 1, 24 do
		local lo, m = 0, nil
		for _ = 1, 6 do
			m = m and m * m * 2 or 1
			lo = lo + next_bit() * m
		end

		local hi = next_bit() * m
		sha3_RC_hi[idx], sha3_RC_lo[idx] = hi, lo + hi * hi_factor_keccak
	end
end

--------------------------------------------------------------------------------
-- MAIN FUNCTIONS
--------------------------------------------------------------------------------
local function sha256ext(width, message)
	-- Create an instance (private objects for current calculation)
	local Array256 = sha2_H_ext256[width] -- # == 8
	local length, tail = 0.0, ""
	local H = table.create(8)
	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] =
		Array256[1], Array256[2], Array256[3], Array256[4], Array256[5], Array256[6], Array256[7], Array256[8]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					sha256_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha256_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- Anyway, it looks very unrealistic that someone would spend more than a year of calculations to process TWO_POW_53 bytes of data by using this Lua script :-)
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha256_feed_64(H, final_blocks, 0, #final_blocks)
				local max_reg = width / 32
				for j = 1, max_reg do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H, "", 1, max_reg)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA256 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA256 digest by invoking this function without an argument
		return partial
	end
end

local function sha512ext(width, message)
	-- Create an instance (private objects for current calculation)
	local length, tail, H_lo, H_hi =
		0.0,
		"",
		table.pack(table.unpack(sha2_H_ext512_lo[width])),
		not HEX64 and table.pack(table.unpack(sha2_H_ext512_hi[width]))

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 128 then
					offs = 128 - #tail
					sha512_feed_128(H_lo, H_hi, tail .. string.sub(message_part, 1, offs), 0, 128)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 128
				sha512_feed_128(H_lo, H_hi, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-17-length) % 128 + 9)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-17 - length) % 128 + 9)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-17 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move floating point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha512_feed_128(H_lo, H_hi, final_blocks, 0, #final_blocks)
				local max_reg = math.ceil(width / 64)

				if HEX64 then
					for j = 1, max_reg do
						H_lo[j] = HEX64(H_lo[j])
					end
				else
					for j = 1, max_reg do
						H_lo[j] = string.format("%08x", H_hi[j] % 4294967296)
							.. string.format("%08x", H_lo[j] % 4294967296)
					end

					H_hi = nil
				end

				H_lo = string.sub(table.concat(H_lo, "", 1, max_reg), 1, width / 4)
			end

			return H_lo
		end
	end

	if message then
		-- Actually perform calculations and return the SHA512 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA512 digest by invoking this function without an argument
		return partial
	end
end

local function md5(message)
	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.create(4), 0.0, ""
	H[1], H[2], H[3], H[4] = md5_sha1_H[1], md5_sha1_H[2], md5_sha1_H[3], md5_sha1_H[4]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					md5_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				md5_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(11) --{tail, "\128", string.rep("\0", (-9 - length) % 64)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64)

				tail = nil
				length = length * 8 -- convert "byte-counter" to "bit-counter"
				for j = 4, 11 do
					local low_byte = length % 256
					final_blocks[j] = string.char(low_byte)
					length = (length - low_byte) / 256
				end

				final_blocks = table.concat(final_blocks)
				md5_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 4 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = string.gsub(table.concat(H), "(..)(..)(..)(..)", "%4%3%2%1")
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the MD5 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get MD5 digest by invoking this function without an argument
		return partial
	end
end

local function sha1(message)
	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.pack(table.unpack(md5_sha1_H)), 0.0, ""

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					sha1_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha1_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha1_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 5 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA-1 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA-1 digest by invoking this function without an argument
		return partial
	end
end

local function keccak(block_size_in_bytes, digest_size_in_bytes, is_SHAKE, message)
	-- "block_size_in_bytes" is multiple of 8
	if type(digest_size_in_bytes) ~= "number" then
		-- arguments in SHAKE are swapped:
		--    NIST FIPS 202 defines SHAKE(message,num_bits)
		--    this module   defines SHAKE(num_bytes,message)
		-- it's easy to forget about this swap, hence the check
		error("Argument 'digest_size_in_bytes' must be a number", 2)
	end

	-- Create an instance (private objects for current calculation)
	local tail, lanes_lo, lanes_hi = "", table.create(25, 0), hi_factor_keccak == 0 and table.create(25, 0)
	local result

	--~     pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)/r is integer),
	--~     break P into n consecutive r-bit pieces P0, ..., Pn-1 (last is zero-padded)
	--~     initialize the state S to a string of b 0 bits.
	--~     absorb the input into the state: For each block Pi,
	--~         extend Pi at the end by a string of c 0 bits, yielding one of length b,
	--~         XOR that with S and
	--~         apply the block permutation f to the result, yielding a new state S
	--~     initialize Z to be the empty string
	--~     while the length of Z is less than d:
	--~         append the first r bits of S to Z
	--~         if Z is still less than d bits long, apply f to S, yielding a new state S.
	--~     truncate Z to d bits
	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				local offs = 0
				if tail ~= "" and #tail + partLength >= block_size_in_bytes then
					offs = block_size_in_bytes - #tail
					keccak_feed(
						lanes_lo,
						lanes_hi,
						tail .. string.sub(message_part, 1, offs),
						0,
						block_size_in_bytes,
						block_size_in_bytes
					)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % block_size_in_bytes
				keccak_feed(lanes_lo, lanes_hi, message_part, offs, size - size_tail, block_size_in_bytes)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				-- append the following bits to the message: for usual SHA3: 011(0*)1, for SHAKE: 11111(0*)1
				local gap_start = is_SHAKE and 31 or 6
				tail = tail
					.. (
						#tail + 1 == block_size_in_bytes and string.char(gap_start + 128)
						or string.char(gap_start) .. string.rep("\0", (-2 - #tail) % block_size_in_bytes) .. "\128"
					)
				keccak_feed(lanes_lo, lanes_hi, tail, 0, #tail, block_size_in_bytes)
				tail = nil

				local lanes_used = 0
				local total_lanes = math.floor(block_size_in_bytes / 8)
				local qwords = {}

				local function get_next_qwords_of_digest(qwords_qty)
					-- returns not more than 'qwords_qty' qwords ('qwords_qty' might be non-integer)
					-- doesn't go across keccak-buffer boundary
					-- block_size_in_bytes is a multiple of 8, so, keccak-buffer contains integer number of qwords
					if lanes_used >= total_lanes then
						keccak_feed(lanes_lo, lanes_hi, "\0\0\0\0\0\0\0\0", 0, 8, 8)
						lanes_used = 0
					end

					qwords_qty = math.floor(math.min(qwords_qty, total_lanes - lanes_used))
					if hi_factor_keccak ~= 0 then
						for j = 1, qwords_qty do
							qwords[j] = HEX64(lanes_lo[lanes_used + j - 1 + lanes_index_base])
						end
					else
						for j = 1, qwords_qty do
							qwords[j] = string.format("%08x", lanes_hi[lanes_used + j] % 4294967296)
								.. string.format("%08x", lanes_lo[lanes_used + j] % 4294967296)
						end
					end

					lanes_used = lanes_used + qwords_qty
					return string.gsub(
						table.concat(qwords, "", 1, qwords_qty),
						"(..)(..)(..)(..)(..)(..)(..)(..)",
						"%8%7%6%5%4%3%2%1"
					),
						qwords_qty * 8
				end

				local parts = {} -- digest parts
				local last_part, last_part_size = "", 0

				local function get_next_part_of_digest(bytes_needed)
					-- returns 'bytes_needed' bytes, for arbitrary integer 'bytes_needed'
					bytes_needed = bytes_needed or 1
					if bytes_needed <= last_part_size then
						last_part_size = last_part_size - bytes_needed
						local part_size_in_nibbles = bytes_needed * 2
						local result = string.sub(last_part, 1, part_size_in_nibbles)
						last_part = string.sub(last_part, part_size_in_nibbles + 1)
						return result
					end

					local parts_qty = 0
					if last_part_size > 0 then
						parts_qty = 1
						parts[parts_qty] = last_part
						bytes_needed = bytes_needed - last_part_size
					end

					-- repeats until the length is enough
					while bytes_needed >= 8 do
						local next_part, next_part_size = get_next_qwords_of_digest(bytes_needed / 8)
						parts_qty = parts_qty + 1
						parts[parts_qty] = next_part
						bytes_needed = bytes_needed - next_part_size
					end

					if bytes_needed > 0 then
						last_part, last_part_size = get_next_qwords_of_digest(1)
						parts_qty = parts_qty + 1
						parts[parts_qty] = get_next_part_of_digest(bytes_needed)
					else
						last_part, last_part_size = "", 0
					end

					return table.concat(parts, "", 1, parts_qty)
				end

				if digest_size_in_bytes < 0 then
					result = get_next_part_of_digest
				else
					result = get_next_part_of_digest(digest_size_in_bytes)
				end
			end

			return result
		end
	end

	if message then
		-- Actually perform calculations and return the SHA3 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA3 digest by invoking this function without an argument
		return partial
	end
end

local function HexToBinFunction(hh)
	return string.char(tonumber(hh, 16))
end

local function hex2bin(hex_string)
	return (string.gsub(hex_string, "%x%x", HexToBinFunction))
end

local base64_symbols = {
	["+"] = 62,
	["-"] = 62,
	[62] = "+",
	["/"] = 63,
	["_"] = 63,
	[63] = "/",
	["="] = -1,
	["."] = -1,
	[-1] = "=",
}

local symbol_index = 0
for j, pair in ipairs({ "AZ", "az", "09" }) do
	for ascii = string.byte(pair), string.byte(pair, 2) do
		local ch = string.char(ascii)
		base64_symbols[ch] = symbol_index
		base64_symbols[symbol_index] = ch
		symbol_index = symbol_index + 1
	end
end

local function bin2base64(binary_string)
	local result = table.create(math.ceil(#binary_string / 3))
	local length = 0

	for pos = 1, #binary_string, 3 do
		local c1, c2, c3, c4 = string.byte(string.sub(binary_string, pos, pos + 2) .. "\0", 1, -1)
		length = length + 1
		result[length] = base64_symbols[math.floor(c1 / 4)]
			.. base64_symbols[c1 % 4 * 16 + math.floor(c2 / 16)]
			.. base64_symbols[c3 and c2 % 16 * 4 + math.floor(c3 / 64) or -1]
			.. base64_symbols[c4 and c3 % 64 or -1]
	end

	return table.concat(result)
end

local function base642bin(base64_string)
	local result, chars_qty = {}, 3
	for pos, ch in string.gmatch(string.gsub(base64_string, "%s+", ""), "()(.)") do
		local code = base64_symbols[ch]
		if code < 0 then
			chars_qty = chars_qty - 1
			code = 0
		end

		local idx = pos % 4
		if idx > 0 then
			result[-idx] = code
		else
			local c1 = result[-1] * 4 + math.floor(result[-2] / 16)
			local c2 = (result[-2] % 16) * 16 + math.floor(result[-3] / 4)
			local c3 = (result[-3] % 4) * 64 + code
			result[#result + 1] = string.sub(string.char(c1, c2, c3), 1, chars_qty)
		end
	end

	return table.concat(result)
end

local block_size_for_HMAC -- this table will be initialized at the end of the module
local function pad_and_xor(str, result_length, byte_for_xor)
	return string.gsub(str, ".", function(c)
		return string.char(bit32_bxor(string.byte(c), byte_for_xor))
	end) .. string.rep(string.char(byte_for_xor), result_length - #str)
end

-- For the sake of speed of converting hexes to strings, there's a map of the conversions here
local BinaryStringMap = {}
for Index = 0, 255 do
	BinaryStringMap[string.format("%02x", Index)] = string.char(Index)
end

-- Update 02.14.20 - added AsBinary for easy GameAnalytics replacement.
local function hmac(hash_func, key, message, AsBinary)
	-- Create an instance (private objects for current calculation)
	local block_size = block_size_for_HMAC[hash_func]
	if not block_size then
		error("Unknown hash function", 2)
	end

	if #key > block_size then
		key = string.gsub(hash_func(key), "%x%x", HexToBinFunction)
		--key = hex2bin(hash_func(key))
	end

	local append = hash_func()(pad_and_xor(key, block_size, 0x36))
	local result

	local function partial(message_part)
		if not message_part then
			result = result
				or hash_func(pad_and_xor(key, block_size, 0x5C) .. (string.gsub(append(), "%x%x", HexToBinFunction)))
			return result
		elseif result then
			error("Adding more chunks is not allowed after receiving the result", 2)
		else
			append(message_part)
			return partial
		end
	end

	if message then
		-- Actually perform calculations and return the HMAC of a message
		local FinalMessage = partial(message)()
		return AsBinary and (string.gsub(FinalMessage, "%x%x", BinaryStringMap)) or FinalMessage
	else
		-- Return function for chunk-by-chunk loading of a message
		-- User should feed every chunk of the message as single argument to this function and finally get HMAC by invoking this function without an argument
		return partial
	end
end

local sha = {
	md5 = md5,
	sha1 = sha1,
	-- SHA2 hash functions:
	sha224 = function(message)
		return sha256ext(224, message)
	end,

	sha256 = function(message)
		return sha256ext(256, message)
	end,

	sha512_224 = function(message)
		return sha512ext(224, message)
	end,

	sha512_256 = function(message)
		return sha512ext(256, message)
	end,

	sha384 = function(message)
		return sha512ext(384, message)
	end,

	sha512 = function(message)
		return sha512ext(512, message)
	end,

	-- SHA3 hash functions:
	sha3_224 = function(message)
		return keccak((1600 - 2 * 224) / 8, 224 / 8, false, message)
	end,

	sha3_256 = function(message)
		return keccak((1600 - 2 * 256) / 8, 256 / 8, false, message)
	end,

	sha3_384 = function(message)
		return keccak((1600 - 2 * 384) / 8, 384 / 8, false, message)
	end,

	sha3_512 = function(message)
		return keccak((1600 - 2 * 512) / 8, 512 / 8, false, message)
	end,

	shake128 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 128) / 8, digest_size_in_bytes, true, message)
	end,

	shake256 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 256) / 8, digest_size_in_bytes, true, message)
	end,

	-- misc utilities:
	hmac = hmac, -- HMAC(hash_func, key, message) is applicable to any hash function from this module except SHAKE*
	hex_to_bin = hex2bin, -- converts hexadecimal representation to binary string
	base64_to_bin = base642bin, -- converts base64 representation to binary string
	bin_to_base64 = bin2base64,
	base64_encode = Base64.Encode,
	base64_decode = Base64.Decode,
	-- converts binary string to base64 representation
}

block_size_for_HMAC = {
	[sha.md5] = 64,
	[sha.sha1] = 64,
	[sha.sha224] = 64,
	[sha.sha256] = 64,
	[sha.sha512_224] = 128,
	[sha.sha512_256] = 128,
	[sha.sha384] = 128,
	[sha.sha512] = 128,
	[sha.sha3_224] = (1600 - 2 * 224) / 8,
	[sha.sha3_256] = (1600 - 2 * 256) / 8,
	[sha.sha3_384] = (1600 - 2 * 384) / 8,
	[sha.sha3_512] = (1600 - 2 * 512) / 8,
}

return sha]]></ProtectedString>
									<string name="ScriptGuid">{669B3287-179E-493B-8FF2-4F820A8BD7E0}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">HashLib.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX5EBB61E584B2478198B866D704E4B28E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">HashLib</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX51DE5FB6FE3E4E7393AE9C7435CB8EC8">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- @original: https://gist.github.com/Reselim/40d62b17d138cc74335a1b0709e19ce2
local Alphabet = {}
local Indexes = {}

-- A-Z
for Index = 65, 90 do
	table.insert(Alphabet, Index)
end

-- a-z
for Index = 97, 122 do
	table.insert(Alphabet, Index)
end

-- 0-9
for Index = 48, 57 do
	table.insert(Alphabet, Index)
end

table.insert(Alphabet, 43) -- +
table.insert(Alphabet, 47) -- /

for Index, Character in ipairs(Alphabet) do
	Indexes[Character] = Index
end

local Base64 = {}

local bit32_rshift = bit32.rshift
local bit32_lshift = bit32.lshift
local bit32_band = bit32.band

--[[**
	Encodes a string in Base64.
	@param [t:string] Input The input string to encode.
	@returns [t:string] The string encoded in Base64.
**--]]
function Base64.Encode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 3 do
		local C1, C2, C3 = string.byte(Input, Index, Index + 2)

		local A = bit32_rshift(C1, 2)
		local B = bit32_lshift(bit32_band(C1, 3), 4) + bit32_rshift(C2 or 0, 4)
		local C = bit32_lshift(bit32_band(C2 or 0, 15), 2) + bit32_rshift(C3 or 0, 6)
		local D = bit32_band(C3 or 0, 63)

		Length = Length + 1
		Output[Length] = Alphabet[A + 1]

		Length = Length + 1
		Output[Length] = Alphabet[B + 1]

		Length = Length + 1
		Output[Length] = C2 and Alphabet[C + 1] or 61

		Length = Length + 1
		Output[Length] = C3 and Alphabet[D + 1] or 61
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] =
			string.char(table.unpack(Output, Index, IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1))
	end

	return table.concat(NewOutput)
end

--[[**
	Decodes a string from Base64.
	@param [t:string] Input The input string to decode.
	@returns [t:string] The newly decoded string.
**--]]
function Base64.Decode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 4 do
		local C1, C2, C3, C4 = string.byte(Input, Index, Index + 3)

		local I1 = Indexes[C1] - 1
		local I2 = Indexes[C2] - 1
		local I3 = (Indexes[C3] or 1) - 1
		local I4 = (Indexes[C4] or 1) - 1

		local A = bit32_lshift(I1, 2) + bit32_rshift(I2, 4)
		local B = bit32_lshift(bit32_band(I2, 15), 4) + bit32_rshift(I3, 2)
		local C = bit32_lshift(bit32_band(I3, 3), 6) + I4

		Length = Length + 1
		Output[Length] = A

		if C3 ~= 61 then
			Length = Length + 1
			Output[Length] = B
		end

		if C4 ~= 61 then
			Length = Length + 1
			Output[Length] = C
		end
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] =
			string.char(table.unpack(Output, Index, IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1))
	end

	return table.concat(NewOutput)
end

return Base64]]></ProtectedString>
										<string name="ScriptGuid">{CBA26A2D-CDEC-4BCA-AC25-7BBB66BDFC90}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Base64.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX7E011BE40DAD4C628310372DCD213060">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
--local GameAnalyticsSendMessage

local logger = {
	_infoLogEnabled = false,
	_infoLogAdvancedEnabled = false,
	_debugEnabled = false --RunService:IsStudio(),
}

function logger:setDebugLog(enabled)
	self._debugEnabled = enabled
end

function logger:setInfoLog(enabled)
	self._infoLogEnabled = enabled
end

function logger:setVerboseLog(enabled)
	self._infoLogAdvancedEnabled = enabled
end

function logger:i(format)
	if not self._infoLogEnabled then
		return
	end

	local m = "Info/GameAnalytics: " .. format
	print(m)
	--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
	--    GameAnalyticsSendMessage:FireAllClients({
	--        Text = m,
	--        Font = Enum.Font.Arial,
	--        Color = Color3.new(255, 255, 255),
	--        FontSize = Enum.FontSize.Size96
	--    })
end

function logger:w(format)
	local m = "Warning/GameAnalytics: " .. format
	warn(m)
	--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
	--    GameAnalyticsSendMessage:FireAllClients({
	--        Text = m,
	--        Font = Enum.Font.Arial,
	--        Color = Color3.new(255, 255, 0),
	--        FontSize = Enum.FontSize.Size96
	--    })
end

function logger:e(format)
	task.spawn(function()
		local m = "Error/GameAnalytics: " .. format
		error(m, 0)
		--        GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
		--        GameAnalyticsSendMessage:FireAllClients({
		--            Text = m,
		--            Font = Enum.Font.Arial,
		--            Color = Color3.new(255, 0, 0),
		--            FontSize = Enum.FontSize.Size96
		--        })
	end)
end

function logger:d(format)
	if not self._debugEnabled then
		return
	end

	local m = "Debug/GameAnalytics: " .. format
	print(m)
	--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
	--    GameAnalyticsSendMessage:FireAllClients({
	--        Text = m,
	--        Font = Enum.Font.Arial,
	--        Color = Color3.new(255, 255, 255),
	--        FontSize = Enum.FontSize.Size96
	--    })
end

function logger:ii(format)
	if not self._infoLogAdvancedEnabled then
		return
	end

	local m = "Verbose/GameAnalytics: " .. format
	print(m)
	--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
	--    GameAnalyticsSendMessage:FireAllClients({
	--        Text = m,
	--        Font = Enum.Font.Arial,
	--        Color = Color3.new(255, 255, 255),
	--        FontSize = Enum.FontSize.Size96
	--    })
end

return logger]]></ProtectedString>
								<string name="ScriptGuid">{5FB20718-3331-4726-8B2D-0712E6165106}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Logger.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX823201E5DE7040A08C2600D3F10CB7AD">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[[
	Postie 1.1.0 by BenSBk
	Depends on:
	- The Roblox API
	- A RemoteEvent named Sent
	- A RemoteEvent named Received

	Postie is a safe alternative to RemoteFunctions with a time-out.

	Postie.invokeClient( // yields, server-side
		player: Player,
		id: string,
		timeOut: number,
		...data: any
	) => didRespond: boolean, ...response: any

		Invoke player with sent data. Invocation identified by id. Yield until
		timeOut (given in seconds) is reached and return false, or a response is
		received back from the client and return true plus the data returned
		from the client. If the invocation reaches the client, but the client
		doesn't have a corresponding callback, return before timeOut regardless
		but return false.

	Postie.invokeServer( // yields, client-side
		id: string,
		timeOut: number,
		...data: any
	) => didRespond: boolean, ...response: any

		Invoke the server with sent data. Invocation identified by id. Yield
		until timeOut (given in seconds) is reached and return false, or a
		response is received back from the server and return true plus the data
		returned from the server. If the invocation reaches the server, but the
		server doesn't have a corresponding callback, return before timeOut
		regardless but return false.

	Postie.setCallback(
		id: string,
		callback?: (...data: any) -> ...response: any
	)

		Set the callback that is invoked when an invocation identified by id is
		sent. Data sent with the invocation are passed to the callback. If on
		the server, the player who invoked is implicitly received as the first
		argument.

	Postie.getCallback(
		id: string
	) => callback?: (...data: any) -> ...response: any

		Return the callback corresponding with id.
]]

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local replicatedStorage = game:GetService("ReplicatedStorage")

if not replicatedStorage:FindFirstChild("PostieSent") then
	--Create
	local f = Instance.new("RemoteEvent")
	f.Name = "PostieSent"
	f.Parent = replicatedStorage
end

if not replicatedStorage:FindFirstChild("PostieReceived") then
	--Create
	local f = Instance.new("RemoteEvent")
	f.Name = "PostieReceived"
	f.Parent = replicatedStorage
end

local sent = replicatedStorage.PostieSent -- RemoteEvent
local received = replicatedStorage.PostieReceived -- RemoteEvent

local isServer = RunService:IsServer()
local callbackById = {}
local listenerByUuid = {}

local Postie = {}

function Postie.invokeClient(id: string, player: Player, timeOut: number, ...: any): (boolean, ...any)
	assert(isServer, "Postie.invokeClient can only be called from the server")

	local thread = coroutine.running()
	local isResumed = false
	local uuid = HttpService:GenerateGUID(false)

	-- We await a signal from the client.
	listenerByUuid[uuid] = function(playerWhoFired, didInvokeCallback, ...)
		if playerWhoFired ~= player then
			-- The client lied about the UUID.
			return
		end
		isResumed = true
		listenerByUuid[uuid] = nil
		if didInvokeCallback then
			task.spawn(thread, true, ...)
		else
			task.spawn(thread, false)
		end
	end

	-- We await the time-out.
	task.delay(timeOut, function()
		if isResumed then
			return
		end
		listenerByUuid[uuid] = nil
		task.spawn(thread, false)
	end)

	-- Finally, we send the signal to the client and await either the client's
	-- response or the time-out.
	sent:FireClient(player, id, uuid, ...)
	return coroutine.yield()
end

function Postie.invokeServer(id: string, timeOut: number, ...: any): (boolean, ...any)
	assert(not isServer, "Postie.invokeServer can only be called from the client")

	local thread = coroutine.running()
	local isResumed = false
	local uuid = HttpService:GenerateGUID(false)

	-- We await a signal from the client.
	listenerByUuid[uuid] = function(didInvokeCallback, ...)
		isResumed = true
		listenerByUuid[uuid] = nil
		if didInvokeCallback then
			task.spawn(thread, true, ...)
		else
			task.spawn(thread, false)
		end
	end

	-- We await the time-out.
	task.delay(timeOut, function()
		if isResumed then
			return
		end
		listenerByUuid[uuid] = nil
		task.spawn(thread, false)
	end)

	-- Finally, we send the signal to the client and await either the client's
	-- response or the time-out.
	sent:FireServer(id, uuid, ...)
	return coroutine.yield()
end

function Postie.setCallback(id: string, callback: ((...any) -> ...any)?)
	callbackById[id] = callback
end

function Postie.getCallback(id: string): ((...any) -> ...any)?
	return callbackById[id]
end

if isServer then
	-- We handle responses received from the client.
	received.OnServerEvent:Connect(function(player, uuid, didInvokeCallback, ...)
		local listener = listenerByUuid[uuid]
		if not listener then
			return
		end
		listener(player, didInvokeCallback, ...)
	end)

	-- We handle requests sent by the client.
	sent.OnServerEvent:Connect(function(player, id, uuid, ...)
		local callback = callbackById[id]
		if callback then
			received:FireClient(player, uuid, true, callback(player, ...))
		else
			received:FireClient(player, uuid, false)
		end
	end)
else
	-- We handle responses received from the server.
	received.OnClientEvent:Connect(function(uuid, didInvokeCallback, ...)
		local listener = listenerByUuid[uuid]
		if not listener then
			return
		end
		listener(didInvokeCallback, ...)
	end)

	-- We handle requests sent by the server.
	sent.OnClientEvent:Connect(function(id, uuid, ...)
		local callback = callbackById[id]
		if callback then
			received:FireServer(uuid, true, callback(...))
		else
			received:FireServer(uuid, false)
		end
	end)
end

return Postie]]></ProtectedString>
								<string name="ScriptGuid">{B0D3A71E-D86E-4134-BBF5-D0602F195B85}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Postie.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX077938B0A24A4D5D8995548BBC41C2B9">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local validation = require(script.Parent.Validation)
local logger = require(script.Parent.Logger)
local http_api = require(script.Parent.HttpApi)
local store = require(script.Parent.Store)
local events = require(script.Parent.Events)
local HTTP = game:GetService("HttpService")

local state = {
	_availableCustomDimensions01 = {},
	_availableCustomDimensions02 = {},
	_availableCustomDimensions03 = {},
	_availableGamepasses = {},
	_enableEventSubmission = true,
	Initialized = false,
	ReportErrors = true,
	UseCustomUserId = false,
	AutomaticSendBusinessEvents = true,
	ConfigsHash = "",
}

local GameAnalyticsRemoteConfigs

local function getClientTsAdjusted(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	if not PlayerData then
		return os.time()
	end

	local clientTs = os.time()
	local clientTsAdjustedInteger = clientTs + PlayerData.ClientServerTimeOffset
	if validation:validateClientTs(clientTsAdjustedInteger) then
		return clientTsAdjustedInteger
	else
		return clientTs
	end
end

local function populateConfigurations(player)
	local PlayerData = store:GetPlayerDataFromCache(player.UserId)
	local sdkConfig = PlayerData.SdkConfig

	if sdkConfig["configs"] then
		local configurations = sdkConfig["configs"]

		for _, configuration in pairs(configurations) do
			if configuration then
				local key = configuration["key"] or ""
				local start_ts = configuration["start_ts"] or 0
				local end_ts = configuration["end_ts"] or math.huge
				local client_ts_adjusted = getClientTsAdjusted(player.UserId)

				if
					#key > 0
					and configuration["value"]
					and client_ts_adjusted > start_ts
					and client_ts_adjusted < end_ts
				then
					PlayerData.Configurations[key] = configuration["value"]
					logger:d(
						"configuration added: key=" .. configuration["key"] .. ", value=" .. configuration["value"]
					)
				end
			end
		end
	end

	logger:i("Remote configs populated")

	PlayerData.RemoteConfigsIsReady = true
	GameAnalyticsRemoteConfigs = GameAnalyticsRemoteConfigs
		or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsRemoteConfigs")
	GameAnalyticsRemoteConfigs:FireClient(player, PlayerData.Configurations)
end

function state:sessionIsStarted(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	if not PlayerData then
		return false
	end

	return PlayerData.SessionStart ~= 0
end

function state:isEnabled(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	if not PlayerData then
		return false
	elseif not PlayerData.InitAuthorized then
		return false
	else
		return true
	end
end

function state:validateAndFixCurrentDimensions(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)

	-- validate that there are no current dimension01 not in list
	if not validation:validateDimension(self._availableCustomDimensions01, PlayerData.CurrentCustomDimension01) then
		logger:d(
			"Invalid dimension01 found in variable. Setting to nil. Invalid dimension: "
				.. PlayerData.CurrentCustomDimension01
		)
	end

	-- validate that there are no current dimension02 not in list
	if not validation:validateDimension(self._availableCustomDimensions02, PlayerData.CurrentCustomDimension02) then
		logger:d(
			"Invalid dimension02 found in variable. Setting to nil. Invalid dimension: "
				.. PlayerData.CurrentCustomDimension02
		)
	end

	-- validate that there are no current dimension03 not in list
	if not validation:validateDimension(self._availableCustomDimensions03, PlayerData.CurrentCustomDimension03) then
		logger:d(
			"Invalid dimension03 found in variable. Setting to nil. Invalid dimension: "
				.. PlayerData.CurrentCustomDimension03
		)
	end
end

function state:setAvailableCustomDimensions01(availableCustomDimensions)
	if not validation:validateCustomDimensions(availableCustomDimensions) then
		return
	end

	self._availableCustomDimensions01 = availableCustomDimensions
	logger:i("Set available custom01 dimension values: (" .. table.concat(availableCustomDimensions, ", ") .. ")")
end

function state:setAvailableCustomDimensions02(availableCustomDimensions)
	if not validation:validateCustomDimensions(availableCustomDimensions) then
		return
	end

	self._availableCustomDimensions02 = availableCustomDimensions
	logger:i("Set available custom02 dimension values: (" .. table.concat(availableCustomDimensions, ", ") .. ")")
end

function state:setAvailableCustomDimensions03(availableCustomDimensions)
	if not validation:validateCustomDimensions(availableCustomDimensions) then
		return
	end

	self._availableCustomDimensions03 = availableCustomDimensions
	logger:i("Set available custom03 dimension values: (" .. table.concat(availableCustomDimensions, ", ") .. ")")
end

function state:setAvailableGamepasses(availableGamepasses)
	self._availableGamepasses = availableGamepasses
	logger:i("Set available game passes: (" .. table.concat(availableGamepasses, ", ") .. ")")
end

function state:setEventSubmission(flag)
	self._enableEventSubmission = flag
end

function state:isEventSubmissionEnabled()
	return self._enableEventSubmission
end

function state:setCustomDimension01(playerId, dimension)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	PlayerData.CurrentCustomDimension01 = dimension
end

function state:setCustomDimension02(playerId, dimension)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	PlayerData.CurrentCustomDimension02 = dimension
end

function state:setCustomDimension03(playerId, dimension)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	PlayerData.CurrentCustomDimension03 = dimension
end

function state:startNewSession(player, teleportData, customFields)
	if state:isEventSubmissionEnabled() and teleportData == nil then
		logger:i("Starting a new session.")
	end

	local PlayerData = store:GetPlayerDataFromCache(player.UserId)

	-- make sure the current custom dimensions are valid
	state:validateAndFixCurrentDimensions(player.UserId)

	local initResult = http_api:initRequest(events.GameKey, events.SecretKey, events.Build, PlayerData, player.UserId)
	local statusCode = initResult.statusCode
	local responseBody = initResult.body

	if
		(statusCode == http_api.EGAHTTPApiResponse.Ok or statusCode == http_api.EGAHTTPApiResponse.Created)
		and responseBody
	then
		-- set the time offset - how many seconds the local time is different from servertime
		local timeOffsetSeconds = 0
		local serverTs = responseBody["server_ts"] or -1
		if serverTs > 0 then
			local clientTs = os.time()
			timeOffsetSeconds = serverTs - clientTs
		end

		responseBody["time_offset"] = timeOffsetSeconds

		if not (statusCode == http_api.EGAHTTPApiResponse.Created) then
			local sdkConfig = PlayerData.SdkConfig

			if sdkConfig["configs"] then
				responseBody["configs"] = sdkConfig["configs"]
			end

			if sdkConfig["ab_id"] then
				responseBody["ab_id"] = sdkConfig["ab_id"]
			end

			if sdkConfig["ab_variant_id"] then
				responseBody["ab_variant_id"] = sdkConfig["ab_variant_id"]
			end
		end

		PlayerData.SdkConfig = responseBody
		PlayerData.InitAuthorized = true
	elseif statusCode == http_api.EGAHTTPApiResponse.Unauthorized then
		logger:w("Initialize SDK failed - Unauthorized")
		PlayerData.InitAuthorized = false
	else
		-- log the status if no connection
		if
			statusCode == http_api.EGAHTTPApiResponse.NoResponse
			or statusCode == http_api.EGAHTTPApiResponse.RequestTimeout
		then
			logger:i("Init call (session start) failed - no response. Could be offline or timeout.")
		elseif
			statusCode == http_api.EGAHTTPApiResponse.BadResponse
			or statusCode == http_api.EGAHTTPApiResponse.JsonEncodeFailed
			or statusCode == http_api.EGAHTTPApiResponse.JsonDecodeFailed
		then
			logger:i("Init call (session start) failed - bad response. Could be bad response from proxy or GA servers.")
		elseif
			statusCode == http_api.EGAHTTPApiResponse.BadRequest
			or statusCode == http_api.EGAHTTPApiResponse.UnknownResponseCode
		then
			logger:i("Init call (session start) failed - bad request or unknown response.")
		end

		PlayerData.InitAuthorized = true
	end

	-- set offset in state (memory) from current config (config could be from cache etc.)
	PlayerData.ClientServerTimeOffset = PlayerData.SdkConfig["time_offset"] or 0
	PlayerData.ConfigsHash = PlayerData.SdkConfig["configs_hash"] or ""
	PlayerData.AbId = PlayerData.SdkConfig["ab_id"] or ""
	PlayerData.AbVariantId = PlayerData.SdkConfig["ab_variant_id"] or ""

	-- populate configurations
	populateConfigurations(player)

	if not state:isEnabled(player.UserId) then
		logger:w("Could not start session: SDK is disabled.")
		return
	end

	if teleportData then
		PlayerData.SessionID = teleportData.SessionID
		PlayerData.SessionStart = teleportData.SessionStart
	else
		PlayerData.SessionID = string.lower(HTTP:GenerateGUID(false))
		PlayerData.SessionStart = getClientTsAdjusted(player.UserId)
	end

	if state:isEventSubmissionEnabled() then
		events:addSessionStartEvent(player.UserId, teleportData, customFields)
	end
end

function state:endSession(playerId, customFields)
	if state.Initialized and state:isEventSubmissionEnabled() then
		logger:i("Ending session.")
		if state:isEnabled(playerId) and state:sessionIsStarted(playerId) then
			events:addSessionEndEvent(playerId, customFields)
			store.PlayerCache[playerId] = nil
		end
	end
end

function state:getRemoteConfigsStringValue(playerId, key, defaultValue)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	return PlayerData.Configurations[key] or defaultValue
end

function state:isRemoteConfigsReady(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	return PlayerData.RemoteConfigsIsReady
end

function state:getRemoteConfigsContentAsString(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	return HTTP:JSONEncode(PlayerData.Configurations)
end

return state]]></ProtectedString>
								<string name="ScriptGuid">{3AB85B94-7CE4-4806-85B5-95D2443CAE57}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">State.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX645236B8D0E943C7B17EC9C05B715F57">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local DS = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")
local DSQ = require(script.DataStoreQueue)

local store = {
	PlayerDS = RunService:IsStudio() and {} or DS:GetDataStore("GA_PlayerDS_1.0.0"),
	AutoSaveData = 180, --Set to 0 to disable
	BasePlayerData = {
		Sessions = 0,
		Transactions = 0,
		ProgressionTries = {},
		CurrentCustomDimension01 = "",
		CurrentCustomDimension02 = "",
		CurrentCustomDimension03 = "",
		ConfigsHash = "",
		AbId = "",
		AbVariantId = "",
		InitAuthorized = false,
		SdkConfig = {},
		ClientServerTimeOffset = 0,
		Configurations = {},
		RemoteConfigsIsReady = false,
		PlayerTeleporting = false,
		OwnedGamepasses = nil, --nil means a completely new player. {} means player with no game passes
		CountryCode = "",
		CustomUserId = "",
	},

	DataToSave = {
		"Sessions",
		"Transactions",
		"ProgressionTries",
		"CurrentCustomDimension01",
		"CurrentCustomDimension02",
		"CurrentCustomDimension03",
		"OwnedGamepasses",
	},

	--Cache
	PlayerCache = {},
	EventsQueue = {},
	DataStoreQueue = DSQ,
}

function store:GetPlayerData(Player)
	local key = Player.UserId
	local success, PlayerData = DSQ.AddRequest(key, function()
		return RunService:IsStudio() and {} or (store.PlayerDS:GetAsync(key) or {})
	end, 7) -- Add to a queue with 7s delay between each request

	if not success then
		PlayerData = {}
	end
	return PlayerData
end

function store:GetPlayerDataFromCache(userId)
	local playerData = store.PlayerCache[tonumber(userId)]
	if playerData then
		return playerData
	end
	playerData = store.PlayerCache[tostring(userId)]
	return playerData
end

function store:GetErrorDataStore(scope)
	local ErrorDS
	local success = pcall(function()
		ErrorDS = RunService:IsStudio() and {} or DS:GetDataStore("GA_ErrorDS_1.0.0", scope)
	end)

	if not success then
		ErrorDS = {}
	end

	return ErrorDS
end

function store:SavePlayerData(Player)
	--Variables
	local PlayerData = store:GetPlayerDataFromCache(Player.UserId)
	local SavePlayerData = {}

	if not PlayerData then
		return
	end

	--Fill
	for _, key in pairs(store.DataToSave) do
		SavePlayerData[key] = PlayerData[key]
	end

	--Save
	local key = Player.UserId
	if not RunService:IsStudio() then
		DSQ.AddRequest(key, function()
			return store.PlayerDS:SetAsync(key, SavePlayerData)
		end, 7)
	end
end

function store:IncrementErrorCount(ErrorDS, ErrorKey, step)
	if not ErrorKey then
		return
	end

	local count = 0
	--Increment count
	if not RunService:IsStudio() then
		--Increment count
		_, count = DSQ.AddRequest(ErrorKey, function()
			return ErrorDS:IncrementAsync(ErrorKey, step)
		end, 7)
	end
	return count
end
return store]]></ProtectedString>
								<string name="ScriptGuid">{A789EEBC-783C-4555-AB57-7157EA76B41A}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Store.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX2A208C7774344A5DBC23AF59521F4102">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Store</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX3BC74BA4186A41B5B811983DF3F5C99A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local DataStoreManager = {}
DataStoreManager.QR = true
DataStoreManager.Queue = {}
DataStoreManager.Process = 0
local LastRequest = {}

task.spawn(function()
	while DataStoreManager.QR do
		task.wait()
		if #DataStoreManager.Queue > 0 then
			local Request = DataStoreManager.Queue[1]
			table.remove(DataStoreManager.Queue, 1)
			if not LastRequest[Request.Key] then
				LastRequest[Request.Key] = 0
			end

			DataStoreManager.Process += 1
			local remain = (Request.Delay + LastRequest[Request.Key]) - DateTime.now().UnixTimestamp
			if remain <= 0 then
				remain = 0
			end
			task.delay(remain, function()
				local Success, Error, ds
				repeat
					LastRequest[Request.Key] = DateTime.now().UnixTimestamp
					Success, Error, ds = pcall(Request.Func)

					if not Success then
						warn(Error)
					end
					if Success and Error then
						break
					end
					if not Request.Delay then
						break
					end
					task.wait(Request.Delay)
				until Success and Error
				Request.Event:Fire(Success, Error, ds)
				DataStoreManager.Process -= 1
				LastRequest[Request.Key] = DateTime.now().UnixTimestamp
			end)
		end
	end
end)

function DataStoreManager.AddRequest(Key, Request, Delay)
	local FinishedEvent = Instance.new("BindableEvent")
	table.insert(DataStoreManager.Queue, {
		Key = Key,
		Delay = Delay,
		Func = Request,
		Event = FinishedEvent,
	})
	local Success, ValOrErr, ds = FinishedEvent.Event:Wait()
	return Success, ValOrErr, ds
end

function DataStoreManager.RemoveKey(Key)
	LastRequest[Key] = nil
end
return DataStoreManager]]></ProtectedString>
									<string name="ScriptGuid">{651B17F4-98D4-4A26-8639-8BE2EEDC6D7D}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DataStoreQueue.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX411A9389C0604B7F833DC6BE96F9FBB8">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local threading = {
	_canSafelyClose = true,
	_endThread = false,
	_isRunning = false,
	_blocks = {},
	_scheduledBlock = nil,
	_hasScheduledBlockRun = true,
}

local logger = require(script.Parent.Logger)
local RunService = game:GetService("RunService")

local function getScheduledBlock()
	local now = tick()

	if
		not threading._hasScheduledBlockRun
		and threading._scheduledBlock ~= nil
		and threading._scheduledBlock.deadline <= now
	then
		threading._hasScheduledBlockRun = true
		return threading._scheduledBlock
	else
		return nil
	end
end

local function run()
	task.spawn(function()
		logger:d("Starting GA thread")

		while not threading._endThread do
			threading._canSafelyClose = false

			if #threading._blocks ~= 0 then
				for _, b in pairs(threading._blocks) do
					local s, e = pcall(b.block)
					if not s then
						logger:e(e)
					end
				end

				threading._blocks = {}
			end

			local timedBlock = getScheduledBlock()
			if timedBlock ~= nil then
				local s, e = pcall(timedBlock.block)
				if not s then
					logger:e(e)
				end
			end

			threading._canSafelyClose = true
			task.wait(1)
		end

		logger:d("GA thread stopped")
	end)

	--Safely Close
	game:BindToClose(function()
		-- waiting bug fix to work inside studio
		if RunService:IsStudio() then
			return
		end

		--Give game.Players.PlayerRemoving time to to its thang
		task.wait(1)

		--Delay
		if not threading._canSafelyClose then
			repeat
				task.wait()
			until threading._canSafelyClose
		end

		task.wait(3)
	end)
end

function threading:scheduleTimer(interval, callback)
	if self._endThread then
		return
	end

	if not self._isRunning then
		self._isRunning = true
		run()
	end

	local timedBlock = {
		block = callback,
		deadline = tick() + interval,
	}

	if self._hasScheduledBlockRun then
		self._scheduledBlock = timedBlock
		self._hasScheduledBlockRun = false
	end
end

function threading:performTaskOnGAThread(callback)
	if self._endThread then
		return
	end

	if not self._isRunning then
		self._isRunning = true
		run()
	end

	local timedBlock = {
		block = callback,
	}

	self._blocks[#self._blocks + 1] = timedBlock
end

function threading:stopThread()
	self._endThread = true
end

return threading]]></ProtectedString>
								<string name="ScriptGuid">{EDC43887-A445-432B-9083-76DA6C9C9E12}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Threading.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3FC8FDC2156C4B81B0394843B5EB7F8D">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[type EventOptions = {
	customFields: { [string]: string }?,
}

export type BusinessEventOptions = EventOptions & {
	amount: number,
	itemType: string,
	itemId: string,
	cartType: string?,
}

export type ResourceEventOptions = EventOptions & {
	flowType: number,
	currency: string,
	amount: number,
	itemType: string,
	itemId: string,
}

export type ProgressionEventOptions = EventOptions & {
	progressionStatus: number,
	progression01: string,
	progression02: string?,
	progression03: string?,
	score: number?,
}

export type DesignEventOptions = EventOptions & {
	eventId: string,
	value: number?,
}

export type ErrorEventOptions = EventOptions & {
	message: string,
	severity: number,
}

export type CustomDimension = string

export type ProductInfo = {
	Name: string,
	PriceInRobux: number,
}

export type ProcessReceiptInfo = {
	ProductId: number,
	PlayerId: number,
	CurrencySpent: number,
}

export type TeleportData = { [string]: any }
export type RemoteConfigs = { [string]: any }

export type GameAnalyticsOptions = {
	enableInfoLog: boolean?,
	enableVerboseLog: boolean?,
	availableCustomDimensions01: { CustomDimension }?,
	availableCustomDimensions02: { CustomDimension }?,
	availableCustomDimensions03: { CustomDimension }?,
	availableResourceCurrencies: { string }?,
	availableResourceItemTypes: { string }?,
	build: string?,
	availableGamepasses: { string }?,
	enableDebugLog: boolean?,
	automaticSendBusinessEvents: boolean?,
	reportErrors: boolean?,
	useCustomUserId: boolean?,
	gameKey: string?,
	secretKey: string?,
}

return {}]]></ProtectedString>
								<string name="ScriptGuid">{50A1D51C-A225-4002-AA1E-5EFB33633E69}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Types.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4CEA3D9AC8F34F0AAC74D94A5010CEA6">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local utilities = {}

function utilities:isStringNullOrEmpty(s)
	return (not s) or #s == 0
end

function utilities:stringArrayContainsString(array, search)
	if #array == 0 then
		return false
	end

	for _, s in ipairs(array) do
		if s == search then
			return true
		end
	end

	return false
end

function utilities:copyTable(t)
	local copy = {}
	for k, v in pairs(t) do
		if typeof(v) == "table" then
			copy[k] = self:copyTable(v)
		else
			copy[k] = v
		end
	end
	return copy
end

return utilities]]></ProtectedString>
								<string name="ScriptGuid">{4FD00615-04B6-449B-937A-DF778C579FFA}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Utilities.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD698D49FCF6548D3A5B27E7B4D54F66A">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local validation = {}

local logger = require(script.Parent.Logger)
local utilities = require(script.Parent.Utilities)

function validation:validateCustomDimensions(customDimensions)
	return validation:validateArrayOfStrings(20, 32, false, "custom dimensions", customDimensions)
end

function validation:validateDimension(dimensions, dimension)
	-- allow nil
	if utilities:isStringNullOrEmpty(dimension) then
		return true
	end

	if not utilities:stringArrayContainsString(dimensions, dimension) then
		return false
	end

	return true
end

function validation:validateResourceCurrencies(resourceCurrencies)
	if not validation:validateArrayOfStrings(20, 64, false, "resource currencies", resourceCurrencies) then
		return false
	end

	-- validate each string for regex
	for _, resourceCurrency in pairs(resourceCurrencies) do
		if not string.find(resourceCurrency, "^[A-Za-z]+$") then
			logger:w(
				"resource currencies validation failed: a resource currency can only be A-Z, a-z. String was: "
					.. resourceCurrency
			)
			return false
		end
	end

	return true
end

function validation:validateResourceItemTypes(resourceItemTypes)
	if not validation:validateArrayOfStrings(20, 32, false, "resource item types", resourceItemTypes) then
		return false
	end

	-- validate each string for regex
	for _, resourceItemType in pairs(resourceItemTypes) do
		if not validation:validateEventPartCharacters(resourceItemType) then
			logger:w(
				"resource item types validation failed: a resource item type cannot contain other characters than A-z, 0-9, -_., ()!?. String was: "
					.. resourceItemType
			)
			return false
		end
	end

	return true
end

function validation:validateEventPartCharacters(eventPart)
	if not string.find(eventPart, "^[A-Za-z0-9%s%-_%.%(%)!%?]+$") then
		return false
	end

	return true
end

function validation:validateArrayOfStrings(maxCount, maxStringLength, allowNoValues, logTag, arrayOfStrings)
	local arrayTag = logTag

	if not arrayTag then
		arrayTag = "Array"
	end

	-- use arrayTag to annotate warning log
	if not arrayOfStrings then
		logger:w(arrayTag .. " validation failed: array cannot be nil.")
		return false
	end

	-- check if empty
	if not allowNoValues and #arrayOfStrings == 0 then
		logger:w(arrayTag .. " validation failed: array cannot be empty.")
		return false
	end

	-- check if exceeding max count
	if maxCount > 0 and #arrayOfStrings > maxCount then
		logger:w(
			arrayTag
				.. " validation failed: array cannot exceed "
				.. tostring(maxCount)
				.. " values. It has "
				.. #arrayOfStrings
				.. " values."
		)
		return false
	end

	-- validate each string
	for _, arrayString in ipairs(arrayOfStrings) do
		local stringLength = 0
		if arrayString then
			stringLength = #arrayString
		end

		-- check if empty (not allowed)
		if stringLength == 0 then
			logger:w(arrayTag .. " validation failed: contained an empty string.")
			return false
		end

		-- check if exceeding max length
		if maxStringLength > 0 and stringLength > maxStringLength then
			logger:w(
				arrayTag
					.. " validation failed: a string exceeded max allowed length (which is: "
					.. tostring(maxStringLength)
					.. "). String was: "
					.. arrayString
			)
			return false
		end
	end

	return true
end

function validation:validateBuild(build)
	if not validation:validateShortString(build, false) then
		return false
	end

	return true
end

function validation:validateShortString(shortString, canBeEmpty)
	-- String is allowed to be empty or nil
	if canBeEmpty and utilities:isStringNullOrEmpty(shortString) then
		return true
	end

	if utilities:isStringNullOrEmpty(shortString) or #shortString > 32 then
		return false
	end

	return true
end

function validation:validateKeys(gameKey, secretKey)
	if string.find(gameKey, "^[A-Za-z0-9]+$") and #gameKey == 32 then
		if string.find(secretKey, "^[A-Za-z0-9]+$") and #secretKey == 40 then
			return true
		end
	end

	return false
end

function validation:validateAndCleanInitRequestResponse(initResponse, configsCreated)
	-- make sure we have a valid dict
	if not initResponse then
		logger:w("validateInitRequestResponse failed - no response dictionary.")
		return nil
	end

	local validatedDict = {}

	-- validate server_ts
	local serverTsNumber = initResponse["server_ts"] or -1
	if serverTsNumber > 0 then
		validatedDict["server_ts"] = serverTsNumber
	end

	if configsCreated then
		validatedDict["configs"] = initResponse["configs"] or {}
		validatedDict["ab_id"] = initResponse["ab_id"] or ""
		validatedDict["ab_variant_id"] = initResponse["ab_variant_id"] or ""
	end

	return validatedDict
end

function validation:validateClientTs(clientTs)
	if clientTs < 1000000000 or clientTs > 9999999999 then
		return false
	end

	return true
end

function validation:validateCurrency(currency)
	if utilities:isStringNullOrEmpty(currency) then
		return false
	end

	if string.find(currency, "^[A-Z]+$") and #currency == 3 then
		return true
	end

	return false
end

function validation:validateEventPartLength(eventPart, allowNull)
	if allowNull and utilities:isStringNullOrEmpty(eventPart) then
		return true
	end

	if utilities:isStringNullOrEmpty(eventPart) then
		return false
	end

	if #eventPart == 0 or #eventPart > 64 then
		return false
	end
	return true
end

function validation:validateBusinessEvent(currency, amount, cartType, itemType, itemId)
	-- validate currency
	if not validation:validateCurrency(currency) then
		logger:w(
			"Validation fail - business event - currency: Cannot be (null) and need to be A-Z, 3 characters and in the standard at openexchangerates.org. Failed currency: "
				.. currency
		)
		return false
	end

	if amount < 0 then
		logger:w("Validation fail - business event - amount: Cannot be less then 0. Failed amount: " .. amount)
		return false
	end

	-- validate cartType
	if not validation:validateShortString(cartType, true) then
		logger:w("Validation fail - business event - cartType. Cannot be above 32 length. String: " .. cartType)
		return false
	end

	-- validate itemType length
	if not validation:validateEventPartLength(itemType, false) then
		logger:w(
			"Validation fail - business event - itemType: Cannot be (null), empty or above 64 characters. String: "
				.. itemType
		)
		return false
	end

	-- validate itemType chars
	if not validation:validateEventPartCharacters(itemType) then
		logger:w(
			"Validation fail - business event - itemType: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. itemType
		)
		return false
	end

	-- validate itemId
	if not validation:validateEventPartLength(itemId, false) then
		logger:w(
			"Validation fail - business event - itemId. Cannot be (null), empty or above 64 characters. String: "
				.. itemId
		)
		return false
	end

	if not validation:validateEventPartCharacters(itemId) then
		logger:w(
			"Validation fail - business event - itemId: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. itemId
		)
		return false
	end

	return true
end

function validation:validateResourceEvent(
	flowTypeValues,
	flowType,
	currency,
	amount,
	itemType,
	itemId,
	currencies,
	itemTypes
)
	if flowType ~= flowTypeValues.Source and flowType ~= flowTypeValues.Sink then
		logger:w("Validation fail - resource event - flowType: Invalid flow type " .. tostring(flowType))
		return false
	end

	if utilities:isStringNullOrEmpty(currency) then
		logger:w("Validation fail - resource event - currency: Cannot be (null)")
		return false
	end

	if not utilities:stringArrayContainsString(currencies, currency) then
		logger:w(
			"Validation fail - resource event - currency: Not found in list of pre-defined available resource currencies. String: "
				.. currency
		)
		return false
	end

	if not (amount > 0) then
		logger:w(
			"Validation fail - resource event - amount: Float amount cannot be 0 or negative. Value: "
				.. tostring(amount)
		)
		return false
	end

	if utilities:isStringNullOrEmpty(itemType) then
		logger:w("Validation fail - resource event - itemType: Cannot be (null)")
		return false
	end

	if not validation:validateEventPartLength(itemType, false) then
		logger:w(
			"Validation fail - resource event - itemType: Cannot be (null), empty or above 64 characters. String: "
				.. itemType
		)
		return false
	end

	if not validation:validateEventPartCharacters(itemType) then
		logger:w(
			"Validation fail - resource event - itemType: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. itemType
		)
		return false
	end

	if not utilities:stringArrayContainsString(itemTypes, itemType) then
		logger:w(
			"Validation fail - resource event - itemType: Not found in list of pre-defined available resource itemTypes. String: "
				.. itemType
		)
		return false
	end

	if not validation:validateEventPartLength(itemId, false) then
		logger:w(
			"Validation fail - resource event - itemId: Cannot be (null), empty or above 64 characters. String: "
				.. itemId
		)
		return false
	end

	if not validation:validateEventPartCharacters(itemId) then
		logger:w(
			"Validation fail - resource event - itemId: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. itemId
		)
		return false
	end

	return true
end

function validation:validateProgressionEvent(
	progressionStatusValues,
	progressionStatus,
	progression01,
	progression02,
	progression03
)
	if
		progressionStatus ~= progressionStatusValues.Start
		and progressionStatus ~= progressionStatusValues.Complete
		and progressionStatus ~= progressionStatusValues.Fail
	then
		logger:w("Validation fail - progression event: Invalid progression status " .. tostring(progressionStatus))
		return false
	end

	-- Make sure progressions are defined as either 01, 01+02 or 01+02+03
	if
		not utilities:isStringNullOrEmpty(progression03)
		and not (not utilities:isStringNullOrEmpty(progression02) or utilities:isStringNullOrEmpty(progression01))
	then
		logger:w(
			"Validation fail - progression event: 03 found but 01+02 are invalid. Progression must be set as either 01, 01+02 or 01+02+03."
		)
		return false
	elseif not utilities:isStringNullOrEmpty(progression02) and utilities:isStringNullOrEmpty(progression01) then
		logger:w(
			"Validation fail - progression event: 02 found but not 01. Progression must be set as either 01, 01+02 or 01+02+03"
		)
		return false
	elseif utilities:isStringNullOrEmpty(progression01) then
		logger:w(
			"Validation fail - progression event: progression01 not valid. Progressions must be set as either 01, 01+02 or 01+02+03"
		)
		return false
	end

	-- progression01 (required)
	if not validation:validateEventPartLength(progression01, false) then
		logger:w(
			"Validation fail - progression event - progression01: Cannot be (null), empty or above 64 characters. String: "
				.. progression01
		)
		return false
	end

	if not validation:validateEventPartCharacters(progression01) then
		logger:w(
			"Validation fail - progression event - progression01: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. progression01
		)
		return false
	end

	-- progression02
	if not utilities:isStringNullOrEmpty(progression02) then
		if not validation:validateEventPartLength(progression02, false) then
			logger:w(
				"Validation fail - progression event - progression02: Cannot be empty or above 64 characters. String: "
					.. progression02
			)
			return false
		end

		if not validation:validateEventPartCharacters(progression02) then
			logger:w(
				"Validation fail - progression event - progression02: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
					.. progression02
			)
			return false
		end
	end

	-- progression03
	if not utilities:isStringNullOrEmpty(progression03) then
		if not validation:validateEventPartLength(progression03, false) then
			logger:w(
				"Validation fail - progression event - progression03: Cannot be empty or above 64 characters. String: "
					.. progression03
			)
			return false
		end

		if not validation:validateEventPartCharacters(progression03) then
			logger:w(
				"Validation fail - progression event - progression03: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
					.. progression03
			)
			return false
		end
	end

	return true
end

function validation:validateEventIdLength(eventId)
	if utilities:isStringNullOrEmpty(eventId) then
		return false
	end

	local count = 0
	for s in string.gmatch(eventId, "([^:]+)") do
		count = count + 1
		if count > 5 or #s > 64 then
			return false
		end
	end

	return true
end

function validation:validateEventIdCharacters(eventId)
	if utilities:isStringNullOrEmpty(eventId) then
		return false
	end

	local count = 0
	for s in string.gmatch(eventId, "([^:]+)") do
		count = count + 1
		if count > 5 or not string.find(s, "^[A-Za-z0-9%s%-_%.%(%)!%?]+$") then
			return false
		end
	end

	return true
end

function validation:validateDesignEvent(eventId)
	if not validation:validateEventIdLength(eventId) then
		logger:w(
			"Validation fail - design event - eventId: Cannot be (null) or empty. Only 5 event parts allowed seperated by :. Each part need to be 32 characters or less. String: "
				.. eventId
		)
		return false
	end

	if not validation:validateEventIdCharacters(eventId) then
		logger:w(
			"Validation fail - design event - eventId: Non valid characters. Only allowed A-z, 0-9, -_., ()!?. String: "
				.. eventId
		)
		return false
	end

	-- value: allow 0, negative and nil (not required)
	return true
end

function validation:validateLongString(longString, canBeEmpty)
	-- String is allowed to be empty
	if canBeEmpty and utilities:isStringNullOrEmpty(longString) then
		return true
	end

	if utilities:isStringNullOrEmpty(longString) or #longString > 8192 then
		return false
	end

	return true
end

function validation:validateErrorEvent(severityValues, severity, message)
	if
		severity ~= severityValues.debug
		and severity ~= severityValues.info
		and severity ~= severityValues.warning
		and severity ~= severityValues.error
		and severity ~= severityValues.critical
	then
		logger:w("Validation fail - error event - severity: Severity was unsupported value " .. tostring(severity))
		return false
	end

	if not validation:validateLongString(message, true) then
		logger:w("Validation fail - error event - message: Message cannot be above 8192 characters.")
		return false
	end

	return true
end

return validation]]></ProtectedString>
								<string name="ScriptGuid">{1E0D8D7A-4500-4BAE-B7C1-DE40E2194712}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Validation.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2E572C1AEDDA4C518FC92E89BAE29EE5">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local version = {
	SdkVersion = "2.2.6"
}

return version]]></ProtectedString>
								<string name="ScriptGuid">{6F8827DB-4B01-4432-AA48-CA7F4F35E54F}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Version.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX8FB5EFE951E442B08719D1E7D3A8233B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local module = {}

local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ScriptContext = game:GetService("ScriptContext")

--[[
    The modules are required inside each function because we wouldn't
    want to load the GameAnalytics library if we're just requiring this
    ModuleScript on the client side, and we don't need to hard code
    a require to Postie on the server side because the networking implementation could change.
]]

function module.initClient()
	local Postie = require(script.Parent.GameAnalytics.Postie)

	ScriptContext.Error:Connect(function(message, stackTrace, scriptInst)
		if not scriptInst then
			return
		end

		local scriptName = nil
		local ok, _ = pcall(function()
			scriptName = scriptInst:GetFullName() -- Can't get name of some scripts because of security permission
		end)
		if not ok then
			return
		end

		ReplicatedStorage.GameAnalyticsError:FireServer(message, stackTrace, scriptName)
	end)

	--Functions
	local function getPlatform()
		if GuiService:IsTenFootInterface() then
			return "Console"
		elseif UserInputService.TouchEnabled and not UserInputService.MouseEnabled then
			return "Mobile"
		else
			return "Desktop"
		end
	end

	--Filtering
	Postie.setCallback("getPlatform", getPlatform)
end

return module]]></ProtectedString>
							<string name="ScriptGuid">{4183861A-402D-4807-A5CE-4D4A3EF4499F}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">GameAnalyticsClient.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX276561660A6148B09A43D91A44876394">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Modules/PlayerUtils.lua
--
--  Description:
--      Utility module providing all player-related helpers used across
--      the experience: identity handling, developer/admin flags, avatar
--      thumbnails, data lookup, reward helpers, device detection,
--      proximity queries, and UGC ownership checks.
--
--      Features:
--          • Safe UserId resolution (players, instances, strings)
--          • Cached player headshot thumbnails (3-attempt fallback)
--          • Developer/Admin whitelists
--          • Premium membership tagging
--          • Unified GetPlayerData / GetPlayerVal helpers
--          • Reward delivery (Coins/Gems + UI feedback)
--          • Device detection (PC / Mobile / Console)
--          • Nearby-player detection within distance range
--          • Server-side UGC ownership verification
--
--  Last Modified: 2025-11-29 by Darkzeb
--  Version: V2025-11
--
--  Dependencies:
--      Services:
--          - MarketplaceService
--          - UserInputService
--
--      Shared Modules:
--          - Channels (Display_Data remote)
--
--  Notes:
--      • Thumbnails are cached in-memory for performance.
--      • RewardPlayer fires Display_Data for visual notifications.
--      • UGC checks use PlayerOwnsAsset (3 attempts, fail-safe false).
--======================================================================

local BadgeService 				= game:GetService("BadgeService")
local MPS 						= game:GetService("MarketplaceService")
local UIS 						= game:GetService("UserInputService")

-- Modules
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod 					= require(Data_Mods_F:WaitForChild("Sound_Mod"))

local Channels 					= require(game.ReplicatedStorage.Modules.Channels)
local Display_Data 			    = Channels.Server_Client_Events.Display_Data

local PlayerUtils = {}
local Player_Image_Cache = {}

local PLAYER_DEFAULT_IMG = "rbxassetid://100127687172105"

local function safeFind(parent, name)
	if not parent then return nil end
	return parent:FindFirstChild(name)
end

function PlayerUtils.getSafeId(player)
	if not player then
		return 0
	end

	if typeof(player) == "Instance" and player:IsA("Player") then
		return player.UserId
	elseif typeof(player) == "Instance" then
		local numeric = tonumber(player.Name:match("%d+")) or math.random(1000000, 9999999)
		return 900000000 + numeric
	elseif typeof(player) == "string" then
		local numeric = tonumber(player:match("%d+")) or math.random(1000000, 9999999)
		return 900000000 + numeric
	else
		return math.random(900000000, 900999999)
	end
end

function PlayerUtils.isDeveloper(player)
	local developers = { "champsavenue", "nairoo999", "Asmozer", "yokadkin23", "ali_artisan", "oriane_dev", "ReigateTime", "STAM_Co", "bezkrad" } -- add all devs
	--local developers = {}
	return player and table.find(developers, player.Name) ~= nil
end

function PlayerUtils.isAdmin(player)
	local admins = { "champsavenue"} 
	return player and table.find(admins, player.Name) ~= nil
end

function PlayerUtils.Is_Premium_Member(Plr)
	if(Plr.MembershipType == Enum.MembershipType.Premium)then
		Plr:SetAttribute("Is_Premium", true)
	else
		Plr:SetAttribute("Is_Premium", false)
	end
end

function PlayerUtils.Is_Player_Fighting(Char)
	return typeof(Char) == "Instance"
		and typeof(Char.GetAttribute) == "function"
		and Char:GetAttribute("Is_Fighting") == true
end

function PlayerUtils.Get_Player_Image(P_ID)
	if(Player_Image_Cache[P_ID] == nil)then
		local Type = Enum.ThumbnailType.HeadShot
		local Size = Enum.ThumbnailSize.Size420x420

		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				Data = game.Players:GetUserThumbnailAsync(P_ID, Type, Size)
			end)

			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end

		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				Player_Image_Cache[P_ID] = D
				return D
			end
		end

		return PLAYER_DEFAULT_IMG
	else
		return Player_Image_Cache[P_ID]
	end
end

function PlayerUtils.GetPlayerData(player)
	if not player then return nil end
	return safeFind(player, "Player_Data")
end

function PlayerUtils.GetPlayerVal(player, key)
	local pd = PlayerUtils.GetPlayerData(player)
	if not pd then return nil end
	return safeFind(pd, key)
end

function PlayerUtils.RewardPlayer(player, reward_type, value)
	SE_Mod.PlaySFX(player, "Cash_SE")
	
	if reward_type == "Coins" then
		local Cash_Val = PlayerUtils.GetPlayerVal(player, "Coins")
		if(Cash_Val ~= nil)then
			Cash_Val.Value += value
			Display_Data:FireClient(player,"💸 You won +"..value.." Cash!", Color3.fromRGB(0, 255, 0))
		end
		
	elseif reward_type == "Gems" then
		local Gem_Val = PlayerUtils.GetPlayerVal(player, "Gems")
		if(Gem_Val ~= nil)then
			Gem_Val.Value += value
			Display_Data:FireClient(player,"💎 You won +"..value.." Gems!", Color3.fromRGB(0, 170, 255))
		end
	end
end

function PlayerUtils.GetPlayerDevice()
	if UIS.TouchEnabled then
		return "Mobile"
	elseif UIS.GamepadEnabled then
		return "Console"
	else
		return "PC"
	end
end

function PlayerUtils.GetNearbyPlayers(originPlayer, range)
	local nearby = {}
	local originChar = originPlayer.Character
	if not originChar or not originChar:FindFirstChild("HumanoidRootPart") then return nearby end

	local originPos = originChar.HumanoidRootPart.Position

	for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
		if otherPlayer ~= originPlayer then
			local otherChar = otherPlayer.Character
			if otherChar and otherChar:FindFirstChild("HumanoidRootPart") then
				local dist = (otherChar.HumanoidRootPart.Position - originPos).Magnitude
				if dist <= range then
					table.insert(nearby, otherPlayer)
				end
			end
		end
	end

	table.insert(nearby, originPlayer)

	return nearby
end

function PlayerUtils.Player_Owns_Item_UGC_ServerCheck(Plr, ID)
	
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = MPS:PlayerOwnsAsset(Plr, ID)
		end)

		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end

	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end

	return false
end

function PlayerUtils.GetStartSpawn()
	return game.workspace.Main_World_F.Environment.Spawns.SpawnLocation
end

function PlayerUtils.GoToPosition(player, position:Vector3)
	--local Char = player.Character
	--local HRP = Char:FindFirstChild("HumanoidRootPart")
	--local Position_CF = CFrame.new(position)
	
	--if HRP ~= nil then
	--	HRP.CFrame = Position_CF
	--end
	
	local Char = player.Character
	local Height = Vector3.new(0, 4, 0)
	local Position_CF = CFrame.new(position + Height)
	Char:PivotTo(Position_CF)
end

function PlayerUtils.Award_Badge(player, badgeId)
	if badgeId then
		local success, hasBadge = pcall(function()
			return BadgeService:UserHasBadgeAsync(player.UserId, badgeId)
		end)

		if success and not hasBadge then
			return pcall(function()
				BadgeService:AwardBadge(player.UserId, badgeId)
			end)
		end
	end
end
return PlayerUtils]]></ProtectedString>
						<string name="ScriptGuid">{2CF7042B-E558-474B-9DE7-46B40CDF73A8}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">PlayerUtils.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX22FD80BD2A06438D8996C78324BCCC2E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Modules/StartupUIHeader.lua
--
--  Description:
--      Startup sequence controller responsible for orchestrating all
--      initial UI flows shown when a player joins the experience.
--
--      Main Features:
--          • Standard & First-Time player sequences
--          • UI path resolution helper (PlayerGui-safe)
--          • Event-driven close notifications
--          • Mini tutorial integration (async continuation)
--          • Ordered execution pipeline with automatic fallback
--
--  Last Modified: 2025-12-04 by Darkzeb
--  Version: V2025-12
--
--  Dependencies:
--      • Players service
--      • PlayerGui
--      • Channels (BindableEvents)
--      • StartupUIManager :contentReference[oaicite:0]{index=0}
--      • Utils (reference style/model) :contentReference[oaicite:1]{index=1}
--
--  Notes:
--      • The sequence manager runs steps in strict order and handles
--        both special scripted stages and UI screens.
--      • Each UI step may trigger events instead of enabling UI
--        directly, depending on configuration.
--      • Close notifications propagate through StartupUIManager to
--        continue the sequence safely.
--
--======================================================================
local RS 				= game:GetService("ReplicatedStorage")
local Players 			= game:GetService("Players")
local PlayerGui 		= Players.LocalPlayer:WaitForChild("PlayerGui")

-- Modules
local Data_Mods_F      	= RS:WaitForChild("Data_Mods_F")
local Global_Params_Mod	= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))
local Channels 			= require(game.ReplicatedStorage.Modules.Channels)
local Server_Context 	= workspace:WaitForChild("Server_Context")
local StartupUIManager 	= {}

------------------------------------------------------------
-- CONFIG ORDERS 
--   - FIRSTIME: first connexion of a player => we propose the Tutorial 
--   - STANDARD: popup Daily offer and Daily rewards
--   - TOURNAMENT: no popup
------------------------------------------------------------
StartupUIManager.StandardOrder = {
	{ path = "StarterGui.Shop.Offer_UI",  event = "Open_Starter_Pack" },
	{ path = "StarterGui.Menus.Rewards_UI", event = "Open_Daily_Rewards" },
}

StartupUIManager.FirstTimePlayerOrder = {
	{ special = "Tutorial" }
}

StartupUIManager.Tournament = {
}

local currentIndex = 0
local activeOrder = nil
local isRunning = false
local pendingCloseCallback = nil
local activeClosingPath = nil

------------------------------------------------------------
-- Helpers
------------------------------------------------------------
local function resolvePath(path)
	local parts = string.split(path, ".")
	local obj = PlayerGui

	if parts[1] == "StarterGui" then
		table.remove(parts, 1)
	end

	for _, seg in ipairs(parts) do
		obj = obj:FindFirstChild(seg)
		if not obj then
			warn("[StartupUIManager] Missing UI:", path)
			return nil
		end
	end

	return obj
end

------------------------------------------------------------
-- SPECIAL STEP : TUTORIAL
------------------------------------------------------------
local function runMiniTutorial(nextStep)
	local Show_Tutorial_Launcher = Channels.Bindable_Events.Show_Tutorial_Launcher
	local Close_Tutorial = Channels.Bindable_Events.Close_Tutorial

	-- Fire existing system
	Show_Tutorial_Launcher:Fire()

	-- Listen for REAL tutorial completion
	local conn
	conn = Close_Tutorial.Event:Connect(function(itemName)
		if itemName == nil then
			conn:Disconnect()
			nextStep()
		end
	end)
end

------------------------------------------------------------
-- MAIN SEQUENCE LOOP
------------------------------------------------------------
local function showNext()
	currentIndex += 1

	if currentIndex > #activeOrder then
		isRunning = false
		return
	end

	local entry = activeOrder[currentIndex]

	-- SPECIAL STEP
	if typeof(entry) == "table" and entry.special == "Tutorial" then
		return runMiniTutorial(showNext)
	end

	-- NORMAL UI STEP
	if entry.path then
		local path = entry.path
		local ui = resolvePath(path)

		-- If event exists, fire it instead of enabling the UI directly
		if entry.event then
			local ev = Channels.Bindable_Events[entry.event]
			if ev then ev:Fire() end
		else
			-- Default behavior: enable UI directly
			if ui then 
				ui.Enabled = true 
			end
		end

		activeClosingPath = entry.path
		pendingCloseCallback = function()
			pendingCloseCallback = nil
			activeClosingPath = nil
			showNext()
		end
	end
end

function StartupUIManager.notifyClose(path)
	if pendingCloseCallback and path == activeClosingPath then
		pendingCloseCallback()
	end
end

------------------------------------------------------------
-- STARTER
------------------------------------------------------------
function StartupUIManager.start(isFirstTime)
	if isRunning then return end
	isRunning = true
	currentIndex = 0	
	activeOrder = StartupUIManager.StandardOrder
	
	if isFirstTime then
		activeOrder = StartupUIManager.FirstTimePlayerOrder 
	end 
	
	if Server_Context.Mode.Value == Global_Params_Mod.Server_Mode.TOURNAMENT then
		activeOrder = StartupUIManager.Tournament
	end
	showNext()
end

return StartupUIManager]]></ProtectedString>
						<string name="ScriptGuid">{BA40AE97-D31C-49FF-9B27-63807AF21424}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">StartupUIManager.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX98CD1936BD344753BAD13CCA59510859">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Vendor</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX2F36B5FA43D44B0FA49E607431D7D5EA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Vendor/Spr.lua
--
--  Description:
--      Spring-driven motion library for Roblox. Provides physics-based
--      animations by interpolating instance properties towards target
--      values with configurable damping and frequency. Includes sleep
--      detection to optimize performance.
--
--  Author(s): Fractality (https://github.com/Fraktality/spr)
--  License: MIT (2024)
--
--  Last Modified: 2024 by Fractality (vendored by Darkzeb)
--
--  Version: Upstream 2024
--
--  Dependencies:
--      - Roblox Services:
--          * RunService
--      - Lua math functions
--
--  Notes:
--      - Public API:
--          * spr.target(obj, dampingRatio, undampedFrequency, targetProps)
--              Animates properties towards target values
--          * spr.stop(obj [, property])
--              Stops one or all properties from animating
--      - Supports various property types via type metadata
--      - Automatic sleep when offset & velocity below thresholds
--      - Visualizer available: https://www.desmos.com/calculator/rzvw27ljh9
--
--======================================================================

--!strict
--!native
---------------------------------------------------------------------
-- spr - Spring-driven motion library
--
-- Copyright (c) 2024 Fractality. All rights reserved.
-- Released under the MIT license.
--
-- Docs & license can be found at https://github.com/Fraktality/spr
--
-- API Summary:
--
-- spr.target(
--    Instance obj,
--    number dampingRatio,
--    number undampedFrequency,
--    dict<string, Variant> targetProperties)
--
--    Animates the given properties towardes the target values,
--    given damping ratio and undamped frequency.
--
--
-- spr.stop(
--    Instance obj[,
--    string property])
--
--    Stops the specified property on an Instance from animating.
--    If no property is specified, all properties of the Instance
--    will stop animating.
--
-- Visualizer: https://www.desmos.com/calculator/rzvw27ljh9
---------------------------------------------------------------------

local STRICT_RUNTIME_TYPES = true -- assert on parameter and property type mismatch
local SLEEP_OFFSET_SQ_LIMIT = (1/3840)^2 -- square of the offset sleep limit
local SLEEP_VELOCITY_SQ_LIMIT = 1e-2^2 -- square of the velocity sleep limit
local SLEEP_ROTATION_DIFF = math.rad(0.01) -- rad
local SLEEP_ROTATION_VELOCITY = math.rad(0.1) -- rad/s
local EPS = 1e-5 -- epsilon for stability checks around pathological frequency/damping values

local RunService: RunService = game:GetService("RunService")

local pi = math.pi
local exp = math.exp
local sin = math.sin
local cos = math.cos
local min = math.min
local max = math.max
local sqrt = math.sqrt
local atan2 = math.atan2
local round = math.round

local function magnitudeSq(vec: {number})
	local out = 0
	for _, v in vec do
		out += v^2
	end
	return out
end

local function distanceSq(vec0: {number}, vec1: {number})
	local out = 0
	for i0, v0 in vec0 do
		out += (vec1[i0] - v0)^2
	end
	return out
end

type TypeMetadata<T> = {
	springType: (dampingRatio: number, frequency: number, pos: number, typedat: TypeMetadata<T>, rawTarget: T) -> LinearSpring<T>,
	toIntermediate: (T) -> {number},
	fromIntermediate: ({number}) -> T,
}

-- Spring for an array of linear values
local LinearSpring = {}

type LinearSpring<T> = typeof(setmetatable({} :: {
	d: number,
	f: number,
	g: {number},
	p: {number},
	v: {number},
	typedat: TypeMetadata<T>,
	rawTarget: T,
}, LinearSpring))

do
	LinearSpring.__index = LinearSpring

	function LinearSpring.new<T>(dampingRatio: number, frequency: number, pos: T, rawGoal: T, typedat)
		local linearPos = typedat.toIntermediate(pos)
		return setmetatable(
			{
				d = dampingRatio,
				f = frequency,
				g = linearPos,
				p = linearPos,
				v = table.create(#linearPos, 0),
				typedat = typedat,
				rawGoal = rawGoal
			},
			LinearSpring
		)
	end

	function LinearSpring.setGoal<T>(self, goal: T)
		self.rawGoal = goal
		self.g = self.typedat.toIntermediate(goal)
	end

	function LinearSpring.setDampingRatio<T>(self: LinearSpring<T>, dampingRatio: number)
		self.d = dampingRatio
	end

	function LinearSpring.setFrequency<T>(self: LinearSpring<T>, frequency: number)
		self.f = frequency
	end

	function LinearSpring.canSleep<T>(self)
		if magnitudeSq(self.v) > SLEEP_VELOCITY_SQ_LIMIT then
			return false
		end

		if distanceSq(self.p, self.g) > SLEEP_OFFSET_SQ_LIMIT then
			return false
		end

		return true
	end

	function LinearSpring.step<T>(self: LinearSpring<T>, dt: number)
		-- Advance the spring simulation by dt seconds.
		-- Take the damped harmonic oscillator ODE:
		--    f^2*(X[t] - g) + 2*d*f*X'[t] + X''[t] = 0
		-- Where X[t] is position at time t, g is target position,
		-- f is undamped angular frequency, and d is damping ratio.
		-- Apply constant initial conditions:
		--    X[0] = p0
		--    X'[0] = v0
		-- Solve the IVP to get analytic expressions for X[t] and X'[t].
		-- The solution takes one of three forms for 0<=d<1, d=1, and d>1

		local d = self.d
		local f = self.f*(2*pi) -- Hz -> Rad/s
		local g = self.g
		local p = self.p
		local v = self.v

		if d == 1 then -- critically damped
			local q = exp(-f*dt)
			local w = dt*q

			local c0 = q + w*f
			local c2 = q - w*f
			local c3 = w*f*f

			for idx = 1, #p do
				local o = p[idx] - g[idx]
				p[idx] = o*c0 + v[idx]*w + g[idx]
				v[idx] = v[idx]*c2 - o*c3
			end

		elseif d < 1 then -- underdamped
			local q = exp(-d*f*dt)
			local c = sqrt(1 - d*d)

			local i = cos(dt*f*c)
			local j = sin(dt*f*c)

			-- Damping ratios approaching 1 can cause division by very small numbers.
			-- To mitigate that, group terms around z=j/c and find an approximation for z.
			-- Start with the definition of z:
			--    z = sin(dt*f*c)/c
			-- Substitute a=dt*f:
			--    z = sin(a*c)/c
			-- Take the Maclaurin expansion of z with respect to c:
			--    z = a - (a^3*c^2)/6 + (a^5*c^4)/120 + O(c^6)
			--    z ≈ a - (a^3*c^2)/6 + (a^5*c^4)/120
			-- Rewrite in Horner form:
			--    z ≈ a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6

			local z
			if c > EPS then
				z = j/c
			else
				local a = dt*f
				z = a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6
			end

			-- Frequencies approaching 0 present a similar problem.
			-- We want an approximation for y as f approaches 0, where:
			--    y = sin(dt*f*c)/(f*c)
			-- Substitute b=dt*c:
			--    y = sin(b*c)/b
			-- Now reapply the process from z.

			local y
			if f*c > EPS then
				y = j/(f*c)
			else
				local b = f*c
				y = dt + ((dt*dt)*(b*b)*(b*b)/20 - b*b)*(dt*dt*dt)/6
			end

			for idx = 1, #p do
				local o = p[idx] - g[idx]
				p[idx] = (o*(i + z*d) + v[idx]*y)*q + g[idx]
				v[idx] = (v[idx]*(i - z*d) - o*(z*f))*q
			end

		else -- overdamped
			local c = sqrt(d*d - 1)

			local r1 = -f*(d + c)
			local r2 = -f*(d - c)

			local ec1 = exp(r1*dt)
			local ec2 = exp(r2*dt)

			for idx = 1, #p do
				local o = p[idx] - g[idx]
				local co2 = (v[idx] - o*r1)/(2*f*c)
				local co1 = ec1*(o - co2)

				p[idx] = co1 + co2*ec2 + g[idx]
				v[idx] = co1*r1 + co2*ec2*r2
			end
		end

		return self.typedat.fromIntermediate(self.p)
	end
end

local RotationSpring = {} 

type RotationSpring = typeof(setmetatable({} :: {
	d: number,
	f: number,
	g: CFrame,
	p: CFrame,
	v: Vector3,
}, RotationSpring))

do
	RotationSpring.__index = RotationSpring

	function RotationSpring.new(d: number, f: number, p: CFrame, g: CFrame)
		return setmetatable(
			{
				d = d,
				f = f,
				g = g:Orthonormalize(),
				p = p:Orthonormalize(),
				v = Vector3.zero
			},
			RotationSpring
		)
	end

	function RotationSpring.setGoal(self: RotationSpring, value: CFrame)
		self.g = value:Orthonormalize()
	end

	function RotationSpring.setDampingRatio(self: RotationSpring, dampingRatio: number)
		self.d = dampingRatio
	end

	function RotationSpring.setFrequency(self: RotationSpring, frequency: number)
		self.f = frequency
	end

	-- evaluate dot products in high precision
	local function dot(v0: Vector3, v1: Vector3)
		return v0.X*v1.X + v0.Y*v1.Y + v0.Z*v1.Z
	end

	local function areRotationsClose(c0: CFrame, c1: CFrame)
		local rx = dot(c0.XVector, c1.XVector)
		local ry = dot(c0.YVector, c1.YVector)
		local rz = dot(c0.ZVector, c1.ZVector)
		local trace = rx + ry + rz
		return trace > 1 + 2*cos(SLEEP_ROTATION_DIFF)
	end

	local function angleDiff(c0: CFrame, c1: CFrame)
		local x = dot(c0.XVector, c1.XVector)
		local y = dot(c0.YVector, c1.YVector)
		local z = dot(c0.ZVector, c1.ZVector)
		local w = x + y + z - 1
		return atan2(sqrt(max(0, 1 - w*w*0.25)), w*0.5)
	end

	-- gives approx. 21% accuracy improvement over CFrame.fromAxisAngle near poles
	local function fromAxisAngle(axis: Vector3, angle: number)
		local c = cos(angle)
		local s = sin(angle)
		local x, y, z = axis.X, axis.Y, axis.Z

		local mxy = x*y*(1 - c)
		local myz = y*z*(1 - c)
		local mzx = z*x*(1 - c)

		local rx = Vector3.new(x*x*(1 - c) + c, mxy + z*s, mzx - y*s)
		local ry = Vector3.new(mxy - z*s, y*y*(1 - c) + c, myz + x*s)
		local rz = Vector3.new(mzx + y*s, myz - x*s, z*z*(1 - c) + c)

		return CFrame.fromMatrix(Vector3.zero, rx, ry, rz):Orthonormalize()
	end

	local function rotateAxis(r0: Vector3, c1: CFrame)
		local c0 = CFrame.identity
		local mag = r0.Magnitude
		if mag > 1e-6 then
			c0 = fromAxisAngle(r0.Unit, mag)
		end
		return c0 * c1
	end

	-- axis*angle difference between two cframes
	local function axisAngleDiff(c0: CFrame, c1: CFrame)
		-- use native axis (stable enough)
		local axis = (c0*c1:Inverse()):ToAxisAngle()

		-- use full-precision angle calculation to minimize truncation
		local angle = angleDiff(c0, c1)
		return axis.Unit*angle
	end

	function RotationSpring.canSleep(self: RotationSpring)
		local sleepP = areRotationsClose(self.p, self.g)
		local sleepV = self.v.Magnitude < SLEEP_ROTATION_VELOCITY
		return sleepP and sleepV
	end

	function RotationSpring.step(self: RotationSpring, dt: number): CFrame
		local d = self.d
		local f = self.f*(2*pi)
		local g = self.g
		local p0 = self.p
		local v0 = self.v

		local offset = axisAngleDiff(p0, g)
		local decay = exp(-d*f*dt)

		local pt: CFrame
		local vt: Vector3

		if d == 1 then -- critically damped
			pt = rotateAxis((offset*(1 + f*dt) + v0*dt)*decay, g)
			vt = (v0*(1 - dt*f) - offset*(dt*f*f))*decay

		elseif d < 1 then -- underdamped
			local c = sqrt(1 - d*d)

			local i = cos(dt*f*c)
			local j = sin(dt*f*c)

			local y = j/(f*c)
			local z = j/c

			pt = rotateAxis((offset*(i + z*d) + v0*y)*decay, g)
			vt = (v0*(i - z*d) - offset*(z*f))*decay

		else -- overdamped
			local c = sqrt(d*d - 1)

			local r1 = -f*(d + c)
			local r2 = -f*(d - c)

			local co2 = (v0 - offset*r1)/(2*f*c)
			local co1 = offset - co2

			local e1 = co1*exp(r1*dt)
			local e2 = co2*exp(r2*dt)

			pt = rotateAxis(e1 + e2, g)
			vt = e1*r1 + e2*r2
		end

		self.p = pt
		self.v = vt

		return pt
	end
end

-- Defined early to be used by CFrameSpring
local typeMetadata_Vector3 = {
	springType = LinearSpring.new,

	toIntermediate = function(value)
		return {value.X, value.Y, value.Z}
	end,

	fromIntermediate = function(value: {number})
		return Vector3.new(value[1], value[2], value[3])
	end,
}

-- Encapsulates a CFrame - Separates translation from rotation
local CFrameSpring = {}
do
	CFrameSpring.__index = CFrameSpring

	function CFrameSpring.new(
		dampingRatio: number,
		frequency: number,
		valueCurrent: CFrame,
		valueGoal: CFrame,
		_: any
	)
		return setmetatable(
			{
				rawGoal = valueGoal,
				_position = LinearSpring.new(dampingRatio, frequency, valueCurrent.Position, valueGoal.Position, typeMetadata_Vector3),
				_rotation = RotationSpring.new(dampingRatio, frequency, valueCurrent.Rotation, valueGoal.Rotation)
			},
			CFrameSpring
		)
	end

	function CFrameSpring:setGoal(value: CFrame)
		self.rawGoal = value
		self._position:setGoal(value.Position)
		self._rotation:setGoal(value.Rotation)
	end

	function CFrameSpring:setDampingRatio(value: number)
		self._position.d = value
		self._rotation.d = value
	end

	function CFrameSpring:setFrequency(value: number)
		self._position.f = value
		self._rotation.f = value
	end

	function CFrameSpring:canSleep()
		return self._position:canSleep() and self._rotation:canSleep()
	end

	function CFrameSpring:step(dt): CFrame
		local p: Vector3 = self._position:step(dt)
		local r: CFrame = self._rotation:step(dt)
		return r + p
	end
end

-- Color conversions
local rgbToLuv
local luvToRgb
do
	local function inverseGammaCorrectD65(c)
		return c < 0.0404482362771076 and c/12.92 or 0.87941546140213*(c + 0.055)^2.4
	end

	local function gammaCorrectD65(c)
		return c < 3.1306684425e-3 and 12.92*c or 1.055*c^(1/2.4) - 0.055
	end

	function rgbToLuv(value: Color3): {number}
		-- convert RGB to a variant of cieluv space
		local r, g, b = value.R, value.G, value.B

		-- D65 sRGB inverse gamma correction
		r = inverseGammaCorrectD65(r)
		g = inverseGammaCorrectD65(g)
		b = inverseGammaCorrectD65(b)

		-- sRGB -> xyz
		local x = 0.9257063972951867*r - 0.8333736323779866*g - 0.09209820666085898*b
		local y = 0.2125862307855956*r + 0.71517030370341085*g + 0.0722004986433362*b
		local z = 3.6590806972265883*r + 11.4426895800574232*g + 4.1149915024264843*b

		-- xyz -> scaled cieluv
		local l = y > 0.008856451679035631 and 116*y^(1/3) - 16 or 903.296296296296*y

		local u, v
		if z > 1e-14 then
			u = l*x/z
			v = l*(9*y/z - 0.46832)
		else
			u = -0.19783*l
			v = -0.46832*l
		end

		return {l, u, v}
	end

	function luvToRgb(value: {number}): Color3
		-- convert back from modified cieluv to rgb space
		local l = value[1]
		if l < 0.0197955 then
			return Color3.new(0, 0, 0)
		end
		local u = value[2]/l + 0.19783
		local v = value[3]/l + 0.46832

		-- cieluv -> xyz
		local y = (l + 16)/116
		y = y > 0.206896551724137931 and y*y*y or 0.12841854934601665*y - 0.01771290335807126
		local x = y*u/v
		local z = y*((3 - 0.75*u)/v - 5)

		-- xyz -> D65 sRGB
		local r =  7.2914074*x - 1.5372080*y - 0.4986286*z
		local g = -2.1800940*x + 1.8757561*y + 0.0415175*z
		local b =  0.1253477*x - 0.2040211*y + 1.0569959*z

		-- clamp minimum sRGB component
		if r < 0 and r < g and r < b then
			r, g, b = 0, g - r, b - r
		elseif g < 0 and g < b then
			r, g, b = r - g, 0, b - g
		elseif b < 0 then
			r, g, b = r - b, g - b, 0
		end

		-- gamma correction from D65
		-- clamp to avoid undesirable overflow wrapping behavior on certain properties (e.g. BasePart.Color)
		return Color3.new(
			min(gammaCorrectD65(r), 1),
			min(gammaCorrectD65(g), 1),
			min(gammaCorrectD65(b), 1)
		)
	end
end

-- Type definitions
-- Transforms Roblox types into intermediate types, converting
-- between spaces as necessary to preserve perceptual linearity
local typeMetadata = {
	boolean = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value and 1 or 0}
		end,

		fromIntermediate = function(value)
			return value[1] >= 0.5
		end,
	},

	number = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value}
		end,

		fromIntermediate = function(value)
			return value[1]
		end,
	},

	NumberRange = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value.Min, value.Max}
		end,

		fromIntermediate = function(value)
			return NumberRange.new(value[1], value[2])
		end,
	},

	UDim = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value.Scale, value.Offset}
		end,

		fromIntermediate = function(value: {number})
			return UDim.new(value[1], round(value[2]))
		end,
	},

	UDim2 = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			local x = value.X
			local y = value.Y
			return {x.Scale, x.Offset, y.Scale, y.Offset}
		end,

		fromIntermediate = function(value: {number})
			return UDim2.new(value[1], round(value[2]), value[3], round(value[4]))
		end,
	},

	Vector2 = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value.X, value.Y}
		end,

		fromIntermediate = function(value: {number})
			return Vector2.new(value[1], value[2])
		end,
	},

	Vector3 = typeMetadata_Vector3,

	Color3 = {
		springType = LinearSpring.new,
		toIntermediate = rgbToLuv,
		fromIntermediate = luvToRgb,
	},

	-- Only interpolates start and end keypoints
	ColorSequence = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			local keypoints = value.Keypoints

			local luv0 = rgbToLuv(keypoints[1].Value)
			local luv1 = rgbToLuv(keypoints[#keypoints].Value)

			return {
				luv0[1], luv0[2], luv0[3],
				luv1[1], luv1[2], luv1[3],
			}
		end,

		fromIntermediate = function(value: {})
			return ColorSequence.new(
				luvToRgb{value[1], value[2], value[3]},
				luvToRgb{value[4], value[5], value[6]}
			)
		end,
	},

	CFrame = {
		springType = CFrameSpring.new,
		toIntermediate = error, -- custom (CFrameSpring)
		fromIntermediate = error, -- custom (CFrameSpring)
	}
}

type PropertyOverride = {
	[string]: {
		class: string,
		get: (any)->(),
		set: (any, any)->(),
	}
}

local PSEUDO_PROPERTIES: PropertyOverride = {
	Pivot = {
		class = "PVInstance",
		get = function(inst: PVInstance)
			return inst:GetPivot()
		end,
		set = function(inst: PVInstance, value: CFrame)
			inst:PivotTo(value)
		end
	},
	Scale = {
		class = "Model",
		get = function(inst: Model)
			return inst:GetScale()
		end,
		set = function(inst: Model, value: number)
			local FLOAT_MANTISSA_MIN = 1.402e-45
			local FLOAT_MANTISSA_MAX = 2^24
			value = math.clamp(value, FLOAT_MANTISSA_MIN, FLOAT_MANTISSA_MAX)
			inst:ScaleTo(value)
		end
	}
}

local function getProperty(instance: Instance, property: string): any
	local override = PSEUDO_PROPERTIES[property]
	if override and instance:IsA(override.class) then
		return override.get(instance)
	else
		return (instance :: any)[property]
	end
end

local function setProperty(instance: Instance, property: string, value: unknown)
	local override = PSEUDO_PROPERTIES[property]
	if override and instance:IsA(override.class) then
		override.set(instance, value)
	else
		(instance :: any)[property] = value
	end
end

-- Frame loop
local springStates_other: {[Instance]: {[string]: any}} = {} -- {[instance] = {[property] = spring}
local springStates_render: {[Instance]: {[string]: any}} = {} -- {[instance] = {[property] = spring}
local completedCallbacks: {[Instance]: {()->()}} = {}

local function processSprings(springStates: typeof(springStates_other), dt: number)
	for instance, state in springStates do
		for propName, spring in state do
			if spring:canSleep() then
				state[propName] = nil
				setProperty(instance, propName, spring.rawGoal)
			else
				setProperty(instance, propName, spring:step(dt))
			end
		end

		if not next(state) then
			springStates[instance] = nil

			-- trigger completed callbacks when all properties finish animating
			local callbackList = completedCallbacks[instance]
			if callbackList then
				-- flush callback list before we run any callbacks in case
				-- one of the callbacks recursively adds another callback
				completedCallbacks[instance] = nil

				for _, callback in callbackList do
					task.spawn(callback)
				end
			end
		end
	end
end

RunService.PreSimulation:Connect(function(dt)
	processSprings(springStates_other, dt)
end)

RunService.PostSimulation:Connect(function(dt)
	processSprings(springStates_render, dt)
end)

local function assertType(argNum: number, fnName: string, expectedType: string, value: unknown)
	if not expectedType:find(typeof(value)) then
		error(`bad argument #{argNum} to {fnName} ({expectedType} expected, got {typeof(value)})`, 3)
	end
end

-- API
local spr = {}

function spr.target(instance: Instance, dampingRatio: number, frequency: number, properties: {[string]: any})
	if STRICT_RUNTIME_TYPES then
		assertType(1, "spr.target", "Instance", instance)
		assertType(2, "spr.target", "number", dampingRatio)
		assertType(3, "spr.target", "number", frequency)
		assertType(4, "spr.target", "table", properties)
	end

	if dampingRatio ~= dampingRatio or dampingRatio < 0 then
		error(("expected damping ratio >= 0; got %.2f"):format(dampingRatio), 2)
	end

	if frequency ~= frequency or frequency < 0 then
		error(("expected undamped frequency >= 0; got %.2f"):format(frequency), 2)
	end

	local targetRecord = (if instance:IsA("Camera") then springStates_render else springStates_other) :: {[Instance]: {[string]: any}}

	local state = targetRecord[instance]
	if not state then
		state = {}
		targetRecord[instance] = state
	end

	for propName, propTarget in properties do
		local propValue = getProperty(instance, propName)

		if STRICT_RUNTIME_TYPES and typeof(propTarget) ~= typeof(propValue) then
			error(`bad property {propName} to spr.target ({typeof(propValue)} expected, got {typeof(propTarget)})`, 2)
		end

		-- Special case infinite frequency for an instantaneous change
		if frequency == math.huge then
			setProperty(instance, propName, propTarget)
			state[propName] = nil
			continue
		end

		local spring = state[propName]
		if not spring then
			local md = typeMetadata[typeof(propTarget)]
			if not md then
				error("unsupported type: " .. typeof(propTarget), 2)
			end

			spring = md.springType(dampingRatio, frequency, propValue, propTarget, md)
			state[propName] = spring
		end

		spring:setGoal(propTarget)
		spring:setDampingRatio(dampingRatio)
		spring:setFrequency(frequency)
	end

	if not next(state) then
		targetRecord[instance] = nil
	end
end

function spr.stop(instance: Instance, property: string?)
	if STRICT_RUNTIME_TYPES then
		assertType(1, "spr.stop", "Instance", instance)
		assertType(2, "spr.stop", "string|nil", property)
	end

	if property then
		local state = springStates_other[instance] or springStates_render[instance]
		if state then
			state[property] = nil
		end
	else
		springStates_other[instance] = nil
		springStates_render[instance] = nil
	end
end

function spr.completed(instance: Instance, callback: ()->())
	if STRICT_RUNTIME_TYPES then
		assertType(1, "spr.completed", "Instance", instance)
		assertType(2, "spr.completed", "function", callback)
	end

	local callbackList = completedCallbacks[instance]
	if callbackList then
		table.insert(callbackList, callback)
	else
		completedCallbacks[instance] = {callback}
	end
end

return table.freeze(spr)]]></ProtectedString>
						<string name="ScriptGuid">{6F076BAA-48FD-442E-97A2-689D10889042}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Spr.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCF6593FE87724D72BC29B977421F7E68">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Vendor/Find.lua
--
--  Description:
--      Utility function to locate a descendant instance by name.
--      Calls a callback immediately if found, otherwise waits for
--      DescendantAdded and disconnects once the instance appears.
--
--  Author(s): Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox API:
--          * Instance:FindFirstChild
--          * Instance.DescendantAdded
--
--  Notes:
--      - Usage:
--          local Find = require(ReplicatedStorage.Vendor.Find)
--          Find(workspace, "TargetPart", function(obj)
--              print("Found:", obj:GetFullName())
--          end)
--      - Disconnects listener once object is found
--
--======================================================================


return function(root:Instance,ref:string,callback)
	local result = root:FindFirstChild(ref,true)
	if result then
		callback(result)
	end

	local conn:RBXScriptConnection
	conn = root.DescendantAdded:Connect(function(newObj:Instance)
		if newObj.Name == ref then
			conn:Disconnect()
			callback(newObj)
		end
	end)

end]]></ProtectedString>
						<string name="ScriptGuid">{94C1AEDA-7322-4B90-B0ED-320CAB7F3239}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Find.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX35F6D8F319914294B72BCE6883E46080">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Vendor/Trove.lua
--
--  Description:
--      Utility for managing collections of cleanup tasks (connections,
--      Instances, functions) grouped into a “Trove”. When the trove is
--      destroyed, all registered items are cleaned up automatically.
--
--  Author(s): (original author upstream) — vendored by Darkzeb
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: vendored version
--
--  Dependencies:
--      - Roblox API:
--          * Instance connection/disconnect
--          * :Destroy for Instances
--          * Property `.Parent`, AncestryChanged (if auto-binding to parent)
--
--  Notes:
--      - Use `Trove.new([parent])` to create a new trove optionally bound to a parent Instance
--      - Methods:
--          * `Add(item)` – registers cleanup for connection, Instance, or function
--          * `Remove(item)` / `Unlink(item)` – removes item from trove without cleanup
--          * `Destroy()` – triggers cleanup for all registered items
--      - If parent is provided, trove auto-destroys when parent is removed from the game
--      - Commonly used to manage lifetime of connections and instances in components/controllers
--
--======================================================================

--!strict

local RunService = game:GetService("RunService")

export type Trove = {
	Extend: (self: Trove) -> Trove,
	Clone: <T>(self: Trove, instance: T & Instance) -> T,
	Construct: <T, A...>(self: Trove, class: Constructable<T, A...>, A...) -> T,
	Connect: (self: Trove, signal: SignalLike | RBXScriptSignal, fn: (...any) -> ...any) -> ConnectionLike,
	BindToRenderStep: (self: Trove, name: string, priority: number, fn: (dt: number) -> ()) -> (),
	AddPromise: <T>(self: Trove, promise: T & PromiseLike) -> T,
	Add: <T>(self: Trove, object: T & Trackable, cleanupMethod: string?) -> T,
	Remove: <T>(self: Trove, object: T & Trackable) -> boolean,
	Clean: (self: Trove) -> (),
	AttachToInstance: (self: Trove, instance: Instance) -> RBXScriptConnection,
	Destroy: (self: Trove) -> (),
}

type TroveInternal = Trove & {
	_objects: { any },
	_cleaning: boolean,
	_findAndRemoveFromObjects: (self: TroveInternal, object: any, cleanup: boolean) -> boolean,
	_cleanupObject: (self: TroveInternal, object: any, cleanupMethod: string?) -> (),
}

--[=[
	@within Trove
	@type Trackable Instance | RBXScriptConnection | ConnectionLike | PromiseLike | thread | ((...any) -> ...any) | Destroyable | DestroyableLowercase | Disconnectable | DisconnectableLowercase
	Represents all trackable objects by Trove.
]=]
export type Trackable =
	Instance
| RBXScriptConnection
| ConnectionLike
| PromiseLike
| thread
| ((...any) -> ...any)
| Destroyable
| DestroyableLowercase
| Disconnectable
| DisconnectableLowercase

--[=[
	@within Trove
	@interface ConnectionLike
	.Connected boolean
	.Disconnect (self) -> ()
]=]
type ConnectionLike = {
	Connected: boolean,
	Disconnect: (self: ConnectionLike) -> (),
}

--[=[
	@within Trove
	@interface SignalLike
	.Connect (self, callback: (...any) -> ...any) -> ConnectionLike
	.Once (self, callback: (...any) -> ...any) -> ConnectionLike
]=]
type SignalLike = {
	Connect: (self: SignalLike, callback: (...any) -> ...any) -> ConnectionLike,
	Once: (self: SignalLike, callback: (...any) -> ...any) -> ConnectionLike,
}

--[=[
	@within Trove
	@interface PromiseLike
	.getStatus (self) -> string
	.finally (self, callback: (...any) -> ...any) -> PromiseLike
	.cancel (self) -> ()
]=]
type PromiseLike = {
	getStatus: (self: PromiseLike) -> string,
	finally: (self: PromiseLike, callback: (...any) -> ...any) -> PromiseLike,
	cancel: (self: PromiseLike) -> (),
}

--[=[
	@within Trove
	@type Constructable { new: (A...) -> T } | (A...) -> T
]=]
type Constructable<T, A...> = { new: (A...) -> T } | (A...) -> T

--[=[
	@within Trove
	@interface Destroyable
	.disconnect (self) -> ()
]=]
type Destroyable = {
	Destroy: (self: Destroyable) -> (),
}

--[=[
	@within Trove
	@interface DestroyableLowercase
	.disconnect (self) -> ()
]=]
type DestroyableLowercase = {
	destroy: (self: DestroyableLowercase) -> (),
}

--[=[
	@within Trove
	@interface Disconnectable
	.disconnect (self) -> ()
]=]
type Disconnectable = {
	Disconnect: (self: Disconnectable) -> (),
}

--[=[
	@within Trove
	@interface DisconnectableLowercase
	.disconnect (self) -> ()
]=]
type DisconnectableLowercase = {
	disconnect: (self: DisconnectableLowercase) -> (),
}

local FN_MARKER = newproxy()
local THREAD_MARKER = newproxy()
local GENERIC_OBJECT_CLEANUP_METHODS = table.freeze({ "Destroy", "Disconnect", "destroy", "disconnect" })

local function GetObjectCleanupFunction(object: any, cleanupMethod: string?)
	local t = typeof(object)

	if t == "function" then
		return FN_MARKER
	elseif t == "thread" then
		return THREAD_MARKER
	end

	if cleanupMethod then
		return cleanupMethod
	end

	if t == "Instance" then
		return "Destroy"
	elseif t == "RBXScriptConnection" then
		return "Disconnect"
	elseif t == "table" then
		for _, genericCleanupMethod in GENERIC_OBJECT_CLEANUP_METHODS do
			if typeof(object[genericCleanupMethod]) == "function" then
				return genericCleanupMethod
			end
		end
	end

	error(`failed to get cleanup function for object {t}: {object}`, 3)
end

local function AssertPromiseLike(object: any)
	if
		typeof(object) ~= "table"
		or typeof(object.getStatus) ~= "function"
		or typeof(object.finally) ~= "function"
		or typeof(object.cancel) ~= "function"
	then
		error("did not receive a promise as an argument", 3)
	end
end

--[=[
	@class Trove
	A Trove is helpful for tracking any sort of object during
	runtime that needs to get cleaned up at some point.
]=]
local Trove = {}
Trove.__index = Trove

--[=[
	@return Trove
	Constructs a Trove object.

	```lua
	local trove = Trove.new()
	```
]=]
function Trove.new(): Trove
	local self = setmetatable({}, Trove)

	self._objects = {}
	self._cleaning = false

	return (self :: any) :: Trove
end

--[=[
	@method Add
	@within Trove
	@param object any -- Object to track
	@param cleanupMethod string? -- Optional cleanup name override
	@return object: any
	Adds an object to the trove. Once the trove is cleaned or
	destroyed, the object will also be cleaned up.

	The following types are accepted (e.g. `typeof(object)`):

	| Type | Cleanup |
	| ---- | ------- |
	| `Instance` | `object:Destroy()` |
	| `RBXScriptConnection` | `object:Disconnect()` |
	| `function` | `object()` |
	| `thread` | `task.cancel(object)` |
	| `table` | `object:Destroy()` _or_ `object:Disconnect()` _or_ `object:destroy()` _or_ `object:disconnect()` |
	| `table` with `cleanupMethod` | `object:<cleanupMethod>()` |

	Returns the object added.

	```lua
	-- Add a part to the trove, then destroy the trove,
	-- which will also destroy the part:
	local part = Instance.new("Part")
	trove:Add(part)
	trove:Destroy()

	-- Add a function to the trove:
	trove:Add(function()
		print("Cleanup!")
	end)
	trove:Destroy()

	-- Standard cleanup from table:
	local tbl = {}
	function tbl:Destroy()
		print("Cleanup")
	end
	trove:Add(tbl)

	-- Custom cleanup from table:
	local tbl = {}
	function tbl:DoSomething()
		print("Do something on cleanup")
	end
	trove:Add(tbl, "DoSomething")
	```
]=]
function Trove.Add(self: TroveInternal, object: Trackable, cleanupMethod: string?): any
	if self._cleaning then
		error("cannot call trove:Add() while cleaning", 2)
	end

	local cleanup = GetObjectCleanupFunction(object, cleanupMethod)
	table.insert(self._objects, { object, cleanup })

	return object
end

--[=[
	@method Clone
	@within Trove
	@return Instance
	Clones the given instance and adds it to the trove. Shorthand for
	`trove:Add(instance:Clone())`.

	```lua
	local clonedPart = trove:Clone(somePart)
	```
]=]
function Trove.Clone(self: TroveInternal, instance: Instance): Instance
	if self._cleaning then
		error("cannot call trove:Clone() while cleaning", 2)
	end

	return self:Add(instance:Clone())
end

--[=[
	@method Construct
	@within Trove
	@param class { new(Args...) -> T } | (Args...) -> T
	@param ... Args...
	@return T
	Constructs a new object from either the
	table or function given.

	If a table is given, the table's `new`
	function will be called with the given
	arguments.

	If a function is given, the function will
	be called with the given arguments.
	
	The result from either of the two options
	will be added to the trove.

	This is shorthand for `trove:Add(SomeClass.new(...))`
	and `trove:Add(SomeFunction(...))`.

	```lua
	local Signal = require(somewhere.Signal)

	-- All of these are identical:
	local s = trove:Construct(Signal)
	local s = trove:Construct(Signal.new)
	local s = trove:Construct(function() return Signal.new() end)
	local s = trove:Add(Signal.new())

	-- Even Roblox instances can be created:
	local part = trove:Construct(Instance, "Part")
	```
]=]
function Trove.Construct<T, A...>(self: TroveInternal, class: Constructable<T, A...>, ...: A...)
	if self._cleaning then
		error("Cannot call trove:Construct() while cleaning", 2)
	end

	local object = nil
	local t = type(class)
	if t == "table" then
		object = (class :: any).new(...)
	elseif t == "function" then
		object = (class :: any)(...)
	end

	return self:Add(object)
end

--[=[
	@method Connect
	@within Trove
	@param signal RBXScriptSignal
	@param fn (...: any) -> ()
	@return RBXScriptConnection
	Connects the function to the signal, adds the connection
	to the trove, and then returns the connection.

	This is shorthand for `trove:Add(signal:Connect(fn))`.

	```lua
	trove:Connect(workspace.ChildAdded, function(instance)
		print(instance.Name .. " added to workspace")
	end)
	```
]=]
function Trove.Connect(self: TroveInternal, signal: SignalLike, fn: (...any) -> ...any)
	if self._cleaning then
		error("Cannot call trove:Connect() while cleaning", 2)
	end

	return self:Add(signal:Connect(fn))
end

--[=[
	@method BindToRenderStep
	@within Trove
	@param name string
	@param priority number
	@param fn (dt: number) -> ()
	Calls `RunService:BindToRenderStep` and registers a function in the
	trove that will call `RunService:UnbindFromRenderStep` on cleanup.

	```lua
	trove:BindToRenderStep("Test", Enum.RenderPriority.Last.Value, function(dt)
		-- Do something
	end)
	```
]=]
function Trove.BindToRenderStep(self: TroveInternal, name: string, priority: number, fn: (dt: number) -> ())
	if self._cleaning then
		error("cannot call trove:BindToRenderStep() while cleaning", 2)
	end

	RunService:BindToRenderStep(name, priority, fn)

	self:Add(function()
		RunService:UnbindFromRenderStep(name)
	end)
end

--[=[
	@method AddPromise
	@within Trove
	@param promise Promise
	@return Promise
	Gives the promise to the trove, which will cancel the promise if the trove is cleaned up or if the promise
	is removed. The exact promise is returned, thus allowing chaining.

	```lua
	trove:AddPromise(doSomethingThatReturnsAPromise())
		:andThen(function()
			print("Done")
		end)
	-- Will cancel the above promise (assuming it didn't resolve immediately)
	trove:Clean()

	local p = trove:AddPromise(doSomethingThatReturnsAPromise())
	-- Will also cancel the promise
	trove:Remove(p)
	```

	:::caution Promise v4 Only
	This is only compatible with the [roblox-lua-promise](https://eryn.io/roblox-lua-promise/) library, version 4.
	:::
]=]
function Trove.AddPromise(self: TroveInternal, promise: PromiseLike)
	if self._cleaning then
		error("cannot call trove:AddPromise() while cleaning", 2)
	end
	AssertPromiseLike(promise)

	if promise:getStatus() == "Started" then
		promise:finally(function()
			if self._cleaning then
				return
			end
			self:_findAndRemoveFromObjects(promise, false)
		end)

		self:Add(promise, "cancel")
	end

	return promise
end

--[=[
	@method Remove
	@within Trove
	@param object any
	Removes the object from the Trove and cleans it up.

	```lua
	local part = Instance.new("Part")
	trove:Add(part)
	trove:Remove(part)
	```
]=]
function Trove.Remove(self: TroveInternal, object: Trackable): boolean
	if self._cleaning then
		error("cannot call trove:Remove() while cleaning", 2)
	end

	return self:_findAndRemoveFromObjects(object, true)
end

--[=[
	@method Extend
	@within Trove
	@return Trove
	Creates and adds another trove to itself. This is just shorthand
	for `trove:Construct(Trove)`. This is useful for contexts where
	the trove object is present, but the class itself isn't.

	:::note
	This does _not_ clone the trove. In other words, the objects in the
	trove are not given to the new constructed trove. This is simply to
	construct a new Trove and add it as an object to track.
	:::

	```lua
	local trove = Trove.new()
	local subTrove = trove:Extend()

	trove:Clean() -- Cleans up the subTrove too
	```
]=]
function Trove.Extend(self: TroveInternal)
	if self._cleaning then
		error("cannot call trove:Extend() while cleaning", 2)
	end

	return self:Construct(Trove)
end

--[=[
	@method Clean
	@within Trove
	Cleans up all objects in the trove. This is
	similar to calling `Remove` on each object
	within the trove. The ordering of the objects
	removed is _not_ guaranteed.

	```lua
	trove:Clean()
	```
]=]
function Trove.Clean(self: TroveInternal)
	if self._cleaning then
		return
	end

	self._cleaning = true

	for _, obj in self._objects do
		self:_cleanupObject(obj[1], obj[2])
	end

	table.clear(self._objects)
	self._cleaning = false
end

--[=[
	@method WrapClean
	@within Trove
	Returns a function that wraps the trove's `Clean()`
	method. Calling the returned function will clean up
	the trove.

	This is often useful in contexts where functions
	are the primary mode for cleaning up an environment,
	such as in many "observer" patterns.

	```lua
	local cleanup = trove:WrapClean()

	-- Sometime later...
	cleanup()
	```

	```lua
	-- Common observer pattern example:
	someObserver(function()
		local trove = Trove.new()
		-- Foo
		return trove:WrapClean()
	end)
	```
]=]
function Trove.WrapClean(self: TroveInternal)
	return function()
		self:Clean()
	end
end

function Trove._findAndRemoveFromObjects(self: TroveInternal, object: any, cleanup: boolean): boolean
	local objects = self._objects

	for i, obj in objects do
		if obj[1] == object then
			local n = #objects
			objects[i] = objects[n]
			objects[n] = nil

			if cleanup then
				self:_cleanupObject(obj[1], obj[2])
			end

			return true
		end
	end

	return false
end

function Trove._cleanupObject(_self: TroveInternal, object: any, cleanupMethod: string?)
	if cleanupMethod == FN_MARKER then
		task.spawn(object)
	elseif cleanupMethod == THREAD_MARKER then
		pcall(task.cancel, object)
	else
		object[cleanupMethod](object)
	end
end

--[=[
	@method AttachToInstance
	@within Trove
	@param instance Instance
	@return RBXScriptConnection
	Attaches the trove to a Roblox instance. Once this
	instance is removed from the game (parent or ancestor's
	parent set to `nil`), the trove will automatically
	clean up.

	This inverses the ownership of the Trove object, and should
	only be used when necessary. In other words, the attached
	instance dictates when the trove is cleaned up, rather than
	the trove dictating the cleanup of the instance.

	:::caution
	Will throw an error if `instance` is not a descendant
	of the game hierarchy.
	:::

	```lua
	trove:AttachToInstance(somePart)
	trove:Add(function()
		print("Cleaned")
	end)

	-- Destroying the part will cause the trove to clean up, thus "Cleaned" printed:
	somePart:Destroy()
	```
]=]
function Trove.AttachToInstance(self: TroveInternal, instance: Instance)
	if self._cleaning then
		error("cannot call trove:AttachToInstance() while cleaning", 2)
	elseif not instance:IsDescendantOf(game) then
		error("instance is not a descendant of the game hierarchy", 2)
	end

	return self:Connect(instance.Destroying, function()
		self:Destroy()
	end)
end

--[=[
	@method Destroy
	@within Trove
	Alias for `trove:Clean()`.

	```lua
	trove:Destroy()
	```
]=]
function Trove.Destroy(self: TroveInternal)
	self:Clean()
end

return {
	new = Trove.new,
}
]]></ProtectedString>
						<string name="ScriptGuid">{C625A0C5-7A85-4275-856C-C353AD922CBB}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Trove.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX41B0A6C506A34132820192DF6612FE19">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	
	The majority of this code is an interface designed to make it easy for you to
	work with TopbarPlus (most methods for instance reference :modifyTheme()).
	The processing overhead mainly consists of applying themes and calculating 
	appearance (such as size and width of labels) which is handled in about
	200 lines of code here and the Widget UI module. This has been achieved
	in v3 by outsourcing a majority of previous calculations to inbuilt Roblox
	features like UIListLayouts.


	v3 provides inbuilt support for controllers (simply press DPadUp),
	touch devices (phones, tablets , etc), localization (automatic resizing
	of widgets, autolocalize for relevant labels), backwards compatability
	with the old topbar, and more.


	My primary goals for the v3 re-write have been to:
		
	1. Improve code readability and organisation (reduced lines of code within
	   Icon+IconController from 3200 to ~950, separated UI elements, etc)
		
	2. Improve ease-of-use (themes now actually make sense and can account
	   for any modifications you want, converted to a package for
	   quick installation and easy-comparisons of new updates, etc)
	
	3. Provide support for all key features of the new Roblox topbar
	   while improving performance of the module (deferring and collecting
	   changes then calling as a singular, utilizing inbuilt Roblox features
	   such as UILIstLayouts, etc)

--]]



-- SERVICES
local UserInputService = game:GetService("UserInputService")
local ContentProvider = game:GetService("ContentProvider")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local Types = require(script.Types)



-- TYPES
export type Icon = Types.Icon



-- REFERENCE HANDLER
-- Multiple Icons packages may exist at runtime (for instance if the developer additionally uses HD Admin)
-- therefore this ensures that the first required package becomes the dominant and only functioning module
local iconModule = script
local Reference = require(iconModule.Reference)
local referenceObject = Reference.getObject()
local leadPackage = referenceObject and referenceObject.Value
if leadPackage and leadPackage ~= iconModule then
	return require(leadPackage) :: Types.StaticIcon
end
if not referenceObject then
	Reference.addToReplicatedStorage()
end



-- MODULES
local Signal = require(iconModule.Packages.GoodSignal)
local Janitor = require(iconModule.Packages.Janitor)
local Utility = require(iconModule.Utility)
local Themes = require(iconModule.Features.Themes)
local Gamepad = require(iconModule.Features.Gamepad)
local Overflow = require(iconModule.Features.Overflow)
local Icon = {}
Icon.__index = Icon



--- LOCAL
local localPlayer = Players.LocalPlayer
local themes = iconModule.Features.Themes
local iconsDict = {}
local anyIconSelected = Signal.new()
local elements = iconModule.Elements
local totalCreatedIcons = 0
local preferredInput = {
	mobile = Enum.PreferredInput.Touch,
	desktop = Enum.PreferredInput.KeyboardAndMouse,
	console = Enum.PreferredInput.Gamepad
}



-- PUBLIC VARIABLES
Icon.baseDisplayOrderChanged = Signal.new()
Icon.baseDisplayOrder = 10
Icon.baseTheme = require(themes.Default)
Icon.isOldTopbar = false -- Logic has been moved to Container
Icon.iconsDictionary = iconsDict
Icon.insetHeightChanged = Signal.new()
Icon.container = require(elements.Container)(Icon)
Icon.topbarEnabled = true
Icon.iconAdded = Signal.new()
Icon.iconRemoved = Signal.new()
Icon.iconChanged = Signal.new()



-- PUBLIC FUNCTIONS
function Icon.getIcons()
	return Icon.iconsDictionary
end

function Icon.getIconByUID(UID)
	local match = Icon.iconsDictionary[UID]
	if match then
		return match
	end
	return nil
end

function Icon.getIcon(nameOrUID)
	local match = Icon.getIconByUID(nameOrUID)
	if match then
		return match
	end
	for _, icon in pairs(iconsDict) do
		if icon.name == nameOrUID then
			return icon
		end
	end
	return nil
end

function Icon.setTopbarEnabled(bool, isInternal)
	if typeof(bool) ~= "boolean" then
		bool = Icon.topbarEnabled
	end
	if not isInternal then
		Icon.topbarEnabled = bool
	end
	for _, screenGui in pairs(Icon.container) do
		screenGui.Enabled = bool
	end
end

function Icon.modifyBaseTheme(modifications)
	modifications = Themes.getModifications(modifications)
	for _, modification in pairs(modifications) do
		for _, detail in pairs(Icon.baseTheme) do
			Themes.merge(detail, modification)
		end
	end
	for _, icon in pairs(iconsDict) do
		icon:setTheme(Icon.baseTheme)
	end
end

function Icon.setDisplayOrder(int)
	Icon.baseDisplayOrder = int
	Icon.baseDisplayOrderChanged:Fire(int)
end



-- SETUP
task.defer(Gamepad.start, Icon)
task.defer(Overflow.start, Icon)
task.defer(function()
	local playerGui = localPlayer:WaitForChild("PlayerGui")
	for _, screenGui in pairs(Icon.container) do
		screenGui.Parent = playerGui
	end
	require(iconModule.Attribute)
end)



-- CONSTRUCTOR
function Icon.new()
	local self = {}
	setmetatable(self, Icon)

	--- Janitors (for cleanup)
	local janitor = Janitor.new()
	self.janitor = janitor
	self.themesJanitor = janitor:add(Janitor.new())
	self.singleClickJanitor = janitor:add(Janitor.new())
	self.captionJanitor = janitor:add(Janitor.new())
	self.joinJanitor = janitor:add(Janitor.new())
	self.menuJanitor = janitor:add(Janitor.new())
	self.dropdownJanitor = janitor:add(Janitor.new())

	-- Register
	local iconUID = Utility.generateUID()
	iconsDict[iconUID] = self
	janitor:add(function()
		iconsDict[iconUID] = nil
	end)

	-- Signals (events)
	self.selected = janitor:add(Signal.new())
	self.deselected = janitor:add(Signal.new())
	self.toggled = janitor:add(Signal.new())
	self.viewingStarted = janitor:add(Signal.new())
	self.viewingEnded = janitor:add(Signal.new())
	self.stateChanged = janitor:add(Signal.new())
	self.notified = janitor:add(Signal.new())
	self.noticeStarted = janitor:add(Signal.new())
	self.noticeChanged = janitor:add(Signal.new())
	self.endNotices = janitor:add(Signal.new())
	self.toggleKeyAdded = janitor:add(Signal.new())
	self.fakeToggleKeyChanged = janitor:add(Signal.new())
	self.alignmentChanged = janitor:add(Signal.new())
	self.updateSize = janitor:add(Signal.new())
	self.resizingComplete = janitor:add(Signal.new())
	self.joinedParent = janitor:add(Signal.new())
	self.menuSet = janitor:add(Signal.new())
	self.dropdownSet = janitor:add(Signal.new())
	self.updateMenu = janitor:add(Signal.new())
	self.startMenuUpdate = janitor:add(Signal.new())
	self.childThemeModified = janitor:add(Signal.new())
	self.indicatorSet = janitor:add(Signal.new())
	self.dropdownChildAdded = janitor:add(Signal.new())
	self.menuChildAdded = janitor:add(Signal.new())

	-- Properties
	self.iconModule = iconModule
	self.UID = iconUID
	self.isEnabled = true
	self.enabled = self.isEnabled -- Backwards compatability
	self.isSelected = false
	self.isViewing = false
	self.joinedFrame = false
	self.parentIconUID = false
	self.deselectWhenOtherIconSelected = true
	self.totalNotices = 0
	self.activeState = "Deselected"
	self.alignment = ""
	self.originalAlignment = ""
	self.appliedTheme = {}
	self.appearance = {}
	self.cachedInstances = {}
	self.cachedNamesToInstances = {}
	self.cachedCollectives = {}
	self.bindedToggleKeys = {}
	self.customBehaviours = {}
	self.toggleItems = {}
	self.bindedEvents = {}
	self.notices = {}
	self.menuIcons = {}
	self.dropdownIcons = {}
	self.childIconsDict = {}
	self.creationTime = os.clock()

	-- Widget is the new name for an icon
	local widget = janitor:add(require(elements.Widget)(self, Icon))
	self.widget = widget
	self:setAlignment()
	
	-- It's important we set an order otherwise icons will not align
	-- correctly within menus
	totalCreatedIcons += 1
	local ourOrder = 1+(totalCreatedIcons*0.01)
	self:setOrder(ourOrder, "deselected")
	self:setOrder(ourOrder, "selected")

	-- This applies the default them
	self:setTheme(Icon.baseTheme)

	-- Button Clicked (for states "Selected" and "Deselected")
	local clickRegion = self:getInstance("ClickRegion")
	local hasUsedMouseButton1Click = false
	local lastToggleTime = 0
	local DEBOUNCE_TIME = 0.1 -- 100ms debounce to prevent rapid toggles

	local function handleToggle()
		if self.locked then
			return
		end

		-- Debounce logic to prevent rapid toggling
		local currentTime = tick()
		if currentTime - lastToggleTime < DEBOUNCE_TIME then
			return
		end
		lastToggleTime = currentTime

		if self.isSelected then
			self:deselect("User", self)
		else
			self:select("User", self)
		end
	end

	clickRegion.MouseButton1Click:Connect(function()
		hasUsedMouseButton1Click = true
		handleToggle()
	end)

	clickRegion.TouchTap:Connect(function()
		-- This resolves the bug report by @28Pixels:
		-- https://devforum.roblox.com/t/topbarplus/1017485/1104
		-- Only use TouchTap if MouseButton1Click has never fired
		-- This handles edge cases where ONLY TouchTap works
		-- Also prevents double-toggle bug with multi-touch on mobile
		-- Credit to @sayer80 for this fix
		if not hasUsedMouseButton1Click then
			handleToggle()
		end
	end)

	-- Keys can be bound to toggle between Selected and Deselected
	janitor:add(UserInputService.InputBegan:Connect(function(input, touchingAnObject)
		if self.locked then
			return
		end
		if self.bindedToggleKeys[input.KeyCode] and not touchingAnObject then
			handleToggle()
		end
	end))

	-- Button Hovering (for state "Viewing")
	-- Hovering is a state only for devices with keyboards
	-- and controllers (not touchpads)
	local function viewingStarted(dontSetState)
		if self.locked then
			return
		end
		self.isViewing = true
		self.viewingStarted:Fire(true)
		if not dontSetState then
			self:setState("Viewing", "User", self)
		end
	end
	local function viewingEnded()
		if self.locked then
			return
		end
		self.isViewing = false
		self.viewingEnded:Fire(true)
		self:setState(nil, "User", self)
	end
	self.joinedParent:Connect(function()
		if self.isViewing then
			viewingEnded()
		end
	end)
	clickRegion.MouseEnter:Connect(function()
		local dontSetState = UserInputService.PreferredInput ~= preferredInput.desktop
		viewingStarted(dontSetState)
	end)
	local touchCount = 0
	janitor:add(UserInputService.TouchEnded:Connect(viewingEnded))
	clickRegion.MouseLeave:Connect(viewingEnded)
	clickRegion.SelectionGained:Connect(viewingStarted)
	clickRegion.SelectionLost:Connect(viewingEnded)
	clickRegion.MouseButton1Down:Connect(function()
		if not self.locked and UserInputService.PreferredInput == preferredInput.mobile then
			touchCount += 1
			local myTouchCount = touchCount
			task.delay(0.2, function()
				if myTouchCount == touchCount then
					viewingStarted()
				end
			end)
		end
	end)
	clickRegion.MouseButton1Up:Connect(function()
		touchCount += 1
	end)

	-- Handle overlay on viewing
	local iconOverlay = self:getInstance("IconOverlay")
	self.viewingStarted:Connect(function()
		iconOverlay.Visible = not self.overlayDisabled
	end)
	self.viewingEnded:Connect(function()
		iconOverlay.Visible = false
	end)

	-- Deselect when another icon is selected
	janitor:add(anyIconSelected:Connect(function(incomingIcon)
		if incomingIcon ~= self and self.deselectWhenOtherIconSelected and incomingIcon.deselectWhenOtherIconSelected then
			self:deselect("AutoDeselect", incomingIcon)
		end
	end))

	-- This checks if the script calling this module is a descendant of a ScreenGui
	-- with 'ResetOnSpawn' set to true. If it is, then we destroy the icon the
	-- client respawns. This solves one of the most asked about questions on the post
	-- The only caveat this may not work if the player doesn't uniquely name their ScreenGui and the frames
	-- the LocalScript rests within
	local source =  debug.info(2, "s")
	local sourcePath = string.split(source, ".")
	local origin = game
	local originsScreenGui
	for i, sourceName in pairs(sourcePath) do
		origin = origin:FindFirstChild(sourceName)
		if not origin then
			break
		end
		if origin:IsA("ScreenGui") then
			originsScreenGui = origin
		end
	end
	if origin and originsScreenGui and originsScreenGui.ResetOnSpawn == true then
		self.originsScreenGui = originsScreenGui
		Utility.localPlayerRespawned(function()
			self:destroy()
		end)
	end

	-- Additional children behaviour when toggled (mostly notices)
	self.toggled:Connect(function(isSelected)
		self.noticeChanged:Fire(self.totalNotices)
		for childIconUID, _ in pairs(self.childIconsDict) do
			local childIcon = Icon.getIconByUID(childIconUID)
			childIcon.noticeChanged:Fire(childIcon.totalNotices)
			if not isSelected and childIcon.isSelected then
				-- If an icon within a menu or dropdown is also
				-- a dropdown or menu, then close it
				for _, _ in pairs(childIcon.childIconsDict) do
					childIcon:deselect("HideParentFeature", self)
				end
			end
		end
	end)
	
	-- This closes/reopens the chat or playerlist if the icon is a dropdown
	-- In the future I'd prefer to use the position+size of the chat
	-- to determine whether to close dropdown (instead of non-right-set)
	-- but for reasons mentioned here it's unreliable at the time of
	-- writing this: https://devforum.roblox.com/t/here/2794915
	-- I could also make this better by accounting for multiple
	-- dropdowns being open (not just this one) but this will work
	-- fine for almost every use case for now.
	self.selected:Connect(function()
		local isDropdown = #self.dropdownIcons > 0
		if isDropdown then
			if StarterGui:GetCore("ChatActive") and self.alignment ~= "Right" then
				self.chatWasPreviouslyActive = true
				StarterGui:SetCore("ChatActive", false)
			end
			if StarterGui:GetCoreGuiEnabled("PlayerList") and self.alignment ~= "Left" then
				self.playerlistWasPreviouslyActive = true
				StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
			end
		end
	end)
	self.deselected:Connect(function()
		if self.chatWasPreviouslyActive then
			self.chatWasPreviouslyActive = nil
			StarterGui:SetCore("ChatActive", true)
		end
		if self.playerlistWasPreviouslyActive then
			self.playerlistWasPreviouslyActive = nil
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
		end
	end)
	
	-- There's a rare occassion where the appearance is not
	-- fully set to deselected so this ensures the icons
	-- appearance is fully as it should be
	task.delay(0.1, function()
		if self.activeState == "Deselected" then
			self.stateChanged:Fire("Deselected")
			self:refresh()
		end
	end)
	
	-- Call icon added
	Icon.iconAdded:Fire(self)

	return self
end



-- METHODS
function Icon:setName(name)
	self.widget.Name = name
	self.name = name
	return self
end

function Icon:setState(incomingStateName, fromSource, sourceIcon)
	-- This is responsible for acknowleding a change in stage (such as from "Deselected" to "Viewing" when
	-- a users mouse enters the widget), then informing other systems of this state change to then act upon
	-- (such as the theme handler applying the theme which corresponds to that state).
	if not incomingStateName then
		incomingStateName = (self.isSelected and "Selected") or "Deselected"
	end
	local stateName = Utility.formatStateName(incomingStateName)
	local previousStateName = self.activeState
	if previousStateName == stateName then
		return
	end
	local currentIsSelected = self.isSelected
	self.activeState = stateName
	if stateName == "Deselected" then
		self.isSelected = false
		if currentIsSelected then
			self.toggled:Fire(false, fromSource, sourceIcon)
			self.deselected:Fire(fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(false, fromSource, sourceIcon)
	elseif stateName == "Selected" then
		self.isSelected = true
		if not currentIsSelected then
			self.toggled:Fire(true, fromSource, sourceIcon)
			self.selected:Fire(fromSource, sourceIcon)
			anyIconSelected:Fire(self, fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(true, fromSource, sourceIcon)
	end
	self.stateChanged:Fire(stateName, fromSource, sourceIcon)
end

function Icon:getInstance(name)
	-- This enables us to easily retrieve instances located within the icon simply by passing its name.
	-- Every important/significant instance is named uniquely therefore this is no worry of overlap.
	-- We cache the result for more performant retrieval in the future.
	local instance = self.cachedNamesToInstances[name]
	if instance then
		return instance
	end
	local function cacheInstance(childName, child)
		local currentCache = self.cachedInstances[child]
		if not currentCache then
			local collectiveName = child:GetAttribute("Collective")
			local cachedCollective = collectiveName and self.cachedCollectives[collectiveName]
			if cachedCollective then
				table.insert(cachedCollective, child)
			end
			self.cachedNamesToInstances[childName] = child
			self.cachedInstances[child] = true
			child.Destroying:Once(function()
				self.cachedNamesToInstances[childName] = nil
				self.cachedInstances[child] = nil
			end)
		end
	end
	local widget = self.widget
	cacheInstance("Widget", widget)
	if name == "Widget" then
		return widget
	end

	local returnChild
	local function scanChildren(parentInstance)
		for _, child in pairs(parentInstance:GetChildren()) do
			local widgetUID = child:GetAttribute("WidgetUID")
			if widgetUID and widgetUID ~= self.UID then
				-- This prevents instances within other icons from being recorded
				-- (for instance when other icons are added to this icons menu)
				continue
			end
			-- If the child is a fake placeholder instance (such as dropdowns, notices, etc)
			-- then its important we scan the real original instance instead of this clone
			local realChild = Themes.getRealInstance(child)
			if realChild then
				child = realChild
			end
			-- Finally scan its children
			scanChildren(child)
			if child:IsA("GuiBase") or child:IsA("UIBase") or child:IsA("ValueBase") then
				local childName = child.Name
				cacheInstance(childName, child)
				if childName == name then
					returnChild = child
				end
			end
		end
	end
	scanChildren(widget)
	return returnChild
end

function Icon:getCollective(name)
	-- A collective is an array of instances within the Widget that have been
	-- grouped together based on a given name. This just makes it easy
	-- to act on multiple instances at once which share similar behaviours.
	-- For instance, if we want to change the icons corner size, all corner instances
	-- with the attribute "Collective" and value "WidgetCorner" could be updated
	-- instantly by doing Themes.apply(icon, "WidgetCorner", newSize)
	local collective = self.cachedCollectives[name]
	if collective then
		return collective
	end
	collective = {}
	for instance, _ in pairs(self.cachedInstances) do
		if instance:GetAttribute("Collective") == name then
			table.insert(collective, instance)
		end
	end
	self.cachedCollectives[name] = collective
	return collective
end

function Icon:getInstanceOrCollective(collectiveOrInstanceName)
	-- Similar to :getInstance but also accounts for 'Collectives', such as UICorners and returns
	-- an array of instances instead of a single instance
	local instances = {}
	local instance = self:getInstance(collectiveOrInstanceName)
	if instance then
		table.insert(instances, instance)
	end
	if #instances == 0 then
		instances = self:getCollective(collectiveOrInstanceName)
	end
	return instances
end

function Icon:getStateGroup(iconState)
	local chosenState = iconState or self.activeState
	local stateGroup = self.appearance[chosenState]
	if not stateGroup then
		stateGroup = {}
		self.appearance[chosenState] = stateGroup
	end
	return stateGroup
end

function Icon:refreshAppearance(instance, specificProperty)
	Themes.refresh(self, instance, specificProperty)
	return self
end

function Icon:refresh()
	self:refreshAppearance(self.widget)
	self.updateSize:Fire()
	return self
end

function Icon:updateParent()
	local parentIcon = Icon.getIconByUID(self.parentIconUID)
	if parentIcon then
		parentIcon.updateSize:Fire()
	end
end

function Icon:setBehaviour(collectiveOrInstanceName, property, callback, refreshAppearance)
	-- You can specify your own custom callback to handle custom logic just before
	-- an instances property is changed by using :setBehaviour()
	local key = collectiveOrInstanceName.."-"..property
	self.customBehaviours[key] = callback
	if refreshAppearance then
		local instances = self:getInstanceOrCollective(collectiveOrInstanceName)
		for _, instance in pairs(instances) do
			self:refreshAppearance(instance, property)
		end
	end
end

function Icon:modifyTheme(modifications, customModificationUID)
	local modificationUID = Themes.modify(self, modifications, customModificationUID)
	return self, modificationUID
end

function Icon:modifyChildTheme(modifications, modificationUID)
	-- Same as modifyTheme except for its children (i.e. icons
	-- within its dropdown or menu)
	self.childModifications = modifications
	self.childModificationsUID = modificationUID
	for childIconUID, _ in pairs(self.childIconsDict) do
		local childIcon = Icon.getIconByUID(childIconUID)
		childIcon:modifyTheme(modifications, modificationUID)
	end
	self.childThemeModified:Fire()
	return self
end

function Icon:removeModification(modificationUID)
	Themes.remove(self, modificationUID)
	return self
end

function Icon:removeModificationWith(instanceName, property, state)
	Themes.removeWith(self, instanceName, property, state)
	return self
end

function Icon:setTheme(theme)
	Themes.set(self, theme)
	return self
end

function Icon:setEnabled(bool)
	self.isEnabled = bool
	self.enabled = self.isEnabled
	self.widget.Visible = bool
	self:updateParent()
	return self
end

function Icon:select(fromSource, sourceIcon)
	self:setState("Selected", fromSource, sourceIcon)
	return self
end

function Icon:deselect(fromSource, sourceIcon)
	self:setState("Deselected", fromSource, sourceIcon)
	return self
end

function Icon:notify(customClearSignal, noticeId)
	-- Generates a notification which appears in the top right of the icon. Useful for example for prompting
	-- users of changes/updates within your UI such as a Catalog
	-- 'customClearSignal' is a signal object (e.g. icon.deselected) or
	-- Roblox event (e.g. Instance.new("BindableEvent").Event)
	local notice = self.notice
	if not notice then
		notice = require(elements.Notice)(self, Icon)
		self.notice = notice
	end
	self.noticeStarted:Fire(customClearSignal, noticeId)
	return self
end

function Icon:clearNotices()
	self.endNotices:Fire()
	return self
end

function Icon:disableOverlay(bool)
	self.overlayDisabled = bool
	return self
end
Icon.disableStateOverlay = Icon.disableOverlay

function Icon:setImage(imageId, iconState)
	self:modifyTheme({"IconImage", "Image", imageId, iconState})
	
	-- This code ensures icon images are preloaded if they haven't been fetched yet
	task.spawn(function()
		local newIdContent = if tonumber(imageId) then `rbxassetid://{imageId}` else imageId
		local initialAssetFetchStatus = ContentProvider:GetAssetFetchStatus(newIdContent)
	
		if initialAssetFetchStatus ~= Enum.AssetFetchStatus.Success then
			pcall(ContentProvider.PreloadAsync, ContentProvider, { newIdContent })
		end
	end)
		
	return self
end

function Icon:setLabel(text, iconState)
	self:modifyTheme({"IconLabel", "Text", text, iconState})
	return self
end

function Icon:setOrder(int, iconState)
	-- We multiply by 100 to allow for custom increments inbetween
	-- (.01, .02, etc) as LayoutOrders only support integers
	local newInt = int*100
	self:modifyTheme({"IconSpot", "LayoutOrder", newInt, iconState})
	self:modifyTheme({"Widget", "LayoutOrder", newInt, iconState})
	return self
end

function Icon:setCornerRadius(udim, iconState)
	self:modifyTheme({"IconCorners", "CornerRadius", udim, iconState})
	return self
end

function Icon:align(leftCenterOrRight, isFromParentIcon)
	-- Determines the side of the screen the icon will be ordered
	local direction = tostring(leftCenterOrRight):lower()
	if direction == "mid" or direction == "centre" then
		direction = "center"
	end
	if direction ~= "left" and direction ~= "center" and direction ~= "right" then
		direction = "left"
	end
	local screenGui = (direction == "center" and Icon.container.TopbarCentered) or Icon.container.TopbarStandard
	local holders = screenGui.Holders
	local finalDirection = string.upper(string.sub(direction, 1, 1))..string.sub(direction, 2)
	if not isFromParentIcon then
		self.originalAlignment = finalDirection
	end
	local joinedFrame = self.joinedFrame
	local alignmentHolder = holders[finalDirection]
	self.screenGui = screenGui
	self.alignmentHolder = alignmentHolder
	if not self.isDestroyed then
		self.widget.Parent = joinedFrame or alignmentHolder
	end
	self.alignment = finalDirection
	self.alignmentChanged:Fire(finalDirection)
	Icon.iconChanged:Fire(self)
	return self
end
Icon.setAlignment = Icon.align

function Icon:setLeft()
	self:setAlignment("Left")
	return self
end

function Icon:setMid()
	self:setAlignment("Center")
	return self
end

function Icon:setRight()
	self:setAlignment("Right")
	return self
end

function Icon:setWidth(offsetMinimum, iconState)
	-- This sets a minimum X offset size for the widget, useful
	-- for example if you're constantly changing the label
	-- but don't want the icon to resize every time
	self:modifyTheme({"Widget", "DesiredWidth", offsetMinimum, iconState})
	return self
end

function Icon:setImageScale(number, iconState)
	self:modifyTheme({"IconImageScale", "Value", number, iconState})
	return self
end

function Icon:setImageRatio(number, iconState)
	self:modifyTheme({"IconImageRatio", "AspectRatio", number, iconState})
	return self
end

function Icon:setTextSize(number, iconState)
	self:modifyTheme({"IconLabel", "TextSize", number, iconState})
	return self
end

function Icon:setTextFont(font, fontWeight, fontStyle, iconState)
	fontWeight = fontWeight or Enum.FontWeight.Regular
	fontStyle = fontStyle or Enum.FontStyle.Normal
	local fontFace
	local fontType = typeof(font)
	if fontType == "number" then
		fontFace = Font.fromId(font, fontWeight, fontStyle)
	elseif fontType == "EnumItem" then
		fontFace = Font.fromEnum(font)
	elseif fontType == "string" then
		if not font:match("rbxasset") then
			fontFace = Font.fromName(font, fontWeight, fontStyle)
		end
	end
	if not fontFace then
		fontFace = Font.new(font, fontWeight, fontStyle)
	end
	self:modifyTheme({"IconLabel", "FontFace", fontFace, iconState})
	return self
end

function Icon:setTextColor(Color, iconState)
	if Color == nil or Color == "" or (type(Color) ~= "userdata" or typeof(Color) ~= "Color3") then
		if Color ~= nil and Color ~= "" then
			warn("setTextColor item must be a Color3 value! Changed the color to white.")
		end
		Color = Color3.fromRGB(255, 255, 255)
	end

	self:modifyTheme({"IconLabel", "TextColor3", Color, iconState})
	return self
end

function Icon:bindToggleItem(guiObjectOrLayerCollector)
	if not guiObjectOrLayerCollector:IsA("GuiObject") and not guiObjectOrLayerCollector:IsA("LayerCollector") then
		error("Toggle item must be a GuiObject or LayerCollector!")
	end
	self.toggleItems[guiObjectOrLayerCollector] = true
	self:_updateSelectionInstances()
	return self
end

function Icon:unbindToggleItem(guiObjectOrLayerCollector)
	self.toggleItems[guiObjectOrLayerCollector] = nil
	self:_updateSelectionInstances()
	return self
end

function Icon:_updateSelectionInstances()
	-- This is to assist with controller navigation and selection
	-- It converts the value true to an array
	for guiObjectOrLayerCollector, _ in pairs(self.toggleItems) do
		local buttonInstancesArray = {}
		for _, instance in pairs(guiObjectOrLayerCollector:GetDescendants()) do
			if (instance:IsA("TextButton") or instance:IsA("ImageButton")) and instance.Active then
				table.insert(buttonInstancesArray, instance)
			end
		end
		self.toggleItems[guiObjectOrLayerCollector] = buttonInstancesArray
	end
end

function Icon:_setToggleItemsVisible(bool, fromSource, sourceIcon)
	for toggleItem, _ in pairs(self.toggleItems) do
		if not sourceIcon or sourceIcon == self or sourceIcon.toggleItems[toggleItem] == nil then
			local property = "Visible"
			if toggleItem:IsA("LayerCollector") then
				property = "Enabled"
			end
			toggleItem[property] = bool
		end
	end
end

function Icon:bindEvent(iconEventName, eventFunction)
	local event = self[iconEventName]
	assert(event and typeof(event) == "table" and event.Connect, "argument[1] must be a valid topbarplus icon event name!")
	assert(typeof(eventFunction) == "function", "argument[2] must be a function!")
	self.bindedEvents[iconEventName] = event:Connect(function(...)
		eventFunction(self, ...)
	end)
	return self
end

function Icon:unbindEvent(iconEventName)
	local eventConnection = self.bindedEvents[iconEventName]
	if eventConnection then
		eventConnection:Disconnect()
		self.bindedEvents[iconEventName] = nil
	end
	return self
end

function Icon:bindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = true
	self.toggleKeyAdded:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:unbindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = nil
	return self
end

function Icon:call(callback, ...)
	local packedArgs = table.pack(...)
	task.spawn(function()
		callback(self, table.unpack(packedArgs))
	end)
	return self
end

function Icon:addToJanitor(callback, methodName, index)
	self.janitor:add(callback, methodName, index)
	return self
end

function Icon:lock()
	-- This disables all user inputs related to the icon (such as clicking buttons, pressing keys, etc)
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = false
	self.locked = true
	return self
end

function Icon:unlock()
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = true
	self.locked = false
	return self
end

function Icon:debounce(seconds)
	self:lock()
	task.wait(seconds)
	self:unlock()
	return self
end

function Icon:autoDeselect(bool)
	-- When set to true the icon will deselect itself automatically whenever
	-- another icon is selected
	if bool == nil then
		bool = true
	end
	self.deselectWhenOtherIconSelected = bool
	return self
end

function Icon:oneClick(bool)
	-- When set to true the icon will automatically deselect when selected, this creates
	-- the effect of a single click button
	local singleClickJanitor = self.singleClickJanitor
	singleClickJanitor:clean()
	if bool or bool == nil then
		singleClickJanitor:add(self.selected:Connect(function()
			self:deselect("OneClick", self)
		end))
	end
	self.oneClickEnabled = true
	return self
end

function Icon:setCaption(text)
	if text == "_hotkey_" and (self.captionText) then
		return self
	end
	local captionJanitor = self.captionJanitor
	self.captionJanitor:clean()
	if not text or text == "" then
		self.caption = nil
		self.captionText = nil
		return self
	end
	local caption = captionJanitor:add(require(elements.Caption)(self))
	caption:SetAttribute("CaptionText", text)
	self.caption = caption
	self.captionText = text
	return self
end

function Icon:setCaptionHint(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.fakeToggleKey = keyCodeEnum
	self.fakeToggleKeyChanged:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:leave()
	local joinJanitor = self.joinJanitor
	joinJanitor:clean()
	return self
end

function Icon:joinMenu(parentIcon)
	Utility.joinFeature(self, parentIcon, parentIcon.menuIcons, parentIcon:getInstance("Menu"))
	parentIcon.menuChildAdded:Fire(self)
	return self
end

function Icon:setMenu(arrayOfIcons)
	self.menuSet:Fire(arrayOfIcons)
	return self
end

function Icon:setFixedMenu(arrayOfIcons)
	self:freezeMenu(arrayOfIcons)
	self:setMenu(arrayOfIcons)
end
Icon.setFrozenMenu = Icon.setFixedMenu

function Icon:freezeMenu()
	-- A frozen menu is a menu which is permanently locked in the
	-- the selected state (with its toggle hidden)
	self:select("FrozenMenu", self)
	self:bindEvent("deselected", function(icon)
		icon:select("FrozenMenu", self)
	end)
	self:modifyTheme({"IconSpot", "Visible", false})
end

function Icon:joinDropdown(parentIcon)
	parentIcon:getDropdown()
	Utility.joinFeature(self, parentIcon, parentIcon.dropdownIcons, parentIcon:getInstance("DropdownScroller"))
	parentIcon.dropdownChildAdded:Fire(self)
	return self
end

function Icon:getDropdown()
	local dropdown = self.dropdown
	if not dropdown then
		dropdown = require(elements.Dropdown)(self)
		self.dropdown = dropdown
		self:clipOutside(dropdown)
	end
	return dropdown
end

function Icon:setDropdown(arrayOfIcons)
	self:getDropdown()
	self.dropdownSet:Fire(arrayOfIcons)
	return self
end

function Icon:clipOutside(instance)
	-- This is essential for items such as notices and dropdowns which will exceed the bounds of the widget. This is an issue
	-- because the widget must have ClipsDescendents enabled to hide items for instance when the menu is closing or opening.
	-- This creates an invisible frame which matches the size and position of the instance, then the instance is parented outside of
	-- the widget and tracks the clone to match its size and position. In order for themes, etc to work the applying system checks
	-- to see if an instance is a clone, then if it is, it applies it to the original instance instead of the clone.
	local instanceClone = Utility.clipOutside(self, instance)
	self:refreshAppearance(instance)
	return self, instanceClone
end

function Icon:setIndicator(keyCode)
	-- An indicator is a direction button prompt with an image of the given keycode. This is useful for instance
	-- with controllers to show the user what button to press to highlight the topbar. You don't need
	-- to set an indicator for controllers as this is handled internally within the Gamepad module
	local indicator = self.indicator
	if not indicator then
		indicator = self.janitor:add(require(elements.Indicator)(self, Icon))
		self.indicator = indicator
	end
	self.indicatorSet:Fire(keyCode)
end

function Icon:convertLabelToNumberSpinner(numberSpinner, callback)
	task.defer(function()
		
		local label = self:getInstance("IconLabel")
		label.Transparency = 1
		numberSpinner.Parent = label.Parent
		numberSpinner.Size = UDim2.fromScale(1, 1)
		numberSpinner.AnchorPoint = Vector2.new(0.5, 0.5)
		numberSpinner.Position = UDim2.new(0.5, 0, 0.5, 0)
		numberSpinner.TextXAlignment = Enum.TextXAlignment.Center
		numberSpinner.ClipsDescendants = false

		local propertiesToChangeLabel = {
			"FontFace",
			"BorderSizePixel",
			"BorderColor3",
			"Rotation",
			"TextStrokeTransparency",
			"TextStrokeColor3",
			"TextStrokeTransparency",
			"TextColor3",
		}
		for _, property in ipairs(propertiesToChangeLabel) do
			numberSpinner[property] = label[property]
			self:addToJanitor(label:GetPropertyChangedSignal(property):Connect(function()
				numberSpinner[property] = label[property]
			end))
		end

		local minDigits = 0
		local maxDigits = 8
		local function getSpinnerSizeAndDigitCount()
			local TotalSize = 0
			local numOfDigits = 0
			for i, child in numberSpinner.Frame:GetChildren() do
				local name = string.lower(child.Name)
				if name == "digit" then
					TotalSize += child.AbsoluteSize.X
					numOfDigits += 1
				elseif name == "prefix" or name == "suffix" or name == "comma" then
					if child.Text ~= "" then
						TotalSize += child.AbsoluteSize.X
						numOfDigits += 1
					end
				end
			end
			return TotalSize, numOfDigits
		end
		
		local function getLabelParentContainerXSize()
			local firstParent = label.Parent
			local nextParent = firstParent and firstParent.Parent
			if nextParent == nil then
				return 0
			end
			if nextParent.IconImage.Visible == true then
				return numberSpinner.Frame.AbsoluteSize.X + label.Parent.Parent.IconImage.AbsoluteSize.X
			else
				return nextParent.AbsoluteSize.X
			end
		end
		local function getNumberSpinnerXSize()
			return numberSpinner.Frame.AbsoluteSize.X
		end

		local function adjustSize()
			local totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			if numOfDigits < 18 then
				self:setLabel(numberSpinner.Value)
			end

			local NumberSpinnerXSize = getNumberSpinnerXSize()

			while totalDigitXSize < NumberSpinnerXSize and self.isDestroyed ~= true do
				task.wait(0.05)
				if numOfDigits > minDigits and numOfDigits < maxDigits then
					numberSpinner.TextSize = label.TextSize
					break
				else
					numberSpinner.TextSize += 1
				end

				NumberSpinnerXSize = getNumberSpinnerXSize()
				totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			end

			local labelParentContainerXSize = getLabelParentContainerXSize()
			while totalDigitXSize > labelParentContainerXSize and self.isDestroyed ~= true do
				task.wait(0.05)
				if numOfDigits < maxDigits and numOfDigits > minDigits then
					numberSpinner.TextSize = label.TextSize
					break
				else
					numberSpinner.TextSize -= 1
				end

				labelParentContainerXSize = getLabelParentContainerXSize()
				totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			end
		end

		self:addToJanitor(numberSpinner.Frame.ChildAdded:Connect(adjustSize))
		self:addToJanitor(numberSpinner.Frame.ChildRemoved:Connect(adjustSize))
		self:addToJanitor(self.iconAdded:Connect(function()
			task.wait(1)
			adjustSize()
		end))

		self:updateParent()

		-- This corrects text to the size of a normal label
		numberSpinner.Name = "LabelSpinner"
		numberSpinner.Prefix = "$"
		numberSpinner.Commas = true
		numberSpinner.Decimals = 0
		numberSpinner.Duration = 0.25
		numberSpinner.Value = 10
		task.wait(0.2)
		
		if typeof(callback) == "function" then
			callback()
		end
		
	end)
	return self
end



-- DESTROY/CLEANUP
function Icon:destroy()
	if self.isDestroyed then
		return
	end
	self:clearNotices()
	if self.parentIconUID then
		self:leave()
	end
	self.isDestroyed = true
	self.janitor:clean()
	Icon.iconRemoved:Fire(self)
end
Icon.Destroy = Icon.destroy

return Icon :: Types.StaticIcon]]></ProtectedString>
						<string name="ScriptGuid">{15B0DD47-F91D-49F7-99FF-8BC8BA2E7822}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TopbarPlus.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXDF11AE9C438647D2A6A1AB6E424143CB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TopbarPlus</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX41C194219B2C488A97DC057AA5F3400D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict

-- GoodSignal Types (...but simpler!)

--- Connection

type Connection<Variant... = ...any> = {
	Disconnect: (self: Connection<Variant...>) -> (),
}

--- Signal

type Signal<Variant... = ...any> = {
	Connect: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
    Once: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
	Wait: (self: Signal<Variant...>) -> Variant...,
}

----------------------

export type IconState = "Deselected" | "Selected" | "Viewing"
export type Events = "selected" | "deselected" | "toggled" | "viewingStarted" | "viewingEnded" | "notified"
export type Alignment = "Left" | "Center" | "Right"
export type EventSource = "User" | "OneClick" | "AutoDeselect" | "HideParentFeature" | "Overflow"
export type Modification = { any }


type StaticFunctions = {
	getIcons: typeof(
		--[[
			Returns a dictionary of icons where the key is the icon's UID and value the icon.
		]]
		function(): { Icon }
			return (nil :: any) :: { Icon }
		end
	),
	getIcon: typeof(
		--[[
			Returns an icon of the given name or UID.
		]]
		function(nameOrUID: string): Icon?
			return nil :: any
		end
	),
	setTopbarEnabled: typeof(
		--[[
			When set to <code>false</code> all TopbarPlus ScreenGuis are hidden.
			This does not impact Roblox's Topbar.
		]]
		function(enabled: boolean)

		end
	),
	modifyBaseTheme: typeof(
		--[[
			Updates the appearance of all icons.
		]]
		function(modifications: { Modification })

		end
	),
	setDisplayOrder: typeof(
		--[[
			Sets the base DisplayOrder of all TopbarPlus ScreenGuis.
		]]
		function(order: number)

		end
	),
}

type Methods = {
	
	-- CLASS FUNCTIONS
	setName: typeof(
		--[[
			Sets the name of the Widget instance. This can be used in conjunction with <code>Icon.getIcon(name)</code>
		]]
		function(self: Icon, name: string): Icon
			return nil :: any
		end
	),
	getInstance: typeof(
		--[[
			Returns the first descendant found within the widget of name <code>instanceName</code>.
		]]
		function(self: Icon, instanceName: string): Instance?
			return (nil :: any) :: Instance?
		end
	),
	modifyTheme: typeof(
		--[[
			Updates the appearance of the icon.
		]]
		function(self: Icon, modifications: {Modification} | Modification): Icon
			return nil :: any
		end
	),
	modifyChildTheme: typeof(
		--[[
			Updates the appearance of all icons that are parented to this icon (for example when a menu or dropdown).
		]]
		function(self: Icon, modifications: { Modification }): Icon
			return nil :: any
		end
	),
	setEnabled: typeof(
		--[[
			When set to <code>false</code> the icon will be disabled and hidden.
		]]
		function(self: Icon, enabled: boolean): Icon
			return nil :: any
		end
	),
	select: typeof(
		--[[
			Selects the icon (as if it were clicked once).
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	deselect: typeof(
		--[[
			Deselects the icon (as if it were clicked, then clicked again).
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	notify: typeof(
		--[[
			Prompts a notice bubble which accumulates the further it is prompted.
			If the icon belongs to a dropdown or menu, then the notice will appear on the parent icon when the parent icon is deselected.
		]]
		function(self: Icon, clearNoticeEvent: Signal?): Icon
			return nil :: any
		end
	),
	clearNotices: typeof(
		--[[
			
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	disableOverlay: typeof(
		--[[
			When set to <code>true</code>, disables the shade effect which appears when the icon is pressed and released.
		]]
		function(self: Icon, disabled: boolean): Icon
			return nil :: any
		end
	),
	setImage: typeof(
		--[[
			Applies an image to the icon based on the given <code>imageId</code>. <code>imageId</code> can be an assetId or a complete asset string.
		]]
		function(self: Icon, imageId: string | number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setLabel: typeof(
		--[[
			
		]]
		function(self: Icon, text: string, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setOrder: typeof(
		--[[
			
		]]
		function(self: Icon, order: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setCornerRadius: typeof(
		--[[
			
		]]
		function(self: Icon, udim: UDim2, iconState: IconState?): Icon
			return nil :: any
		end
	),
	align: typeof(
		--[[
			This enables you to set the icon to the <code>"Left"</code> (default), <code>"Center"</code> or <code>"Right"</code> side of the screen.
		]]
		function(self: Icon, alignment: Alignment?): Icon
			return nil :: any
		end
	),
	setWidth: typeof(
		--[[
			This sets the minimum width the icon can be (it can be larger for instance when setting a long label). The default width is <code>44</code>.
		]]
		function(self: Icon, minimumSize: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setImageScale: typeof(
		--[[
			How large the image is relative to the icon. The default value is <code>0.5</code>.
		]]
		function(self: Icon, scale: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setImageRatio: typeof(
		--[[
			How stretched the image will appear. The default value is <code>1</code> (a perfect square).
		]]
		function(self: Icon, ratio: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextSize: typeof(
		--[[
			The size of the icon labels' text. The default value is <code>16</code>.
		]]
		function(self: Icon, textSize: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextColor: typeof(
		--[[
			The color of the icon labels' text
		]]
		function(self: Icon, color: Color3, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextFont: typeof(
		--[[
			Sets the labels FontFace.
			<code>font</code> can be a font family name (such as <code>"Creepster"</code>),
			a font enum (such as <code>Enum.Font.Bangers</code>),
			a font ID (such as <code>12187370928</code>),
			or font family link (such as <code>"rbxasset://fonts/families/Sarpanch.json"</code>).
		]]
		function(self: Icon, font: string | Enum.Font, fontWeight: Enum.FontWeight?, fontStyle: Enum.FontSize?, iconState: IconState?): Icon
			return nil :: any
		end
	),
	bindToggleItem: typeof(
		--[[
			Binds a GuiObject or LayerCollector to appear and disappeared when the icon is toggled.
		]]
		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
			return nil :: any
		end
	),
	unbindToggleItem: typeof(
		--[[
			Unbinds the given GuiObject or LayerCollector from the toggle.
		]]
		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
			return nil :: any
		end
	),
	bindEvent: typeof(
		--[[
			Connects to an icon event with <code>iconEventName</code>.
			It's important to remember all event names are in <code>camelCase</code>.
			<code>callback</code> is called with arguments <code>(self, ...)</code> when the event is triggered.
		]]
		function(self: Icon, event: Events, callback: (...any) -> ()): Icon
			return nil :: any
		end
	),
	unbindEvent: typeof(
		--[[
			Unbinds the connection of the associated <code>iconEventName</code>.
		]]
		function(self: Icon, event: Events): Icon
			return nil :: any
		end
	),
	bindToggleKey: typeof(
		--[[
			Binds a keycode which toggles the icon when pressed.
		]]
		function(self: Icon, keycode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	unbindToggleKey: typeof(
		--[[
			Unbinds the given keycode.
		]]
		function(self: Icon, keycode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	call: typeof(
		--[[
			Calls the function immediately via <code>task.spawn</code>.
			The first argument passed is the icon itself.
			This is useful when needing to extend the behaviour of an icon while remaining in the chain.
		]]
		function(self: Icon, func: (self: Icon) -> (...any), ...: any): Icon
			return nil :: any
		end
	),
	addToJanitor: typeof(
		--[[
			Passes the given userdata to the icons janitor to be destroyed/disconnected on the icons destruction.
			If a function is passed, it will be called when the icon is destroyed.
		]]
		function(self: Icon, userdata: unknown): Icon
			return nil :: any
		end
	),
	lock: typeof(
		--[[
			Prevents the icon being toggled by user-input (such as clicking), however, the icon can still be toggled via localscript using methods such as <code>icon:select()</code>.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	unlock: typeof(
		--[[
			Re-enables user-input to toggle the icon again.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	debounce: typeof(
		--[[
			Locks the icon, yields for the given time, then unlocks the icon, effectively shorthand for <code>icon:lock() task.wait(seconds) icon:unlock()</code>.
			This is useful for applying cooldowns (to prevent an icon from being pressed again) after an icon has been selected or deselected.
		]]
		function(self: Icon, seconds: number): Icon
			return nil :: any
		end
	),
	autoDeselect: typeof(
		--[[
			When set to <code>true</code> (the default) the icon is deselected when another icon (with autoDeselect enabled) is pressed.
			Set to <code>false</code> to prevent the icon being deselected when another icon is selected (a useful behaviour in dropdowns).
		]]
		function(self: Icon, enabled: boolean?): Icon
			return nil :: any
		end
	),
	oneClick: typeof(
		--[[
			When set to true the icon will automatically deselect when selected.
			This creates the effect of a single click button.
		]]
		function(self: Icon, enabled: boolean?): Icon
			return nil :: any
		end
	),
	setCaption: typeof(
		--[[
			Sets a caption. To remove, pass <code>nil</code> as <code>text</code>.
		]]
		function(self: Icon, text: string?): Icon
			return nil :: any
		end
	),
	setCaptionHint: typeof(
		--[[
			This customizes the appearance of the caption's hint without having to use <code>icon:bindToggleKey</code>.
		]]
		function(self: Icon, keyCode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	setDropdown: typeof(
		--[[
			Creates a vertical dropdown based upon the given table array of icons.
			Pass an empty table <code>{}</code> to remove the dropdown.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	joinDropdown: typeof(
		--[[
			Joins the dropdown of <code>parentIcon</code>.
			This is what <code>icon:setDropdown</code> calls internally on the icons within its array.
		]]
		function(self: Icon, parent: Icon): Icon
			return nil :: any
		end
	),
	setMenu: typeof(
		--[[
			Creates a horizontal menu based upon the given array of icons.
			Pass an empty table <code>{}</code> to remove the menu.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	setFixedMenu: typeof(
		--[[
			Creates a menu that is always selected and has it's close button hidden.
			Pass an empty table <code>{}</code> to remove the menu.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	joinMenu: typeof(
		--[[
			Joins the menu of <code>parentIcon</code>.
			This is what <code>icon:setMenu</code> calls internally on the icons within its array.
		]]
		function(self: Icon, parentIcon: Icon): Icon
			return nil :: any
		end
	),
	leave: typeof(
		--[[
			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	convertLabelToNumberSpinner: typeof(
		--[[
			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
		]]
		function(self: Icon, numberSpinner: any, func: (...any) -> (...any), ...: any): Icon
			return nil :: any
		end
	),
	destroy: typeof(
		--[[
			Clears all connections and destroys all instances associated with the icon.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
} & StaticFunctions

type Fields = {
	-- CLASS PROPERTIES
	name: string,
	isSelected: boolean,
	isEnabled: boolean,
	totalNotices: number,
	locked: boolean,

	-- CLASS EVENTS
	selected: Signal<EventSource>,
	deselected: Signal<EventSource>,
	toggled: Signal<boolean, EventSource>,
	viewingStarted: Signal,
	viewingEnded: Signal,
	notified: Signal,
}

export type Icon = Methods & StaticFunctions --typeof(setmetatable({} :: Fields, MT))

export type StaticIcon = {
	new: typeof(
		--[[
			Constructs an empty <code>32x32</code> icon on the topbar.
		]]
		function(): Icon
			return (nil :: any) :: Icon
		end
	),
} & StaticFunctions

return {}]]></ProtectedString>
							<string name="ScriptGuid">{5741A538-9856-49A3-8987-9B47AD558CD0}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Types.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5DB80DDD75E546FC995B1B613984875A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
-- LOCAL
local VERSION = {}



-- SHARED
VERSION.appVersion = "v3.4.0"
VERSION.latestVersion = nil :: string?



-- FUNCTIONS
function VERSION.getLatestVersion(): string?
	local DEVELOPMENT_PLACE_ID = 117501901079852
	local latestVersion = VERSION.latestVersion
	if latestVersion then
		return latestVersion
	end
	local placeName = ""
	while true do
		local success, hdDevelopmentDetails = pcall(function()
			return game:GetService("MarketplaceService"):GetProductInfo(DEVELOPMENT_PLACE_ID)
		end)
		if success and hdDevelopmentDetails then
			placeName = hdDevelopmentDetails.Name
			break
		end
		task.wait(1)
	end
	latestVersion = string.match(placeName, "^TopbarPlus (.*)$")
	if latestVersion then
		latestVersion = latestVersion:gsub("%s+", "") -- Remove all whitespace (spaces, tabs, newlines)
	end
	VERSION.latestVersion = latestVersion
	return latestVersion
end

function VERSION.getAppVersion()
	return VERSION.appVersion
end

function VERSION.isUpToDate()
	local latestVersion = VERSION.getLatestVersion()
	local appVersion = VERSION.getAppVersion()
	return latestVersion ~= nil and latestVersion == appVersion
end



return VERSION]]></ProtectedString>
							<string name="ScriptGuid">{B7899FD8-922C-4D43-B3CC-8C21FC65C1F7}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">VERSION.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE883F64DBB754C00BE25E45AF3AADAFD">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- This module enables you to place Icon wherever you like within the data model while
-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
-- This is necessary to prevent two TopbarPlus applications initiating at runtime which would
-- cause icons to overlap with each other

local replicatedStorage = game:GetService("ReplicatedStorage")
local Reference = {}
Reference.objectName = "TopbarPlusReference"

function Reference.addToReplicatedStorage()
	local existingItem = replicatedStorage:FindFirstChild(Reference.objectName)
    if existingItem then
        return false
    end
    local objectValue = Instance.new("ObjectValue")
	objectValue.Name = Reference.objectName
    objectValue.Value = script.Parent
    objectValue.Parent = replicatedStorage
    return objectValue
end

function Reference.getObject()
	local objectValue = replicatedStorage:FindFirstChild(Reference.objectName)
    if objectValue then
        return objectValue
    end
    return false
end

return Reference]]></ProtectedString>
							<string name="ScriptGuid">{0885A554-A758-4954-852F-18B30ABD2529}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Reference.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4889CA571A434D3485B2736033C89519">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[[

	TopbarPlus was developed by ForeverHD and is possible thanks to HD Admin.

	By using TopbarPlus in your experience or application, you agree to either:
		1. Keep Attribute unchanged, or
		2. If an experience, to credit TopbarPlus in your description, or in a
		   devforum post linked from your experience's description.

	v3 has involved over 350 hours of work to develop, so please consider supporting
	its development by reporting any issues or feedback you have at its repository:
	https://github.com/1ForeverHD/TopbarPlus

	You can get in touch with me on Discord via the social link here:
	https://create.roblox.com/store/asset/92368439343389/TopbarPlus

	Many thanks! ~Ben, June 10th 2025
	
]]

task.defer(function()
	local RunService = game:GetService("RunService")
	local VERSION = require(script.Parent.VERSION)
	local appVersion = VERSION.getAppVersion()
	local latestVersion = VERSION.getLatestVersion()
	local isOutdated = not VERSION.isUpToDate()
	if not RunService:IsStudio() then
		print(`🍍 Running TopbarPlus {appVersion} by @ForeverHD & HD Admin`)
	end
	if isOutdated then
		warn(`A new version of TopbarPlus ({latestVersion}) is available: https://devforum.roblox.com/t/topbarplus/1017485`)
	end
end)

return {}]]></ProtectedString>
							<string name="ScriptGuid">{1E9A1358-4189-44E1-83CF-808A3263B69A}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Attribute.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXDD4EE03DEB8549A2BDF29E0DFD38BCBD">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Just generic utility functions which I use and repeat across all my projects



-- LOCAL
local Utility = {}
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer



-- FUNCTIONS
function Utility.createStagger(delayTime, callback, delayInitially)
	-- This creates and returns a function which when called
	-- acts identically to callback, however will only be called
	-- for a maximum of once per delayTime. If the returned function
	-- is called more than once during the delayTime, then it will
	-- wait until the expiryTime then perform another recall.
	-- This is useful for visual interfaces and effects which may be
	-- triggered multiple times within a frame or short period, but which
	-- we don't necessary need to (for performance reasons).
	local staggerActive = false
	local multipleCalls = false
	if not delayTime or delayTime == 0 then
		-- We make 0.01 instead of 0 because devices can now run at
		-- different frame rates
		delayTime = 0.01
	end
	local function staggeredCallback(...)
		if staggerActive then
			multipleCalls = true
			return
		end
		local packedArgs = table.pack(...)
		staggerActive = true
		multipleCalls = false
		task.spawn(function()
			if delayInitially then
				task.wait(delayTime)
			end
			callback(table.unpack(packedArgs))
		end)
		task.delay(delayTime, function()
			staggerActive = false
			if multipleCalls then
				-- This means it has been called at least once during
				-- the stagger period, so call again
				staggeredCallback(table.unpack(packedArgs))
			end
		end)
	end
	return staggeredCallback
end

function Utility.round(n)
	-- Credit to Darkmist101 for this
	return math.floor(n + 0.5)
end

function Utility.reverseTable(t)
	for i = 1, math.floor(#t/2) do
		local j = #t - i + 1
		t[i], t[j] = t[j], t[i]
	end
end

function Utility.copyTable(t)
	-- Credit to Stephen Leitnick (September 13, 2017) for this function from TableUtil
	assert(type(t) == "table", "First argument must be a table")
	local tCopy = table.create(#t)
	for k,v in pairs(t) do
		if (type(v) == "table") then
			tCopy[k] = Utility.copyTable(v)
		else
			tCopy[k] = v
		end
	end
	return tCopy
end

local validCharacters = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9","0","<",">","?","@","{","}","[","]","!","(",")","=","+","~","#"}
function Utility.generateUID(length)
	length = length or 8
	local UID = ""
	local list = validCharacters
	local total = #list
	for i = 1, length do
		local randomCharacter = list[math.random(1, total)]
		UID = UID..randomCharacter
	end
	return UID
end

local instanceTrackers = {}
function Utility.setVisible(instance, bool, sourceUID)
	-- This effectively works like a buff object but
	-- incredibly simplified. It stacks false values
	-- so that if there is more than more than, the 
	-- instance remains hidden even if set visible true
	local tracker = instanceTrackers[instance]
	if not tracker then
		tracker = {}
		instanceTrackers[instance] = tracker
		instance.Destroying:Once(function()
			instanceTrackers[instance] = nil
		end)
	end
	if not bool then
		tracker[sourceUID] = true
	else
		tracker[sourceUID] = nil
	end
	local isVisible = bool
	if bool then
		for sourceUID, _ in pairs(tracker) do
			isVisible = false
			break
		end
	end
	instance.Visible = isVisible
end

function Utility.formatStateName(incomingStateName)
	return string.upper(string.sub(incomingStateName, 1, 1))..string.lower(string.sub(incomingStateName, 2))
end

function Utility.localPlayerRespawned(callback)
	-- The client localscript may be located under a ScreenGui with ResetOnSpawn set to true
	-- In these scenarios, traditional methods like CharacterAdded won't be called by the
	-- time the localscript has been destroyed, therefore we listen for removing instead
	-- If humanoid and health == 0, then reset/died normally, else was
	-- forcefully reset via a method such as LoadCharacter
	-- We wrap this behaviour in case any additional quirks need to be accounted for
	localPlayer.CharacterRemoving:Connect(callback)
end

function Utility.getClippedContainer(screenGui)
	-- We always want clipped items to display in front hence
	-- why we have this
	local clippedContainer = screenGui:FindFirstChild("ClippedContainer")
	if not clippedContainer then
		clippedContainer = Instance.new("Folder")
		clippedContainer.Name = "ClippedContainer"
		clippedContainer.Parent = screenGui
	end
	return clippedContainer
end

local Janitor = require(script.Parent.Packages.Janitor)
local GuiService = game:GetService("GuiService")
function Utility.clipOutside(icon, instance)
	local cloneJanitor = icon.janitor:add(Janitor.new())
	instance.Destroying:Once(function()
		cloneJanitor:Destroy()
	end)
	icon.janitor:add(instance)

	local originalParent = instance.Parent
	local clone = cloneJanitor:add(Instance.new("Frame"))
	clone:SetAttribute("IsAClippedClone", true)
	clone.Name = instance.Name
	clone.AnchorPoint = instance.AnchorPoint
	clone.Size = instance.Size
	clone.Position = instance.Position
	clone.BackgroundTransparency = 1
	clone.LayoutOrder = instance.LayoutOrder
	clone.Parent = originalParent

	local valueInstance = Instance.new("ObjectValue")
	valueInstance.Name = "OriginalInstance"
	valueInstance.Value = instance
	valueInstance.Parent = clone

	local valueInstanceCopy = valueInstance:Clone()
	instance:SetAttribute("HasAClippedClone", true)
	valueInstanceCopy.Name = "ClippedClone"
	valueInstanceCopy.Value = clone
	valueInstanceCopy.Parent = instance

	local screenGui
	local Icon = require(icon.iconModule)
	local container = Icon.container
	local function updateScreenGui()
		local originalScreenGui = originalParent:FindFirstAncestorWhichIsA("ScreenGui")
		screenGui = if string.match(originalScreenGui.Name, "Clipped") then originalScreenGui else container[originalScreenGui.Name.."Clipped"]
		instance.AnchorPoint = Vector2.new(0, 0)
		instance.Parent = Utility.getClippedContainer(screenGui)
	end
	cloneJanitor:add(icon.alignmentChanged:Connect(updateScreenGui))
	updateScreenGui()

	-- Lets copy over children that modify size
	for _, child in pairs(instance:GetChildren()) do
		if child:IsA("UIAspectRatioConstraint") then
			child:Clone().Parent = clone
		end
	end

	-- If the icon is hidden, its important we are too (as
	-- setting a parent to visible = false no longer makes
	-- this hidden)
	local widget = icon.widget
	local isOutsideParent = false
	local ignoreVisibilityUpdater = instance:GetAttribute("IgnoreVisibilityUpdater")
	local function updateVisibility()
		if ignoreVisibilityUpdater then
			return
		end
		local isVisible = widget.Visible
		if isOutsideParent then
			isVisible = false
		end
		Utility.setVisible(instance, isVisible, "ClipHandler")
	end
	cloneJanitor:add(widget:GetPropertyChangedSignal("Visible"):Connect(updateVisibility))

	local previousScroller
	local function checkIfOutsideParentXBounds()
		-- Defer so that roblox's properties reflect their true values
		task.defer(function()
			-- If the instance is within a parent item (such as a dropdown or menu)
			-- then we hide it if it exceeds the bounds of that parent
			local parentInstance
			local ourUID = icon.UID
			local nextIconUID = ourUID
			local shouldClipToParent = instance:GetAttribute("ClipToJoinedParent")
			if shouldClipToParent then
				for i = 1, 10 do -- This is safer than while true do and should never be > 4 parents
					local nextIcon = Icon.getIconByUID(nextIconUID)
					if not nextIcon then
						break
					end
					local nextParentInstance = nextIcon.joinedFrame
					nextIconUID = nextIcon.parentIconUID
					if not nextParentInstance then
						break
					end
					parentInstance = nextParentInstance
					if parentInstance and parentInstance.Name == "DropdownScroller" then
						break
					end
				end
			end
			if not parentInstance then
				isOutsideParent = false
				updateVisibility()
				return
			end
			local pos = instance.AbsolutePosition
			local halfSize = instance.AbsoluteSize/2
			local parentPos = parentInstance.AbsolutePosition
			local parentSize = parentInstance.AbsoluteSize
			local posHalf = (pos + halfSize)
			local exceededLeft = posHalf.X < parentPos.X
			local exceededRight = posHalf.X > (parentPos.X + parentSize.X)
			local exceededTop = posHalf.Y < parentPos.Y
			local exceededBottom = posHalf.Y > (parentPos.Y + parentSize.Y)
			local hasExceeded = exceededLeft or exceededRight or exceededTop or exceededBottom
			if hasExceeded ~= isOutsideParent then
				isOutsideParent = hasExceeded
				updateVisibility()
			end
			if parentInstance:IsA("ScrollingFrame") and previousScroller ~= parentInstance then
				previousScroller = parentInstance
				local connection = parentInstance:GetPropertyChangedSignal("AbsoluteWindowSize"):Connect(function()
					checkIfOutsideParentXBounds()
				end)
				cloneJanitor:add(connection, "Disconnect", "TrackUtilityScroller-"..ourUID)
			end
		end)
	end

	local camera = workspace.CurrentCamera
	local additionalOffsetX = instance:GetAttribute("AdditionalOffsetX") or 0
	local function trackProperty(property)
		local absoluteProperty = "Absolute"..property
		local function updateProperty()
			local cloneValue = clone[absoluteProperty]
			local absoluteValue = UDim2.fromOffset(cloneValue.X, cloneValue.Y)
			if property == "Position" then

				-- This binds the instances within the bounds of the screen
				local SIDE_PADDING = 4
				local limitX = camera.ViewportSize.X - instance.AbsoluteSize.X - SIDE_PADDING
				local inputX = absoluteValue.X.Offset
				if inputX < SIDE_PADDING then
					inputX = SIDE_PADDING
				elseif inputX > limitX then
					inputX = limitX
				end
				absoluteValue = UDim2.fromOffset(inputX, absoluteValue.Y.Offset)

				-- AbsolutePosition does not perfectly match with TopbarInsets enabled
				-- This corrects this
				local topbarInset = GuiService.TopbarInset
				local viewportWidth = workspace.CurrentCamera.ViewportSize.X
				local guiWidth = screenGui.AbsoluteSize.X
				local guiOffset = screenGui.AbsolutePosition.X
				--local widthDifference = guiOffset - topbarInset.Min.X
				local oldTopbarCenterOffset = 0--widthDifference/30
				local offsetX = if Icon.isOldTopbar then guiOffset else viewportWidth - guiWidth - oldTopbarCenterOffset
				
				-- Also add additionalOffset
				offsetX -= additionalOffsetX
				absoluteValue += UDim2.fromOffset(-offsetX, topbarInset.Height)

				-- Finally check if within its direct parents bounds
				checkIfOutsideParentXBounds()

			end
			instance[property] = absoluteValue
		end
		
		-- This defer is essential as the listener may be in a different screenGui to the actor
		local updatePropertyStaggered = Utility.createStagger(0.01, updateProperty)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyStaggered))
		cloneJanitor:add(clone:GetAttributeChangedSignal("ForceUpdate"):Connect(function()
			updatePropertyStaggered()
		end))

		-- This is to patch a weirddddd bug with ScreenGuis with SreenInsets set to
		-- 'TopbarSafeInsets'. For some reason the absolute position of gui instances
		-- within this type of screenGui DO NOT accurately update to match their new
		-- real world position; instead they jump around almost randomly for a few frames.
		-- I have spent way too many hours trying to solve this bug, I think the only way
		-- for the time being is to not use ScreenGuis with TopbarSafeInsets, but I don't
		-- have time to redesign the entire system around that at the moment.
		-- Here's a GIF of this bug: https://i.imgur.com/VitHdC1.gif
		local updatePropertyPatch = Utility.createStagger(0.5, updateProperty, true)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyPatch))
		
		-- When the screenGui is resized (such as when chat is hidden/shown), we need
		-- to update the position of the clone. Ths especially fixes the following:
		-- https://devforum.roblox.com/t/bug/1017485/1732
		if property == "Position" then
			cloneJanitor:add(screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				updatePropertyStaggered()
			end))
		end

	end
	task.delay(0.1, checkIfOutsideParentXBounds)
	checkIfOutsideParentXBounds()
	updateVisibility()
	trackProperty("Position")
	
	-- Track visiblity changes
	cloneJanitor:add(instance:GetPropertyChangedSignal("Visible"):Connect(function()
		--print("Visiblity changed:", instance, clone, instance.Visible)
		--clone.Visible = instance.Visible
	end))

	-- To ensure accurate positioning, it's important the clone also remains the same size as the instance
	local shouldTrackCloneSize = instance:GetAttribute("TrackCloneSize")
	if shouldTrackCloneSize then
		trackProperty("Size")
	else
		cloneJanitor:add(instance:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			local absolute = instance.AbsoluteSize
			clone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end))
	end

	return clone
end

function Utility.joinFeature(originalIcon, parentIcon, iconsArray, scrollingFrameOrFrame)

	-- This is resonsible for moving the icon under a feature like a dropdown
	local joinJanitor = originalIcon.joinJanitor
	joinJanitor:clean()
	if not scrollingFrameOrFrame then
		originalIcon:leave()
		return
	end
	originalIcon.parentIconUID = parentIcon.UID
	originalIcon.joinedFrame = scrollingFrameOrFrame
	local function updateAlignent()
		local parentAlignment = parentIcon.alignment
		if parentAlignment == "Center" then
			parentAlignment = "Left"
		end
		originalIcon:setAlignment(parentAlignment, true)
	end
	joinJanitor:add(parentIcon.alignmentChanged:Connect(updateAlignent))
	updateAlignent()
	originalIcon:modifyTheme({"IconButton", "BackgroundTransparency", 1}, "JoinModification")
	originalIcon:modifyTheme({"ClickRegion", "Active", false}, "JoinModification")
	if parentIcon.childModifications then
		-- We defer so that the default values (such as dropdown
		-- minimum width can be applied before any custom
		-- child modifications from the user)
		task.defer(function()
			originalIcon:modifyTheme(parentIcon.childModifications, parentIcon.childModificationsUID)
		end)
	end
	--
	local clickRegion = originalIcon:getInstance("ClickRegion")
	local function makeSelectable()
		clickRegion.Selectable = parentIcon.isSelected
	end
	joinJanitor:add(parentIcon.toggled:Connect(makeSelectable))
	task.defer(makeSelectable)
	joinJanitor:add(function()
		clickRegion.Selectable = true
	end)
	--

	-- We track icons in arrays and dictionaries using their UID instead of the icon
	-- itself to prevent heavy cyclical tables when printing the icons
	local originalIconUID = originalIcon.UID
	table.insert(iconsArray, originalIconUID)
	parentIcon:autoDeselect(false)
	parentIcon.childIconsDict[originalIconUID] = true
	if not parentIcon.isEnabled then
		parentIcon:setEnabled(true)
	end
	originalIcon.joinedParent:Fire(parentIcon)

	-- This is responsible for removing it from that feature and updating
	-- their parent icon so its informed of the icon leaving it
	joinJanitor:add(function()
		local joinedFrame = originalIcon.joinedFrame
		if not joinedFrame then
			return
		end
		for i, iconUID in pairs(iconsArray) do
			if iconUID == originalIconUID then
				table.remove(iconsArray, i)
				break
			end
		end
		local Icon = require(originalIcon.iconModule)
		local parentIcon = Icon.getIconByUID(originalIcon.parentIconUID)
		if not parentIcon then
			return
		end
		originalIcon:setAlignment(originalIcon.originalAlignment)
		originalIcon.parentIconUID = false
		originalIcon.joinedFrame = false
		--originalIcon:setBehaviour("IconButton", "BackgroundTransparency", nil, true)
		originalIcon:removeModification("JoinModification")
		
		local parentHasNoChildren = true
		local parentChildIcons = parentIcon.childIconsDict
		parentChildIcons[originalIconUID] = nil
		for childIconUID, _ in pairs(parentChildIcons) do
			parentHasNoChildren = false
			break
		end
		if parentHasNoChildren and not parentIcon.isAnOverflow then
			parentIcon:setEnabled(false)
		end
		updateAlignent()

	end)

end



return Utility]]></ProtectedString>
							<string name="ScriptGuid">{867B0683-FF67-4FF6-80BA-8FB7F80D4602}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Utility.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX805FA1AAF6CB42CFB5778419AD9194D7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Elements</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX8BB9C89C61684C8F97F1AF9A0E3E49CB">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local CAPTION_COLOR = Color3.fromRGB(39, 41, 48)
local TEXT_SIZE = 15
return function(icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local clickRegion = icon:getInstance("ClickRegion")
	local caption = Instance.new("CanvasGroup")
	caption.Name = "Caption"
	caption.AnchorPoint = Vector2.new(0.5, 0)
	caption.BackgroundTransparency = 1
	caption.BorderSizePixel = 0
	caption.GroupTransparency = 1
	caption.Position = UDim2.fromOffset(0, 0)
	caption.Visible = true
	caption.ZIndex = 30
	caption.Parent = clickRegion

	local box = Instance.new("Frame")
	box.Name = "Box"
	box.AutomaticSize = Enum.AutomaticSize.XY
	box.BackgroundColor3 = CAPTION_COLOR
	box.Position = UDim2.fromOffset(4, 7)
	box.ZIndex = 12
	box.Parent = caption

	local header = Instance.new("TextLabel")
	header.Name = "Header"
	header.FontFace = Font.new(
		"rbxasset://fonts/families/BuilderSans.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	header.Text = "Caption"
	header.TextColor3 = Color3.fromRGB(255, 255, 255)
	header.TextSize = TEXT_SIZE
	header.TextTruncate = Enum.TextTruncate.None
	header.TextWrapped = false
	header.TextXAlignment = Enum.TextXAlignment.Left
	header.AutomaticSize = Enum.AutomaticSize.X
	header.BackgroundTransparency = 1
	header.LayoutOrder = 1
	header.Size = UDim2.fromOffset(0, 16)
	header.ZIndex = 18
	header.Parent = box

	local layout = Instance.new("UIListLayout")
	layout.Name = "Layout"
	layout.Padding = UDim.new(0, 8)
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Parent = box

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "CaptionCorner"
	UICorner.Parent = box

	local padding = Instance.new("UIPadding")
	padding.Name = "Padding"
	padding.PaddingBottom = UDim.new(0, 12)
	padding.PaddingLeft = UDim.new(0, 12)
	padding.PaddingRight = UDim.new(0, 12)
	padding.PaddingTop = UDim.new(0, 12)
	padding.Parent = box

	local hotkeys = Instance.new("Frame")
	hotkeys.Name = "Hotkeys"
	hotkeys.AutomaticSize = Enum.AutomaticSize.Y
	hotkeys.BackgroundTransparency = 1
	hotkeys.LayoutOrder = 3
	hotkeys.Size = UDim2.fromScale(1, 0)
	hotkeys.Visible = false
	hotkeys.Parent = box

	local layout1 = Instance.new("UIListLayout")
	layout1.Name = "Layout1"
	layout1.Padding = UDim.new(0, 6)
	layout1.FillDirection = Enum.FillDirection.Vertical
	layout1.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout1.HorizontalFlex = Enum.UIFlexAlignment.None
	layout1.ItemLineAlignment = Enum.ItemLineAlignment.Automatic
	layout1.VerticalFlex = Enum.UIFlexAlignment.None
	layout1.SortOrder = Enum.SortOrder.LayoutOrder
	layout1.Parent = hotkeys

	local keyTag1 = Instance.new("ImageLabel")
	keyTag1.Name = "Key1"
	keyTag1.Image = "rbxasset://textures/ui/Controls/key_single.png"
	keyTag1.ImageTransparency = 0.7
	keyTag1.ScaleType = Enum.ScaleType.Slice
	keyTag1.SliceCenter = Rect.new(5, 5, 23, 24)
	keyTag1.AutomaticSize = Enum.AutomaticSize.X
	keyTag1.BackgroundTransparency = 1
	keyTag1.LayoutOrder = 1
	keyTag1.Size = UDim2.fromOffset(0, 30)
	keyTag1.ZIndex = 15
	keyTag1.Parent = hotkeys

	local inset = Instance.new("UIPadding")
	inset.Name = "Inset"
	inset.PaddingLeft = UDim.new(0, 8)
	inset.PaddingRight = UDim.new(0, 8)
	inset.Parent = keyTag1

	local labelContent = Instance.new("TextLabel")
	labelContent.AutoLocalize = false
	labelContent.Name = "LabelContent"
	labelContent.FontFace = Font.new(
		"rbxasset://fonts/families/GothamSSm.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	labelContent.Text = ""
	labelContent.TextColor3 = Color3.fromRGB(189, 190, 190)
	labelContent.TextSize = TEXT_SIZE
	labelContent.AutomaticSize = Enum.AutomaticSize.X
	labelContent.BackgroundTransparency = 1
	labelContent.Position = UDim2.fromOffset(0, -1)
	labelContent.Size = UDim2.fromScale(1, 1)
	labelContent.ZIndex = 16
	labelContent.Parent = keyTag1
	
	local caret = Instance.new("ImageLabel")
	caret.Name = "Caret"
	caret.Image = "rbxassetid://101906294438076"
	caret.ImageColor3 = CAPTION_COLOR
	caret.AnchorPoint = Vector2.new(0, 0.5)
	caret.BackgroundTransparency = 1
	caret.Position = UDim2.new(0, 0, 0, 4)
	caret.Size = UDim2.fromOffset(16, 8)
	caret.ZIndex = 12
	caret.Parent = caption

	local dropShadow = Instance.new("ImageLabel")
	dropShadow.Visible = true
	dropShadow.Name = "DropShadow"
	dropShadow.Image = "rbxassetid://124920646932671"
	dropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
	dropShadow.ImageTransparency = 0.45
	dropShadow.ScaleType = Enum.ScaleType.Slice
	dropShadow.SliceCenter = Rect.new(12, 12, 13, 13)
	dropShadow.BackgroundTransparency = 1
	dropShadow.Position = UDim2.fromOffset(0, 5)
	dropShadow.Size = UDim2.new(1, 0, 0, 48)
	dropShadow.Parent = caption
	box:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		dropShadow.Size = UDim2.new(1, 0, 0, box.AbsoluteSize.Y + 8)
	end)
	
	-- It's important we match the sizes as this is not
	-- handles within clipOutside (as it assumes the sizes
	-- are already the same)
	local captionJanitor = icon.captionJanitor
	local _, captionClone = icon:clipOutside(caption)
	captionClone.AutomaticSize = Enum.AutomaticSize.None
	local function matchSize()
		local absolute = caption.AbsoluteSize
		captionClone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
	end
	captionJanitor:add(caption:GetPropertyChangedSignal("AbsoluteSize"):Connect(matchSize))
	matchSize()
	
	
	
	-- This handles the appearing/disappearing/positioning of the caption
	local isCompletelyEnabled = false
	local captionHeader = caption.Box.Header
	local UserInputService = game:GetService("UserInputService")
	local function updateHotkey(keyCodeEnum)
		local hasKeyboard = UserInputService.KeyboardEnabled
		local text = caption:GetAttribute("CaptionText") or ""
		local hideHeader = text == "_hotkey_"
		if not hasKeyboard and hideHeader then
			icon:setCaption()
			return
		end
		captionHeader.Text = text
		captionHeader.Visible = not hideHeader
		if keyCodeEnum then
			labelContent.Text = keyCodeEnum.Name
			hotkeys.Visible = true
		end
		if not hasKeyboard then
			hotkeys.Visible = false
		end
	end
	caption:GetAttributeChangedSignal("CaptionText"):Connect(updateHotkey)

	local EASING_STYLE = Enum.EasingStyle.Quad
	local TWEEN_SPEED = 0.2
	local TWEEN_INFO_IN = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.In)
	local TWEEN_INFO_OUT = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.Out)
	local TweenService = game:GetService("TweenService")
	local RunService = game:GetService("RunService")
	local function getCaptionPosition(customEnabled)
		local enabled = if customEnabled ~= nil then customEnabled else isCompletelyEnabled
		local yOut = 2
		local yIn = yOut + 8
		local yOffset = if enabled then yIn else yOut
		return UDim2.new(0.5, 0, 1, yOffset)
	end
	local function updatePosition(forcedEnabled)
		
		-- Ignore changes if not enabled to reduce redundant calls
		if not isCompletelyEnabled then
			return
		end
		
		-- Currently the one thing which isn't accounted for are the bounds of the screen
		-- This would be an issue if someone sets a long caption text for the left or
		-- right most icon
		local enabled = if forcedEnabled ~= nil then forcedEnabled else isCompletelyEnabled
		local startPosition = getCaptionPosition(not enabled)
		local endPosition = getCaptionPosition(enabled)
		
		-- It's essential we reset the carets position to prevent the x sizing bounds
		-- of the caption from infinitely scaling up
		if enabled then
			local caretY = caret.Position.Y.Offset
			caret.Position = UDim2.fromOffset(0, caretY)
			caption.AutomaticSize = Enum.AutomaticSize.XY
			caption.Size = UDim2.fromOffset(32, 53)
		else
			local absolute = caption.AbsoluteSize
			caption.AutomaticSize = Enum.AutomaticSize.Y
			caption.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end
		
		-- We initially default to the opposite state
		local previousCaretX
		local function updateCaret()
			local caretX = clickRegion.AbsolutePosition.X - caption.AbsolutePosition.X + clickRegion.AbsoluteSize.X/2 - caret.AbsoluteSize.X/2
			local caretY = caret.Position.Y.Offset
			local newCaretPosition = UDim2.fromOffset(caretX, caretY)
			if previousCaretX ~= caretX then
				-- Again, it's essential we reset the caret if
				-- a difference in X position is detected otherwise
				-- a slight quirk with AutomaticCanvas can cause
				-- the caption to infinitely scale
				previousCaretX = caretX
				caret.Position = UDim2.fromOffset(0, caretY)
				task.wait()
			end
			caret.Position = newCaretPosition
		end
		captionClone.Position = startPosition
		updateCaret()
		
		-- Now we tween into the new state
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tween = TweenService:Create(captionClone, tweenInfo, {Position = endPosition})
		local updateCaretConnection = RunService.Heartbeat:Connect(updateCaret)
		tween:Play()
		tween.Completed:Once(function()
			updateCaretConnection:Disconnect()
		end)
		
	end
	captionJanitor:add(clickRegion:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updatePosition()
	end))
	updatePosition(false)
	
	captionJanitor:add(icon.toggleKeyAdded:Connect(updateHotkey))
	for keyCodeEnum, _ in pairs(icon.bindedToggleKeys) do
		updateHotkey(keyCodeEnum)
		break
	end
	captionJanitor:add(icon.fakeToggleKeyChanged:Connect(updateHotkey))
	local fakeToggleKey = icon.fakeToggleKey
	if fakeToggleKey then
		updateHotkey(fakeToggleKey)
	end

	local function setCaptionEnabled(enabled)
		if isCompletelyEnabled == enabled then
			return
		end
		local joinedFrame = icon.joinedFrame
		if joinedFrame and string.match(joinedFrame.Name, "Dropdown") then
			enabled = false
		end
		isCompletelyEnabled = enabled
		local newTransparency = (enabled and 0) or 1
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tweenTransparency = TweenService:Create(caption, tweenInfo, {
			GroupTransparency = newTransparency
		})
		tweenTransparency:Play()
		if enabled then
			captionClone:SetAttribute("ForceUpdate", true)
		end
		updatePosition()
		updateHotkey()
	end
	
	local WAIT_DURATION = 0.5
	local RECOVER_PERIOD = 0.3
	local Icon = require(icon.iconModule)
	captionJanitor:add(icon.stateChanged:Connect(function(stateName)
		if stateName == "Viewing" then
			local lastClock = Icon.captionLastClosedClock
			local clockDifference = (lastClock and os.clock() - lastClock) or 999
			local waitDuration = (clockDifference < RECOVER_PERIOD and 0) or WAIT_DURATION
			task.delay(waitDuration, function()
				if icon.activeState == "Viewing" then
					setCaptionEnabled(true)
				end
			end)
		else
			Icon.captionLastClosedClock = os.clock()
			setCaptionEnabled(false)
		end
	end))
	
	return caption
end]]></ProtectedString>
								<string name="ScriptGuid">{FD78753F-4ADF-4957-954C-40030E1DD5AC}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Caption.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC9F55D7E1AFF447F89936CC14AF94A2E">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local hasBecomeOldTheme = false
local previousInsetHeight = 0
return function(Icon)
	
	-- Has to be included for the time being due to this bug mentioned here:
	-- https://devforum.roblox.com/t/bug/2973508/7
	local GuiService = game:GetService("GuiService")
	local Players =  game:GetService("Players")
	local UserInputService = game:GetService("UserInputService")
	local container = {}
	local Signal = require(script.Parent.Parent.Packages.GoodSignal)
	local insetChanged = Signal.new()
	local guiInset = GuiService:GetGuiInset()
	local startInset = 0
	local yDownOffset = 0
	local ySizeOffset = 0
	local checkCount = 0
	local isConsoleScreen = false
	local isUsingVR = false
	local function checkInset(status)
		local currentHeight = GuiService.TopbarInset.Height
		local isOldTopbar = currentHeight <= 36
		

		-- These additional checks are needed to ensure *it is actually* the old topbar
		-- and not a client which takes a really long time to load
		-- There's unfortunately no APIs to do this a prettier way
		isConsoleScreen = GuiService:IsTenFootInterface()
		isUsingVR = UserInputService.VREnabled
		Icon.isOldTopbar = isOldTopbar
		checkCount += 1
		if currentHeight == 0 and status == nil then
			task.defer(function()
				task.wait(8)
				checkInset("ForceConvertToOld")
			end)
		elseif checkCount == 1 then
			task.delay(5, function()
				local localPlayer = Players.LocalPlayer
				localPlayer:WaitForChild("PlayerGui")
				if checkCount == 1 then
					checkInset()
				end
			end)
		end

		-- Conver to old theme if verified
		if Icon.isOldTopbar and not isConsoleScreen and not isUsingVR and hasBecomeOldTheme == false and (currentHeight ~= 0 or status == "ForceConvertToOld") then
			hasBecomeOldTheme = true
			task.defer(function()
				-- If oldtopbar, apply the Classic theme
				local themes = script.Parent.Parent.Features.Themes
				local Classic = require(themes.Classic)
				Icon.modifyBaseTheme(Classic)

				-- Also configure the oldtopbar correctly
				local function decideToHideTopbar()
					if GuiService.MenuIsOpen then
						Icon.setTopbarEnabled(false, true)
					else
						Icon.setTopbarEnabled()
					end
				end
				GuiService:GetPropertyChangedSignal("MenuIsOpen"):Connect(decideToHideTopbar)
				decideToHideTopbar()
			end)
		end

		-- Modify the offsets slightly depending on device type
		guiInset = GuiService:GetGuiInset()
		startInset = if isOldTopbar then 12 else guiInset.Y - 50
		yDownOffset = if isOldTopbar then 2 else 0 --if isOldTopbar then 2 else 0 
		ySizeOffset = -2
		if isConsoleScreen then
			startInset = 10
			yDownOffset = 0 ---9
		end
		if GuiService.TopbarInset.Height == 0 and not hasBecomeOldTheme then
			yDownOffset += 13
			ySizeOffset = 50
		end

		-- Now inform other areas of the change
		insetChanged:Fire(guiInset)
		local insetHeight = guiInset.Y
		if insetHeight ~= previousInsetHeight then
			previousInsetHeight = insetHeight
			task.defer(function()
				Icon.insetHeightChanged:Fire(insetHeight)
			end)
		end
		
	end
	GuiService:GetPropertyChangedSignal("TopbarInset"):Connect(checkInset)
	checkInset("FirstTime")

	local screenGui = Instance.new("ScreenGui")
	insetChanged:Connect(function()
		screenGui:SetAttribute("StartInset", startInset)
	end)
	screenGui.Name = "TopbarStandard"
	screenGui.Enabled = true
	screenGui.DisplayOrder = Icon.baseDisplayOrder
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.IgnoreGuiInset = true
	screenGui.ResetOnSpawn = false
	screenGui.ScreenInsets = Enum.ScreenInsets.TopbarSafeInsets
	container[screenGui.Name] = screenGui
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGui.DisplayOrder = Icon.baseDisplayOrder
	end)

	local holders = Instance.new("Frame")
	holders.Name = "Holders"
	holders.BackgroundTransparency = 1
	insetChanged:Connect(function()
		local holderY = if isUsingVR then 36 else 56
		local holderSize = if isConsoleScreen then UDim2.new(1, 0, 0, holderY) else UDim2.new(1, 0, 1, ySizeOffset)
		holders.Position = UDim2.new(0, 0, 0, yDownOffset)
		holders.Size = holderSize
	end)
	holders.Visible = true
	holders.ZIndex = 1
	holders.Parent = screenGui
	
	local screenGuiCenter = screenGui:Clone()
	local holdersCenter = screenGuiCenter.Holders
	local function updateCenteredHoldersHeight()
		holdersCenter.Size = UDim2.new(1, 0, 0, GuiService.TopbarInset.Height+ySizeOffset)
	end
	screenGuiCenter.Name = "TopbarCentered"
	screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
	screenGuiCenter.ScreenInsets = Enum.ScreenInsets.None
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
	end)
	container[screenGuiCenter.Name] = screenGuiCenter
	
	insetChanged:Connect(updateCenteredHoldersHeight)
	updateCenteredHoldersHeight()
	
	local screenGuiClipped = screenGui:Clone()
	screenGuiClipped.Name = screenGuiClipped.Name.."Clipped"
	screenGuiClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	end)
	container[screenGuiClipped.Name] = screenGuiClipped
	
	local screenGuiCenterClipped = screenGuiCenter:Clone()
	screenGuiCenterClipped.Name = screenGuiCenterClipped.Name.."Clipped"
	screenGuiCenterClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenterClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	end)
	container[screenGuiCenterClipped.Name] = screenGuiCenterClipped
	
	local holderReduction = -24
	local left = Instance.new("ScrollingFrame")
	left:SetAttribute("IsAHolder", true)
	left.Name = "Left"
	insetChanged:Connect(function()
		left.Position = UDim2.fromOffset(startInset, 0)
	end)
	left.Size = UDim2.new(1, holderReduction, 1, 0)
	left.BackgroundTransparency = 1
	left.Visible = true
	left.ZIndex = 1
	left.Active = false
	left.ClipsDescendants = true
	left.HorizontalScrollBarInset = Enum.ScrollBarInset.None
	left.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	left.AutomaticCanvasSize = Enum.AutomaticSize.X
	left.ScrollingDirection = Enum.ScrollingDirection.X
	left.ScrollBarThickness = 0
	left.BorderSizePixel = 0
	left.Selectable = false
	left.ScrollingEnabled = false--true
	left.ElasticBehavior = Enum.ElasticBehavior.Never
	left.Parent = holders
	
	local UIListLayout = Instance.new("UIListLayout")
	insetChanged:Connect(function()
		UIListLayout.Padding = UDim.new(0, startInset)
	end)
	UIListLayout.FillDirection = Enum.FillDirection.Horizontal
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
	UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	UIListLayout.Parent = left
	
	local center = left:Clone()
	insetChanged:Connect(function()
		center.UIListLayout.Padding = UDim.new(0, startInset)
	end)
	center.ScrollingEnabled = false
	center.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	center.Name = "Center"
	center.Parent = holdersCenter
	
	local right = left:Clone()
	insetChanged:Connect(function()
		right.UIListLayout.Padding = UDim.new(0, startInset)
	end)
	right.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
	right.Name = "Right"
	right.AnchorPoint = Vector2.new(1, 0)
	right.Position = UDim2.new(1, -12, 0, 0)
	right.Parent = holders

	-- This is important so that all elements update instantly
	insetChanged:Fire(guiInset)

	return container
end]]></ProtectedString>
								<string name="ScriptGuid">{17CB52EF-7E68-42F8-A317-7D119E9DC214}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Container.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0199F1AFD6B846DB90C863C81F444F2A">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local widget = icon.widget
	local contents = icon:getInstance("Contents")
	local indicator = Instance.new("Frame")
	indicator.Name = "Indicator"
	indicator.LayoutOrder = 9999999
	indicator.ZIndex = 6
	indicator.Size = UDim2.new(0, 42, 0, 42)
	indicator.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicator.BackgroundTransparency = 1
	indicator.Position = UDim2.new(1, 0, 0.5, 0)
	indicator.BorderSizePixel = 0
	indicator.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicator.Parent = contents

	local indicatorButton = Instance.new("Frame")
	indicatorButton.Name = "IndicatorButton"
	indicatorButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.AnchorPoint = Vector2.new(0.5, 0.5)
	indicatorButton.BorderSizePixel = 0
	indicatorButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.Parent = indicator
	
	local GuiService = game:GetService("GuiService")
	local GamepadService = game:GetService("GamepadService")
	local ourClickRegion = icon:getInstance("ClickRegion")
	local function selectionChanged()
		local selectedClickRegion = GuiService.SelectedObject
		if selectedClickRegion == ourClickRegion then
			indicatorButton.BackgroundTransparency = 1
			indicatorButton.Position = UDim2.new(0.5, -2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1.2, 1.2)
		else
			indicatorButton.BackgroundTransparency = 0.75
			indicatorButton.Position = UDim2.new(0.5, 2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1, 1)
		end
	end
	icon.janitor:add(GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(selectionChanged))
	selectionChanged()

	local imageLabel = Instance.new("ImageLabel")
	imageLabel.LayoutOrder = 2
	imageLabel.ZIndex = 15
	imageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	imageLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.BackgroundTransparency = 1
	imageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.Image = "rbxasset://textures/ui/Controls/XboxController/DPadUp@2x.png"
	imageLabel.Parent = indicatorButton

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = indicatorButton

	local UserInputService = game:GetService("UserInputService")
	local function setIndicatorVisible(visibility)
		if visibility == nil then
			visibility = indicator.Visible
		end
		if GamepadService.GamepadCursorEnabled then
			visibility = false
		end
		if visibility then
			icon:modifyTheme({"PaddingRight", "Size", UDim2.new(0, 0, 1, 0)}, "IndicatorPadding")
		elseif indicator.Visible then
			icon:removeModification("IndicatorPadding")
		end
		icon:modifyTheme({"Indicator", "Visible", visibility})
		icon.updateSize:Fire()
	end
	icon.janitor:add(GamepadService:GetPropertyChangedSignal("GamepadCursorEnabled"):Connect(setIndicatorVisible))
	icon.indicatorSet:Connect(function(keyCode)
		local visibility = false
		if keyCode then
			imageLabel.Image = UserInputService:GetImageForKeyCode(keyCode)
			visibility = true
		end
		setIndicatorVisible(visibility)
	end)

	local function updateSize()
		local ySize = widget.AbsoluteSize.Y*0.96
		indicator.Size = UDim2.new(0, ySize, 0, ySize)
	end
	widget:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateSize)
	updateSize()

	return indicator
end]]></ProtectedString>
								<string name="ScriptGuid">{EF565418-F83D-48B8-BDB8-0FE308ADB35D}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Indicator.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX008168E195744743A3E4B6F24CB3CEB5">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[return function(icon)

	local menu = Instance.new("ScrollingFrame")
	menu.Name = "Menu"
	menu.BackgroundTransparency = 1
	menu.Visible = true
	menu.ZIndex = 1
	menu.Size = UDim2.fromScale(1, 1)
	menu.ClipsDescendants = true
	menu.TopImage = ""
	menu.BottomImage = ""
	menu.HorizontalScrollBarInset = Enum.ScrollBarInset.Always
	menu.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	menu.ScrollingEnabled = true
	menu.ScrollingDirection = Enum.ScrollingDirection.X
	menu.ZIndex = 20
	menu.ScrollBarThickness = 3
	menu.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	menu.ScrollBarImageTransparency = 0.8
	menu.BorderSizePixel = 0
	menu.Selectable = false
	
	local Icon = require(icon.iconModule)
	local menuUIListLayout = Icon.container.TopbarStandard:FindFirstChild("UIListLayout", true):Clone()
	menuUIListLayout.Name = "MenuUIListLayout"
	menuUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	menuUIListLayout.Parent = menu

	local menuGap = Instance.new("Frame")
	menuGap.Name = "MenuGap"
	menuGap.BackgroundTransparency = 1
	menuGap.Visible = false
	menuGap.AnchorPoint = Vector2.new(0, 0.5)
	menuGap.ZIndex = 5
	menuGap.Parent = menu
	
	local hasStartedMenu = false
	local Themes = require(script.Parent.Parent.Features.Themes)
	local function totalChildrenChanged()
		
		local menuJanitor = icon.menuJanitor
		local totalIcons = #icon.menuIcons
		if hasStartedMenu then
			if totalIcons <= 0 then
				menuJanitor:clean()
				hasStartedMenu = false
			end
			return
		end
		hasStartedMenu = true
		
		-- Listen for changes
		menuJanitor:add(icon.toggled:Connect(function()
			if #icon.menuIcons > 0 then
				icon.updateSize:Fire()
			end
		end))
		
		-- Modify appearance of menu icon when joined
		local _, modificationUID = icon:modifyTheme({
			{"Menu", "Active", true},
		})
		task.defer(function()
			menuJanitor:add(function()
				icon:removeModification(modificationUID)
			end)
		end)
		
		-- For right-aligned icons, this ensures their menus
		-- close button appear instantly when selected (instead
		-- of partially hidden from view)
		local previousCanvasX = menu.AbsoluteCanvasSize.X
		local function rightAlignCanvas()
			if icon.alignment == "Right" then
				local newCanvasX = menu.AbsoluteCanvasSize.X
				local difference = previousCanvasX - newCanvasX
				previousCanvasX = newCanvasX
				menu.CanvasPosition = Vector2.new(menu.CanvasPosition.X - difference, 0)
			end
		end
		menuJanitor:add(icon.selected:Connect(rightAlignCanvas))
		menuJanitor:add(menu:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(rightAlignCanvas))
		
		-- Apply a close selected image if the user hasn't applied thier own
		local stateGroup = icon:getStateGroup()
		local imageDeselected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Deselected")
		local imageSelected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Selected")
		if imageDeselected == imageSelected then
			local fontLink = "rbxasset://fonts/families/FredokaOne.json"
			local fontFace = Font.new(fontLink, Enum.FontWeight.Light, Enum.FontStyle.Normal)
			icon:removeModificationWith("IconLabel", "Text", "Viewing")
			icon:removeModificationWith("IconLabel", "Image", "Viewing")
			icon:modifyTheme({
				{"IconLabel", "FontFace", fontFace, "Selected"},
				{"IconLabel", "Text", "X", "Selected"},
				{"IconLabel", "TextSize", 20, "Selected"},
				{"IconLabel", "TextStrokeTransparency", 0.8, "Selected"},
				{"IconImage", "Image", "", "Selected"},
			})
		end

		-- Change order of spot when alignment changes
		local menuGap = icon:getInstance("MenuGap")
		local function updateAlignent()
			local alignment = icon.alignment
			local spotIndex = -99999
			local gapIndex = -99998
			if alignment == "Right" then
				spotIndex = 99999
				gapIndex = 99998
			end
			icon:modifyTheme({"IconSpot", "LayoutOrder", spotIndex})
			menuGap.LayoutOrder = gapIndex
		end
		menuJanitor:add(icon.alignmentChanged:Connect(updateAlignent))
		updateAlignent()
		
		-- This updates the scrolling frame to only display a scroll
		-- length equal to the distance produced by its MaxIcons
		menu:GetAttributeChangedSignal("MenuCanvasWidth"):Connect(function()
			local canvasWidth = menu:GetAttribute("MenuCanvasWidth")
			local canvasY = menu.CanvasSize.Y
			menu.CanvasSize = UDim2.new(0, canvasWidth, canvasY.Scale, canvasY.Offset)
		end)
		menuJanitor:add(icon.updateMenu:Connect(function()
			local maxIcons = menu:GetAttribute("MaxIcons")
			if not maxIcons then
				return
			end
			local orderedInstances = {}
			for _, child in pairs(menu:GetChildren()) do
				local widgetUID = child:GetAttribute("WidgetUID")
				if widgetUID and child.Visible then
					table.insert(orderedInstances, {child, child.AbsolutePosition.X})
				end
			end
			table.sort(orderedInstances, function(groupA, groupB)
				return groupA[2] < groupB[2]
			end)
			local totalWidth = 0
			for i = 1, maxIcons do
				local group = orderedInstances[i]
				if not group then
					break
				end
				local child = group[1]
				local width = child.AbsoluteSize.X + menuUIListLayout.Padding.Offset
				totalWidth += width
			end
			menu:SetAttribute("MenuWidth", totalWidth)
		end))
		local function startMenuUpdate()
			task.delay(0.1, function()
				icon.startMenuUpdate:Fire()
			end)
		end
		menuJanitor:add(menu.ChildAdded:Connect(startMenuUpdate))
		menuJanitor:add(menu.ChildRemoved:Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxIcons"):Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxWidth"):Connect(startMenuUpdate))
		startMenuUpdate()
	end
	
	icon.menuChildAdded:Connect(totalChildrenChanged)
	icon.menuSet:Connect(function(arrayOfIcons)
		-- Reset any previous icons
		for i, otherIconUID in pairs(icon.menuIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		-- Apply new icons
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinMenu(icon)
			end
		end
	end)
	
	return menu
end]]></ProtectedString>
								<string name="ScriptGuid">{47DFD364-2608-4FCC-B2EE-B8CD93013DEE}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Menu.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX526FFFD686314B6AAB1C5C2094F06377">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local notice = Instance.new("Frame")
	notice.Name = "Notice"
	notice.ZIndex = 25
	notice.AutomaticSize = Enum.AutomaticSize.X
	notice.BorderColor3 = Color3.fromRGB(0, 0, 0)
	notice.BorderSizePixel = 0
	notice.BackgroundTransparency = 0.1
	notice.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	notice.Visible = false
	notice.Parent = icon.widget

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = notice

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Parent = notice

	local noticeLabel = Instance.new("TextLabel")
	noticeLabel.Name = "NoticeLabel"
	noticeLabel.ZIndex = 26
	noticeLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	noticeLabel.AutomaticSize = Enum.AutomaticSize.X
	noticeLabel.Size = UDim2.new(1, 0, 1, 0)
	noticeLabel.BackgroundTransparency = 1
	noticeLabel.Position = UDim2.new(0.5, 0, 0.515, 0)
	noticeLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.FontSize = Enum.FontSize.Size14
	noticeLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.Text = "1"
	noticeLabel.TextWrapped = true
	noticeLabel.TextWrap = true
	noticeLabel.Font = Enum.Font.Arial
	noticeLabel.Parent = notice
	
	local iconModule = script.Parent.Parent
	local packages = iconModule.Packages
	local Janitor = require(packages.Janitor)
	local Signal = require(packages.GoodSignal)
	local Utility = require(iconModule.Utility)
	icon.noticeChanged:Connect(function(totalNotices)

		-- Notice amount
		if not totalNotices then
			return
		end
		local exceeded99 = totalNotices > 99
		local noticeDisplay = (exceeded99 and "99+") or totalNotices
		noticeLabel.Text = noticeDisplay
		if exceeded99 then
			noticeLabel.TextSize = 11
		end

		-- Should enable
		local enabled = true
		if totalNotices < 1 then
			enabled = false
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		local dropdownOrMenuActive = #icon.dropdownIcons > 0 or #icon.menuIcons > 0
		if icon.isSelected and dropdownOrMenuActive then
			enabled = false
		elseif parentIcon and not parentIcon.isSelected then
			enabled = false
		end
		Utility.setVisible(notice, enabled, "NoticeHandler")

	end)
	icon.noticeStarted:Connect(function(customClearSignal, noticeId)
	
		if not customClearSignal then
			customClearSignal = icon.deselected
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		if parentIcon then
			parentIcon:notify(customClearSignal)
		end
		
		local noticeJanitor = icon.janitor:add(Janitor.new())
		local noticeComplete = noticeJanitor:add(Signal.new())
		noticeJanitor:add(icon.endNotices:Connect(function()
			noticeComplete:Fire()
		end))
		noticeJanitor:add(customClearSignal:Connect(function()
			noticeComplete:Fire()
		end))
		noticeId = noticeId or Utility.generateUID()
		icon.notices[noticeId] = {
			completeSignal = noticeComplete,
			clearNoticeEvent = customClearSignal,
		}
		local function updateNotice()
			icon.noticeChanged:Fire(icon.totalNotices)
		end
		icon.notified:Fire(noticeId)
		icon.totalNotices += 1
		updateNotice()
		noticeComplete:Once(function()
			noticeJanitor:destroy()
			icon.totalNotices -= 1
			icon.notices[noticeId] = nil
			updateNotice()
		end)
	end)
	
	-- Establish the notice
	notice:SetAttribute("ClipToJoinedParent", true)
	icon:clipOutside(notice)
	
	return notice
end]]></ProtectedString>
								<string name="ScriptGuid">{12440AE5-EB20-4708-9C09-17CFA1ECE608}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Notice.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC704ED0533254F73812ADC884C0E2432">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[return function(Icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local selectionContainer = Instance.new("Frame")
	selectionContainer.Name = "SelectionContainer"
	selectionContainer.Visible = false
	
	local selection = Instance.new("Frame")
	selection.Name = "Selection"
	selection.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	selection.BackgroundTransparency = 1
	selection.BorderColor3 = Color3.fromRGB(0, 0, 0)
	selection.BorderSizePixel = 0
	selection.Parent = selectionContainer

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Name = "UIStroke"
	UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	UIStroke.Color = Color3.fromRGB(255, 255, 255)
	UIStroke.Thickness = 3
	UIStroke.Parent = selection

	local selectionGradient = Instance.new("UIGradient")
	selectionGradient.Name = "SelectionGradient"
	selectionGradient.Parent = UIStroke

	local UICorner = Instance.new("UICorner")
	UICorner:SetAttribute("Collective", "IconCorners")
	UICorner.Name = "UICorner"
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = selection
	
	local RunService = game:GetService("RunService")
	local GuiService = game:GetService("GuiService")
	local rotationSpeed = 1
	selection:GetAttributeChangedSignal("RotationSpeed"):Connect(function()
		rotationSpeed = selection:GetAttribute("RotationSpeed")
	end)
	RunService.Heartbeat:Connect(function()
		if not GuiService.SelectedObject then
			return
		end
		selectionGradient.Rotation = (os.clock() * rotationSpeed * 100) % 360
	end)

	return selectionContainer
	
end]]></ProtectedString>
								<string name="ScriptGuid">{D000321A-9131-4594-91A4-683E58417957}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Selection.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5BF398017D984EA5A9F6DF06C1D20602">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- I named this 'Widget' instead of 'Icon' to make a clear difference between the icon *object* and
-- the icon (aka Widget) instance.
-- This contains the core components of the icon such as the button, image, label and notice. It's
-- also responsible for handling the automatic resizing of the widget (based upon image visibility and text length)

return function(icon, Icon)

	local widget = Instance.new("Frame")
	widget:SetAttribute("WidgetUID", icon.UID)
	widget.Name = "Widget"
	widget.BackgroundTransparency = 1
	widget.Visible = true
	widget.ZIndex = 20
	widget.Active = false
	widget.ClipsDescendants = true

	local button = Instance.new("Frame")
	button.Name = "IconButton"
	button.Visible = true
	button.ZIndex = 2
	button.BorderSizePixel = 0
	button.Parent = widget
	button.ClipsDescendants = true
	button.Active = false -- This is essential for mobile scrollers to work when dragging
	icon.deselected:Connect(function()
		button.ClipsDescendants = true
		task.delay(0.2, function()
			if icon.isSelected then
				button.ClipsDescendants = false
			end
		end)
	end)

	-- Account for PreferredTransparency which can be set by every player
	local GuiService = game:GetService("GuiService")
	icon:setBehaviour("IconButton", "BackgroundTransparency", function(value)
		local preference = GuiService.PreferredTransparency
		local newValue = value * preference
		if value == 1 then
			return value
		end
		return newValue
	end)
	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
		icon:refreshAppearance(button, "BackgroundTransparency")
	end))

	local iconCorner = Instance.new("UICorner")
	iconCorner:SetAttribute("Collective", "IconCorners")
	iconCorner.Name = "UICorner"
	iconCorner.Parent = button

	local menu = require(script.Parent.Menu)(icon)
	local menuUIListLayout = menu.MenuUIListLayout
	local menuGap = menu.MenuGap
	menu.Parent = button

	local iconSpot = Instance.new("Frame")
	iconSpot.Name = "IconSpot"
	iconSpot.BackgroundColor3 = Color3.fromRGB(225, 225, 225)
	iconSpot.BackgroundTransparency = 0.9
	iconSpot.Visible = true
	iconSpot.AnchorPoint = Vector2.new(0, 0.5)
	iconSpot.ZIndex = 5
	iconSpot.Parent = menu

	local iconSpotCorner = iconCorner:Clone()
	iconSpotCorner.Parent = iconSpot

	local overlay = iconSpot:Clone()
	overlay.UICorner.Name = "OverlayUICorner"
	overlay.Name = "IconOverlay"
	overlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	overlay.ZIndex = iconSpot.ZIndex + 1
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.Position = UDim2.new(0, 0, 0, 0)
	overlay.AnchorPoint = Vector2.new(0, 0)
	overlay.Visible = false
	overlay.Parent = iconSpot

	local clickRegion = Instance.new("TextButton")
	clickRegion:SetAttribute("CorrespondingIconUID", icon.UID)
	clickRegion.Name = "ClickRegion"
	clickRegion.BackgroundTransparency = 1
	clickRegion.Visible = true
	clickRegion.Text = ""
	clickRegion.ZIndex = 20
	clickRegion.Selectable = true
	clickRegion.SelectionGroup = true
	clickRegion.Parent = iconSpot
	
	local Gamepad = require(script.Parent.Parent.Features.Gamepad)
	Gamepad.registerButton(clickRegion)

	local clickRegionCorner = iconCorner:Clone()
	clickRegionCorner.Parent = clickRegion

	local contents = Instance.new("Frame")
	contents.Name = "Contents"
	contents.BackgroundTransparency = 1
	contents.Size = UDim2.fromScale(1, 1)
	contents.Parent = iconSpot

	local contentsList = Instance.new("UIListLayout")
	contentsList.Name = "ContentsList"
	contentsList.FillDirection = Enum.FillDirection.Horizontal
	contentsList.VerticalAlignment = Enum.VerticalAlignment.Center
	contentsList.SortOrder = Enum.SortOrder.LayoutOrder
	contentsList.VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly
	contentsList.Padding = UDim.new(0, 3)
	contentsList.Parent = contents

	local paddingLeft = Instance.new("Frame")
	paddingLeft.Name = "PaddingLeft"
	paddingLeft.LayoutOrder = 1
	paddingLeft.ZIndex = 5
	paddingLeft.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingLeft.BackgroundTransparency = 1
	paddingLeft.BorderSizePixel = 0
	paddingLeft.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingLeft.Parent = contents

	local paddingCenter = Instance.new("Frame")
	paddingCenter.Name = "PaddingCenter"
	paddingCenter.LayoutOrder = 3
	paddingCenter.ZIndex = 5
	paddingCenter.Size = UDim2.new(0, 0, 1, 0)
	paddingCenter.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingCenter.BackgroundTransparency = 1
	paddingCenter.BorderSizePixel = 0
	paddingCenter.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingCenter.Parent = contents

	local paddingRight = Instance.new("Frame")
	paddingRight.Name = "PaddingRight"
	paddingRight.LayoutOrder = 5
	paddingRight.ZIndex = 5
	paddingRight.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingRight.BackgroundTransparency = 1
	paddingRight.BorderSizePixel = 0
	paddingRight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingRight.Parent = contents

	local iconLabelContainer = Instance.new("Frame")
	iconLabelContainer.Name = "IconLabelContainer"
	iconLabelContainer.LayoutOrder = 4
	iconLabelContainer.ZIndex = 3
	iconLabelContainer.AnchorPoint = Vector2.new(0, 0.5)
	iconLabelContainer.Size = UDim2.new(0, 0, 0.5, 0)
	iconLabelContainer.BackgroundTransparency = 1
	iconLabelContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
	iconLabelContainer.Parent = contents

	local iconLabel = Instance.new("TextLabel")
	local viewportX = workspace.CurrentCamera.ViewportSize.X+200
	iconLabel.Name = "IconLabel"
	iconLabel.LayoutOrder = 4
	iconLabel.ZIndex = 15
	iconLabel.AnchorPoint = Vector2.new(0, 0)
	iconLabel.Size = UDim2.new(0, viewportX, 1, 0)
	iconLabel.ClipsDescendants = false
	iconLabel.BackgroundTransparency = 1
	iconLabel.Position = UDim2.fromScale(0, 0)
	iconLabel.RichText = true
	iconLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
	iconLabel.Text = ""
	iconLabel.TextWrapped = true
	iconLabel.TextWrap = true
	iconLabel.TextScaled = false
	iconLabel.Active = false
	iconLabel.AutoLocalize = true
	iconLabel.Parent = iconLabelContainer

	local iconImage = Instance.new("ImageLabel")
	iconImage.Name = "IconImage"
	iconImage.LayoutOrder = 2
	iconImage.ZIndex = 15
	iconImage.AnchorPoint = Vector2.new(0, 0.5)
	iconImage.Size = UDim2.new(0, 0, 0.5, 0)
	iconImage.BackgroundTransparency = 1
	iconImage.Position = UDim2.new(0, 11, 0.5, 0)
	iconImage.ScaleType = Enum.ScaleType.Stretch
	iconImage.Active = false
	iconImage.Parent = contents

	local iconImageCorner = iconCorner:Clone()
	iconImageCorner:SetAttribute("Collective", nil)
	iconImageCorner.CornerRadius = UDim.new(0, 0)
	iconImageCorner.Name = "IconImageCorner"
	iconImageCorner.Parent = iconImage

	local TweenService = game:GetService("TweenService")
	local resizingCount = 0
	local function handleLabelAndImageChangesUnstaggered(forceUpdateString)

		-- We defer changes by a frame to eliminate all but 1 requests which
		-- could otherwise stack up to 20+ requests in a single frame
		-- We then repeat again once to account for any final changes
		-- Deferring is also essential because properties are set immediately
		-- afterwards (therefore calculations will use the correct values)
		task.defer(function()
			local indicator = icon.indicator
			local usingIndicator = indicator and indicator.Visible
			local usingText = usingIndicator or iconLabel.Text ~= ""
			local usingImage = iconImage.Image ~= "" and iconImage.Image ~= nil
			local _alignment = Enum.HorizontalAlignment.Center
			local NORMAL_BUTTON_SIZE = UDim2.fromScale(1, 1)
			local buttonSize = NORMAL_BUTTON_SIZE
			if usingImage and not usingText then
				iconLabelContainer.Visible = false
				iconImage.Visible = true
				paddingLeft.Visible = false
				paddingCenter.Visible = false
				paddingRight.Visible = false
			elseif not usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = false
				paddingLeft.Visible = true
				paddingCenter.Visible = false
				paddingRight.Visible = true
			elseif usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = true
				paddingLeft.Visible = true
				paddingCenter.Visible = not usingIndicator
				paddingRight.Visible = not usingIndicator
				_alignment = Enum.HorizontalAlignment.Left
			end
			button.Size = buttonSize

			local function getItemWidth(item)
				local targetWidth = item:GetAttribute("TargetWidth") or item.AbsoluteSize.X
				return targetWidth
			end
			local contentsPadding = contentsList.Padding.Offset
			local initialWidgetWidth = contentsPadding --0
			local textWidth = iconLabel.TextBounds.X
			iconLabelContainer.Size = UDim2.new(0, textWidth, iconLabel.Size.Y.Scale, 0)
			for _, child in pairs(contents:GetChildren()) do
				if child:IsA("GuiObject") and child.Visible == true then
					local itemWidth = getItemWidth(child)
					initialWidgetWidth += itemWidth + contentsPadding
				end
			end
			local widgetMinimumWidth = widget:GetAttribute("MinimumWidth")
			local widgetMinimumHeight = widget:GetAttribute("MinimumHeight")
			local widgetBorderSize = widget:GetAttribute("BorderSize")
			local widgetWidth = math.clamp(initialWidgetWidth, widgetMinimumWidth, viewportX)
			local menuIcons = icon.menuIcons
			local additionalWidth = 0
			local hasMenu = #menuIcons > 0
			local showMenu = hasMenu and icon.isSelected
			if showMenu then
				for _, frame in pairs(menu:GetChildren()) do
					if frame ~= iconSpot and frame:IsA("GuiObject") and frame.Visible then
						additionalWidth += getItemWidth(frame) + menuUIListLayout.Padding.Offset
					end
				end
				if not iconSpot.Visible then
					widgetWidth -= (getItemWidth(iconSpot) + menuUIListLayout.Padding.Offset*2 + widgetBorderSize)
				end
				additionalWidth -= (widgetBorderSize*0.5)
				widgetWidth += additionalWidth - (widgetBorderSize*0.75)
			end
			menuGap.Visible = showMenu and iconSpot.Visible
			local desiredWidth = widget:GetAttribute("DesiredWidth")
			if desiredWidth and widgetWidth < desiredWidth then
				widgetWidth = desiredWidth
			end

			icon.updateMenu:Fire()
			local preWidth = math.max(widgetWidth-additionalWidth, widgetMinimumWidth)
			local spotWidth = preWidth-(widgetBorderSize*2)
			local menuWidth = menu:GetAttribute("MenuWidth")
			local totalMenuWidth = menuWidth and menuWidth + spotWidth + menuUIListLayout.Padding.Offset + 10
			if totalMenuWidth then
				local maxWidth = menu:GetAttribute("MaxWidth")
				if maxWidth then
					totalMenuWidth = math.max(maxWidth, widgetMinimumWidth)
				end
				menu:SetAttribute("MenuCanvasWidth", widgetWidth)
				if totalMenuWidth < widgetWidth then
					widgetWidth = totalMenuWidth
				end
			end

			local style = Enum.EasingStyle.Quint
			local direction = Enum.EasingDirection.Out
			local spotWidthMax = math.max(spotWidth, getItemWidth(iconSpot), iconSpot.AbsoluteSize.X)
			local widgetWidthMax = math.max(widgetWidth, getItemWidth(widget), widget.AbsoluteSize.X)
			local SPEED = 750
			local spotTweenInfo = TweenInfo.new(spotWidthMax/SPEED, style, direction)
			local widgetTweenInfo = TweenInfo.new(widgetWidthMax/SPEED, style, direction)
			TweenService:Create(iconSpot, spotTweenInfo, {
				Position = UDim2.new(0, widgetBorderSize, 0.5, 0),
				Size = UDim2.new(0, spotWidth, 1, -widgetBorderSize*2),
			}):Play()
			TweenService:Create(clickRegion, spotTweenInfo, {
				Size = UDim2.new(0, spotWidth, 1, 0),
			}):Play()
			local newWidgetSize = UDim2.fromOffset(widgetWidth, widgetMinimumHeight)
			local updateInstantly = widget.Size.Y.Offset ~= widgetMinimumHeight
			if updateInstantly then
				widget.Size = newWidgetSize
			end
			widget:SetAttribute("TargetWidth", newWidgetSize.X.Offset)
			local movingTween = TweenService:Create(widget, widgetTweenInfo, {
				Size = newWidgetSize,
			})
			movingTween:Play()
			resizingCount += 1
			for i = 1, widgetTweenInfo.Time * 100 do
				task.delay(i/100, function()
					Icon.iconChanged:Fire(icon)
				end)
			end
			task.delay(widgetTweenInfo.Time-0.2, function()
				resizingCount -= 1
				task.defer(function()
					if resizingCount == 0 then
						icon.resizingComplete:Fire()
					end
				end)
			end)
			icon:updateParent()
		end)
	end
	local Utility = require(script.Parent.Parent.Utility)
	local handleLabelAndImageChanges = Utility.createStagger(0.01, handleLabelAndImageChangesUnstaggered)
	local firstTimeSettingFontFace = true
	icon:setBehaviour("IconLabel", "Text", handleLabelAndImageChanges)
	icon:setBehaviour("IconLabel", "FontFace", function(value)
		local previousFontFace = iconLabel.FontFace
		if previousFontFace == value then
			return
		end
		task.spawn(function()
			--[[
			local fontLink = value.Family
			if string.match(fontLink, "rbxassetid://") then
				local ContentProvider = game:GetService("ContentProvider")
				local assets = {fontLink}
				ContentProvider:PreloadAsync(assets)
			end--]]

			-- Afaik there's no way to determine when a Font Family has
			-- loaded (even with ContentProvider), so we just have to try
			-- a few times and hope it loads within the refresh period
			handleLabelAndImageChanges()
			if firstTimeSettingFontFace then
				firstTimeSettingFontFace = false
				for i = 1, 10 do
					task.wait(1)
					handleLabelAndImageChanges()
				end
			end
		end)
	end)
	local function updateBorderSize()
		task.defer(function()
			local borderOffset = widget:GetAttribute("BorderSize")
			local alignment = icon.alignment
			local alignmentOffset = (iconSpot.Visible == false and 0) or (alignment == "Right" and -borderOffset) or borderOffset
			menu.Position = UDim2.new(0, alignmentOffset, 0, 0)
			menuGap.Size = UDim2.fromOffset(borderOffset, 0)
			menuUIListLayout.Padding = UDim.new(0, 0)
			handleLabelAndImageChanges()
		end)
	end
	icon:setBehaviour("Widget", "BorderSize", updateBorderSize)
	icon:setBehaviour("IconSpot", "Visible", updateBorderSize)
	icon.startMenuUpdate:Connect(handleLabelAndImageChanges)
	icon.updateSize:Connect(handleLabelAndImageChanges)
	icon:setBehaviour("ContentsList", "HorizontalAlignment", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "DesiredWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumHeight", handleLabelAndImageChanges)
	icon:setBehaviour("Indicator", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("IconImageRatio", "AspectRatio", handleLabelAndImageChanges)
	icon:setBehaviour("IconImage", "Image", function(value)
		local textureId = (tonumber(value) and "http://www.roblox.com/asset/?id="..value) or value or ""
		if iconImage.Image ~= textureId then
			handleLabelAndImageChanges()
		end
		return textureId
	end)
	icon.alignmentChanged:Connect(function(newAlignment)
		if newAlignment == "Center" then
			newAlignment = "Left"
		end
		menuUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment[newAlignment]
		updateBorderSize()
	end)

	-- Localization support (refresh icon size whenever player changes language changes in-game)
	local Players = game:GetService("Players")
	local localPlayer = Players.LocalPlayer
	local lastLocaleId = localPlayer.LocaleId
	icon.janitor:add(localPlayer:GetPropertyChangedSignal("LocaleId"):Connect(function()
		task.delay(0.2, function()
			local newLocaleId = localPlayer.LocaleId
			if newLocaleId ~= lastLocaleId then
				lastLocaleId = newLocaleId
				icon:refresh()
				task.wait(0.5)
				icon:refresh()
			end
		end)
	end))
	
	local iconImageScale = Instance.new("NumberValue")
	iconImageScale.Name = "IconImageScale"
	iconImageScale.Parent = iconImage
	iconImageScale:GetPropertyChangedSignal("Value"):Connect(function()
		iconImage.Size = UDim2.new(iconImageScale.Value, 0, iconImageScale.Value, 0)
	end)

	local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
	UIAspectRatioConstraint.Name = "IconImageRatio"
	UIAspectRatioConstraint.AspectType = Enum.AspectType.FitWithinMaxSize
	UIAspectRatioConstraint.DominantAxis = Enum.DominantAxis.Height
	UIAspectRatioConstraint.Parent = iconImage

	local iconGradient = Instance.new("UIGradient")
	iconGradient.Name = "IconGradient"
	iconGradient.Enabled = true
	iconGradient.Parent = button

	local iconSpotGradient = Instance.new("UIGradient")
	iconSpotGradient.Name = "IconSpotGradient"
	iconSpotGradient.Enabled = true
	iconSpotGradient.Parent = iconSpot

	return widget
end]]></ProtectedString>
								<string name="ScriptGuid">{D79AED54-3AC6-4A35-9EC6-59B3B3243300}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Widget.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3C259F311B274736B2B7A590C1638FF7">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Themes = require(script.Parent.Parent.Features.Themes)
local PADDING = 0 -- used to be 8
return function(icon)
	
	local dropdown = Instance.new("Frame") -- Instance.new("CanvasGroup")
	dropdown.Name = "Dropdown"
	dropdown.AutomaticSize = Enum.AutomaticSize.X
	dropdown.BackgroundTransparency = 1
	dropdown.BorderSizePixel = 0
	dropdown.AnchorPoint = Vector2.new(0.5, 0)
	dropdown.Position = UDim2.new(0.5, 0, 1, 10)
	dropdown.ZIndex = -2
	dropdown.ClipsDescendants = true
	dropdown.Parent = icon.widget

	-- Account for PreferredTransparency which can be set by every player
	local GuiService = game:GetService("GuiService")
	icon:setBehaviour("Dropdown", "BackgroundTransparency", function(value)
		local preference = GuiService.PreferredTransparency
		local newValue = value * preference
		if value == 1 then
			return value
		end
		return newValue
	end)
	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
		icon:refreshAppearance(dropdown, "BackgroundTransparency")
	end))

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "DropdownCorner"
	UICorner.CornerRadius = UDim.new(0, 10)
	UICorner.Parent = dropdown

	local dropdownScroller = Instance.new("ScrollingFrame")
	dropdownScroller.Name = "DropdownScroller"
	dropdownScroller.AutomaticSize = Enum.AutomaticSize.X
	dropdownScroller.BackgroundTransparency = 1
	dropdownScroller.BorderSizePixel = 0
	dropdownScroller.AnchorPoint = Vector2.new(0, 0)
	dropdownScroller.Position = UDim2.new(0, 0, 0, 0)
	dropdownScroller.ZIndex = -1
	dropdownScroller.ClipsDescendants = true
	dropdownScroller.Visible = true
	dropdownScroller.VerticalScrollBarInset = Enum.ScrollBarInset.None --ScrollBar
	dropdownScroller.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
	dropdownScroller.Active = false
	dropdownScroller.ScrollingEnabled = true
	dropdownScroller.AutomaticCanvasSize = Enum.AutomaticSize.Y
	dropdownScroller.ScrollBarThickness = 5
	dropdownScroller.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	dropdownScroller.ScrollBarImageTransparency = 0.8
	dropdownScroller.CanvasSize = UDim2.new(0, 0, 0, 0)
	dropdownScroller.Selectable = false
	dropdownScroller.Active = true
	dropdownScroller.Parent = dropdown

	local TweenDuration = Instance.new("NumberValue") -- this helps to change the speed to open / close in modifyTheme()
	TweenDuration.Name = "DropdownSpeed"
	TweenDuration.Value = 0.07
	TweenDuration.Parent = dropdown

	local dropdownPadding = Instance.new("UIPadding")
	dropdownPadding.Name = "DropdownPadding"
	dropdownPadding.PaddingTop = UDim.new(0, PADDING)
	dropdownPadding.PaddingBottom = UDim.new(0, PADDING)
	dropdownPadding.Parent = dropdownScroller

	local dropdownList = Instance.new("UIListLayout")
	dropdownList.Name = "DropdownList"
	dropdownList.FillDirection = Enum.FillDirection.Vertical
	dropdownList.SortOrder = Enum.SortOrder.LayoutOrder
	dropdownList.HorizontalAlignment = Enum.HorizontalAlignment.Center
	dropdownList.HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly
	dropdownList.Parent = dropdownScroller

	local dropdownJanitor = icon.dropdownJanitor
	local Icon = require(icon.iconModule)
	icon.dropdownChildAdded:Connect(function(childIcon)
		local _, modificationUID = childIcon:modifyTheme({
			{"Widget", "BorderSize", 0},
			{"IconCorners", "CornerRadius", UDim.new(0, 10)},
			{"Widget", "MinimumWidth", 190},
			{"Widget", "MinimumHeight", 58},
			{"IconLabel", "TextSize", 20},
			{"IconOverlay", "Size", UDim2.new(1, 0, 1, 0)},
			{"PaddingLeft", "Size", UDim2.fromOffset(25, 0)},
			{"Notice", "Position", UDim2.new(1, -24, 0, 5)},
			{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Left},
			{"Selection", "Size", UDim2.new(1, -PADDING, 1, -PADDING)},
			{"Selection", "Position", UDim2.new(0, PADDING/2, 0, PADDING/2)},
		})
		task.defer(function()
			childIcon.joinJanitor:add(function()
				childIcon:removeModification(modificationUID)
			end)
		end)
	end)
	icon.dropdownSet:Connect(function(arrayOfIcons)
		for i, otherIconUID in pairs(icon.dropdownIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinDropdown(icon)
			end
		end
	end)

	local function updateMaxIcons()
		--icon:modifyTheme({"Dropdown", "Visible", icon.isSelected})
		local maxIcons = dropdown:GetAttribute("MaxIcons")
		if not maxIcons then return 0 end
		local children = {}
		for _, child in pairs(dropdownScroller:GetChildren()) do
			if child:IsA("GuiObject") and child.Visible then
				table.insert(children, child)
			end
		end

		table.sort(children, function(a, b) return a.AbsolutePosition.Y < b.AbsolutePosition.Y end)
		local totalHeight = 0
		local maxIconsRoundedUp = math.ceil(maxIcons)
		for i = 1, maxIconsRoundedUp do
			local child = children[i]
			if not child then break end
			local height = child.AbsoluteSize.Y
			local isReduced = i == maxIconsRoundedUp and maxIconsRoundedUp ~= maxIcons
			if isReduced then
				height *= (maxIcons - maxIconsRoundedUp + 1)
			end
			totalHeight += height
		end
		totalHeight += dropdownPadding.PaddingTop.Offset + dropdownPadding.PaddingBottom.Offset
		return totalHeight
	end
	
	local openTween = nil
	local closeTween = nil
	local currentSpeedMultiplier = nil
	local currentTweenInfo = nil
	local function getTweenInfo()
		local speedMultiplier = Themes.getInstanceValue(dropdown, "MaxIcons") or 1
		if currentSpeedMultiplier and currentSpeedMultiplier == speedMultiplier and currentTweenInfo then
			return currentTweenInfo
		end
		local newTweenInfo = TweenInfo.new(
			TweenDuration.Value * speedMultiplier,
			Enum.EasingStyle.Exponential,
			Enum.EasingDirection.Out
		)
		currentTweenInfo = newTweenInfo
		currentSpeedMultiplier = speedMultiplier
		return newTweenInfo
	end
	local function updateVisibility()
		-- Update visibiliy of dropdown using tween transition
		local tweenInfo = getTweenInfo()
		
		if openTween then
			openTween:Cancel()
			openTween = nil
		end
		if closeTween then
			closeTween:Cancel()
			closeTween = nil
		end

		if icon.isSelected then
			local height = updateMaxIcons()
			dropdown.Visible = true
			dropdown.BackgroundTransparency = 0 -- no transparency so it looks solid
			dropdown.Size = UDim2.new(0, dropdown.Size.X.Offset, 0, 0) -- reset height to 0 before tween

			openTween = TweenService:Create(dropdown, tweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, height)})
			openTween:Play()
			openTween.Completed:Connect(function()
				openTween = nil
			end)
		else
			local closeTweenInfo = TweenInfo.new(0)
			closeTween = TweenService:Create(dropdown, closeTweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, 0)})
			closeTween:Play()
			closeTween.Completed:Connect(function()
				closeTween = nil
			end)
		end
	end

	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))
	updateVisibility()
	--task.delay(0.2, updateVisibility)

	local function updateChildSize()
		local tweenInfo = getTweenInfo()
		if not icon.isSelected then return end
		if openTween then
			openTween:Cancel()
			openTween = nil
		end
		if closeTween then
			closeTween:Cancel()
			closeTween = nil
		end
		
		RunService.Heartbeat:Wait()
		
		local height = updateMaxIcons()

		openTween = TweenService:Create(dropdown, tweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, height)})
		openTween:Play()
		openTween.Completed:Connect(function()	
			openTween = nil
		end)
	end

	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))

	-- Ensures canvas and size stay synced (original updateMaxIcons logic)
	local updateCount = 0
	local isUpdating = false

	-- This updates the scrolling frame to only display a scroll
	-- length equal to the distance produced by its MaxIcons
	local function updateMaxIconsListener()
		updateCount += 1
		if isUpdating then return end
		local myUpdateCount = updateCount
		isUpdating = true
		task.defer(function()
			isUpdating = false
			if updateCount ~= myUpdateCount then
				updateMaxIconsListener()
			end
		end)
		local maxIcons = dropdown:GetAttribute("MaxIcons")
		if not maxIcons then return end

		local orderedInstances = {}
		for _, child in pairs(dropdownScroller:GetChildren()) do
			if child:IsA("GuiObject") and child.Visible then
				table.insert(orderedInstances, {child, child.AbsolutePosition.Y})
			end
		end
		table.sort(orderedInstances, function(a, b) return a[2] < b[2] end)

		local totalHeight = 0
		local hasSetNextSelection = false
		local maxIconsRoundedUp = math.ceil(maxIcons)
		for i = 1, maxIconsRoundedUp do
			local group = orderedInstances[i]
			if not group then break end
			local child = group[1]
			local height = child.AbsoluteSize.Y
			local isReduced = i == maxIconsRoundedUp and maxIconsRoundedUp ~= maxIcons
			if isReduced then
				height = height * (maxIcons - maxIconsRoundedUp + 1)
			end
			totalHeight += height
			if isReduced then
				continue
			end
			local iconUID = child:GetAttribute("WidgetUID")
			local childIcon = iconUID and Icon.getIconByUID(iconUID)
			if childIcon then
				local nextSelection = nil
				if not hasSetNextSelection then
					hasSetNextSelection = true
					nextSelection = icon:getInstance("ClickRegion")
				end
				childIcon:getInstance("ClickRegion").NextSelectionUp = nextSelection
			end
		end
		totalHeight += dropdownPadding.PaddingTop.Offset + dropdownPadding.PaddingBottom.Offset

		dropdownScroller.Size = UDim2.fromOffset(0, totalHeight)

	end

	dropdownJanitor:add(dropdownScroller:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdownScroller.ChildAdded:Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateChildSize)) -- rezise the dropdown when icon delects or adds
	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateChildSize))
	dropdownJanitor:add(icon.childThemeModified:Connect(updateMaxIconsListener))
	updateMaxIconsListener()

	-- Ensures each child listens to visibility changes
	local function connectVisibilityListeners(child)
		if child:IsA("GuiObject") then
			child:GetPropertyChangedSignal("Visible"):Connect(updateChildSize)
			child:GetPropertyChangedSignal("Size"):Connect(updateChildSize) -- -- update max icons when child size changes
		end
	end
	
	-- For existing children
	for _, child in pairs(dropdownScroller:GetChildren()) do
		connectVisibilityListeners(child)
	end
	-- For new children
	dropdownScroller.ChildAdded:Connect(function(child)
		RunService.Heartbeat:Wait()
		connectVisibilityListeners(child)
		updateChildSize()
	end)

	-- On start, hide dropdown (prevent it showing as opened)
	dropdown.Visible = false

	return dropdown
end]]></ProtectedString>
								<string name="ScriptGuid">{81DF200C-7FC4-4DC7-A096-12ABD16FDD75}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Dropdown.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX2C980A3BA3044056AC0A16F1F0B38C9E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Features</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX1FF7973576BB40D7ACA6D7DB2200C93C">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- As the name suggests, this handles everything related to gamepads
-- (i.e. Xbox or Playstation controllers) and their navigation
-- I created a separate module for gamepads (and not touchpads or
-- keyboards) because gamepads are greatly more unqiue and require
-- additional tailored programming



-- SERVICES
local GamepadService = game:GetService("GamepadService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")



-- LOCAL
local DEFAULT_HIGHLIGHT_KEY = Enum.KeyCode.DPadUp -- The default key to highlight the topbar icon
local GAMEPAD_INPUT = Enum.PreferredInput.Gamepad
local Gamepad = {}
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Gamepad.start(incomingIcon)
	
	-- Public variables
	Icon = incomingIcon
	Icon.highlightKey = if Icon.highlightKey ~= nil then Icon.highlightKey else DEFAULT_HIGHLIGHT_KEY -- What controller key to highlight the topbar (or set to false to disable)
	Icon.highlightIcon = false -- Change to a specific icon if you'd like to highlight a specific icon instead of the left-most
	
	-- We defer so the developer can make changes before the
	-- gamepad controls are initialized
	task.delay(1, function()
		-- Some local utility
		local iconsDict = Icon.iconsDictionary
		local function getIconFromSelectedObject()
			local clickRegion = GuiService.SelectedObject
			local iconUID = clickRegion and clickRegion:GetAttribute("CorrespondingIconUID")
			local icon = iconUID and iconsDict[iconUID]
			return icon
		end
		
		-- This enables users to instantly open up their last selected icon
		local previousHighlightedIcon
		local usedIndicatorOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
		local usedBOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
		local Selection = require(script.Parent.Parent.Elements.Selection)
		local function updateSelectedObject()
			local icon = getIconFromSelectedObject()
			local isUsingGamepad = UserInputService.PreferredInput == GAMEPAD_INPUT
			if icon then
				if isUsingGamepad then
					local clickRegion = icon:getInstance("ClickRegion")
					local selection = icon.selection
					if not selection then
						selection = icon.janitor:add(Selection(Icon))
						selection:SetAttribute("IgnoreVisibilityUpdater", true)
						selection.Parent = icon.widget
						icon.selection = selection
						icon:refreshAppearance(selection) --icon:clipOutside(selection)
					end
					clickRegion.SelectionImageObject = selection.Selection
				end
				if previousHighlightedIcon and previousHighlightedIcon ~= icon then
					previousHighlightedIcon:setIndicator()
				end
				local newIndicator = if isUsingGamepad and not usedBOnce and not icon.parentIconUID then Enum.KeyCode.ButtonB else nil
				previousHighlightedIcon = icon
				Icon.lastHighlightedIcon = icon
				icon:setIndicator(newIndicator)
			else
				local newIndicator = if isUsingGamepad and not usedIndicatorOnce then Icon.highlightKey else nil
				if not previousHighlightedIcon then
					previousHighlightedIcon = Gamepad.getIconToHighlight()
				end
				if newIndicator == Icon.highlightKey then
					-- We only display the highlightKey once to show
					-- the user how to highlight the topbar icon
					usedIndicatorOnce = true
				else
					--usedBOnce = true
				end
				if previousHighlightedIcon then
					previousHighlightedIcon:setIndicator(newIndicator)
				end
			end
		end
		GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(updateSelectedObject)

		-- This listens for a gamepad being present/added/removed
		local function preferredInputChanged()
			local preferredInput = UserInputService.PreferredInput
			local isUsingGamepad = preferredInput == GAMEPAD_INPUT

			if not isUsingGamepad then
				usedIndicatorOnce = false
				usedBOnce = false
			end
			updateSelectedObject()
		end
		UserInputService:GetPropertyChangedSignal("PreferredInput"):Connect(preferredInputChanged)
		preferredInputChanged()

		-- This allows for easy highlighting of the topbar when the
		-- when ``Icon.highlightKey`` (i.e. DPadUp) is pressed.
		-- If you'd like to disable, do ``Icon.highlightKey = false``
		UserInputService.InputBegan:Connect(function(input, touchingAnObject)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				-- Sometimes the Roblox gamepad glitches when combined with a cursor
				-- This fixes that by unhighlighting if the cursor is pressed down
				-- (i.e. a mouse click)
				local icon = getIconFromSelectedObject()
				if icon then
					GuiService.SelectedObject = nil
				end
				return
			end
			if input.KeyCode ~= Icon.highlightKey then
				return
			end
			local iconToHighlight = Gamepad.getIconToHighlight()
			if iconToHighlight then
				if GamepadService.GamepadCursorEnabled then
					task.wait(0.2)
					GamepadService:DisableGamepadCursor()
				end
				local clickRegion = iconToHighlight:getInstance("ClickRegion")
				GuiService.SelectedObject = clickRegion
			end
		end)
	end)
end

function Gamepad.getIconToHighlight()
	-- If an icon has already been selected, returns the last selected icon
	-- Else if more than 0 icons, it selects the left-most icon
	local iconsDict = Icon.iconsDictionary
	local iconToHighlight = Icon.highlightIcon or Icon.lastHighlightedIcon
	if not iconToHighlight then
		local currentX
		for _, icon in pairs(iconsDict) do
			if icon.parentIconUID then
				continue
			end
			local thisX = icon.widget.AbsolutePosition.X
			if not currentX or thisX < currentX then
				iconToHighlight = icon
				currentX = iconToHighlight.widget.AbsolutePosition.X
			end
		end
	end
	return iconToHighlight
end

-- This called when the icon's ClickRegion is created
function Gamepad.registerButton(buttonInstance)
	-- This provides a basic level of support for controllers by making
	-- the icons easy to highlight via the virtual cursor, then
	-- when selected, focuses in on the selected icon and hops
	-- between other nearby icons simply by toggling the joystick
	local inputBegan = false
	buttonInstance.InputBegan:Connect(function(input)
		-- Two wait frames required to ensure inputBegan is detected within
		-- UserInputService.InputBegan. We do this because object.InputBegan
		-- does not return the correct input objects (unlike the service)
		inputBegan = true
		task.wait()
		task.wait()
		inputBegan = false
	end)
	local connection = UserInputService.InputBegan:Connect(function(input)
		task.wait()
		if input.KeyCode == Enum.KeyCode.ButtonA and inputBegan then
			-- We focus on an icon when selected via the virtual cursor
			task.wait(0.2)
			GamepadService:DisableGamepadCursor()
			GuiService.SelectedObject = buttonInstance
			return
		end
		local isSelected = GuiService.SelectedObject == buttonInstance
		local unselectKeyCodes = {"ButtonB", "ButtonSelect"}
		local keyName = input.KeyCode.Name
		if table.find(unselectKeyCodes, keyName) and isSelected then
			-- We unfocus when back button is pressed, but ignore
			-- if the virtual cursor is disabled otherwise it will be
			-- impossible to select the topbar
			if not(keyName == "ButtonSelect" and not GamepadService.GamepadCursorEnabled) then
				GuiService.SelectedObject = nil
			end
		end
	end)
	buttonInstance.Destroying:Once(function()
		connection:Disconnect()
	end)
end



return Gamepad]]></ProtectedString>
								<string name="ScriptGuid">{206AA87D-C515-4797-AE2A-8D02404F9B55}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Gamepad.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX191E42CC783340CE9E46865D284B5C53">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- When designing your game for many devices and screen sizes, icons may occasionally
-- particularly for smaller devices like phones, overlap with other icons or the bounds
-- of the screen. The overflow handler solves this challenge by moving the out-of-bounds
-- icon into an overflow menu (with a limited scrolling canvas) preventing overlaps occuring



-- LOCAL
local Overflow = {}
local holders = {}
local orderedAvailableIcons = {}
local iconsDict
local currentCamera = workspace.CurrentCamera
local overflowIcons = {}
local overflowIconUIDs = {}
local Utility = require(script.Parent.Parent.Utility)
local beginCheckingCenterIcons = false
local beganSecondaryCenterCheck = false
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Overflow.start(incomingIcon)
	Icon = incomingIcon
	iconsDict = Icon.iconsDictionary
	local primaryScreenGui
	for _, screenGui in pairs(Icon.container) do
		if primaryScreenGui == nil and screenGui.ScreenInsets == Enum.ScreenInsets.TopbarSafeInsets then
			primaryScreenGui = screenGui
		end
		for _, holder in pairs(screenGui.Holders:GetChildren()) do
			if holder:GetAttribute("IsAHolder") then
				holders[holder.Name] = holder
			end
		end
	end

	-- We listen for changes in icons (such as them being added, removed,
	-- the setting of a different alignment, the widget size changing, etc)
	local beginOverflow = false
	local updateBoundaries = Utility.createStagger(0.1, function(ignoreAvailable)
		if not beginOverflow then
			return
		end
		if not ignoreAvailable then
			Overflow.updateAvailableIcons("Center")
		end
		Overflow.updateBoundary("Left")
		Overflow.updateBoundary("Right")
	end)
	task.delay(0.5, function()
		beginOverflow = true
		updateBoundaries()
	end)
	task.delay(2, function()
		-- This is essential to prevent central icons begin added
		-- left or right due to incomplete UIListLayout calculations
		-- within the first few frames
		beginCheckingCenterIcons = true
		updateBoundaries()
	end)
	Icon.iconAdded:Connect(updateBoundaries)
	Icon.iconRemoved:Connect(updateBoundaries)
	Icon.iconChanged:Connect(updateBoundaries)
	currentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
		updateBoundaries(true)
	end)
	primaryScreenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updateBoundaries(true)
	end)
end

function Overflow.getWidth(icon, getMaxWidth)
	local widget = icon.widget
	return widget:GetAttribute("TargetWidth") or widget.AbsoluteSize.X
end

function Overflow.getAvailableIcons(alignment)
	local ourOrderedIcons = orderedAvailableIcons[alignment]
	if not ourOrderedIcons then
		ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	end
	return ourOrderedIcons
end

function Overflow.updateAvailableIcons(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon)
	local ourTotal = 0
	local ourOrderedIcons = {}
	for _, icon in pairs(iconsDict) do
		local parentUID = icon.parentIconUID
		local isDirectlyOnTopbar = not parentUID or overflowIconUIDs[parentUID]
		local isOverflow = overflowIconUIDs[icon.UID]
		if isDirectlyOnTopbar and icon.alignment == alignment and not isOverflow and icon.isEnabled then
			table.insert(ourOrderedIcons, icon)
			ourTotal += 1
		end
	end

	-- Ignore if no icons are available
	if ourTotal <= 0 then
		return {}
	end

	-- This sorts these icons by smallest order, or if equal, left-most position
	-- (even for the right alignment because all icons are sorted left-to-right)
	table.sort(ourOrderedIcons, function(iconA, iconB)
		local orderA = iconA.widget.LayoutOrder
		local orderB = iconB.widget.LayoutOrder
		local hasParentA = iconA.parentIconUID
		local hasParentB = iconB.parentIconUID
		if hasParentA == hasParentB then
			if orderA < orderB then
				return true
			end
			if orderA > orderB then
				return false
			end
			return iconA.widget.AbsolutePosition.X < iconB.widget.AbsolutePosition.X
		elseif hasParentB then
			return false
		elseif hasParentA then
			return true
		end
		return nil
	end)

	-- Finish up
	orderedAvailableIcons[alignment] = ourOrderedIcons
	return ourOrderedIcons

end

function Overflow.getRealXPositions(alignment, orderedIcons)
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local isLeft = alignment == "Left"
	local holder = holders[alignment]
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local holderUIList = holder.UIListLayout
	local topbarInset = holderUIList.Padding.Offset
	local absoluteX = (isLeft and holderXPos) or holderXPos + holderXSize
	local realXPositions = {}
	if isLeft then
		Utility.reverseTable(orderedIcons)
	end
	for i = #orderedIcons, 1, -1 do
		local icon = orderedIcons[i]
		local sizeX = Overflow.getWidth(icon)
		if not isLeft then
			absoluteX -= sizeX
		end
		realXPositions[icon.UID] = absoluteX
		if isLeft then
			absoluteX += sizeX
		end
		absoluteX += (isLeft and topbarInset) or -topbarInset
	end
	return realXPositions
end

function Overflow.updateBoundary(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon) or within an overflow
	local holder = holders[alignment]
	local holderUIList = holder.UIListLayout
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local topbarInset = holderUIList.Padding.Offset
	local topbarPadding = holderUIList.Padding.Offset
	local BOUNDARY_GAP = topbarInset
	local ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	local boundWidth = 0
	local ourTotal = 0
	for _, icon in pairs(ourOrderedIcons) do
		boundWidth += Overflow.getWidth(icon) + topbarPadding
		ourTotal += 1
	end
	if ourTotal <= 0 then
		return
	end
	
	-- These are the icons with menus which icons will be moved into
	-- when overflowing
	local isCentral = alignment == "Center"
	local isLeft = alignment == "Left"
	local isRight = not isLeft
	local overflowIcon = overflowIcons[alignment]
	if not overflowIcon and not isCentral and #ourOrderedIcons > 0 then
		local order = (isLeft and -9999999) or 9999999
		overflowIcon = Icon.new()--:setLabel(`{alignment}`)
		overflowIcon:setImage(6069276526, "Deselected")
		overflowIcon:setName("Overflow"..alignment)
		overflowIcon:setOrder(order)
		overflowIcon:setAlignment(alignment)
		overflowIcon:autoDeselect(false)
		overflowIcon.isAnOverflow = true
		--overflowIcon:freezeMenu()
		overflowIcon:select("OverflowStart", overflowIcon)
		overflowIcon:setEnabled(false)
		overflowIcons[alignment] = overflowIcon
		overflowIconUIDs[overflowIcon.UID] = true
		if not Icon.closeableOverflowMenus then
			local iconSpot = overflowIcon:getInstance("IconSpot")
			iconSpot.Visible = false
		end
	end

	-- The default boundary is the point where both the left-most-right-icon
	-- and left-most-right-icon meet OR the opposite side of the screen
	local oppositeAlignment = (alignment == "Left" and "Right") or "Left"
	local oppositeOrderedIcons = Overflow.updateAvailableIcons(oppositeAlignment)
	local nearestOppositeIcon = (isLeft and oppositeOrderedIcons[1]) or (isRight and oppositeOrderedIcons[#oppositeOrderedIcons])
	local oppositeOverflowIcon = overflowIcons[oppositeAlignment]
	local boundary = (isLeft and holderXPos + holderXSize) or holderXPos
	if nearestOppositeIcon then
		local oppositeRealXPositions = Overflow.getRealXPositions(oppositeAlignment, oppositeOrderedIcons)
		local oppositeX = oppositeRealXPositions[nearestOppositeIcon.UID]
		local oppositeXSize = Overflow.getWidth(nearestOppositeIcon)
		boundary = (isLeft and oppositeX - BOUNDARY_GAP) or oppositeX + oppositeXSize + BOUNDARY_GAP
	end
	
	-- We get the left-most icon (if left alignment) or right-most-icon (if
	-- right alignment) of the central icons group to see if we need to change
	-- the boundary (if the central icon boundary is smaller than the alignment
	-- boundary then we use the central)
	local totalChecks = 0
	local usingNearestCenter = false
	local function checkToShiftCentralIcon()
		local centerOrderedIcons = Overflow.getAvailableIcons("Center")
		local centerPos = (isLeft and 1) or #centerOrderedIcons
		local nearestCenterIcon = centerOrderedIcons[centerPos]
		local function secondaryCheck()
			if not beganSecondaryCenterCheck then
				beganSecondaryCenterCheck = true
				task.delay(3, Overflow.updateBoundary, alignment)
			end
		end
		if nearestCenterIcon and not nearestCenterIcon.hasRelocatedInOverflow then
			local ourNearestIcon = (isLeft and ourOrderedIcons[#ourOrderedIcons]) or (isRight and ourOrderedIcons[1])
			local centralNearestXPos = nearestCenterIcon.widget.AbsolutePosition.X
			local ourNearestXPos = ourNearestIcon.widget.AbsolutePosition.X
			local ourNearestXSize = Overflow.getWidth(ourNearestIcon)
			local centerBoundary = (isLeft and centralNearestXPos-BOUNDARY_GAP) or centralNearestXPos + Overflow.getWidth(nearestCenterIcon) + BOUNDARY_GAP
			local removeBoundary = (isLeft and ourNearestXPos + ourNearestXSize) or ourNearestXPos
			local hasShifted = false
			if isLeft then
				if centerBoundary < removeBoundary then
					if not beginCheckingCenterIcons then
						secondaryCheck()
						return
					end
					nearestCenterIcon:align("Left")
					nearestCenterIcon.hasRelocatedInOverflow = true
					hasShifted = true
				end
			elseif isRight then
				if centerBoundary > removeBoundary then
					if not beginCheckingCenterIcons or removeBoundary < 0 then
						secondaryCheck()
						return
					end
					nearestCenterIcon:align("Right")
					nearestCenterIcon.hasRelocatedInOverflow = true
					hasShifted = true
				end
			end
			if hasShifted then
				totalChecks += 1
				if totalChecks <= 4 then
					Overflow.updateAvailableIcons("Center")
					checkToShiftCentralIcon()
				end
			end
		end
	end
	checkToShiftCentralIcon()
	
	--[[
	This updates the maximum size of the overflow menus
	The menu determines its bounds from the smallest of either:
	 	1. The closest center-aligned icon (i.e. the boundary)
	 	2. The edge of the opposite overflow menu UNLESS...
	 	3. ... the edge exceeds more than half the screenGui
	--]]
	if overflowIcon then
		local menuBoundary = boundary
		local menu = overflowIcon:getInstance("Menu")
		local holderXEndPos = holderXPos + holderXSize
		local menuWidth = holderXSize
		if menu and oppositeOverflowIcon then
			local oppositeWidget = oppositeOverflowIcon.widget
			local oppositeXPos = oppositeWidget.AbsolutePosition.X
			local oppositeXSize = Overflow.getWidth(oppositeOverflowIcon)
			local oppositeBoundary = (isLeft and oppositeXPos - BOUNDARY_GAP) or oppositeXPos + oppositeXSize + BOUNDARY_GAP
			local oppositeMenu = oppositeOverflowIcon:getInstance("Menu")
			local isDominant = menu.AbsoluteCanvasSize.X >= oppositeMenu.AbsoluteCanvasSize.X
			if not usingNearestCenter then
				local halfwayXPos = holderXPos + holderXSize/2
				local halfwayBoundary = (isLeft and halfwayXPos - BOUNDARY_GAP/2) or halfwayXPos + BOUNDARY_GAP/2
				menuBoundary = halfwayBoundary
				if isDominant then
					menuBoundary = oppositeBoundary
				end
			end
			menuWidth = (isLeft and menuBoundary - holderXPos) or (holderXEndPos - menuBoundary)
		end
		local currentMaxWidth = menu and menu:GetAttribute("MaxWidth")
		menuWidth = Utility.round(menuWidth)
		if menu and currentMaxWidth ~= menuWidth then
			menu:SetAttribute("MaxWidth", menuWidth)
		end
	end

	-- Parent ALL icons of that alignment into the overflow if at least on
	-- sibling exceeds the bounds.
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local joinOverflow = false
	local realXPositions = Overflow.getRealXPositions(alignment, ourOrderedIcons)
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local widgetX = Overflow.getWidth(icon)
		local xPos = realXPositions[icon.UID]
		if (isLeft and xPos + widgetX >= boundary) or (isRight and xPos <= boundary) then
			joinOverflow = true
		end
	end
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local isOverflow = overflowIconUIDs[icon.UID]
		if not isOverflow then
			if joinOverflow and not icon.parentIconUID then
				icon:joinMenu(overflowIcon)
			elseif not joinOverflow and icon.parentIconUID then
				icon:leave()
			end
		end
	end
	
	-- Hide the overflows when not in use
	if overflowIcon.isEnabled ~= joinOverflow then
		overflowIcon:setEnabled(joinOverflow)
	end
	
	-- Have the menus auto selected
	if overflowIcon.isEnabled and not overflowIcon.overflowAlreadyOpened then
		overflowIcon.overflowAlreadyOpened = true
		overflowIcon:select()
	end

end



return Overflow]]></ProtectedString>
								<string name="ScriptGuid">{8DEDD4AD-0D55-46BF-874C-937315B2FF8F}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Overflow.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX26482A071CE541E8AE22AFC7090A6DB3">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- The functions here are dedicated solely to managing theme state
-- and updating the appearance of instances to match that state.
-- You don't need to use any of these functions, the useful ones
-- have been abstracted as icon methods



-- LOCAL
local Themes = {}
local Utility = require(script.Parent.Parent.Utility)
local baseTheme = require(script.Default)



-- FUNCTIONS
function Themes.getThemeValue(stateGroup, instanceName, property, iconState)
	if stateGroup then
		for _, detail in pairs(stateGroup) do
			local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
			if instanceName == checkingInstanceName and property == checkingPropertyName then
				return checkingValue
			end
		end
	end
	return nil
end

function Themes.getInstanceValue(instance, property)
	local success, value = pcall(function()
		return instance[property]
	end)
	if not success then
		value = instance:GetAttribute(property)
	end
	return value
end

function Themes.getRealInstance(instance)
	if not instance:GetAttribute("IsAClippedClone") then
		return
	end
	local originalInstance = instance:FindFirstChild("OriginalInstance")
	if not originalInstance then
		return
	end
	return originalInstance.Value
end

function Themes.getClippedClone(instance)
	if not instance:GetAttribute("HasAClippedClone") then
		return
	end
	local clippedClone = instance:FindFirstChild("ClippedClone")
	if not clippedClone then
		return
	end
	return clippedClone.Value
end

function Themes.refresh(icon, instance, specificProperty)
	-- Some instances such as notices need immediate refreshing upon creation as
	-- they're added in after the initial refresh period
	if specificProperty then
		local stateGroup = icon:getStateGroup()
		local value = Themes.getThemeValue(stateGroup, instance.Name, specificProperty) or Themes.getInstanceValue(instance, specificProperty)
		Themes.apply(icon, instance, specificProperty, value, true)
		return
	end
	-- If no property is specified we update all properties that exist within
	-- the applied theme appearance
	local stateGroup = icon:getStateGroup()
	if not stateGroup then
		return
	end
	local validInstances = {[instance.Name] = instance}
	for _, child in pairs(instance:GetDescendants()) do
		local collective = child:GetAttribute("Collective")
		if collective then
			validInstances[collective] = child
		end
		validInstances[child.Name] = child
	end
	for _, detail in pairs(stateGroup) do
		local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
		local instanceToUpdate = validInstances[checkingInstanceName]
		if instanceToUpdate then
			Themes.apply(icon, instanceToUpdate.Name, checkingPropertyName, checkingValue, true)
		end
	end
	return
end

function Themes.apply(icon, collectiveOrInstanceNameOrInstance, property, value, forceApply)
	-- This is responsible for **applying** appearance changes to instances within the icon
	-- however it IS NOT responsible for updating themes. Use :modifyTheme for that.
	-- This also calls callbacks given by :setBehaviour before applying these property changes
	-- to the given instances
	if icon.isDestroyed then
		return
	end
	local instances
	local collectiveOrInstanceName = collectiveOrInstanceNameOrInstance
	if typeof(collectiveOrInstanceNameOrInstance) == "Instance" then
		instances = {collectiveOrInstanceNameOrInstance}
		collectiveOrInstanceName = collectiveOrInstanceNameOrInstance.Name
	else
		instances = icon:getInstanceOrCollective(collectiveOrInstanceNameOrInstance)
	end
	local key = collectiveOrInstanceName.."-"..property
	local customBehaviour = icon.customBehaviours[key]
	for _, instance in pairs(instances) do
		local clippedClone = Themes.getClippedClone(instance)
		if clippedClone then
			-- This means theme effects are applied to both the original
			-- instance and its clone (instead of just the instance).
			-- This is important for some properties such as position
			-- and size which might be dictated by the clone
			table.insert(instances, clippedClone)
		end
	end
	for _, instance in pairs(instances) do
		if property == "Position" and Themes.getClippedClone(instance) then
			-- The clone manages the position of the real instance so ignore
			continue
		elseif property == "Size" and Themes.getRealInstance(instance) then
			-- The real instance manages the size of the clone so ignore
			continue
		end
		local currentValue = Themes.getInstanceValue(instance, property)
		if not forceApply and value == currentValue then
			continue
		end
		if customBehaviour then
			local newValue = customBehaviour(value, instance, property)
			if newValue ~= nil then
				value = newValue
			end
		end
		local success = pcall(function()
			instance[property] = value
		end)
		if not success then
			-- If property is not a real property, we set
			-- the value as an attribute instead. This is useful
			-- for instance in :setWidth where we also want to
			-- specify a desired width for every state which can
			-- then be easily read by the widget element
			instance:SetAttribute(property, value)
		end
	end
end

function Themes.getModifications(modifications)
	if typeof(modifications[1]) ~= "table" then
		-- This enables users to do :modifyTheme({a,b,c,d})
		-- in addition of :modifyTheme({{a,b,c,d}})
		modifications = {modifications}
	end
	return modifications
end

function Themes.merge(detail, modification, callback)
	local instanceName, property, value, stateName = table.unpack(modification)
	local checkingInstanceName, checkingPropertyName, _, checkingStateName = table.unpack(detail)
	if instanceName == checkingInstanceName and property == checkingPropertyName and Themes.statesMatch(stateName, checkingStateName) then
		detail[3] = value
		if callback then
			callback(detail)
		end
		return true
	end
	return false
end

function Themes.modify(icon, modifications, modificationsUID)
	-- This is what the 'old set' used to do (although for clarity that behaviour has now been
	-- split into two methods, .modifyTheme and .apply).
	-- modifyTheme is responsible for UPDATING the internal values within a theme for a particular
	-- state, then checking to see if the appearance of the icon needs to be updated.
	-- If no iconState is specified, the change is applied to both Deselected and Selected
	-- A modification can also be 'undone' using :removeModification and passing in
	-- the UID returned from this method
	task.spawn(function()
		modificationsUID = modificationsUID or Utility.generateUID()
		modifications = Themes.getModifications(modifications)
		for _, modification in pairs(modifications) do
			local instanceName, property, value, iconState = table.unpack(modification)
			if iconState == nil then
				-- If no state specified, apply to all states
				Themes.modify(icon, {instanceName, property, value, "Selected"}, modificationsUID)
				Themes.modify(icon, {instanceName, property, value, "Viewing"}, modificationsUID)
			end
			local chosenState = Utility.formatStateName(iconState or "Deselected")
			local stateGroup = icon:getStateGroup(chosenState)
			local function nowSetIt()
				if chosenState == icon.activeState then
					Themes.apply(icon, instanceName, property, value)
				end
			end
			local function updateRecord()
				for stateName, detail in pairs(stateGroup) do
					local didMerge = Themes.merge(detail, modification, function(detail)
						detail[5] = modificationsUID
						nowSetIt()
					end)
					if didMerge then
						return
					end
				end
				local detail = {instanceName, property, value, chosenState, modificationsUID}
				table.insert(stateGroup, detail)
				nowSetIt()
			end
			updateRecord()
		end
	end)
	return modificationsUID
end

function Themes.remove(icon, modificationsUID)
	for iconState, stateGroup in pairs(icon.appearance) do
		for i = #stateGroup, 1, -1 do
			local detail = stateGroup[i]
			local checkingUID = detail[5]
			if checkingUID == modificationsUID then
				table.remove(stateGroup, i)
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.removeWith(icon, instanceName, property, state)
	for iconState, stateGroup in pairs(icon.appearance) do
		if state == iconState or not state then
			for i = #stateGroup, 1, -1 do
				local detail = stateGroup[i]
				local detailName = detail[1]
				local detailProperty = detail[2]
				if detailName == instanceName and detailProperty == property then
					table.remove(stateGroup, i)
				end
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.change(icon)
	-- This changes the theme to the appearance of whatever
	-- state is currently active
	local stateGroup = icon:getStateGroup()
	for _, detail in pairs(stateGroup) do
		local instanceName, property, value = unpack(detail)
		Themes.apply(icon, instanceName, property, value)
	end
end

function Themes.set(icon, theme)
	-- This is responsible for processing the final appearance of a given theme (such as
	-- ensuring Deselected merge into missing Selected, saving that internal state,
	-- then checking to see if the appearance of the icon needs to be updated
	local themesJanitor = icon.themesJanitor
	themesJanitor:clean()
	themesJanitor:add(icon.stateChanged:Connect(function()
		Themes.change(icon)
	end))
	if typeof(theme) == "Instance" and theme:IsA("ModuleScript") then
		theme = require(theme)
	end
	icon.appliedTheme = theme
	Themes.rebuild(icon)
end

function Themes.statesMatch(state1, state2)
	-- States match if they have the same name OR if nil (because unspecified represents all states)
	local state1lower = (state1 and string.lower(state1))
	local state2lower = (state2 and string.lower(state2))
	return state1lower == state2lower or not state1 or not state2
end

function Themes.rebuild(icon)
	-- A note for my future self: this code can be optimised further by
	-- converting appearance into a instanceName-property dictionary
	-- as apposed to an array of every potential change. When converting
	-- in the future, .modify and .apply would also have to be updated.
	local appliedTheme = icon.appliedTheme
	local statesArray = {"Deselected", "Selected", "Viewing"}
	local function generateTheme()
		for _, stateName in pairs(statesArray) do
			-- This applies themes in layers
			-- The last layers take higher priority as they overwrite
			-- any duplicate earlier applied effects
			local stateAppearance = {}
			local function updateDetails(theme, incomingStateName)
				-- This ensures there's always a base 'default' layer
				if not theme then
					return
				end
				for _, detail in pairs(theme) do
					local modificationsUID = detail[5]
					local detailStateName = detail[4]
					if Themes.statesMatch(incomingStateName, detailStateName) then
						local key = detail[1].."-"..detail[2]
						local newDetail = Utility.copyTable(detail)
						newDetail[5] = modificationsUID
						stateAppearance[key] = newDetail
					end
				end
			end
			-- First we apply the base theme (i.e. the Default module)
			if stateName == "Selected" then
				updateDetails(baseTheme, "Deselected")
			end
			updateDetails(baseTheme, "Empty")
			updateDetails(baseTheme, stateName)
			-- Next we apply any custom themes by the games developer
			if appliedTheme ~= baseTheme then
				if stateName == "Selected" then
					updateDetails(appliedTheme, "Deselected")
				end
				updateDetails(baseTheme, "Empty")
				updateDetails(appliedTheme, stateName)
			end
			-- Finally we apply any modifications that have already been made
			-- Modifiers are all the changes made using icon:modifyTheme(...)
			local alreadyAppliedTheme = {}
			local alreadyAppliedGroup = icon.appearance[stateName]
			if alreadyAppliedGroup then
				for _, modifier in pairs(alreadyAppliedGroup) do
					local modificationsUID = modifier[5]
					if modificationsUID ~= nil then
						local modification = {modifier[1], modifier[2], modifier[3], stateName, modificationsUID}
						table.insert(alreadyAppliedTheme, modification)
					end
				end
			end
			updateDetails(alreadyAppliedTheme, stateName)
			-- This now converts it into our final appearance
			local finalStateAppearance = {}
			for _, detail in pairs(stateAppearance) do
				table.insert(finalStateAppearance, detail)
			end
			icon.appearance[stateName] = finalStateAppearance
		end
		Themes.change(icon)
	end
	generateTheme()
end



return Themes]]></ProtectedString>
								<string name="ScriptGuid">{504B37B6-884A-4872-AB5F-A715EB2C92D6}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Themes.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX9B63A0E647694B5DBFE915BEC535FA6C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Themes</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX10D5B4470B454FC987AC69604C1A0ED2">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[-- This is to provide backwards compatability with the old Roblox
-- topbar while experiences transition over to the new topbar
-- You don't need to apply this yourself, topbarplus automatically
-- applies it if the old roblox topbar is detected


return {
	{"Selection", "Size", UDim2.new(1, -6, 1, -5)},
	{"Selection", "Position", UDim2.new(0, 3, 0, 3)},
	
	{"Widget", "MinimumWidth", 32, "Deselected"},
	{"Widget", "MinimumHeight", 32, "Deselected"},
	{"Widget", "BorderSize", 0, "Deselected"},
	{"IconCorners", "CornerRadius", UDim.new(0, 9), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.5, "Deselected"},
	{"IconLabel", "TextSize", 14, "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.5, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -3), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 15, 0, 15), "Deselected"},
	{"NoticeLabel", "TextSize", 11, "Deselected"},
	
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Selected"},
	{"IconSpot", "BackgroundTransparency", 0.702, "Selected"},
	{"IconSpotGradient", "Enabled", false, "Selected"},
	{"IconOverlay", "BackgroundTransparency", 0.97, "Selected"},
	
}]]></ProtectedString>
									<string name="ScriptGuid">{6DC1A723-7439-4015-AF5A-4ADE52F6B844}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Classic.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX52C2DCD69FA34FD092F8885FF7011499">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[-- Themes in v3 work simply by applying the value (agument[3])
-- to the property (agument[2]) of an instance within the icon which
-- matches the name of argument[1]. Argument[1] can also be used to
-- specify a collection of instances with a corresponding 'collective'
-- value. A colletive is simply an attribute applied to some instances
-- within the icon to group them together (such as "IconCorners").
-- If the property (argument[2]) does not exist within the instance,
-- it will instead be applied as an attribute on the instance:
-- (i.e. ``instance:SetAttribute(argument[2], [argument[3])``)
-- Use argument[4] to specify a state: "Deselected", "Selected"
-- or "Viewing". If argument[4] is empty the state will default
-- to "Deselected".
-- I've designed themes this way so you have full control over
-- the appearance of the widget and its descendants


return {
	
	-- When no state is specified the modification is applied to *all* states (Deselected, Selected and Viewing)
	{"IconCorners", "CornerRadius", UDim.new(1, 0)},
	{"Selection", "RotationSpeed", 1},
	{"Selection", "Size", UDim2.new(1, 0, 1, 1)},
	{"Selection", "Position", UDim2.new(0, 0, 0, 0)},
	{"SelectionGradient", "Color", ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(86, 86, 86)),
	})},
	
	-- When the icon is deselected
	{"IconImage", "Image", "", "Deselected"},
	{"IconLabel", "Text", "", "Deselected"},
	{"IconLabel", "Position", UDim2.fromOffset(0, 0), "Deselected"}, -- 0, -1
	{"Widget", "DesiredWidth", 44, "Deselected"},
	{"Widget", "MinimumWidth", 44, "Deselected"},
	{"Widget", "MinimumHeight", 44, "Deselected"},
	{"Widget", "BorderSize", 4, "Deselected"},
  	{"IconButton", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.08, "Deselected"},
	{"IconImageScale", "Value", 0.5, "Deselected"},
	{"IconImageCorner", "CornerRadius", UDim.new(0, 0), "Deselected"},
	{"IconImage", "ImageColor3", Color3.fromRGB(255, 255, 255), "Deselected"},
	{"IconImage", "ImageTransparency", 0, "Deselected"},
	{"IconImageRatio", "AspectRatio", 1, "Deselected"},
	{"IconLabel", "FontFace", Font.new("rbxasset://fonts/families/BuilderSans.json", Enum.FontWeight.Bold, Enum.FontStyle.Normal), "Deselected"},
	{"IconLabel", "TextSize", 16, "Deselected"},
	{"IconSpot", "BackgroundTransparency", 1, "Deselected"},
	{"IconOverlay", "BackgroundTransparency", 0.85, "Deselected"},
	{"IconSpotGradient", "Enabled", false, "Deselected"},
	{"IconGradient", "Enabled", false, "Deselected"},
	{"ClickRegion", "Active", true, "Deselected"},  -- This is set to false within scrollers to ensure scroller can be dragged on mobile
	{"Menu", "Active", false, "Deselected"},
	{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Center, "Deselected"},
  	{"Dropdown", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.08, "Deselected"},
	{"Dropdown", "MaxIcons", 4.5, "Deselected"},
	{"Menu", "MaxIcons", 4, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -1), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 20, 0, 20), "Deselected"},
	{"NoticeLabel", "TextSize", 13, "Deselected"},
	{"PaddingLeft", "Size", UDim2.new(0, 9, 1, 0), "Deselected"},
	{"PaddingRight", "Size", UDim2.new(0, 11, 1, 0), "Deselected"},
	
	-- When the icon is selected
	-- Selected also inherits everything from Deselected if nothing is set
	{"IconSpot", "BackgroundTransparency", 0.7, "Selected"},
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(255, 255, 255), "Selected"},
	{"IconSpotGradient", "Enabled", true, "Selected"},
	{"IconSpotGradient", "Rotation", 45, "Selected"},
	{"IconSpotGradient", "Color", ColorSequence.new(Color3.fromRGB(96, 98, 100), Color3.fromRGB(77, 78, 80)), "Selected"},
	
	
	-- When a cursor is hovering above, a controller highlighting, or touchpad (mobile) pressing (but not released)
	--{"IconSpot", "BackgroundTransparency", 0.75, "Viewing"},
	
}]]></ProtectedString>
									<string name="ScriptGuid">{46394F6F-14E6-4B8F-820C-97E0B28D6FF3}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Default.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX91AFFED531DC4C6288C2BD128819D8B6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Packages</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX9BAA435E9EDF408B9BA6C4BA532FCB7A">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread()
	-- Note: We cannot use the initial set of arguments passed to
	-- runEventHandlerInFreeThread for a call to the handler, because those
	-- arguments would stay on the stack for the duration of the thread's
	-- existence, temporarily leaking references. Without access to raw bytecode
	-- there's no way for us to clear the "..." references from the stack.
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end
Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		_handlerListHead = false,
	}, Signal)
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false
end
Signal.Destroy = Signal.DisconnectAll

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
				-- Get the freeRunnerThread to the first yield
				coroutine.resume(freeRunnerThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

-- Implement Signal:Once() in terms of a connection which disconnects
-- itself before running the handler.
function Signal:Once(fn)
	local cn;
	cn = self:Connect(function(...)
		if cn._connected then
			cn:Disconnect()
		end
		fn(...)
	end)
	return cn
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

return Signal]]></ProtectedString>
								<string name="ScriptGuid">{174596F1-3C48-45FC-91D2-A22A6EB0E1BE}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">GoodSignal.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX15C7EACB0DB3487F972FB98EA38D35AE">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[[
-------------------------------------
This package was modified by ForeverHD.

PACKAGE MODIFICATIONS:
	1. Added pascalCase aliases for all methods
	2. Modified behaviour of :add so that it takes both objects and promises (previously only objects)
	3. Slight change to how promises are tracked
	4. Added isAnInstanceBeingDestroyed check to line 228
	5. Added 'OriginalTraceback' to help determine where an error was added to the janitor
	6. Likely some additional changes which weren't record here
	7. Removed comments as these were detected by Moonwave
-------------------------------------
--]]



-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local function getPromiseReference()
	return false
end

local IndicesReference = newproxy(true)
getmetatable(IndicesReference).__tostring = function()
	return "IndicesReference"
end

local LinkToInstanceIndex = newproxy(true)
getmetatable(LinkToInstanceIndex).__tostring = function()
	return "LinkToInstanceIndex"
end

local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

local Janitor = {
	IGNORE_MEMORY_DEBUG = true,
	ClassName = "Janitor";
	__index = {
		CurrentlyCleaning = true;
		[IndicesReference] = nil;
	};
}

local TypeDefaults = {
	["function"] = true;
	["Promise"] = "cancel";
	RBXScriptConnection = "Disconnect";
}

function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

Janitor.is = Janitor.Is

function Janitor.__index:Add(Object, MethodName, Index)
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	local objectType = typeof(Object)
	if objectType == "table" and string.match(tostring(Object), "Promise") then
		objectType = "Promise"
		--local status = Object:getStatus()
		--print("status =", status, status == "Rejected")
	end
	MethodName = MethodName or TypeDefaults[objectType] or "Destroy"
	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil :: any, 2)))
	end

	local OriginalTraceback = debug.traceback("")
	self[Object] = {MethodName, OriginalTraceback}
	return Object
end
Janitor.__index.Give = Janitor.__index.Add

-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

function Janitor.__index:AddPromise(PromiseObject)
	local Promise = getPromiseReference()
	if Promise then
		if not Promise.is(PromiseObject) then
			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
		end
		if PromiseObject:getStatus() == Promise.Status.Started then
			local Id = newproxy(false)
			local NewPromise = self:Add(Promise.new(function(Resolve, _, OnCancel)
				if OnCancel(function()
						PromiseObject:cancel()
					end) then
					return
				end

				Resolve(PromiseObject)
			end), "cancel", Id)

			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise
		else
			return PromiseObject
		end
	else
		return PromiseObject
	end
end
Janitor.__index.GivePromise = Janitor.__index.AddPromise

-- This will assume whether or not the object is a Promise or a regular object.
function Janitor.__index:AddObject(Object)
	local Id = newproxy(false)
	local Promise = getPromiseReference()
	if Promise and Promise.is(Object) then
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	else
		return self:Add(Object, false, Id), Id
	end
end

Janitor.__index.GiveObject = Janitor.__index.AddObject

function Janitor.__index:Remove(Index)
	local This = self[IndicesReference]
	if This then
		local Object = This[Index]

		if Object then
			local ObjectDetail = self[Object]
			local MethodName = ObjectDetail and ObjectDetail[1]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

function Janitor.__index:Get(Index)
	local This = self[IndicesReference]
	if This then
		return This[Index]
	end
	return nil
end

function Janitor.__index:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil
		for Object, ObjectDetail in next, self do
			if Object == IndicesReference then
				continue
			end

			-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
			local TypeOf = type(Object)
			if TypeOf == "string" or TypeOf == "number" then
				self[Object] = nil
				continue
			end

			local MethodName = ObjectDetail[1]
			local OriginalTraceback = ObjectDetail[2]
			local function warnUser(warning)
				local cleanupLine = debug.traceback("", 3)--string.gsub(debug.traceback("", 3), "%c", "")
				local addedLine = OriginalTraceback
				warn("-------- Janitor Error --------".."\n"..tostring(warning).."\n"..cleanupLine..""..addedLine)
			end
			if MethodName == true then
				local success, warning = pcall(Object)
				if not success then
					warnUser(warning)
				end
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					local success, warning = pcall(ObjectMethod, Object)
					local isAnInstanceBeingDestroyed = typeof(Object) == "Instance" and ObjectMethod == "Destroy"
					if not success and not isAnInstanceBeingDestroyed then
						warnUser(warning)
					end
				end
			end

			self[Object] = nil
		end

		local This = self[IndicesReference]
		if This then
			for Index in next, This do
				This[Index] = nil
			end

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

Janitor.__index.Clean = Janitor.__index.Cleanup

function Janitor.__index:Destroy()
	self:Cleanup()
	--table.clear(self)
	--setmetatable(self, nil)
end

Janitor.__call = Janitor.__index.Cleanup

local Disconnect = {Connected = true}
Disconnect.__index = Disconnect
function Disconnect:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function Disconnect:__tostring()
	return "Disconnect<" .. tostring(self.Connected) .. ">"
end

function Janitor.__index:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, Disconnect)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				coroutine.wrap(function()
					Heartbeat:Wait()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							Heartbeat:Wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)()
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

function Janitor.__index:LinkToInstances(...)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

for FunctionName, Function in next, Janitor.__index do
	local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
	Janitor.__index[NewFunctionName] = Function
end

return Janitor]]></ProtectedString>
								<string name="ScriptGuid">{B0A8A9EB-5AC9-4124-AC5E-F57F942393D5}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Janitor.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX014CA04BF9954C78B69267DCBB16130B">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ServerScriptService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX8E2727C668824B39AD2DFBB547490048">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Core</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX05EB3043A9E54111B5985B2D421AA77D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Player</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX60F6204C812F4E2098CB194238A6913D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Player/Combination_Handle.server.lua
--
--  Description:
--      Handles player customization of strike combos, submissions,
--      takedowns, equipped clothing, emote slots, and avatar settings.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Animation_Mod
--          * Data_Mods_F/Clothing_Mod
--          * Data_Mods_F/Skin_Tone_Mod
--          * Data_Mods_F/Country_Mod
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Bindable_F/RF
--          * Channels_F/Client_Server_F/RF
--          * Channels_F/Client_Server_F/Events
--      - Roblox Services:
--          * TextService (for safe text filtering)
--      - Player Instances:
--          * Player.Player_Data.Strike Combo (1–3)
--          * Player.Player_Data.Submission Key
--          * Player.Player_Data.Takedown Key
--          * Player.Player_Data.Current Gloves
--          * Player.Player_Data.Current Shorts
--
--  Notes:
--      - Validates ownership before assigning animations or clothing
--      - Updates player strike combos dynamically
--      - Supports equipping gloves/shorts via Clothing_Mod
--      - Handles emote slot assignment and filtering of text
--
--======================================================================

-- Services
local TextService 				= game:GetService("TextService")

-- Modules
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod 			= require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Clothing_Mod 				= require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Skin_Mod 					= require(Data_Mods_F:WaitForChild("Skin_Tone_Mod"))
local Country_Mod 				= require(Data_Mods_F:WaitForChild("Country_Mod"))
local PlayerUtils 				= require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels 					= require(game.ReplicatedStorage.Modules.Channels)
local Combo_Action_Request 		= Channels.CS_Remote_Functions.Combo_Action_Request
local Avatar_Clothing_Request 	= Channels.CS_Remote_Functions.Avatar_Clothing_Request
local Emote_Slot_Request 		= Channels.CS_Remote_Functions.Emote_Slot_Request
local Reset_Sequence 			= Channels.CS_Remote_Events.Reset_Sequence
local Save_Appearance 			= Channels.CS_Remote_Events.Save_Appearance

local Get_Player_Val 			= PlayerUtils.GetPlayerVal

local function getFilterResult(text, fromUserId)
	local filterResult
	local success, errorMessage = pcall(function()
		filterResult = TextService:FilterStringAsync(text, fromUserId)
	end)

	if success then
		local success2, filteredText = pcall(function()
			return filterResult:GetNonChatStringForBroadcastAsync()
		end)

		if success2 then
			return filteredText
		else
			warn("Error filtering text")
			return false
		end
	else
		warn("Error generating TextFilterResult:", errorMessage)
		return false
	end
end

Combo_Action_Request.OnServerInvoke = function(Plr, Entry, Index, Action_Type, Action) --Combo_Name, Strike, Action)
	local PD = Plr:WaitForChild("Player_Data")
	if Entry ~=nil and Index ~= nil then
		local check_if_own = Animation_Mod.Player_Owns_Strike_Key(Plr, Action)
		if (check_if_own == true) then -- free
			local Combo_Value = PD:FindFirstChild(Entry)

			if Combo_Value ~= nil then
				local Combo_List = Combo_Value.Value:split(",")
				Combo_List[Index] = Action 	
				Combo_Value.Value = table.concat(Combo_List, ",")
				return true
			end
		end
	elseif Entry ~=nil then	
		if Animation_Mod.Player_Owns_Action(Plr, Action_Type, Action) then 
			local Entry_Value = PD:FindFirstChild(Entry)
			Entry_Value.Value = Action
			return true
		end
	end

	return false
end

Avatar_Clothing_Request.OnServerInvoke = function(Plr, Equipment_Type, Key) -- plr,(glove/shorts),key
	if (Equipment_Type ~= nil) then
		if (Equipment_Type == "Gloves") then
			--// check if own
			local check_if_own = Clothing_Mod.Player_Owns_Gloves_Key(Plr, Key)
			local CurrentGlov = Get_Player_Val(Plr, "Current Gloves")
			if (check_if_own == true and CurrentGlov and CurrentGlov.Value ~= Key) then
				CurrentGlov.Value = Key
				return true
			end

		elseif (Equipment_Type == "Shorts") then

			local check_if_own = Clothing_Mod.Player_Owns_Shorts_Key(Plr, Key)
			local Current_Shorts = Get_Player_Val(Plr, "Current Shorts")
			if (check_if_own == true and Current_Shorts and Current_Shorts.Value ~= Key) then
				Current_Shorts.Value = Key
				return true
			end

		end
	end

	return false
end

Emote_Slot_Request.OnServerInvoke = function(Plr, Slot_Number, Key)
	--// Verify Players own the emote 
	--// If Player owns emote then replace the emote slot with the new emote.
	if (Slot_Number ~= nil and Key ~= nil) then
		local check_if_own = Animation_Mod.Player_Owns_Emote_Key(Plr, Key)
		if (check_if_own == true) then
			local PD = Plr:WaitForChild("Player_Data")
			local Emote_Slot = PD:FindFirstChild("Current Emotes")
			local EmotesSelected = Emote_Slot.Value:split(",")
			if (Emote_Slot ~= nil) then
				EmotesSelected[tonumber(Slot_Number:match("%d+"))] = Key
				Emote_Slot.Value = table.concat(EmotesSelected, ",")
				return true
			end
		end
	end

	return false
end

Reset_Sequence.OnServerEvent:Connect(function(Plr, Entry, Default_Value)
	local PD = Plr:WaitForChild("Player_Data")
	if(Entry ~= nil) then
		local Entry_Value = PD:FindFirstChild(Entry)
		if (Entry_Value) then
			Entry_Value.Value = Default_Value
		end
	end
end)


Save_Appearance.OnServerEvent:Connect(function(Plr, bio, country, skin, body_type)
	if(Plr ~= nil)then
		local PD = Plr:WaitForChild("Player_Data")
		if (PD ~= nil) then
			--if isMale == nil then
			if (getFilterResult(bio, Plr.UserId)) then
				PD:FindFirstChild("Bio").Value = getFilterResult(bio, Plr.UserId)
			end
			if Country_Mod.Get_Country_Data()[country] then
				PD:FindFirstChild("Country").Value = country
			end
			if (Skin_Mod.Get_Skin_Tone_Data()[skin]) then
				local color = Skin_Mod.Get_Skin_Tone_Data()[skin]
				local R,G,B 
				R = math.round(color.R * 255)
				G = math.round(color.G * 255)
				B = math.round(color.B * 255)
				PD:FindFirstChild("Skin Tone").Value = R .. "," .. G .. "," .. B
			end
			if body_type == "Male" or body_type == "Female" then
				if PD:FindFirstChild("Body Type").Value ~= body_type then
					PD:FindFirstChild("Body Type").Value = body_type
				end
			end
		end
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{6849E9BD-29E0-4F52-AAD1-96EADB0DBE52}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Combination_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB22EF4AB7E504EF5B70318D2C9E2891E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Player/Badge_Attribute_Handle.server.lua
--
--  Description:
--      Handles badge checks, awards, and group membership attributes.
--      Provides Bindable and RemoteFunction interfaces for verifying and
--      awarding badges, and checking player group membership.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Bindable_F/RF
--          * Channels_F/Client_Server_F/RF
--      - Roblox Services:
--          * BadgeService
--          * Players
--
--  Notes:
--      - Uses UserHasBadgeAsync and AwardBadge with retry (3 attempts)
--      - Checks player membership in Group_ID = 35784641
--      - Sets Player attribute "In_Group" accordingly
--      - Exposes:
--          * RF: Player_In_Group, Player_Owns_Badge
--          * BindableEvent: Award_Badge
--
--======================================================================

-- Services
local BS = game:GetService("BadgeService")

-- Modules
local Utils = require(game.ReplicatedStorage.Modules.Utils)

-- Events
local Channels 					= require(game.ReplicatedStorage.Modules.Channels)

local Player_In_Group_RF 		= Channels.Bindable_Functions.Player_In_Group
local Player_In_Group_CS_RF 	= Channels.CS_Remote_Functions.Player_In_Group
local Player_Owns_Badge_RF 		= Channels.Bindable_Functions.Player_Owns_Badge
local Player_Owns_Badge_CS_RF 	= Channels.CS_Remote_Functions.Player_Owns_Badge

local Award_Badge				= Channels.Bindable_Events.Award_Badge

local function Player_Owns_Badge(Plr, Badge_ID)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = BS:UserHasBadgeAsync(Plr.UserId, Badge_ID)
		end)
		
		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end
	
	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end
	
	return false
end

local function Award_Badge_Handle(Plr, Badge_ID)
	if(Player_Owns_Badge(Plr, Badge_ID) == false)then
		local function Async()
			local success, errormessage = pcall(function()
				BS:AwardBadge(Plr.UserId, Badge_ID)
			end)
			
			if(success)then
				return true
			end
			return false
		end
		
		for i = 1, 3 do
			local D = Async()
			if(D)then
				return
			end
		end
	end
end

local function Is_Player_In_Group(Plr)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			local Group_ID = Utils.getGroupId()
			Data = Plr:IsInGroup(Group_ID)
		end)

		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end

	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end
	return false
end


Player_In_Group_RF.OnInvoke = function(Plr)
	local In_Group = Is_Player_In_Group(Plr)
	Plr:SetAttribute("In_Group", In_Group)
	return In_Group
end

Player_In_Group_CS_RF.OnServerInvoke = function(Plr)
	local In_Group = Is_Player_In_Group(Plr)
	Plr:SetAttribute("In_Group", In_Group)
	return In_Group
end

Player_Owns_Badge_RF.OnInvoke = function(Plr, Badge_ID)
	return Player_Owns_Badge(Plr, Badge_ID)
end

Player_Owns_Badge_CS_RF.OnServerInvoke = function(Plr, Badge_ID)
	return Player_Owns_Badge(Plr, Badge_ID)
end


Award_Badge.Event:Connect(function(Plr, Badge_ID)
	Award_Badge_Handle(Plr, Badge_ID)
end)]]></ProtectedString>
							<string name="ScriptGuid">{A5CEC041-ACCF-420F-B0B2-C3666C269205}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Badge_Attribute_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1AF45546965040C19F9EA5396355B8AA">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Player/Core_Character_Handle.server.lua
--
--  Description:
--      Sets up and manages player characters in fights. Handles ragdoll
--      physics, clothing updates, collision groups, and overhead UI.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Server_Client_F/Events
--          * Channels_F/Client_Server_F/Events
--          * Data_Mods_F/Elo_Mod
--          * Data_Mods_F/Clothing_Mod
--          * Data_Mods_F/Country_Mod
--      - Roblox Services:
--          * PhysicsService (collision groups A, B, Hitbox)
--      - Script Assets:
--          * Name_Tag_UI
--          * Fighting_UI
--      - Player Instances:
--          * Player.Player_Data (Elo, Country, Owned clothes, etc.)
--
--  Notes:
--      - Registers collision groups and disables inter-collision
--      - Implements ragdoll system via BallSocketConstraints
--      - Restores humanoid state after ragdoll period
--      - Updates character cosmetics using Clothing_Mod
--      - Displays player info with NameTag and Fighting_UI
--
--======================================================================

-- Services
local PS = game:GetService("PhysicsService")
PS:RegisterCollisionGroup("A")
PS:RegisterCollisionGroup("B")
PS:RegisterCollisionGroup("Hitbox")
PS:CollisionGroupSetCollidable("A", "B", false)
PS:CollisionGroupSetCollidable("A", "A", false)
PS:CollisionGroupSetCollidable("B", "B", false)
PS:CollisionGroupSetCollidable("Hitbox", "A", false)
PS:CollisionGroupSetCollidable("Hitbox", "B", false)

-- Modules
local Elo_Mod = require(game.ReplicatedStorage.Data_Mods_F.Elo_Mod)
local Clothing_Mod = require(game.ReplicatedStorage.Data_Mods_F.Clothing_Mod)
local Country_Mod = require(game.ReplicatedStorage.Data_Mods_F.Country_Mod)
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)
local Fight_Params_Mod = require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)

-- Events
local Channels				= require(game.ReplicatedStorage.Modules.Channels)
local Update_Player_Device 	= Channels.SC_Remote_Events.Update_Player_Device
local Set_Player_Device		= Channels.CS_Remote_Events.Set_Player_Device
local Award_Badge			= Channels.Bindable_Events.Award_Badge
local Display_Data			= Channels.SC_Remote_Events.Display_Data
local Ragdoll_Player_E		= Channels.Bindable_Events.Ragdoll_Player
local Show_Shield_UI        = Channels.CS_Remote_Events.Show_Shield_UI

local Name_Tag_TMP = script:WaitForChild("Name_Tag_UI")
local Fight_UI_TMP = script:WaitForChild("Fighting_UI")

local Get_Player_Val = PlayerUtils.GetPlayerVal


local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

local function Join_Check(t)
	local Joints = {"LeftWrist","RightWrist","LeftAnkle","RightAnkle", "Root"}
	if(table.find(Joints, t) ~= nil)then
		return false
	end
	return true
end

local function Ragdoll_Player(Char)
	local Hum = Char:FindFirstChild("Humanoid")

	local function Set_Up_Character_Ragdoll()
		for _,v in pairs(Char:GetDescendants()) do
			if v:IsA("Motor6D")and Join_Check(v.Name)then
				local b = Instance.new("BallSocketConstraint",v.Parent)
				local a0,a1 = Instance.new("Attachment"),Instance.new("Attachment")

				a0.Parent,a1.Parent = v.Part0,v.Part1
				b.Attachment0,b.Attachment1 = a0,a1
				a0.CFrame,a1.CFrame = v.c0,v.c1
				b.LimitsEnabled = true
				b.TwistLimitsEnabled = true
				b.Enabled = false

			elseif v:IsA'BasePart' or v:IsA("MeshPart") then
				if(v.Name ~= "Hitbox_Part")then
					PS:SetPartCollisionGroup(v, "A")--  => deprecated (SEB)
					--v.CollisionGroup = "A"
				else
					v.CanCollide = false
				end

				if v.Name == "HumanoidRootPart" then
					PS:SetPartCollisionGroup(v, "B")-- => deprecated (SEB)
					--v.CollisionGroup = "B"
				elseif v.Name=="Head"then
					v.CanCollide = true
				end

			end
		end
		PS:CollisionGroupSetCollidable("A", "B", false)
	end
	Set_Up_Character_Ragdoll()

	Hum:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
	Hum:ChangeState(Enum.HumanoidStateType.Ragdoll)
	Hum.PlatformStand = true

	for _,v in pairs(Char:GetDescendants()) do
		if v:IsA'Motor6D'and Join_Check(v.Name)then
			v.Enabled = false
		elseif v:IsA'BallSocketConstraint' then
			v.Enabled = true
		end
	end

	task.wait(3.5)

	if(Char ~= nil)then
		for _,v in pairs(Char:GetDescendants()) do
			if(v:IsA'BasePart' or v:IsA("MeshPart"))then
				if v.Name == "Hitbox_Part"then
					v.CanCollide = true
				else
					PS:SetPartCollisionGroup(v, "Default") --=> deprecated (SEB)
					--v.CollisionGroup = "Default"
				end
			end

			if v:IsA'Motor6D'and Join_Check(v.Name)then
				v.Enabled = true
			elseif v:IsA'BallSocketConstraint' then
				v.Enabled = false
				v:Destroy()
			end
		end

		Hum:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
		Hum:ChangeState(Enum.HumanoidStateType.GettingUp)
		Hum.PlatformStand = false
	end
end

local function Update_Shorts(Plr, Char)
	--Get the Default Key, get the Model, Clone it
	--Remove any Previous Models in Character
	--Loop through Each BodyPart, set up CFrame Offset and Weld to BodyPart
	local Shorts_Key, Shorts_TMP = Clothing_Mod.Get_Player_Current_Shorts(Plr)
	local Prev_Shorts = Char:FindFirstChild("Shorts_M")
	if(Prev_Shorts ~= nil)then
		Prev_Shorts:Destroy()
	end

	local New_Shorts = Shorts_TMP:Clone()
	New_Shorts.Parent = Char
	New_Shorts.Name = "Shorts_M"

	local function Configure_New_Shorts()
		local function Set_New_Part(P)
			local Main_BP = Char:FindFirstChild(P.Name)
			local Offset_CF = P:GetAttribute("Spawn_Offset_CF") or CFrame.new()
			--if(Offset_CF == nil)then
			--	P.CFrame = Main_BP.CFrame
			--else
			--	P.CFrame = Main_BP.CFrame:ToWorldSpace(Offset_CF)
			--end

			local W = Instance.new("Weld", P)
			W.Name = "WeldConstraint"
			W.Part0 = Main_BP
			W.Part1 = P
			W.C0 = Offset_CF
		end

		local All_P = New_Shorts:GetChildren()
		for i = 1, #All_P do
			local P = All_P[i]
			if(P ~= nil and Char:FindFirstChild(P.Name) ~= nil)then
				Set_New_Part(P)
			end
		end
	end
	Configure_New_Shorts()
end

local function Update_Gloves(Plr, Char)	
	local Gloves_Key, Gloves_TMP = Clothing_Mod.Get_Player_Current_Gloves(Plr)
	local Prev_Gloves = Char:FindFirstChild("Gloves_M")

	local Default_Gloves =nil
	Default_Gloves = Char:FindFirstChild("Default_Gloves")
	if Default_Gloves then
		for _, item in ipairs(Default_Gloves:GetDescendants()) do
			if item:IsA("BasePart") then
				item.Transparency = 1
			end
		end
	end

	if(Prev_Gloves ~= nil)then
		Prev_Gloves:Destroy()
	end

	local New_Gloves = Gloves_TMP:Clone()
	New_Gloves.Parent = Char
	New_Gloves.Name = "Gloves_M"

	local function Configure_New_Gloves()
		local function Set_New_Part(P, isFlipped)			
			local Main_BP = Char:FindFirstChild(P.Name)
			local HRP = Char:FindFirstChild("HumanoidRootPart")
			local Offset_CF = P:GetAttribute("Spawn_Offset_CF")
			--P.Size = Vector3.new(0.753, 1.094, 0.787)
			if Default_Gloves~=nil then
				P.CFrame = Default_Gloves:FindFirstChild(P.Name).CFrame
			else
				P.CFrame = Main_BP.CFrame
			end
			if isFlipped == true then
				P.CFrame *= CFrame.Angles(0, math.pi, 0)
			end
			--local Dif_V = Vector3.new(0.753, 1.094, 0.787) / Vector3.new(0.772, 0.938, 0.838)

			local W = Instance.new("WeldConstraint", P)
			W.Part0 = P
			local part1 = Main_BP
			if Default_Gloves~=nil then
				if P.Name == "LeftHand" then
					part1 = Char:FindFirstChild("RightHand")
				else
					part1 = Char:FindFirstChild("LeftHand")
				end
			end

			W.Part1 = part1
			W.Enabled = true
		end

		local All_P = New_Gloves:GetChildren()
		for i = 1, #All_P do
			local P = All_P[i]
			if(P ~= nil and Char:FindFirstChild(P.Name) ~= nil)then
				Set_New_Part(P, Gloves_TMP:GetAttribute("FlipGloves"))
			end
		end
	end
	Configure_New_Gloves()
end

local function Update_Skin_Color(Plr, Char)
	--Get the Skin Color Val, Create Color3 Val
	--> Update BodyColors Value
	--> 


	local Skin_Color_V = Get_Player_Val(Plr, "Skin Tone")
	if(Skin_Color_V ~= nil) then
		local function Configure_Skin_Color()
			local Str = string.split(Skin_Color_V.Value, ",")
			if(Str ~= nil and #Str >= 3)then
				local R, G, B = tonumber(Str[1]), tonumber(Str[2]), tonumber(Str[3])
				R, G, B = math.clamp(R, 0, 255), math.clamp(G, 0, 255), math.clamp(B, 0, 255)
				return Color3.fromRGB(R, G, B)
			end

			return Color3.fromRGB(234, 184, 146)
		end
		local Skin_Col = Configure_Skin_Color()

		local function Configure_Body_Color()
			local BC = Char:FindFirstChildWhichIsA("BodyColors")
			if(BC ~= nil)then
				BC.HeadColor3 = Skin_Col
				BC.LeftArmColor3 = Skin_Col
				BC.RightArmColor3 = Skin_Col
				BC.LeftLegColor3 = Skin_Col
				BC.RightLegColor3 = Skin_Col
				BC.TorsoColor3 = Color3.new(0, 0, 0)
				Char:FindFirstChild("UpperTorso").Color = Skin_Col
			end
		end
		Configure_Body_Color()

		local function Update_Surface_Appearance(BP)
			local All_D = BP:GetDescendants()
			for i = 1, #All_D do
				local D = All_D[i]
				if(D ~= nil and D:IsA("SurfaceAppearance"))then
					D.Color = Skin_Col
				end
			end
		end
		local Is_Male = Get_Player_Val(Plr, "Body Type").Value == "Male"
		if Is_Male then
			Update_Surface_Appearance(Char:WaitForChild("UpperTorso"))
			Update_Surface_Appearance(Char:WaitForChild("RightUpperLeg"):WaitForChild("Mainheight6.002"))
			Update_Surface_Appearance(Char:WaitForChild("RightUpperArm"))
			Update_Surface_Appearance(Char:WaitForChild("RightLowerLeg"):WaitForChild("Mainheight5.002"))
			Update_Surface_Appearance(Char:WaitForChild("RightLowerArm"))
			Update_Surface_Appearance(Char:WaitForChild("LowerTorso"):WaitForChild("r15 tt.003"))
			Update_Surface_Appearance(Char:WaitForChild("LeftUpperLeg"):WaitForChild("Mainheight6.001"))
			Update_Surface_Appearance(Char:WaitForChild("LeftUpperArm"))
			Update_Surface_Appearance(Char:WaitForChild("LeftLowerLeg"):WaitForChild("Mainheight5.001"))
			Update_Surface_Appearance(Char:WaitForChild("LeftLowerArm"))
		end
		local function Update_Hand_Colors()
			local Hand_M = Char:FindFirstChild("Hands33")
			if(Hand_M ~= nil)then
				local All_P = Hand_M:GetChildren()
				for i = 1, #All_P do
					local P = All_P[i]
					if(P ~= nil and P:IsA("MeshPart") and string.match(P.Name, "Hand") ~= nil)then
						P.Color = Skin_Col
					end
				end
			end
		end
		Update_Hand_Colors()

		--local function Set_Lat_Colors(Lat_P)
		--	if(Lat_P ~= nil)then
		--		Lat_P.Color = Skin_Col
		--	end
		--end
		--Set_Lat_Colors(Char:WaitForChild("Lat_L"))
		--Set_Lat_Colors(Char:WaitForChild("Lat_R"))
	end
end

local function Get_Device_Image(Plr)
	local Device_Imgs = {
		['PC'] = "rbxassetid://115464285887151",
		['Console'] = "rbxassetid://120642019576021",
		['Mobile'] = "rbxassetid://98548614504710"
	}

	local Device_Atrib = Plr:GetAttribute("Device")
	if(Device_Atrib == nil or Device_Imgs[Device_Atrib] == nil)then
		Update_Player_Device:FireClient(Plr)
	else
		return Device_Imgs[Device_Atrib]
	end

	return Device_Imgs['PC']
end

local function Get_Player_Name_Tag(Plr)
	local Char = Plr.Character
	if(Char ~= nil and Char:FindFirstChild("Name_Tag_UI") ~= nil)then
		return Char:FindFirstChild("Name_Tag_UI")
	end
	return nil
end

local function Update_Name_Tag_Data(Plr, Data_Type)
	--For Health and Stamina
	local Fight_Data_F = Plr:FindFirstChild("Fight_Data")
	local Name_Tag_UI = Get_Player_Name_Tag(Plr)
	if(Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild(Data_Type) ~= nil and Name_Tag_UI ~= nil and  
		Name_Tag_UI:FindFirstChild("Main_F") ~= nil)then

		local Data_V = Fight_Data_F:FindFirstChild(Data_Type)
		local Main_F = Name_Tag_UI:FindFirstChild("Main_F")
		local Bar_F = Main_F:FindFirstChild("Stam_Bar_F")
		if(Data_Type == "Health")then
			Bar_F = Main_F:FindFirstChild("Health_Bar_F")
		end

		if(Bar_F ~= nil and Bar_F:FindFirstChild("Val_Txt") ~= nil and Bar_F:FindFirstChild("Bar_F") ~= nil)then
			local X_Size = math.clamp(Data_V.Value / 100, 0, 1)
			Bar_F:FindFirstChild("Bar_F"):TweenSize(UDim2.new(X_Size, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)

			Bar_F:FindFirstChild("Val_Txt").Text = Data_V.Value .. ""
		end
	end
end

local function Update_Name_Tag_Elo(Plr)
	--For the Rank Display
	local Name_Tag_UI = Get_Player_Name_Tag(Plr)
	if(Name_Tag_UI ~= nil and Name_Tag_UI:FindFirstChild("Main_F") ~= nil and 
		Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Rank_F") ~= nil)then

		local Rank_F = Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Rank_F")
		local Rank_Txt = Rank_F:FindFirstChild("Rank_Txt")
		local Rank_Img = Rank_F:FindFirstChild("Rank_Img")
		local Rank_Data, Elo_Amount = Elo_Mod.Get_Player_Rank_Data(Plr)

		if(Rank_F ~= nil and Rank_Img ~= nil and Rank_Txt ~= nil and Rank_Data ~= nil 
			and Elo_Amount ~= nil)then

			local Rank_Col = Rank_Data['Color'] or Color3.fromRGB(170, 170, 127)
			Rank_Txt.Text = Format_Number(Elo_Amount) .. ""
			Rank_Txt.TextColor3 = Rank_Col
			Rank_Img.Image = Rank_Data['Icon'] or "rbxassetid://89194867048049"
			Rank_Img.ImageColor3 = Rank_Col
		end
	end
end

local function Update_Name_Tag_Country(Plr)
	local Name_Tag_UI = Get_Player_Name_Tag(Plr)
	if(Name_Tag_UI ~= nil and Name_Tag_UI:FindFirstChild("Main_F") ~= nil and 
		Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Country_Img") ~= nil)then

		local Country_Img = Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Country_Img")
		local Country_Key, Country_Icon = Country_Mod.Get_Player_Country_Data(Plr)
		if(Country_Icon ~= nil)then
			Country_Img.Image = Country_Icon
		end
	end
end

local function Update_Name_Tag_Connection(Plr)
	--For the Player Connection Handle
	local Name_Tag_UI = Get_Player_Name_Tag(Plr)
	local Ping = Plr:GetNetworkPing() * 100
	--> less than 100 ms (Green)
	--> Less than 250 ms (Yellow)
	--> Greater than 250 ms (Red)

	if(Name_Tag_UI ~= nil and Name_Tag_UI:FindFirstChild("Main_F") ~= nil and 
		Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Connection_Img") ~= nil)then

		local Connection_Img = Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Connection_Img")
		local UIG = Connection_Img:FindFirstChildWhichIsA("UIGradient")

		if(UIG ~= nil)then
			if(Ping <= 100)then
				UIG.Color = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Color3.new(0, 1, 0)),
					ColorSequenceKeypoint.new(1, Color3.new(0, 1, 0))
				}
			elseif(Ping <= 250)then
				UIG.Color = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Color3.new(1, 1, 0)),
					ColorSequenceKeypoint.new(0.6875, Color3.new(1, 1, 0)),
					ColorSequenceKeypoint.new(0.6876, Color3.fromRGB(200, 200, 200)),
					ColorSequenceKeypoint.new(1, Color3.fromRGB(200, 200, 200))
				}
			else
				UIG.Color = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Color3.new(1, 0, 0)),
					ColorSequenceKeypoint.new(0.3875, Color3.new(1, 0, 0)),
					ColorSequenceKeypoint.new(0.3876, Color3.fromRGB(200, 200, 200)),
					ColorSequenceKeypoint.new(1, Color3.fromRGB(200, 200, 200))
				}
			end
		end
	end
end

local function Update_Playtime_Tracking(Plr)
	local Session_Time_V = Get_Player_Val(Plr, "Total Playtime")
	if(Session_Time_V ~= nil)then
		Session_Time_V.Value += 1
	end
end

local bufferToken = 0
local function Update_Fight_Block_UI(Plr)
	local function Get_Player_Fight_UI()
		local Char = Plr.Character
		if(Char ~= nil and Char:FindFirstChild("Fighting_UI") ~= nil)then
			return Char:FindFirstChild("Fighting_UI")
		end
		return nil
	end
	local Fight_UI = Get_Player_Fight_UI()
	local Fight_Data_F = Plr:FindFirstChild("Fight_Data")

	if(Fight_UI ~= nil and Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild("Block Power") ~= nil 
		and Fight_UI:FindFirstChild("Main_F") ~= nil and 
		Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then

		local Block_Power_V = Fight_Data_F:FindFirstChild("Block Power")
		local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
		local Img = Sheild_F:FindFirstChild("Shield_Img")
		local Txt = Sheild_F:FindFirstChild("Shield_Txt")
		local Spinner = Img:FindFirstChild("Spinner")

		if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
			local UIG = Img:FindFirstChildWhichIsA("UIGradient")
			local Block_Power = Block_Power_V.Value
			local Dif =  math.clamp(Block_Power / Fight_Params_Mod.Block_Power.Max_Value, 0, 1)
			local Offset_Pos_Y = (1 - Dif) - 0.5

			UIG.Offset = Vector2.new(0, Offset_Pos_Y)
			Txt.Text = Block_Power .. ""
			if(Dif <= 0.25)then
				Txt.TextColor3 = Color3.new(1, 0, 0)
			else
				Txt.TextColor3 = Color3.new(1, 1, 1)
			end

			if Spinner ~= nil then
				bufferToken += 1
				local myToken = bufferToken

				-- NE PAS BLOQUER, NE PAS multiplier les boucles
				coroutine.wrap(function()
					while myToken == bufferToken and Block_Power_V:GetAttribute("Is_Buffering") do
						Spinner.Visible = true
						Spinner.Rotation += 10
						task.wait(0.1)
					end

					-- sort de la boucle = stop logique
					Spinner.Visible = false
				end)()
			end
		end
	end
end

local function Toggle_Fight_Block_UI(Plr, Is_Enabled)
	local function Get_Player_Fight_UI()
		local Char = Plr.Character
		if(Char ~= nil and Char:FindFirstChild("Fighting_UI") ~= nil)then
			return Char:FindFirstChild("Fighting_UI")
		end
		return nil
	end
	local Fight_UI = Get_Player_Fight_UI()

	if(Fight_UI ~= nil)then
		Fight_UI.Enabled = Is_Enabled
	end
end

local New_Char_Created_Manually = false
local function Update_Bodytype(player)

	New_Char_Created_Manually = true
	local Body_Type_V = Get_Player_Val(player, "Body Type")
	if(Body_Type_V == nil) then return end
	local Body_Type = Body_Type_V.Value

	local StarterCharacter = nil 
	if Body_Type == "Male" then
		StarterCharacter =  game.ServerStorage.Avatars:WaitForChild("Male_StarterCharacter"):Clone()
	elseif Body_Type == "Female" then
		StarterCharacter =  game.ServerStorage.Avatars:WaitForChild("Female_StarterCharacter"):Clone()
	end

	local oldChar = player.Character
	if not oldChar or not StarterCharacter then return end
	local oldhum = oldChar:FindFirstChild("Humanoid")
	local oldhrp = oldChar:FindFirstChild("HumanoidRootPart")

	-- 1. Cloning and setup
	local newChar = StarterCharacter:Clone()
	newChar.Name = player.Name
	newChar:SetPrimaryPartCFrame(oldChar:GetPrimaryPartCFrame())
	local hum = newChar:WaitForChild("Humanoid")
	hum.WalkSpeed = oldhum.WalkSpeed
	hum.JumpPower = oldhum.JumpPower
	newChar:PivotTo(oldhrp.CFrame)

	-- 3. Keep attributes
	for name, value in pairs(oldChar:GetAttributes()) do
		if not string.match(name, "^RBX_") then
			newChar:SetAttribute(name, value)
		end
	end

	-- 4. Swap
	newChar.Parent = workspace
	player.Character = newChar
	oldChar:Destroy()

	-- 5. Enalble Scripts 
	for _, originalScript in pairs(game.StarterPlayer.StarterCharacterScripts:GetChildren()) do
		-- On vérifie s'il n'est pas déjà présent pour éviter les doublons
		if not newChar:FindFirstChild(originalScript.Name) then
			local scriptClone = originalScript:Clone()
			scriptClone.Parent = newChar
			scriptClone.Disabled = false -- On force l'activation
		end
	end

	-- 6. Wait for Animate to load
	local Animate = newChar:FindFirstChild("Animate")
	Animate.Enabled = false
	wait()
	Animate.Enabled = true

	-- 8. Add ForceField
	local Force_Field = Instance.new("ForceField")
	Force_Field.Visible = true 
	Force_Field.Parent = newChar
	game:GetService("Debris"):AddItem(Force_Field, 5)
end

local function Character_Handle(Plr: Player, Char)
	local Hum = Char:WaitForChild("Humanoid")
	local HRP = Char:WaitForChild("HumanoidRootPart")
	local Head = Char:WaitForChild("Head")

	Char:SetAttribute("UserId", Plr.UserId)

	local plrValue = Instance.new("ObjectValue")
	plrValue.Value = Plr
	plrValue.Name = "_PLAYER_VALUE_"
	plrValue.Parent = Char

	--Set up Skin Color Change Handle based on Data
	--Set up Player Accessories and Face from the Default Character
	--Add Player Gloves and Shorted based on the Current Values

	local function Add_Character_Face_Accessories()
		local function Create_Original_Character()
			local function Async()
				local Data = nil
				local success, errormessage = pcall(function()
					Data = game.Players:CreateHumanoidModelFromUserId(Plr.UserId)
				end)

				if(success and Data ~= nil)then
					return Data
				end
				return nil
			end

			for i = 1, 3 do
				local D = Async()
				if(D ~= nil)then
					D.Parent = script
					return D
				end
			end

			return nil
		end
		local Orig_Char = Create_Original_Character()

		if(Orig_Char ~= nil)then
			local All_C = Orig_Char:GetChildren()
			for i = 1, #All_C do
				local C = All_C[i]
				if(C ~= nil and C:IsA("Accessory"))then
					--Hum:AddAccessory(C)
					C.Parent = Char
				elseif(C ~= nil and C.Name == "Head" and C:FindFirstChildWhichIsA("Decal") ~= nil)then
					--C:FindFirstChildWhichIsA("Decal").Parent = Head

					--Create a Face Part for some reason
					local Old_Face_P = Head:FindFirstChild("Face_Part")
					if(Old_Face_P ~= nil)then
						Old_Face_P:Destroy()
					end
					local Face_P = Instance.new("Part", Head)
					Face_P.Name = "Face_Part"
					Face_P.Size = Head.Size
					Face_P.Anchored = false
					Face_P.CanCollide = false
					Face_P.CanTouch = false
					Face_P.Massless = true
					Face_P.Transparency = 1
					Face_P.Material = Enum.Material.SmoothPlastic
					Face_P.CFrame = Head.CFrame

					local W = Instance.new("WeldConstraint", Face_P)
					W.Part0 = Face_P
					W.Part1 = Head
					W.Enabled = true

					local New_Face = C:FindFirstChildWhichIsA("Decal"):Clone()
					New_Face.Parent = Face_P

				end
			end

			Orig_Char:Destroy()
		end

		Hum.BreakJointsOnDeath = false
		Hum.RequiresNeck = false
		Hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
		Hum.HealthDisplayType = Enum.HumanoidHealthDisplayType.AlwaysOff
	end
	Add_Character_Face_Accessories()

	Update_Skin_Color(Plr, Char)
	Update_Gloves(Plr, Char)
	Update_Shorts(Plr, Char)


	local function Disable_Health_Regen()
		local Health = Char:WaitForChild("Health",.01)
		if(Health ~= nil and Health:IsA("Script"))then
			Health:Destroy()
		end
	end
	Disable_Health_Regen()

	local function Auto_Ragdoll_On_Death()
		if(Hum ~= nil)then
			Hum.Died:Connect(function()
				if(Char ~= nil)then
					Ragdoll_Player(Char)
				end
			end)
		end
	end
	Auto_Ragdoll_On_Death()

	local function Name_Tag_Handle()
		if(HRP ~= nil and Char:FindFirstChild("Name_Tag_UI") == nil)then
			--When we have a Name Tag, apply it here
			local Name_Tag_UI = Name_Tag_TMP:Clone()
			Name_Tag_UI.Name = "Name_Tag_UI"
			Name_Tag_UI.Parent = Char
			Name_Tag_UI.Adornee = HRP

			local Main_F = Name_Tag_UI:WaitForChild("Main_F")
			Main_F:WaitForChild("Player_Name_Txt").Text = Plr.DisplayName
			Name_Tag_UI.Enabled = true
			Main_F:WaitForChild("Device_Img").Image = Get_Device_Image(Plr)

			Update_Name_Tag_Data(Plr, "Health")
			Update_Name_Tag_Data(Plr, "Staminia")
			Update_Name_Tag_Elo(Plr)
			Update_Name_Tag_Connection(Plr)
			Update_Name_Tag_Country(Plr)
		end

		if(HRP ~= nil and Char:FindFirstChild("Fighting_UI") == nil)then
			local Fight_UI = Fight_UI_TMP:Clone()
			Fight_UI.Name = "Fighting_UI"
			Fight_UI.Parent = Char
			Fight_UI.Adornee = HRP
			Fight_UI.Enabled = true

			Update_Fight_Block_UI(Plr)
			Toggle_Fight_Block_UI(Plr, false)
		end	
	end
	Name_Tag_Handle()

	local function Create_Collision_Hitbox()
		--local CF, Size = Char:GetBoundingBox()
		--local HB = Instance.new("Part", Char)
		local HB = script:WaitForChild("Round_Hitbox_P"):Clone()
		HB.Parent = Char
		HB.Name = "Hitbox_Part"
		HB.Transparency = 1
		HB.CanTouch = false
		HB.CanCollide = true
		HB.Anchored = false
		HB.Massless = true
		--HB.Size = Size
		--HB.CFrame = CF
		HB.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, 0, 0)
		HB.CollisionGroup = "Hitbox"

		local W = Instance.new("WeldConstraint", HB)
		W.Part0 = HB
		W.Part1 = HRP
		W.Enabled = true		
	end
	Create_Collision_Hitbox()
end

local function Total_Knockout_Badge_Handle(Plr)
	local Badges_Data = {
		[10] = 3359889418756738,
		[50] = 3881066402115385,
		[100] = 2633101226400876,
		[1000] = 873841622513803,
		[10000] = 757308337186417
	}

	local function Compile_Total_Knockouts()
		local Total_KO = 0
		local Punch_KO_V = Get_Player_Val(Plr, "Punch Knockout Wins")
		local Kick_KO_V = Get_Player_Val(Plr, "Leg Knockout Wins")

		if(Punch_KO_V ~= nil)then
			Total_KO += Punch_KO_V.Value
		end

		if(Kick_KO_V ~= nil)then
			Total_KO += Kick_KO_V.Value
		end

		return Total_KO
	end
	local Total_Knockouts = Compile_Total_Knockouts()

	if(Badges_Data[Total_Knockouts] ~= nil)then
		Award_Badge:Fire(Plr, Badges_Data[Total_Knockouts])

		local Txt = "👊 Congrats on over " .. Format_Number(Total_Knockouts) .. " Total Knockouts!"
		Display_Data:FireClient(Plr, Txt, Color3.fromRGB(255, 170, 0))
	end
end



local function Player_Data_Changes_Handle(Plr)
	local PD = Plr:WaitForChild("Player_Data")
	local FD = Plr:WaitForChild("Fight_Data")

	PD:WaitForChild("Body Type").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Bodytype(Plr)
		end
	end)

	PD:WaitForChild("Skin Tone").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Skin_Color(Plr, Plr.Character)
		end
	end)

	PD:WaitForChild("Current Shorts").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Shorts(Plr, Plr.Character)
		end
	end)

	PD:WaitForChild("Current Gloves").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Gloves(Plr, Plr.Character)
		end
	end)

	PD:WaitForChild("Elo").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Name_Tag_Elo(Plr)
		end
	end)
	Update_Name_Tag_Elo(Plr)

	PD:WaitForChild("Country").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Name_Tag_Country(Plr)
		end
	end)

	PD:WaitForChild("Punch Knockout Wins").Changed:Connect(function()
		if(Plr ~= nil)then
			Total_Knockout_Badge_Handle(Plr)
		end
	end)

	PD:WaitForChild("Leg Knockout Wins").Changed:Connect(function()
		if(Plr ~= nil)then
			Total_Knockout_Badge_Handle(Plr)
		end
	end)

	--Fight Data Changes
	local Health_V = FD:WaitForChild("Health")
	Health_V.Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			if(Health_V.Value <= 0)then
				Ragdoll_Player(Plr.Character)
			end

			Update_Name_Tag_Data(Plr, "Health")
		end
	end)

	FD:WaitForChild("Staminia").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Name_Tag_Data(Plr, "Staminia")
		end
	end)

	FD:WaitForChild("Block Power").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Fight_Block_UI(Plr)
		end
	end)
end

game.Players.PlayerAdded:Connect(function(Plr)	
	local Init_Char = Plr.Character
	if(Init_Char ~= nil)then
		Character_Handle(Plr, Init_Char)
	end

	Plr.CharacterAdded:Connect(function(Char)
		Character_Handle(Plr, Char)
		
		if not New_Char_Created_Manually then
			task.delay(2, function()
				Update_Bodytype(Plr)
			end)
		end
		
		-- reset variable
		New_Char_Created_Manually = false
	end)

	Player_Data_Changes_Handle(Plr)
end)

Ragdoll_Player_E.Event:Connect(function(Char)
	if(Char ~= nil and Char:FindFirstChild("Humanoid") ~= nil)then
		Ragdoll_Player(Char)
	end
end)

Set_Player_Device.OnServerEvent:Connect(function(Plr, Device_Str)
	if(Plr ~= nil and Plr:IsA("Player")) then
		Plr:SetAttribute("Device", Device_Str)

		--Update their Name Tag
		local Name_Tag = Get_Player_Name_Tag(Plr)
		if(Name_Tag ~= nil)then
			Name_Tag:WaitForChild("Main_F"):WaitForChild("Device_Img").Image = Get_Device_Image(Plr)
		end
	end
end)

Show_Shield_UI.OnServerEvent:Connect(function(Plr, Is_Enabled)
	if(Plr ~= nil and Plr.Character ~= nil)then
		Toggle_Fight_Block_UI(Plr, Is_Enabled)
	end
end)

function Update_Player_Connections()
	--Update this to run each
	while task.wait(1) do
		local All_P = game.Players:GetPlayers()
		for i = 1, #All_P do
			local P = All_P[i]
			if(P ~= nil and P.Character ~= nil)then
				Update_Playtime_Tracking(P)
				if(i % 10 == 0)then
					Update_Name_Tag_Connection(P)
				end
			end
		end
	end
end

Update_Player_Connections()

--[[
	* Name Tag Changed Events
		-> Elo Changes
		-> Health Value
		-> Stamina Value
		
		On Init
		-> Name
		-> Device
		
	* Server Update Function of Player Ping every 10 Seconds
]]]]></ProtectedString>
							<string name="ScriptGuid">{79A6D092-14D9-4C66-9E0A-E701129ED247}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Core_Character_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX05D71F5958284FF7A1043C3001F39EAC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Monetization</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXCDCB4827385C4B209D56B478D87AE42D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Codes_Handle.server.lua
--
--  Description:
--      Handles promotional/reward codes. Applies rewards such as cash,
--      gems, free gamepasses, crates, skill tree points, and unlockable
--      animations or moves to eligible players.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Monetization_Mod
--          * Data_Mods_F/Rewards_Mod
--          * Data_Mods_F/Crate_Mod
--          * Data_Mods_F/Skill_Tree_Mod
--          * Data_Mods_F/Animation_Mod
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Bindable_F/RF
--          * Channels_F/Client_Server_F/RF
--          * Channels_F/Client_Server_F/Events
--          * Channels_F/Server_Client_F/Events
--      - Player Instances:
--          * Player.Player_Data.Coins
--          * Player.Player_Data.Gems
--          * Player.Player_Data.Owned Special Submissions
--          * Player.Player_Data.Owned Special Strikes
--          * Player.Player_Data.Owned Gamepasses
--
--  Notes:
--      - Supports cash/gems boost and pack rewards
--      - Grants free gamepasses via BindableEvents
--      - Awards crates with simulated purchase/opening
--      - Unlocks ranked moves or strikes not yet owned
--      - Uses Rewards_Mod to validate code-to-reward mapping
--
--======================================================================

local RunService = game:GetService("RunService")

-- Modules
local Data_Mod_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Monetization_Mod = require(Data_Mod_F:WaitForChild("Monetization_Mod"))
local Rewards_Mod = require(Data_Mod_F:WaitForChild("Rewards_Mod"))
local Crate_Mod = require(Data_Mod_F:WaitForChild("Crate_Mod"))
local Skill_Tree_Mod = require(Data_Mod_F:WaitForChild("Skill_Tree_Mod"))
local Animation_Mod = require(Data_Mod_F:WaitForChild("Animation_Mod"))
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels 					= require(game.ReplicatedStorage.Modules.Channels)
local Grant_Gamepass_Perks		= Channels.Bindable_Events.Grant_Gamepass_Perks
local Grant_Free_Crate			= Channels.SC_Remote_Events.Grant_Free_Crate
local Claim_Daily_Reward		= Channels.CS_Remote_Functions.Claim_Daily_Reward
local Redeem_Skill_Tree_Reward	= Channels.CS_Remote_Functions.Redeem_Skill_Tree_Reward
local Redeem_Code 				= Channels.CS_Remote_Functions.Redeem_Code

local Get_Player_Val = PlayerUtils.GetPlayerVal

--Grant Cash, Cash Packs, Increase Cash Multiplier, Free Car (Or Cash Value of Car if already owned), Free Boosts

local function Boost_Cash(Plr, Amount)
	local Cash_Val = Get_Player_Val(Plr, "Coins")
	Cash_Val.Value += Amount
end

local function Boost_Gems(Plr, Amount)
	local Gems_Val = Get_Player_Val(Plr, "Gems")
	Gems_Val.Value += Amount
end

local function Boost_Cash_Via_Pack(Plr, Cash_Key)
	local Cash_Val = Get_Player_Val(Plr, "Coins")
	local Cash_Boost_Data = Monetization_Mod.Get_Cash_Boost_Amount(Plr)
	local Amount = Cash_Boost_Data[Cash_Key] or 1000
	
	Cash_Val.Value += Amount
end

local function Boost_Gems_Via_Pack(Plr, Gems_Key)
	local Gems_Val = Get_Player_Val(Plr, "Gems")
	local Amount = Monetization_Mod.Get_Gems_Pack_Amount(Gems_Key)

	Gems_Val.Value += Amount
end

local function Grant_Free_Gamepass(Plr, GP_Key)
	local GP_ID = Monetization_Mod.Get_ID_From_Key(true, GP_Key)
	if(GP_ID ~= -1)then
		Grant_Gamepass_Perks:Fire(Plr, GP_ID)
	end	
end

local function Award_Free_Crate(Plr, Crate_Key)
	--[[
		* get Crate Data from Key
		* Award Player the Coins in order to buy the Crate real quick
		* Fire the Shop UI to Play the Effects of the Crate Opening up
	]]--
	
	local Crate_Data = Crate_Mod.GetCrates()[Crate_Key]
	if(Crate_Data ~= nil)then
		local Price_In_Coins = Crate_Data['PriceCoins'] or 0
		Boost_Cash(Plr, Price_In_Coins)
		Grant_Free_Crate:FireClient(Plr, Crate_Data)
	end
end

local function Award_Ranked_Move(Plr, Select_Key)
	--[[
		* Get Moves the Player doesn't own that cost money
		* Get one Randomly, add to Player Data
	]]--
	
	local Owned_Submissions_V = Get_Player_Val(Plr, "Owned Special Submissions")
	if(Plr ~= nil and Owned_Submissions_V ~= nil)then
		local Owned_Keys = string.split(Owned_Submissions_V.Value, ",")
		if(Select_Key == nil or table.find(Owned_Keys, Select_Key) ~= nil)then
			local Keys_To_Give = Animation_Mod.Get_Unlockable_Submission_Keys(Plr)
			if(Keys_To_Give ~= nil and #Keys_To_Give > 0)then
				Select_Key = Keys_To_Give[math.random(1, #Keys_To_Give)]
			end
		end
		
		if(Select_Key ~= nil)then
			table.insert(Owned_Keys, Select_Key)
			Owned_Submissions_V.Value = table.concat(Owned_Keys, ",")

			local Submission_Data = Animation_Mod.Get_Special_Submission_Data(Select_Key)
			if(Submission_Data ~= nil and Submission_Data['Name'] ~= nil)then
				return Submission_Data['Name'] .. "!"
			end
		end
	end
	
	return ""
end

local function Award_Ranked_Strike(Plr, Select_Key)
	--Same as Ranked Move
	local Owned_Strikes_V = Get_Player_Val(Plr, "Owned Special Strikes")
	if(Plr ~= nil and Owned_Strikes_V ~= nil)then
		local Owned_Keys = string.split(Owned_Strikes_V.Value, ",")
		if(Select_Key == nil or table.find(Owned_Keys, Select_Key) ~= nil)then
			local Keys_To_Give = Animation_Mod.Get_Unlockable_Strike_Keys(Plr)
			if(Keys_To_Give ~= nil and #Keys_To_Give > 0)then
				Select_Key = Keys_To_Give[math.random(1, #Keys_To_Give)]
			end
		end

		if(Select_Key ~= nil)then
			table.insert(Owned_Keys, Select_Key)
			Owned_Strikes_V.Value = table.concat(Owned_Keys, ",")

			local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Select_Key)
			if(Strike_Data ~= nil and Strike_Data['Name'] ~= nil)then
				return Strike_Data['Name'] .. "!"
			end
		end
	end

	return ""
end

local function Award_Emotes(Plr, Select_Key)
	local Owned_Emotes_V = Get_Player_Val(Plr, "Owned Emotes")
	if(Plr ~= nil and Owned_Emotes_V ~= nil)then
		local Owned_Keys = string.split(Owned_Emotes_V.Value, ",")
		if(Select_Key == nil or table.find(Owned_Keys, Select_Key) ~= nil)then
			local Keys_To_Give = Animation_Mod.Get_Unlockable_Emotes(Plr)
			if(Keys_To_Give ~= nil and #Keys_To_Give > 0)then
				Select_Key = Keys_To_Give[math.random(1, #Keys_To_Give)]
			end
		end

		if(Select_Key ~= nil)then
			table.insert(Owned_Keys, Select_Key)
			Owned_Emotes_V.Value = table.concat(Owned_Keys, ",")

			local Emote_Data = Animation_Mod.Get_Emote_Data_From_Key(Select_Key)
			if(Emote_Data ~= nil and Emote_Data['Name'] ~= nil)then
				return Emote_Data['Name'] .. "!"
			end
		end
	end

	return ""
end

--local function Give_Free_Boost(Plr, Boost_Data)
--	--BOOST_DATA = {['Key'] = Boost_Key, ['Amount'] = 1}
	
--	local Owned_Products_V = Get_Player_Val(Plr, "Owned Products")
--	local Boost_Key = Boost_Data['Key'] or "D"
--	local Amount = Boost_Data['Amount'] or 1
--	local Owned_Products = string.split(Owned_Products_V.Value, ",")
	
--	for i = 1, Amount do
--		table.insert(Owned_Products, Boost_Key)
--	end
	
--	Owned_Products_V.Value = table.concat(Owned_Products, ",")
	
--	Open_Shop:FireClient(Plr, "Boosts")
--end

local function Boost_Wins(plr, amount)
	local winsVal = Get_Player_Val(plr, "Total Wins")
	if winsVal then
		winsVal.Value += amount
	end
end

local Codes_Data = {
	['A'] = {
		Code = "CHAMPS",
		Reward = Boost_Gems,
		Amount = 100,
		Text = "💎 Successfully Redeemed Code & Earned +100 Gems!",
		ExpirationDate = "2025-07-31",
		Type = "ALL",
	},

	['B'] = {
		Code = "2MILLIONS",
		Reward = Boost_Gems,
		Amount = 165,
		Text = "💎 Successfully Redeemed Code & Earned +165 Gems!",
		ExpirationDate = "2025-07-31",
		Type = "ALL",
	},

	['C'] = {
		Code = "UFCPARIS2025",
		Reward = Boost_Gems,
		Amount = 150,
		Text = "💎 Successfully Redeemed Code & Earned +150 Gems!",
		ExpirationDate = "2025-09-30",
		Type = "ALL",   
	},

	['D'] = {
		Code = "10MILLIONS",
		Reward = Boost_Gems,
		Amount = 100,
		Text = "💎 Thank you ALL for bringing MMA Fighters here +100 Gems!",
		ExpirationDate = "2025-11-30",
		Type = "ALL",
	},
	['E'] = {
		Code = "GEMS",
		Reward = Boost_Gems,
		Amount = 10000,
		Text = "💎 SPECIAL BOOST +10K Gems!",
		ExpirationDate = "2026-12-31",
		Type = "TEAM",
	},
	['F'] = {
		Code = "CASH",
		Reward = Boost_Cash,
		Amount = 10000,
		Text = "💵 SPECIAL BOOST +10K Coins !",
		ExpirationDate = "2026-12-31",
		Type = "TEAM",
	},
	['G'] = {
		Code = "ARENA",
		Reward = Boost_Wins,
		Amount = 10,
		Text = "🏆 +10 victories added to your profile!",
		ExpirationDate = "2026-12-31",
		Type = "TEAM",
	},
	['H'] = {
		Code = "5KDISCORD",
		Reward = Boost_Gems,
		Amount = 150,
		Text = "💎 Thanks for joining our MMA Fighters Discord here +150 Gems!",
		ExpirationDate = "2026-06-30",
		Type = "ALL",
	},
	['I'] = {
		Code = "HAPPYNEWYEAR",
		Reward = Boost_Gems,
		Amount = 100,
		Text = "💎 Happy new year Fighters +100 Gems!",
		ExpirationDate = "2026-06-30",
		Type = "ALL",
	},
}


local function isCodeExpired(expiration)
	if not expiration then return false end

	local year, month, day = expiration:match("(%d+)%-(%d+)%-(%d+)")
	local expTime = os.time({year = year, month = month, day = day, hour = 23, min = 59, sec = 59})

	return os.time() > expTime
end

local function isCodeAllowedForPlayer(player, codeType)
	if codeType == "ALL" then 
		return true 
	elseif codeType == "TEAM" then
		return PlayerUtils.isDeveloper(player) or RunService:IsStudio()
	else
		return false
	end
end

local function Get_Code_Key(Code)
	for Key, Data in next, Codes_Data do
		if(Data['Code'] == Code)then
			return Key
		end
	end
	return nil
end

-----	Redeem Daily Rewards Handle	-----

local Func_Data = {
	['Gems'] = Boost_Gems,
	['Cash'] = Boost_Cash,
	['Cash Pack'] = Boost_Cash_Via_Pack,
	['Gems Pack'] = Boost_Gems_Via_Pack,
	['Crate'] = Award_Free_Crate,
	['Gamepass'] = Grant_Free_Gamepass,
	['Ranked Move'] = Award_Ranked_Move,
	['Ranked Strike'] = Award_Ranked_Strike,
	['Emotes'] = Award_Emotes
}

Claim_Daily_Reward.OnServerInvoke = function(Plr, Key)
	local Owned_Key_Val =  Get_Player_Val(Plr, "Redeemed Rewards")
	local Owned_Keys = Rewards_Mod.Get_Claimed_Daily_Player_Rewards(Plr)
	local Current_Streak = Rewards_Mod.Get_Player_Retention_Streak(Plr)

	if(Owned_Key_Val ~= nil and Current_Streak >= Key and table.find(Owned_Keys, Key .. "") == nil)then
		local Reward_Data = Rewards_Mod.Get_Specific_Daily_Reward(Key)
		local Reward_Type = Reward_Data['Type']
		local Amount = Reward_Data['Amount']
		Func_Data[Reward_Type](Plr, Amount)

		table.insert(Owned_Keys, Key)
		Owned_Key_Val.Value = table.concat(Owned_Keys, ",")

		return true
	end

	return false
end

Redeem_Skill_Tree_Reward.OnServerInvoke = function(Plr, Key, Tree_Index)
	--[[
		* Verify Player & Data Value
		* Verify the Player hasn't Redeemed already
		* Verify the Reward / Requirement Exists
		* Verify the Player has met the Requirement
		
		- Add Data Packet to the Value
		- Redeem the Reward
		- Process and return the Reward Text
	]]--
	
	local Owned_Skill_Tree_V = Get_Player_Val(Plr, "Redeemed Skill Tree")
	if(Plr ~= nil and Owned_Skill_Tree_V ~= nil and Skill_Tree_Mod.Verify_Tree_Index(Key, Tree_Index) 
		and Skill_Tree_Mod.Has_Player_Can_Redeemed_Reward(Plr, Key, Tree_Index) and 
		Skill_Tree_Mod.Player_Has_Met_Requirement(Plr, Key, Tree_Index))then
		
		local Redeemed_ST_Rewards = string.split(Owned_Skill_Tree_V.Value, ",")
		local Data_Entry = Skill_Tree_Mod.Get_Redeem_Data_Entry(Key, Tree_Index)
		table.insert(Redeemed_ST_Rewards, Data_Entry)
		Owned_Skill_Tree_V.Value = table.concat(Redeemed_ST_Rewards, ",")
		
		local Reward_Data = Skill_Tree_Mod.Get_Reward_Data(Key, Tree_Index)
		local Reward_Type = Reward_Data['Reward']
		local Amount = Reward_Data['Amount']
		local Ret_Txt = Reward_Data['Text'] 
		local Res_Txt = Func_Data[Reward_Type](Plr, Amount)
		if(Res_Txt ~= nil)then
			Ret_Txt = string.gsub(Ret_Txt, "Takedown & Submission Combo!", Res_Txt)
		end
		
		--task.spawn(Unit_Test_For_Progression, Plr, Key, Tree_Index + 1)
		return true, Ret_Txt
	end
	
	return false, ""
end

Redeem_Code.OnServerInvoke = function(Plr, Code)
	local ok = function(msg)
		return msg
	end
	local notOk = function(msg, recurse)
		local UniqueCodeFunc = game.ServerScriptService.Core.Monetization.Unique_Codes_Handle.Function

		if recurse == true then
			local result = UniqueCodeFunc:Invoke(Plr, Code)
			return result
		else
			return msg
		end
	end

	local Code_Key = Get_Code_Key(string.upper(Code))
	if not Code_Key then
		return notOk("❌ Invalid Code! Please try another!", true)
	end

	local CodeData = Codes_Data[Code_Key]

	-- expired?
	if isCodeExpired(CodeData.ExpirationDate) then
		return notOk("⌛ This code has expired!", false)
	end

	-- type mismatch?
	if not isCodeAllowedForPlayer(Plr, CodeData.Type) then
		return notOk("🚫 You are not eligible to redeem this code!", false)
	end

	-- already used?
	if CodeData.Type ~= "TEAM" then
		local Plr_Codes_Val = Get_Player_Val(Plr, "Codes")
		local Used_Codes = string.split(Plr_Codes_Val.Value, ",")
		if table.find(Used_Codes, Code_Key) ~= nil then
			return notOk("⚠️ You've already redeemed this code!", false)
		end

		-- ✅ reward
		table.insert(Used_Codes, Code_Key)
		Plr_Codes_Val.Value = table.concat(Used_Codes, ",")
	end

	local Amount = CodeData.Amount
	CodeData.Reward(Plr, Amount)

	return ok(CodeData.Text)
end

]]></ProtectedString>
							<string name="ScriptGuid">{1317DE5E-6E7C-487F-B6F5-1B423D90CA0B}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Codes_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF707390BFAF541AFB25E0B55AAC41165">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Shop_Handle.lua
--
--  Description:
--      Handles the in-game shop and crate system. Processes purchases,
--      manages currencies, and distributes cosmetic rewards (gloves, shorts).
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Crate_Mod
--          * Data_Mods_F/Clothing_Mod
--          * Data_Mods_F/Monetization_Mod
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Bindable_F/RF
--          * Channels_F/Client_Server_F/RF
--          * Channels_F/Client_Server_F/Events
--          * Channels_F/Server_Client_F/Events
--      - Roblox Services:
--          * Players
--      - Player Instances:
--          * Player.Player_Data.Coins
--          * Player.Player_Data.Gems
--
--  Notes:
--      - Validates crate availability with Crate_Mod
--      - Deducts Coins or Gems before rewarding
--      - Luck multiplier (Monetization_Mod) increases rare drop chances
--      - Rewards handled via Clothing_Mod (gloves, shorts)
--      - Supports weighted random item selection per crate
--      - Broadcasts shop-related messages to all clients
--
--======================================================================


-- Moduless
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Crate_Mod 				= require(Data_Mods_F:WaitForChild("Crate_Mod"))
local Clothing_Mod 				= require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Monetization_Mod 			= require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Utils 					= require(game.ReplicatedStorage.Modules.Utils)
local PlayerUtils 				= require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels 					= require(game.ReplicatedStorage.Modules.Channels)
local Server_Message_Crate 		= Channels.CS_Remote_Events.Server_Message_Crate
local Crate_Action_Request 		= Channels.CS_Remote_Functions.Crate_Action_Request
local Crate_Display 			= Channels.CS_Remote_Events.Crate_Display
local Show_Crate_Effects 		= Channels.SC_Remote_Events.Show_Crate_Effects
local Server_Chat 				= Channels.SC_Remote_Events.Server_Chat
local Shop_Item_Purchased 		= Channels.SC_Remote_Events.Shop_Item_Purchased
local Shop_Purchase_Rejected	= Channels.SC_Remote_Events.Shop_Purchase_Rejected
local Purchase_Cloth_Item 		= Channels.CS_Remote_Events.Purchase_Cloth_Item
local Display_Data 				= Channels.SC_Remote_Events.Display_Data

-- Workspace references
local Main_World_F 				= game.Workspace:WaitForChild("Main_World_F")
local GymCaseRig				= game.ServerStorage:WaitForChild("TemplateUIs"):WaitForChild("GymCaseRig")
local Crates_F 					= Main_World_F:WaitForChild("Gameplay"):WaitForChild("Shop"):WaitForChild("Crates")

local ITEM_PURCHASED 			= "✅ Item purchased you can equip it on your avatar!"
local ITEM_PURCHASED_ALREADY 	= "ℹ️ You already own this item, you can equip it on your avatar!"


local Get_Player_Val 			= PlayerUtils.GetPlayerVal

local function Check_Crate(CrateName)
	local Crates = Crate_Mod.GetCrates()
	for i, crate in pairs(Crates) do
		if (crate["Name"] == CrateName) then
			return true, i
		end
	end
	return false, nil
end


--// Server Message
--Server_Message_Crate.OnServerEvent:Connect(function(Plr, Txt, Clr)
--	if(Plr ~= nil)then
--		Server_Chat:FireAllClients(Txt, Clr)
--		task.wait()
--	end
--end)

Utils.SecureRemote(
	Server_Message_Crate,
	function(player, text, color)
		Server_Chat:FireAllClients(text, color)
	end,
	{ "string", "Color3" },
	{
		RateLimit = 2,
		MaxBurst = 2,
		PunishThreshold = 10
	}
)


Utils.SecureFunction(
	Crate_Action_Request,

	function(Plr, crateName, Currency)
		if typeof(crateName) ~= "string" then return false, nil end
		if typeof(Currency) ~= "string" then return false, nil end

		local Crates = Crate_Mod.GetCrates()
		local CheckCrate, Index = Check_Crate(crateName)

		if (Plr and CheckCrate == true) then
			if (Currency == "Gems" or Currency == "Coins") then

				local Player_Currency = Get_Player_Val(Plr, Currency)
				local Chosen_Currency = "PriceCoins"
				if Currency == "Gems" then
					Chosen_Currency = "PriceGems"
				end

				if(Player_Currency and Player_Currency.Value >= Crates[Index][Chosen_Currency]) then

					Player_Currency.Value -= Crates[Index][Chosen_Currency]

					local Luck = Monetization_Mod.Get_Luck_Multi(Plr)
					local rewardType = Crates[Index].RewardType
					local rewardFunction

					if rewardType == "Gloves" then
						rewardFunction = Clothing_Mod.Give_Player_Gloves
					elseif rewardType == "Shorts" then
						rewardFunction = Clothing_Mod.Give_Player_Shorts
					end

					if rewardFunction == nil then
						Player_Currency.Value += Crates[Index][Chosen_Currency] -- REFUND
						return false, nil
					end

					local items = Crates[Index]["Items"]
					local selectedItem = nil
					local selectedItemKey = nil

					local scaling = 1.0
					local totalWeight = 0
					local adjustedItems = {}

					for _, item in pairs(items) do
						local baseChance = item["Rarity"]
						local boostFactor = 1 + ((1 / baseChance) ^ 0.5 - 1) * (Luck - 1) * scaling
						local adjustedChance = baseChance * boostFactor

						table.insert(adjustedItems, {
							Name = item["Name"],
							Weight = adjustedChance,
							ItemKey = item["ItemKey"],
						})

						totalWeight += adjustedChance
					end

					local roll = Random.new():NextNumber(0, totalWeight)
					local cumulative = 0
					for _, item in ipairs(adjustedItems) do
						cumulative += item.Weight
						if roll <= cumulative then
							selectedItem = item.Name
							selectedItemKey = item.ItemKey
							break
						end
					end

					rewardFunction(Plr, selectedItemKey)
					adjustedItems = nil

					if (selectedItem) then
						return true, selectedItem
					end

				end
			end
		end

		return false, nil
	end,
	{ "string", "string" },

	-- ==== OPTIONS (soft mode) ====
	{
		AllowMissingArgs = false,
		RateLimit = 1,
		MaxBurst = 1,
		PunishThreshold = 10,
		LogOnExploit = true
	}
)

--// Handle Displaying Crate
local function PlayKeyframeCallback(animation, Position, Callback)
	local Animation = animation
	while (task.wait() and Animation.IsPlaying) do
		if (Animation.TimePosition >= Position) then
			if (Callback) then coroutine.wrap(Callback)() end
			break
		end
	end
end

Utils.SecureRemote(
		Crate_Display,
		function(player, item, rarity, color)
			if (player ~= nil and player.Character ~= nil) then
				if (Crates_F:FindFirstChild(player.Name) == nil) then

					local ClothingFolder = game.ReplicatedStorage:WaitForChild("Models"):WaitForChild("Clothing_F")

					if not item or not item.Name then return end
					local template = ClothingFolder:FindFirstChild(item.Name, true)
					if not template then return end

					local char = player.Character
					if not char then return end
					local rootPart = char:FindFirstChild("HumanoidRootPart")
					if not rootPart then return end

					local forwardVec = rootPart.CFrame.LookVector
					local offsetPos = rootPart.Position + forwardVec * 10
					local rayOrigin = offsetPos + Vector3.new(0, 10, 0)
					local rayDirection = Vector3.new(0, -100, 0)

					local rayParams = RaycastParams.new()
					rayParams.FilterDescendantsInstances = {char}
					rayParams.FilterType = Enum.RaycastFilterType.Exclude

					local result = workspace:Raycast(rayOrigin, rayDirection, rayParams)
					if not result then return end

					local groundPos = result.Position

					local crate = GymCaseRig:Clone()
					crate.Name = player.Name
					crate.Parent = Crates_F

					local size = crate:GetExtentsSize()
					local halfHeight = size.Y / 12
					local cratePos = groundPos + Vector3.new(0, halfHeight, 0)
					local flatLookVector = -Vector3.new(forwardVec.X, 0, forwardVec.Z).Unit
					local lookCFrame = CFrame.new(cratePos, cratePos + flatLookVector)

					local anim = Instance.new("Animation")
					anim.AnimationId = "rbxassetid://113179003402113"
					local track_cons = {}
					local track = crate.AnimationController.Animator:LoadAnimation(anim)

					track:Play()
					task.wait(.1)
					crate:PivotTo(lookCFrame * CFrame.new(0,-0.65,0))

					-- Fire client to handle animations/VFX
					local nearbyPlayers = PlayerUtils.GetNearbyPlayers(player, 30) 
					for _, player in ipairs(nearbyPlayers) do
						Show_Crate_Effects:FireClient(player, crate, item.Name, color)
					end

					local glove

					PlayKeyframeCallback(track, 4, function()

						glove = template:Clone()

						if (glove:FindFirstChild("LeftHand")) then

							for _, part in pairs(glove:GetChildren()) do
								if (part:IsA("BasePart") and (part.Name == "LeftHand" or part.Name == "RightHand")) then
									local groupName = part.Name .. "M"
									local group = glove:FindFirstChild(groupName) or Instance.new("Model")
									group.Name = groupName
									group.Parent = glove
									part.Parent = group
									part.Anchored = true
								end
							end

							if (glove:FindFirstChild("LeftHandM") and glove:FindFirstChild("RightHandM")) then
								glove:PivotTo(CFrame.new(0,0,0))
								
								glove:WaitForChild("RightHandM"):PivotTo(CFrame.new(0.5, 0, 0))
								
								glove:WaitForChild("LeftHandM"):PivotTo(CFrame.new(-0.5, 0, 0))
							end


						elseif (glove:FindFirstChild("LowerTorso")) then
							glove.PrimaryPart.PivotOffset = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
						end

						local cf,size = glove:GetBoundingBox()
						local handle = Instance.new("Part")
						handle.Name = "Handle"
						handle.Size = Vector3.new(1, 1, 1)
						handle.CFrame = cf
						handle.Transparency = 1
						handle.Anchored = true
						handle.CanCollide = false
						handle.Parent = glove
						glove.PrimaryPart = handle
						glove:SetAttribute("Owner", player.Name)

						for _, part in pairs(glove:GetDescendants()) do
							if part:IsA("BasePart") then
								part.Anchored = true
								part.CanCollide = false
							end
						end

						glove:PivotTo(crate.PrimaryPart.CFrame + Vector3.new(0, 1, 0))
						glove:ScaleTo(1.5)
						glove.Parent = Crates_F
						task.wait(1)
						track:AdjustSpeed(.2)
						task.wait(6)
						track:AdjustSpeed(1)
					end)

					table.insert(track_cons, track.Stopped:Connect(function()
						crate:Destroy()
						crate = nil

						for i = 1, #track_cons do
							if(track_cons[i] ~= nil)then
								track_cons[i]:Disconnect()
							end
						end
						table.clear(track_cons)

						task.delay(1 + 0.25, function()
							if (glove) then
								glove:Destroy()
								glove = nil
							end
						end)
					end))
					
					task.delay(18, function()
						if (crate) then
							crate:Destroy()
						end
						if (glove) then
							glove:Destroy()
						end
						
						for i = 1, #track_cons do
							if(track_cons[i] ~= nil)then
								track_cons[i]:Disconnect()
							end
						end
						table.clear(track_cons)
					end)
				end
			end
		end,
	{ "Instance", "number", "Color3" },
	{
		RateLimit = 1,
		MaxBurst = 5,
		PunishThreshold = 10
	}
)

Utils.SecureRemote(
	Purchase_Cloth_Item,
	function(player, isGlove, key)
		if not key  or typeof(key) ~= "string" or key == ""  then return end

		if isGlove then
			if Clothing_Mod.Player_Owns_Gloves_Key(player,key) then
				Display_Data:FireClient(player, ITEM_PURCHASED_ALREADY, Color3.fromRGB(255, 0, 0))
				return
			end
		else
			if Clothing_Mod.Player_Owns_Shorts_Key(player,key) then
				Display_Data:FireClient(player, ITEM_PURCHASED_ALREADY, Color3.fromRGB(255, 0, 0))
				return
			end
		end


		local Offers_Config = require(Data_Mods_F:WaitForChild("Offers_Config"))
		local data = Offers_Config.GetClothDataByKey(key, isGlove)
		local PD = player:FindFirstChild("Player_Data")
		local Gems = PD and PD:FindFirstChild("Gems")


		if Gems and tonumber(Gems.Value) >= data.Gems then
			Gems.Value = Gems.Value - data.Gems
			if isGlove then
				Clothing_Mod.Give_Player_Gloves(player, key)
				Shop_Item_Purchased:FireClient(player,"Cloth_Glove",key)
			else
				Clothing_Mod.Give_Player_Shorts(player, key)
				Shop_Item_Purchased:FireClient(player,"Cloth_Shorts",key)
			end
			Display_Data:FireClient(player, ITEM_PURCHASED, Color3.fromRGB(0, 255, 0))
		else
			local MessageTxt = string.format(
				"You don't have enough Gems to buy this. You need %s more.",
				tostring(data.Gems - Gems.Value)
			)
			Shop_Purchase_Rejected:FireClient(player, "NOT_ENOUGH_GEMS", MessageTxt, Color3.fromRGB(255, 0, 0))
		end
	end,
	{ "boolean", "string" },
	{
		RateLimit = 1,
		MaxBurst = 1,
		PunishThreshold = 10
	}
)]]></ProtectedString>
							<string name="ScriptGuid">{43A24781-0771-4677-8717-FC62930F283C}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Shop_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFA1EA8775BC54525AEF95DEB571AD548">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Monetization_Handle.server.lua
--
--  Description:
--      Handles monetization logic including Gamepasses, DevProducts,
--      limited items, and emotes. Updates player data, grants rewards,
--      and sends purchase confirmation messages.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ServerScriptService:
--          * GAModule
--      - ReplicatedStorage:
--          * Data_Mods_F/Monetization_Mod
--          * Data_Mods_F/Num_String_Mod
--          * Data_Mods_F/Clothing_Mod
--          * GameAnalytics
--          * CreatorCodes
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Client_Server_F
--          * Channels_F/Server_Client_F/Events/Display_Data
--          * Channels_F/Server_Client_F/Events/Open_Shop
--      - Roblox Services:
--          * MarketplaceService
--          * ExperienceNotificationService
--          * MessagingService
--          * DataStoreService
--      - DataStore:
--          * Limited_Items ("Fury_Gloves", max 1000)
--      - Player Instances:
--          * Player.Player_Data.Coins
--          * Player.Player_Data.Gems
--          * Player.Player_Data.Owned Gamepasses
--          * Player.Player_Data.Owned Emotes
--
--  Notes:
--      - Integrates with GameAnalytics for purchase tracking
--      - Handles VIP, Luck boosts, Cash/ELO multipliers, and emote unlocks
--      - Limited items tracked in DataStore with purchase cap
--      - Broadcasts purchase confirmations to clients
--
--======================================================================

-- Services
local MPS 				= game:GetService("MarketplaceService")
local DatastoreService	= game:GetService("DataStoreService")
local LimitedItemsStore = DatastoreService:GetDataStore("Limited_Items")

-- Modules
local Data_Mod_F 		= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Monetization_Mod 	= require(Data_Mod_F:WaitForChild("Monetization_Mod"))
local Clothing_Mod 		= require(Data_Mod_F:WaitForChild("Clothing_Mod"))
local GAModule 			= require(game.ServerScriptService.Modules.GAModule)
local GameAnalytics 	= require(game.ReplicatedStorage.Modules.GameAnalytics)
local CreatorCodes 		= require(game.ReplicatedStorage.Modules.CreatorCodes)
local PlayerUtils 		= require(game.ReplicatedStorage.Modules.PlayerUtils)
local Utils 			= require(game.ReplicatedStorage.Modules.Utils)
local Exploit_Logger 	= require(game.ServerScriptService.Modules.Exploit_Logger)

local ItemKeyName 		= "Fury_Gloves"
local ItemMaxCount 		= 1000

-- Events
local Channels					= require(game.ReplicatedStorage.Modules.Channels)

local Server_Chat				= Channels.SC_Remote_Events.Server_Chat
local Msg_E 					= Channels.SC_Remote_Events.Display_Data
local Open_Shop_E 				= Channels.SC_Remote_Events.Open_Shop
local Open_Emotes_E 			= Channels.SC_Remote_Events.Open_Emotes
local Convert_Feedback 			= Channels.SC_Remote_Events.Convert_Feedback
local Hide_Special_Gloves_Frame = Channels.SC_Remote_Events.Hide_Special_Gloves_Frame
local Grant_Gamepass_Perks		= Channels.Bindable_Events.Grant_Gamepass_Perks
local Convert_Cash_To_Gems 		= Channels.CS_Remote_Events.Convert_Cash_To_Gems

local Get_Player_Val 			= PlayerUtils.GetPlayerVal

local MAX_TRANSACTION_AMOUNT 	= 5_000_000

local function Award_Cash_Gems(Plr, Data_Type, Amount)
	if typeof(Amount) ~= "number" then return end
	if Amount <= 0 then return end
	if Amount > MAX_TRANSACTION_AMOUNT then return end  -- avoid infinite cash injections

	local Cash_Val = Get_Player_Val(Plr, Data_Type)
	if(Cash_Val ~= nil)then
		Cash_Val.Value = math.clamp(Cash_Val.Value + Amount, 0, MAX_TRANSACTION_AMOUNT)
	end
end

local function Award_Emotes_To_Player(Plr, Emote_Keys)
	local Owned_Emotes_V = Get_Player_Val(Plr, "Owned Emotes")
	if(Owned_Emotes_V ~= nil)then
		local Owned_Emotes_Arr = string.split(Owned_Emotes_V.Value, ",") or {}
		for i = 1, #Emote_Keys do
			local K = string.gsub(Emote_Keys[i], " ", "")
			if(K ~= nil and string.len(K) > 0 and table.find(Owned_Emotes_Arr, K) == nil)then
				table.insert(Owned_Emotes_Arr, K)
			end
		end
		
		Owned_Emotes_V.Value = table.concat(Owned_Emotes_Arr, ",")
	end
end

local function Gamepass_Handle(Plr, ID)
	local Key = Monetization_Mod.Get_Key_From_ID(true, ID)
	local Owned_Gamepass_Val = Get_Player_Val(Plr, "Owned Gamepasses")
	if(Owned_Gamepass_Val ~= nil) then
		local Owned_Keys = string.split(Owned_Gamepass_Val.Value, ",")
		if(table.find(Owned_Keys, Key) == nil)then
			table.insert(Owned_Keys, Key)
			Owned_Gamepass_Val.Value = table.concat(Owned_Keys, ",")
		end

		--Core Logic of Gamepass being Earned
		local GP_Msg_Data = {
			['B'] = {
				['Text'] = "⭐ Successfully purchased! You're now Earning x2 ELO after Winning Ranked Fights!",
				['Color'] = Color3.fromRGB(170, 85, 255)
			},
			
			['C'] = {
				['Text'] = "💸 Successfully purchased! You're now Earning x2 more Cash per Knockout!",
				['Color'] = Color3.new(0, 1, 0)
			},
			
			['E'] = {
				['Text'] = "🍀 Successfully purchased! You'll have x2 more Luck when opening Equipment Crates!",
				['Color'] = Color3.fromRGB(170, 255, 0)
			},
			
			['F'] = {
				['Text'] = "🍀 Successfully purchased! You'll have x3 more Luck when opening Equipment Crates!",
				['Color'] = Color3.fromRGB(170, 85, 255)
			},
			
		}

		if(Key == "A")then
			Plr:SetAttribute("Is_VIP", true)

			local Txt = "👑 You're now a VIP Player! Enjoy + 10% more Cash per Knockout & a VIP Chat Tag!"
			Msg_E:FireClient(Plr, Txt, Color3.fromRGB(255, 170, 0))

			local Txt = Plr.Name .. " is now a VIP Player!"
			Server_Chat:FireAllClients(Txt, Color3.fromRGB(255, 170, 0))

		elseif(Key == "D")then
			local Txt = "💪 Successfully purchased! You've Unlocked 3 Special Emotes!"
			Msg_E:FireClient(Plr, Txt, Color3.fromRGB(0, 170, 255))
			
			--Give to Player
			Award_Emotes_To_Player(Plr, {"I", "J", "K"}) -- Add in the 3 new Emote Keys later when you add these in
			
			Open_Emotes_E:FireClient(Plr)

		elseif(GP_Msg_Data[Key] ~= nil)then
			local D = GP_Msg_Data[Key]
			Msg_E:FireClient(Plr, D['Text'], D['Color'])
			
			if(Key == "E" or Key == "F")then
				Open_Shop_E:FireClient(Plr, "Crates")
			end
		end
	end
end

local function Additional_GP_Security_Delay(Plr, GP_ID)
	--3 Second Delay to check if Player owns Gamepass
	for i = 1, 3 do
		if(Plr == nil)then
			return false
		end

		local Did_Buy = Monetization_Mod.Hard_Gamepass_Check(Plr, GP_ID)
		if(Did_Buy == true)then
			return true
		end

		task.wait(1)
	end

	return false	
end

local GamepassCache = {}
MPS.PromptGamePassPurchaseFinished:Connect(function(Plr, GP_ID, Did_Buy)
	task.wait() -- Wait until Gamepass is fully Processed
	if(Plr ~= nil and Did_Buy)then
		local Secondary_Security_Check = Additional_GP_Security_Delay(Plr, GP_ID)
		if(Secondary_Security_Check)then
			Gamepass_Handle(Plr, GP_ID)
		end
		
		--task.spawn(function()
		--	GameAnalytics:GamepassPurchased(Plr, GP_ID)
		--end)
		task.spawn(function()
			local plrData = Plr:FindFirstChild("Player_Data")
			if plrData ~= nil then
				local creatorCode = plrData:FindFirstChild("Creator Code")
				if creatorCode ~= nil then
					local newCodeIndex = creatorCode.Value
					if CreatorCodes[newCodeIndex] ~= nil then
						local gamepassInfo = GamepassCache[GP_ID]

						--Cache
						if not gamepassInfo then
							--Get
							gamepassInfo = MPS:GetProductInfo(GP_ID, Enum.InfoType.GamePass)
							GamepassCache[GP_ID] = gamepassInfo
						end

						if gamepassInfo then
							GAModule:CreatorSupported(Plr, CreatorCodes[newCodeIndex].Name, gamepassInfo.PriceInRobux)
						end
					end
				end
			end
		end)
	end
end)

Grant_Gamepass_Perks.Event:Connect(function(Plr, GP_ID)
	if(Plr ~= nil)then
		Gamepass_Handle(Plr, GP_ID)
	end
end)

local function Dev_Product_Handle(Plr, ID)
	local Key = Monetization_Mod.Get_Key_From_ID(false, ID)
	local Item_Data = Monetization_Mod.Get_All_Dev_Product_Data()[Key]
	local Type = Item_Data['Type']
	
	local HasCreatorCode = false
	local plrData = Plr:FindFirstChild("Player_Data")
	if plrData ~= nil then
		local creatorValue = plrData:FindFirstChild("Creator Code")
		if creatorValue ~= nil then
			local creatorKey = creatorValue.Value
			if CreatorCodes[creatorKey] ~= nil then
				HasCreatorCode = true
			end
		end
	end
	
	local multiplier = 1
	if HasCreatorCode == true then
		multiplier = 1.1
	end

	if(Type == "Cash")then
		local Boost_Amount = math.ceil(Monetization_Mod.Get_Cash_Boost_Amount(Plr)[Key] * multiplier)
		Award_Cash_Gems(Plr, "Coins", Boost_Amount)

		local Txt = "💸 You successfully purchased + $" .. Utils.NumToString(Boost_Amount) .. "!"
		Msg_E:FireClient(Plr, Txt, Color3.fromRGB(170, 255, 0))
		return true
		
	elseif(Type == "Gems")then
		local Boost_Amount = math.ceil((Item_Data['Amount'] or 10) * multiplier)
		Award_Cash_Gems(Plr, "Gems", Boost_Amount)

		local Txt = "💎 You successfully purchased + " .. Utils.NumToString(Boost_Amount) .. " Gems!"
		Msg_E:FireClient(Plr, Txt, Color3.fromRGB(0, 170, 255))
		return true
	elseif (Type == "StarterPack")then
		local plrData = Plr:FindFirstChild("Player_Data")
		if plrData == nil then
			return false
		end
		
		local starterPackTimer = plrData:FindFirstChild("StarterPackTimer")
		if starterPackTimer == nil then
			return false
		end
		local rookieTag = plrData:FindFirstChild("RookieTag")
		if rookieTag == nil then
			return false
		end
		
		local deltaTime = starterPackTimer.Value - os.time()
		if deltaTime <= -10 then
			return false
		end

		local Txt = "You successfully purchased the Starter Pack!"
		Msg_E:FireClient(Plr, Txt, Color3.fromRGB(255, 200, 0))

		Award_Cash_Gems(Plr, "Coins", math.ceil(200 * multiplier))
		Award_Cash_Gems(Plr, "Gems", math.ceil(5 * multiplier))
		Clothing_Mod.Give_Player_Gloves(Plr, "C")
		rookieTag.Value = true
		
		starterPackTimer.Value = os.time() - 15 -- Reset it so that 
		
		return true
	elseif Type == "Special Gloves" then

		local Txt = "You successfully purchased the Special Gloves!"
		Msg_E:FireClient(Plr, Txt, Color3.fromRGB(255, 200, 0))

		local success, err = pcall(function()

			local value = false
			LimitedItemsStore:UpdateAsync(ItemKeyName, function(oldValue)
				if oldValue == nil then
					oldValue = 0
				end

				local newValue = oldValue + 1
				game.Workspace:SetAttribute("Remaining_Special_Gloves", math.min(newValue, ItemMaxCount))

				if newValue <= ItemMaxCount then
					value = true
				else
					value = false
				end

				if value == true then
					local plrData = Plr:FindFirstChild("Player_Data")
					if plrData ~= nil then
						if Clothing_Mod.Player_Owns_Gloves_Key(Plr, "G2") ~= true then
							Clothing_Mod.Give_Player_Gloves(Plr, "G2")
							Hide_Special_Gloves_Frame:FireClient(Plr)
						end
					end
				end

				return newValue
			end)

		end)

		if not success then
			warn("[Special Gloves] UpdateAsync failed:", err)
			return false
		end

		return true
	end

	return false
end

task.spawn(function()
	while true do
		local currentCount = ItemMaxCount
		pcall(function()
			currentCount = LimitedItemsStore:GetAsync(ItemKeyName) or 0
		end)
		
		game.Workspace:SetAttribute("Total_Special_Gloves", ItemMaxCount)
		game.Workspace:SetAttribute("Remaining_Special_Gloves", currentCount)
		
		task.wait(60)
	end
end)

local Dev_Product_Receipts = {}
local ProductCache = {}

local function Create_Receipt(receiptInfo)
	--Verify Player exists, Verify Dev Product exists
	--Add Result of Purchase to Dev Product Receipt Table
	local P_ID = receiptInfo.PlayerId
	local Dev_ID = tonumber(receiptInfo.ProductId)
	local Plr = game.Players:GetPlayerByUserId(P_ID)
	local Dev_Key = Monetization_Mod.Get_Key_From_ID(false, Dev_ID)

	if(Plr ~= nil and Dev_Key ~= nil)then
		--Add to Data Table
		if(Dev_Product_Receipts[Dev_ID] ~= nil)then
			table.insert(Dev_Product_Receipts[Dev_ID], P_ID)
		else
			Dev_Product_Receipts[Dev_ID] = {P_ID}
		end
		
		task.spawn(function()
			GameAnalytics:ProcessReceiptCallback(receiptInfo)
		end)
		task.spawn(function()
			local plrData = Plr:FindFirstChild("Player_Data")
			if plrData ~= nil then
				local creatorCode = plrData:FindFirstChild("Creator Code")
				if creatorCode ~= nil then
					local newCodeIndex = creatorCode.Value
					if CreatorCodes[newCodeIndex] ~= nil then
						local ProductInfo = ProductCache[receiptInfo.ProductId]

						if not ProductInfo then
							local success, err = pcall(function()
								ProductInfo = MPS:GetProductInfo(receiptInfo.ProductId, Enum.InfoType.Product)
								ProductCache[receiptInfo.ProductId] = ProductInfo
							end)
							if success == false then
								warn(err)
							end
						end

						if ProductInfo then
							GAModule:CreatorSupported(Plr, CreatorCodes[newCodeIndex].Name, ProductInfo.PriceInRobux)
						end
					end
				end
			end
		end)

		return Enum.ProductPurchaseDecision.PurchaseGranted
	end

	return Enum.ProductPurchaseDecision.NotProcessedYet
end
MPS.ProcessReceipt = Create_Receipt

MPS.PromptProductPurchaseFinished:Connect(function(P_ID, Dev_ID, Did_Buy)
	task.wait() -- Wait until Recepit is made and Processed
	if(game.Players:GetPlayerByUserId(P_ID) ~= nil and Did_Buy and Dev_Product_Receipts[Dev_ID] ~= nil)then
		local P_Index = table.find(Dev_Product_Receipts[Dev_ID], P_ID)
		if(P_Index ~= nil)then
			local Plr = game.Players:GetPlayerByUserId(P_ID)
			local Was_Processed = Dev_Product_Handle(Plr, Dev_ID)

			--Don't remove if this is a Home Sale Listing Slot
			if(Was_Processed)then
				table.remove(Dev_Product_Receipts[Dev_ID], P_Index)
			end
		end
	end
end)

-- Listen for the Convert_Cash_To_Gems event for cash to gem conversion (see Client_Shop_Handle in Shop_UI)
-- =========================================================
-- SECURE REMOTE : Convert_Cash_To_Gems
-- =========================================================
Utils.SecureRemote(
	Convert_Cash_To_Gems,

	function(player, amount)
		local Conversion_Settings = Monetization_Mod.Get_Conversion_Settings()
		local RATE = Conversion_Settings.RATE
		local FEE = Conversion_Settings.FEE

		-- Basic validation
		if typeof(amount) ~= "number" then
			Exploit_Logger.Log(player, "Invalid Argument Type", "Amount was not a number")
			return 
		end
		if amount <= 0 then return end
		if amount > MAX_TRANSACTION_AMOUNT then
			Exploit_Logger.Log(player, "Excessive Amount", "Tried to convert ".. amount)
			return 
		end  -- hard cap protection

		-- Anti exploit: prevent decimals or tiny spam
		amount = math.floor(amount)

		-- Load player data
		local PD = player:FindFirstChild("Player_Data")
		if not PD then return end

		local cash = PD:FindFirstChild("Coins")
		local gems = PD:FindFirstChild("Gems")
		if not cash or not gems then return end

		-- Player must have enough cash
		if cash.Value < amount then
			Convert_Feedback:FireClient(player, "Not enough cash available.")
			return
		end

		-- Calculate final gems
		local gemsRaw = amount / (1 / RATE)
		local gemsFinal = math.floor(gemsRaw * (1 - FEE))

		if amount >= 20 and gemsFinal < 1 then
			gemsFinal = 1
		end

		if gemsFinal < 1 then
			Convert_Feedback:FireClient(player, "Not enough for 1 gem.")
			return
		end

		-- Apply conversion
		cash.Value -= amount
		gems.Value = math.min(gems.Value + gemsFinal, 9_000_000_000) -- overflow protection

		Convert_Feedback:FireClient(player, cash.Value, gems.Value)
	end,

	{ "number" },

	{
		AllowMissingArgs = false,
		RateLimit = 1,
		MaxBurst = 5,
		PunishThreshold = 8
	}
)]]></ProtectedString>
							<string name="ScriptGuid">{F8916A80-E54C-4417-8553-3E4953B8DD68}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Monetization_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX900320C362AA470AB79100569C137827">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Training_Handle.lua
--
--  Description:
--      Manages gym training machines and player workout sessions.
--      Tracks repetitions, time spent, and rewards players with Cash/Gems.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/GymObjects/Machines_F
--      - ReplicatedStorage:
--          * Data_Mods_F
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Bindable_F/RF
--          * Channels_F/Client_Server_F/RF
--          * Channels_F/Client_Server_F/Events
--          * Channels_F/Server_Client_F/Events
--      - Roblox Services:
--          * RunService
--      - Player Instances:
--          * Player.Player_Data (Cash, Gems, Gym Training, etc.)
--
--  Notes:
--      - Tracks per-player workout times and updates "Gym Training" stat
--      - Small chance to reward Gems instead of Cash per repetition
--      - Grants periodic Cash rewards during training
--      - Welds machine parts together for stability
--      - Cleans up connections on player removal
--
--======================================================================

-- Modules
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)
local Utils = require(game.ReplicatedStorage.Modules.Utils)

-- Events
local Channels 			= require(game.ReplicatedStorage.Modules.Channels)
local Workout_Rep 		= Channels.CS_Remote_Events.Workout_Rep
local Init_Gym_Training = Channels.SC_Remote_Events.Init_Gym_Training
local Exit_Machine_E 	= Channels.CS_Remote_Events.Exit_Machine

local Get_Player_Val = PlayerUtils.GetPlayerVal


local Machines_F = Utils.SafePath(workspace, {
	"Main_World_F", "Gameplay", "Objects", "GymObjects", "Machines"
})
if not Machines_F then return end

--// machine tables
local Prompts = {}
local Cons = {}

--// time tables
local Player_Times = {}
local Server_Plr_Times = {}
local last_RepTime = {}

local Most_Time_Spent = nil

--// track player who spent most time working 

local function len(t)
	local n = 0

	for _ in pairs(t) do
		n = n + 1
	end
	return n
end

local function Check_Training(plr: Player)
	if (plr ~= nil) then
		for _, machine in pairs(Machines_F:GetChildren()) do
			if (machine ~= nil and machine:FindFirstChild("Stats")) then
				if (machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == plr.Name) then
					return true, machine
				end
			end
		end
	end
end

local function Check_Most_Time()
	local n = len(Server_Plr_Times)
	if n >= 1 then
		local most_Time = 0
		local most_Plr = nil

		for player, number in pairs(Server_Plr_Times) do
			if number > most_Time then
				most_Time = number
				most_Plr = player
			end
			
			local playerInstance = game.Players:FindFirstChild(player)
			if not playerInstance then
				continue
			end
			
			local Gym_V = Get_Player_Val(playerInstance, "Gym Training")
			if (number > Gym_V.Value) then
				Gym_V.Value = number
			end
		end

		if (most_Plr) then
			Most_Time_Spent = most_Plr
		end
	end
end

local function Disconnect_PlrCons(PlayerName)
	if not Cons[PlayerName] then return end

	if Cons[PlayerName].Connection then
		task.cancel(Cons[PlayerName].Connection)
	end

	if Cons[PlayerName].Event then
		Cons[PlayerName].Event:Disconnect()
	end

	Cons[PlayerName] = nil
end

--// setup tracking time spent on machine
--// Have a 0.1% chance that the Player can earn +1 Diamond / Gem instead of Cash after each Rep
--// Reward the Player with occasional Cash during/after Reps

--// treadmill : every 30 seconds, do +1 Rep 
local function Weld_Model_Parts(model: Model)
	for _, part in pairs(model:GetDescendants()) do
		if (model.PrimaryPart ~= nil) then
			if (part:IsA("BasePart") and part ~= model.PrimaryPart) then
				local weld = Instance.new("WeldConstraint")
				weld.Part0 = model.PrimaryPart
				weld.Part1 = part
				weld.Parent = model.PrimaryPart
			end
		end
	end
end

local function Weld_Obj(Plr : Player, GymObj : Instance) -- if gym obj has weight then this will weld it to the player
	if (Plr ~= nil and GymObj ~= nil) then
		local char = Plr.Character
		if not char then return end

		local hand = char:FindFirstChild("RightHand")
		if not hand then return end

		local torso = char:FindFirstChild("HumanoidRootPart")
		if not torso then return end

		if (GymObj.Name == "Barbell") then
			local barbell = GymObj:Clone()
			barbell.Name = "GymObj"
			barbell.Parent = workspace[Plr.Name]

			if not barbell.PrimaryPart then
				if barbell:FindFirstChild("BarbellRod") then
					barbell.PrimaryPart = barbell.BarbellRod
				end
			end

			Weld_Model_Parts(barbell)

			for _, part in ipairs(barbell:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Anchored = false
					part.Massless = true
					part.Transparency = 0
				end
			end

			for _, part in ipairs(GymObj:GetChildren()) do
				if part:IsA("BasePart") then
					part.Transparency = 1
				end
			end

			barbell.PrimaryPart:SetNetworkOwner(Plr)

			local handAttachment = hand:FindFirstChild("BarbellAttachment") or Instance.new("Attachment")
			handAttachment.Name = "BarbellAttachment"
			handAttachment.Parent = hand

			local barbellAttachment = Instance.new("Attachment")
			barbellAttachment.Name = "HandleAttachment"
			barbellAttachment.Parent = barbell.PrimaryPart

			local alignPos = Instance.new("AlignPosition")
			alignPos.Attachment0 = barbellAttachment
			alignPos.Attachment1 = handAttachment
			alignPos.RigidityEnabled = true
			alignPos.ReactionForceEnabled = false
			alignPos.MaxForce = math.huge
			alignPos.Responsiveness = 200
			alignPos.Parent = barbell.PrimaryPart

			local alignOri = Instance.new("AlignOrientation")
			alignOri.Attachment0 = barbellAttachment
			alignOri.Attachment1 = handAttachment
			alignOri.RigidityEnabled = true
			alignOri.ReactionTorqueEnabled = false 
			alignOri.MaxTorque = math.huge
			alignOri.Responsiveness = 200
			alignOri.Mode = Enum.OrientationAlignmentMode.OneAttachment
			alignOri.Parent = barbell.PrimaryPart

			alignOri.CFrame = CFrame.Angles(0, math.rad(90), 0) 

			if (GymObj.Parent.Name == "BenchPress") then
				barbellAttachment.CFrame = CFrame.new(0, -0.3, 1.4)
			elseif (GymObj.Parent.Name == "BenchPress2") then
				barbellAttachment.CFrame = CFrame.new(0, -0.3, -1.4)
			elseif (GymObj.Parent.Name == "SquatRack") then
				barbellAttachment.CFrame = CFrame.new(0, -0.3, -1.8)
			end

		elseif (GymObj.Name == "Dumbells") then

			local LDumbell = GymObj:FindFirstChild("Dumbell"):Clone()
			LDumbell.Name = "LDumbell"
			LDumbell.Parent = workspace[Plr.Name]
			LDumbell.Anchored = false
			LDumbell.Massless = true
			LDumbell.Transparency = 0

			local RDumbell = GymObj:FindFirstChild("Dumbell"):Clone()
			RDumbell.Name = "RDumbell"
			RDumbell.Parent = workspace[Plr.Name]
			RDumbell.Anchored = false
			RDumbell.Massless = true
			RDumbell.Transparency = 0

			LDumbell:SetNetworkOwner(Plr)
			RDumbell:SetNetworkOwner(Plr)

			RDumbell:PivotTo(char:FindFirstChild("RightHand").CFrame  * CFrame.new(0, -0.35, 0)) -- * CFrame.new(-1.5, -0.5, 0) * CFrame.Angles(0, math.rad(90), 0)
			LDumbell:PivotTo(char:FindFirstChild("LeftHand").CFrame  * CFrame.new(0, -0.35, 0))

			local weld = Instance.new("WeldConstraint")
			weld.Name = "DumbellWeld"
			weld.Part0 = char:FindFirstChild("RightHand")
			weld.Part1 = RDumbell
			weld.Parent = RDumbell

			local weld2 = Instance.new("WeldConstraint")
			weld2.Name = "DumbellWeld"
			weld2.Part0 = char:FindFirstChild("LeftHand")
			weld2.Part1 = LDumbell
			weld2.Parent = LDumbell
		end
	end
end

local function Detach_Obj(Plr: Player, Machine : Instance)
	if (Plr ~= nil and Machine ~= nil) then
		if (Plr.Character:FindFirstChild("GymObj")) then

			Plr.Character:FindFirstChild("GymObj"):Destroy()

			if (Machine:FindFirstChild("Barbell") ~= nil) then
				for _, part in pairs(Machine:FindFirstChild("Barbell"):GetChildren()) do
					if part:IsA("BasePart") then
						part.Transparency = 0
					end
				end
			end

		elseif (Plr.Character:FindFirstChild("LDumbell")) then
			Plr.Character:FindFirstChild("LDumbell"):Destroy()
			Plr.Character:FindFirstChild("RDumbell"):Destroy()

			if (Machine:FindFirstChild("Dumbells") ~= nil) then
				for _, part in pairs(Machine:FindFirstChild("Dumbells"):GetChildren()) do
					if part:IsA("BasePart") then
						part.Transparency = 0
					end
				end
			end
		end
	end
end

local function Reward_Player(player : Player)
	
	local randomRoll = math.random(1, 100) 
	local reward_value = randomRoll == 1 and 100 or 5 --1% chance to get 100 cash instead of 5
	PlayerUtils.RewardPlayer(player, "Coins", reward_value)
	
	--if randomRoll == 1 then -- 1% chance
	--	--print(player.Name .. " earned 5 GEMS!")
	--	local Gem_Val = Get_Player_Val(player, "Gems")
	--	if(Gem_Val ~= nil)then
	--		Gem_Val.Value += 5
	--	end
	--else
	--	--print(player.Name .. " earned some cash.")
	--	local Cash_Val = Get_Player_Val(player, "Coins")
	--	if(Cash_Val ~= nil)then
	--		Cash_Val.Value += 1
	--	end
	--end
end

local function Update_Stats(Plr : Player, bool : boolean, Object : Instance)
	--// update the stats on the ui and training
	if (Plr ~= nil and Plr.Character ~= nil) then

		local IsTraining, Machine = Check_Training(Plr)
		if (IsTraining == true and bool == true) then
			if (Plr.Character:FindFirstChild("HumanoidRootPart"):FindFirstChild("Training_Stats_UI") == nil) then
				--// start training
				local UI = script:WaitForChild("Training_Stats_UI"):Clone()
				UI.Parent = Plr.Character:FindFirstChild("HumanoidRootPart")
				UI.Adornee = Plr.Character:FindFirstChild("HumanoidRootPart")
				UI.Enabled = true

				if (Most_Time_Spent == Plr.Name and Server_Plr_Times[Plr.Name] ~= nil) then
					UI.Main_F.Longest_Trainer_F.Data_Txt.Text = string.format("%02i:%02i", Server_Plr_Times[Plr.Name]/60, Server_Plr_Times[Plr.Name]%60)
					UI.Main_F.Longest_Trainer_F.Visible = true
				end

				if (Object ~= nil and Object.Name == "Treadmill") then
					Cons[Plr.Name] = {}

					Cons[Plr.Name].Connection = task.spawn(function()
						Player_Times[Plr.Name] = 0
						local current_Time = 0
						local Countdown = 31
						local machine_stats = Machine.Stats

						--// time
						while task.wait(1) do

							--local Check_Training, Machine_Obj = Check_Training(Plr)
							--if not Check_Training then break end
							if not Cons[Plr.Name] then break end
							
							if Plr:FindFirstChild("Player_Data") then
								if Plr.Player_Data:FindFirstChild("Gym Training") then
									Plr.Player_Data["Gym Training"].Value += 1
								end
							end

							Countdown -= 1
							current_Time += 1
							Player_Times[Plr.Name] += 1
							UI.Main_F.Countdown_Timer_F.Data_Txt.Text = tostring(Countdown).."s"
							UI.Main_F.Current_Timer_F.Data_Txt.Text = string.format("%02i:%02i", machine_stats.Time_Spent.Value/60, machine_stats.Time_Spent.Value%60)
							machine_stats.Time_Spent.Value = Player_Times[Plr.Name]

							if current_Time >= 30 then -- every 30 seconds rep time for treadmil
								current_Time = 0

								if Machine and Machine:FindFirstChild("Stats") then
									machine_stats.Reps.Value += 1
									UI.Main_F.Rep_Counter_F.Data_Txt.Text = tostring(machine_stats.Reps.Value).." Reps"
								end
							end

							if (Countdown <= 0) then
								--// reward player cash or gems etc.. 
								--// reward player reward
								Reward_Player(Plr)
								Countdown = 31 -- default
							end
						end
					end)


				elseif (Object ~= nil and Machine:FindFirstChild("Stats") ~= nil) then --and Object.Name == "BenchPress" or Object.Name == "SquatRack"

					local machine_stats = Machine.Stats

					if (Object:FindFirstChild("Barbell") ~= nil) then
						Weld_Obj(Plr, Object:FindFirstChild("Barbell"))
					elseif (Object:FindFirstChild("Dumbells") ~= nil) then
						Weld_Obj(Plr, Object:FindFirstChild("Dumbells"))
					end

					Cons[Plr.Name] = {}
					Cons[Plr.Name].Connection = task.spawn(function()
						Player_Times[Plr.Name] = 0
						local current_Time = 0
						local Countdown = 31

						--// time
						while task.wait(1) do

							--local Check_Training, Machine_Obj = Check_Training(Plr)
							--if not Check_Training then break end
							if not Cons[Plr.Name] then break end

							if not UI then break end
							
							if Plr:FindFirstChild("Player_Data") then
								if Plr.Player_Data:FindFirstChild("Gym Training") then
									Plr.Player_Data["Gym Training"].Value += 1
								end
							end

							Countdown -= 1
							current_Time += 1
							Player_Times[Plr.Name] += 1
							UI.Main_F.Countdown_Timer_F.Data_Txt.Text = tostring(Countdown).."s"
							UI.Main_F.Current_Timer_F.Data_Txt.Text = string.format("%02i:%02i", machine_stats.Time_Spent.Value/60, machine_stats.Time_Spent.Value%60)
							machine_stats.Time_Spent.Value = Player_Times[Plr.Name]

							if current_Time >= 30 then -- every 30 seconds rep time for treadmil
								current_Time = 0
							end

							if (Countdown <= 0) then
								Reward_Player(Plr)
								Countdown = 31 -- default
							end
						end
					end)

					if (Machine.Name ~= "Pusher") then
						Cons[Plr.Name].Event = Workout_Rep.OnServerEvent:Connect(function(player)
							if (player.Name == Plr.Name) then
								local now = tick()
								if last_RepTime[player.Name] and now - last_RepTime[player.Name] < 1 then
									return
								end

								last_RepTime[player.Name] = now
								--// plus 1 rep 
								if Machine and Machine:FindFirstChild("Stats") then
									machine_stats.Reps.Value += 1
									UI.Main_F.Rep_Counter_F.Data_Txt.Text = tostring(machine_stats.Reps.Value).." Reps"
								end
							end
						end)
					elseif (Machine.Name == "Pusher") then
						local initialMachineCFrame = Machine:FindFirstChild("Push").PrimaryPart.CFrame
						local initialPlayerCFrame = Plr.Character.HumanoidRootPart.CFrame
						local PushMachine = Machine:FindFirstChild("Push")
						
						Cons[Plr.Name].Event = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
							if (Plr.Character:FindFirstChild("Humanoid") ~= nil) then
								
								local distance = (Machine:FindFirstChild("End_HitBox").Position - Plr.Character.HumanoidRootPart.Position).Magnitude
								
								local direction = PushMachine.PrimaryPart.CFrame.LookVector
								PushMachine:PivotTo(PushMachine.PrimaryPart.CFrame + direction * 2 * deltaTime)

								local offset = -PushMachine.PrimaryPart.CFrame.LookVector * 3.5
								Plr.Character.HumanoidRootPart.CFrame = PushMachine.PrimaryPart.CFrame * CFrame.new(offset.X, 1.1, offset.Z)
								
								if distance < 4 then
									-- Reset Pusher
									Machine:FindFirstChild("Push"):PivotTo(initialMachineCFrame)
									Plr.Character.HumanoidRootPart.CFrame = initialPlayerCFrame

									if Machine and Machine:FindFirstChild("Stats") then
										machine_stats.Reps.Value += 1
										UI.Main_F.Rep_Counter_F.Data_Txt.Text = tostring(machine_stats.Reps.Value).." Reps"
									end
								end	
							end
							task.wait(0.1)
						end)
					end
				end
			end
		elseif (IsTraining == true and bool == false) then-- end training reset everything finished training

			if (Plr.Character:FindFirstChild("HumanoidRootPart"):FindFirstChild("Training_Stats_UI")) then
				Plr.Character:FindFirstChild("HumanoidRootPart"):FindFirstChild("Training_Stats_UI"):Destroy()
			end

			for _, machine in pairs(Machines_F:GetChildren()) do
				if (machine ~= nil and machine:FindFirstChild("Stats")) then
					if (machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == Plr.Name) then
						machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value = ""
						machine:FindFirstChild("Stats"):FindFirstChild("Reps").Value = 0
						machine:FindFirstChild("Stats"):FindFirstChild("Time_Spent").Value = 0
						break
					end
				end
			end

			if (Machine:FindFirstChild("Barbell") ~= nil or Machine:FindFirstChild("Dumbells") ~= nil) then
				Detach_Obj(Plr, Machine)
			end
			
			if (Machine.Name == "Pusher") then
				Machine:FindFirstChild("Push"):PivotTo(CFrame.new(Machine:FindFirstChild("Push").PrimaryPart.CFrame.X,Machine:FindFirstChild("Push").PrimaryPart.CFrame.Y,-247.739))
			end
	
			if (Prompts[Plr.Name]) then
				Prompts[Plr.Name].Enabled = true
				Prompts[Plr.Name] = nil
			end

			if (Server_Plr_Times[Plr.Name] == nil and Player_Times[Plr.Name] ~= nil) then
				Server_Plr_Times[Plr.Name] = Player_Times[Plr.Name]
			elseif (Server_Plr_Times[Plr.Name] ~= nil and Player_Times[Plr.Name] ~= nil) then
				if (Player_Times[Plr.Name] >= Server_Plr_Times[Plr.Name]) then
					Server_Plr_Times[Plr.Name] = Player_Times[Plr.Name]
				end
			end

			if (last_RepTime[Plr.Name] ~= nil) then
				last_RepTime[Plr.Name] = nil
			end

			if (Cons[Plr.Name]) then
				Disconnect_PlrCons(Plr.Name)
			end
		end
	end
	task.wait()
end

--// setup all the proximity prompts and triggering the basic stuff
local function Setup_Gym() -- dumbells, gymfloormat, treadmill, benchpress, pusher, squatrack
	local Machines = Machines_F:GetChildren()

	for i = 1, #Machines do
		local Machine = Machines[i]
		if(Machine ~= nil and Machine:FindFirstChild("ProximityPrompt", true)) then 
			--if (Machine.Name == "Treadmill") then
			Machine:FindFirstChild("ProximityPrompt", true).Triggered:Connect(function(Plr)
				if (Prompts[Plr.Name] == nil) then
					Prompts[Plr.Name] = Machine:FindFirstChild("ProximityPrompt", true)
					Prompts[Plr.Name].Enabled = false
					if (Machine:FindFirstChild("Stats") ~= nil and Machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == "") then
						if (Plr.Character:FindFirstChild("Humanoid")) then
							local char = Plr.Character
							Machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value = Plr.Name
							char:FindFirstChild("HumanoidRootPart"):PivotTo(Machine:FindFirstChild("Player_Pos").CFrame)
							Init_Gym_Training:FireClient(Plr, true)
							Update_Stats(Plr, true, Machine)
							task.wait(.3)
							char:FindFirstChild("HumanoidRootPart").Anchored = true
						end
					end
				end
			end)
		end
	end

	task.spawn(function()
		while task.wait(100) do
			Check_Most_Time()
		end
	end)
end

local function Exit_Machine(Plr : Player) -- // exit the machine and reset everything 
	task.spawn(Check_Most_Time)
	Update_Stats(Plr, false, nil)
	
	local playerCharacter = Plr.Character
	local hrp:BasePart = playerCharacter:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("Can't get HRP for player",Plr.Name)
		return
	end
	
	if (hrp ~= nil) then
		hrp.Anchored = false
	end

	if (Cons[Plr.Name]) then
		Disconnect_PlrCons(Plr.Name)
	end

	Init_Gym_Training:FireClient(Plr, false)
end

Exit_Machine_E.OnServerEvent:Connect(Exit_Machine)
Setup_Gym()

--// setup player removing and make sure everything is cleaned up and reset in-case they were using a machine and remove them from the server time table
game:GetService("Players").PlayerRemoving:Connect(function(Plr)
	if (Prompts[Plr.Name]) then
		--local Last_Used = nil

		for _, machine in pairs(Machines_F:GetChildren()) do
			if (machine ~= nil and machine:FindFirstChild("Stats")) then
				if (machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == Plr.Name) then
					machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value = ""
					machine:FindFirstChild("Stats"):FindFirstChild("Reps").Value = 0
					machine:FindFirstChild("Stats"):FindFirstChild("Time_Spent").Value = 0
					--Last_Used = machine
					break
				end
			end
		end

		if (Prompts[Plr.Name]) then
			Prompts[Plr.Name].Enabled = true
			Prompts[Plr.Name] = nil
		end	

		if (Cons[Plr.Name]) then
			Disconnect_PlrCons(Plr.Name)
		end
	end
	
	Player_Times[Plr.Name] = nil
	Server_Plr_Times[Plr.Name] = nil
end)]]></ProtectedString>
							<string name="ScriptGuid">{A7E40BE6-13BC-4FDE-B528-C70C42BF003C}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Training_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX61BDF336D9FA4DC097E293A23C9104B7">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Gym_Reward_Handle.server.lua
--
--  Description:
--      Manages gym reward events where players race to hit a highlighted
--      object (punching bag or mannequin). First to strike wins a prize.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-09-29 by Oriane
--
--  Version: V2025-09
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/GymObjects/BoxingManequins/BoxingMannequin
--          * Main_World_F/Objects/GymObjects/PunchingBag
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events/Display_Data
--          * Channels_F/Server_Client_F/Events/Gym_Reward_Testing
--          * Channels_F/Client_Server_F/Events/Gym_Reward_Testing
--          * Channels_F/Bindable_F/Events/Equipment_Strike
--      - Roblox Services:
--          * Players
--
--  Notes:
--      - Designed for a single gym reward event per server
--      - Dynamically selects a punching bag or mannequin for the event
--      - Uses a highlight to mark the selected event object
--      - Sends countdown and result notifications to all clients
--      - Rewards the winning player with a random item from a list
--      - Resets the event after a delay
--      - Cleans up highlight and event state after completion
--
--======================================================================

-- Modules
local DataMods = game:GetService("ReplicatedStorage"):WaitForChild("Data_Mods_F")
local RewardsMod = require(DataMods:WaitForChild("Rewards_Mod"))
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Utils = require(game.ReplicatedStorage.Modules.Utils)
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels = require(game.ReplicatedStorage.Modules.Channels)

-- Events configuration
local Display_Data_E 		=  Channels.SC_Remote_Events.Display_Data
local Gym_Reward_Testing 	= Channels.CS_Remote_Events.Gym_Reward_Testing
local Gym_Reward_Update 	= Channels.Bindable_Events.Gym_Reward_Update
local Equipment_Strike_E	= Channels.Bindable_Events.Equipment_Strike

local GymHighlightTemplate = game.ReplicatedStorage:WaitForChild("Models"):WaitForChild("GymEventAssets"):WaitForChild("Highlight")

local Event_Messages_Color = RewardsMod.Gym_Rewards_Messages_Color ----Color3.fromRGB(255, 208, 21)
--local Event_TimeFrame = RewardsMod.Gym_Rewards_TimeFrame -- 5 minutes
local Event_Duration = RewardsMod.Gym_Rewards_Duration -- 15 secondes
local Event_Data = RewardsMod.Gym_Rewards_Data

local function Get_Children_By_Name(folder, name)
	local results = {}
	for _, obj in ipairs(folder:GetChildren()) do
		if obj.Name == name then
			table.insert(results, obj)
		end
	end
	return results
end

local function Concat_Lists(a, b)
	local result = {}
	for _, v in ipairs(a) do
		table.insert(result, v)
	end
	for _, v in ipairs(b) do
		table.insert(result, v)
	end
	return result
end

local GymObjects = Utils.SafePath(workspace, {
	"Main_World_F", "Gameplay", "Objects", "GymObjects"
})
if not GymObjects then return end

local Manequins = Get_Children_By_Name(GymObjects.BoxingManequins, "BoxingMannequin")
local BoxingBags = Get_Children_By_Name(GymObjects.PunchingBags, "PunchingBag")
local CandidateObjects = Concat_Lists(Manequins, BoxingBags)

-- Event state
local EventActive = false
local RewardGiven = false
local Highlight = nil

-- Random object selection
local function getRandomObject()
	return CandidateObjects[math.random(1, #CandidateObjects)]
end

-- Add highlight to the chosen Object 
local function highlightObject(obj)
	Highlight = GymHighlightTemplate:Clone()
	Highlight.Parent = GymObjects
	Highlight:PivotTo(obj.PrimaryPart.CFrame)
end

-- Remove highlight
local function unhighlightObject()
	if Highlight then
		Highlight:Destroy()
		Highlight = nil
	end
end

---- Reward the winning player
--local function Give_Reward(player, reward)
--	-- apply reward to player data
--	local PD = player:FindFirstChild("Player_Data")
--	if PD and reward then
--		if reward.type == "Coins" or reward.type == "Cash" then
--			local coins = PD:FindFirstChild("Coins")
--			if coins then
--				coins.Value += reward.amount
--			end
--		elseif reward.type == "Gems" then
--			local gems = PD:FindFirstChild("Gems")
--			if gems then
--				gems.Value += reward.amount
--			end
--		end
--	end
--end

-- Save player's reward count to DataStore
local function Save_DataStore(player)
	local plrData = player:FindFirstChild("Player_Data")
	if not plrData then return false end

	local gymEventRewards = plrData:FindFirstChild("GymEventRewards")
	if not gymEventRewards then
		return false
	end
	gymEventRewards.Value = gymEventRewards.Value+1
	return true
end

local function Send_Message(msg, color)
	Display_Data_E:FireAllClients(msg, color)
end

-- Start event on a random object at a random time in the timeframe
local function Start_Gym_Event(reward)
	if EventActive then return end
	EventActive = true
	RewardGiven = false

	local chosenObject = getRandomObject()
	highlightObject(chosenObject)
	Sound_Mod.PlaySFX(chosenObject, "Start_Fight_Bell_SE")

	local msg = "🎯 Golden Punch target identified in the Gym! Be the first to hit it!"
	Send_Message(msg, Event_Messages_Color)

	-- Detect strike on the chosen object
	Equipment_Strike_E.Event:Connect(function(player, equipment)
		if EventActive and not RewardGiven then
			if chosenObject and chosenObject.Parent then
				if (equipment == chosenObject or equipment.Parent == chosenObject) then
					RewardGiven = true
					local msg = "🏆 "..player.Name .." won the Golden Punch reward! ".. reward.label
					Send_Message(msg, Event_Messages_Color)

					-- ✅ Reward for the player
					PlayerUtils.RewardPlayer(player, reward.type, reward.amount)
					-- Store the reward in the player's datastore
					Save_DataStore(player)

					unhighlightObject()
					EventActive = false
					-- Only for testing
					Gym_Reward_Testing:FireAllClients(false, 0)
				end
			end
		end
	end)

	for i = Event_Duration, 1, -1 do
		if EventActive and not RewardGiven then
			-- Update countdown 
			Gym_Reward_Update:Fire(i)
			-- Only for testing
			Gym_Reward_Testing:FireAllClients(true, i)
		end
		task.wait(1)
	end

	if EventActive and not RewardGiven then
		local msg = "⏳ Golden Punch ended. No one won the reward."
		Send_Message(msg, Event_Messages_Color)
		
		unhighlightObject()
		EventActive = false
		
		-- Only for testing
		Gym_Reward_Testing:FireAllClients(false, 0)
	end
end


local function LaunchGymEvent(timeframe, reward)
	-- Only for testing
	Gym_Reward_Testing:FireAllClients(true, 0)
	
	local msg = "🥊 Golden Punch incoming in less than " .. timeframe .. "min! Get ready!"
	Send_Message(msg, Event_Messages_Color)

	local Delay_Before_Start_In_Sec = math.random(0, timeframe * 60)	
	task.delay(Delay_Before_Start_In_Sec, function()
		Start_Gym_Event(reward)
	end)
end

Utils.SecureRemote(
	Gym_Reward_Testing,
	function(player)
		-- Optional: restrict to developers or group roles
		if not PlayerUtils.IsDeveloper(player) then
			return -- block non-authorized use
		end

		LaunchGymEvent(0.5, { type="Coins", amount=500, label="+500 💵" })
	end,
	{},
	{
		RateLimit = 1,
		MaxBurst = 5,
		PunishThreshold = 3
	}
)

-- 🔹 Daily Event Scheduler (UTC)
-- Launch event every day on a random time in the timeframe bginning at Event_Start_Hour
task.spawn(function()
	while true do
		local now = os.date("!*t") -- UTC (avoid DST issues)
		local Now_Minutes = now.hour * 60 + now.min	

		for _,RewardData in ipairs(Event_Data) do
			local Event_Start_Hour = RewardData.Event_Start_Hour
			local Target_Minutes = Event_Start_Hour * 60 
			if Now_Minutes == Target_Minutes then
				if Utils.GetServerType() == "Public" then
					LaunchGymEvent(RewardsMod.Gym_Rewards_TimeFrame, RewardData.reward)
				end
			end 
		end
		task.wait(60) -- Check Every Minute
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{8197EF78-503D-4B05-B6F8-05D4733CE051}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Gym_Reward_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8211CDB5117245ABB842CC346CDE9E81">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Unique_Codes_Handle.lua
--
--  Description:
--      Handles one-time unique code redemption and rewards for players.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ServerScriptService:
--          * Codes_Unique 
--      - StarterGui:
--          * Codes_UI
--      - Roblox Services:
--          * DataStoreService (UsedUniqueCodes_FINAL DataStore)
--          * ServerStorage
--
--  Notes:
--      - Uses UpdateAsync to prevent race conditions
--      - Validates input code (string, trimmed, uppercase, max length)
--      - Wraps reward execution in pcall for safety
--
--======================================================================

-- Services
local ServerStorage = game:GetService("ServerStorage")
local DataStoreService = game:GetService("DataStoreService")
local UsedCodesStore = DataStoreService:GetDataStore("UsedUniqueCodes_FINAL")

-- Modules
local Codes = require(game.ServerScriptService.Modules.Codes_Unique)
local RewardModules = ServerStorage:WaitForChild("Rewards")

-- Track player cooldowns
local debounceList = {}
game.Players.PlayerAdded:Connect(function(plr)
	debounceList[plr.UserId] = 0
end)
game.Players.PlayerRemoving:Connect(function(plr)
	debounceList[plr.UserId] = nil
end)

-- Utility: sanitize and normalize input code
local function sanitizeCode(input)
	if type(input) ~= "string" then return nil end
	local s = input:match("^%s*(.-)%s*$") -- trim
	if #s == 0 or #s > 128 then return nil end
	return s:upper()
end

script.Function.OnInvoke = function(player: Player, code: any)
	-- Rate limiting per player (by UserId)
	local last = debounceList[player.UserId]
	if last and (tick() - last) <= 1 then
		debounceList[player.UserId] = tick()
		return "? Too many requests. Try again later!"
	end
	debounceList[player.UserId] = tick()

	-- Validate player data container
	local playerData = player:FindFirstChild("Player_Data")
	if not playerData then
		return "? Player data not ready. Try again later!"
	end

	local UniqueCodeUsed = playerData:FindFirstChild("UniqueCodeUsed")
	if UniqueCodeUsed and UniqueCodeUsed.Value then
		return "? Already used a code before!"
	end

	-- Sanitize and normalize code
	local safeCode = sanitizeCode(code)
	if not safeCode then
		return "? Invalid Code format!"
	end

	-- Find code in server-side list
	local codeFound, codeData
	for _, codeInfo in Codes do
		if type(codeInfo.Code) == "string" and codeInfo.Code:upper() == safeCode then
			codeFound = true
			codeData = codeInfo
			break
		end
	end
	if not codeFound then
		return "? Invalid Code! Please try another!"
	end

	-- Atomic check-and-set in DataStore
	local wonRedeem = false
	local ok, err = pcall(function()
		UsedCodesStore:UpdateAsync(safeCode, function(old)
			if old then
				return old -- already redeemed
			end
			wonRedeem = true
			return {
				userId = player.UserId,
				username = player.Name,
				time = os.time()
			}
		end)
	end)
	if not ok then
		warn("DataStore UpdateAsync failed:", err)
		return "? Error checking code. Try again later."
	end
	if not wonRedeem then
		return "? This code has already been redeemed!"
	end

	-- Load reward module safely
	local rewardName = codeData.Reward
	local rewardModule = RewardModules:FindFirstChild(rewardName)
	if not rewardModule or not rewardModule:IsA("ModuleScript") then
		warn("Reward module missing or invalid:", rewardName)
		return "? Reward not available. Contact support."
	end

	local successRequire, giveReward = pcall(require, rewardModule)
	if not successRequire or type(giveReward) ~= "function" then
		warn("Invalid reward module:", rewardName)
		return "? Reward handler error. Contact support."
	end

	local okReward, rewardErr = pcall(function()
		giveReward(player)
	end)
	if not okReward then
		warn("Reward execution failed:", rewardErr)
		return "? Failed to give reward. Contact support."
	end

	-- Mark player as having used a code
	if UniqueCodeUsed then
		UniqueCodeUsed.Value = true
	end

	return "✅ Successfully Redeemed Code!"
end]]></ProtectedString>
							<string name="ScriptGuid">{19F5F163-823D-412C-B200-C4EA672404DB}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Unique_Codes_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX79B1D28823474DA7ABFB40D9D53C17A8">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/UGC_Pack_Handle.lua
--
--  Description:
--      Server-side module managing UGC (User Generated Content) packs.
--      Handles ownership validation, accessory application, cleanup,
--      and MarketplaceService integration for bulk purchases.
--      Communicates with client remotes for preview and purchase flow.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-14 by Dark
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * ReplicatedStorage (Remotes, Data_Mods_F, OfferItems)
--          * MarketplaceService (ownership & purchases)
--          * InsertService (load assets dynamically)
--          * Players (join handling & attributes)
--          * Workspace (Main_World_F, Objects)
--
--      - Module Scripts:
--          * Data_Mods_F.UGC_Pack_Config
--          * Data_Mods_F.Offers_Config.OfferStorageData_Mod
--
--  Features:
--      - Player_Owns_Item_UGC_ServerCheck : verifies item ownership safely
--      - giveAccessory                     : loads and attaches accessories
--      - CleanUpPlayer                     : removes all accessories reliably
--      - applyPack                         : applies a full UGC pack to player
--      - SetUpBulkPurchase                 : prepares and triggers bulk buy
--      - Remote events for Apply/Show avatar flows
--      - Automatic player initialization and pack restoration
--
--  Notes:
--      - Uses InsertService for fallback asset loading — requires universe permission
--      - Pack definitions must exist in UGC_Pack_Config.UGCPacks
--      - Add rate limiting or validation via RemoteUtils if used in production
--
--======================================================================

-- Services
local RS  						= game:GetService("ReplicatedStorage")
local MPS 						= game:GetService("MarketplaceService")
local Server_Context 			= workspace:WaitForChild("Server_Context")

-- Modules
local Data_Mods_F       		= RS:WaitForChild("Data_Mods_F")
local UGC_Pack_Config    		= require(Data_Mods_F:WaitForChild("UGC_Pack_Config"))
local Offers_SavedData    		= require(Data_Mods_F.Offers_Config.OfferStorageData_Mod)
local PlayerUtils 				= require(game.ReplicatedStorage.Modules.PlayerUtils)
local Utils 					= require(game.ReplicatedStorage.Modules.Utils)
local Global_Params_Mod			= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))
-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local ShowAvatarAndGetTriggerRE = Channels.UGC_Pack.ShowAvatarAndGetTriggerRE

-- Workspace references
local UGCPacks 					= RS.Models.UGC.OfferItems.UGCPacks

for _, model in ipairs(UGCPacks:GetChildren()) do
	if model:FindFirstChild("Humanoid") then
		local humanoid = model.Humanoid
		humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
	end
end

local function SetUpBulkPurchase(plr,PackId)
	local Pack = UGC_Pack_Config.UGCPacks[PackId]

	local lineItems={}
	for _, item in ipairs(Pack.items) do

		table.insert(lineItems,{ Id = item.id, Type = Enum.MarketplaceProductType.AvatarAsset})
	end

	MPS:PromptBulkPurchase(plr, lineItems, {})
end

game.Players.PlayerAdded:Connect(function(plr)

	local character = plr.Character or plr.CharacterAdded:Wait()
	
	if Server_Context.Mode.Value == Global_Params_Mod.Server_Mode.TOURNAMENT then
		return
	end
	
	local Saved = Offers_SavedData.LoadOfferState("UGCActivePack",plr)
	local packId=nil
	if Saved~=nil then
		packId = Saved.ActivePack
	end
	local PackNames={}
	local Packs = UGC_Pack_Config.UGCPacks
	local MAX_PACKS = 4
	local sent = 0

	-- Walk Pack1, Pack2, ... until we run out OR send 4 packs
	for i = 1, math.huge do
		local packName = "Pack"..i
		local pack = Packs[packName]
		if not pack then break end

		-- collect only items the player doesn't own
		local itemsToShow = {}
		for _, item in ipairs(pack.items) do
			if not PlayerUtils.Player_Owns_Item_UGC_ServerCheck(plr, item.id) then
				itemsToShow[#itemsToShow+1] = {
					Id = item.id,
					Type = Enum.MarketplaceProductType.AvatarAsset,
					task.wait(0.25)
				}
			end
		end

		-- skip packs where the player owns everything
		if #itemsToShow > 0 then
			table.insert(PackNames,packName)
			sent += 1
			task.wait(1)
			if sent >= MAX_PACKS then break end
		end
	end
	ShowAvatarAndGetTriggerRE:FireClient(plr, PackNames)
end)

--ShowAvatarAndGetTriggerRE.OnServerEvent:Connect(function(player, PackId)
--	SetUpBulkPurchase(player,PackId)
--end)

Utils.SecureRemote(
	ShowAvatarAndGetTriggerRE,
	function(player, packId)

		-- Validate PackId (string "Pack1", "Pack2", etc.)
		if typeof(packId) ~= "string" then return end
		if not UGC_Pack_Config.UGCPacks[packId] then return end

		SetUpBulkPurchase(player, packId)
	end,
	{ "string" }, -- expected args
	{
		RateLimit = 1,
		MaxBurst = 5,
		PunishThreshold = 10
	}
)]]></ProtectedString>
							<string name="ScriptGuid">{05A62322-F384-436E-95BA-9B49A9800933}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UGC_Pack_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX736F29A752A4435E88A7FD9A93075929">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/OffersService.lua
--
--  Description:
--      Manages limited-time offers, UGC items, DevProducts, and Gamepasses.
--      Exposes RemoteEvents/RemoteFunctions to clients for requesting and 
--      redeeming offers, and triggers MarketplaceService purchases.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-09-30 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Monetization_Mod
--          * Data_Mods_F/Offers_Config
--          * Remotes/Offers/... (RemoteEvents & RemoteFunctions)
--      - Roblox Services:
--          * MarketplaceService
--          * ReplicatedStorage
--      - Player Instances:
--          * Player.Player_Data.Coins (used for internal currency offers)
--
--  Notes:
--      - Dynamically creates missing RemoteEvents/RemoteFunctions at startup
--      - Validates offers against Offers_Config before purchase
--      - Handles DevProduct, UGC, and Gamepass purchases via MarketplaceService
--      - Supports internal currency ("Coins") for Gamepass-style offers
--      - Uses DataStoreService for persistent offer redemption tracking
--      -
--
--======================================================================
-- Services
local RS  = game:GetService("ReplicatedStorage")
local MPS = game:GetService("MarketplaceService")

-- Modules
local Data_Mods_F       = RS:WaitForChild("Data_Mods_F")
local Monetization_Mod  = require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Offers_Config    	= require(Data_Mods_F:WaitForChild("Offers_Config"))
local Utils 			= require(game.ReplicatedStorage.Modules.Utils)
local Offers_SavedData  = require(game.ReplicatedStorage.Data_Mods_F.Offers_Config.OfferStorageData_Mod)

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Grant_Gamepass_Perks		= Channels.Bindable_Events.Grant_Gamepass_Perks
local GetActiveOffers 			= Channels.Offers.GetActiveOffers
local RequestPurchase 			= Channels.Offers.RequestPurchase
local SendOfferToClient 		= Channels.Offers.SendOfferToClient
local ShowOfferSignalBind 		= Channels.Offers.ShowOfferSignalBind
local GetNewClothOffer			= Channels.Offers.GetNewClothOffer
local ClothItemIdSignal 		= Channels.Offers.ClothItemIdSignal
local SendUGCOfferToClient 		= Channels.Offers.SendUGCOfferToClient
local ShowMessage 				= Channels.Offers.ShowMessage
local Open_InsufficientFundsRE 	= Channels.Offers.Open_InsufficientFunds
local Shop_Item_Purchased = Channels.SC_Remote_Events.Shop_Item_Purchased

-- UI References
local Main_World_F = workspace:WaitForChild("Main_World_F")
local Gameplay = Main_World_F:WaitForChild("Gameplay")
local Offers_Data = Gameplay:WaitForChild("Shop"):WaitForChild("Offers_Data")
local podiums = Offers_Data.UGCPodiums:GetChildren()


local runningOffers={}
local allActiveOffers={}
local TIME_IN_DAYS_UGC = 4 * 24 * 60 * 60
local ITEM_PURCHASED = "✅ Item purchased you can equip it on your avatar!"

local function SendClientAUGCOffer(plr,PodiumName)
	local offer 
	if  next(allActiveOffers) == nil or #allActiveOffers<=0 then
		local best,allOffers = Offers_Config.GetUGCItemNew(plr)
		allActiveOffers = allOffers
	end
	local rand=math.random(1, #allActiveOffers)
	if PodiumName==podiums[1].Name then
		rand=1
	end
	offer = allActiveOffers[rand]
	table.remove(allActiveOffers,rand)

	if runningOffers[PodiumName].Key == offer.Key then
		SendClientAUGCOffer(plr,PodiumName)
		task.wait()
		return
	end
	offer.EndsAt=os.time()+TIME_IN_DAYS_UGC
	Offers_SavedData.SaveUGCOfferState("UGC_1_",PodiumName,plr,offer.RefName,offer.EndsAt)
	local prio, key, title = Offers_Config.parseName(offer.RefName)
	plr:SetAttribute("MyUGCID"..PodiumName,key)
	runningOffers[PodiumName]=offer
	SendUGCOfferToClient:FireClient(plr,offer,PodiumName)
end

local function PurchaseUGC(plr,Name)

	local key =plr:GetAttribute("MyUGCID"..Name)
	MPS:PromptPurchase(plr, key)

end

local function podiumInitialSetUp()

	table.sort(podiums, function(a, b)
		local aNum = tonumber(a.Name:match("^(%d+)"))
		local bNum = tonumber(b.Name:match("^(%d+)"))
		return (aNum or math.huge) < (bNum or math.huge)
	end)

	local function Create_Prompt_Part(podium)
		local P = Instance.new("Attachment", podium)
		P.Name = "OfferAttachment"
		local Prompt = Instance.new("ProximityPrompt", P)
		Prompt.Name = "Prompt"
		Prompt.ClickablePrompt = true
		Prompt.Enabled = true
		Prompt.HoldDuration = 0
		Prompt.MaxActivationDistance = 10
		Prompt.RequiresLineOfSight = false
		Prompt.ActionText = "Purchase"
		Prompt.ObjectText = "Item" .. "!"
		local iFolder = Instance.new("Folder", podium)
		iFolder.Name = "Item"
		return Prompt
	end
	for i, pn in ipairs(podiums) do
		local existingAttach = pn:FindFirstChildOfClass("Attachment")
		local existingPrompt = existingAttach and existingAttach:FindFirstChildOfClass("ProximityPrompt")
		if not existingPrompt then
			existingPrompt=Create_Prompt_Part(pn)
		end
		existingPrompt.Triggered:Connect(function(player)
			PurchaseUGC(player,pn.Name)
		end)
		existingPrompt.Enabled=false
	end

end
podiumInitialSetUp()

function GetNewClothOffer.OnServerInvoke(plr)
	local function IsSameDay(t1)
		local d1 = os.date("!*t", t1)
		local d2 = os.date("!*t", os.time())
		return d1.year == d2.year and d1.yday == d2.yday
	end
	task.wait(1)
	local countData=Offers_SavedData.LoadOfferState("ClothOfferCount",plr)
	local count = 0
	if countData then
		count = countData.PurchasedCount
		if not IsSameDay(countData["LastPurchasedDate"]) then
			count=0
		end
	end


	if count>=3 then
		return nil
	end
	local top = Offers_Config.GetAndCreateClothOffer(plr)
	if not top then return nil end
	return top
end

function GetActiveOffers.OnServerInvoke(plr)
	local top = Offers_Config.pickTopOffer(plr)
	if not top then return {} end
	return { top }
end

game.Players.PlayerAdded:Connect(function(plr)
	local now = os.time()
	local function removeValue(t, value)
		for i, v in ipairs(t) do
			if v == value then
				table.remove(t, i)
				return
			end
		end
	end

	local best,allOffers = Offers_Config.GetUGCItemNew(plr)
	allActiveOffers=allOffers
	local allSavedOffers = Offers_SavedData.LoadOfferState("UGC_1_",plr)
	local activeOffers = allSavedOffers and allSavedOffers.ActiveOffer or {}
	if activeOffers~=nil and next(activeOffers) ~= nil then
		for i, pn in ipairs(podiums) do

			local offer=nil
			local rawoffer = activeOffers[pn.Name]
			if rawoffer then
				offer = Offers_Config.GenerateUGCSavedOffer(rawoffer.CurrentKey)
				if (rawoffer.EndsAt-now)<=0 then
					offer.EndsAt = now+120
				else
					offer.EndsAt = rawoffer.EndsAt
				end
			else
				removeValue(allActiveOffers,best)
				if pn.Name==podiums[1].Name then
					offer = best
				else
					local rand = math.random(1, #allActiveOffers)
					offer=allActiveOffers[rand]
					table.remove(allActiveOffers,rand)
				end
				offer.EndsAt=now+TIME_IN_DAYS_UGC

				Offers_SavedData.SaveUGCOfferState("UGC_1_",podiums[i].Name,plr,offer.RefName,offer.EndsAt)
			end
			local prio, key, title = Offers_Config.parseName(offer.RefName)
			plr:SetAttribute("MyUGCID"..podiums[i].Name,key)
			runningOffers[podiums[i].Name]=offer
			SendUGCOfferToClient:FireClient(plr,offer,podiums[i].Name)
		end
	else
		for i, pn in ipairs(podiums) do
			local PodiumName = pn.Name
			local rand=math.random(1, #allActiveOffers)
			if PodiumName==podiums[1].Name then
				rand=1
			end
			local offer=allActiveOffers[rand]
			table.remove(allActiveOffers,rand)
			offer.EndsAt=os.time()+TIME_IN_DAYS_UGC
			Offers_SavedData.SaveUGCOfferState("UGC_1_",PodiumName,plr,offer.RefName,offer.EndsAt)
			local prio, key, title = Offers_Config.parseName(offer.RefName)
			plr:SetAttribute("MyUGCID"..PodiumName,key)
			runningOffers[PodiumName]=offer
			SendUGCOfferToClient:FireClient(plr,offer,PodiumName)
		end
	end
end)

Utils.SecureRemote(
	SendUGCOfferToClient,
	function(player, podiumName)
		if typeof(podiumName) ~= "string" then return end

		SendClientAUGCOffer(player, podiumName)
	end,
	{ "string" },
	{
		RateLimit = 1,
		MaxBurst = 15,
		PunishThreshold = 15
	}
)

ShowOfferSignalBind.Event:Connect(function(plr, Kind,ItemKey)

	local top = Offers_Config.getOfferByKey(plr,Kind,ItemKey)
	if not top and (Kind=="Gloves" or Kind=="Shorts") then
		local offer = Offers_SavedData.LoadOfferState("ClothOffer_",plr)

		if offer then
			local data = string.split(offer.ActiveOffer.CurrentKey,"_")
				Offers_Config.GetAndCreateClothOfferOnKey(plr,data[1],data[2],offer.ActiveOffer.EndsAt)
			task.wait(1)
		end
			top = Offers_Config.getOfferByKey(plr,Kind,ItemKey)
	end
	
	if not top then return {} end
	SendOfferToClient:FireClient(plr,top )

end)

Utils.SecureRemote(
	RequestPurchase,
	function(player, productKind, productKey)

		if typeof(productKind) ~= "string" then return end
		if typeof(productKey) ~= "string" then return end

		local top = Offers_Config.getOfferByKey(player, productKind, productKey)
		if not top or top.ProductKey ~= productKey then return end

		if top.EndsAt and top.EndsAt > 0 and os.time() > top.EndsAt then return end

		if top.Kind == "DevProduct" then
			local dev = Monetization_Mod.Get_All_Dev_Product_Data()[productKey]
			if dev and dev.ID then MPS:PromptProductPurchase(player, dev.ID) end
			return
		end

		if top.Kind == "Gamepass" then
			local PD    = player:FindFirstChild("Player_Data")
			local coins = PD and PD:FindFirstChild("Coins")
			local price = tonumber(top.NewPrice) or 0

			if coins and coins.Value >= price then
				coins.Value = coins.Value - price

				-- Get the real GP_ID from Monetization_Mod
				local gp = Monetization_Mod.Get_All_Gamepass_Data()[productKey]
				if gp and gp.ID then
					-- Grant perks using the bindable event
					Grant_Gamepass_Perks:Fire(player, gp.ID)

					ShowMessage:FireClient(player, gp.Name .. " unlocked with coins!", true)
				else
					ShowMessage:FireClient(player, "Something went wrong. GP not found.", false)
					coins.Value = coins.Value + price -- refund
				end
			else
				ShowMessage:FireClient(player, "Not enough coins!", false)
			end
			return
		end

		if top.Kind == "Gloves" then
			local key = top.Ownership and top.Ownership.Key
			if not key then return end
			local PD = player:FindFirstChild("Player_Data")
			local Gems = PD and PD:FindFirstChild("Gems")
			if Gems and tonumber(Gems.Value) >= top.NewPrice then
				Gems.Value = Gems.Value - top.NewPrice
				local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
				ClothItemIdSignal:FireClient(player)
				Clothing_Mod.Give_Player_Gloves(player, key)
				ShowMessage:FireClient(player, ITEM_PURCHASED, true)
				Offers_SavedData.SaveOfferPurchaseCount("ClothOfferCount",player)
			else
				Open_InsufficientFundsRE:FireClient(player, false, top.NewPrice - Gems.Value)
			end
			return
		end

		-- Handle Shorts purchase with coins
		if top.Kind == "Shorts" then
			local key = top.Ownership and top.Ownership.Key
			if not key then return end
			local PD = player:FindFirstChild("Player_Data")
			local Gems = PD and PD:FindFirstChild("Gems")
			if Gems and tonumber(Gems.Value) >= top.NewPrice then
				Gems.Value = Gems.Value - top.NewPrice
				local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
				Clothing_Mod.Give_Player_Shorts(player, key)

				ClothItemIdSignal:FireClient(player)
				ShowMessage:FireClient(player, ITEM_PURCHASED, true)
				Offers_SavedData.SaveOfferPurchaseCount("ClothOfferCount", player)
			else
				Open_InsufficientFundsRE:FireClient(player, false, top.NewPrice - Gems.Value)
			end
			return
		end

	end,
	{ "string", "string" },
	{
		RateLimit = 2,
		MaxBurst = 2,
		PunishThreshold = 5
	}
)

MPS.PromptPurchaseFinished:Connect(function(plr, assetId, isPurchased)
	if not isPurchased then return end
	for podiumId, offer in pairs(runningOffers) do
		if tonumber(offer.Key) == tonumber(assetId) then

			SendUGCOfferToClient:FireClient(plr,nil,podiumId)
			task.spawn(function()
				local best,allOffers = Offers_Config.GetUGCItemNew(plr)
				allActiveOffers = allOffers
				SendClientAUGCOffer(plr,podiumId)
			end)

			ShowMessage:FireClient(plr, ITEM_PURCHASED, true)
			return
		end
	end
	Shop_Item_Purchased:FireClient(plr,"UGC_item",tonumber(assetId))
end)]]></ProtectedString>
							<string name="ScriptGuid">{DFDD4CBD-46F1-44FD-88DF-1D70FFFE3C8D}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">OffersService.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX24CF3E6885314513856356D54B5A9D11">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Session_Reward_Handle.lua
--
--  Description:
--      Manages session-based rewards tied to playtime. 
-- 		Tracks elapsed time, enforces daily resets, and validates reward claims via thresholds.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-11-03 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Reward_Mod
--          * Channels_F/Server_Client_F/Events/Session_Reward_Progress
--          * Channels_F/Server_Client_F/Events/Session_Reward_Claim_Result
--          * Channels_F/Client_Server_F/RF/Claim_Session_Reward
--          * Channels_F/Client_Server_F/RF/Get_Session_Progress
--      - Roblox Services:
--          * Players
--          * ReplicatedStorage
--      - Player Instances:
--          * Player.Player_Data.SR_Day
--          * Player.Player_Data.SR_Count
--          * Player.Player_Data.SR_ClaimedTimes
--
--  Notes:
--      - Resets reward counters daily (UTC-based)
--      - Prevents duplicate claims with per-player locks
--      - Sends live progress updates via RemoteEvents
--      - Thresholds and claim logic provided by Reward_Mod
--
--======================================================================

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Modules
local DataMods = ReplicatedStorage:WaitForChild("Data_Mods_F")
local RewardsMod = require(DataMods:WaitForChild("Rewards_Mod"))
local Utils = require(game.ReplicatedStorage.Modules.Utils)
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels = require(game.ReplicatedStorage.Modules.Channels)

-- Use centralized references from Channels.Remotes
local Session_Reward_Progress_E    	= Channels.SC_Remote_Events.Session_Reward_Progress
local Session_Reward_Claim_Result_E = Channels.SC_Remote_Events.Session_Reward_Claim_Result
local Claim_Session_Reward_RF       = Channels.CS_Remote_Functions.Claim_Session_Reward
local Get_Session_Progress_RF  		= Channels.CS_Remote_Functions.Get_Session_Progress


-- Ensure flat values under Player_Data
local function ensureSR(pd)
	local day  = pd:FindFirstChild("SR_Day")  or Instance.new("StringValue")
	day.Name = "SR_Day"; if not day.Parent then day.Parent = pd end

	local cnt  = pd:FindFirstChild("SR_Count") or Instance.new("IntValue")
	cnt.Name = "SR_Count"; if not cnt.Parent then cnt.Parent = pd end

	local clm  = pd:FindFirstChild("SR_ClaimedTimes") or Instance.new("StringValue")
	clm.Name = "SR_ClaimedTimes"; if not clm.Parent then clm.Parent = pd end

	if day.Value ~= Utils.todayUTC() then
		day.Value = Utils.todayUTC()
		cnt.Value = 0
		clm.Value = ""
	end
	return day, cnt, clm
end

local function parseClaimed(csv)
	local map = {}
	if csv and csv ~= "" then
		for _, s in ipairs(string.split(csv, ",")) do
			local n = tonumber(s)
			if n then map[n] = true end
		end
	end
	return map
end

local function appendClaimed(claimedSV, tSec)
	local cur = claimedSV.Value
	if cur == "" then claimedSV.Value = tostring(tSec)
	else claimedSV.Value = cur .. "," .. tostring(tSec) end
end

-- Anti double-click per player
local ClaimLock = {}
-- Track join times for authoritative elapsed computation
local JoinTimes = {}

local function sendProgress(p)
	local pd = PlayerUtils.GetPlayerData(p)
	if pd then
		local _, cnt, clm = ensureSR(pd)
		local joinTime = JoinTimes[p.UserId] or os.time()
		local elapsed = os.time() - joinTime
		Session_Reward_Progress_E:FireClient(p, {
			thresholds   = RewardsMod.Session_Rewards_Data, -- ?? merge
			elapsed      = elapsed,
			count        = cnt.Value,
			maxClaims    = RewardsMod.Get_Max_Session_Claims(), -- ?? merge
			claimedTimes = clm.Value,
		})
	end
end

Players.PlayerAdded:Connect(function(p)
	JoinTimes[p.UserId] = os.time()
	sendProgress(p)
end)

Players.PlayerRemoving:Connect(function(p)
	ClaimLock[p] = nil
	JoinTimes[p.UserId] = nil
end)


-- Secure RemoteFunction: Get_Session_Progress_RF
Utils.SecureFunction(
	Get_Session_Progress_RF,
	function(player)
		local pd = PlayerUtils.GetPlayerData(player)
		if not pd then return nil end
		local _, cnt, clm = ensureSR(pd)
		local joinTime = JoinTimes[player.UserId] or os.time()
		local elapsed = os.time() - joinTime
		return {
			thresholds   = RewardsMod.Session_Rewards_Data,
			elapsed      = elapsed,
			count        = cnt.Value,
			maxClaims    = RewardsMod.Get_Max_Session_Claims(),
			claimedTimes = clm.Value,
		}
	end,
	0, -- expected number of args
	{ 
		RateLimit = 2
	}
)


-- Secure RemoteFunction: Claim_Session_Reward_RF
Utils.SecureFunction(
	Claim_Session_Reward_RF,
	function(player, thresholdTime)
		if ClaimLock[player] then
			return { ok = false, reason = "busy" }
		end
		ClaimLock[player] = true

		local ok, res = pcall(function()
			local pd = PlayerUtils.GetPlayerData(player)
			if not pd then return { ok=false, reason="no_pd" } end

			local _, cnt, clm = ensureSR(pd)
			local claimed = parseClaimed(clm.Value)

			local reward = nil
			for _, entry in ipairs(RewardsMod.Session_Rewards_Data) do
				if entry.t == thresholdTime then
					reward = entry.reward
					break
				end
			end
			if not reward then return { ok=false, reason="invalid_threshold" } end

			local joinTime = JoinTimes[player.UserId] or os.time()
			local elapsed = os.time() - joinTime
			if elapsed < thresholdTime then
				return { ok=false, reason="too_early" }
			end
			if claimed[thresholdTime] then
				return { ok=false, reason="already_claimed" }
			end

			local PD = player:FindFirstChild("Player_Data")
			if PD and reward then
				local target = PD:FindFirstChild(reward.type)
				if target then
					target.Value += reward.amount
				else
					warn("[SessionRewards] No " .. reward.type .. " value for", player.Name)
				end
			end

			appendClaimed(clm, thresholdTime)
			cnt.Value += 1
			Session_Reward_Claim_Result_E:FireClient(player, { ok=true, reward=reward })
			return { ok=true, reward=reward }
		end)

		ClaimLock[player] = nil
		return ok and res or { ok=false, reason="error" }
	end,
	{ "number" }, -- expected argument types
	{ 
		RateLimit = 2
	}
)]]></ProtectedString>
							<string name="ScriptGuid">{CB6395A6-61B1-4288-A0DC-1BA24DA7A5E8}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Session_Reward_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX20A357F13BBF46068F40DC89B0168D6A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">System</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX805BD3149C28455EA75FEFACB324C4A7">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/System/Server_List_Handle.server.lua
--
--  Description:
--      Collects, stores, and shares server statistics across instances.
--      Handles server list compilation and cross-server teleportation.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ServerScriptService/Core:
--          * MS_Module (MemoryStore integration)
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/Update_Server_Data
--          * Channels_F/Server_Client_F/Events/Update_All_Server_Data
--          * Channels_F/Client_Server_F/RF/Get_All_Server_Data
--      - Roblox Services:
--          * TeleportService
--          * RunService
--      - Player Instances:
--          * Player.Player_Data.Elo
--          * Player.Player_Data.Total Wins
--          * Player.Player_Data.Ranked Wins
--
--  Notes:
--      - Pushes per-server stats into MemoryStore (via MS_Module)
--      - Broadcasts compiled multi-server data to all clients
--      - Provides RemoteFunction for client-side server list requests
--      - Allows teleportation to a specific server ID
--
--======================================================================

-- Services
local Teleport_Service = game:GetService("TeleportService")
local RunService = game:GetService("RunService")

-- Modules
local MS_Mod = require(script:WaitForChild("MS_Module"))
local Utils = require(game.ReplicatedStorage.Modules.Utils)
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels = require(game.ReplicatedStorage.Modules.Channels)

local Update_Server_Data 			= Channels.Bindable_Events.Update_Server_Data
local Get_All_Server_Data_RF		= Channels.CS_Remote_Functions.Get_All_Server_Data
local Update_All_Server_Data		= Channels.SC_Remote_Events.Update_All_Server_Data
local Teleport_To_Server			= Channels.CS_Remote_Functions.Teleport_To_Server


local Get_Player_Val = PlayerUtils.GetPlayerVal

-- Compile les infos du serveur local et les envoie à la MemoryStore
local function Compile_Main_Server_Data()
	local Server_Size_Data = {}
	local Highest_Elo = -1
	local Avg_Elo, Avg_Wins, Avg_Ranked_Wins = 0, 0, 0
	local All_P = game.Players:GetPlayers()

	local function Process_Plr(Plr)
		local P_Elo = Get_Player_Val(Plr, "Elo") 
		local P_Wins = Get_Player_Val(Plr, "Total Wins") 
		local P_Ranked_Wins = Get_Player_Val(Plr, "Ranked Wins") 

		if P_Elo ~= nil then
			P_Elo = P_Elo.Value
		else	
			P_Elo = 0
		end
		
		if P_Wins ~= nil then
			P_Wins = P_Wins.Value
		else	
			P_Wins = 0
		end
		
		if P_Ranked_Wins ~= nil then
			P_Ranked_Wins = P_Ranked_Wins.Value
		else	
			P_Ranked_Wins = 0
		end
		
		Avg_Elo += P_Elo 
		Avg_Wins += P_Wins
		Avg_Ranked_Wins += P_Ranked_Wins

		if P_Elo >= Highest_Elo then
			Highest_Elo = P_Elo
		end

		table.insert(Server_Size_Data, Plr.UserId)
	end

	for _, P in ipairs(All_P) do
		Process_Plr(P)
	end

	local count = #Server_Size_Data
	if count == 0 then count = 1 end -- éviter division par 0

	local S_Data = {
		['Highest Elo'] = Highest_Elo,
		['Average Elo'] = math.ceil(Avg_Elo / count),
		['Average Wins'] = math.ceil(Avg_Wins / count),
		['Average Ranked Wins'] = math.ceil(Avg_Ranked_Wins / count),
		['Server Size'] = Server_Size_Data
	}

	local Server_ID = Utils.getServerId()
	MS_Mod.Add_Data(Server_ID, S_Data)
end
task.spawn(Compile_Main_Server_Data)

-- Mise à jour forcée par événement
Update_Server_Data.Event:Connect(function()
	if not RunService:IsStudio() then		
		Compile_Main_Server_Data()
	end
end)

-- Récupération et broadcast des données de tous les serveurs
local function Get_All_Server_Data()
	local Raw_Data = MS_Mod.Get_All_World_Data()
	local Compiled_Data = {}

	for S_ID, Data in pairs(Raw_Data) do
		local size = Data['Server Size'] and #Data['Server Size'] or 0
		if size > 0 then -- ignore empty servers
			local D = {
				['Highest Elo'] = Data['Highest Elo'] or 0,
				['Average Elo'] = Data['Average Elo'] or 0,
				['Average Wins'] = Data['Average Wins'] or 0,
				['Average Ranked Wins'] = Data['Average Ranked Wins'] or 0,
				['Server Size'] = Data['Server Size'] or {},
				['Server ID'] = S_ID
			}
			table.insert(Compiled_Data, D)
		else
			--print("[Server_List_Handle] Ignored empty server", S_ID)
		end
	end

	--print("[Server_List_Handle] Get_All_Server_Data ->", #Compiled_Data, "servers")
	Update_All_Server_Data:FireAllClients(Compiled_Data)
	return Compiled_Data
end

local All_Server_Data = Get_All_Server_Data()

Get_All_Server_Data_RF.OnServerInvoke = function()
	--print("[Server_List_Handle] Client requested server list, returning", #All_Server_Data)
	return All_Server_Data
end

-- Téléportation inter-serveurs
local function Teleport_Player_To_Server(Plr, S_ID)
	local Place_ID = 117620200631077
	local TP_Data = Instance.new("TeleportOptions")
	TP_Data.ReservedServerAccessCode = ""
	TP_Data.ServerInstanceId = tostring(S_ID)
	TP_Data.ShouldReserveServer = false

	local function Async()
		local success, errormessage = pcall(function()
			Teleport_Service:TeleportAsync(Place_ID, {Plr}, TP_Data)
		end)
		if not success then
			warn("[Server_List_Handle] Teleport failed:", errormessage)
		end
		return success
	end

	for i = 1, 3 do 
		if Async() then
			return true
		end
	end
	return false
end

Teleport_To_Server.OnServerInvoke = function(Plr, S_ID)
	return Teleport_Player_To_Server(Plr, S_ID)
end

-- Boucle d’auto-update
local function Auto_Update_Servers_Data()
	while task.wait(60) do
		-- Forcer une recompilation locale
		Compile_Main_Server_Data()
		-- Mettre à jour la variable globale + notifier clients
		All_Server_Data = Get_All_Server_Data()
	end
end
task.spawn(Auto_Update_Servers_Data)
]]></ProtectedString>
							<string name="ScriptGuid">{7931D417-BC5A-486C-BE93-BF3A8C1DF1CE}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Server_List_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXA0AB1ACB420E4A14B226D58514ED2E4A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Server_List_Handle</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX9F2DD4C000C74AC095BF174A34CEC9AF">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Server_List_Handle/MS_Module.lua
--
--  Description:
--      MemoryStore abstraction for cross-server communication. Provides
--      functions to add, retrieve, remove, and list server data entries
--      using a SortedMap with JSON encoding.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * MemoryStoreService (SortedMap "Servers_Data")
--          * HttpService (JSONEncode/Decode)
--          * RunService (Studio detection & fallback key generation)
--
--  Notes:
--      - Default TTL for entries: 1800s (30 minutes), clamped to [5s, 12h]
--      - Safe key generator ensures valid non-empty keys
--      - All operations retried up to 3 times on failure
--      - Get_All_World_Data returns up to 200 entries decoded from JSON
--
--
local funcs = {}
local MSS = game:GetService("MemoryStoreService")
local HttpService = game:GetService("HttpService")

-- Main MemoryStore SortedMap used to share data between servers
local Servers_Data = MSS:GetSortedMap("Servers_Data")

-- Default data duration (time-to-live) in seconds (30 minutes)
local Data_Duration = 1800

-- === Helpers ===

-- Ensure TTL stays in Roblox allowed range (5s - 12h)
local function clampTTL(ttl)
	ttl = tonumber(ttl) or Data_Duration
	if ttl < 5 then ttl = 5 end
	if ttl > 43200 then ttl = 43200 end
	return ttl
end

-- Ensure key is safe (non-empty string).
-- Always generate a fallback if empty.
local function safeKey(key)
	local k = (key ~= nil and tostring(key) or "")
	if k == "" then
		-- fallback key, works both in Studio and production
		k = ("server_%s_%d"):format(game.PlaceId, os.time())
	end
	return k
end

-- Generic retry wrapper for MemoryStore operations
-- action: function(attemptIndex) -> result or nil
local function retry(attempts, action)
	for i = 1, attempts do
		local success, result = pcall(action, i)
		if success and result ~= nil then
			return result
		end
		if not success then
			warn("[Servers_Data] attempt #" .. i .. " failed: " .. tostring(result))
		end
	end
	return nil
end

-- === Core API ===

-- Store a JSON-encoded data table under a given key
function funcs.Add_Data(Key, Data)
	local k = safeKey(Key)
	if not k then
		warn("[Servers_Data] Add_Data ignored: empty key")
		return false
	end

	return retry(3, function()
		Servers_Data:SetAsync(k, HttpService:JSONEncode(Data), clampTTL(Data_Duration))
		return true
	end)
end

-- Retrieve and decode JSON data for a given key
function funcs.Get_Data(Key)
	local k = safeKey(Key)
	if not k then
		warn("[Servers_Data] Get_Data ignored: empty key")
		return nil
	end

	return retry(3, function()
		local data = Servers_Data:GetAsync(k)
		return data and HttpService:JSONDecode(data) or nil
	end)
end

-- Remove a key from the store
function funcs.Remove_Data(Key)
	local k = safeKey(Key)
	if not k then
		warn("[Servers_Data] Remove_Data ignored: empty key")
		return false
	end

	return retry(3, function()
		Servers_Data:RemoveAsync(k)
		return true
	end)
end

-- Retrieve all available entries (up to 200) as a dictionary
-- { key -> decoded JSON value }
function funcs.Get_All_World_Data()
	return retry(3, function()
		local data = Servers_Data:GetRangeAsync(Enum.SortDirection.Descending, 200)
		if not data then return nil end

		local ret = {}
		for _, entry in ipairs(data) do
			ret[entry.key] = HttpService:JSONDecode(entry.value)
		end

		--print("[Servers_Data] Get_All_World_Data ->", #data, "entries")
		return ret
	end) or {}
end

return funcs
]]></ProtectedString>
								<string name="ScriptGuid">{C979AAB9-4B79-4059-99AC-4BABB7F50BD5}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">MS_Module.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX0D0492A2541B42CBA722BC6240683871">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/System/Bloxlink.lua
--
--  Description:
--      Integrates with the Bloxlink API to verify if a player is linked 
--      to a Discord account in the target guild. Rewards verified players 
--      with exclusive items and sends confirmation messages.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Clothing_Mod
--          * Channels_F/Server_Client_F/Events/Display_Data
--      - Roblox Services:
--          * HttpService (HTTP requests, GetSecret, JSONDecode)
--          * Players
--          * RunService
--      - External:
--          * Bloxlink Public API (https://api.blox.link/v4/public/guilds/...)
--
--  Notes:
--      - Requires secret key "BloxLinkAPI" (stored securely via HttpService:GetSecret)
--      - Periodically checks membership and stops once reward is given
--      - Grants "Mystic Gloves" to verified community members
--      - Cleans up background tasks on PlayerRemoving
--
--======================================================================

-- Services
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Modules
local Clothing_Mod = require(game.ReplicatedStorage.Data_Mods_F.Clothing_Mod)

-- Events
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Msg_E = Channels.SC_Remote_Events.Display_Data

-- Auth
local AuthKey = ""
if not RunService:IsStudio() then
	AuthKey = HttpService:GetSecret("BloxLinkAPI") or ""
	if AuthKey == "" then
		warn("[Bloxlink] Missing API key. Verification disabled.")
	end
end

-- Caches
local verifiedCache = {}
local lastCheck = {}

-- Config
local COOLDOWN = 10 * 60 -- 10 minutes

--======================================================================
-- Helpers
--======================================================================
local function canCheck(userId)
	local t = lastCheck[userId]
	if not t then return true end
	return (os.clock() - t) > COOLDOWN
end

local function isInServer(userId)
	if verifiedCache[userId] then
		return true
	end
	if AuthKey == "" or not canCheck(userId) then
		return false
	end

	lastCheck[userId] = os.clock()

	local url = "https://api.blox.link/v4/public/guilds/1371423884921933837/roblox-to-discord/" .. userId
	local headers = { ["Authorization"] = AuthKey }

	local success, result = pcall(function()
		return HttpService:GetAsync(url, false, headers)
	end)

	if not success then
		warn(("[Bloxlink] HTTP error for %d: %s"):format(userId, tostring(result)))
		return false
	end

	local ok, data = pcall(function()
		return HttpService:JSONDecode(result)
	end)

	if not ok then
		warn(("[Bloxlink] JSON decode error for %d"):format(userId))
		return false
	end

	if data and data.discordIDs then
		verifiedCache[userId] = true
		return true
	end

	return false
end

local function awardDiscordReward(player: Player)
	local plrData = player:FindFirstChild("Player_Data")
	if not plrData then return false end

	local discordReward = plrData:FindFirstChild("DiscordReward")
	if not discordReward or discordReward.Value then
		return false
	end

	if Clothing_Mod.Player_Owns_Gloves_Key(player, "K") then
		return false
	end

	Clothing_Mod.Give_Player_Gloves(player, "K")
	Msg_E:FireClient(player, "✨ You are a member of our community. Here is a pair of Mystic Gloves!", Color3.fromRGB(255, 170, 0))
	discordReward.Value = true
	return true
end

--======================================================================
-- Player flow
--======================================================================
Players.PlayerAdded:Connect(function(player)
	local plrData = player:WaitForChild("Player_Data", 30)
	if not plrData or not player:IsDescendantOf(Players) then
		return
	end

	task.spawn(function()
		if isInServer(player.UserId) then
			awardDiscordReward(player)
		end
	end)
end)
]]></ProtectedString>
							<string name="ScriptGuid">{4AB8435A-F1E2-4BBB-B5BD-CEA1364EB1EB}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Bloxlink.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8AC7305CBDD5471AB10CC200767B6CF0">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/System/Video_Player.lua
--
--  Description:
--      Automatically sets up and plays looping videos on tagged SurfaceGuis.
--      Injects a VideoFrame inside a Frame child and assigns the video asset.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * CollectionService (tagged instances with "VideoFrame")
--      - Instances:
--          * SurfaceGui (with attribute "Video")
--          * Frame (child of SurfaceGui)
--          * VideoFrame (created dynamically)
--
--  Notes:
--      - Uses CollectionService:GetInstanceAddedSignal to handle new tags
--      - Iterates existing tagged objects at startup
--      - Waits for VideoFrame to be loaded before calling :Play()
--      - Loops videos with muted audio (Volume = 0)
--
--======================================================================

-- Services
local CollectionService = game:GetService("CollectionService")

local function setupVideo(surfaceGui: SurfaceGui)
	local frame = surfaceGui:FindFirstChildWhichIsA("Frame")
	if not frame then
		warn("[Video_Player] No Frame found in", surfaceGui:GetFullName())
		return
	end

	local videoId = tonumber(surfaceGui:GetAttribute("Video"))
	if not videoId then
		warn("[Video_Player] Invalid or missing Video attribute in", surfaceGui:GetFullName())
		return
	end

	local videoPlayer = Instance.new("VideoFrame")
	videoPlayer.Name = "VideoPlayer"
	videoPlayer.Size = UDim2.new(1, 0, 1, 0)
	videoPlayer.Looped = true
	videoPlayer.Volume = 0
	videoPlayer.Video = "rbxassetid://" .. videoId
	videoPlayer.Parent = frame

	if not videoPlayer.IsLoaded then
		videoPlayer.Loaded:Wait()
	end

	videoPlayer:Play()

--print("[Video_Player] Playing video", videoId, "on", surfaceGui:GetFullName())
end

-- Helper pour protéger les appels
local function safeSetup(obj)
	local success, err = pcall(setupVideo, obj)
	if not success then
		warn("[Video_Player] Failed to setup video for", obj:GetFullName(), ":", err)
	end
end

-- Connect new tagged instances
CollectionService:GetInstanceAddedSignal("VideoFrame"):Connect(safeSetup)

-- Initialize already tagged instances
for _, obj in CollectionService:GetTagged("VideoFrame") do
	task.spawn(safeSetup, obj)

end
]]></ProtectedString>
							<string name="ScriptGuid">{D6C0198D-952D-40AC-B804-111BCA4F1B67}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Video_Player.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX15F222EBECEA473BB9B8916F6D1638AB">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/System/Settings.lua
--
--  Description:
--      Server-side handler for saving and updating player settings.
--      Listens for client events, validates incoming data, and writes to
--      the player's settings ValueObjects (BoolValues only).
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-02-10 by Darkzeb
--
--  Version: V2025-02
--
--  Dependencies:
--      - Modules:
--          * PlayerUtils      (GetPlayerVal accessor)
--          * Channels         (Save_Settings remote event)
--          * Data_Mods_F      (general data modules root)
--
--  Used By:
--      - Client UI settings panels
--      - Any system that modifies player preferences
--
--  Notes:
--      - Only boolean settings are supported by design.
--      - Each incoming key is mapped to a ValueObject in player data.
--      - Secure: ignores invalid keys or incorrect data types.
--      - Extendable if numeric or string settings are needed later.
--
--======================================================================


-- Modules
local PlayerUtils 		= require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels 		 	= require(game.ReplicatedStorage.Modules.Channels)
local Save_Settings	 	= Channels.CS_Remote_Events.Save_Settings

local Get_Player_Val 	= PlayerUtils.GetPlayerVal

-----	Save & Update Settings Handle	-----
Save_Settings.OnServerEvent:Connect(function(Plr, New_Data)
	if(Plr ~= nil)then
		for Data_Key, Data_Val in next, New_Data do
			local Val = Get_Player_Val(Plr, Data_Key)
			if(Val ~= nil and Val:IsA("BoolValue") and typeof(Data_Val) == "boolean")then
				Val.Value = Data_Val
			end
		end
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{50EE5D00-5107-46AF-A98F-F5D44D03BE8B}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Settings.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXC5DE4237FD7643BAAD952284A9B44A25">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Datastore</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX4B9BB74E39C649A4B14AAFC8FB998E19">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Datastore/DS_Module.lua
--
--  Description:
--      Utility module for DataStore operations. Provides abstraction for
--      leaderboards, player data loading/saving, and backup management.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-12-09 by Darkzeb
--
--  Version: V2025-12
--
--  Dependencies:
--      - Roblox Services:
--          * DataStoreService
--          * HttpService (JSONDecode/Encode)
--
--  Notes:
--      - Implements OrderedDataStore helpers for leaderboards
--      - Wraps all calls in pcall with retry (3 attempts)
--      - Provides backup loading if main DataStore fails
--      - Data values stored in JSON format
--
--======================================================================

local DataStoreService 		= game:GetService("DataStoreService")
local WebService 			= game:GetService("HttpService")
local funcs 				= {}


-- NEW MIGRATION CONSTANTS
local NEW_DATASTORE_NAME 	= "PLAYER_DATASTORE_LIVE"
local MIGRATION_LOG 		= "PLAYER_MIGRATION_LOG"
local OLD_SUFFIX 			= "_Game_Data"

local function Log_Migration(userId)
	local ds = DataStoreService:GetDataStore(MIGRATION_LOG)
	pcall(function()
		ds:SetAsync(userId, os.time())
	end)
end

--Set up for Leaderboards pertaining to Wins and Donations!
function funcs.Save_Leaderboard(Key, DataType, Value)
	local function Attempt_To_Save()
		local success, errormessage = pcall(function()
			local ODS = DataStoreService:GetOrderedDataStore(DataType)
			ODS:SetAsync(Key, Value)
		end)

		if(success)then
			return true
		else
			warn(string.format(
				"Saving Error -> Key: %s | Data Type: %s | Error Msg: %s",
				tostring(Key),
				tostring(DataType),
				tostring(errormessage)
				))

			return false
		end
	end

	for i = 1, 3 do
		local Save = Attempt_To_Save()
		if(Save)then
			i = 3
			break
		end
	end
end

function funcs.Load_Leaderboard(DataType, PageSize)
	local function Get_Data()
		local Data = nil
		local success, errormessage = pcall(function()
			local ODS = DataStoreService:GetOrderedDataStore(DataType)
			Data = ODS:GetSortedAsync(false, PageSize)
		end)

		if(success and Data ~= nil)then
			return Data
		else
			return nil
		end
	end

	for i = 1, 3 do
		local Data = Get_Data()
		if(Data ~= nil)then
			return Data:GetCurrentPage()
		end
	end

	return nil
end

function funcs.Delete_Leaderboard(Key, DataType)
	local function Attempt_To_Delete()
		local success, errormessage = pcall(function()
			local ODS = DataStoreService:GetOrderedDataStore(DataType)
			ODS:RemoveAsync(Key)
		end)

		if(success)then
			return true
		else
			return false
		end
	end

	for i = 1, 3 do
		local Removed = Attempt_To_Delete()
		if(Removed)then
			i = 3
			break
		end
	end
end

function funcs.Load_Data(userId, DataType)
	userId = tostring(userId)

	local mainDS = DataStoreService:GetDataStore(NEW_DATASTORE_NAME)
	local backupDS = DataStoreService:GetDataStore(NEW_DATASTORE_NAME .. "_BACKUP")

	---------------------------------------------------------------------
	-- 1) READ NEW DATASTORE (WITH RETRY)
	---------------------------------------------------------------------
	for i = 1, 3 do
		local ok, raw = pcall(function()
			return mainDS:GetAsync(userId)
		end)
		if ok and raw then
			return WebService:JSONDecode(raw)
		end
		task.wait(0.2 * i)
	end

	---------------------------------------------------------------------
	-- 2) FALLBACK ON BACKUP DS
	---------------------------------------------------------------------
	for i = 1, 3 do
		local ok, raw = pcall(function()
			return backupDS:GetAsync(userId)
		end)
		if ok and raw then
			return WebService:JSONDecode(raw)
		end
		task.wait(0.2 * i)
	end

	---------------------------------------------------------------------
	-- 3) OLD DATASTORE AUTO-MIGRATION (comme avant)
	---------------------------------------------------------------------
	local oldKey = userId .. OLD_SUFFIX
	local oldDS = DataStoreService:GetDataStore(oldKey)

	for i = 1, 3 do
		local ok, oldRaw = pcall(function()
			return oldDS:GetAsync(DataType)
		end)
		if ok and oldRaw then
			mainDS:SetAsync(userId, oldRaw)
			backupDS:SetAsync(userId, oldRaw)
			Log_Migration(userId)
			return WebService:JSONDecode(oldRaw)
		end
		task.wait(0.2 * i)
	end

	return nil
end

function funcs.Save_Data(userId, DataType, Value)
	userId = tostring(userId)

	local mainDS = DataStoreService:GetDataStore(NEW_DATASTORE_NAME)
	local backupDS = DataStoreService:GetDataStore(NEW_DATASTORE_NAME .. "_BACKUP")

	local encoded = WebService:JSONEncode(Value)

	---------------------------------------------------------------------
	-- WRITE MAIN DS (3 RETRIES)
	---------------------------------------------------------------------
	for i = 1, 3 do
		local ok = pcall(function()
			mainDS:SetAsync(userId, encoded)
		end)
		if ok then break end
		task.wait(0.2 * i)
	end

	---------------------------------------------------------------------
	-- WRITE BACKUP DS (3 RETRIES)
	---------------------------------------------------------------------
	for i = 1, 3 do
		local ok = pcall(function()
			backupDS:SetAsync(userId, encoded)
		end)
		if ok then break end
		task.wait(0.2 * i)
	end
end

function funcs.Delete_Data(userId)
	userId = tostring(userId)

	local mainDS   = DataStoreService:GetDataStore(NEW_DATASTORE_NAME)
	local backupDS = DataStoreService:GetDataStore(NEW_DATASTORE_NAME .. "_BACKUP")

	---------------------------------------------------------------------
	-- INTERNAL DELETE FUNCTION (WITH RETRIES)
	---------------------------------------------------------------------
	local function Attempt(store, key)
		for i = 1, 3 do
			local ok, err = pcall(function()
				store:RemoveAsync(key)
			end)

			if ok then
				return true
			else
				warn("Delete_Data error:", key, err)
				task.wait(0.2 * i)
			end
		end
		return false
	end

	---------------------------------------------------------------------
	-- DELETE MAIN ENTRY
	---------------------------------------------------------------------
	Attempt(mainDS, userId)

	---------------------------------------------------------------------
	-- DELETE BACKUP ENTRY
	---------------------------------------------------------------------
	Attempt(backupDS, userId)
end

function funcs.Delete_Legacy_DataStore(Key, SubKey)
	local function Attempt_To_Delete(DT)
		local success, errormessage = pcall(function()
			local DataStore = DataStoreService:GetDataStore(Key)
			DataStore:RemoveAsync(DT)
		end)

		if success then
			return true
		else
			warn(string.format(
				"Deleting Legacy Error -> DS: %s | Key: %s | Error: %s",
				tostring(Key),
				tostring(DT),
				tostring(errormessage)
				))
			return false
		end
	end

	for i = 1, 3 do
		if Attempt_To_Delete(SubKey) then break end
		task.wait(0.2 * i)
	end

	for i = 1, 3 do
		if Attempt_To_Delete(SubKey .. "_BACKUP") then break end
		task.wait(0.2 * i)
	end
end


return funcs
]]></ProtectedString>
							<string name="ScriptGuid">{B299E22E-4CF2-4D5C-9593-576D949A14FD}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">DS_Module.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8743FA441B1847F690568134BB39D13B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Datastore/DS_Handle.lua
--
--  Description:
--      Core handler for player data persistence. 
-- 		Interfaces with DS_Module to save and load player profiles, manages monetization, leaderboards,
--      and premium status checks.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ServerScriptService:
--          * DS_Module
--          * GlobalLeaderBoards
--      - ReplicatedStorage:
--          * Data_Mods_F/Monetization_Mod
--          * Channels_F/Bindable_F/RF
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Server_Client_F/Events
--          * Channels_F/Client_Server_F
--      - Roblox Services:
--          * MarketplaceService
--          * DataStoreService (via DS_Module)
--
--
--  Current Datastores usages into MMA Fighters
--          * $USERID_Game_Data : profile for players | DS_Handle
--          * PlayerOfferState : for podium offers | Offers_Config / Display_Podium_Center / Display_Podium_Left
--          * GA_PlayerDS_1.0.0 : track buying for GA module | GameAnalytics/Store
--          * Limited_Items : see Monetization_Handle
--          * Natio_Elo, Natio_Elo1, Natio_Elo2 : see GlobalLeaderBoards
--
--  Notes:
--      - Player profile schema includes Elo, stats, cosmetics, audio prefs, etc.
--      - Main DataStore key: "PLAYER_DATASTORE_LIVE"
--      - Handles premium membership detection and badge rewards
--      - Tagging system for top players (currently disabled in code)
--
--======================================================================

--Services
local RunService 					= game:GetService("RunService")

-- Modules
local DS_Mod 						= require(script.Parent:WaitForChild("DS_Module"))
local Data_Mods_F 					= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Monetization_Mod 				= require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local GlobalLeaderboardsModule 		= require(game.ServerScriptService.Modules.GlobalLeaderBoards)
local Utils							= require(game.ReplicatedStorage.Modules.Utils)
local PlayerUtils 					= require(game.ReplicatedStorage.Modules.PlayerUtils)
local Fight_Params_Mod 				= require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)

-- Events
local Channels 						= require(game.ReplicatedStorage.Modules.Channels)
local Player_In_Group_RF 			= Channels.Bindable_Functions.Player_In_Group
local Player_Owns_Badge_RF			= Channels.Bindable_Functions.Player_Owns_Badge
local Award_Badge					= Channels.Bindable_Events.Award_Badge
local Player_Leaderboard_Data 		= Channels.Bindable_Events.Player_Leaderboard_Data
local Update_Server_Data 			= Channels.Bindable_Events.Update_Server_Data
local Server_Chat					= Channels.SC_Remote_Events.Server_Chat
local Update_Player_List 			= Channels.SC_Remote_Events.Update_Player_List
local Set_Creator_Reward_Code		= Channels.CS_Remote_Events.Set_Creator_Reward_Code
local Reset_Player_Profile			= Channels.CS_Remote_Events.Reset_Player_Profile
local Game_Startup_Ready 			= Channels.SC_Remote_Events.Game_Startup_Ready

local Leaderboard_Keys 				= {}
local PLAYER_DATA_KEY 				= "PLAYER_DATASTORE_LIVE"
local SAVE_DATA_INTERVAL 			= 30 -- seconds

--[[
	Player Data Profile
	> Stored Player Data
		- Elo
		- Cash
		- Gems
		- Used Codes
		- Retention Streak (and the other Values assosiated with this)
		- Bio
		- Country
		- Skin Tone
		- Right Handed
		- Total Wins
		- Total Ties
		- Total Matches
		- Ranked Wins
		- Total Strikes
		- Dodged Strikes
		- Takedowns Landed
		- Takedowns Attempted
		- Submissions Finished
		- Submissions Attempted
		- Punch Knockout Wins
		- Leg Knockout Wins
		- Submission Wins
		
		- Power per Strike
		- Strike Defense
		- Submission Timeout
		- Submission Defense
		- Staminia
		
		- Current Shorts
		- Current Gloves
		- Inventory Shorts
		- Inventory Gloves
		- Inventory Special Strikes
		- Inventory Special Submissions
		
		- Background Music
		- Sound Effects
		- Voice Over
		- Show Fight Prompt
]]--

local function Update_Retention_Streak(Plr)
	local Current_Time = os.time()
	local PD = Plr:WaitForChild("Player_Data")
	local Prev_Time_Val = PD:WaitForChild("Previous Session Time")
	local Streak_Val = PD:WaitForChild("Retention Streak")
	local Raw_Time_Val = PD:WaitForChild("Raw Prev Session Time")
	local Rewards_Val = PD:WaitForChild("Redeemed Rewards")

	local Dif = Current_Time - Prev_Time_Val.Value

	local function Is_Next_Day()
		local Month_Data = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
		local Prev_Data = os.date("!*t", Prev_Time_Val.Value)
		local Prev_Month, Prev_Day = Prev_Data['month'], Prev_Data['day']
		local Current_Day = os.date("!*t", Current_Time)['day'] 

		local Next_Day_Val = Prev_Day + 1
		if(Month_Data[Prev_Month] < Next_Day_Val)then			
			Next_Day_Val = 1
		end

		if(Current_Day == Next_Day_Val or (Dif >= 86400 and Dif <= 172800))then
			return true
		end
		return false
	end

	--[[
	local function Has_Unlocked_All_Rewards()
		if(Rewards_Val ~= nil and Rewards_Val.Value ~= "")then
			local Max_Rewards_Count = Daily_Rewards_Mod.Get_Total_Reward_Amount()
			local Rewards_Keys = string.split(Rewards_Val.Value, ",")
			local Count = 0
			
			for i = 1, #Rewards_Keys do
				local K = string.gsub(Rewards_Keys[i], " ", "")
				if(K ~= nil and K ~= "")then
					Count += 1
				end
			end
			
			if(Count >= Max_Rewards_Count)then
				return true
			end
		end
		
		return false
	end
	local Has_Unlocked_All_R = Has_Unlocked_All_Rewards()
	]]--
	local Has_Unlocked_All_R = false

	if(Is_Next_Day() and Has_Unlocked_All_R == false)then
		Prev_Time_Val.Value = Current_Time
		Streak_Val.Value = Streak_Val.Value + 1
		--print("Is the next Day! Earn new Reward!")

	elseif(Dif > 172800 or Has_Unlocked_All_R == true)then

		--print("Resetting Streak!")
		Prev_Time_Val.Value = Current_Time
		Streak_Val.Value = 1
		Rewards_Val.Value = ""
	end

	Raw_Time_Val.Value = Current_Time
	Plr:SetAttribute("Join_Time", Current_Time)
end

local function Load_Player_Data(Plr)
	-- NEW PARADIGM: one datastore, per-player key
	local Key = tostring(Plr.UserId)
	
	local Default_Data = {
		--General Player Stats
		['Total Sessions'] = 0,
		['Total Playtime'] = 0,
		['Elo'] = 400,
		['Coins'] = 0,
		['Gems'] = 0,
		['Bio'] = "",
		['Country'] = "United States",
		--['League'] = "Rookie",
		--['League_Wins'] = 0,
		--['League_Matches'] = 0,
		--['League_Ties'] = 0,
		['Body Type'] = "Male",
		['Skin Tone'] = "234,184,146",
		['Right Handed'] = true,
		['Creator Code'] = "",
		['Total Wins'] = 0,
		['League Matches'] = 0,
		['League Wins'] = 0,
		['Total Ties'] = 0,
		['Total Matches'] = 0,
		['Win Streak'] = 0,
		['Ranked Wins'] = 0,
		['Ranked Matches'] = 0,
		['Ranked Ties'] = 0,
		['Total Strikes'] = 0,
		['Strikes Landed'] = 0,
		['Dodged Strikes'] = 0,
		['Takedowns Landed'] = 0,
		['Takedowns Attempted'] = 0,
		['Submissions Finished'] = 0,
		['Submissions Attempted'] = 0,
		['Punch Knockout Wins'] = 0,
		['Leg Knockout Wins'] = 0,
		['Submissions Wins'] = 0,
		['Gym Training'] = 0,
		['GymEventRewards'] = 0,
		
		['Power per Strike'] = 2.5,
		['Strike Defense'] = 30,
		['Submission Timeout'] = 1,
		['Submission Defense'] = 1,
		['Staminia'] = 100,
		
		['Vip'] = false,
		['Cash2x'] = false,

		['StarterPackTimer'] = nil,
		['RookieTag'] = false,
		['DiscordReward'] = false,
		
		--General Player Data
		['Codes'] = {},
		['Previous Session Time'] = os.time(),
		['Retention Streak'] = 1,
		['Raw Prev Session Time'] = os.time(),
		['Redeemed Rewards'] = {},
		['Owned Gamepasses'] = {},
		['Owned Products'] = {},
		['Redeemed Skill Tree'] = {},
		
		-- Session Rewards (NEW SL)
		['SR_Day'] = os.date("!%Y-%m-%d"),
		['SR_Count'] = 0,
		['SR_ClaimedTimes'] = "",
		
		--Player Inventory Data
		['Current Shorts'] = "A",
		['Current Gloves'] = "A",
		['Current Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Owned Shorts'] = {"A"},
		['Owned Gloves'] = {"A"},
		['Owned Special Strikes'] = {},
		['Owned Special Submissions'] = {},
		['Owned Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Punch Combo'] = {"C", "A", "B","C", "A", "G"},
		['Kick Combo'] = {"F", "D", "E","F", "J", "H"},
		['Strike Combo 1'] = {"C", "A", "B"},
		['Strike Combo 2'] = {"F", "D", "E"},
		['Strike Combo 3'] = {"G", "L", "M"},
		['Strike Combo 4'] = {"F", "J", "H"},
		['Fight Intro Key'] = "A",
		['Fight Outro Key'] = "A",
		['Takedown Key'] = "A",
		['Submission Key'] = "A",
		
		--Player Settings
		['Background Music'] = true,
		['Sound Effects'] = true,
		['Voice Over'] = true,
		['Fight Prompts'] = true,
		['Trading'] = true

	}
	
	local Plr_Data = DS_Mod.Load_Data(Key, PLAYER_DATA_KEY)
	
	if Plr_Data == nil then
		Plr_Data = Default_Data
		GlobalLeaderboardsModule:RegisterNationElo(Plr_Data.Country, Plr_Data.Elo)
	end
	
	if Plr_Data.StarterPackTimer == nil then
		Plr_Data.StarterPackTimer = os.time() + 24 * 60 * 60
	end
	
	if Plr_Data.RookieTag == true then
		Plr:SetAttribute("Rookie", true)
	else
		Plr:SetAttribute("Rookie", false)
	end
	
	local PD = Instance.new("Folder", Plr)
	PD.Name = "Player_Data"

	-----------------------------------

	local function Get_Object_Type(Data)
		local Data_Type = {
			['string'] = "StringValue",
			['table'] = "StringValue",
			['number'] = "NumberValue",
			['boolean'] = "BoolValue"
		}

		local Key = typeof(Data)
		return Data_Type[Key]
	end

	for Data_Key, Data_Val in next, Plr_Data do
		local Obj_Type = Get_Object_Type(Data_Val)
		local V = Instance.new(Obj_Type, PD)
		V.Name = Data_Key

		if(typeof(Data_Val) == "table")then
			V.Value = table.concat(Data_Val, ",")
		else
			V.Value = Data_Val
		end
	end

	for Data_Key, Data_Val in next, Default_Data do
		if not PD:FindFirstChild(Data_Key) then
			local Obj_Type = Get_Object_Type(Data_Val)
			local V = Instance.new(Obj_Type, PD)
			V.Name = Data_Key

			if(typeof(Data_Val) == "table")then
				V.Value = table.concat(Data_Val, ",")
			else
				V.Value = Data_Val
			end
		end
	end
	
	local function Increment_Session_Count()
		local Val = PD:FindFirstChild("Total Sessions")
		if(Val ~= nil)then
			Val.Value += 1
		end
	end
	Increment_Session_Count()
	
	PD:WaitForChild("RookieTag").Changed:Connect(function()
		if PD.RookieTag.Value == true then
			Plr:SetAttribute("Rookie", true)
		end
	end)

	local lastCountry = PD:WaitForChild("Country").Value
	PD:WaitForChild("Country").Changed:Connect(function()
		local newElo = PD:WaitForChild("Elo").Value
		local newCountry = PD:WaitForChild("Country").Value

		GlobalLeaderboardsModule:RegisterNationElo(lastCountry, -newElo)
		GlobalLeaderboardsModule:RegisterNationElo(newCountry, newElo)
		
		lastCountry = newCountry
	end)
	
	local lastElo = PD:WaitForChild("Elo").Value
	PD:WaitForChild("Elo").Changed:Connect(function()
		local newElo = PD:WaitForChild("Elo").Value
		
		GlobalLeaderboardsModule:RegisterNationElo(PD.Country.Value, newElo - lastElo)
		
		lastElo = newElo
	end)
	
	return PD
end

local function Fight_Data_Non_Saveable(Plr)
	local Fight_Data_F = Instance.new("Folder", Plr)
	Fight_Data_F.Name = "Fight_Data"
	
	local Health_V = Instance.new("IntValue", Fight_Data_F)
	Health_V.Name = "Health"
	Health_V.Value = Fight_Params_Mod.Health.Max_Value
	
	local Stam_V = Instance.new("IntValue", Fight_Data_F)
	Stam_V.Name = "Staminia"
	Stam_V.Value = Fight_Params_Mod.Stamina.Max_Value
	Stam_V:SetAttribute("Is_Dodging", false)
	
	local Strike_Power_V = Instance.new("NumberValue", Fight_Data_F)
	Strike_Power_V.Name = "Strike Power"
	Strike_Power_V.Value = Fight_Params_Mod.Punch_Power.Max_Value
	
	local Block_Power_V = Instance.new("IntValue", Fight_Data_F)
	Block_Power_V.Name = "Block Power"
	Block_Power_V.Value = Fight_Params_Mod.Block_Power.Max_Value
	Block_Power_V:SetAttribute("Is_Blocking", false)
end

local function Update_Player_Friend_Boosts()
	local All_Plrs = game.Players:GetPlayers()

	local function Get_Friends_Count(P)
		local function Is_Friends_Async(Other_Plr)
			local function Async()
				local Data = nil
				local success, errormessage = pcall(function()
					Data = P:IsFriendsWith(Other_Plr.UserId)
				end)

				if(success and Data ~= nil)then
					return Data
				end
				return nil
			end

			for i = 1, 3 do
				local D = Async()
				if(D ~= nil)then
					return D
				end
			end
			return false
		end

		local Count = 0

		for i = 1, #All_Plrs do
			if(All_Plrs[i] ~= nil and All_Plrs[i] ~= P and Is_Friends_Async(All_Plrs[i]))then
				Count = Count + 1
			end
		end

		return Count
	end

	for i = 1, #All_Plrs do
		local Plr = All_Plrs[i]
		if(Plr ~= nil)then
			Plr:SetAttribute("Friends_Count", Get_Friends_Count(Plr))
		end
	end
end

local function Init_Gamepass_Data(Plr)
	local Gamepass_Val = Plr:WaitForChild("Player_Data"):WaitForChild("Owned Gamepasses")
	local Gamepass_Data = Monetization_Mod.Get_All_Gamepass_Data()
	local Owned_Keys = Monetization_Mod.Get_Player_Owned_Gamepasses_Keys(Plr)

	for GP_Key, GP_Data in next, Gamepass_Data do
		if(table.find(Owned_Keys, GP_Key) == nil and Monetization_Mod.Hard_Gamepass_Check(Plr, GP_Data['ID']))then
			table.insert(Owned_Keys, GP_Key)
		end
	end
	Gamepass_Val.Value = table.concat(Owned_Keys, ",")
end

local function Save_Player_Data(Plr)
	-- NEW PARADIGM: use only numeric userId key
	local Plr_Key = tostring(Plr.UserId)
	
	local PD_Vals = Plr:FindFirstChild("Player_Data"):GetChildren()
	local Current_Player_Data = {
		--General Player Stats
		['Total Sessions'] = 0,
		['Total Playtime'] = 0,
		['Elo'] = 400,
		['Coins'] = 0,
		['Gems'] = 0,
		['Bio'] = "",
		['Country'] = "United States",
		--['League'] = "Rookie",
		--['League_Wins'] = 0,
		--['League_Matches'] = 0,
		--['League_Ties'] = 0,
		['Body Type'] = "Male",
		['Skin Tone'] = "234,184,146",
		['Right Handed'] = true,
		['Creator Code'] = "",
		['Win Streak'] = 0,
		['Total Wins'] = 0,
		['League Matches'] = 0,
		['League Wins'] = 0,
		['Total Ties'] = 0,
		['Total Matches'] = 0,
		['Ranked Wins'] = 0,
		['Ranked Matches'] = 0,
		['Ranked Ties'] = 0,
		['Total Strikes'] = 0,
		['Strikes Landed'] = 0,
		['Dodged Strikes'] = 0,
		['Takedowns Landed'] = 0,
		['Takedowns Attempted'] = 0,
		['Submissions Finished'] = 0,
		['Submissions Attempted'] = 0,
		['Punch Knockout Wins'] = 0,
		['Leg Knockout Wins'] = 0,
		['Submissions Wins'] = 0,
		['Gym Training'] = 0,
		['GymEventRewards'] = 0,

		['Power per Strike'] = 2.5,
		['Strike Defense'] = 30,
		['Submission Timeout'] = 1,
		['Submission Defense'] = 1,
		['Staminia'] = 100,

		['StarterPackTimer'] = nil,
		['DiscordReward'] = false,

		--General Player Data
		['Codes'] = {},
		['Previous Session Time'] = os.time(),
		['Retention Streak'] = 1,
		['Raw Prev Session Time'] = os.time(),
		['Redeemed Rewards'] = {},
		['Owned Gamepasses'] = {},
		['Owned Products'] = {},
		['Redeemed Skill Tree'] = {},

		-- Session Rewards (NEW SL)
		['SR_Day'] = os.date("!%Y-%m-%d"),
		['SR_Count'] = 0,
		['SR_ClaimedTimes'] = "",

		--Player Inventory Data
		['Current Shorts'] = "A",
		['Current Gloves'] = "A",
		['Current Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Owned Shorts'] = {"A"},
		['Owned Gloves'] = {"A"},
		['Owned Special Strikes'] = {},
		['Owned Special Submissions'] = {},
		['Owned Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Punch Combo'] = {"C", "A", "B","C", "A", "G"},
		['Kick Combo'] = {"F", "D", "E","F", "J", "H"},
		['Strike Combo 1'] = {"C", "A", "B"},
		['Strike Combo 2'] = {"F", "D", "E"},
		['Strike Combo 3'] = {"G", "L", "M"},
		['Strike Combo 4'] = {"F", "J", "H"},
		['Fight Intro Key'] = "A",
		['Fight Outro Key'] = "A",
		['Takedown Key'] = "A",
		['Submission Key'] = "A",

		--Player Settings
		['Background Music'] = true,
		['Sound Effects'] = true,
		['Voice Over'] = true,
		['Fight Prompts'] = true,
		['Trading'] = true,

	}

	for i = 1, #PD_Vals do
		local Key, Data = PD_Vals[i].Name, PD_Vals[i].Value
		if(typeof(Current_Player_Data[Key]) == "table")then
			Current_Player_Data[Key] = string.split(Data, ",")
		else
			Current_Player_Data[Key] = Data
		end

		--Leaderboard Data
		if(table.find(Leaderboard_Keys, Key) ~= nil)then
			DS_Mod.Save_Leaderboard(Plr_Key, Key, Data)
		end
	end

	--DS_Mod.Save_Data(Plr_Key, PLAYER_DATA_KEY, Current_Player_Data)
	-- Save always uses the NEW datastore format
	DS_Mod.Save_Data(Plr_Key, PLAYER_DATA_KEY, Current_Player_Data)
end

local function Update_Player_Data_Val(P_ID, Key, New_Data)
	-- NEW PARADIGM
	local Plr_Key = tostring(P_ID)
	
	local P_Data = DS_Mod.Load_Data(Plr_Key, PLAYER_DATA_KEY)
	if(P_Data[Key] ~= nil)then
		P_Data[Key] = New_Data
	end

	DS_Mod.Save_Data(Plr_Key, PLAYER_DATA_KEY, P_Data)
	print("Successfully Updated Player Data Value: " .. Key)
end

local function Handle_Reset_Profile(adminPlayer, targetPlayer, preserveKeys)

	local KEYS_TO_PRESERVE = {
		"Coins",
		"Gems",
		"Owned Gamepasses",
		"Owned Special Strikes",
		"Owned Products",
		"Owned Shorts",
		"Owned Special Submissions",
		"Owned Gloves",
		"Redeemed Skill Tree"
	}

	if not PlayerUtils.isAdmin(adminPlayer) then
		return
	end

	if not targetPlayer then
		targetPlayer = adminPlayer
	end

	local userId = targetPlayer.UserId

	-- Keep backup
	local oldData = preserveKeys and (DS_Mod.Load_Data(userId, PLAYER_DATA_KEY) or {}) or nil

	-- Wipe DS
	DS_Mod.Save_Data(userId, PLAYER_DATA_KEY, nil)

	-- Reset the Player_Data folder
	local pdata = targetPlayer:FindFirstChild("Player_Data")
	if pdata then
		pdata:Destroy()
	end

	task.wait(0.5)
	Load_Player_Data(targetPlayer)
	Fight_Data_Non_Saveable(targetPlayer)

	-- Restore preserved keys
	if preserveKeys and oldData then

		for _, key in ipairs(KEYS_TO_PRESERVE) do
			local value = oldData[key]

			if value ~= nil then
				-- Restore DataStore using the official helper
				Update_Player_Data_Val(userId, key, value)

				-- Restore in-memory Player_Data only if it's a simple value
				local inst = targetPlayer.Player_Data:FindFirstChild(key)
				if inst and typeof(value) ~= "table" and inst:IsA("ValueBase") then
					inst.Value = value
				end
			end
		end
	end

	-- Notify
	Server_Chat:FireClient(
		adminPlayer,
		"Profile for " .. targetPlayer.Name .. " has been reset.",
		Color3.fromRGB(255, 150, 0)
	)

	Server_Chat:FireClient(
		targetPlayer,
		"Your profile has been reset by an administrator.",
		Color3.fromRGB(255, 60, 60)
	)

	Update_Player_List:FireAllClients(targetPlayer, true)
	Update_Server_Data:Fire()
end

Utils.SecureRemote(
	Reset_Player_Profile,
	function(adminPlayer, targetPlayer)

		-- strict server-side admin check
		if not PlayerUtils.isAdmin(adminPlayer) then
			return
		end

		-- default behavior: target = admin
		if targetPlayer == nil then
			targetPlayer = adminPlayer
		end

		Handle_Reset_Profile(adminPlayer, targetPlayer)
	end,
	{ "Instance" }, 
	{
		RateLimit = 1,
		MaxBurst = 5,
		PunishThreshold = 3
	}
)

Utils.SecureRemote(
	Set_Creator_Reward_Code,

	function(plr, newCodeIndex)
		-- Type-check strict
		if typeof(newCodeIndex) ~= "number" then
			return
		end

		-- Hard integer floor to avoid decimals
		newCodeIndex = math.floor(newCodeIndex)

		-- Load player data
		local plrData = plr:FindFirstChild("Player_Data")
		if not plrData then return end

		local creatorCodeVal = plrData:FindFirstChild("Creator Code")
		if not creatorCodeVal then return end

		-- Load creator code table
		local codes = require(game.ReplicatedStorage.Modules.CreatorCodes)

		-- If valid index → apply
		if codes[newCodeIndex] ~= nil then
			creatorCodeVal.Value = newCodeIndex
		else
			-- If invalid, wipe safely (as in your original logic)
			creatorCodeVal.Value = ""
		end
	end,

	{ "number" },

	{
		AllowMissingArgs = false,

		-- Prevent spam resets (super important due to DS hits)
		RateLimit = 1,        -- 1 request per second max
		MaxBurst = 2,         -- small buffer for UI double-clicks
		PunishThreshold = 12, -- only hackers trigger this
	}
)

local function isForcedFirstTimePlayer(Plr)
	if RunService:IsStudio() then
		return false
	else
		local ConfigService = game:GetService("ConfigService")
		local config = ConfigService:GetConfigAsync() 
		local isFirstPlayer = config:GetValue("isFirstPlayer")
		return isFirstPlayer == true	
	end
end

game.Players.PlayerAdded:Connect(function(Plr)
	local pdata = Load_Player_Data(Plr)
	
	Fight_Data_Non_Saveable(Plr)
	
	--Set up Attributes
	Player_In_Group_RF:Invoke(Plr)
	PlayerUtils.Is_Premium_Member(Plr)
	
	Update_Player_Friend_Boosts()

	local Welcome_Badge_ID = Utils.getWelcomeBadgeId()
	local Owns_Welcome = Player_Owns_Badge_RF:Invoke(Plr, Welcome_Badge_ID)
	local isFirstTimePlayer = not Owns_Welcome or isForcedFirstTimePlayer(Plr)
	Plr:SetAttribute("First_Time_Player", isFirstTimePlayer)
	
	--Give Welcome Badge
	if(Owns_Welcome == false)then
		Award_Badge:Fire(Plr, Welcome_Badge_ID)
	end
	
	Update_Retention_Streak(Plr)	
	
	--INIT MONETIZATION HANDLE TO GIVE PLAYERS THE GAMEPASSES THEY INITIALLY BOUGHT FROM WEBSITE
	Init_Gamepass_Data(Plr)
	local Is_VIP = Monetization_Mod.Does_Player_Own_Gamepass_Key(Plr, "A")
	Plr:SetAttribute("Is_VIP", Is_VIP)
	
	if Plr.Player_Data.Vip.Value == true then
		Plr:SetAttribute("Is_VIP", true)
	end

	if Plr:GetAttribute("Is_VIP") then
		local Txt = "A VIP Player has Joined! Welcome back " .. Plr.Name .. "!"
		Server_Chat:FireAllClients(Txt, Color3.fromRGB(255, 170, 0))
	end

	Player_Leaderboard_Data:Fire(Plr)
	Update_Server_Data:Fire()
	Update_Player_List:FireAllClients(Plr, true)	
	
	task.defer(function()
		Game_Startup_Ready:FireClient(Plr, {
			firstTime = Plr:GetAttribute("First_Time_Player")
		})
	end)
end)

game.Players.PlayerMembershipChanged:Connect(function(Plr)
	if(Plr.MembershipType == Enum.MembershipType.Premium)then
		Plr:SetAttribute("Is_Premium", true)
	end
end)

game.Players.PlayerRemoving:Connect(function(Plr)
	task.defer(function()
		Save_Player_Data(Plr)

		Update_Player_Friend_Boosts()
		Update_Server_Data:Fire()
		Update_Player_List:FireAllClients(Plr, false)
	end)
end)

game:BindToClose(function()
	if(game:GetService("RunService"):IsStudio())then
		return
	end
	
	local Plrs = game.Players:GetPlayers()
	local savePromises = {}
	
	-- Start all saves in parallel
	for i = 1, #Plrs do
		if(Plrs[i] ~= nil)then
			table.insert(savePromises, task.spawn(function()
				local success, err = pcall(function()
					Save_Player_Data(Plrs[i])
				end)
				if not success then
					warn("Failed to save data for " .. Plrs[i].Name .. ": " .. tostring(err))
				end
			end))
		end
	end
	
	-- Wait for all saves to complete (max 10 seconds timeout)
	local startTime = tick()
	for _, promise in ipairs(savePromises) do
		local elapsed = tick() - startTime
		if elapsed >= 10 then
			warn("BindToClose: Timeout reached, some data may not have saved")
			break
		end
		task.wait(0.1)
	end
	print("BindToClose: All players data save attempts completed")
end)

while task.wait(SAVE_DATA_INTERVAL) do
	local playerList = game:GetService("Players"):GetPlayers()
	for _, Plr in pairs(playerList) do
		local success, err = pcall(function()
			Save_Player_Data(Plr)
		end)
		print(`Auto-saving for player {Plr} was {success and "successful" or "errored"}`)
	end
end]]></ProtectedString>
							<string name="ScriptGuid">{48BFEB26-FDC6-4955-B927-23F1135372DB}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">DS_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXD48B731353E548699BAD7D70236A5435">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Archives</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX98DBF6291579485B8E90E6C9D45BFD03">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Roblox ServerScript : Award Halloween 2025 Badge only during event period
local RS = game:GetService("ReplicatedStorage")
local BadgeService = game:GetService("BadgeService")
local Players = game:GetService("Players")

local Channels 	= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Display_Data_E = Channels.Bindable_Events.Display_Data

-- Replace this with your actual Badge ID
local BADGE_ID = 428903715368330

-- Define event period (UTC time)
local EVENT_START = os.time({year = 2025, month = 10, day = 24, hour = 0, min = 0, sec = 0})
local EVENT_END   = os.time({year = 2025, month = 11, day = 14, hour = 0, min = 0, sec = 0})

-- Function to check if the current time is within the event period
local function isWithinEventPeriod()
	local now = os.time()
	return now >= EVENT_START and now < EVENT_END
end

-- Function to award the badge safely
local function awardBadge(player)
	local success, hasBadge = pcall(function()
		return BadgeService:UserHasBadgeAsync(player.UserId, BADGE_ID)
	end)

	if success and not hasBadge then
		local ok, result = pcall(function()
			return BadgeService:AwardBadge(player.UserId, BADGE_ID)
		end)

		if ok then
			Display_Data_E:FireClient(player, "🎃 Halloween Champion 2025 badge awarded to " .. player.Name, Color3.fromRGB(255, 170, 0))
		end
	end
end

-- Main event trigger
Players.PlayerAdded:Connect(function(player)
	if isWithinEventPeriod() then
		task.wait(20)
		awardBadge(player)
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{A50D5FC2-3704-4B6F-A277-ECF109EADE3B}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">HalloweenBadge.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX29BEF0EC96814AF2B6589747DA771FCC">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local RS = game:GetService("ReplicatedStorage")
local DataStoreService = game:GetService("DataStoreService")
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

local M_LOG = "PLAYER_MIGRATION_LOG"

local Channels = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Admin_Notification = Channels.SC_Remote_Events.Admin_Notification

local function countKeys(dsName)
	local ds = DataStoreService:GetDataStore(dsName)

	local ok, pages = pcall(function()
		return ds:ListKeysAsync()
	end)

	if not ok or not pages then
		return 0
	end

	local function processPage(pageObj, acc)
		acc += #pageObj:GetCurrentPage()

		if pageObj.IsFinished then
			return acc
		end

		local okNext = pcall(function()
			pageObj:AdvanceToNextPageAsync()
		end)

		if not okNext then
			return acc
		end

		return processPage(pageObj, acc)
	end

	return processPage(pages, 0)
end

game.Players.PlayerAdded:Connect(function(plr)
	plr.Chatted:Connect(function(msg)
		if msg == "/migration_stats" then
			if not PlayerUtils.isAdmin(plr) then
				return
			end

			local migrated = countKeys(M_LOG)

			Admin_Notification:FireClient(
				plr,
				"Migration Stats",
				string.format("Migrated players: %d", migrated)
			)

			print("[Migration] Migrated count:", migrated)
		end
	end)
end)
]]></ProtectedString>
							<string name="ScriptGuid">{CBA252AB-7195-4F4C-AB7C-39F3B7DF057D}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">MigrationStats.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX91AF99CEC9A04CEE883119CA94E21B5F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local DataStoreService = game:GetService("DataStoreService")

local M_LOG = "PLAYER_MIGRATION_LOG"
local CONTROL_DS = "PLAYER_MIGRATION_CLEANUP_PROGRESS"
local OLD_SUFFIX = "_Game_Data"

local DS_Mod = require(script.Parent.Parent.Core.Datastore.DS_Module)
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

local BATCH_DELAY = 0.3          -- delay between each delete
local ERROR_DELAY = 5            -- delay after any failure
local PROGRESS_KEY = "last_key"  -- resume cursor

local function safeWait(t)
	task.wait(t or BATCH_DELAY)
end

local function cleanup(plr)
	local logDS = DataStoreService:GetDataStore(M_LOG)
	local controlDS = DataStoreService:GetDataStore(CONTROL_DS)

	-- Load last processed key
	local lastKey = nil
	pcall(function()
		lastKey = controlDS:GetAsync(PROGRESS_KEY)
	end)

	local pages
	local ok, err = pcall(function()
		pages = logDS:ListKeysAsync(lastKey)
	end)

	if not ok or not pages then
		warn("Cannot list migration log keys:", err)
		return
	end

	local deleted = 0

	while true do
		for _, entry in ipairs(pages:GetCurrentPage()) do
			local userId = entry.KeyName
			local oldKey = userId .. OLD_SUFFIX

			local success = false
			while not success do
				local okDel, errDel = pcall(function()
					DS_Mod.Delete_Legacy_DataStore(oldKey, "PLAYER_DATASTORE_LIVE")
				end)

				if okDel then
					success = true
					deleted += 1

					-- persist progress
					pcall(function()
						controlDS:SetAsync(PROGRESS_KEY, userId)
					end)

					safeWait()
				else
					warn("Delete failed for", userId, errDel)
					safeWait(ERROR_DELAY)
				end
			end
		end

		if pages.IsFinished then
			break
		end

		local okPage = pcall(function()
			pages:AdvanceToNextPageAsync()
		end)

		if not okPage then
			warn("Page advance failed, retrying after delay")
			safeWait(ERROR_DELAY)
		end
	end

	plr:SendNotification({
		Title = "Migration Cleanup Done",
		Text = "Deleted old datastores for " .. tostring(deleted) .. " players",
		Duration = 8
	})

	print("[Migration] Cleanup complete, deleted:", deleted)
end

game.Players.PlayerAdded:Connect(function(plr)
	plr.Chatted:Connect(function(msg)
		if msg == "!cleanup_migrated" then
			if not PlayerUtils.isAdmin(plr) then
				plr:Kick("You are not allowed to run migration cleanup.")
				return
			end

			task.spawn(function()
				cleanup(plr)
			end)
		end
	end)
end)
]]></ProtectedString>
							<string name="ScriptGuid">{907964AD-7D27-4822-95DF-4F84F279D4AC}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">MigrationCleanup.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX0F27D007A7F64A6A897ED5B33FDFC38D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">League_Service</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXE70190DA277043A09272980538177F55">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ServerScriptService/League_Service/Tournament_Manager.lua
-- ==========================================================
-- Tournament_Manager
--
-- Orchestrates weekly League tournaments by division:
--   - Schedules and starts tournaments (Saturday 18:00 UTC)
--   - Manages per-division lifecycle (Waiting → Active → Ended)
--   - Handles player registration and queueing
--   - Performs matchmaking within each division
--   - Tracks live scores and rankings
--   - Applies LP rewards and penalties
--   - Triggers promotions and demotions via League_Manager
--   - Awards participation and winner badges
--   - Broadcasts live and final results to clients
--
-- Key characteristics:
--   - Division-isolated tournaments (Bronze → Legend)
--   - Event-driven lifecycle (Messaging/Timers)
--   - Real-time updates through RemoteEvents
--   - Offline-safe progression (promotion/demotion by UserId)
--   - Shard-local authority: one manager per TOURNAMENT server
--   - Context-aware: active only when Server_Context.Mode == TOURNAMENT
--   - Physical waiting zones drive matchmaking entry
--
-- Responsibilities:
--   - Start/End all divisions for a weekly tournament
--   - Register/Unregister players
--   - Build and broadcast live rankings
--   - Pair players for fights
--   - Process match results
--   - Apply League outcomes (LP, wins/losses, promotions)
--   - Rotate League season at global tournament end
--
-- Author(s): Darkzeb
-- Last Modified: 2026-01
-- ==========================================================

local RS 						= game:GetService("ReplicatedStorage")
local Players 					= game:GetService("Players")
local ServerScriptService 		= game:GetService("ServerScriptService")

local Server_Context 			= workspace:WaitForChild("Server_Context")

local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local League_Manager 			= require(ServerScriptService.League_Service:WaitForChild("League_Manager"))

local Global_Params_Mod			= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))
local League_Mod 				= require(Data_Mods_F:WaitForChild("League_Mod"))
local PlayerUtils 				= require(game.ReplicatedStorage.Modules.PlayerUtils)

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Client -> Server
local RegisterRE 				= Channels.CS_Remote_Events.Tournament_Register

-- Server -> Client
local Tournament_Update 		= Channels.SC_Remote_Events.Tournament_Update
local Tournament_Results 		= Channels.SC_Remote_Events.Tournament_Results

-- Server bindables
local Tournament_Fight_Ended 	= Channels.Bindable_Events.Tournament_Fight_Ended
local Tournament_Score_Updated 	= Channels.Bindable_Events.Tournament_Score_Updated

local Tournament_Manager = {}

-- Weekly schedule: Saturday 18:00 UTC
Tournament_Manager.TOURNAMENT_WEEKDAY = 7 -- Saturday (Lua: 1=Sunday ... 7=Saturday)
Tournament_Manager.TOURNAMENT_HOUR = 18
Tournament_Manager.TOURNAMENT_MIN = 0

Tournament_Manager.IsTournamentActive = false
Tournament_Manager.Divisions = {}
Tournament_Manager.ActiveFights = {}

-- =========================
-- LP / ELO weighted config
-- =========================
Tournament_Manager.BASE_LP_WIN  = 20
Tournament_Manager.BASE_LP_LOSS = -10
Tournament_Manager.ELO_FACTOR   = 0.02
Tournament_Manager.MAX_BONUS    = 15
Tournament_Manager.MAX_MALUS    = -15
Tournament_Manager.LEAVE_PENALTY = -25

local function clamp(v, min, max)
	return math.max(min, math.min(max, v))
end

local function computeLPDelta(winnerElo, loserElo)
	local diff = loserElo - winnerElo
	local bonus = clamp(diff * Tournament_Manager.ELO_FACTOR, Tournament_Manager.MAX_MALUS, Tournament_Manager.MAX_BONUS)

	local winnerLP = math.floor(Tournament_Manager.BASE_LP_WIN + bonus)
	local loserLP  = math.floor(Tournament_Manager.BASE_LP_LOSS - bonus)

	return winnerLP, loserLP
end

local function getNextSaturday18UTC(now)
	local t = os.date("!*t", now) -- UTC time table

	local deltaDays = (Tournament_Manager.TOURNAMENT_WEEKDAY - t.wday) % 7

	local candidate = {
		year = t.year,
		month = t.month,
		day = t.day + deltaDays,
		hour = Tournament_Manager.TOURNAMENT_HOUR,
		min = Tournament_Manager.TOURNAMENT_MIN,
		sec = 0,
		isdst = false,
	}

	local candidateTs = os.time(candidate)

	-- If it's already past 18:00 UTC on Saturday → next week
	if deltaDays == 0 and now >= candidateTs then
		candidateTs += 7 * 24 * 60 * 60
	end

	return candidateTs
end

local function getNextTournamentStartUTC()
	return getNextSaturday18UTC(os.time())
end

-- =========================
-- Helpers
-- =========================

local function getParticipantName(participant)
	if typeof(participant) == "Instance" then
		return participant.Name
	end
	return "Unknown"
end

local function getCharacter(participant)
	if participant and participant:IsA("Player") then
		return participant.Character
	end
	if participant and participant:IsA("Instance") and participant:FindFirstChild("CharacterModel") then
		local ov = participant.CharacterModel
		return ov and ov.Value
	end
	return nil
end

local function buildRanking(scores)
	local ranking = {}
	for userId, entry in pairs(scores) do
		table.insert(ranking, {
			UserId = userId,
			Name = entry.Name,
			Score = entry.LP or entry.Score or 0
		})
	end
	table.sort(ranking, function(a, b)
		return (a.Score or 0) > (b.Score or 0)
	end)
	return ranking
end

function Tournament_Manager:BroadcastDivision(divisionName)
	local d = self.Divisions[divisionName]
	if not d then return end

	local ranking = buildRanking(d.Scores)

	Tournament_Update:FireAllClients({
		Type = "live",
		Division = divisionName,
		IsActive = (d.State == "Active"),
		Ranking = ranking,
		Timestamp = os.time(),
	})
end

function Tournament_Manager:SendPlayerState(player, divisionName)
	if not player or not player:IsA("Player") then return end
	local d = self.Divisions[divisionName]
	if not d then return end

	local userId = player.UserId
	local score = (d.Scores[userId] and d.Scores[userId].Score) or 0

	Tournament_Update:FireClient(player, {
		Status = d.Registered[userId] and "Registered" or "Unregistered",
		Division = divisionName,
		Score = score,
		NextStartTime = d.StartTime,
		IsActive = (d.State == "Active")
	})
end

-- =========================
-- Lifecycle
-- =========================
function Tournament_Manager:StartAllDivisions()
	if self.IsTournamentActive then
		warn("[TOURNAMENT] StartAllDivisions ignored: tournament already active")
		return
	end

	local duration = League_Mod.Config.Global.TournamentDuration
	local now = os.time()

	self.IsTournamentActive = true

	for _, divisionName in ipairs(League_Manager.Divisions) do
		self:StartDivisionTournament(divisionName, now, duration)
	end

	task.delay(duration, function()
		self:EndAllDivisions()
	end)
end

function Tournament_Manager:StartDivisionTournament(divisionName, startTime, duration)
	self.Divisions[divisionName] = self.Divisions[divisionName] or {}
	local d = self.Divisions[divisionName]

	d.State = "Active"
	d.StartTime = startTime
	d.EndTime = startTime + duration
	d.Registered = d.Registered or {}
	d.Queue = d.Queue or {}
	d.Scores = d.Scores or {}

	print(("[TOURNAMENT] Division %s started (%ds)"):format(divisionName, duration))

	-- Optional: auto-register online players of this division
	for _, plr in ipairs(Players:GetPlayers()) do
		local div = League_Manager:GetDivision(plr)
		if div == divisionName then
			self:RegisterPlayer(plr)
		end
	end

	self:BroadcastDivision(divisionName)
	
	-- Instant matchmaking
	task.defer(function()
		--TODO matchmaking logic here
	end)
end

function Tournament_Manager:EndAllDivisions()
	for divisionName, _ in pairs(self.Divisions) do
		self:EndDivisionTournament(divisionName)
	end
	self.IsTournamentActive = false
	
	local ok, newKey = League_Manager:RotateWeeklySeason()
	print("[TOURNAMENT] League season rotated:", ok, newKey)
end
function Tournament_Manager:EndDivisionTournament(divisionName)
	local d = self.Divisions[divisionName]
	if not d then return end
	if d.State ~= "Active" then return end

	d.State = "Ended"
	d.StartTime = getNextTournamentStartUTC()

	local ranking = buildRanking(d.Scores)
	local playerCount = #ranking

	local cfg = League_Mod.Config[divisionName]
	local promotionRate = cfg.promotionRate or 0
	local demotionRate  = cfg.demotionRate  or 0

	-- Compute dynamic slots from rates
	local promotionCount = promotionRate > 0 and math.max(1, math.floor(playerCount * promotionRate)) or 0
	local demotionCount  = demotionRate  > 0 and math.max(1, math.floor(playerCount * demotionRate))  or 0

	print(("[TOURNAMENT] Ending %s | %d ranked players | +%d / -%d"):format(
		divisionName, playerCount, promotionCount, demotionCount
		))

	for i, entry in ipairs(ranking) do
		local lpChange = 0
		local status = "Stable"

		if promotionCount > 0 and i <= promotionCount then
			status = "Promoted"
			League_Manager:PromoteByUserId(entry.UserId)
		elseif demotionCount > 0 and i > (playerCount - demotionCount) then
			status = "Demoted"
			League_Manager:DemoteByUserId(entry.UserId)
		end

		print(string.format("[TOURNAMENT] %-16s #%d | %d pts | %+d LP | %s",
			entry.Name, i, entry.Score or 0, lpChange, status))
	end

	-- Award division badge to #1
	local winner = ranking[1]
	if winner then
		local badgeId = League_Mod.Winner_Badges[divisionName].id
		local badgeName = League_Mod.Winner_Badges[divisionName].name
		local ok = PlayerUtils.Award_Badge(winner, badgeId)
		if ok then
			print("[LEAGUE] Winner badge awarded:", divisionName, winner.Name)
		end
	end

	-- Notify clients (final)
	Tournament_Results:FireAllClients({
		Division = divisionName,
		Rankings = ranking,
		Timestamp = os.time(),
	})

	-- Clear runtime queues for next tournament
	d.Registered = {}
	d.Queue = {}
	d.Scores = {}
	self.ActiveFights = {}

	self:BroadcastDivision(divisionName)

	print(("[TOURNAMENT] Division %s ended and reset."):format(divisionName))
end


-- =========================
-- Registration
-- =========================
function Tournament_Manager:RegisterPlayer(player)
	local divisionName = League_Manager:GetDivision(player)
	if divisionName == "Unranked" then
		divisionName = "Bronze"
	end

	self.Divisions[divisionName] = self.Divisions[divisionName] or {
		State = "Waiting",
		Registered = {},
		Queue = {},
		Scores = {},
		StartTime = getNextTournamentStartUTC()
	}

	local d = self.Divisions[divisionName]
	local userId = player.UserId
	if not userId then return end

	if d.Registered[userId] then
		self:SendPlayerState(player, divisionName)
		return
	end

	d.Registered[userId] = player
	d.Scores[userId] = d.Scores[userId] or {
		Name = getParticipantName(player),
		Score = 0
	}

	table.insert(d.Queue, player)

	print(string.format(
		"[TOURNAMENT] %s registered for %s division tournament (%s)",
		getParticipantName(player),
		divisionName,
		d.State
		))

	if player:IsA("Player") then
		local badgeId = League_Mod.Participant_Badges[divisionName].id
		local badgeName = League_Mod.Participant_Badges[divisionName].name
		local ok, result = PlayerUtils.Award_Badge(player, badgeId)
		if ok then
			print("[LEAGUE] Participation badge awarded:", divisionName, player.Name)
		end
		
		Tournament_Update:FireClient(player, {
			Status = "Registered",
			Pending = (d.State ~= "Active"),
			Division = divisionName,
			Score = d.Scores[userId].Score,
			NextStartTime = d.StartTime,
			IsActive = (d.State == "Active")
		})
	end

	-- If tournament already running, try immediate matchmaking
	if d.State == "Active" then
		task.defer(function()
			self:TryMatchPlayers(divisionName)
		end)
	end
end

function Tournament_Manager:UnregisterPlayer(player)
	local userId = player.UserId
	if not userId then return end

	for divisionName, d in pairs(self.Divisions) do
		if d and d.Registered and d.Registered[userId] then
			d.Registered[userId] = nil

			-- remove from queue
			for i = #d.Queue, 1, -1 do
				if d.Queue[i].UserId == userId then
					table.remove(d.Queue, i)
				end
			end

			print(("[TOURNAMENT] %s unregistered from %s"):format(getParticipantName(player), divisionName))

			---- =========================
			---- LP LEAVE PENALTY (HERE)
			---- =========================
			--d.Scores[userId] = d.Scores[userId]
			--	or { Name = getParticipantName(player), LP = 0 }

			--d.Scores[userId].LP += Tournament_Manager.LEAVE_PENALTY

			--Tournament_Score_Updated:Fire({
			--	Division = divisionName,
			--	UserId = userId,
			--	Name = getParticipantName(player),
			--	LPDelta = Tournament_Manager.LEAVE_PENALTY,
			--	TotalLP = d.Scores[userId].LP,
			--	Reason = "Leave",
			--	Timestamp = os.time(),
			--})
			
			if player and player:IsA("Player") then
				Tournament_Update:FireClient(player, { 
					Status = "Unregistered",
					NextStartTime = d.StartTime
				})
			end

			self:BroadcastDivision(divisionName)
			return
		end
	end
end

function Tournament_Manager:CollectMatchPairs(divisionName)
	local d = self.Divisions[divisionName]
	if not d or d.State ~= "Active" then return {} end

	-- Clean queue
	local cleaned = {}
	for _, p in ipairs(d.Queue) do
		local uid = p.UserId
		if uid and d.Registered[uid] and not self.ActiveFights[uid] then
			table.insert(cleaned, p)
		end
	end
	d.Queue = cleaned

	local pairs = {}

	while #d.Queue >= 2 do
		local p1 = table.remove(d.Queue, 1)
		local p2 = table.remove(d.Queue, 1)

		local p1Id = p1.UserId
		local p2Id = p2.UserId
		if not p1Id or not p2Id then break end

		self.ActiveFights[p1Id] = true
		self.ActiveFights[p2Id] = true

		table.insert(pairs, {
			P1 = p1,
			P2 = p2,
			P1Id = p1Id,
			P2Id = p2Id,
		})
	end

	return pairs
end

-- =========================
-- Matchmaking + fights
-- =========================
function Tournament_Manager:TryMatchPlayers(divisionName)
	for _, match in ipairs(self:CollectMatchPairs(divisionName)) do
		--local cage = Cage_Factory:CreateCage(Fight_Params_Mod.CageType.LEAGUE)
		
		-- TODO Oriane update this
		
		--if not cage then
		--	warn("[TOURNAMENT] Failed to create cage")
		--	self.ActiveFights[match.P1Id] = nil
		--	self.ActiveFights[match.P2Id] = nil
		--	return
		--end

		local c1 = getCharacter(match.P1)
		local c2 = getCharacter(match.P2)
		if not c1 or not c2 then
			self.ActiveFights[match.P1Id] = nil
			self.ActiveFights[match.P2Id] = nil
			--Cage_Factory:DestroyArena(cage.Name)
			return
		end

		--cage:SetAttribute("TournamentDivision", divisionName)
		--cage:SetAttribute("P1UserId", match.P1Id)
		--cage:SetAttribute("P2UserId", match.P2Id)

		print(("[TOURNAMENT][LOCAL] %s vs %s"):format(
			getParticipantName(match.P1),
			getParticipantName(match.P2)
			))

		--task.spawn(function()
		--	Start_Core_Fight:Fire(cage, c1, c2)
		--end)
	end
end

function Tournament_Manager:OnMatchFinished(result)
	-- Expected: result.Players[1], result.Players[2], result.Winner, result.Arena (we use cage)
	if not result or not result.Players or not result.Winner then return end

	local winner = result.Winner
	local p1 = result.Players[1]
	local p2 = result.Players[2]
	local loser = (winner == p1) and p2 or p1

	local winnerId = winner.UserId
	local loserId = loser.UserId
	if not winnerId or not loserId then
		warn("[TOURNAMENT] Invalid winner/loser in OnMatchFinished")
		return
	end

	local winnerData = League_Manager:LoadPlayerData(winner)
	local loserData = League_Manager:LoadPlayerData(loser)

	local divisionName = (winnerData and winnerData.Division) or "Bronze"
	local d = self.Divisions[divisionName]
	if not d then
		warn("[TOURNAMENT] Missing division data:", divisionName)
		return
	end

	-- Score: +1 win
	d.Scores[winnerId] = d.Scores[winnerId] or { Name = (winnerData and winnerData.Name) or getParticipantName(winner), Score = 0 }
	d.Scores[loserId]  = d.Scores[loserId]  or { Name = (loserData and loserData.Name) or getParticipantName(loser),  Score = 0 }
	d.Scores[winnerId].Score = (d.Scores[winnerId].Score or 0) + 1

	-- League stats / LP
	League_Manager:AddWin(winner)
	League_Manager:AddLoss(loser)
	
	-- =========================
	-- Tournament LP (ELO weighted)
	-- =========================
	local winnerElo = League_Manager:GetLP(winner)
	local loserElo  = League_Manager:GetLP(loser)

	d.Scores[winnerId] = d.Scores[winnerId] or { Name = winner.Name }
	d.Scores[loserId]  = d.Scores[loserId]  or { Name = loser.Name }

	d.Scores[winnerId].LP = d.Scores[winnerId].LP or 0
	d.Scores[loserId].LP  = d.Scores[loserId].LP  or 0

	local lpWin, lpLoss = computeLPDelta(winnerElo, loserElo)

	d.Scores[winnerId].LP += lpWin
	d.Scores[loserId].LP  += lpLoss

	print(string.format(
		"[TOURNAMENT][LP] %s (%d) beat %s (%d) | LP %+d / %+d",
		winner.Name, winnerElo,
		loser.Name, loserElo,
		lpWin, lpLoss
		))

	-- Notify observers (UI / console / analytics)
	Tournament_Score_Updated:Fire({
		Division = divisionName,
		Winner = {
			UserId = winnerId,
			Name = winner.Name,
			LPDelta = lpWin,
			TotalLP = d.Scores[winnerId].LP,
		},
		Loser = {
			UserId = loserId,
			Name = loser.Name,
			LPDelta = lpLoss,
			TotalLP = d.Scores[loserId].LP,
		},
		Timestamp = os.time(),
	})

	print(("[TOURNAMENT] %s defeated %s in %s (+1)"):format(
		d.Scores[winnerId].Name, d.Scores[loserId].Name, divisionName
		))

	-- Cleanup cage
	if result.Source ~= "Arena" and result.Arena then
		--Cage_Factory:DestroyArena(result.Arena.Name)
	end
	
	-- Release fight slots
	self.ActiveFights[winnerId] = nil
	self.ActiveFights[loserId] = nil

	-- Re-queue only if still registered and tournament active
	if d.State == "Active" then
		if d.Registered[winnerId] then table.insert(d.Queue, d.Registered[winnerId]) end
		if d.Registered[loserId] then table.insert(d.Queue, d.Registered[loserId]) end
	end

	-- Live updates
	self:BroadcastDivision(divisionName)

	-- Instant rematch matchmaking
	task.defer(function()
		self:TryMatchPlayers(divisionName)
	end)
end

function Tournament_Manager:EnterWaitingZone(player)
	if Server_Context.Mode.Value ~= Global_Params_Mod.Server_Mode.TOURNAMENT then
		return
	end
	
	local divisionName = League_Manager:GetDivision(player)
	local d = self.Divisions[divisionName]
	if not d or d.State ~= "Active" then return end

	local uid = player.UserId
	if not d.Registered[uid] then return end

	if not table.find(d.Queue, player) then
		table.insert(d.Queue, player)
	end

	task.defer(function()
		self:TryMatchPlayers(divisionName)
	end)
end

-- =========================
-- Events wiring
-- =========================
if RegisterRE and RegisterRE.OnServerEvent then
	RegisterRE.OnServerEvent:Connect(function(player)
		Tournament_Manager:RegisterPlayer(player)
	end)
else
	warn("[TOURNAMENT] Missing CS_Remote_Events.Tournament_Register (registration disabled)")
end

Tournament_Fight_Ended.Event:Connect(function(result)
	Tournament_Manager:OnMatchFinished(result)
end)

Players.PlayerAdded:Connect(function(player)
	task.defer(function()
		local division = League_Manager:GetDivision(player)
		local d = Tournament_Manager.Divisions[division]

		if not d then
			-- division not initialized yet → still send next schedule
			Tournament_Update:FireClient(player, {
				Status = "Unregistered",
				NextStartTime = getNextTournamentStartUTC(),
			})
			return
		end

		Tournament_Update:FireClient(player, {
			Status = d.Registered[player.UserId] and "Registered" or "Unregistered",
			Division = division,
			Score = (d.Scores[player.UserId] and d.Scores[player.UserId].Score) or 0,
			NextStartTime = d.StartTime,
			IsActive = (d.State == "Active")
		})
	end)
end)

task.spawn(function()
	while true do
		local startAt = getNextTournamentStartUTC()
		local delaySeconds = math.max(0, startAt - os.time())
		task.wait(delaySeconds)
		Tournament_Manager:StartAllDivisions()
	end
end)

return Tournament_Manager]]></ProtectedString>
						<string name="ScriptGuid">{7305FDD4-5351-4FEB-BE05-958F432469ED}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tournament_Manager.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF5FAED3C24054B6A8EDB3B7D2B77359A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ServerScriptService/League_Service/League_Manager.lua
-- ==========================================================
-- League_Manager
--
-- Central authority for League data:
--   - Stores and loads per-player League profiles
--   - Manages divisions (Bronze → Legend)
--   - Tracks LP, wins, and losses
--   - Handles promotion and demotion (triggered by Tournament_Manager)
--   - Uses one DataStore per weekly season (LeagueDS_W_YYYY_WW)
--   - Supports offline updates (promotions, demotions, LP changes)
--   - Pushes live updates to clients via RemoteEvents
--
-- Design principles:
--   - Cache-first (PlayerCache keyed by UserId)
--   - Offline-safe persistence
--   - Season rotation is event-driven (not time-driven)
--   - API operates on real Players or UserIds only
--
-- Responsibilities:
--   - Load/Save League profiles
--   - Provide getters (Division, LP, Stats)
--   - Apply LP changes and match outcomes
--   - Promote/Demote players at season end
--   - Rotate weekly League seasons
--
-- Author(s): Darkzeb
-- Last Modified: 2026-01
-- ==========================================================

local RS 						= game:GetService("ReplicatedStorage")
local Players					= game:GetService("Players")
local DataStoreService 			= game:GetService("DataStoreService")

local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local League_Mod 				= require(Data_Mods_F:WaitForChild("League_Mod"))
local Global_Params_Mod			= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Tournament_Leaderboard 	= require(script.Parent:WaitForChild("Tournament_Leaderboard"))

local LeagueUpdateRE 			= Channels.SC_Remote_Events.League_DivisionUpdate

local League_Manager 			= {}

local DEFAULT_LEAGUE 			= Global_Params_Mod.League.MMA_FIGHTERS

League_Manager.Divisions 		= League_Mod.Order
League_Manager.PlayerCache 		= {}

local function BuildSeasonKey(utcTime)
	-- Use same pattern as leaderboards: YYYY_%W
	return "LeagueDS_W_" .. os.date("!%Y_%W", utcTime or os.time())
end

League_Manager.CurrentSeasonKey = BuildSeasonKey(os.time())
League_Manager.LeagueStore = DataStoreService:GetDataStore(League_Manager.CurrentSeasonKey)


local function sortDivisionIndex(division)
	for i, d in ipairs(League_Manager.Divisions) do
		if d == division then
			return i
		end
	end
	return 1
end

function League_Manager:GetNextDivision(current)
	local idx = sortDivisionIndex(current)
	return League_Manager.Divisions[idx + 1]
end

function League_Manager:GetPreviousDivision(current)
	local idx = sortDivisionIndex(current)
	return League_Manager.Divisions[idx - 1]
end

-- =========================
-- DataStore
-- =========================
function League_Manager:LoadPlayerData(player)
	local userId = player.UserId

	if self.PlayerCache[userId] then
		return self.PlayerCache[userId]
	end

	local success, data = pcall(function()
		return self.LeagueStore:GetAsync(userId)
	end)

	if not success or not data then
		data = {
			UserId = userId,
			Name = player.Name,
			ActiveLeague = DEFAULT_LEAGUE,
			Leagues = {}
		}
	end

	-- Normalize root
	data.UserId = userId
	data.Name = data.Name or player.Name
	data.ActiveLeague = data.ActiveLeague or DEFAULT_LEAGUE
	data.Leagues = data.Leagues or {}

	-- Ensure active league profile exists
	local league = data.ActiveLeague
	data.Leagues[league] = data.Leagues[league] or {
		Division = "Bronze",
		LP = 0,
		Wins = 0,
		Losses = 0,
		LastUpdated = os.time(),
	}

	self.PlayerCache[userId] = data
	return data
end


function League_Manager:SavePlayerData(player)
	local userId = player.UserId
	if not userId then return end

	local data = self.PlayerCache[userId]
	if not data then return end

	pcall(function()
		self.LeagueStore:SetAsync(userId, data)
	end)
end

-- =========================
-- Public getters
-- =========================
function League_Manager:GetDivision(player)
	local root = self:LoadPlayerData(player)
	local prof = root.Leagues[root.ActiveLeague]
	return prof.Division
end

function League_Manager:GetLP(player)
	local root = self:LoadPlayerData(player)
	local prof = root.Leagues[root.ActiveLeague]
	return prof.LP
end

function League_Manager:GetStats(player)
	local root = self:LoadPlayerData(player)
	local prof = root.Leagues[root.ActiveLeague]

	return {
		Division = prof.Division,
		LP = prof.LP,
		Wins = prof.Wins,
		Losses = prof.Losses,
	}
end

function League_Manager:RotateWeeklySeason(optionalNextKey)
	local nextKey = optionalNextKey

	if not nextKey then
		-- Default: next week based on UTC time + 7 days
		nextKey = "LeagueDS_W_" .. os.date("!%Y_%W", os.time() + 7 * 24 * 60 * 60)
	end

	if nextKey == self.CurrentSeasonKey then
		return false, "Already on this season"
	end

	self.CurrentSeasonKey = nextKey
	self.CurrentSeason = nextKey
	self.LeagueStore = DataStoreService:GetDataStore(nextKey)

	-- Important: flush cache to avoid mixing seasons
	self.PlayerCache = {}

	warn("[LEAGUE] Rotated weekly season to:", nextKey)
	return true, nextKey
end

local function pushLeagueUI(player, data)
	if player and player:IsA("Player") then
		LeagueUpdateRE:FireClient(player, {
			Division = data.Division,
			Rank = data.LP,
			Wins = data.Wins,
		})
	end
end

-- =========================
-- LP & outcomes
-- =========================
function League_Manager:AddLPByUserId(userId, delta)
	local root = self.PlayerCache[userId]
	if not root then
		local plr = Players:GetPlayerByUserId(userId)
		if plr then
			root = self:LoadPlayerData(plr)
		else
			local ok, data = pcall(function()
				return self.LeagueStore:GetAsync(userId)
			end)
			if not ok or not data then return false end
			root = data
			self.PlayerCache[userId] = root
		end
	end

	local league = root.ActiveLeague or DEFAULT_LEAGUE
	root.Leagues = root.Leagues or {}
	root.Leagues[league] = root.Leagues[league] or {
		Division = "Bronze",
		LP = 0,
		Wins = 0,
		Losses = 0,
		LastUpdated = os.time(),
	}

	local prof = root.Leagues[league]

	prof.LP = math.max(0, (prof.LP or 0) + delta)
	prof.LastUpdated = os.time()

	pcall(function()
		self.LeagueStore:SetAsync(userId, root)
	end)
	
	task.defer(function()
		Tournament_Leaderboard:RecordFromLeagueProfile(self.LeagueStore, userId, root, league)

	end)

	local plr = Players:GetPlayerByUserId(userId)
	if plr then
		pushLeagueUI(plr, prof)
	end

	return true
end

function League_Manager:AddWin(player)
	local root = self:LoadPlayerData(player)
	local prof = root.Leagues[root.ActiveLeague]

	prof.Wins += 1
	prof.LastUpdated = os.time()

	self:AddLPByUserId(player.UserId, League_Mod.Config.Global.LP_Win)
end

function League_Manager:AddLoss(player)
	local root = self:LoadPlayerData(player)
	local prof = root.Leagues[root.ActiveLeague]

	prof.Losses += 1
	prof.LastUpdated = os.time()

	self:AddLPByUserId(player.UserId, League_Mod.Config.Global.LP_Loss)
end

-- =========================
-- Promotion / demotion (end of tournament)
-- =========================
function League_Manager:PromoteByUserId(userId)
	local root = self.PlayerCache[userId]
	if not root then
		local plr = Players:GetPlayerByUserId(userId)
		if plr then
			root = self:LoadPlayerData(plr)
		else
			-- offline: load from datastore
			local ok, data = pcall(function()
				return self.LeagueStore:GetAsync(userId)
			end)
			if not ok or not data then return false end
			root = data
			self.PlayerCache[userId] = root
		end
	end

	local league = root.ActiveLeague or DEFAULT_LEAGUE
	root.Leagues = root.Leagues or {}
	root.Leagues[league] = root.Leagues[league] or { Division="Bronze", LP=0, Wins=0, Losses=0, LastUpdated=os.time() }
	local prof = root.Leagues[league]

	local nextDiv = self:GetNextDivision(prof.Division)
	if not nextDiv then return false end

	prof.Division = nextDiv
	prof.LP = 0
	prof.LastUpdated = os.time()

	pcall(function()
		self.LeagueStore:SetAsync(userId, root)
	end)
	task.defer(function()
		Tournament_Leaderboard:RecordFromLeagueProfile(self.LeagueStore, userId, root, league)


	end)

	local plr = Players:GetPlayerByUserId(userId)
	if plr then
		pushLeagueUI(plr, prof)
	end

	return true
end

function League_Manager:DemoteByUserId(userId)
	local root = self.PlayerCache[userId]
	if not root then
		local plr = Players:GetPlayerByUserId(userId)
		if plr then
			root = self:LoadPlayerData(plr)
		else
			local ok, data = pcall(function()
				return self.LeagueStore:GetAsync(userId)
			end)
			if not ok or not data then return false end
			root = data
			self.PlayerCache[userId] = root
		end
	end

	local league = root.ActiveLeague or DEFAULT_LEAGUE
	root.Leagues = root.Leagues or {}
	root.Leagues[league] = root.Leagues[league] or { Division="Bronze", LP=0, Wins=0, Losses=0, LastUpdated=os.time() }
	local prof = root.Leagues[league]

	local prevDiv = self:GetPreviousDivision(prof.Division)
	if not prevDiv then return false end

	prof.Division = prevDiv
	prof.LP = 0
	prof.LastUpdated = os.time()

	pcall(function()
		self.LeagueStore:SetAsync(userId, root)
	end)
	task.defer(function()
		Tournament_Leaderboard:RecordFromLeagueProfile(self.LeagueStore, userId, root, league)

	end)

	local plr = Players:GetPlayerByUserId(userId)
	if plr then
		pushLeagueUI(plr, prof)
	end

	return true
end

-- =========================
-- Join/leave
-- =========================
Players.PlayerAdded:Connect(function(player)
	task.defer(function()
		local root = League_Manager:LoadPlayerData(player)
		if root then
			local prof = root.Leagues[root.ActiveLeague]
			pushLeagueUI(player, prof)
		end
	end)
end)

Players.PlayerRemoving:Connect(function(player)
	task.defer(function()
		League_Manager:SavePlayerData(player)
	end)
end)

return League_Manager]]></ProtectedString>
						<string name="ScriptGuid">{A0947BEB-68AA-4E88-A343-28CC31713313}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">League_Manager.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX229461A9B33A40DE8EDCD550DFBDC980">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ServerScriptService/League_Service/Tournament_Portal_Handle.lua
-- ==========================================================
-- Tournament_Portal_Handle
--
-- Central router for players switching between STANDARD and TOURNAMENT
-- contexts from the League portal. This script is authoritative for:
--
--   • Interpreting client intent (STANDARD vs TOURNAMENT)
--   • Requesting shard allocation from Tournament_Orchestrator
--   • Teleporting players with the correct server access code
--   • Injecting deterministic TeleportData { mode, division, serverId }
--   • Initializing workspace.Server_Context on join
--   • Notifying clients of their effective runtime context
--
-- Architecture:
--   - Single PlaceId for all modes (no dedicated places)
--   - STANDARD: same place, no reservation
--   - TOURNAMENT: reserved shards per division
--   - Context is reconstructed on PlayerAdded via TeleportData
--   - Server identity is tracked through Server_Context
--
-- Flow:
--   1. Client fires League_Portal_Teleport { mode, division }
--   2. If STANDARD:
--        - TeleportAsync to same place with { mode = STANDARD }
--   3. If TOURNAMENT:
--        - Orchestrator:AllocatePlayer(userId, division)
--        - Receive { serverId, accessCode }
--        - TeleportAsync using ReservedServerAccessCode
--        - Inject { mode, division, serverId } as TeleportData
--   4. On PlayerAdded:
--        - Read TeleportData
--        - Initialize Server_Context (Mode / Division / ServerId)
--        - Fire League_Portal_Init to the client
--
-- Guarantees:
--   - Deterministic server role on join
--   - Server-agnostic routing
--   - No cross-mode contamination
--   - Single lobby, multi-mode topology
--
-- Used by:
--   - League UI
--   - Tournament_Orchestrator
--   - Tournament_Server_Heartbeat (via Server_Context)
--
-- Author(s): Darkzeb
-- Last Modified: 2026-01
-- ==========================================================

local RS 						= game:GetService("ReplicatedStorage")
local TeleportService 			= game:GetService("TeleportService")
local ServerScriptService 		= game:GetService("ServerScriptService")
local Players 					= game:GetService("Players")

-- Modules
local Data_Mods_F      			= RS:WaitForChild("Data_Mods_F")
local Global_Params_Mod			= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local League_Portal_Teleport 	= Channels.CS_Remote_Events.League_Portal_Teleport
local League_Portal_Init 		= Channels.SC_Remote_Events.League_Portal_Init

local Orchestrator 				= require(ServerScriptService.League_Service:WaitForChild("Tournament_Orchestrator"))
local Context 					= workspace:WaitForChild("Server_Context")

local function logKV(tag, kv)
	local parts = {}
	for k, v in pairs(kv) do
		table.insert(parts, tostring(k) .. "=" .. tostring(v))
	end
	table.sort(parts)
	print(("[TOURNAMENT_PORTAL][%s] %s"):format(tag, table.concat(parts, " ")))
end

local function ensureStandard()
	if Context.Mode.Value == "" then
		Context.Mode.Value = Global_Params_Mod.Server_Mode.STANDARD
		Context.Division.Value = ""
	end
end

TeleportService.TeleportInitFailed:Connect(function(player, result, err, placeId)
	logKV("TELEPORT_FAIL", {
		player = player and player.Name,
		userId = player and player.UserId,
		result = result,
		err = err,
		placeId = placeId,
	})
end)

League_Portal_Teleport.OnServerEvent:Connect(function(player, data)
	logKV("REQUEST", {
		player = player.Name,
		userId = player.UserId,
		mode = data and data.mode,
		division = data and data.division,
		ctxMode = Context.Mode.Value,
		ctxDivision = Context.Division.Value,
		lobbyJobId = game.JobId,
	})
	
	if data.mode ~= Global_Params_Mod.Server_Mode.TOURNAMENT then
		local options = Instance.new("TeleportOptions")
		options:SetTeleportData({ mode = Global_Params_Mod.Server_Mode.STANDARD })
		logKV("TP_STANDARD", { player = player.Name })
		TeleportService:TeleportAsync(game.PlaceId, { player }, options)
		return
	end

	local division = data.division or "Bronze"
	local server = Orchestrator:AllocatePlayer(player.UserId, division)

	logKV("ALLOC_RESULT", {
		player = player.Name,
		userId = player.UserId,
		serverId = server and server.serverId,
		hasAccessCode = server and server.accessCode and server.accessCode ~= "" or false,
	})
	
	local options = Instance.new("TeleportOptions")
	options.ReservedServerAccessCode = server.accessCode
	options:SetTeleportData({
		mode = Global_Params_Mod.Server_Mode.TOURNAMENT ,
		division = division,
		serverId = server.serverId
	})

	logKV("TP_TOURNAMENT", {
		player = player.Name,
		userId = player.UserId,
		serverId = server.serverId,
		division = division,
	})
	
	TeleportService:TeleportAsync(game.PlaceId, { player }, options)
end)

Players.PlayerAdded:Connect(function(player)
	local joinData = player:GetJoinData()
	local payload = joinData and joinData.TeleportData
	
	logKV("JOIN", {
		player = player.Name,
		userId = player.UserId,
		mode = payload and payload.mode,
		division = payload and payload.division,
		serverId = payload and payload.serverId,
	})

	if payload and payload.mode == Global_Params_Mod.Server_Mode.TOURNAMENT  then
		if Context.Mode.Value ~= Global_Params_Mod.Server_Mode.TOURNAMENT  then
			Context.Mode.Value = Global_Params_Mod.Server_Mode.TOURNAMENT 
			Context.Division.Value = payload.division or "Bronze"
			Context.ServerId.Value = payload.serverId or ""
			
			logKV("CTX_INIT", {
				mode = Context.Mode.Value,
				division = Context.Division.Value,
				serverId = Context.ServerId.Value,
			})

		end
	else
		ensureStandard()
	end

	if payload then
		League_Portal_Init:FireClient(player, payload)
	end
end)]]></ProtectedString>
						<string name="ScriptGuid">{4C683596-D799-441C-B398-B3EBB5728D87}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tournament_Portal_Handle.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7D0BADE88D234AA980075146F23F75B4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ServerScriptService/League_Service/Tournament_Server_Heartbeat.lua
-- ==========================================================
-- Tournament_Server_Heartbeat
--
-- This daemon runs inside every Tournament server instance.
-- Its responsibility is to keep the server state alive in MemoryStore
-- so that the Tournament_Orchestrator can make correct routing decisions.
--
-- High-level flow:
--   1. Wait for Server_Context to be initialized (Mode / Division / ServerId)
--   2. Exit if this server is not in TOURNAMENT mode
--   3. Periodically publish this server state to MemoryStore
--   4. Update:
--        - current player count
--        - last heartbeat timestamp
--        - booted = true (server is now physically alive)
--   5. Keep the entry alive via TTL refresh
--
-- This makes MemoryStore the single source of truth for:
--   - Which Tournament servers are alive
--   - Which ones are fully booted
--   - How many players are inside each one
--
-- Author(s): Darkzeb
-- Last Modified: 2026-01
-- ==========================================================

local RS 						= game:GetService("ReplicatedStorage")
local Players 					= game:GetService("Players")
local MemoryStoreService 		= game:GetService("MemoryStoreService")
local RunService 				= game:GetService("RunService")

-- Modules
local Data_Mods_F      			= RS:WaitForChild("Data_Mods_F")
local Global_Params_Mod			= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))

-- Server-side context (mode, division, etc.)
local Context 					= workspace:WaitForChild("Server_Context")

local function logKV(tag, kv)
	local parts = {}
	for k, v in pairs(kv) do
		table.insert(parts, tostring(k) .. "=" .. tostring(v))
	end
	table.sort(parts)
	warn(("[HEARTBEAT][%s] %s"):format(tag, table.concat(parts, " ")))
end

task.spawn(function()
	logKV("BOOT", { placeId = game.PlaceId, jobId = game.JobId, mode = Context.Mode.Value, division = Context.Division.Value })
	
	-- Wait until mode, division and serverId are known
	while Context.Mode.Value == "" or Context.Division.Value == "" or Context:FindFirstChild("ServerId") == nil or Context.ServerId.Value == "" do
		task.wait(0.5)
	end

	-- Exit if this is not a Tournament server
	if Context.Mode.Value ~= Global_Params_Mod.Server_Mode.TOURNAMENT then
		logKV("Not a tournament server, exiting", { mode = Context.Mode.Value })
		return
	end

	logKV("starting heartbeat", {
		placeId = game.PlaceId,
		jobId = game.JobId,
		mode = Context.Mode.Value,
		division = Context.Division.Value,
		serverId = Context.ServerId.Value,
	})
	
	local division = Context.Division.Value
	local serverId = Context.ServerId.Value
	
	-- Each division has its own SortedMap
	local map = MemoryStoreService:GetSortedMap("TournamentServers:" .. division)

	-- Publishes the current server state into MemoryStore
	local function heartbeat()
		if RunService:IsStudio() then
			return
		end

		local playersCount = #Players:GetPlayers()
		local now = os.time()

		local ok, res = pcall(function()
			return map:UpdateAsync(serverId, function(current)
				if not current then
				-- Do not recreate records here; orchestrator is the authority for accessCode.
				return nil
			end

			current.players = playersCount
			current.lastHeartbeat = now
			current.booted = true -- server is now physically alive
			return current, playersCount
			end, Global_Params_Mod.Tournament_Server_TTL)
		end)

		if not ok then
			logKV("UPDATE_FAIL", { serverId = serverId, division = division, err = res })
			return
		end

		-- Optional readback to confirm what is stored (super helpful while debugging)
		local rbOk, rb = pcall(function()
			return map:GetAsync(serverId)
		end)

		logKV("TICK", {
			serverId = serverId,
			jobId = game.JobId,
			division = division,
			playersCount = playersCount,
			rbOk = rbOk,
			rbPlayers = rb and rb.players,
			rbCapacity = rb and rb.capacity,
			rbLastHb = rb and rb.lastHeartbeat,
			rbHasAccessCode = (rb and rb.accessCode and rb.accessCode ~= "") and true or false,
			rbBooted = rb and rb.booted,
		})

	end

	-- Keep the entry alive and fresh
	while true do
		heartbeat()
		task.wait(Global_Params_Mod.Tournament_Server_Heartbeat_Interval)
	end
end)]]></ProtectedString>
						<string name="ScriptGuid">{45932EF3-D3B4-4C98-9573-1E68C2E23F3B}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tournament_Server_Heartbeat.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX89CF7899EAE24436940772422F48CED7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ServerScriptService/League_Service/WaitingZone.lua
-- ==========================================================
-- WaitingZone
--
-- Lightweight server-side utility to track players entering
-- and leaving a physical “waiting” area in the world.
--
-- The module:
--   - Registers a BasePart as a touch zone
--   - Detects players via HumanoidRootPart collisions
--   - Maintains an in-memory set of players currently inside
--   - Exposes helpers to query zone state
--   - Mirrors state on players via the `T_Waiting_Active` attribute
--
-- Behavior:
--   - On Touched:
--       * Resolve Player from HumanoidRootPart
--       * Mark player as inside
--       * Set Player:SetAttribute("T_Waiting_Active", true)
--   - On TouchEnded:
--       * Unmark player
--       * Clear attribute
--   - On PlayerRemoving:
--       * Cleanup internal state
--
-- API:
--   - RegisterTouchZone(zonePart)
--   - GetCount() -> number
--   - GetPlayersInside() -> { Player }
--   - IsInside(player) -> boolean
--
-- Purpose:
--   - Provide a deterministic, server-authoritative waiting area
--   - Enable orchestration logic (queues, matchmaking, tournaments)
--   - Avoid reliance on client-side proximity checks
--
-- Guarantees:
--   - Only real players are tracked (HRP validation)
--   - No memory leaks on player leave
--   - O(1) membership checks by UserId
--
-- Author(s): Darkzeb
-- Last Modified: 2026-01
-- ==========================================================

local Players = game:GetService("Players")

local MatchMakingTouchZone = {}

local inside = {}

-- Resolve a Player instance from a touched HumanoidRootPart.
-- Ensures the hit part truly belongs to a character root and
-- prevents false positives from accessories or physics debris.
local function getPlayerFromHRP(hit: BasePart): Player?
	if not hit or hit.Name ~= "HumanoidRootPart" then return nil end

	local character = hit:FindFirstAncestorOfClass("Model")
	if not character then return nil end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if hrp ~= hit then return nil end

	return Players:GetPlayerFromCharacter(character)
end

-- Register a BasePart as a matchmaking waiting zone.
-- Hooks Touched / TouchEnded to track players entering or leaving.
-- Updates both the internal state and the player attribute
-- `T_Waiting_Active` for external systems (UI, orchestration, etc.).
function MatchMakingTouchZone.RegisterTouchZone(zonePart: BasePart)
	zonePart.Touched:Connect(function(hit)
		local plr = getPlayerFromHRP(hit)
		if not plr then return end

		inside[plr.UserId] = plr
		plr:SetAttribute("T_Waiting_Active", true)
	end)

	zonePart.TouchEnded:Connect(function(hit)
		local plr = getPlayerFromHRP(hit)
		if not plr then return end

		inside[plr.UserId] = nil
		plr:SetAttribute("T_Waiting_Active", false)
	end)

	Players.PlayerRemoving:Connect(function(plr)
		inside[plr.UserId] = nil
	end)
end

-- Return the current number of players inside the waiting zone.
function MatchMakingTouchZone.GetCount(): number
	local n = 0
	for _ in pairs(inside) do n += 1 end
	return n
end

-- Return a clean list of Players currently inside the zone.
-- Filters out stale references and guarantees live Player instances.
function MatchMakingTouchZone.GetPlayersInside(): {Player}
	local list = {}
	for _, plr in pairs(inside) do
		if plr and plr.Parent == Players then
			table.insert(list, plr)
		end
	end
	return list
end

-- Check whether a given player is currently inside the zone.
function MatchMakingTouchZone.IsInside(plr: Player): boolean
	return plr and inside[plr.UserId] ~= nil
end

return MatchMakingTouchZone
]]></ProtectedString>
						<string name="ScriptGuid">{C6E78B75-2395-4983-BD75-A82505FDA12A}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">MatchMakingTouchZone.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3BB15AED76EB43A98A7E81BD5CF40507">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ServerScriptService/League_Service/Tournament_Leaderboard.lua
-- ==========================================================
-- Tournament_Leaderboard
--
-- Server-side leaderboard engine for Tournament mode.
-- Maintains a Top-N (default: 100) ranking per active league
-- using a single DataStore key per league.
--
-- Features:
--   - Deterministic Top-N list stored as an ordered table
--   - Per-league isolation via namespaced keys
--   - Idempotent upsert (one entry per UserId)
--   - Automatic trimming to MAX entries
--   - Normalization of incoming data (types, bounds, defaults)
--
-- Storage Model:
--   - One key per league:
--       "__TL_TOP100__:<LeagueName>"
--   - Value = array of entries sorted by LP desc
--
-- Entry Schema:
--   {
--     UserId    : number,
--     Name      : string,
--     Division  : string,
--     LP        : number,
--     Country   : string,
--     UpdatedAt : unix timestamp
--   }
--
-- Public API:
--   - RecordFromLeagueProfile(store, userId, rootProfile, activeLeague)
--       * Extracts league data from a profile and upserts into Top-N
--   - GetTop100(store, activeLeague?) -> { entries }
--       * Loads and returns the persisted leaderboard
--   - GetCurrentServerTop(League_Manager, activeLeague?) -> { entries }
--       * Builds a live snapshot from players currently in-server
--   - SeedMockTop100(store, activeLeague?, count?)
--       * Dev-only helper to populate mock data
--
-- Guarantees:
--   - Stable ordering by LP (descending)
--   - One row per player
--   - Bounded memory and storage size
--   - Safe under concurrent updates (UpdateAsync)
--
-- Author(s): Darkzeb
-- Last Modified: 2026-01
-- ==========================================================

local Players = game:GetService("Players")

local Tournament_Leaderboard = {}

Tournament_Leaderboard.MAX = 100
Tournament_Leaderboard.KEY_PREFIX = "__TL_TOP100__"

local function getKey(activeLeague: string?)
	activeLeague = activeLeague or "DEFAULT"
	return Tournament_Leaderboard.KEY_PREFIX .. ":" .. tostring(activeLeague)
end

local function normalizeEntry(entry)
	entry.UserId = tonumber(entry.UserId) or 0
	entry.Name = tostring(entry.Name or ("User_" .. tostring(entry.UserId)))
	entry.Division = entry.Division or "Bronze"
	entry.LP = math.max(0, math.floor(tonumber(entry.LP) or 0))
	entry.Country = entry.Country or "United States"
	entry.UpdatedAt = tonumber(entry.UpdatedAt) or os.time()
	return entry
end

local function upsertTopList(list, entry)
	list = list or {}
	entry = normalizeEntry(entry)

	-- remove old entry if exists
	for i = #list, 1, -1 do
		if tonumber(list[i].UserId) == entry.UserId then
			table.remove(list, i)
			break
		end
	end

	table.insert(list, entry)

	table.sort(list, function(a, b)
		return (tonumber(a.LP) or 0) > (tonumber(b.LP) or 0)
	end)

	while #list > Tournament_Leaderboard.MAX do
		table.remove(list)
	end

	return list
end

-- ==========================================================
-- Public API
-- ==========================================================

-- store = League_Manager.LeagueStore (passed in)
function Tournament_Leaderboard:RecordFromLeagueProfile(store, userId, rootProfile, activeLeague)
	if not store then return false end
	if not userId or userId <= 0 then return false end
	if not rootProfile then return false end

	local leagues = rootProfile.Leagues or {}
	activeLeague = activeLeague or rootProfile.ActiveLeague
	local prof = activeLeague and leagues[activeLeague]
	if not prof then return false end

	local plr = Players:GetPlayerByUserId(userId)
	local country = rootProfile.Country or "United States"

	if plr then
		local pd = plr:FindFirstChild("Player_Data")
		local c = pd and pd:FindFirstChild("Country")
		if c and typeof(c.Value) == "string" and c.Value ~= "" then
			country = c.Value
		end
	end

	local entry = {
		UserId = userId,
		Name = rootProfile.Name,
		Division = prof.Division,
		LP = prof.LP,
		Country = country,
		UpdatedAt = os.time(),
	}

	local key = getKey(activeLeague)

	local ok, err = pcall(function()
		store:UpdateAsync(key, function(old)
			return upsertTopList(old, entry)
		end)
	end)

	if not ok then
		warn("[TL] RecordFromLeagueProfile failed:", err)
		return false
	end

	return true
end

--local top100 = TL:GetTop100(League_Manager.LeagueStore, "MMA_FIGHTERS")
function Tournament_Leaderboard:GetTop100(store, activeLeague: string?)
	if not store then return {} end
	local key = getKey(activeLeague)

	local ok, data = pcall(function()
		return store:GetAsync(key)
	end)

	if not ok or type(data) ~= "table" then
		return {}
	end

	table.sort(data, function(a, b)
		return (tonumber(a.LP) or 0) > (tonumber(b.LP) or 0)
	end)

	return data
end

--local serverTop = TL:GetCurrentServerTop(League_Manager, "MMA_FIGHTERS")
function Tournament_Leaderboard:GetCurrentServerTop(League_Manager, activeLeague: string?)
	local list = {}

	for _, plr in ipairs(Players:GetPlayers()) do
		local ok, root = pcall(function()
			
			return League_Manager:LoadPlayerData(plr)
			
		end)

		if ok and root then
			local league = activeLeague or root.ActiveLeague
			local prof = root.Leagues and root.Leagues[league]

			if prof then
				table.insert(list, {
					UserId = plr.UserId,
					Name = plr.Name,
					Division = prof.Division or "Bronze",
					LP = tonumber(prof.LP) or 0,
					Wins = tonumber(prof.Wins) or 0,
					Losses = tonumber(prof.Losses) or 0,
					
				})
			end
		end
	end

	table.sort(list, function(a, b)
		return (a.LP or 0) > (b.LP or 0)
	end)

	while #list > self.MAX do
		table.remove(list)
	end

	return list
end

-- ==========================================================
-- DEV / TESTING
-- ==========================================================
function Tournament_Leaderboard:SeedMockTop100(store, activeLeague: string?, count: number?)
	if not store then return false end

	count = math.clamp(tonumber(count) or 25, 1, self.MAX)
	activeLeague = activeLeague or "DEFAULT"

	local key = getKey(activeLeague)

	local mock = {}
	local Players = game:GetService("Players")
	for i, plr in ipairs(Players:GetPlayers()) do
		table.insert(mock, {
			UserId = plr.UserId,
			Name = plr.Name,
			Division = "Bronze",
			LP =200+i,
			UpdatedAt = os.time(),
		})
	end
	for i = 1, count do
		table.insert(mock, {
			UserId = i, -- 1..count (works fine, even if no real players)
			Name = "MockPlayer_" .. tostring(i),
			Division = "Bronze",
			LP = math.random(0, 200),
			UpdatedAt = os.time(),
		})
	end

	table.sort(mock, function(a, b) return (a.LP or 0) > (b.LP or 0) end)

	local ok, err = pcall(function()
		store:SetAsync(key, mock)
	end)

	if not ok then
		warn("[TL] SeedMockTop100 failed:", err)
		return false
	end

	warn("[TL] Seeded mock leaderboard:", activeLeague, "Count:", count)
	return true
end

return Tournament_Leaderboard]]></ProtectedString>
						<string name="ScriptGuid">{FE472889-CCAB-44C7-A7E7-2AAE480A89C0}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tournament_Leaderboard.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA1702E0B844E44E2AEEFC6AE8281FC20">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ServerScriptService/League_Service/Tournament_Leaderboard_Handle.server.lua
local Players 				= game:GetService("Players")
local RS 					= game:GetService("ReplicatedStorage")
local Data_Mods_F 			= RS:WaitForChild("Data_Mods_F")

local League_Manager 		= require(script.Parent:WaitForChild("League_Manager"))
local TL 					= require(script.Parent:WaitForChild("Tournament_Leaderboard"))
local Utils 				= require(RS:WaitForChild("Modules"):WaitForChild("Utils"))
local Country_Mod 			= require(Data_Mods_F:WaitForChild("Country_Mod"))

local Global_Params_Mod		= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))
local ACTIVE_LEAGUE 		= Global_Params_Mod.League.MMA_FIGHTERS

--fake 
--TL:SeedMockTop100(League_Manager.LeagueStore, "MMA_FIGHTERS", 50)

local Themes = game.Workspace:WaitForChild("Main_World_F"):WaitForChild("Themes")

local Tournament1 = Themes:WaitForChild("Tournament", 10)

if not Tournament1 then
	return
end

local T_Leaderboards = Utils.SafePath(Tournament1, {
	"Tournament_Info",
	"T_Leaderboards"
})
local RunUILoop =nil

local THUMBNAIL_TYPE = Enum.ThumbnailType.HeadShot
local THUMBNAIL_SIZE = Enum.ThumbnailSize.Size180x180

local Player_Thumbnail_Data = {}

-- ==========================================================
-- Thumbnail
-- ==========================================================
local function Get_Player_Thumbnail(userId: number)
	if Player_Thumbnail_Data[userId] then
		return Player_Thumbnail_Data[userId]
	end

	for _ = 1, 3 do
		local success, data = pcall(function()
			return Players:GetUserThumbnailAsync(userId, THUMBNAIL_TYPE, THUMBNAIL_SIZE)
		end)

		if success and data then
			Player_Thumbnail_Data[userId] = data
			return data
		end
		task.wait(0.5)
	end

	return "rbxassetid://100127687172105"
end

-- ==========================================================
-- UI Helpers
-- ==========================================================
local function Get_LB_UI_Data(Key)
	local LB_M = T_Leaderboards:FindFirstChild(Key)
	if LB_M and LB_M.PrimaryPart and LB_M.PrimaryPart:FindFirstChildWhichIsA("SurfaceGui") then
		local Main_UI = LB_M.PrimaryPart:FindFirstChildWhichIsA("SurfaceGui")
		local Main_Data_F = Main_UI:FindFirstChild("Main_Data_F")
		if Main_Data_F and Main_Data_F:FindFirstChild("Tabs_F") and Main_Data_F:FindFirstChild("Tab_TMP") then
			Main_Data_F.CanvasPosition = Vector2.new(0, 0)
			return Main_Data_F:FindFirstChild("Tabs_F"), Main_Data_F:FindFirstChild("Tab_TMP")
		end
	end
	return nil, nil
end

local function GetDivisonIMG(Division)
	return "rbxassetid://117296716521959"
end

local function Update_Leaderboard_Display(Key, DataList,IsGlobal)
	local Tabs_F, Tab_TMP = Get_LB_UI_Data(Key)
	if not Tabs_F or not Tab_TMP then return end

	Tabs_F:ClearAllChildren()

	local UIList = Instance.new("UIListLayout")
	UIList.Parent = Tabs_F
	UIList.Padding = UDim.new(0.02, 0)
	UIList.SortOrder = Enum.SortOrder.LayoutOrder

	-- sort by LP high to low
	table.sort(DataList, function(a, b)
		return (tonumber(a.LP) or 0) > (tonumber(b.LP) or 0)
	end)

	for rank, row in ipairs(DataList) do
		local userId = tonumber(row.UserId) or -1
		local lp = tonumber(row.LP) or 0
		local division = tostring(row.Division or "Bronze")
		--local name = tostring(row.Name or ("User_" .. tostring(userId)))

		local Tab = Tab_TMP:Clone()
		Tab.Parent = Tabs_F
		Tab.Name = "Tab_" .. rank
		Tab.LayoutOrder = rank
		Tab.Visible = true

		local Plr_Img = Tab:WaitForChild("Plr_Img")
		local Rank_Txt = Tab:WaitForChild("Rank_Txt")
		local P_Name_Txt = Tab:WaitForChild("P_Name_Txt")
		local P_DisplayName_Txt = Tab:WaitForChild("P_DisplayName_Txt")
		local P_Data_Val = Tab:WaitForChild("P_Data_Val")
		local Country_Img = Tab:FindFirstChild("Country_Img")

		if Country_Img then
			local countryName
			if IsGlobal then
				Country_Img.Image = GetDivisonIMG(division)
			else
				Tabs_F.Parent.Parent.Title_F:WaitForChild("Data_Icon_1").Image = GetDivisonIMG(division)
				Tabs_F.Parent.Parent.Title_F:WaitForChild("Data_Icon_2").Image = GetDivisonIMG(division)

				countryName = row.Country or "United States"
				Country_Img.Image = Country_Mod.Get_Flag_ID(countryName)
			end
		end

		P_Data_Val.Text = tostring(lp)
		P_Data_Val.TextXAlignment = Enum.TextXAlignment.Center
		P_DisplayName_Txt.Text = "🏆 " .. division
		P_Name_Txt.Text = row.Name

		if rank <= 3 then
			Plr_Img.Image = Get_Player_Thumbnail(userId)
			Plr_Img.Visible = true
			Rank_Txt.Visible = false
		else
			Rank_Txt.Text = "#" .. rank
			Rank_Txt.Visible = true
			Plr_Img.Visible = false
		end
	end
end

-- ==========================================================
-- MAIN
-- ==========================================================
local function Update_All_Leaderboard_Displays()
	-- Global Top100 (saved by TL inside LeagueStore key "__TL_TOP100__:MMA_FIGHTERS")
	local top100 = TL:GetTop100(League_Manager.LeagueStore, ACTIVE_LEAGUE)
	local serverTop = TL:GetCurrentServerTop(League_Manager, ACTIVE_LEAGUE)

	Update_Leaderboard_Display("League", top100,true)
	Update_Leaderboard_Display("Division", serverTop)
end

local RunUILoop=function ()
	Update_All_Leaderboard_Displays()
	task.delay(30, RunUILoop)

end

task.defer(RunUILoop)]]></ProtectedString>
						<string name="ScriptGuid">{4135CF02-8F38-4A88-9F7F-A2214F9015D2}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tournament_Leaderboard_Handle.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX196ECE657A974B54924C276E61561F4E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ServerScriptService/League_Service/Tournament_Orchestrator.lua
-- ==========================================================
-- Tournament_Orchestrator
--
-- Central allocator for Tournament servers, backed by MemoryStore.
-- Its role is to decide where a player should be sent when entering
-- Tournament mode for a given division.
--
-- Responsibilities:
--   - Track live Tournament servers per division (Bronze → Legend)
--   - Create new reserved servers when none are suitable
--   - Allocate players to existing servers atomically
--   - Favor even player counts to ease matchmaking
--   - Prevent double-booking via MemoryStore UpdateAsync
--   - Expire dead servers using heartbeat + TTL
--
-- Data model (per division, in MemoryStore SortedMap):
--   Key   : serverId (GUID)
--   Value :
--     {
--       serverId     = string,
--       placeId      = number,
--       accessCode   = string,
--       players      = number,
--       capacity     = number,
--       lastHeartbeat= unix timestamp,
--       booted       = boolean,
--       createdAt    = unix timestamp,
--       createdBy    = userId
--     }
--
-- Design principles:
--   - Stateless per call (all authority in MemoryStore)
--   - Concurrency-safe (atomic slot reservation)
--   - Server-agnostic (works across all shards)
--   - Resilient to crashes (TTL + heartbeat timeout)
--   - Two-phase lifecycle: reserved → booted → active
--   - Defensive against half-born servers (booted=false filtered)
--
-- Used by:
--   - Tournament_Portal_Handle / Tournament_Server_Configurator
--   - Any server needing to allocate a player into a Tournament shard
--
-- Author(s): Darkzeb
-- Last Modified: 2026-01
-- ==========================================================

local RS 						= game:GetService("ReplicatedStorage")
local MemoryStoreService 		= game:GetService("MemoryStoreService")
local TeleportService 			= game:GetService("TeleportService")
local HttpService               = game:GetService("HttpService")

local Tournament_Orchestrator 	= {}

-- Modules
local Data_Mods_F      			= RS:WaitForChild("Data_Mods_F")
local Global_Params_Mod			= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))

local STALE_AFTER =
	Global_Params_Mod.Tournament_Server_Heartbeat_Interval * 3

-- Number of servers to fetch when looking for an existing one
Tournament_Orchestrator.NB_SERVER_TO_FETCH = 50

local function logKV(tag, kv)
	-- Structured-ish logs for easy grep
	local parts = {}
	for k, v in pairs(kv) do
		table.insert(parts, tostring(k) .. "=" .. tostring(v))
	end
	table.sort(parts)
	print(("[ORCHESTRATOR][%s] %s"):format(tag, table.concat(parts, " ")))
end

-- Returns the SortedMap for a given division
local function getMap(division)
	return MemoryStoreService:GetSortedMap("TournamentServers:" .. division)
end

-- Creates a brand new reserved server for a division
function Tournament_Orchestrator:CreateServer(division)
	local accessCode = TeleportService:ReserveServer(game.PlaceId)
	local jobId = game.JobId

	return {
		jobId = jobId,
		placeId = game.PlaceId,
		accessCode = accessCode,
	}
end

-- Allocates a player to an existing server, or creates one if needed
function Tournament_Orchestrator:AllocatePlayer(userId, division)
	local map = getMap(division)
	local now = os.time()

	local requestId = HttpService:GenerateGUID(false)

	logKV("ALLOC_BEGIN", {
		requestId = requestId,
		userId = userId,
		division = division,
		placeId = game.PlaceId,
		lobbyJobId = game.JobId,
		now = now,
	})
	
	-- 1) Fetch candidate servers (sorted by score ascending = least players first)
	local ok, entries = pcall(function()
		return map:GetRangeAsync(Enum.SortDirection.Ascending, self.NB_SERVER_TO_FETCH)
	end)
	
	if not ok then
		logKV("GET_RANGE_FAIL", { requestId = requestId, division = division })
	end

	if ok and entries then
		logKV("CANDIDATES", { requestId = requestId, division = division, count = #entries })
		for _, e in ipairs(entries) do
			local key = e.key

			local val = e.value
			logKV("CANDIDATE", {
				requestId = requestId,
				key = key,
				players = val and val.players,
				capacity = val and val.capacity,
				lastHeartbeat = val and val.lastHeartbeat,
				hasAccessCode = (val and val.accessCode and val.accessCode ~= "") and true or false,
			})
			
			local success, updated = pcall(function()
				return map:UpdateAsync(key, function(current)
					if not current then
						return nil
					end

					-- Server exists but is not yet physically alive
					if not current.booted then
						return nil
					end
					
					-- Dead / stale server
					if (now - (current.lastHeartbeat or 0)) >= STALE_AFTER then
						return nil
					end

					local cap = current.capacity or Global_Params_Mod.Tournament_Server_Capacity
					local players = current.players or 0

					-- Full server
					if players >= cap then
						return nil
					end

					-- Reserve one slot
					players += 1
					current.players = players
					current.lastHeartbeat = now

					-- IMPORTANT: return value + new score (players)
					return current, players
				end, Global_Params_Mod.Tournament_Server_TTL)
			end)

			if not success then
				logKV("UPDATE_FAIL", { requestId = requestId, key = key })
			end
			
			if success and updated then
				logKV("ALLOC_MATCH", {
					requestId = requestId,
					serverId = updated.serverId,
					key = key,
					players = updated.players,
					capacity = updated.capacity,
					hasAccessCode = (updated.accessCode and updated.accessCode ~= "") and true or false,
				})
				return updated
			end
		end
	end

	-- 2) No usable server -> create one and reserve first slot
	local accessCode = TeleportService:ReserveServer(game.PlaceId)
	local serverId = HttpService:GenerateGUID(false)

	local record = {
		serverId = serverId,
		placeId = game.PlaceId,
		accessCode = accessCode,
		players = 1,
		capacity = Global_Params_Mod.Tournament_Server_Capacity,
		lastHeartbeat = now,
		booted = false,
		createdAt = now,
		createdBy = userId
	}

	local setOk, setErr = pcall(function()
		map:SetAsync(serverId, record, Global_Params_Mod.Tournament_Server_TTL, 1)
	end)

	logKV("ALLOC_CREATE", {
		requestId = requestId,
		serverId = serverId,
		players = 1,
		capacity = record.capacity,
		ttl = Global_Params_Mod.Tournament_Server_TTL,
		accessCodeLen = accessCode and #accessCode or 0,
		setOk = setOk,
		setErr = setErr,
	})

	return record
end

return Tournament_Orchestrator]]></ProtectedString>
						<string name="ScriptGuid">{C3C9399C-C085-4E96-8F02-2F43929969A9}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tournament_Orchestrator.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7419C51AEE874A76B5135DB892CAD41C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ServerScriptService/League_Service/Tournament_Server_Heartbeat.lua
-- ==========================================================
-- Tournament_Server_Heartbeat
--
-- This daemon runs inside every Tournament server instance.
-- Its responsibility is to keep the server state alive in MemoryStore
-- so that the Tournament_Orchestrator can make correct routing decisions.
--
-- High-level flow:
--   1. Wait for Server_Context to be initialized
--   2. Exit if this server is not in TOURNAMENT mode
--   3. Periodically publish this server state to MemoryStore
--   4. Update:
--        - current player count
--        - last heartbeat timestamp
--   5. Remove the entry when the server becomes empty
--   6. Locates the Rankings object tree safely and moves Ranking_Items to the predefined Stand_Pos anchor
--
-- Author(s): Darkzeb
-- Last Modified: 2026-01
-- ==========================================================

local RS 						= game:GetService("ReplicatedStorage")

-- Modules
local Data_Mods_F      			= RS:WaitForChild("Data_Mods_F")
local Global_Params_Mod			= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))
local ThemeManager 				= require(RS:WaitForChild("Design"):WaitForChild("ThemeManager"))
local Utils 					= require(RS:WaitForChild("Modules"):WaitForChild("Utils"))
local Server_Context 			= workspace:WaitForChild("Server_Context")

local configured 				= false

local function applyTournamentTheme()
	print("[SERVER] Applying tournament theme")
	if Server_Context.Mode.Value == Global_Params_Mod.Server_Mode.TOURNAMENT then
		ThemeManager.applyTheme("Tournament", { division = Server_Context.Division.Value })
	else
		ThemeManager.applyTheme("Standard")
	end
end

local function RelocateRanking()
	local RankingsFolder = Utils.SafePath(workspace, {
		"Main_World_F",
		"Gameplay",
		"Objects",
		"Rankings",
	})
	RankingsFolder:WaitForChild("Ranking_Items"):PivotTo(RankingsFolder:WaitForChild("Stand_Pos").CFrame)
end

task.spawn(function()
	-- Wait until context is known
	while Server_Context.Mode.Value == "" or Server_Context.Division.Value == "" do
		task.wait(0.1)
	end

	if Server_Context.Mode.Value ~= Global_Params_Mod.Server_Mode.TOURNAMENT then
		return
	end

	if not configured then
		configured = true
		applyTournamentTheme()		
		RelocateRanking()
	end
end)
]]></ProtectedString>
						<string name="ScriptGuid">{46C9C442-D926-46DA-AE1D-895304B208D8}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tournament_Server_Configurator.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX99B2401ABE494282B9E409628BA9DBA9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Fight_Service</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX9786D8236C824649B1DC15E4CD90A7CF">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Fight_Service/Core_Fight_Handler.server.lua
--
--  Description:
--      Central server-side orchestrator for the entire fight flow.
--      Handles fight initialisation, player teleporting, logic loop
--      management, victory conditions, takedowns, submissions, clinch
--      sequences, and fight termination.
--
--      Features:
--          • Validates cage availability & character readiness
--          • Builds a shared context for all refactored fight modules
--          • Runs initialisation, main loop, and end-of-fight modules
--          • Cleans UI queue elements & resets fight model visuals
--          • Supports bot fighters with modular AI behaviour loading
--          • Handles Ready-To-Fight events & automatically boots bots
--
--  Last Modified: 2025-11-29 
--  Version: V2025-11
--
--  Dependencies:
--      ReplicatedStorage:
--          - Data_Mods_F:
--              Stats_Manager_Mod, Sound_Mod, Animation_Mod,
--              Elo_Mod, Monetization_Mod, Fight_Params_Mod
--          - Modules/Channels
--
--      ServerStorage:
--          - TemplateUIs/Player_Display_UI
--
--      Workspace:
--          - Main_World_F.Gameplay.Objects.Fight_Cages_F
--
--      Internal Modules (children of this script):
--          - Fight_Initialization
--          - Fight_Loop
--          - Fight_End
--          - Server_Submission_Minigame
--          - Server_Clinch_Sequence
--
--  Notes:
--      • Core orchestrator only — all gameplay logic lives in the
--        refactored modules.
--      • Bot behaviours are dynamically resolved using _registry
--        stored inside behaviour modules.
--======================================================================

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local Sound_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Monetization_Mod = require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local Cage_Factory = require(Data_Mods_F:WaitForChild("Cage_Factory"))
local Utils	= require(game.ReplicatedStorage.Modules.Utils)
local Global_Params_Mod	= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))

-- Events
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Start_Core_Fight = Channels.Bindable_Events.Start_Core_Fight
local Ready_To_Fight	=  Channels.CS_Remote_Events.Ready_To_Fight
local Fight_Intro_Finished	=  Channels.CS_Remote_Events.Fight_Intro_Finished


-- require our refactored modules; they must be children of this script
local Fight_Initialization = require(script:WaitForChild("Fight_Initialization"))
local Fight_Loop = require(script:WaitForChild("Fight_Loop"))
local Fight_End = require(script:WaitForChild("Fight_End"))
local Server_Submission_Minigame = require(script:WaitForChild("Server_Submission_Minigame"))
local Server_Clinch_Sequence = require(script:WaitForChild("Server_Clinch_Sequence"))

----- ASSETS -----
local Player_Display_UI = game.ServerStorage:WaitForChild("TemplateUIs"):WaitForChild("Player_Display_UI")
local Scoreboard_UI = game.ServerStorage:WaitForChild("TemplateUIs"):WaitForChild("Scoreboard_UI")

-- disconnects all connections stored in the given array
local function Disconnect_Cons(Cons)
	for i = 1, #Cons do
		if Cons[i] ~= nil then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

-- determine whether a fight can start: the round is unused and both
-- characters are valid
local function Verify_Fight_Can_Start(Fight_M, Fight_Char_1, Fight_Char_2)
	local function Is_Fight_Active()
		local Fight_Data_F = Fight_M:FindFirstChild("Fight_Data_F")
		
		if Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild("Active_Fight") ~= nil then
			local Active_V = Fight_Data_F:FindFirstChild("Active_Fight")
			return Active_V.Value
		end
		return false
	end
	local function Verify_Character(Char)
		if Char ~= nil and Char:FindFirstChildWhichIsA("Humanoid") ~= nil and Char:FindFirstChild("HumanoidRootPart") ~= nil then
			return true
		end
		return false
	end
	if Is_Fight_Active() == false and Verify_Character(Fight_Char_1) and Verify_Character(Fight_Char_2) then
		return true
	end
	return false
end

-- retrieve a character's fight data values (Health and Staminia)
local function Get_Player_Fight_Data_Vals(Char)
	local Fight_Data_F = Char:FindFirstChild("Fight_Data")
	if Fight_Data_F == nil and game.Players:GetPlayerFromCharacter(Char) ~= nil then
		local Plr = game.Players:GetPlayerFromCharacter(Char)
		Fight_Data_F = Plr:FindFirstChild("Fight_Data")
	end
	return Fight_Data_F:FindFirstChild("Health"), Fight_Data_F:FindFirstChild("Staminia")
end

-- core handler that orchestrates fight initialisation, loop and end logic
local function Core_Fight_Logic_Handle(Fight_M, Fight_Char_1, Fight_Char_2)
	-- build a context table to share state across modules
	local context = {}
	context.Cons = {}
	context.Disconnect_Cons = Disconnect_Cons
	context.Fight_M = Fight_M
	context.Fight_Char_1 = Fight_Char_1
	context.Fight_Char_2 = Fight_Char_2
	-- gather fight data values and references
	local Fight_Data_F = Fight_M:WaitForChild("Fight_Data_F")
	context.Fight_Data_F = Fight_Data_F
	context.Inside_Checker_M = Fight_M:WaitForChild("Inside_Checker_M")
	context.Active_V = Fight_Data_F:WaitForChild("Active_Fight")
	context.Char_1_V = Fight_Data_F:WaitForChild("Fight_Char_1")
	context.Char_2_V = Fight_Data_F:WaitForChild("Fight_Char_2")
	context.Round_Count_V = Fight_Data_F:WaitForChild("Round_Count")
	context.Round_Wins_V = Fight_Data_F:WaitForChild("Round_Wins")
	context.Takedown_Track = Fight_Data_F:WaitForChild("Takedown_Track")
	context.Takedown_E = Fight_Data_F:WaitForChild("Takedown_E")
	context.Submission_Char = Fight_Data_F:WaitForChild("Submission_Hold_Character")
	context.C1_Clicked_E = context.Submission_Char:WaitForChild("C1_Clicked_E")
	context.C2_Clicked_E = context.Submission_Char:WaitForChild("C2_Clicked_E")
	context.C1_Health_V, context.C1_Stam_V = Get_Player_Fight_Data_Vals(Fight_Char_1)
	context.C2_Health_V, context.C2_Stam_V = Get_Player_Fight_Data_Vals(Fight_Char_2)
	context.C1_HRP = Fight_Char_1:FindFirstChild("HumanoidRootPart")
	context.C2_HRP = Fight_Char_2:FindFirstChild("HumanoidRootPart")
	context.C1_HUM = Fight_Char_1:FindFirstChild("Humanoid")
	context.C2_HUM = Fight_Char_2:FindFirstChild("Humanoid")
	context.C1_Name = Fight_Char_1.Name
	context.C2_Name = Fight_Char_2.Name
	context.Cage_Parts_M = Fight_M:WaitForChild("Cage_Walls_M")
	context.Cage_Type = Fight_M:GetAttribute("Cage_Type")
	context.Is_Bot_Fight = Fight_M:GetAttribute("Bot_Fight") or false
	context.Game_Mode = Utils.GetServerGameMode()

	-- initial stats snapshots
	context.Init_C1_Data = Stats_Manager_Mod.Create_Fight_Data_Structure(Fight_Char_1)
	context.Init_C2_Data = Stats_Manager_Mod.Create_Fight_Data_Structure(Fight_Char_2)
	context.C1_Rank_Data, context.C1_Elo = Elo_Mod.Get_Player_Rank_Data(game.Players:GetPlayerFromCharacter(Fight_Char_1))
	context.C2_Rank_Data, context.C2_Elo = Elo_Mod.Get_Player_Rank_Data(game.Players:GetPlayerFromCharacter(Fight_Char_2))
	context.Win_Data = {}
	context.Start_Time = os.clock()
	-- expose dependencies to modules
	context.Stats_Manager_Mod = Stats_Manager_Mod
	context.Sound_Mod = Sound_Mod
	context.Animation_Mod = Animation_Mod
	context.Elo_Mod = Elo_Mod
	context.Monetization_Mod = Monetization_Mod
	context.Fight_Params_Mod = Fight_Params_Mod

	-- initialise the fight and teleport players
	Fight_Initialization.Set_Fight_Data(context)
	Fight_Initialization.Move_Players_Into_Fight(context, true, true)
	-- wire up victory detection, takedown tracking and other loops
	Fight_Loop.Victory_Detection_Tracking(context, Fight_End)
	Fight_Loop.Takedown_Handle(context)
	Fight_Loop.Move_To_The_Ground_Handle(context, Fight_End, Server_Submission_Minigame)
	Fight_Loop.Out_Of_Bounds_Handle(context)
	Server_Clinch_Sequence.Cage_Control_Handle(context)
end

-- respond to the Start_Core_Fight event by preparing the arena and
-- launching the fight logic.  This logic reproduces the queue and UI
-- clearing behaviour of the original script before delegating to
-- Core_Fight_Logic_Handle.
Start_Core_Fight.Event:Connect(function(Fight_M, Fight_Char_1, Fight_Char_2)
	local canStart = Verify_Fight_Can_Start(Fight_M, Fight_Char_1, Fight_Char_2)
	if canStart then
		
		-- FIX Move to Fight Assignement
		if Utils.GetServerGameMode() == Global_Params_Mod.Server_Mode.STANDARD then 
			-- update fight model UI elements and remove invite buttons
			local fightModels = {
				{Fight_M:FindFirstChild("Fighter_1"), Fight_Char_1},
				{Fight_M:FindFirstChild("Fighter_2"), Fight_Char_2},
			}
			for _, fmData in pairs(fightModels) do
				local FM = fmData[1]
				local char = fmData[2]
				local Main_P = FM:FindFirstChild("Main_P")
				local B1, B2 = Main_P:FindFirstChild("B1"), Main_P:FindFirstChild("B2")
				--local Display_UI = Main_P:FindFirstChild("Player_Display_UI")
				local Empty_Txt = Player_Display_UI:FindFirstChild("Empty_Txt")
				local Player_F = Player_Display_UI:FindFirstChild("Player_F")
				local Outline_P = FM:FindFirstChild("Outline_P")
				local Rot_P = FM:FindFirstChild("Rot_Part")
				local QueueGlow = FM:FindFirstChild("QueueGlow")
				local QueueNeon = FM:FindFirstChild("QueueNeon")
				Player_F.Visible = false
				Empty_Txt.Visible = true
				local Col_Seq = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Color3.fromRGB(248, 248, 248)),
					ColorSequenceKeypoint.new(1, Color3.fromRGB(248, 248, 248))
				}
				B1.Color = Col_Seq
				B2.Color = Col_Seq
				Rot_P.Color = Color3.fromRGB(248, 248, 248)
				Outline_P.Color = Color3.fromRGB(248, 248, 248)
				QueueGlow.Color = Color3.fromRGB(207, 172, 169)
				QueueNeon.Color = Color3.fromRGB(207, 172, 169)
				local Prev_Char = char
				if Prev_Char ~= nil and game.Players:GetPlayerFromCharacter(Prev_Char) ~= nil then
					local Prev_Plr = game.Players:GetPlayerFromCharacter(Prev_Char)
					local PG = Prev_Plr:FindFirstChild("PlayerGui")
					local Invite_Buttons_UI = PG:WaitForChild("Fight"):FindFirstChild("Invite_Buttons_UI")
					if PG ~= nil and Invite_Buttons_UI ~= nil then
						Invite_Buttons_UI:Destroy()
					end
				end
			end
		end 
		-- launch the refactored fight logic
		Core_Fight_Logic_Handle(Fight_M, Fight_Char_1, Fight_Char_2)
		
		-- Spawn Scoreboards
		if Fight_M:FindFirstChild("ScoreBoard") then
			local new_Scoreboard_UI = Scoreboard_UI:Clone()
			new_Scoreboard_UI.Parent = Fight_M.ScoreBoard
			new_Scoreboard_UI.Adornee = Fight_M.ScoreBoard
		end 
	end
end)

local function IsBot(char)
	return char and char:GetAttribute("IsBot") == true
end

Ready_To_Fight.OnServerEvent:Connect(function(player, cageName)
	local cage = nil
	if cageName and cageName:sub(1, 8) == Fight_Params_Mod.CageType.TUTORIAL then
		cage = Cage_Factory:getCageFolder(Fight_Params_Mod.CageType.TUTORIAL):FindFirstChild(cageName)
	else
		cage = Cage_Factory:getCageFolder(Fight_Params_Mod.CageType.STANDARD):FindFirstChild(cageName)
	end

	if not cage then return end

	local Fight_Data_F = cage:FindFirstChild("Fight_Data_F")

	local char1 = Fight_Data_F:FindFirstChild("Fight_Char_1").Value
	local char2 = Fight_Data_F:FindFirstChild("Fight_Char_2").Value
	if not char1 or not char2 then return end

	local botChar = nil

	if IsBot(char1) then botChar = char1 end
	if IsBot(char2) then botChar = char2 end

	if botChar then
		local behavior
		-- Fallback: look up the behaviour instance from the registry on the module
		local behaviourName = botChar:GetAttribute("Behavior")
		if behaviourName then
			-- normalise to uppercase to match module names
			local modName = string.upper(behaviourName)
			local behavioursFolder = Data_Mods_F:WaitForChild("Bot_Behaviors")
			local behaviourModule = behavioursFolder:FindFirstChild(modName)
			if behaviourModule then
				local mod = require(behaviourModule)
				if mod and mod._registry then
					behavior = mod._registry[botChar]
				end
			end
		end

		-- Only start bot logic when intro is really finished
		if cage:GetAttribute("Intro_Finished") == true then
			if behavior then
				behavior:StartFight()
			end
		else
			-- queue start until intro finished
			local con
			con = game:GetService("RunService").Stepped:Connect(function()
				if cage:GetAttribute("Intro_Finished") == true then
					if con then con:Disconnect() end
					if behavior then
						behavior:StartFight()
					end
				end
			end)
		end
	end

end)

Fight_Intro_Finished.OnServerEvent:Connect(function(player, cageName)
	local cage = nil
	if cageName and cageName:sub(1, 8) == Fight_Params_Mod.CageType.TUTORIAL then
		cage = Cage_Factory:getCageFolder(Fight_Params_Mod.CageType.TUTORIAL):FindFirstChild(cageName)
	else
		cage = Cage_Factory:getCageFolder(Fight_Params_Mod.CageType.STANDARD):FindFirstChild(cageName)
	end
	
	if cage then
		cage:SetAttribute("Intro_Finished", true)
	end
end)
]]></ProtectedString>
						<string name="ScriptGuid">{3B9BDB42-04A2-4894-87D7-C55ADAFB8413}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Core_Fight_Handle.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX8735D017BF1E4E139054D074FA75BD5E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Core_Fight_Handle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA745AE5CA84B431C911FF1DC0AC01C9B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Events
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Fight_Set_Up = Channels.SC_Remote_Events.Fight_Set_Up


local Fight_Initialization = {}

--[[
    Fight_Initialization
    
    This module encapsulates the logic responsible for preparing a fight.  It
    mirrors the behaviour of the corresponding section of the original
    Core_Fight_Handle.server script without altering any functionality.  All
    state is passed in through the `context` table.  That table should
    contain all values and references used by the original Set_Fight_Data
    and Move_Players_Into_Fight functions (for example Active_V,
    Char_1_V, Char_2_V, Fight_M, C1_HRP, C2_HRP, etc.).

    Functions:
      Set_Fight_Data(context)      -- marks a fight as active and stores initial values
      Move_Players_Into_Fight(context, Init_Fight, initialTP)
        -- teleports characters into the arena, resets their health and
        -- stamina and notifies clients

    It is important that this module is required from the server-side
    Core_Fight_Handle script and the returned functions are invoked with
    the proper context.  No values are stored in the module itself; it
    relies entirely on the supplied context table.
]]

-- Marks a fight as active and sets up round counters.  This function
-- corresponds exactly to the original Set_Fight_Data definition.  It
-- assumes the following keys exist on the context table:
--   Active_V, Char_1_V, Char_2_V, Round_Count_V, Round_Wins_V,
--   Submission_Char, Fight_Char_1, Fight_Char_2
function Fight_Initialization.Set_Fight_Data(context)
	local Active_V = context.Active_V
	local Char_1_V = context.Char_1_V
	local Char_2_V = context.Char_2_V
	local Round_Count_V = context.Round_Count_V
	local Round_Wins_V = context.Round_Wins_V
	local Submission_Char = context.Submission_Char
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2

	-- replicate Set_Fight_Data from the original script
	Active_V.Value = true
	Char_1_V.Value = Fight_Char_1
	Char_2_V.Value = Fight_Char_2
	Round_Count_V.Value = 1
	Round_Wins_V.Value = ""

	local Old_Mid_Point = Submission_Char:FindFirstChild("Midpoint")
	if Old_Mid_Point ~= nil then
		Old_Mid_Point:Destroy()
	end
end

-- Teleports fighters into the arena and prepares their stats.  This
-- corresponds exactly to the Move_Players_Into_Fight function from the
-- original script.  The `Init_Fight` flag determines whether ranked
-- teleport behaviour is used; `initialTP` controls the initial wait
-- before teleporting when not ranked.  The context table must provide
-- numerous values including:
--   Fight_M, C1_HRP, C2_HRP, C1_HUM, C2_HUM, C1_Health_V,
--   C1_Stam_V, C2_Health_V, C2_Stam_V, Fight_Data_F,
--   Fight_Char_1, Fight_Char_2, Char_1_V, Is_Ranked_Match,
--   Sending_Events_F
function Fight_Initialization.Move_Players_Into_Fight(context, Init_Fight, initialTP)
	local C1_HRP = context.C1_HRP
	local C2_HRP = context.C2_HRP
	local C1_HUM = context.C1_HUM
	local C2_HUM = context.C2_HUM
	local C1_Health_V = context.C1_Health_V
	local C1_Stam_V = context.C1_Stam_V
	local C2_Health_V = context.C2_Health_V
	local C2_Stam_V = context.C2_Stam_V
	local Fight_Data_F = context.Fight_Data_F
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2
	local Char_1_V = context.Char_1_V
	local Fight_M = context.Fight_M
	local Is_Ranked_Match = context.Cage_Type == "RANKED"
	
	-- local helper replicating the Client_Set_Up_Event from the original
	local function Client_Set_Up_Event(Char)
		local C_Plr = game.Players:GetPlayerFromCharacter(Char)
		if C_Plr ~= nil then
			local Target_HRP, Target_Char, Is_C1 = C1_HRP, Fight_Char_1, true
			if Char == Char_1_V.Value then
				Target_HRP, Target_Char, Is_C1 = C2_HRP, Fight_Char_2, false
			end

			if Init_Fight then
				local isBot = game.Players:GetPlayerFromCharacter(Target_HRP.Parent) == nil
				if isBot == true then
					Fight_Set_Up:FireClient(C_Plr, Fight_M, true, Target_Char.Name)
				else
					Fight_Set_Up:FireClient(C_Plr, Fight_M, false, Target_Char, Target_HRP)
				end

				wait(1.1)

				if Is_Ranked_Match and Target_HRP ~= nil then
					local Ranked_Spawns_F = Fight_M:FindFirstChild("Ranked_Spawns_F")
					if Ranked_Spawns_F ~= nil then
						if Is_C1 and Ranked_Spawns_F:FindFirstChild("C1_Ranked_Spawn_P") ~= nil then
							local Spawn_P = Ranked_Spawns_F:FindFirstChild("C1_Ranked_Spawn_P")
							Target_HRP.CFrame = Spawn_P.CFrame
						elseif Is_C1 == false and Ranked_Spawns_F:FindFirstChild("C2_Ranked_Spawn_P") ~= nil then
							local Spawn_P = Ranked_Spawns_F:FindFirstChild("C2_Ranked_Spawn_P")
							Target_HRP.CFrame = Spawn_P.CFrame
						end
					end
				end
			end
		end
	end

	-- fire the client setup events concurrently
	task.spawn(Client_Set_Up_Event, Fight_Char_1)
	task.spawn(Client_Set_Up_Event, Fight_Char_2)

	-- wait based on ranked status
	if Init_Fight and Is_Ranked_Match then
		wait(18)
	else
		if initialTP == true then
			wait(1)
		end
	end

	-- teleport and reset fighter 1
	if C1_HRP ~= nil then
		local sp = Fight_Data_F:WaitForChild("Spawn_1")
		C1_HRP.CFrame = sp.CFrame * CFrame.new(0, -sp.Size.Y / 2 + C1_HRP.Size.Y / 2 + C1_HUM.HipHeight, 0)
		if C1_Health_V ~= nil then
			C1_Health_V.Value = 100
		end
		if C1_Stam_V ~= nil then
			C1_Stam_V.Value = 100
		end
		local Reset_Fight_Health_Data_C1 = Fight_Char_1:FindFirstChild("Reset_Fight_Health_Data")
		if Reset_Fight_Health_Data_C1 ~= nil then
			Reset_Fight_Health_Data_C1:Fire()
		end
	end

	-- teleport and reset fighter 2
	if C2_HRP ~= nil then
		local sp = Fight_Data_F:WaitForChild("Spawn_2")
		C2_HRP.CFrame = sp.CFrame * CFrame.new(0, -sp.Size.Y / 2 + C2_HRP.Size.Y / 2 + C2_HUM.HipHeight, 0)
		if C2_Health_V ~= nil then
			C2_Health_V.Value = 100
		end
		if C2_Stam_V ~= nil then
			C2_Stam_V.Value = 100
		end
		local Reset_Fight_Health_Data_C2 = Fight_Char_2:FindFirstChild("Reset_Fight_Health_Data")
		if Reset_Fight_Health_Data_C2 ~= nil then
			Reset_Fight_Health_Data_C2:Fire()
		end
	end
end

return Fight_Initialization]]></ProtectedString>
							<string name="ScriptGuid">{FD23B6BC-A8E3-40AE-8D04-6AE8E2FE3AD0}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Fight_Initialization.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX63F0B177451F4D7D8E756885D690F9D1">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Fight_Params_Mod = require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Overhead_Display_E = Channels.SC_Remote_Events.Overhead_Display

local Fight_Loop = {}

--[[
    Fight_Loop

    This module contains the ongoing fight logic once a bout has been
    initialized.  Functions here wire up health change listeners,
    detect takedown conditions, manage submissions, monitor out of
    bounds behaviour and handle per‐second cage proximity checks.  All
    functions expect a `context` table holding the same fields that
    existed as locals inside the original Core_Fight_Handle.server
    script.  Event connections created here are stored in
    context.Cons so that the caller may disconnect them when the fight
    ends.

    Functions:
      Clear_Takedown_Tracking(context)
      Nullify_Takedown_Tracking(context)
      Victory_Detection_Tracking(context, fightEndModule)
      Takedown_Handle(context)
      Move_To_The_Ground_Handle(context, fightEndModule, submissionMinigameModule)
      Out_Of_Bounds_Handle(context)
]]

-- Reset the takedown tracking value and clear all attributes on the
-- takedown tracker.  Mirrors Clear_Takedown_Tracking from the original
-- script.  context must contain Takedown_Track.
function Fight_Loop.Clear_Takedown_Tracking(context)
	local Takedown_Track = context.Takedown_Track
	Takedown_Track.Value = false
	for Key, Val in next, Takedown_Track:GetAttributes() do
		Takedown_Track:SetAttribute(Key, nil)
	end
end

-- Zero out all attributes on the takedown tracker and reset the
-- Start_Time value.  This is equivalent to Nullify_Takedown_Tracking
-- in the original script.  context must contain Takedown_Track and
-- Start_Time.
function Fight_Loop.Nullify_Takedown_Tracking(context)
	local Takedown_Track = context.Takedown_Track
	for Key, Val in next, Takedown_Track:GetAttributes() do
		Takedown_Track:SetAttribute(Key, 0)
	end
	context.Start_Time = os.clock()
end

-- Set up listeners to detect when a fighter has been knocked out or
-- otherwise removed from play.  When a victory condition is met,
-- Victory_Handle on the fightEndModule will be invoked.  context must
-- provide C1_Health_V, C2_Health_V, C1_HUM, C2_HUM, Fight_Char_1,
-- Fight_Char_2 and Cons.
function Fight_Loop.Victory_Detection_Tracking(context, fightEndModule)
	local Cons = context.Cons
	local C1_Health_V = context.C1_Health_V
	local C2_Health_V = context.C2_Health_V
	local C1_HUM = context.C1_HUM
	local C2_HUM = context.C2_HUM
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2

	-- debounce to avoid multiple triggers on fast health changes
	local Died_From_Health_Debounce = false

	if C1_Health_V ~= nil then
		table.insert(Cons, C1_Health_V.Changed:Connect(function()
			if C1_Health_V.Value <= 0 and Died_From_Health_Debounce == false then
				Died_From_Health_Debounce = true
				fightEndModule.Victory_Handle(context, Fight_Char_2, false)
				wait(3)
				Died_From_Health_Debounce = false
			end
		end))
		table.insert(Cons, C1_HUM.Changed:Connect(function()
			if C1_HUM.Health <= 0 and Died_From_Health_Debounce == false then
				Died_From_Health_Debounce = true
				fightEndModule.Victory_Handle(context, Fight_Char_2, true)
				wait(3)
				Died_From_Health_Debounce = false
			end
		end))
	end

	if C2_Health_V ~= nil then
		table.insert(Cons, C2_Health_V.Changed:Connect(function()
			if C2_Health_V.Value <= 0 and Died_From_Health_Debounce == false then
				Died_From_Health_Debounce = true
				fightEndModule.Victory_Handle(context, Fight_Char_1, false)
				wait(3)
				Died_From_Health_Debounce = false
			end
		end))
		table.insert(Cons, C2_HUM.Changed:Connect(function()
			if C2_HUM.Health <= 0 and Died_From_Health_Debounce == false then
				Died_From_Health_Debounce = true
				fightEndModule.Victory_Handle(context, Fight_Char_1, true)
				wait(3)
				Died_From_Health_Debounce = false
			end
		end))
	end

	if Fight_Char_1 ~= nil then
		table.insert(Cons, Fight_Char_1.AncestryChanged:Connect(function()
			if Fight_Char_1 == nil or Fight_Char_1.Parent == nil or not Fight_Char_1:IsDescendantOf(game.Workspace) then
				fightEndModule.Victory_Handle(context, context.Fight_Char_2, true)
			end
		end))
	end

	if Fight_Char_2 ~= nil then
		table.insert(Cons, Fight_Char_2.AncestryChanged:Connect(function()
			if Fight_Char_2 == nil or Fight_Char_2.Parent == nil or not Fight_Char_2:IsDescendantOf(game.Workspace) then
				fightEndModule.Victory_Handle(context, context.Fight_Char_1, true)
			end
		end))
	end
end

-- Track damage taken by each fighter and raise the takedown flag when
-- certain thresholds are exceeded.  This implements the original
-- Takedown_Handle function and relies on Clear_Takedown_Tracking to
-- reset the state before starting.  context must provide
-- Takedown_Track, C1_Name, C2_Name, C1_Health_V, C1_Stam_V,
-- C2_Health_V, C2_Stam_V, Submission_Char and Cons.
function Fight_Loop.Takedown_Handle(context)
	local Takedown_Track = context.Takedown_Track
	local C1_Name = context.C1_Name
	local C2_Name = context.C2_Name
	local C1_Health_V = context.C1_Health_V
	local C1_Stam_V = context.C1_Stam_V
	local C2_Health_V = context.C2_Health_V
	local C2_Stam_V = context.C2_Stam_V
	local Submission_Char = context.Submission_Char
	local Cons = context.Cons

	-- algorithm parameters
	local Min_Difference = Fight_Params_Mod.Takedown.Min_Difference
	-- reset takedown tracking at the beginning
	Fight_Loop.Clear_Takedown_Tracking(context)

	-- update tracking values when a fighter takes damage
	local function Player_Hit_Tracking(Key, Opponent_Health_V, Opponent_Stam_V)
		
		local function Increment_Takedown_Tracker(Health_Dif)
			if Health_Dif > 0 then
				local Prev_Val = Takedown_Track:GetAttribute(Key) or 0
				local New_Value = Prev_Val + 1

				Takedown_Track:SetAttribute(Key, New_Value)
			end
		end
		
		local function Update_Takedown_Bool()
			if Submission_Char.Value == nil then
				local C1_Val = Takedown_Track:GetAttribute(C1_Name) or 0
				local C2_Val = Takedown_Track:GetAttribute(C2_Name) or 0
				local Min_Val = math.min(C1_Val, C2_Val)
				local Difference = math.abs(C1_Val - C2_Val)
				
				Takedown_Track:SetAttribute(C1_Name, C1_Val - Min_Val)
				Takedown_Track:SetAttribute(C2_Name, C2_Val - Min_Val)
				Takedown_Track.Value = Difference >= Min_Difference
			end
		end
		
		local Prev_Health = Opponent_Health_V.Value
		local Debounce_H = false
		table.insert(Cons, Opponent_Health_V.Changed:Connect(function()
			if Debounce_H == false then
				Debounce_H = true
				local Current_Health = Opponent_Health_V.Value
				local Health_Dif = Prev_Health - Current_Health
				Prev_Health = Current_Health
				Increment_Takedown_Tracker(Health_Dif)
				Update_Takedown_Bool()
				-- wait(1)
				Debounce_H = false
			end
		end))
		Takedown_Track:SetAttribute(Key, 0)
	end
	-- start tracking hits for both fighters
	Player_Hit_Tracking(C1_Name, C2_Health_V, C2_Stam_V)
	Player_Hit_Tracking(C2_Name, C1_Health_V, C1_Stam_V)
end

-- Handles all logic associated with takedowns leading to a submission
-- mini–game.  This mirrors the Move_To_The_Ground_Handle function in
-- the original script.  The `submissionMinigame` parameter should
-- expose a function Submission_Handle(context, Submission_Plr) which
-- contains the minigame implementation.  fightEndModule is not used
-- here but is passed to maintain the same signature used elsewhere.
function Fight_Loop.Move_To_The_Ground_Handle(context, fightEndModule, submissionMinigame)
	local Debounce_Takedown = false
	local Takedown_Track = context.Takedown_Track
	local C1_Name = context.C1_Name
	local C2_Name = context.C2_Name
	local C1_HRP = context.C1_HRP
	local C2_HRP = context.C2_HRP
	local C1_HUM = context.C1_HUM
	local C2_HUM = context.C2_HUM
	local C1_Health_V = context.C1_Health_V
	local C1_Stam_V = context.C1_Stam_V
	local C2_Health_V = context.C2_Health_V
	local C2_Stam_V = context.C2_Stam_V
	local Submission_Char = context.Submission_Char
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2
	local Takedown_E = context.Takedown_E
	local C1_HRP = context.C1_HRP
	local C2_HRP = context.C2_HRP
	local Active_V = context.Active_V
	local Cons = context.Cons
	local Stats_Manager_Mod = context.Stats_Manager_Mod

	-- Determine if a player can successfully initiate a takedown
	local function Can_Take_Down_Player(Plr)
		local C1_Val = Takedown_Track:GetAttribute(C1_Name) or 0
		local C2_Val = Takedown_Track:GetAttribute(C2_Name) or 0
		local Dist = (C1_HRP.Position - C2_HRP.Position).Magnitude
		if ((C1_Val > C2_Val and C1_Name == Plr.Name) or (C1_Val < C2_Val and C2_Name == Plr.Name)) and Dist <= 20 then
			return true
		end
		return false
	end

	-- enable or disable the damage UI on a character
	--local function Toggle_Players_Damage_Bars(Char, Is_Enabled)
	--	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	--	if Fight_UI ~= nil then
	--		Fight_UI.Enabled = Is_Enabled
	--	end
	--end

	-- reposition fighters and weld them for the takedown and submission sequences
	--local function New_Animation_Handle(T_Char, R_Char, Submission_Plr)
	--	local T_HRP = T_Char:FindFirstChild("HumanoidRootPart")
	--	local R_HRP = R_Char:FindFirstChild("HumanoidRootPart")
	--	local destructor = function() end
	--	local function Assert_Check()
	--		return T_HRP ~= nil and R_HRP ~= nil and Submission_Plr.Character ~= nil
	--	end
	--	if Assert_Check() then
	--		local Takedown_Data, Submission_Data = context.Animation_Mod.Get_Takedown_Submission_Data(Submission_Plr.Character)
	--		local R_CF_Origin = R_HRP.CFrame
	--		T_HRP.CFrame = R_CF_Origin:ToWorldSpace(Takedown_Data['CF Offset'])
	--		local weld = Instance.new("Weld")
	--		weld.Part0 = R_HRP
	--		weld.Part1 = T_HRP
	--		weld.C0 = Takedown_Data['CF Offset']
	--		weld.Parent = R_HRP
	--		Toggle_Players_Damage_Bars(T_Char, false)
	--		Toggle_Players_Damage_Bars(R_Char, false)
	--		destructor = function()
	--			weld:Destroy()
	--		end
	--		task.spawn(function()
	--			task.wait(Takedown_Data['Time Length'] + 0.25)
	--			if Assert_Check() then
	--				T_HRP.CFrame = R_CF_Origin:ToWorldSpace(Submission_Data['CF Offset'])
	--				weld.C0 = Submission_Data['CF Offset']
	--			end
	--		end)
	--	end
	--	return destructor
	--end

	-- reduce the stamina of the attacking player after an attempted takedown
	local function Deduct_Stam(Plr)
		local Stamina_Consumption = Fight_Params_Mod.Stamina.Attempted_Takedown
		if Fight_Char_1 ~= nil and C1_Name == Plr.Name and C1_Stam_V ~= nil then
			local Val = C1_Stam_V.Value - Stamina_Consumption
			C1_Stam_V.Value = math.clamp(Val, 25, 100)
		elseif Fight_Char_2 ~= nil and C2_Name == Plr.Name and C2_Stam_V ~= nil then
			local Val = C2_Stam_V.Value - Stamina_Consumption
			C2_Stam_V.Value = math.clamp(Val, 25, 100)
		end
	end

	-- apply impulse and overhead text when a takedown is missed
	local function Missed_Takedown(Plr)
		local P_Char = Plr.Character
		if P_Char ~= nil and P_Char:FindFirstChild("HumanoidRootPart") ~= nil then
			local P_HRP = P_Char:FindFirstChild("HumanoidRootPart")
			local Hit_Force = 500
			local Dir = P_HRP.CFrame.LookVector
			P_HRP:ApplyImpulse(Dir * Hit_Force * P_HRP:GetMass())
			Overhead_Display_E:FireAllClients(P_Char, "Missed!", Color3.fromRGB(9, 137, 207))
		end
	end

	-- orchestrate a successful takedown leading into a submission
	local function Set_Up_Takedown(Plr)
		Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Takedowns Landed", 1)
		Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Submissions Attempted", 1)
		
		Submission_Char.Value = Plr.Character
		-- reset tracking before the submission game begins
		Fight_Loop.Nullify_Takedown_Tracking(context)
		-- launch the submission minigame
		submissionMinigame.Submission_Handle(context, Plr)
	end

	-- connect to the takedown remote and handle success or miss
	table.insert(Cons, Takedown_E.OnServerEvent:Connect(function(Plr)
		if Debounce_Takedown == false and Active_V.Value == true and Takedown_Track.Value == true and Submission_Char.Value == nil then
			Debounce_Takedown = true
			Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Takedowns Attempted", 1)
			Deduct_Stam(Plr)
			if Can_Take_Down_Player(Plr) then
				Set_Up_Takedown(Plr)
			else
				Missed_Takedown(Plr)
			end
			wait(10)
			Debounce_Takedown = false
		end
	end))
end

-- Monitor fighters’ positions relative to the fighting area and force
-- them back inside if they stray too far for too long.  Mirrors
-- Out_Of_Bounds_Handle in the original.  context must provide
-- Fight_Char_1, Fight_Char_2, Inside_Checker_M and Cons.
function Fight_Loop.Out_Of_Bounds_Handle(context)
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2
	local Inside_Checker_M = context.Inside_Checker_M
	local Cons = context.Cons

	local function Track_Character(Character)
		local time_outside = 0
		local max_time_outside = 3
		local runCon = game:GetService("RunService").Heartbeat:Connect(function(dt)
			local HRP = Character:FindFirstChild("HumanoidRootPart")
			local isOutside = true
			if HRP then
				local collider = Inside_Checker_M.Collider
				local pos = HRP.Position
				local localPos = collider.CFrame:pointToObjectSpace(pos)
				localPos = Vector2.new(
					localPos.X / (collider.Size.X / 2),
					math.sqrt(localPos.Y ^ 2 + localPos.Z ^ 2) / (collider.Size.Y / 2)
				)
				if math.abs(localPos.X) <= 1 and math.abs(localPos.Y) <= 1 then
					isOutside = false
				end
			end
			if isOutside == true then
				time_outside += dt
			else
				time_outside -= dt
			end
			time_outside = math.clamp(time_outside, 0, max_time_outside)
			if time_outside >= max_time_outside then
				Character:PivotTo(Inside_Checker_M.Position.CFrame * CFrame.new(0, 3, 0))
			end
		end)
		table.insert(Cons, runCon)
	end
	if Fight_Char_1 then Track_Character(Fight_Char_1) end
	if Fight_Char_2 then Track_Character(Fight_Char_2) end
end

return Fight_Loop]]></ProtectedString>
							<string name="ScriptGuid">{888A3D1C-85BC-42D7-BEC2-FCE3E46A4BD3}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Fight_Loop.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXCAE24B6917634B3ABD4FE12693E612EF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Fight_Initialization 		= require(script.Parent:WaitForChild("Fight_Initialization"))
local Fight_Loop 				= require(script.Parent:WaitForChild("Fight_Loop"))
local PlayerUtils 				= require(game.ReplicatedStorage.Modules.PlayerUtils)
local Elo_Mod 					= require(game.ReplicatedStorage.Data_Mods_F.Elo_Mod)
local Channels 					= require(game.ReplicatedStorage.Modules.Channels)
local Fight_Params_Mod			= require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)
local Global_Params_Mod			= require(game.ReplicatedStorage.Data_Mods_F.Global_Params_Mod)
local League_Manager			= require(game.ServerScriptService.League_Service.League_Manager)
local Stats_Manager_Mod			= require(game.ReplicatedStorage.Data_Mods_F.Stats_Manager_Mod)
local Monetization_Mod			= require(game.ReplicatedStorage.Data_Mods_F.Monetization_Mod)

local Round_Result_Win 			= Channels.Server_Client_Events.Round_Result_Win
local End_Fight 				= Channels.Server_Client_Events.End_Fight
local Fight_Data_Result 		= Channels.Server_Client_Events.Fight_Data_Result
local Display_Data 				= Channels.Server_Client_Events.Display_Data

--[[
    Fight_End

    This module defines the victory resolution logic for the fight system.
    Its primary entry point is Victory_Handle which mirrors the original
    function of the same name found within Core_Fight_Handle.server.
    It accepts a context table carrying all state required to compute
    winner determination, stat rewards and round progression.  The
    function is invoked by the fight loop when a knockout or other
    victory condition is detected.

    The module depends on the Fight_Initialization and Fight_Loop
    modules to reset rounds and clear/nullify takedown tracking when
    necessary.  Those modules are required via script.Parent so that
    they can be found alongside this module in Roblox Studio.
]]

local Fight_End = {}

local ROUND_END_DELAY = 3.5
local MOVE_OUT_OF_CAGE_DELAY = 5

--------------------------------------------------------
-- UTILITY HELPERS
--------------------------------------------------------

local function FireToWinnerRound(Winning_Char, Was_KO)
	local plr = game.Players:GetPlayerFromCharacter(Winning_Char)
	if plr then
		warn(tostring(Winning_Char) .. " won the round")
		Round_Result_Win:FireClient(plr, Was_KO)
	end
end

-- helper to get the opponent character for teleporting out of the ring
local function GetOpponent(ctx, Char)
	if Char == ctx.Fight_Char_1 then
		return ctx.Fight_Char_2
	end
	return ctx.Fight_Char_1
end

--------------------------------------------------------
-- MATCH WINNER RESOLUTION 
--------------------------------------------------------

local function Get_Winning_Result(ctx, Winning_Char, Dead_Or_KO)
	local Win_Data = ctx.Win_Data
	local C1_Name = ctx.C1_Name
	local Fight_Char_1 = ctx.Fight_Char_1
	local Fight_Char_2 = ctx.Fight_Char_2
	local Is_Ranked_Match = ctx.Cage_Type == "RANKED"

	local Needed_Wins = Fight_Params_Mod.Needed_Winning_Rounds.STANDARD
	if Is_Ranked_Match == true then
		Needed_Wins = Fight_Params_Mod.Needed_Winning_Rounds.RANKED
	end

	local C1_Wins = 0
	local C2_Wins = 0

	for _, name in ipairs(Win_Data) do
		if name == C1_Name then
			C1_Wins += 1
		else
			C2_Wins += 1
		end
	end

	if Fight_Char_1 == nil then return Fight_Char_2 end
	if Fight_Char_2 == nil then return Fight_Char_1 end

	if Dead_Or_KO then
		if C1_Wins >= C2_Wins then return Fight_Char_1 else return Fight_Char_2 end
	end

	if C1_Wins >= Needed_Wins then return Fight_Char_1 end
	if C2_Wins >= Needed_Wins then return Fight_Char_2 end

	return nil
end

--------------------------------------------------------
-- AWARD STATS 
--------------------------------------------------------

-- Handle win or loss of ELO depending of previous ELO scores of both players
local function ELO_Reward(GameMode, CageType, Char, Plr, Did_Win, Fight_Char_1, Fight_Char_2)
	if GameMode == Global_Params_Mod.Server_Mode.STANDARD or GameMode == "" then 
		-- ELO (Ranked or Standard Cage)
		local EloMode = nil
		if CageType == Fight_Params_Mod.CageType.RANKED then
			EloMode = Elo_Mod.EloMode.Ranked

		elseif CageType == Fight_Params_Mod.CageType.STANDARD then
			EloMode = Elo_Mod.EloMode.Standard

			-- No ELO for other CageType : TUTORIAL, etc. 
		end

		if EloMode then
			local Opponent_Char = (Char == Fight_Char_1) and Fight_Char_2 or Fight_Char_1
			local Opponent_Plr = Opponent_Char['_PLAYER_VALUE_'].Value

			local myElo = Plr.Player_Data.Elo.Value
			local oppElo = Opponent_Plr.Player_Data.Elo.Value

			local newWinnerElo, newLoserElo = Elo_Mod.Compute_Elo(
				Did_Win and myElo or oppElo,
				Did_Win and oppElo or myElo,
				EloMode
			)

			local myNewElo = Did_Win and newWinnerElo or newLoserElo
			local rawDelta = myNewElo - myElo

			local Elo_Multi = Monetization_Mod.Get_Elo_Multi(Plr)
			local Final_Elo_Change = math.ceil(rawDelta * Elo_Multi)

			Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Elo", Final_Elo_Change)

			local msg = Did_Win
				and ("🏆 You won " .. Final_Elo_Change .. " Elo!")
				or  ("❌ You lost " .. math.abs(Final_Elo_Change) .. " Elo!")

			local color = Did_Win and Color3.fromRGB(255,170,0) or Color3.fromRGB(255,60,60)
			Display_Data:FireClient(Plr, msg, color)
		end
	end
end

-- Increment Player Stats for different type of matches and different types of wins, increment win streak too 
local function Matches_Wins_Count(GameMode, CageType, Plr, Did_Win, Submission_Char)
	if GameMode == Global_Params_Mod.Server_Mode.STANDARD or GameMode == "" then
		if CageType == Fight_Params_Mod.CageType.RANKED then
			Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Ranked Matches", 1)
			Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Ranked Wins", Did_Win and 1 or 0)

		elseif CageType == Fight_Params_Mod.CageType.STANDARD then
			Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Matches", 1)
			Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Wins", Did_Win and 1 or 0)
		end
		-- No count for other CageType : TUTORIAL etc. 

	elseif GameMode == Global_Params_Mod.Server_Mode.TOURNAMENT then
		Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "League Matches", 1)
		Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "League Wins", Did_Win and 1 or 0)
	end	


	-- Type of Win Stats
	if Did_Win then
		Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Win Streak", 1)

		if Submission_Char.Value ~= nil then
			Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Submissions Wins", 1)
		else
			local Did_Punch_Last = Plr:GetAttribute("Did_Punch_Last")
			if Did_Punch_Last == false then
				Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Leg Knockout Wins", 1)
			else
				Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Punch Knockout Wins", 1)
			end
		end

	else 
		Stats_Manager_Mod.Set_Player_Stats_Data(Plr, "Win Streak", 0)
	end
end

-- Give reward to player depending on gamemode and type of match
local function Rewards(GameMode, CageType, Plr, Did_Win)
	-- Cash reward for standard mode
	if GameMode == Global_Params_Mod.Server_Mode.STANDARD or GameMode == ""  then
		if Did_Win then
			local Cash_Reward = 0
			if CageType == Fight_Params_Mod.CageType.RANKED then
				Cash_Reward = Fight_Params_Mod.Reward.Ranked_Win_Cash

			elseif CageType == Fight_Params_Mod.CageType.STANDARD then
				Cash_Reward = Fight_Params_Mod.Reward.Standard_Win_Cash
			end -- Not Cash reward for other cage type

			local Cash_Multi = Monetization_Mod.Get_Cash_Multi(Plr)
			local Reward = math.ceil(Cash_Reward * Cash_Multi)
			PlayerUtils.RewardPlayer(Plr, "Coins", Reward)
		end

		-- Give league points for tournament matches
	elseif GameMode == Global_Params_Mod.Server_Mode.TOURNAMENT  then
		if Did_Win then 
			print("TOURNAMENT : "..Plr.Name.." win")
			League_Manager:AddWin(Plr)
		else 
			print("TOURNAMENT : "..Plr.Name.." loose")
			League_Manager:AddLoss(Plr)
		end
	end
end

local function Award_Stats(ctx, Char, Winning_Char)
	local Plr = Char['_PLAYER_VALUE_'].Value
	local Did_Win = (Char == Winning_Char)
	local GameMode = ctx.Game_Mode
	local CageType = ctx.Cage_Type

	-- No reward for Bot fights
	if ctx.Is_Bot_Fight then return end

	-- ELO only in Standard gamemode - no bots
	ELO_Reward(GameMode, CageType, Char, Plr, Did_Win, ctx.Fight_Char_1, ctx.Fight_Char_2)

	-- Match count 
	Matches_Wins_Count(GameMode, CageType, Plr, Did_Win, ctx.Submission_Char)

	-- Fight Rewards (cash or league points)
	Rewards(GameMode, CageType, Plr, Did_Win)
end



-- move players out of the ring after stats are updated
local function Move_Out_Of_Cage(ctx, Char)
	local Plr = Char['_PLAYER_VALUE_'].Value
	
	if Plr and Plr.Character then
		local Chr = Plr.Character
		if Chr.PrimaryPart then
			local Is_Tournament = ctx.Game_Mode == Global_Params_Mod.Server_Mode.TOURNAMENT
			local Is_Tutorial = ctx.Cage_Type == Fight_Params_Mod.CageType.TUTORIAL

			-- for tutorial & league we want to teleport them to the start spawn after the fight is over
			if Is_Tutorial or Is_Tournament then
				local spawnLocation = PlayerUtils.GetStartSpawn()
				PlayerUtils.GoToPosition(Plr, spawnLocation.Position)
				-- for normal fights we want to teleport them to the end spawn after the fight is over
			else
				local End_Spawn_P = ctx.Fight_Data_F:WaitForChild("End_Spawn")
				PlayerUtils.GoToPosition(Plr, End_Spawn_P.Position)
			end

			-- if the character is still anchored, unanchor it
			local hrp2 = Chr:FindFirstChild("HumanoidRootPart")
			if hrp2 then
				hrp2.Anchored = true
				task.spawn(function()
					task.wait(1)
					hrp2.Anchored = false
				end)
			end
		end
	end
end


-- send aggregated fight statistics back to both players
local function Get_Fight_Data(ctx, Winning_Char)
	local Did_C1_Win = (Winning_Char == ctx.Fight_Char_1)

	local Final_C1 = Stats_Manager_Mod.Create_Fight_Data_Structure(ctx.Fight_Char_1)
	local Final_C2 = Stats_Manager_Mod.Create_Fight_Data_Structure(ctx.Fight_Char_2)

	local Final_Fight_Data = Stats_Manager_Mod.Create_Fight_Result_Data(
		ctx.Init_C1_Data,
		ctx.Init_C2_Data,
		Final_C1,
		Final_C2,
		ctx.Win_Data,
		Did_C1_Win
	)

	return Final_Fight_Data
end

local function Process_End_Of_Fight_For_Char(ctx, Char, Winning_Char, Final_Fight_Data)

	local Plr = game.Players:GetPlayerFromCharacter(Char)

	if Char:GetAttribute("UserId") and Plr ~= nil then
		local isBot = Char:GetAttribute("IsBot")
		if not isBot then
			Award_Stats(ctx, Char, Winning_Char)
			Fight_Data_Result:FireClient(Plr, Final_Fight_Data, Winning_Char)
			coroutine.wrap(function()
				task.wait(MOVE_OUT_OF_CAGE_DELAY)
				End_Fight:FireClient(Plr, GetOpponent(ctx, Char))
				Move_Out_Of_Cage(ctx, Char)
			end)()
		end
	end
end

-- reset fight data back to an idle state
local function Fight_Data_Reset(ctx)
	ctx.Char_1_V.Value = nil
	ctx.Char_2_V.Value = nil
	ctx.Round_Count_V.Value = 1
	ctx.Round_Wins_V.Value = ""
	ctx.Submission_Char.Value = nil

	task.spawn(function()
		Fight_Loop.Clear_Takedown_Tracking(ctx)
	end)

	if ctx.C1_Health_V then
		task.defer(function()
			task.wait(ROUND_END_DELAY)
			ctx.C1_Health_V.Value = 100
		end)
	end
	if ctx.C2_Health_V then
		task.defer(function()
			task.wait(ROUND_END_DELAY)
			ctx.C2_Health_V.Value = 100
		end)
	end

	if ctx.C1_Stam_V then
		ctx.C1_Stam_V.Value = 100
	end
	if ctx.C2_Stam_V then
		ctx.C2_Stam_V.Value = 100
	end

	if ctx.Is_Bot_Fight then
		task.spawn(function()
			task.wait(ROUND_END_DELAY)
			if ctx.Fight_Char_1 and game.Players:GetPlayerFromCharacter(ctx.Fight_Char_1) == nil then
				ctx.Fight_Char_1:Destroy()
			end
			if ctx.Fight_Char_2 and game.Players:GetPlayerFromCharacter(ctx.Fight_Char_2) == nil then
				ctx.Fight_Char_2:Destroy()
			end
		end)
	end

	ctx.Active_V.Value = false
end

-- no outright winner: prepare for the next round
local function Prepare_Next_Round(ctx)
	task.wait(ROUND_END_DELAY)

	local Plr1 = game.Players:GetPlayerFromCharacter(ctx.Fight_Char_1)
	if Plr1 then
		local Fight_Data_F_Plr = Plr1:FindFirstChild("Fight_Data")
		if Fight_Data_F_Plr then
			local Block_Power_V = Fight_Data_F_Plr:FindFirstChild("Block Power")
			if Block_Power_V then Block_Power_V.Value = 30 end
		end
	end

	local Plr2 = game.Players:GetPlayerFromCharacter(ctx.Fight_Char_2)
	if Plr2 then
		local Fight_Data_F_Plr = Plr2:FindFirstChild("Fight_Data")
		if Fight_Data_F_Plr then
			local Block_Power_V = Fight_Data_F_Plr:FindFirstChild("Block Power")
			if Block_Power_V then Block_Power_V.Value = 30 end
		end
	end

	if ctx.Active_V.Value == true then
		ctx.Round_Count_V.Value += 1
		ctx.Submission_Char.Value = nil
		-- reset takedown tracking so the next round starts fresh
		Fight_Loop.Nullify_Takedown_Tracking(ctx)
		-- teleport fighters back to their starting positions for the new round
		Fight_Initialization.Move_Players_Into_Fight(ctx, false)
	end
end


--------------------------------------------------------
-- DISPATCH FULL MATCH WIN FLOW 
--------------------------------------------------------
local function Process_Full_Victory(ctx, Winning_Char)
	ctx.Disconnect_Cons(ctx.Cons)

	local Final_Fight_Data = Get_Fight_Data(ctx, Winning_Char)

	if ctx.Fight_Char_1 then 
		Process_End_Of_Fight_For_Char(ctx, ctx.Fight_Char_1, Winning_Char, Final_Fight_Data)
	end

	if ctx.Fight_Char_2 then 
		Process_End_Of_Fight_For_Char(ctx, ctx.Fight_Char_2, Winning_Char, Final_Fight_Data)
	end

	task.wait(MOVE_OUT_OF_CAGE_DELAY)
	Fight_Data_Reset(ctx)

	-- Remove Scoreboard 
	if ctx.Fight_M:FindFirstChild("ScoreBoard") then
		local Scoreboard_UI = ctx.Fight_M:FindFirstChild("ScoreBoard"):FindFirstChild("Scoreboard_UI")
		Scoreboard_UI:Destroy()
	end
end

--------------------------------------------------------
-- MAIN ENTRY POINT 
--------------------------------------------------------
-- Resolve the winner of a round, update statistics and reset for the
-- next round or end of fight.  Winning_Char is the character that
-- delivered the knockout or otherwise triggered a round end, and
-- End_Fight indicates whether a fighter died (true) or was simply
-- knocked down (false).  All state and services are carried on the
-- context table.
function Fight_End.Victory_Handle(ctx, Winning_Char, Dead_Or_KO)
	local Win_Data = ctx.Win_Data

	-- append the winner’s name to the running list of round winners
	table.insert(Win_Data, Winning_Char.Name)
	ctx.Round_Wins_V.Value = table.concat(Win_Data, ",")

	-- disable takedown tracking for the remainder of the round
	ctx.Takedown_Track.Value = false

	-- determine if the fight as a whole has been won (best of 3 ranked, best of 2 unranked)
	local Winning_Result = Get_Winning_Result(ctx, Winning_Char, Dead_Or_KO)

	-- fire a round result event to the winning player (knockout vs submission)
	task.spawn(function()
		local Was_KO = (ctx.Submission_Char.Value == nil)
		FireToWinnerRound(Winning_Char, Was_KO)
	end)

	-- 5. If match over → full victory flow
	if Winning_Result ~= nil then
		Process_Full_Victory(ctx, Winning_Char)
		return
	end

	-- 6. Otherwise → next round flow
	Prepare_Next_Round(ctx)
end

return Fight_End]]></ProtectedString>
							<string name="ScriptGuid">{D8A9FF0E-D479-47CE-B678-C97DEEA273B9}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Fight_End.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX339F9C00357F40888078931BD138FF46">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Fight_Params_Mod = require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Cage_Clinch_Start = Channels.SC_Remote_Events.Cage_Clinch_Start
local AI_Training_Cage_Clinch = Channels.Bindable_Events.AI_Training_Cage_Clinch

local Clinch_Sequence = {}

--[[
    Clinch_Sequence

    Encapsulates the "against the cage" clinch logic from the original
    Core_Fight_Handle.server script.  When certain health and stamina
    conditions are met, and fighters are pressed against the cage,
    this module runs a cinematic sequence that drains stamina and
    health.  All state and services are passed in via a context table
    mirroring the local variables of the original script.

    Functions:
      Cage_Control_Handle(context)
        -- monitors fighters during the fight and triggers the cage
        -- clinch sequence when appropriate

    Required context fields:
      Round_Count_V, Fight_Char_1, Fight_Char_2, Submission_Char,
      Takedown_Track, C1_Health_V, C2_Health_V, C1_Stam_V, C2_Stam_V,
      C1_HRP, C2_HRP, Cage_Parts_M, Animation_Mod, Sound_Mod, Active_V.
]]

function Clinch_Sequence.Cage_Control_Handle(context)
	local Prev_Round = 0
	local Distance_To_Cage = 5
	local Max_Opponent_Health = 75
	local Min_Health_To_Trigger = 75
	local Min_Stam_To_Tigger = 50
	local Round_Count_V = context.Round_Count_V
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2
	local Submission_Char = context.Submission_Char
	local Takedown_Track = context.Takedown_Track
	local C1_Health_V = context.C1_Health_V
	local C2_Health_V = context.C2_Health_V
	local C1_Stam_V = context.C1_Stam_V
	local C2_Stam_V = context.C2_Stam_V
	local C1_HRP = context.C1_HRP
	local C2_HRP = context.C2_HRP
	local Cage_Parts_M = context.Cage_Parts_M
	local Animation_Mod = context.Animation_Mod
	local Sound_Mod = context.Sound_Mod
	local Active_V = context.Active_V

	-- play the full clinch sequence for the attacking and defending characters
	local function Against_The_Cage_Sequence(Attacking_Char, Bad_Char, Cage_Pos)
		local Attacking_Offset_CF = CFrame.new(Vector3.new(0.8270339965820312, 0, -4.329065322875977)) * CFrame.Angles(math.rad(180), 0, math.rad(180))
		Prev_Round = Round_Count_V.Value
		-- lock players in place against the cage
		local function Lock_Players_Down()
			local function Move_Bad_Char()
				local Bad_Char_HRP = Bad_Char:FindFirstChild("HumanoidRootPart")
				if Bad_Char_HRP ~= nil then
					local Rot = Bad_Char_HRP.CFrame.Rotation
					Bad_Char_HRP.CFrame = CFrame.new(Cage_Pos) * Rot
					Bad_Char_HRP.Anchored = true
					return Bad_Char_HRP
				end
				return nil
			end
			local Bad_Char_HRP = Move_Bad_Char()
			if Bad_Char_HRP ~= nil then
				local function Move_Attacking_Char()
					local Attack_HRP = Attacking_Char:FindFirstChild("HumanoidRootPart")
					if Attack_HRP ~= nil then
						Attack_HRP.CFrame = Bad_Char_HRP.CFrame:ToWorldSpace(Attacking_Offset_CF)
						Attack_HRP.Anchored = true
					end
				end
				Move_Attacking_Char()
			end
			return Bad_Char_HRP
		end
		local Bar_Char_HRP = Lock_Players_Down()
		-- trigger animations and camera effects for both fighters
		local function Start_Client_Effects()
			local function Get_Cam_Clinch_CF()
				local CF_Offset = CFrame.new(Vector3.new(-7.615234375, 5.331428527832031, -7.482333183288574)) * CFrame.Angles(math.rad(-140), math.rad(-40), math.rad(-155))
				if Bar_Char_HRP ~= nil then
					return Bar_Char_HRP.CFrame:ToWorldSpace(CF_Offset)
				end
				return CF_Offset
			end
			local Cam_Clinch_CF = Get_Cam_Clinch_CF()
			local Sequence_Keys = Animation_Mod.Generate_Clinch_Attack_Keys()
			-- notify the attacking player
			local function Init_Attacking_Player()
				if Attacking_Char ~= nil then
					local Attack_Plr = game.Players:GetPlayerFromCharacter(Attacking_Char)
					if Attack_Plr ~= nil then
						Cage_Clinch_Start:FireClient(Attack_Plr, Sequence_Keys, true, Cam_Clinch_CF)
					else
						AI_Training_Cage_Clinch:Fire(Attacking_Char, Sequence_Keys, true)
					end
				end
			end
			task.spawn(Init_Attacking_Player)
			-- notify the defending player
			local function Init_Bad_Player()
				if Bad_Char ~= nil then
					local Bad_Plr = game.Players:GetPlayerFromCharacter(Bad_Char)
					if Bad_Plr ~= nil then
						Cage_Clinch_Start:FireClient(Bad_Plr, Sequence_Keys, false, Cam_Clinch_CF)
					else
						AI_Training_Cage_Clinch:Fire(Bad_Char, Sequence_Keys, false)
					end
				end
			end
			task.spawn(Init_Bad_Player)
			-- wait for the introduction animations
			wait(2.3)
			for i = 1, 5 do
				if Bar_Char_HRP ~= nil then
					Sound_Mod.PlaySFX(Bar_Char_HRP, "Punch_Hit_SE")
				end
				wait(1)
			end
		end
		Start_Client_Effects()
		-- handle stamina and health adjustments post sequence
		local function End_Sequence_Handle()
			local function Attacking_Char_Handle()
				if Attacking_Char ~= nil then
					local A_HRP = Attacking_Char:FindFirstChild("HumanoidRootPart")
					if A_HRP ~= nil then
						A_HRP.Anchored = false
					end
					if Fight_Char_1 ~= nil and Attacking_Char == Fight_Char_1 and C1_Stam_V ~= nil then
						C1_Stam_V.Value = math.clamp(C1_Stam_V.Value - 25, 0, 100)
					elseif Fight_Char_2 ~= nil and Attacking_Char == Fight_Char_2 and C2_Stam_V ~= nil then
						C2_Stam_V.Value = math.clamp(C2_Stam_V.Value - 25, 0, 100)
					end
				end
			end
			Attacking_Char_Handle()
			local function Bad_Char_Handle()
				if Bad_Char ~= nil then
					local B_HRP = Bad_Char:FindFirstChild("HumanoidRootPart")
					if B_HRP ~= nil then
						B_HRP.Anchored = false
					end
					if Fight_Char_1 ~= nil and Bad_Char == Fight_Char_1 and C1_Health_V ~= nil then
						C1_Health_V.Value -= 25
					elseif Fight_Char_2 ~= nil and Bad_Char == Fight_Char_2 and C2_Health_V ~= nil then
						C2_Health_V.Value -= 25
					end
				end
			end
			Bad_Char_Handle()
		end
		End_Sequence_Handle()
		wait(5)
	end
	-- evaluate whether the clinch sequence should trigger
	local function Detection_Result()
		if Prev_Round < Round_Count_V.Value and Fight_Char_1 ~= nil and Fight_Char_2 ~= nil and Submission_Char ~= nil and Submission_Char.Value == nil and Takedown_Track ~= nil and Takedown_Track.Value == false then
			-- test if a character is pressed against the cage
			local function Get_Attacking_Player()
				local function Is_Against_The_Cage(C_HRP, dist)
					local Dir = -1 * C_HRP.CFrame.LookVector * dist
					local Ray_Parms = RaycastParams.new()
					Ray_Parms.FilterDescendantsInstances = {Cage_Parts_M}
					Ray_Parms.FilterType = Enum.RaycastFilterType.Include
					Ray_Parms.IgnoreWater = true
					local Ray_Res = game.Workspace:Raycast(C_HRP.Position, Dir, Ray_Parms)
					if Ray_Res ~= nil and Ray_Res.Position ~= nil then
						return true, Ray_Res.Position
					end
					return false, nil
				end
				if C1_Health_V.Value <= Max_Opponent_Health and C1_HRP ~= nil and C2_Stam_V.Value >= Min_Stam_To_Tigger and C2_Health_V.Value > Min_Health_To_Trigger then
					local Is_Back_To_Cage, Pos = Is_Against_The_Cage(C1_HRP, Distance_To_Cage)
					if Is_Back_To_Cage == true and Pos ~= nil then
						return Fight_Char_2, Fight_Char_1, Pos
					end
				end
				if C2_Health_V.Value <= Max_Opponent_Health and C2_HRP ~= nil and C1_Stam_V.Value >= Min_Stam_To_Tigger and C1_Health_V.Value > Min_Health_To_Trigger then
					local Is_Back_To_Cage, Pos = Is_Against_The_Cage(C2_HRP, Distance_To_Cage)
					if Is_Back_To_Cage == true and Pos ~= nil then
						return Fight_Char_1, Fight_Char_2, Pos
					end
				end
				return nil, nil, nil
			end
			local Attacking_Player, Bad_Player, Cage_Pos = Get_Attacking_Player()
			if Attacking_Player ~= nil and Bad_Player ~= nil and Cage_Pos ~= nil then
				Against_The_Cage_Sequence(Attacking_Player, Bad_Player, Cage_Pos)
			end
		end
	end
	-- repeatedly check for clinch conditions while the fight is active
	if Fight_Params_Mod.CageClinch.Active then
		while Active_V ~= nil and Active_V.Value == true do
			Detection_Result()
			wait(1)
		end
	end
end

return Clinch_Sequence]]></ProtectedString>
							<string name="ScriptGuid">{DBF9E46B-7F6E-4969-8AF9-809152DBB85A}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Server_Clinch_Sequence.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX33C0E31CAD0D43DEBBD0082C4F5BA627">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Fight_Params_Mod = require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Submission_Minigame_Update = Channels.SC_Remote_Events.Submission_Minigame_Update
local AI_Training_Submission = Channels.Bindable_Events.AI_Training_Submission

local Submission_Params = Fight_Params_Mod.Submission_Minigame

local Submission_Minigame = {}

--[[
    Submission_Minigame

    This module contains the chokehold mini–game logic that is invoked
    whenever a takedown transitions the fight to the ground.  It
    faithfully reproduces the original `Submission_Handle` function
    from Core_Fight_Handle.server, but parameterises all references
    through the provided context table.  No behavioural changes have
    been made; the module simply organises the code into a reusable
    function.

    Functions:
      Submission_Handle(context, Submission_Plr)
        -- initiates and runs the chokehold mini–game for the
        -- submitting player

    The context table must include at least the following fields:
      Fight_Char_1, Fight_Char_2, C1_HRP, C2_HRP, C1_Health_V, C2_Health_V,
      C1_Stam_V, C2_Stam_V, Submission_Char, C1_Clicked_E, C2_Clicked_E,
      Submission_Minigame, Stats_Manager_Mod, 
      Is_Bot_Fight, Animation_Mod, Disconnect_Cons, Cons, and Monetization_Mod.

    It also requires the Toggle_Players_Damage_Bars and New_Animation_Handle
    helpers which are defined locally below to mirror their counterparts
    in the original script.
]]

-- enable or disable the damage UI on a fighter
local function Toggle_Players_Damage_Bars(Char, Is_Enabled)
	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	if Fight_UI ~= nil then
		Fight_UI.Enabled = Is_Enabled
	end
end

-- weld and reposition fighters for the chokehold mini–game
local function New_Animation_Handle(context, T_Char, R_Char, Submission_Plr)
	local destructor = function() end
	local T_HRP = T_Char:FindFirstChild("HumanoidRootPart")
	local R_HRP = R_Char:FindFirstChild("HumanoidRootPart")
	local function Assert_Check()
		return T_HRP ~= nil and R_HRP ~= nil and Submission_Plr.Character ~= nil
	end
	if Assert_Check() then
		local Takedown_Data, Submission_Data = context.Animation_Mod.Get_Takedown_Submission_Data(Submission_Plr.Character)
		local R_CF_Origin = R_HRP.CFrame
		T_HRP.CFrame = R_CF_Origin:ToWorldSpace(Takedown_Data['CF Offset'])
		local weld = Instance.new("Weld")
		weld.Part0 = R_HRP
		weld.Part1 = T_HRP
		weld.C0 = Takedown_Data['CF Offset']
		weld.Parent = R_HRP
		Toggle_Players_Damage_Bars(T_Char, false)
		Toggle_Players_Damage_Bars(R_Char, false)
		destructor = function()
			weld:Destroy()
		end
		task.spawn(function()
			task.wait(Takedown_Data['Time Length'] + 0.25)
			if Assert_Check() then
				T_HRP.CFrame = R_CF_Origin:ToWorldSpace(Submission_Data['CF Offset'])
				weld.C0 = Submission_Data['CF Offset']
			end
		end)
	end
	return destructor
end

-- primary entry point: run the submission mini–game for the given player
function Submission_Minigame.Submission_Handle(context, Submission_Plr)
	local WAIT_INTERVAL = 0.2
	local gameCounter = 0
	local games = {}
	local Cons = context.Cons
	local Disconnect_Cons = context.Disconnect_Cons
	local Stats_Manager_Mod = context.Stats_Manager_Mod
	local Is_Bot_Fight = context.Is_Bot_Fight
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2
	local C1_Health_V = context.C1_Health_V
	local C2_Health_V = context.C2_Health_V
	local C1_Stam_V = context.C1_Stam_V
	local C2_Stam_V = context.C2_Stam_V
	local Submission_Char = context.Submission_Char
	local C1_Clicked_E = context.C1_Clicked_E
	local C2_Clicked_E = context.C2_Clicked_E
	local C1_HRP = context.C1_HRP
	local C2_HRP = context.C2_HRP
	-- helper to fetch thumbnails for players
	local function FetchThumbnail(player)
		if player == nil then
			local BOT_DEFAULT_IMG = "rbxassetid://134663290660847"
			return BOT_DEFAULT_IMG
		end
		local userId = player.UserId
		local thumbType = Enum.ThumbnailType.HeadShot
		local thumbSize = Enum.ThumbnailSize.Size420x420
		local success, result = pcall(function()
			return game.Players:GetUserThumbnailAsync(userId, thumbType, thumbSize)
		end)
		if success then
			return result
		else
			warn("Thumbnail fetching for ", player.Name , " has failed, resulting to default")
			return "rbxthumb://type=AvatarHeadShot&id=1233225830&w=420&h=420"
		end
	end
	-- create and run a chokehold game between two characters
	local function StartChokehold(player1Char, player2Char)
		-- derive Player objects for characters if possible
		local player1 = game.Players:GetPlayerFromCharacter(player1Char)
		local player2 = game.Players:GetPlayerFromCharacter(player2Char)
		local thumbnail1 = FetchThumbnail(player1)
		local thumbnail2 = FetchThumbnail(player2)
		local myGame = {
			player1 = player1 or player1Char,
			player2 = player2 or player2Char,
			score = Submission_Params.Initial_Score,
			status = "Running",
			gameID = gameCounter,
			destructor = nil
		}
		-- update the game score based on which fighter clicks
		local function On_Click_Update(P_Char)
			if P_Char ~= nil then
				if P_Char == Fight_Char_1 then
					myGame.score -= 1
				end

				if P_Char == Fight_Char_2 then
					myGame.score += 1
				end
			end
			
			--print(P_Char.Name.." clicked		>> new score : "..myGame.score)
		end
		
		-- click rate varies depending on device and bot status
		local MIN_INTERVAL = 1/15
		local isBotFight = Is_Bot_Fight or player1 == nil or player2 == nil
		if not isBotFight then
			local Device_Atrib_p1 = player1:GetAttribute("Device")
			local Device_Atrib_p2 = player2:GetAttribute("Device")
			if Device_Atrib_p1 == "Mobile" and Device_Atrib_p2 == "Mobile" then
				MIN_INTERVAL = 1/20
			end
		end
		local lastClick2 = os.clock()
		local lastClick1 = os.clock()
		local C1_Con = C1_Clicked_E.OnServerEvent:Connect(function(player)
			if os.clock() - lastClick1 >= MIN_INTERVAL then
				On_Click_Update(player.Character)
				lastClick1 = os.clock()
			end
		end)
		local C2_Con = C2_Clicked_E.OnServerEvent:Connect(function(player)
			if os.clock() - lastClick2 >= MIN_INTERVAL then
				On_Click_Update(player.Character)
				lastClick2 = os.clock()
			end
		end)
		-- record connections for later cleanup
		table.insert(Cons, C1_Con)
		table.insert(Cons, C2_Con)
		local Choke_Cons = {}
		table.insert(Choke_Cons, C1_Con)
		table.insert(Choke_Cons, C2_Con)
		-- choose the receiving character based on who initiated the submission
		local function Get_R_Char()
			if Fight_Char_1 ~= nil and Submission_Char.Value == Fight_Char_1 then
				return Fight_Char_2
			else
				return Fight_Char_1
			end
		end
		local R_Char = Get_R_Char()
		-- weld fighters together for the submission animation
		local weldDestructor = New_Animation_Handle(context, Submission_Plr.Character, R_Char, Submission_Plr)
		myGame.destructor = weldDestructor
		-- optional AI clicking for bots
		local Bot_C = nil
		local function AI_Clicking_Handle(Bot_Char)
			if Submission_Plr.Character ~= nil then
				AI_Training_Submission:Fire(Bot_Char, Submission_Plr.Character, true)
			end
			Bot_C = Bot_Char
			
			local Minigame_Params = Fight_Params_Mod.Submission_Minigame
			local IsTutorialRunning = Submission_Plr:GetAttribute("IsTutorialRunning")
			local Click_Time_Delay = IsTutorialRunning and Minigame_Params.Coach_Bot_ClickDelay or Minigame_Params.Bot_ClickDelay
			while myGame.status == "Running" and Bot_Char ~= nil do
				On_Click_Update(Bot_Char)
				wait(Click_Time_Delay)
			end
		end
		
		-- initialise the UI for both players or bot
		if player1 ~= nil then
			Submission_Minigame_Update:FireClient(
				player1, 
				"START", 
				{
					imageIDs = {thumbnail1, thumbnail2}, 
					flip = true, 
					P1 = player1, 
					P2 = player2
				}, 
				C1_Clicked_E)
		elseif Is_Bot_Fight == true and player1 == nil and Fight_Char_1 ~= nil then
			task.spawn(AI_Clicking_Handle, Fight_Char_1)
		end
		
		
		if player2 ~= nil then
			Submission_Minigame_Update:FireClient(
				player2, 
				"START", 
				{
					imageIDs = {thumbnail1, thumbnail2}, 
					flip = false, 
					P1 = player1, 
					P2 = player2
				},
				C2_Clicked_E)
		elseif Is_Bot_Fight == true and player2 == nil and Fight_Char_2 ~= nil then
			task.spawn(AI_Clicking_Handle, Fight_Char_2)
		end
		-- core game loop: update the score and apply outcomes
		task.defer(function()
			while myGame.status == "Running" do
				task.wait(WAIT_INTERVAL)
				--print("----- Update Sumission Minigame -----")
				--print(myGame.score)
				--print(player1.Character)
				--print(player2.Character)
				if myGame.score >= Submission_Params.Winning_Score then
					myGame.status = "Ended"
					
					if player2 ~= nil and player2 == Submission_Plr then
						C1_Health_V.Value = -10
						Stats_Manager_Mod.Add_To_Player_Stats_Data(Submission_Plr, "Submissions Finished", 1)
						
					else
						if C2_Stam_V ~= nil then
							C2_Stam_V.Value = math.clamp(C2_Stam_V.Value * 0.65, 25, 100)
						end
						if C1_Stam_V ~= nil then
							C1_Stam_V.Value = math.clamp(C1_Stam_V.Value * 0.65, 25, 100)
						end
						if C1_Health_V ~= nil then
							C1_Health_V.Value = math.clamp(C1_Health_V.Value * 0.75, 25, 100)
						end
						Submission_Char.Value = nil
					end
					
					break
				elseif myGame.score <= Submission_Params.Loosing_Score then
					myGame.status = "Ended"
					
					if player1 ~= nil and player1 == Submission_Plr then
						C2_Health_V.Value = -10
						Stats_Manager_Mod.Add_To_Player_Stats_Data(Submission_Plr, "Submissions Finished", 1)
					else
						if C1_Stam_V ~= nil then
							C1_Stam_V.Value = math.clamp(C1_Stam_V.Value * 0.65, 25, 100)
						end
						if C2_Stam_V ~= nil then
							C2_Stam_V.Value = math.clamp(C2_Stam_V.Value * 0.65, 25, 100)
						end
						if C2_Health_V ~= nil then
							C2_Health_V.Value = math.clamp(C2_Health_V.Value * 0.75, 25, 100)
						end
						Submission_Char.Value = nil
					end
					break
				end
				if player1 ~= nil then
					C1_Clicked_E:FireClient(player1, {gameProgress = myGame.score})
				end
				if player2 ~= nil then
					C2_Clicked_E:FireClient(player2, {gameProgress = myGame.score})
				end
				
				if (player1 and player1.Character == nil) or (player2 and player2.Character == nil) then
					-- no winner
					myGame.status = "Ended"
				end
			end
			-- unwind weld and clean up after the game ends
			weldDestructor()
			local Old_Mid_Point = Submission_Char:FindFirstChild("Midpoint")
			if Old_Mid_Point ~= nil then
				Old_Mid_Point:Destroy()
			end
			if player1 ~= nil then
				Submission_Minigame_Update:FireClient(player1, "STOP")
			end
			if player2 ~= nil then
				Submission_Minigame_Update:FireClient(player2, "STOP")
			end
			myGame.status = "Ended"
			Disconnect_Cons(Choke_Cons)
			if Fight_Char_1 ~= nil then
				Toggle_Players_Damage_Bars(Fight_Char_1, true)
				if C1_HRP ~= nil then
					C1_HRP.Anchored = false
				end
			end
			if Fight_Char_2 ~= nil then
				Toggle_Players_Damage_Bars(Fight_Char_2, true)
				if C2_HRP ~= nil then
					C2_HRP.Anchored = false
				end
			end
			if Is_Bot_Fight and Bot_C ~= nil then
				AI_Training_Submission:Fire(Bot_C, nil, false)
			end
		end)
		games[gameCounter] = myGame
		gameCounter = gameCounter + 1
		return myGame
	end
	-- immediately start a chokehold for the submitting player against the opponent
	if Fight_Char_1 ~= nil and Fight_Char_2 ~= nil then
		StartChokehold(Fight_Char_1, Fight_Char_2)
	end
end

return Submission_Minigame]]></ProtectedString>
							<string name="ScriptGuid">{26774372-7F27-4ADA-9809-58EEF172CD26}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Server_Submission_Minigame.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX164C79558B3D459ABD52F75AF91B931D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Fight_Service/Fight_Spawn_Manager.server.lua
--
--  Description:
--      Central server-side handler responsible for all pre-fight logic:
--      player spawning into cages, slot assignment, UI states, bot
--      creation, invite notifications, ranked restrictions, and
--      auto-launching the fight when both slots are valid.
--
--      Core Responsibilities:
--          • Detect players entering cage spawn pads
--          • Populate Fight_Char_1 / Fight_Char_2 dynamically
--          • Render UI preview (rank, icon, display name, glow colors)
--          • Handle invite button injection / cleanup
--          • Validate ranked-match rules (Elo proximity)
--          • Automatically start fights via Start_Core_Fight
--          • Support bot fights (training, tutorial, No_Bots rules)
--          • Reset empty slots when players walk away
--          • Send invite notifications to all players
--          • Handle mini-tutorial state updates
--
--  Last Modified: 2025-09-30
--  Version: V2025-09
--
--  Dependencies:
--      ReplicatedStorage:
--          - Data_Mods_F:
--              Bots_Mod, Elo_Mod
--          - Modules:
--              Channels, Utils, PlayerUtils
--          - Design/ThemeManager
--
--      ServerStorage:
--          - TemplateUIs
--
--      Workspace:
--          - Main_World_F.Gameplay.Objects.Fight_Cages_F
--
--      Internal:
--          - Bots_Manager (child of this script)
--
--  Notes:
--      • This script handles ONLY the pre-fight and cage logic.
--      • The actual fight sequence is executed by Core_Fight_Handler.
--      • Bot behaviors rely on Bots_Mod profiles and Bots_Manager.
--======================================================================

----- MODULES -----
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Global_Params_Mod	= require(Data_Mods_F:WaitForChild("Global_Params_Mod"))
local Fight_Params_Mod 			= require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local Bots_Mod = require(Data_Mods_F:WaitForChild("Bots_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Cage_Factory = require(Data_Mods_F:WaitForChild("Cage_Factory"))
local Bots_Manager = require(script:WaitForChild("Bots_Manager"))
local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)
local Utils = require(game.ReplicatedStorage.Modules.Utils)
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

----- EVENTS -----
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Elo_Rank_Dif = Channels.SC_Remote_Events.Elo_Rank_Dif
local Start_Core_Fight = Channels.Bindable_Events.Start_Core_Fight
local Create_Training_Bot = Channels.CS_Remote_Functions.Create_Training_Bot
local Destroy_Training_Bot = Channels.CS_Remote_Functions.Destroy_Training_Bot
local Fight_Spawn_Notification = Channels.SC_Remote_Events.Fight_Spawn_Notification
local Send_Invite_Notification = Channels.CS_Remote_Functions.Send_Invite_Notification

----- ASSETS -----
local Invite_Buttons_UI = game.ServerStorage:WaitForChild("TemplateUIs"):WaitForChild("Invite_Buttons_UI")
local Player_Display_UI = game.ServerStorage:WaitForChild("TemplateUIs"):WaitForChild("Player_Display_UI")

local function Display_Player_UI_For_All(M)
	-- TO CHECK by Oriane
	
	--local Fight_M1 = M:WaitForChild("Fighter_1")
	--local Fight_M2 = M:WaitForChild("Fighter_2")
	--local Fighters_M = {Fight_M1, Fight_M2}
	--for _, Fight_M in pairs(ok) do
	--	local Main_P = Fight_M:WaitForChild("Main_P")
	--	local Display_UI = Main_P:WaitForChild("Player_Display_UI")
	--	Display_UI.PlayerToHideFrom = nil
	--end
	local Fight_M1 = M:WaitForChild("Fighter_1")
	local Fight_M2 = M:WaitForChild("Fighter_2")
	local Fighters_M = { Fight_M1, Fight_M2 }

	for _, Fight_M in pairs(Fighters_M) do
		local Main_P = Fight_M:WaitForChild("Main_P")

		-- Ensure Player_Display_UI exists (tutorial cages included)
		local Display_UI = Main_P:FindFirstChild("Player_Display_UI")
		if not Display_UI then
			Display_UI = Player_Display_UI:Clone()
			Display_UI.Adornee = Main_P
			Display_UI.Parent = Main_P
		end

		Display_UI.PlayerToHideFrom = nil
	end
end

local function Fight_Spawn_Handle(M)
	local Data_F = M:WaitForChild("Fight_Data_F")
	local Active_Fight_V = Data_F:WaitForChild("Active_Fight")
	local Fight_Char_1_V = Data_F:WaitForChild("Fight_Char_1")
	local Fight_Char_2_V = Data_F:WaitForChild("Fight_Char_2")
	local Fight_M1 = M:WaitForChild("Fighter_1")
	local Fight_M2 = M:WaitForChild("Fighter_2")
	local Is_Ranked_Fight = (M:GetAttribute("Cage_Type") or "") == "RANKED"

	local Occupied_Spawns = {

	}
	
	local function Reset_Spawn_M(FM, Char_V)
		local Main_P = FM:FindFirstChild("Main_P")
		local B1, B2 = Main_P:FindFirstChild("B1"), Main_P:FindFirstChild("B2")
		
		local Display_UI = Main_P:FindFirstChild("Player_Display_UI") or Player_Display_UI:Clone()
		Display_UI.Adornee = Main_P
		Display_UI.Parent = Main_P
	
		local Empty_Txt = Display_UI:FindFirstChild("Empty_Txt")
		local Player_F = Display_UI:FindFirstChild("Player_F")
		local Outline_P = FM:FindFirstChild("Outline_P")
		local Rot_P = FM:FindFirstChild("Rot_Part")
		local QueueGlow = FM:FindFirstChild("QueueGlow")
		local QueueNeon = FM:FindFirstChild("QueueNeon")

		Player_F.Visible = false
		Empty_Txt.Visible = true

		local Col_Seq = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Color3.fromRGB(248, 248, 248)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(248, 248, 248))
		}
		B1.Color = Col_Seq
		B2.Color = Col_Seq
		Rot_P.Color = Color3.fromRGB(248, 248, 248)
		Outline_P.Color = Color3.fromRGB(248, 248, 248)
		QueueGlow.Color = Color3.fromRGB(207, 172, 169)
		QueueNeon.Color = Color3.fromRGB(207, 172, 169)

		local Prev_Char = Char_V.Value
		if(Prev_Char ~= nil and game.Players:GetPlayerFromCharacter(Prev_Char) ~= nil)then
			--Remove the Player's Invite Buttons from Client
			local Prev_Plr = game.Players:GetPlayerFromCharacter(Prev_Char)
			local PG = Prev_Plr:FindFirstChild("PlayerGui")
			local Prev_Player_Invite_Buttons_UI = PG:WaitForChild("Fight"):FindFirstChild("Invite_Buttons_UI")
			if(PG ~= nil and Prev_Player_Invite_Buttons_UI ~= nil)then
				Prev_Player_Invite_Buttons_UI:Destroy()
			end
		end

		Display_UI.PlayerToHideFrom = nil
		Char_V.Value = nil
	end

	local function Verify_Hit_Part(hit)
		if(hit ~= nil and hit.Parent ~= nil and game.Players:GetPlayerFromCharacter(hit.Parent) ~= nil 
			and PlayerUtils.Is_Player_Fighting(hit.Parent) == false)then			
			return game.Players:GetPlayerFromCharacter(hit.Parent), hit.Parent
		end

		return nil, nil
	end
	
	local function Process_Fighter_Touch(FM, Char_V)
		
		Reset_Spawn_M(FM, Char_V)
		
		local Main_P = FM:WaitForChild("Main_P")
		local B1, B2 = Main_P:WaitForChild("B1"), Main_P:WaitForChild("B2")
		local Display_UI = Main_P:WaitForChild("Player_Display_UI")
		local Empty_Txt = Display_UI:WaitForChild("Empty_Txt")
		local Player_F = Display_UI:WaitForChild("Player_F")
		local Outline_P = FM:WaitForChild("Outline_P")
		local Rot_P = FM:WaitForChild("Rot_Part")
		local QueueGlow = FM:FindFirstChild("QueueGlow")
		local QueueNeon = FM:FindFirstChild("QueueNeon")
		local Touch_P = FM:WaitForChild("Touch_P")
		local Is_Ranked_Match = (M:GetAttribute("Cage_Type") or "") == "RANKED"
		local Debounce_H = false
		local Debounce_Elo_Dif = false

		local function New_Fighter_Added(Plr, Char)
			if(Plr ~= nil and Char ~= nil)then
				Empty_Txt.Visible = false

				local colorHex = ThemeManager.getPath("cages.PlayerSpawnGlowColor.Color")
				local Select_Col = colorHex and Color3.fromHex(colorHex) or Color3.new(1, 1, 1)

				if(Is_Ranked_Match ~= nil and Is_Ranked_Match)then
					Select_Col = Color3.new(1, 0, 0)
				end

				local Col_Seq = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Select_Col),
					ColorSequenceKeypoint.new(1, Select_Col)
				}
				B1.Color = Col_Seq
				B2.Color = Col_Seq
				Rot_P.Color = Select_Col
				Outline_P.Color = Select_Col
				QueueGlow.Color = Select_Col
				QueueNeon.Color = Select_Col

				local function Update_Player_Data_F()
					local Rank_Data, Elo_Amount = Elo_Mod.Get_Player_Rank_Data(Plr)
					local Rank_F = Player_F:FindFirstChild("Rank_F")
					local Rank_Img = Rank_F:FindFirstChild("Rank_Img")
					local Rank_Txt = Rank_F:FindFirstChild("Rank_Txt")
					local Rank_Col = Rank_Data['Color'] or Color3.fromRGB(170, 170, 127)
					local Plr_Icon = PlayerUtils.Get_Player_Image(Plr.UserId)
					Rank_Img.Image = Rank_Data['Icon'] or "rbxassetid://89194867048049"
					Rank_Img.ImageColor3 = Rank_Col
					Rank_Txt.Text = Utils.Format_Number(Elo_Amount) .. ""
					Rank_Txt.TextColor3 = Rank_Col
					Rank_F.Visible = true

					Player_F:FindFirstChild("Player_Name").Text = Plr.Name
					Player_F:FindFirstChild("Display_Name").Text = "@" .. Plr.DisplayName
					Player_F:FindFirstChild("Icon_F"):FindFirstChild("Player_Img").Image = Plr_Icon

					Display_UI.PlayerToHideFrom = Plr
					Player_F.Visible = true	

					return {
						['Name'] = Plr.Name, 
						['Rank Icon'] = Rank_Img.Image,
						['Rank Color'] = Rank_Col,
						['Rank Value'] = Rank_Txt.Text,
						['Player Icon'] = Plr_Icon,

						['Main_Char_V'] = Char_V,
						['Char_V1'] = Fight_Char_1_V,
						['Char_V2'] = Fight_Char_2_V,
						['Active_V'] = Active_Fight_V
					}
				end
				Update_Player_Data_F()

				local function Add_Player_Invite_Buttons()
					local PG = Plr:FindFirstChild("PlayerGui")
					local New_Player_Invite_Buttons_UI = PG:WaitForChild("Fight"):FindFirstChild("Invite_Buttons_UI")

					if(PG ~= nil)then
						if New_Player_Invite_Buttons_UI ~= nil then
							New_Player_Invite_Buttons_UI:Destroy()
						end
						local New_Invite_Buttons = Invite_Buttons_UI:Clone()
						New_Invite_Buttons:WaitForChild("Cage_M").Value = M
						New_Invite_Buttons:WaitForChild("No_Bots").Value = M:GetAttribute("No_Bots")
						New_Invite_Buttons.Adornee = Main_P
						New_Invite_Buttons.Parent = PG:WaitForChild("Fight")						
					end
				end
				Add_Player_Invite_Buttons()

				Char_V.Value = Char

				--If both Char Values are filled ~ Start the Fight
				--> Else, tell the whole server that the 2nd Fight Slot is vacant

				Occupied_Spawns[FM] = {
					['Model'] = FM,
					['Char_V'] = Char_V,
					['Main Char'] = Char,
					['Touch_P'] = Touch_P,
					['Active_V'] = Active_Fight_V
				}

				local function Process_Ranked_Match_Check(C1, C2)
					if(Is_Ranked_Fight ~= nil and Is_Ranked_Fight == true)then
						local P_C1 = game.Players:GetPlayerFromCharacter(C1)
						local P_C2 = game.Players:GetPlayerFromCharacter(C2)

						if(P_C1 ~= nil and P_C2 ~= nil)then
							if not Elo_Mod.Adjacent_Elo_Ranks(P_C1, P_C2) then 
								if(Debounce_Elo_Dif == false)then
									task.spawn(function()
										Debounce_Elo_Dif = true
										Elo_Rank_Dif:FireClient(P_C1, P_C2)
										Elo_Rank_Dif:FireClient(P_C2, P_C1)
										task.wait(3)
										Debounce_Elo_Dif = false
									end)
								end
								return false
							else 
								return true
							end
						end
					end

					return true
				end

				if(Fight_Char_1_V.Value ~= nil and Fight_Char_2_V.Value ~= nil and 
					Fight_Char_1_V.Value ~= Fight_Char_2_V.Value and Active_Fight_V.Value == false)then

					if(Process_Ranked_Match_Check(Fight_Char_1_V.Value, Fight_Char_2_V.Value))then
						M:SetAttribute("Bot_Fight", false)
						Start_Core_Fight:Fire(M, Fight_Char_1_V.Value, Fight_Char_2_V.Value)
						Display_Player_UI_For_All(M)
					end
				end
			else
				Reset_Spawn_M(FM, Char_V)
			end
		end

		Touch_P.Touched:Connect(function(hit)
			if hit.Name ~= "HumanoidRootPart" then
				return
			end

			if(Active_Fight_V.Value == false and Debounce_H == false and Char_V.Value == nil and 
				hit ~= nil and hit.Parent ~= nil)then
				Debounce_H = true

				local Plr, Char = Verify_Hit_Part(hit)
				if(Plr ~= nil and Char ~= nil and Fight_Char_1_V.Value ~= Char 
					and Fight_Char_2_V.Value ~= Char)then

					New_Fighter_Added(Plr, Char)
					task.wait(0.25)
				end
				Debounce_H = false
			end
		end)
	end
	Process_Fighter_Touch(Fight_M1, Fight_Char_1_V)
	Process_Fighter_Touch(Fight_M2, Fight_Char_2_V)

	local function Check_Removal()	
		local function Delete_Old_Fight_Teleports()
			local All_P = game.Players:GetPlayers()

			for i = 1, #All_P do
				local P = All_P[i]
				if(P ~= nil and P:FindFirstChild("PlayerGui") ~= nil)then
					local PG = P:FindFirstChild("PlayerGui")					
					local Invite_Buttons_UI = PG:WaitForChild("Fight"):FindFirstChild("Invite_Buttons_UI")
					if(Invite_Buttons_UI ~= nil and Invite_Buttons_UI:FindFirstChild("Cage_M").Value.Name == M.Name)then
						Invite_Buttons_UI:Destroy()
					end
				end
			end
		end
		
		local function Switch_To_Empty_Label()
			local Fighters = {Fight_M1, Fight_M2}
			for _,FM in pairs(Fighters) do
				local Main_P = FM:FindFirstChild("Main_P")
				local Display_UI = Main_P:FindFirstChild("Player_Display_UI")
				if Display_UI then
					local Empty_Txt = Display_UI:FindFirstChild("Empty_Txt")
					local Player_F = Display_UI:FindFirstChild("Player_F")
					Empty_Txt.Visible = true
					Player_F.Visible = false
				end
			end
		end
		
		Active_Fight_V.Changed:Connect(function()
			if(Active_Fight_V.Value == false)then
				Delete_Old_Fight_Teleports()
				Switch_To_Empty_Label()
			end
		end)

		local function Should_Reset_Occupied_Slot()
			local function Check_Char_In_Region(Char, Touch_P)
				local Overlap_P = OverlapParams.new()
				Overlap_P.FilterType = Enum.RaycastFilterType.Include
				Overlap_P.FilterDescendantsInstances = {Char}
				Overlap_P.MaxParts = 50

				local Region_Data = game.Workspace:GetPartsInPart(Touch_P, Overlap_P)
				if(Region_Data ~= nil and #Region_Data > 0)then
					return true
				end

				return false
			end

			for FM, Data in next, Occupied_Spawns do
				local Active_V = Data['Active_V']
				if(Active_V ~= nil and Active_V.Value == false)then
					--Check the Distance or if the HRP is nil
					local Char_V = Data['Char_V']
					local Touch_P = Data['Touch_P']
					local Main_Char = Data['Main Char']

					if(Char_V ~= nil and Touch_P ~= nil and (Main_Char ~= nil and 
						Check_Char_In_Region(Main_Char, Touch_P) == false) or Main_Char == nil)then

						--Reset, not in Region
						Reset_Spawn_M(FM, Char_V)

						--Remove from Occupied
						Occupied_Spawns[FM] = nil
					end
				end
			end
		end

		while task.wait(0.1) do
			--Handle Resetting Slots of the Player jumps offs
			Should_Reset_Occupied_Slot()
		end
	end
	task.spawn(Check_Removal)
end


--======================================================================
--  Called remotely by the client (via the "Bot Fight" button) to
--  request spawning of a training bot inside the specified cage.
--
--  Parameters:
--      cageName (string) : The name of the fight cage where the player requested a bot.
--      botProfile (string) : The type of bot to spawn (e.g., "NORMAL", "COACH").
--
--  Behavior:
--      1. Locates the cage model in the workspace.
--      2. Determines which fighter slot (Fight_Char_1 or Fight_Char_2)
--         is vacant and can receive a bot.
--      3. Calls Bots_Manager.SpawnBotInCage() to instantiate the bot.
--      4. Validates that both characters are now present in the cage.
--      5. Fires Start_Core_Fight to begin the fight between the player
--         and the bot.
--
--  Returns:
--      (bool, string?)
--          true if the bot was created successfully.
--          false and an error message otherwise.
--======================================================================
local function Update_Player_Display_For_Bot(Cage_M, bot)
	local fightData = Cage_M:WaitForChild("Fight_Data_F") 
	local char1 = fightData:WaitForChild("Fight_Char_1").Value
	local char2 = fightData:WaitForChild("Fight_Char_2").Value
	
	local Fighter_Model = nil
	if bot == char1 then
		Fighter_Model = Cage_M:WaitForChild("Fighter_1")
	elseif bot == char2 then
		Fighter_Model = Cage_M:WaitForChild("Fighter_2")
	end
	
	if Fighter_Model ~= nil then
	
		local Main_P = Fighter_Model:FindFirstChild("Main_P")
		local Display_UI = Main_P:FindFirstChild("Player_Display_UI") or Player_Display_UI:Clone()
		Display_UI.Adornee = Main_P
		Display_UI.Parent = Main_P
		local Empty_Txt = Display_UI:WaitForChild("Empty_Txt")
		local Player_F = Display_UI:WaitForChild("Player_F")
		local Rank_F = Player_F:FindFirstChild("Rank_F")
		
		Player_F:FindFirstChild("Player_Name").Text = bot:GetAttribute("Display_Name")
		Player_F:FindFirstChild("Display_Name").Text = "@BOT" 
		Player_F:FindFirstChild("Icon_F"):FindFirstChild("Player_Img").Image = "rbxassetid://134663290660847"
		Rank_F.Visible = false
		
		Display_UI.PlayerToHideFrom = nil
		Player_F.Visible = true	
		Empty_Txt.Visible = false
	end
end

Create_Training_Bot.OnServerInvoke = function(player, cageType, cageName, botProfile)
	local res = {
		success = false, 
		err = "",
		cageName = cageName
	}
	
	local cageModel = nil
	
	if cageType == Fight_Params_Mod.CageType.STANDARD then
		cageModel = workspace.Main_World_F.Gameplay.Objects.Fight_Cages_F:FindFirstChild(cageName)
		if not cageModel then 
			res.err = "Invalid cage name" 
			return res
		end
		if cageModel:GetAttribute("No_Bots") then
			res.err = "No bots cage"
			return res
		end
		
	elseif cageType == Fight_Params_Mod.CageType.TUTORIAL then
		cageModel = Cage_Factory:CreateCage(cageType)
		cageModel:SetAttribute("Cage_Type", "TUTORIAL")
		local char1 = cageModel:WaitForChild("Fight_Data_F"):WaitForChild("Fight_Char_1")
		char1.Value = player.Character
		res.cageName = cageModel.Name
		player:SetAttribute("IsTutorialRunning", true)
		
	elseif cageType == Fight_Params_Mod.CageType.LEAGUE then		
		-- TODO
		-- dont forget to add Attribute Cage_Type = 	
		--CageType = {
		--STANDARD = "STANDARD",
		--RANKED   = "RANKED",
		--TUTORIAL = "TUTORIAL",
		--LEAGUE   = "LEAGUE"
		--},
	else
		-- TODO
	end
	
	-- Create bot in the cage 
	if not botProfile then
		botProfile = Bots_Mod.profiles.COACH
	end

	local bot = Bots_Manager.SpawnBotInCage(player, cageModel, botProfile)
	if not bot then res.err = "Bot spawn failed" return res end

	-- Check Fight data before Starting Fight
	local fightData = cageModel:WaitForChild("Fight_Data_F")
	local char1 = fightData:WaitForChild("Fight_Char_1").Value
	local char2 = fightData:WaitForChild("Fight_Char_2").Value
	if not (char1 and char2) then res.err = "Fight not ready" return res end

	Start_Core_Fight:Fire(cageModel, char1, char2)
	Display_Player_UI_For_All(cageModel)
	
	-- Add bot data in Player_Display_UI
	Update_Player_Display_For_Bot(cageModel, bot)
	
	res.success = true
	return res
end

Destroy_Training_Bot.OnServerInvoke = function(player, cageName)
	local bot =workspace.Main_World_F.Gameplay.Objects.Bots:FindFirstChild(cageName.."_Bot")
	if bot then
		bot:Destroy()
		return true
	end
	return false
end

--======================================================================
--  Called remotely by the client (via the "Send Invite" button) to
--  invite every player of the room to fight.
--
--  Parameters:
--      cageName (string)
--          The name of the fight cage where the player requested an invite to
--          fight.
-- 		Plr (Player)
--			The inviting Player 
--
--  Behavior:
--      1. Locates the cage model in the workspace.
--      2. Check if the player can invite someone to this cage if ranked
--      3. Prepare invitation Data to send
-- 		4. Send the invite to All other player in the room
--======================================================================
local function Get_Invitation_Data(Cage, Plr)
	local Inviting_Char = Plr.Character
	-- Cage Infos
	local Fight_Data = Cage:WaitForChild("Fight_Data_F")
	local Active_Fight_V = Fight_Data:WaitForChild("Active_Fight")
	local Fight_Char_1_V = Fight_Data:WaitForChild("Fight_Char_1")
	local Fight_Char_2_V = Fight_Data:WaitForChild("Fight_Char_2")

	local Fight_M1 = Cage:WaitForChild("Fighter_1")
	local Fight_M2 = Cage:WaitForChild("Fighter_2")

	local Main_Char_V = nil
	local Spawn_Location = nil
	if Inviting_Char == Fight_Char_1_V.Value then
		Main_Char_V = Fight_Char_1_V
		Spawn_Location = Fight_M2:FindFirstChild("Player_Spawn_P").CFrame

	elseif Inviting_Char == Fight_Char_2_V.Value then
		Main_Char_V = Fight_Char_2_V
		Spawn_Location = Fight_M1:FindFirstChild("Player_Spawn_P").CFrame
	end

	-- Player Info
	local Rank_Data, Elo_Amount = Elo_Mod.Get_Player_Rank_Data(Plr)
	local Rank_Col = Rank_Data['Color'] or Color3.fromRGB(170, 170, 127)
	local Plr_Icon = PlayerUtils.Get_Player_Image(Plr.UserId)
	
	local Is_Ranked_Fight = (Cage:GetAttribute("Cage_Type") or "") == "RANKED"

	return {
		['Name'] = Plr.Name, 
		['Rank Icon'] = Rank_Data['Icon'] or "rbxassetid://89194867048049",
		['Rank Color'] = Rank_Col,
		['Rank Value'] = Utils.Format_Number(Elo_Amount) .. "",
		['Player Icon'] = Plr_Icon,

		['Main_Char_V'] = Main_Char_V,
		['Spawn_Location'] = Spawn_Location,
		['Active_V'] = Active_Fight_V,
		['Ranked_Fight'] = Is_Ranked_Fight,
	}
end

Send_Invite_Notification.OnServerInvoke = function(Plr, cageName)

	local cagesFolder = workspace.Main_World_F.Gameplay.Objects.Fight_Cages_F
	local cageModel = cagesFolder:FindFirstChild(cageName)
	if not cageModel then
		return false, "Invalid cage reference"
	end

	local Is_Ranked_Fight = (cageModel:GetAttribute("Cage_Type") or "") == "RANKED"
	
	local Total_Wins_V = PlayerUtils.GetPlayerVal(Plr, "Total Wins")
	if(Is_Ranked_Fight ~= nil and Is_Ranked_Fight == true and Total_Wins_V ~= nil and 
		Total_Wins_V.Value < Fight_Params_Mod.Ranked_Arena_Required_Wins)then
		return false, "Player cannot start a fight in a Ranked Cage"
	end

	local Invitation_Data = Get_Invitation_Data(cageModel, Plr)
	if Invitation_Data == nil then
		return false, "Invited player is not in cage anymore"
	else
		Fight_Spawn_Notification:FireAllClients(Plr, Invitation_Data)
		return true
	end
end

------ INITIALISATION 
function Init_Fight_Spawn_Handles()
	-- Init Spawn location for cages only in Standard mode
	local GameMode = Utils.GetServerGameMode()
	if GameMode ~= Global_Params_Mod.Server_Mode.STANDARD and GameMode ~= "" then return end
	
	task.wait(1)
	local cageFolder = Cage_Factory:getCageFolder(Fight_Params_Mod.CageType.STANDARD)
	local All_M = cageFolder:GetChildren()
	for i = 1, #All_M do
		if(All_M[i] ~= nil)then
			Fight_Spawn_Handle(All_M[i])
		end
	end
end
Init_Fight_Spawn_Handles()
]]></ProtectedString>
						<string name="ScriptGuid">{4C2F4D0D-C9B8-4896-B38C-A8490882D9EB}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_Assignment_Handle.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXC6D64767531A467E98A3B0DE034593AF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_Assignment_Handle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX426A9CFA5DA14FAD94E930AFF863F6BB">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  Module: Bots_Manager
--
--  Description:
--      Handles spawning and configuration of training bots for fights.
--      Uses Bots_Mod for per-cage configuration (template + difficulty).
--
--  Usage:
--      local Bots_Manager = require(script:WaitForChild("Bots_Manager"))
--      Receiving_RF.Create_Training_Bot.OnServerInvoke = function(plr)
--          return Bots_Manager.CreateTrainingBot(plr)
--      end
--======================================================================
local RS 				= game:GetService("ReplicatedStorage")
local Bots_Mod 			= require(game.ReplicatedStorage.Data_Mods_F.Bots_Mod)
local Fight_Params_Mod 	= require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)

local Bots_Manager = {}

--======================================================================
--  Creates and configures a training bot for the given cage.
--  This function is responsible for:
--     - selecting the correct bot profile (NORMAL, COACH, etc.)
--     - cloning the corresponding bot template
--     - setting its attributes (DisplayName, Behavior)
--     - attaching it to the cage slot (Fight_Char_1 / Fight_Char_2)
--     - dynamically injecting the correct behavior module
--
--  Parameters:
--      cageModel (Model)
--          The cage model in which the bot will be spawned.
--
--      vacantCharValue (ObjectValue)
--          The ObjectValue (Fight_Char_1 or Fight_Char_2) representing
--          the empty slot that should receive the bot.
--
--  Behavior:
--      - Reads the cage’s configured profile from Bots_Mod.
--      - Clones the bot template from ServerStorage/Training_Bots.
--      - Assigns bot metadata and marks the cage as a "Bot Fight".
--      - Loads and runs the corresponding AI behavior (NORMAL, COACH).
--
--  Returns:
--      bot (Model)
--          The newly spawned bot instance ready for the fight.
--      nil
--          If any step fails (missing template, invalid profile, etc.)
--======================================================================

local function getVacantSlot(cageModel)
	local data = cageModel:WaitForChild("Fight_Data_F")
	local char1 = data:WaitForChild("Fight_Char_1")
	local char2 = data:WaitForChild("Fight_Char_2")

	if char1.Value == nil then return char1 end
	if char2.Value == nil then return char2 end
	return nil
end

function Bots_Manager.SpawnBotInCage(player, cageModel, botProfile)
	local vacantCharValue = getVacantSlot(cageModel)
	if not vacantCharValue then
		warn("[Bots_Manager] No vacant slot available")
		return nil
	end
	
	----------------------------------------------------------------
	-- Load bot configuration
	----------------------------------------------------------------
	local cageName = cageModel.Name
	local profile = nil
	
	if botProfile then
		profile = botProfile
	else
		profile = Bots_Mod.getProfileForCage(cageName)
		if not profile then
			warn("[Bots_Manager] Missing profile for cage:", cageName)
			return nil
		end
	end

	----------------------------------------------------------------
	-- Clone bot template
	----------------------------------------------------------------
	local templateFolder = Bots_Mod.getBotsTemplateFolder()
	local template = templateFolder:FindFirstChild(profile.Template)
	if not template then
		warn("[Bots_Manager] Bot template not found:", profile.Template)
		return nil
	end

	local bot = template:Clone()
	local displayName = profile.DisplayName or "Bot"
	bot.Name = cageName .. "_Bot"
	bot.Parent = Bots_Mod.getBotsWorkspaceFolder()

	----------------------------------------------------------------
	-- Apply attributes (metadata)
	----------------------------------------------------------------
	bot:SetAttribute("Display_Name", displayName)
	bot:SetAttribute("IsBot", true)
	bot:SetAttribute("UserId", -1)
	bot:SetAttribute("Behavior", profile.Behavior or "NORMAL")

	
	local playerVal = Instance.new("IntValue")
	playerVal.Name = "_PLAYER_VALUE_"
	playerVal.Value = -1 -- bots n’ont pas de vrai UserId
	playerVal.Parent = bot

	-- Optionnel : ajouter un dossier Fight_Data si inexistant
	if not bot:FindFirstChild("Fight_Data") then
		local fightData = Instance.new("Folder")
		fightData.Name = "Fight_Data"

		local health = Instance.new("IntValue")
		health.Name = "Health"
		health.Value = Fight_Params_Mod.Health.Max_Value
		health.Parent = fightData

		local stamina = Instance.new("IntValue")
		stamina.Name = "Staminia"
		stamina.Value = Fight_Params_Mod.Stamina.Max_Value
		stamina.Parent = fightData

		local block = Instance.new("IntValue")
		block.Name = "Block Power"
		block.Value = Fight_Params_Mod.Block_Power.Max_Value
		block.Parent = fightData

		local strike = Instance.new("IntValue")
		strike.Name = "Strike Power"
		strike.Value = Fight_Params_Mod.Punch_Power.Max_Value
		strike.Parent = fightData

		fightData.Parent = bot
	end
	
	
	vacantCharValue.Value = bot
	
	cageModel:SetAttribute("Bot_Fight", true)

	----------------------------------------------------------------
	-- Inject the bot behavior module dynamically
	----------------------------------------------------------------
	task.spawn(function()		
		local behaviorModuleName = string.upper(profile.Behavior)
		local behaviorModulePath = RS:WaitForChild("Data_Mods_F"):WaitForChild("Bot_Behaviors")
		local behaviorModule = behaviorModulePath:FindFirstChild(behaviorModuleName)

		if not behaviorModule then
			warn("[Bots_Manager] Behavior module not found:", behaviorModuleName)
			return
		end

		local behavior = require(behaviorModule)
		local ai = behavior.new()
		ai:Init(player, bot)
	end)

	return bot
end

return Bots_Manager]]></ProtectedString>
							<string name="ScriptGuid">{C5581300-485D-4C6C-8D9F-8488F84A3383}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Bots_Manager.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX3F0E136655144F4596228D961948FA38">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Modules</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX66A7948DFD4E4A09B319E591D99D615B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Security/Exploit_Logger.lua
--
--  Description:
--      Lightweight server-side module for reporting suspicious or
--      exploit-related activity to a Discord webhook. Provides a
--      simple Log(player, category, details) API producing structured
--      embed messages.
--
--      Features:
--          • Async webhook posting (non-blocking)
--          • JSON encoded payload (Discord embed)
--          • Automatic player identity formatting
--          • Safe error-handling via pcall
--
--  Last Modified: 2025-09-30
--  Version: V2025-09
--
--  Dependencies:
--      Services:
--          - HttpService
--
--  Configuration:
--      • Set WEBHOOK_URL to your Discord webhook before use.
--
--  Notes:
--      • Intended to be required by server-only code.
--      • Logging silently fails if the webhook is unavailable.
--======================================================================

local HttpService = game:GetService("HttpService")
local Exploit_Logger = {}
local WEBHOOK_URL = "https://discord.com/api/webhooks/1442964977316270273/xBDgrJG8Vq3rL7b-Dz1xxRf2XVtaO6Ykwdh0XVaxBpdQWHyMAdxBSdeuYEvdQidn75JF"

local function SendWebhook(data)
	if not WEBHOOK_URL or WEBHOOK_URL == "" then
		warn("[Exploit_Logger] No webhook URL configured.")
		return
	end

	task.spawn(function()
		local jsonData = HttpService:JSONEncode(data)

		local success, err = pcall(function()
			HttpService:PostAsync(WEBHOOK_URL, jsonData, Enum.HttpContentType.ApplicationJson)
		end)

		if not success then
			warn("[Exploit_Logger] Failed to send log:", err)
		end
	end)
end

function Exploit_Logger.Log(player, category, details)
	SendWebhook({
		["username"] = "Anti-Exploit Bot",
		["embeds"] = {{
			["title"] = "🚨 Exploit Detected",
			["color"] = 16711680,
			["fields"] = {
				{
					["name"] = "Player",
					["value"] = string.format("**%s** (%s)", player.Name, player.UserId),
					["inline"] = false
				},
				{
					["name"] = "Type",
					["value"] = category,
					["inline"] = false
				},
				{
					["name"] = "Details",
					["value"] = details or "N/A",
					["inline"] = false
				}
			},
			["timestamp"] = DateTime.now():ToIsoDate()
		}}
	})
end

return Exploit_Logger]]></ProtectedString>
						<string name="ScriptGuid">{92273E00-D0A3-498D-B8C7-DECAF272E278}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Exploit_Logger.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX91C1129CAD6B47339983B1F4C9F88E0C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Modules/GAModule.lua
--
--  Description:
--      Wrapper module for GameAnalytics integration.
--      Handles initialization and business event logging for purchases.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * GameAnalytics (module)
--      - Roblox Services:
--          * Players (used indirectly through function parameters)
--
--  Notes:
--      - Initializes GameAnalytics server SDK with game keys
--      - Disables verbose/info logs on startup
--      - Logs Robux purchase events with Creator Codes
--      - Contains hardcoded secrets (⚠ should be secured properly)
--
--======================================================================

local GAModule = {}

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local GameAnalytics = require(game.ReplicatedStorage.Modules.GameAnalytics)

function GAModule:CreatorSupported(player:Player, creatorId: string, robuxAmount: number)
	if not creatorId or not robuxAmount then
		warn("Missing creatorId or robuxAmount for GA log.")
		return
	end

	GameAnalytics:addBusinessEvent(
		player.UserId,
		{
			currency = "Robux",
			amount = robuxAmount,
			itemType = "DevProduct",
			itemId = "WithCreatorCode",
			cartType = tostring(creatorId)
		}
	)
end

local function SafeGetSecret(name: string)
	-- Only Roblox Cloud environments expose HttpService:GetSecret()
	if HttpService.GetSecret and not RunService:IsStudio() then
		local ok, value = pcall(function()
			return HttpService:GetSecret(name)
		end)
		if ok and value and value ~= "" then
			return value
		end
	end
	return nil
end

function GAModule:Init()
	GameAnalytics:setEnabledInfoLog(false)
	GameAnalytics:setEnabledVerboseLog(false)
	
	-- Try to load keys securely
	local key = SafeGetSecret("GameAnalyticsKey") or "acf2fbabbd9612a55e53d758fa5f8184"
	local secret = SafeGetSecret("GameAnalyticsSecret") or "108c93f6570a18f37d56abda957bbb2c1a8bfb2e"
	
	if key and secret then
		GameAnalytics:initServer(key, secret) 
	end
end

GAModule:Init()

return GAModule
]]></ProtectedString>
						<string name="ScriptGuid">{94C97774-F0BD-49DA-B09F-7B445C9BDE1D}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GAModule.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9D2923DD9B9644B1B364966662AEF0E0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Modules/GlobalLeaderBoards.lua
--
--  Description:
--      Manages global player leaderboards using OrderedDataStores.
--      Supports multiple competitive scopes (Weekly, Monthly, All-Time)
--      via time-based datastore keys (no destructive resets).
--
--      - Weekly leaderboards are the default and drive short-term competition
--      - Monthly leaderboards reward consistency
--      - All-Time leaderboards provide long-term prestige
--
--      Nation Elo is handled separately on a yearly basis and represents
--      a global, historical aggregation (not seasonal or competitive).
--
--      The module:
--      - Collects and serializes player stats
--      - Writes to OrderedDataStores through a queued system (anti-throttling)
--      - Periodically refreshes in-world leaderboard UIs with cooldowns
--      - Caches player thumbnails and user info for performance
--      - Emits events when Top 3 players change
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-12-21 by Darkzeb
--
--  Version: V2025-12
--
--  Leaderboard Scopes:
--      - Weekly   : "_W_YYYY_WW" (Sunday-based week number, os.date %U)
--      - Monthly  : "_M_YYYY_MM"
--      - All-Time : "_A"
--
--  Nation Elo:
--      - Stored per year (e.g. "Natio_Elo_2026")
--      - Legacy store "Natio_Elo2" used for year 2025
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Gameplay/Objects/Leaderboards
--      - ReplicatedStorage:
--          * Data_Mods_F/Country_Mod
--          * Modules/Utils
--          * Modules/Channels
--          * Channels/SC_Remote_Events/Top3_Players_Updated
--      - Roblox Services:
--          * Players
--          * UserService
--          * DataStoreService
--
--  Notes:
--      - Uses OrderedDataStore for ranked leaderboards
--      - Uses a custom DataStoreQueue to prevent throttling
--      - Wraps all DataStore operations in pcall for resilience
--      - UI refreshes are rate-limited per leaderboard
--      - Player thumbnails use HeadShot (180x180)
--
--======================================================================

local module = {
	NationElos = {},
	TopPlayers = { -1, -1, -1 }
}

local Top3Initialized 			= false

-- Services
local Players 					= game:GetService("Players")
local UserService 				= game:GetService("UserService")
local DataStoreService 			= game:GetService("DataStoreService")

-- Modules
local Data_Mod_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Country_Mod 				= require(Data_Mod_F:WaitForChild("Country_Mod"))
local Utils						= require(game.ReplicatedStorage.Modules.Utils)

-- Events
local Channels 					= require(game.ReplicatedStorage.Modules.Channels)
local Top3_Players_Updated 		= Channels.SC_Remote_Events.Top3_Players_Updated
local LeaderboardModeChanged 	= Channels.CS_Remote_Events.Leaderboard_Mode_Changed

-- Workspace References
local Main_World_F 				= game.Workspace:WaitForChild("Main_World_F")
local Objects 					= Main_World_F:WaitForChild("Gameplay"):WaitForChild("Objects")
local Leaderboards_F 			= Objects:WaitForChild("Leaderboards")


local DEFAULT_COUNTRY 			= "United States"
local THUMBNAIL_TYPE 			= Enum.ThumbnailType.HeadShot
local THUMBNAIL_SIZE 			= Enum.ThumbnailSize.Size180x180

local LEADERBOARD_MODE 			= {
	Weekly = "Weekly",
	Monthly = "Monthly",
	AllTime = "AllTime"
}

local DEFAULT_MODE 				= LEADERBOARD_MODE.Weekly
local CurrentMode 				= DEFAULT_MODE

local LeaderboarKeys = {
	Elo = "Best Elo",
	Wins = "Total Wins",
	WinStreak = "Win Streak",
	Knockouts = "Knockouts",
	Submissions = "Submissions Wins",
	GymTraining = "Gym Training",
	RankedWins = "Ranked Wins",
	PunchScore = "Punch Score",
}

local LAST_LB_REFRESH = {}
local LB_REFRESH_COOLDOWN = 60 -- seconds


-- Get the current key depending on the mode (Weekly/Monthly/Alltime)
local function GetLeaderboardKey(mode)
	local now = os.date("*t")

	if mode == LEADERBOARD_MODE.Weekly then
		return "_W_" .. os.date("%Y_%W")
	elseif mode == LEADERBOARD_MODE.Monthly then
		return "_M_" .. now.year .. "_" .. string.format("%02d", now.month)
	elseif mode == LEADERBOARD_MODE.AllTime then
		-- Legacy All-Time handling
		if now.year == 2025 then
			return "_2"
		else
			return "_A"
		end
	else 
		warn("Unknown mode: " .. tostring(mode))
	end
end

local function BuildLeaderboardStores(mode)
	local key = GetLeaderboardKey(mode)
	local stores = {}

	for i, v in pairs(LeaderboarKeys) do
		stores[i] = DataStoreService:GetOrderedDataStore(v .. key)
	end

	return stores, key
end

local LeaderboarStores, LeaderboardKey = BuildLeaderboardStores(CurrentMode)

local function BuildWriteStores()
	local stores = {
		Weekly = {},
		Monthly = {},
		AllTime = {},
	}

	for scope, mode in pairs({
		Weekly = LEADERBOARD_MODE.Weekly,
		Monthly = LEADERBOARD_MODE.Monthly,
		AllTime = LEADERBOARD_MODE.AllTime,
		}) do
		local key = GetLeaderboardKey(mode)
		for k, v in pairs(LeaderboarKeys) do
			stores[scope][k] = DataStoreService:GetOrderedDataStore(v .. key)
		end
	end

	return stores
end

-- ============================================================
-- Write stores (always written, mode-independent)
-- ============================================================
WriteStores = BuildWriteStores()

-- Nation elo are handled on a yearly  basis
local CURRENT_NATION_ELO_YEAR = tonumber(os.date("%Y"))
local nationStoreName

if CURRENT_NATION_ELO_YEAR == 2025 then
	nationStoreName = "Natio_Elo2" -- legacy store used until end of 2025
else
	nationStoreName = "Natio_Elo_" .. tostring(CURRENT_NATION_ELO_YEAR)
end

local NationEloStore = DataStoreService:GetDataStore(nationStoreName)
local NationEloKey = "_KEYS_"
local NationEloData = {}

local Player_Info_Data = {}
local Player_Thumbnail_Data = {}
local LastPlayerValues = {}

-- ============================================================
-- DataStore Queue System
-- ============================================================
local DataStoreQueue = {}
DataStoreQueue.Queue = {}
DataStoreQueue.Busy = false

function DataStoreQueue:Add(store, key, value, mode, callback)
	table.insert(self.Queue, {
		store = store,
		key = key,
		value = value,
		mode = mode,
		callback = callback
	})
end

function DataStoreQueue:Process(onFinished)
	if self.Busy then return end
	self.Busy = true
	task.spawn(function()
		while #self.Queue > 0 do
			local req = table.remove(self.Queue, 1)
			local success, err
			if req.mode == "set" then
				success, err = pcall(function()
					req.store:SetAsync(req.key, req.value)
				end)
			elseif req.mode == "update" then
				success, err = pcall(function()
					req.store:UpdateAsync(req.key, req.value)
				end)
			end
			if not success then
				warn("DataStoreQueue error:", err)
				table.insert(self.Queue, req)
				task.wait(2)
			elseif req.callback then
				req.callback()
			end
			task.wait(0.1)
		end
		self.Busy = false
		if onFinished then
			onFinished()
		end
	end)
end

-- ============================================================
-- Player thumbnails and info
-- ============================================================
local function Get_Player_Thumbnail(ID)
	if Player_Thumbnail_Data[ID] then
		return Player_Thumbnail_Data[ID]
	end
	for _ = 1, 3 do
		local success, data = pcall(function()
			return Players:GetUserThumbnailAsync(ID, THUMBNAIL_TYPE, THUMBNAIL_SIZE)
		end)
		if success and data then
			Player_Thumbnail_Data[ID] = data
			return data
		end
		task.wait(1)
	end
	return "rbxassetid://100127687172105"
end

local function Get_Player_Info_Data(ID)
	if Player_Info_Data[ID] then
		return Player_Info_Data[ID]
	end
	for _ = 1, 3 do
		local success, data = pcall(function()
			return UserService:GetUserInfosByUserIdsAsync({tonumber(ID)})
		end)
		if success and data and data[1] and data[1].Username then
			local entry = {
				Username = data[1].Username,
				DisplayName = data[1].DisplayName
			}
			Player_Info_Data[ID] = entry
			return entry
		end
		task.wait(1)
	end
	return { Username = "PlayerName", DisplayName = "Player" }
end

-- ============================================================
-- Utils
-- ============================================================
local function SerializeDataAndCountry(data: number, country: string)
	local countryId = Country_Mod.Get_Country_Number_From_Index(country)
	data = math.round(data)
	return tonumber(tostring(data) .. string.format("%04d", countryId))
end

local function DeserializeDataAndCountry(serialized: number)
	local str = tostring(serialized)
	local dataPart = 0
	if #str >= 5 then dataPart = tonumber(string.sub(str, 1, #str - 4)) end
	local countryId = tonumber(string.sub(str, -4))
	return math.round(dataPart), countryId
end


local function UpdateTop3AllTime()
	local store = WriteStores.AllTime.Wins
	if not store then return end

	local success, pages = pcall(function()
		return store:GetSortedAsync(false, 3)
	end)
	if not success or not pages then return end

	local page = pages:GetCurrentPage()
	if not page or #page == 0 then
		return
	end

	local newTop = { -1, -1, -1 }

	for rank = 1, math.min(3, #page) do
		newTop[rank] = tonumber(page[rank].key) or -1
	end

	local changed = false
	for i = 1, 3 do
		if module.TopPlayers[i] ~= newTop[i] then
			changed = true
			break
		end
	end

	if changed or not Top3Initialized then
		Top3Initialized = true
		module.TopPlayers = newTop
		Top3_Players_Updated:FireAllClients(newTop)
	end
end



-- ============================================================
-- Update leaderboards display
-- ============================================================
local function Update_All_Leaderboard_Displays()
	local function Get_LB_UI_Data(Key)
		
		local LB_M = Leaderboards_F:FindFirstChild(Key)
		if LB_M and LB_M.PrimaryPart and LB_M.PrimaryPart:FindFirstChildWhichIsA("SurfaceGui") then
			local Main_UI = LB_M.PrimaryPart:FindFirstChildWhichIsA("SurfaceGui")
			local Main_Data_F = Main_UI:FindFirstChild("Main_Data_F")
			if Main_Data_F and Main_Data_F:FindFirstChild("Tabs_F") and Main_Data_F:FindFirstChild("Tab_TMP") then
				Main_Data_F.CanvasPosition = Vector2.new(0, 0)
				return Main_Data_F:FindFirstChild("Tabs_F"), Main_Data_F:FindFirstChild("Tab_TMP")
			end
		end
		return nil, nil
	end

	local function Update_Leaderboard_Display(Key, Data)
		local Y_Pos = 0.0875
		local Tabs_F, Tab_TMP = Get_LB_UI_Data(Key)
		if Tabs_F and Tab_TMP then
			Tabs_F:ClearAllChildren()
			local UIList = Instance.new("UIListLayout")
			UIList.Parent = Tabs_F
			UIList.Padding = UDim.new(0.02, 0)
			UIList.SortOrder = Enum.SortOrder.LayoutOrder

			local function Create_New_Tab(Rank, Data)
				local ID = Data['ID'] or -1
				local Sort_Val = Data['Sort Val'] or 0
				local Country = Data['Country'] or "USA"

				local Tab = Tab_TMP:Clone()
				local Plr_Img = Tab:WaitForChild("Plr_Img")
				local Rank_Txt = Tab:WaitForChild("Rank_Txt")
				local P_Name_Txt = Tab:WaitForChild("P_Name_Txt")
				local P_DisplayName_Txt = Tab:WaitForChild("P_DisplayName_Txt")
				local P_Data_Val = Tab:WaitForChild("P_Data_Val")
				Tab.Parent = Tabs_F
				Tab.Position = UDim2.new(0.5, 0, Y_Pos, 0)
				Tab.Name = "Tab_" .. Rank
				Tab.LayoutOrder = Rank

				Tab:WaitForChild("Country_Img").Image = Country_Mod.Get_Flag_ID(Country)
				P_Data_Val.Text = Utils.NumToString(Sort_Val)
				if Key == "Gym Training" then
					P_Data_Val.Text = Utils.Time_Conversion(Sort_Val)
				end
				P_Data_Val.TextXAlignment = Enum.TextXAlignment.Center

				if Key == "Nation Elo" then
					Plr_Img.Visible = false
					Rank_Txt.Visible = true
					Rank_Txt.Text = "#" .. Rank
					P_DisplayName_Txt.Text = "Country"
					P_Name_Txt.Text = Country
				else
					if Rank <= 3 then
						Plr_Img.Image = Get_Player_Thumbnail(ID)
						Rank_Txt.Visible = false
						Plr_Img.Visible = true
					else
						Rank_Txt.Text = "#" .. Rank
						Rank_Txt.Visible = true
						Plr_Img.Visible = false
					end
					local Plr_Info_Data = Get_Player_Info_Data(ID)
					P_Name_Txt.Text = Plr_Info_Data.DisplayName or "Player Name"
					P_DisplayName_Txt.Text = "@" .. (Plr_Info_Data.Username or "Player")
				end

				Y_Pos += 0.175
				Tab.Visible = true
			end

			for i = 1, #Data do
				Create_New_Tab(i, Data[i])
			end
		end
	end

	local function tryGetData(leaderboardStore: OrderedDataStore)
		local success, data = pcall(function()
			return leaderboardStore:GetSortedAsync(false, 100)
		end)
		if success then return data else warn("Could not get leaderboard pages", data) end
	end

	local function tryGetPage(pages: DataStorePages)
		local success, page = pcall(function()
			return pages:GetCurrentPage()
		end)
		if success then return page else warn("Could not get page") end
	end

	for leaderboardType, leaderboardStore in pairs(LeaderboarStores) do

		local lbKey = LeaderboarKeys[leaderboardType]
		
		if not lbKey then continue end
		
		-- UI refresh cooldown per leaderboard
		local now = os.clock()
		if LAST_LB_REFRESH[leaderboardType] and now - LAST_LB_REFRESH[leaderboardType] < LB_REFRESH_COOLDOWN then
			continue
		end
		LAST_LB_REFRESH[leaderboardType] = now
		
		local leaderboardPages = tryGetData(leaderboardStore)
		if not leaderboardPages then continue end
		local currentPage = tryGetPage(leaderboardPages)
		if not currentPage then continue end

		local finalValues = {}
		for _, data in currentPage do
			local playerKey, playerValue = data.key, data.value
			if playerKey and playerValue then
				local score, countryId = DeserializeDataAndCountry(playerValue)
				local countryName = Country_Mod.Get_Country_Index_From_Number(countryId) or DEFAULT_COUNTRY
				table.insert(finalValues, {["Sort Val"] = score, Country = countryName, ID = playerKey})
			end
		end
		table.sort(finalValues, function(a, b) return a["Sort Val"] > b["Sort Val"] end)

		Update_Leaderboard_Display(lbKey, finalValues)
	end

	local finalValues = {}
	for i, v in pairs(NationEloData) do
		finalValues[#finalValues + 1] = {["Sort Val"] = v, Country = i, ID = 1}
	end
	table.sort(finalValues, function(a, b) return a["Sort Val"] > b["Sort Val"] end)
	Update_Leaderboard_Display("Nation Elo", finalValues)
end

-- ============================================================
-- Nation Elo
-- ============================================================
function module:ProcessNationElo()
	local entries = {}
	for _, v in pairs(module.NationElos) do
		entries[v[1]] = (entries[v[1]] or 0) + v[2]
	end
	for _ = 1, 5 do
		local success, err = pcall(function()
			NationEloStore:UpdateAsync(NationEloKey, function(data)
				data = data or {}
				for i in Country_Mod.Get_Country_Data() do
					if not data[i] then data[i] = 0 end
				end
				for i, v in pairs(entries) do
					if data[i] then data[i] += v end
				end
				NationEloData = data
				return data
			end)
		end)
		if success then break else warn(err) task.wait(1) end
	end
end

function module:RegisterNationElo(countryIndex: string, eloCount: number)
	if not countryIndex or not Country_Mod.Get_Country_Data()[countryIndex] then
		error(`Invalid Country Index {countryIndex}`)
	end
	if not eloCount or typeof(eloCount) ~= "number" then
		error(`Invalid Elo {eloCount}`)
	end
	table.insert(module.NationElos, {countryIndex, eloCount})
end

function module:_ClearNationElo()
	module.NationElos = {}
end

game:BindToClose(function()
	module:ProcessNationElo()
	module:_ClearNationElo()
end)

local function RunDataStoreLoop()
	WriteStores = BuildWriteStores()
	
	module:ProcessNationElo()
	module:_ClearNationElo()

	for _, plr in ipairs(Players:GetPlayers()) do
		local key = plr.UserId
		
		-- Skip test players / invalid UserIds (Studio only)
		if typeof(key) ~= "number" or key <= 0 then
			continue
		end
		
		local player_Data = plr:FindFirstChild("Player_Data")
		if player_Data and player_Data:FindFirstChild("Country") then	
			local countryId = player_Data["Country"].Value
			local updates = {
				{"Wins", "Total Wins"},
				{"Elo", "Elo"},
				{"Knockouts", "Leg Knockout Wins", "Punch Knockout Wins"},
				{"GymTraining", "Gym Training"},
				{"Submissions", "Submissions Wins"},
				{"RankedWins", "Ranked Wins"},
				
				{"PunchScore", "Punch Score"},
			}

			--for _, entry in ipairs(updates) do
				--local store, stat1, stat2 = entry[1], entry[2], entry[3]
			for _, entry in ipairs(updates) do
				
				
				if entry[2] == "Punch Score" then
					local v = player_Data:FindFirstChild("Punch Score")
					if not v then
						v = Instance.new("IntValue")
						v.Name = "Punch Score"
						v.Value = 0
						v.Parent = player_Data
					end
				end

				
				local lbKey, stat1, stat2 = entry[1], entry[2], entry[3]
				local val = player_Data[stat1].Value
				if stat2 then val += player_Data[stat2].Value end

				-- OrderedDataStore: ignore zero values
				if val <= 0 then
					continue
				end
				
				local serialized = SerializeDataAndCountry(val, countryId)

				if LastPlayerValues[key .. lbKey] ~= serialized then
					LastPlayerValues[key .. lbKey] = serialized

					-- write to ALL scopes
					for _, scopeStores in pairs(WriteStores) do
						local store = scopeStores[lbKey]
						if store then
							DataStoreQueue:Add(store, key, serialized, "set")
						end
					end
				end
	
			end

			for _, scopeStores in pairs(WriteStores) do
				local store = scopeStores.WinStreak
				if store then
					DataStoreQueue:Add(
						store,
						key,
						function(old)
							local oldScore = 0
							if old then oldScore = DeserializeDataAndCountry(old) end
							return SerializeDataAndCountry(
								math.max(oldScore, player_Data["Win Streak"].Value),
								countryId
							)
						end,
						"update"
					)
				end
			end
		end
	end
	
	DataStoreQueue:Process(function()
		UpdateTop3AllTime()
	end)
	
	for cacheKey in pairs(LastPlayerValues) do
		local userId = tonumber(cacheKey:match("^(%d+)"))
		if userId and not Players:GetPlayerByUserId(userId) then
			LastPlayerValues[cacheKey] = nil
		end
	end
	
	task.delay(120 + math.random() * 30, RunDataStoreLoop)
end
task.defer(RunDataStoreLoop)

local function RunUILoop()
	Update_All_Leaderboard_Displays()
	task.delay(30, RunUILoop)
end

task.defer(RunUILoop)

LeaderboardModeChanged.OnServerEvent:Connect(function(player, newMode)
	if not player or not player:IsDescendantOf(Players) then
		return
	end
	
	if not LEADERBOARD_MODE[newMode] then
		warn("Invalid leaderboard mode: " .. tostring(newMode))
		return
	end

	if CurrentMode == newMode then
		return
	end

	CurrentMode = newMode
	LeaderboarStores, LeaderboardKey = BuildLeaderboardStores(CurrentMode)

	-- force UI refresh
	LAST_LB_REFRESH = {}

	Update_All_Leaderboard_Displays()

	--print("[GlobalLeaderBoards] Mode switched to:", newMode)
end)


Players.PlayerAdded:Connect(function(player)
	Top3_Players_Updated:FireClient(player, module.TopPlayers)
end)

return module]]></ProtectedString>
						<string name="ScriptGuid">{BEF27FE2-ABFB-473D-B18B-C867D9068DAD}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GlobalLeaderBoards.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB720B3D171B74065A571C2CBA165F58A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Modules/Codes_Unique.lua
--
--  Description:
--      Contains a static list of one-time unique codes and associated rewards.
--      Used by Unique_Codes_Handle.lua for code redemption validation.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ServerScriptService/Unique_Codes_Handle.lua
--
--  Notes:
--      - Codes are stored as { Code = "...", Reward = "..." }
--      - Referenced by 
--      - Includes multiple reward tiers (e.g., LargediamondsPack, HugeMoneyPack)
--
--======================================================================


local module = {
	[1] = { Code = "0F4AA7QH", Reward = "LargediamondsPack" },
	[2] = { Code = "0HKYWSP8", Reward = "LargediamondsPack" },
	[3] = { Code = "10IZX44L", Reward = "LargediamondsPack" },
	[4] = { Code = "14GN6X52", Reward = "LargediamondsPack" },
	[5] = { Code = "15UT4E3Z", Reward = "LargediamondsPack" },
	[6] = { Code = "19913MO4", Reward = "LargediamondsPack" },
	[7] = { Code = "1BNUVK7F", Reward = "LargediamondsPack" },
	[8] = { Code = "1C2U1RLN", Reward = "LargediamondsPack" },
	[9] = { Code = "1KRDOF81", Reward = "LargediamondsPack" },
	[10] = { Code = "1M10ZJZP", Reward = "LargediamondsPack" },
	[11] = { Code = "1QSWL6VL", Reward = "LargediamondsPack" },
	[12] = { Code = "1SX2XT0B", Reward = "LargediamondsPack" },
	[13] = { Code = "1WZ655T9", Reward = "LargediamondsPack" },
	[14] = { Code = "20R8HC0Y", Reward = "LargediamondsPack" },
	[15] = { Code = "2KXHOT67", Reward = "LargediamondsPack" },
	[16] = { Code = "2NDJ5X2Y", Reward = "LargediamondsPack" },
	[17] = { Code = "2NQT277O", Reward = "LargediamondsPack" },
	[18] = { Code = "2P19PY2A", Reward = "LargediamondsPack" },
	[19] = { Code = "2ZFYZXRM", Reward = "LargediamondsPack" },
	[20] = { Code = "3CXNXNU1", Reward = "LargediamondsPack" },
	[21] = { Code = "3UBMQZTV", Reward = "LargediamondsPack" },
	[22] = { Code = "3X8Z3Z4K", Reward = "LargediamondsPack" },
	[23] = { Code = "3XYU6H8Y", Reward = "LargediamondsPack" },
	[24] = { Code = "439W6RGZ", Reward = "LargediamondsPack" },
	[25] = { Code = "48JMAB7T", Reward = "LargediamondsPack" },
	[26] = { Code = "4KW3OAJW", Reward = "LargediamondsPack" },
	[27] = { Code = "4OU7J8DA", Reward = "LargediamondsPack" },
	[28] = { Code = "501AZUM9", Reward = "LargediamondsPack" },
	[29] = { Code = "558ZPVB5", Reward = "LargediamondsPack" },
	[30] = { Code = "5KZBMKTH", Reward = "LargediamondsPack" },
	[31] = { Code = "5UNQFNRJ", Reward = "LargediamondsPack" },
	[32] = { Code = "5URZ9ZYB", Reward = "LargediamondsPack" },
	[33] = { Code = "5YW22ETQ", Reward = "LargediamondsPack" },
	[34] = { Code = "5Z7N0JDV", Reward = "LargediamondsPack" },
	[35] = { Code = "60S4ANMM", Reward = "LargediamondsPack" },
	[36] = { Code = "61TI1NOA", Reward = "LargediamondsPack" },
	[37] = { Code = "62X05UA0", Reward = "LargediamondsPack" },
	[38] = { Code = "6K1VDR98", Reward = "LargediamondsPack" },
	[39] = { Code = "6Z8HT6GY", Reward = "LargediamondsPack" },
	[40] = { Code = "7CBC4PEM", Reward = "LargediamondsPack" },
	[41] = { Code = "7CLGYJVG", Reward = "LargediamondsPack" },
	[42] = { Code = "7DISFT94", Reward = "LargediamondsPack" },
	[43] = { Code = "7E77HGYF", Reward = "LargediamondsPack" },
	[44] = { Code = "7KBQE13T", Reward = "LargediamondsPack" },
	[45] = { Code = "83C5IK6X", Reward = "LargediamondsPack" },
	[46] = { Code = "8BTB895M", Reward = "LargediamondsPack" },
	[47] = { Code = "8OO3JRS8", Reward = "LargediamondsPack" },
	[48] = { Code = "8UHZ7DJJ", Reward = "LargediamondsPack" },
	[49] = { Code = "8VAT7N9S", Reward = "LargediamondsPack" },
	[50] = { Code = "8WNNHFNH", Reward = "LargediamondsPack" },
	[51] = { Code = "8XG2UAEB", Reward = "HugeMoneyPack" },
	[52] = { Code = "97SOH11Q", Reward = "HugeMoneyPack" },
	[53] = { Code = "9D5IS95K", Reward = "HugeMoneyPack" },
	[54] = { Code = "9FHE5UQ0", Reward = "HugeMoneyPack" },
	[55] = { Code = "9KI14Z3K", Reward = "HugeMoneyPack" },
	[56] = { Code = "9NL4KFHW", Reward = "HugeMoneyPack" },
	[57] = { Code = "9UPTYD0D", Reward = "HugeMoneyPack" },
	[58] = { Code = "A9REG5P5", Reward = "HugeMoneyPack" },
	[59] = { Code = "ABI9E1ZX", Reward = "HugeMoneyPack" },
	[60] = { Code = "B32J2CF1", Reward = "HugeMoneyPack" },
	[61] = { Code = "BCFAM7CY", Reward = "HugeMoneyPack" },
	[62] = { Code = "BEN0HJZE", Reward = "HugeMoneyPack" },
	[63] = { Code = "BISF3AP6", Reward = "HugeMoneyPack" },
	[64] = { Code = "BJT67NX4", Reward = "HugeMoneyPack" },
	[65] = { Code = "BLS4SV10", Reward = "HugeMoneyPack" },
	[66] = { Code = "BNUCD9P5", Reward = "HugeMoneyPack" },
	[67] = { Code = "BPQ18UV6", Reward = "HugeMoneyPack" },
	[68] = { Code = "BXXAIZVZ", Reward = "HugeMoneyPack" },
	[69] = { Code = "C39CESVQ", Reward = "HugeMoneyPack" },
	[70] = { Code = "C6MRCELC", Reward = "HugeMoneyPack" },
	[71] = { Code = "CBX6NGHM", Reward = "HugeMoneyPack" },
	[72] = { Code = "CESP2Y9G", Reward = "HugeMoneyPack" },
	[73] = { Code = "CLZ4WKKS", Reward = "HugeMoneyPack" },
	[74] = { Code = "CZMCBMUT", Reward = "HugeMoneyPack" },
	[75] = { Code = "D1HQGIVK", Reward = "HugeMoneyPack" },
	[76] = { Code = "D2R9HWU5", Reward = "HugeMoneyPack" },
	[77] = { Code = "D5WUIDLT", Reward = "HugeMoneyPack" },
	[78] = { Code = "D6AXGQA6", Reward = "HugeMoneyPack" },
	[79] = { Code = "D9GRWTMP", Reward = "HugeMoneyPack" },
	[80] = { Code = "DEL8JP7S", Reward = "HugeMoneyPack" },
	[81] = { Code = "E4IC5E9Q", Reward = "HugeMoneyPack" },
	[82] = { Code = "E4UCF9NN", Reward = "HugeMoneyPack" },
	[83] = { Code = "EI2IRGNC", Reward = "HugeMoneyPack" },
	[84] = { Code = "EIMW91OJ", Reward = "HugeMoneyPack" },
	[85] = { Code = "EJLXZ3YK", Reward = "HugeMoneyPack" },
	[86] = { Code = "ELS9BZFW", Reward = "HugeMoneyPack" },
	[87] = { Code = "ENVZQ2L4", Reward = "HugeMoneyPack" },
	[88] = { Code = "F483ND4N", Reward = "HugeMoneyPack" },
	[89] = { Code = "F8DGP7A2", Reward = "HugeMoneyPack" },
	[90] = { Code = "FW1NR7Y8", Reward = "HugeMoneyPack" },
	[91] = { Code = "G1LJIZMD", Reward = "HugeMoneyPack" },
	[92] = { Code = "G7DNO6SH", Reward = "HugeMoneyPack" },
	[93] = { Code = "GCNET6FQ", Reward = "HugeMoneyPack" },
	[94] = { Code = "GEXLW8H6", Reward = "HugeMoneyPack" },
	[95] = { Code = "GG6OO722", Reward = "HugeMoneyPack" },
	[96] = { Code = "GO7JN55V", Reward = "HugeMoneyPack" },
	[97] = { Code = "GOX4DJJ6", Reward = "HugeMoneyPack" },
	[98] = { Code = "GSGWHS1Y", Reward = "HugeMoneyPack" },
	[99] = { Code = "GUIWQY3D", Reward = "HugeMoneyPack" },
	[100] = { Code = "GUR2DBGA", Reward = "HugeMoneyPack" },
	[101] = { Code = "HN0ORKU6", Reward = "VIP" },
	[102] = { Code = "HUKUZG4W", Reward = "VIP" },
	[103] = { Code = "I6DC05DZ", Reward = "VIP" },
	[104] = { Code = "IJXCWQR7", Reward = "VIP" },
	[105] = { Code = "IK20LRQJ", Reward = "VIP" },
	[106] = { Code = "IO3I638K", Reward = "VIP" },
	[107] = { Code = "ISC3QNEV", Reward = "VIP" },
	[108] = { Code = "J6AZ1DBA", Reward = "VIP" },
	[109] = { Code = "JCHVHFU6", Reward = "VIP" },
	[110] = { Code = "JEZ0RRGT", Reward = "VIP" },
	[111] = { Code = "JGTQ289T", Reward = "VIP" },
	[112] = { Code = "JHDNSMCY", Reward = "VIP" },
	[113] = { Code = "JLA0ZLLK", Reward = "VIP" },
	[114] = { Code = "JWPLUJQU", Reward = "VIP" },
	[115] = { Code = "KAMBCNKU", Reward = "VIP" },
	[116] = { Code = "KDOLBVY9", Reward = "VIP" },
	[117] = { Code = "KG0XLM7H", Reward = "VIP" },
	[118] = { Code = "KUAEPF43", Reward = "VIP" },
	[119] = { Code = "KZDR7M6P", Reward = "VIP" },
	[120] = { Code = "L65PVTC6", Reward = "VIP" },
	[121] = { Code = "L8WNRB3X", Reward = "VIP" },
	[122] = { Code = "L92W30LG", Reward = "VIP" },
	[123] = { Code = "LL2U23RZ", Reward = "VIP" },
	[124] = { Code = "M3WE3SJA", Reward = "VIP" },
	[125] = { Code = "M9AUXMUK", Reward = "VIP" },
	[126] = { Code = "MBXLA7HO", Reward = "VIP" },
	[127] = { Code = "MI4RY2NU", Reward = "VIP" },
	[128] = { Code = "MJQP6P2Q", Reward = "VIP" },
	[129] = { Code = "MM8DJY4F", Reward = "VIP" },
	[130] = { Code = "MTTVWRZB", Reward = "VIP" },
	[131] = { Code = "MZV8TM0L", Reward = "VIP" },
	[132] = { Code = "N00V9RW5", Reward = "VIP" },
	[133] = { Code = "N1AZZT33", Reward = "VIP" },
	[134] = { Code = "N50DSEZ5", Reward = "VIP" },
	[135] = { Code = "NK8G3SYJ", Reward = "VIP" },
	[136] = { Code = "NKMENE1T", Reward = "VIP" },
	[137] = { Code = "NMFSXPUE", Reward = "VIP" },
	[138] = { Code = "NNQ2Z7AM", Reward = "VIP" },
	[139] = { Code = "NSE40IB6", Reward = "VIP" },
	[140] = { Code = "NWLL7JR2", Reward = "VIP" },
	[141] = { Code = "OEPW0FJN", Reward = "VIP" },
	[142] = { Code = "OMTHR179", Reward = "VIP" },
	[143] = { Code = "OZ64Q44N", Reward = "VIP" },
	[144] = { Code = "P2KV2XQD", Reward = "VIP" },
	[145] = { Code = "P3GSMKG4", Reward = "VIP" },
	[146] = { Code = "PCGX5IGZ", Reward = "VIP" },
	[147] = { Code = "PHXXAJ24", Reward = "VIP" },
	[148] = { Code = "Q6926TK4", Reward = "VIP" },
	[149] = { Code = "Q8DWMJP3", Reward = "VIP" },
	[150] = { Code = "QEEVIM6I", Reward = "VIP" },
	[151] = { Code = "QIPH9CDC", Reward = "2xCash" },
	[152] = { Code = "QV3TA3XW", Reward = "2xCash" },
	[153] = { Code = "R4ZRV0G7", Reward = "2xCash" },
	[154] = { Code = "ROYACZQP", Reward = "2xCash" },
	[155] = { Code = "RXQTR3PF", Reward = "2xCash" },
	[156] = { Code = "RZHKP3VU", Reward = "2xCash" },
	[157] = { Code = "S0HN2Q71", Reward = "2xCash" },
	[158] = { Code = "S4SX17ZW", Reward = "2xCash" },
	[159] = { Code = "S7WENIJ0", Reward = "2xCash" },
	[160] = { Code = "SERAD7DM", Reward = "2xCash" },
	[161] = { Code = "TNBMLWWI", Reward = "2xCash" },
	[162] = { Code = "TUFTJEFV", Reward = "2xCash" },
	[163] = { Code = "TVWFDAN2", Reward = "2xCash" },
	[164] = { Code = "TXU3HWWQ", Reward = "2xCash" },
	[165] = { Code = "TYOFWCLR", Reward = "2xCash" },
	[166] = { Code = "U3O0748S", Reward = "2xCash" },
	[167] = { Code = "U8Q6GCEL", Reward = "2xCash" },
	[168] = { Code = "URXJNJ20", Reward = "2xCash" },
	[169] = { Code = "VCFB0AY3", Reward = "2xCash" },
	[170] = { Code = "VECCLQZI", Reward = "2xCash" },
	[171] = { Code = "VGDDDCZ5", Reward = "2xCash" },
	[172] = { Code = "VOT6PV9H", Reward = "2xCash" },
	[173] = { Code = "VWI6J4GP", Reward = "2xCash" },
	[174] = { Code = "W5G7WRK1", Reward = "2xCash" },
	[175] = { Code = "W67HTAI0", Reward = "2xCash" },
	[176] = { Code = "WJE2L2AH", Reward = "2xCash" },
	[177] = { Code = "WNHGGXV6", Reward = "2xCash" },
	[178] = { Code = "X1TX6ML2", Reward = "2xCash" },
	[179] = { Code = "X2AV6CMJ", Reward = "2xCash" },
	[180] = { Code = "X6CXG5N3", Reward = "2xCash" },
	[181] = { Code = "X8O4T9WZ", Reward = "2xCash" },
	[182] = { Code = "XAA9X32H", Reward = "2xCash" },
	[183] = { Code = "XFLOVDT6", Reward = "2xCash" },
	[184] = { Code = "XIA3MHHW", Reward = "2xCash" },
	[185] = { Code = "XPJXNJTP", Reward = "2xCash" },
	[186] = { Code = "XR8C5UP5", Reward = "2xCash" },
	[187] = { Code = "XTT1WSWW", Reward = "2xCash" },
	[188] = { Code = "XV42E9FY", Reward = "2xCash" },
	[189] = { Code = "XWRH3238", Reward = "2xCash" },
	[190] = { Code = "Y6KB215X", Reward = "2xCash" },
	[191] = { Code = "Y97K6RSD", Reward = "2xCash" },
	[192] = { Code = "Y9WZ853N", Reward = "2xCash" },
	[193] = { Code = "YX3L9RI7", Reward = "2xCash" },
	[194] = { Code = "Z2MKCG7I", Reward = "2xCash" },
	[195] = { Code = "Z2PB5XLR", Reward = "2xCash" },
	[196] = { Code = "ZBQK5OCX", Reward = "2xCash" },
	[197] = { Code = "ZK4HTGHR", Reward = "2xCash" },
	[198] = { Code = "ZLLMN82A", Reward = "2xCash" },
	[199] = { Code = "ZNDD0LEH", Reward = "2xCash" },
	[200] = { Code = "ZRE97OI4", Reward = "2xCash" },
	

	[201] = { Code = "S8CNP5LB", Reward = "LargediamondsPack" },
	[202] = { Code = "3XJSEW6B", Reward = "LargediamondsPack" },
	[203] = { Code = "QLSOODMH", Reward = "LargediamondsPack" },
	[204] = { Code = "XL035IAI", Reward = "LargediamondsPack" },
	[205] = { Code = "PDGV1BTL", Reward = "LargediamondsPack" },
	[206] = { Code = "DH4SS86R", Reward = "LargediamondsPack" },
	[207] = { Code = "7OSE00LH", Reward = "LargediamondsPack" },
	[208] = { Code = "7NSW0NZE", Reward = "LargediamondsPack" },
	[209] = { Code = "Q7VTBWJ0", Reward = "LargediamondsPack" },
	[210] = { Code = "W4XRZM10", Reward = "LargediamondsPack" },
	[211] = { Code = "XFQ65JKB", Reward = "LargediamondsPack" },
	[212] = { Code = "DYW32ZGI", Reward = "LargediamondsPack" },
	[213] = { Code = "DJI5GQJG", Reward = "LargediamondsPack" },
	[214] = { Code = "0ZPKFVTS", Reward = "LargediamondsPack" },
	[215] = { Code = "HK6F1ZFF", Reward = "LargediamondsPack" },
	[216] = { Code = "8KAKSGUY", Reward = "LargediamondsPack" },
	[217] = { Code = "MVNJBLNG", Reward = "LargediamondsPack" },
	[218] = { Code = "2DOQ4HZY", Reward = "LargediamondsPack" },
	[219] = { Code = "BSZX4SJ9", Reward = "LargediamondsPack" },
	[220] = { Code = "LDY8OOHZ", Reward = "LargediamondsPack" },
	[221] = { Code = "4F78D3FM", Reward = "LargediamondsPack" },
	[222] = { Code = "6CCK0IDS", Reward = "LargediamondsPack" },
	[223] = { Code = "8L9UZSL2", Reward = "LargediamondsPack" },
	[224] = { Code = "9DXA8HUN", Reward = "LargediamondsPack" },
	[225] = { Code = "DQNFSXIZ", Reward = "LargediamondsPack" },
	[226] = { Code = "LFKAC83L", Reward = "LargediamondsPack" },
	[227] = { Code = "V49JM0BG", Reward = "LargediamondsPack" },
	[228] = { Code = "76BVVTA1", Reward = "LargediamondsPack" },
	[229] = { Code = "GVS2ITMR", Reward = "LargediamondsPack" },
	[230] = { Code = "NJW8S8IZ", Reward = "LargediamondsPack" },
	[231] = { Code = "ZBMKUOD5", Reward = "LargediamondsPack" },
	[232] = { Code = "BIDBL2RR", Reward = "LargediamondsPack" },
	[233] = { Code = "EL1KRM26", Reward = "LargediamondsPack" },
	[234] = { Code = "7FB8VO3N", Reward = "LargediamondsPack" },
	[235] = { Code = "ZH5CPNCM", Reward = "LargediamondsPack" },
	[236] = { Code = "CFXG835S", Reward = "LargediamondsPack" },
	[237] = { Code = "DGP731KN", Reward = "LargediamondsPack" },
	[238] = { Code = "PXTP8WYW", Reward = "LargediamondsPack" },
	[239] = { Code = "DF63M6E9", Reward = "LargediamondsPack" },
	[240] = { Code = "E24QZLBG", Reward = "LargediamondsPack" },
	[241] = { Code = "63WK497B", Reward = "LargediamondsPack" },
	[242] = { Code = "WHZ991HD", Reward = "LargediamondsPack" },
	[243] = { Code = "RWD44SRY", Reward = "LargediamondsPack" },
	[244] = { Code = "H0K61DOY", Reward = "LargediamondsPack" },
	[245] = { Code = "OIIRN9MM", Reward = "LargediamondsPack" },
	[246] = { Code = "4ULM3WX8", Reward = "LargediamondsPack" },
	[247] = { Code = "RMAURGSB", Reward = "LargediamondsPack" },
	[248] = { Code = "2UFUQHIP", Reward = "LargediamondsPack" },
	[249] = { Code = "OKIUDD4N", Reward = "LargediamondsPack" },
	[250] = { Code = "1YY4D94V", Reward = "LargediamondsPack" },
	[251] = { Code = "XC6ND0PP", Reward = "LargediamondsPack" },
	[252] = { Code = "G2AK3VJD", Reward = "LargediamondsPack" },
	[253] = { Code = "A5S8CMV7", Reward = "LargediamondsPack" },
	[254] = { Code = "VFC9MXW5", Reward = "LargediamondsPack" },
	[255] = { Code = "TCP2C0P0", Reward = "LargediamondsPack" },
	[256] = { Code = "OC8VS7RY", Reward = "LargediamondsPack" },
	[257] = { Code = "KAIVDZSD", Reward = "LargediamondsPack" },
	[258] = { Code = "P25SAMVJ", Reward = "LargediamondsPack" },
	[259] = { Code = "47NVVMY0", Reward = "LargediamondsPack" },
	[260] = { Code = "N6NLDKXC", Reward = "LargediamondsPack" },
	[261] = { Code = "41OV62VW", Reward = "LargediamondsPack" },
	[262] = { Code = "2Z3TTGD0", Reward = "LargediamondsPack" },
	[263] = { Code = "ZVYO5EIR", Reward = "LargediamondsPack" },
	[264] = { Code = "Y1ZMNKBM", Reward = "LargediamondsPack" },
	[265] = { Code = "U04VI1WP", Reward = "LargediamondsPack" },
	[266] = { Code = "NDQ8EWGE", Reward = "LargediamondsPack" },
	[267] = { Code = "GBM227XY", Reward = "LargediamondsPack" },
	[268] = { Code = "3G04V90V", Reward = "LargediamondsPack" },
	[269] = { Code = "NYO8NFUJ", Reward = "LargediamondsPack" },
	[270] = { Code = "I2825ANM", Reward = "LargediamondsPack" },
	[271] = { Code = "T1UCF27J", Reward = "LargediamondsPack" },
	[272] = { Code = "28UI1Z6J", Reward = "LargediamondsPack" },
	[273] = { Code = "JJZ2JQZH", Reward = "LargediamondsPack" },
	[274] = { Code = "U41Y1GS2", Reward = "LargediamondsPack" },
	[275] = { Code = "1CWROZCB", Reward = "LargediamondsPack" },
	[276] = { Code = "KI7AATOC", Reward = "HugeMoneyPack" },
	[277] = { Code = "5KLHVGYZ", Reward = "HugeMoneyPack" },
	[278] = { Code = "PFW8QVWG", Reward = "HugeMoneyPack" },
	[279] = { Code = "CWP52RO6", Reward = "HugeMoneyPack" },
	[280] = { Code = "W4AX1MJV", Reward = "HugeMoneyPack" },
	[281] = { Code = "B7HA9TFE", Reward = "HugeMoneyPack" },
	[282] = { Code = "V2NFVIRD", Reward = "HugeMoneyPack" },
	[283] = { Code = "90VUI4G2", Reward = "HugeMoneyPack" },
	[284] = { Code = "I27K2VCA", Reward = "HugeMoneyPack" },
	[285] = { Code = "M8NB007X", Reward = "HugeMoneyPack" },
	[286] = { Code = "1IJ8JLD0", Reward = "HugeMoneyPack" },
	[287] = { Code = "P8B0EGCU", Reward = "HugeMoneyPack" },
	[288] = { Code = "JW60CRJH", Reward = "HugeMoneyPack" },
	[289] = { Code = "4D9ZRO2V", Reward = "HugeMoneyPack" },
	[290] = { Code = "AAIKNDRE", Reward = "HugeMoneyPack" },
	[291] = { Code = "S99UEG1N", Reward = "HugeMoneyPack" },
	[292] = { Code = "ZGONI1C0", Reward = "HugeMoneyPack" },
	[293] = { Code = "SJ2PYB17", Reward = "HugeMoneyPack" },
	[294] = { Code = "4BW8N04E", Reward = "HugeMoneyPack" },
	[295] = { Code = "NXNWQSW4", Reward = "HugeMoneyPack" },
	[296] = { Code = "6FK2BTBP", Reward = "HugeMoneyPack" },
	[297] = { Code = "BNCUL0P5", Reward = "HugeMoneyPack" },
	[298] = { Code = "DP9A12LQ", Reward = "HugeMoneyPack" },
	[299] = { Code = "6OZDYX4T", Reward = "HugeMoneyPack" },
	[300] = { Code = "ZC62LYRU", Reward = "HugeMoneyPack" },
	[301] = { Code = "2ISL57QK", Reward = "HugeMoneyPack" },
	[302] = { Code = "T7WKTVCU", Reward = "HugeMoneyPack" },
	[303] = { Code = "HRB6JTTS", Reward = "HugeMoneyPack" },
	[304] = { Code = "3QWQ9DHN", Reward = "HugeMoneyPack" },
	[305] = { Code = "PZOSP170", Reward = "HugeMoneyPack" },
	[306] = { Code = "3QBP1C7R", Reward = "HugeMoneyPack" },
	[307] = { Code = "YBCE8G57", Reward = "HugeMoneyPack" },
	[308] = { Code = "8CVM386Z", Reward = "HugeMoneyPack" },
	[309] = { Code = "8LCX5HIF", Reward = "HugeMoneyPack" },
	[310] = { Code = "DNMCHQRG", Reward = "HugeMoneyPack" },
	[311] = { Code = "DAT14YRN", Reward = "HugeMoneyPack" },
	[312] = { Code = "PRTRJNS7", Reward = "HugeMoneyPack" },
	[313] = { Code = "PTPQJLVZ", Reward = "HugeMoneyPack" },
	[314] = { Code = "4WBEB73T", Reward = "HugeMoneyPack" },
	[315] = { Code = "P4DBLH4C", Reward = "HugeMoneyPack" },
	[316] = { Code = "4IRUS17M", Reward = "HugeMoneyPack" },
	[317] = { Code = "IWED5SE6", Reward = "HugeMoneyPack" },
	[318] = { Code = "AD9TT6G6", Reward = "HugeMoneyPack" },
	[319] = { Code = "4PUEU091", Reward = "HugeMoneyPack" },
	[320] = { Code = "29F8FTI6", Reward = "HugeMoneyPack" },
	[321] = { Code = "9RDV2JAN", Reward = "HugeMoneyPack" },
	[322] = { Code = "HOVBV0LA", Reward = "HugeMoneyPack" },
	[323] = { Code = "Y14OST8E", Reward = "HugeMoneyPack" },
	[324] = { Code = "7ZD4AH4M", Reward = "HugeMoneyPack" },
	[325] = { Code = "XXICT35N", Reward = "HugeMoneyPack" },
	[326] = { Code = "BYIAIYX5", Reward = "HugeMoneyPack" },
	[327] = { Code = "IJICQ681", Reward = "HugeMoneyPack" },
	[328] = { Code = "SFWMYU3C", Reward = "HugeMoneyPack" },
	[329] = { Code = "L5P402IS", Reward = "HugeMoneyPack" },
	[330] = { Code = "MUX2BDMQ", Reward = "HugeMoneyPack" },
	[331] = { Code = "EZV6CBUV", Reward = "HugeMoneyPack" },
	[332] = { Code = "ZJLHT63H", Reward = "HugeMoneyPack" },
	[333] = { Code = "7K1Z14SN", Reward = "HugeMoneyPack" },
	[334] = { Code = "Q09RAF37", Reward = "HugeMoneyPack" },
	[335] = { Code = "LCXY3MDB", Reward = "HugeMoneyPack" },
	[336] = { Code = "MW73LTEG", Reward = "HugeMoneyPack" },
	[337] = { Code = "CA32A6KM", Reward = "HugeMoneyPack" },
	[338] = { Code = "RC82WIDM", Reward = "HugeMoneyPack" },
	[339] = { Code = "W8220JQJ", Reward = "HugeMoneyPack" },
	[340] = { Code = "EIS2VFGV", Reward = "HugeMoneyPack" },
	[341] = { Code = "0H9IWDEV", Reward = "HugeMoneyPack" },
	[342] = { Code = "TJSLQ6HP", Reward = "HugeMoneyPack" },
	[343] = { Code = "22WJB57C", Reward = "HugeMoneyPack" },
	[344] = { Code = "66JNO0MA", Reward = "HugeMoneyPack" },
	[345] = { Code = "8GJKI20K", Reward = "HugeMoneyPack" },
	[346] = { Code = "ZUX1SR8Q", Reward = "HugeMoneyPack" },
	[347] = { Code = "NRFDYD84", Reward = "HugeMoneyPack" },
	[348] = { Code = "L5EYCK0Z", Reward = "HugeMoneyPack" },
	[349] = { Code = "YXFMW2XB", Reward = "HugeMoneyPack" },
	[350] = { Code = "XYFTO5BB", Reward = "HugeMoneyPack" },
	[351] = { Code = "EN34JXR3", Reward = "VIP" },
	[352] = { Code = "S8ICOB2W", Reward = "VIP" },
	[353] = { Code = "UXJ4BCYF", Reward = "VIP" },
	[354] = { Code = "SUKHH4K7", Reward = "VIP" },
	[355] = { Code = "HQCIDIKL", Reward = "VIP" },
	[356] = { Code = "MY51Z4YE", Reward = "VIP" },
	[357] = { Code = "CEVQG2K8", Reward = "VIP" },
	[358] = { Code = "G6I8I5X1", Reward = "VIP" },
	[359] = { Code = "VNQ5OWNV", Reward = "VIP" },
	[360] = { Code = "VCJ7EXQ4", Reward = "VIP" },
	[361] = { Code = "K4D3WDJZ", Reward = "VIP" },
	[362] = { Code = "VAHTVFYV", Reward = "VIP" },
	[363] = { Code = "4Y4G4EDC", Reward = "VIP" },
	[364] = { Code = "46W05LOU", Reward = "VIP" },
	[365] = { Code = "3N5QQKOG", Reward = "VIP" },
	[366] = { Code = "IKXZU11E", Reward = "VIP" },
	[367] = { Code = "8EI8IC4C", Reward = "VIP" },
	[368] = { Code = "1JC0YG6P", Reward = "VIP" },
	[369] = { Code = "PWL6C3B7", Reward = "VIP" },
	[370] = { Code = "NM0PITXK", Reward = "VIP" },
	[371] = { Code = "DTIOTHKR", Reward = "VIP" },
	[372] = { Code = "X5B2D25U", Reward = "VIP" },
	[373] = { Code = "6ELDCSOJ", Reward = "VIP" },
	[374] = { Code = "B4MF7KQ9", Reward = "VIP" },
	[375] = { Code = "ARUYR5R2", Reward = "VIP" },
	[376] = { Code = "EO5CN5PM", Reward = "VIP" },
	[377] = { Code = "XGGRGOR3", Reward = "VIP" },
	[378] = { Code = "09BMAYH0", Reward = "VIP" },
	[379] = { Code = "MDGPU025", Reward = "VIP" },
	[380] = { Code = "LJHK33SV", Reward = "VIP" },
	[381] = { Code = "BP16M77R", Reward = "VIP" },
	[382] = { Code = "MF5ULG0I", Reward = "VIP" },
	[383] = { Code = "PHXZ478J", Reward = "VIP" },
	[384] = { Code = "IOXCQVDS", Reward = "VIP" },
	[385] = { Code = "Q2EUAY81", Reward = "VIP" },
	[386] = { Code = "WVN37RNR", Reward = "VIP" },
	[387] = { Code = "YJANS37L", Reward = "VIP" },
	[388] = { Code = "US8VYL5O", Reward = "VIP" },
	[389] = { Code = "DY01W3UX", Reward = "VIP" },
	[390] = { Code = "BIZ9S2SF", Reward = "VIP" },
	[391] = { Code = "DR5YJHXT", Reward = "VIP" },
	[392] = { Code = "F71M2PQR", Reward = "VIP" },
	[393] = { Code = "G5UGCMSZ", Reward = "VIP" },
	[394] = { Code = "DFGKAJNA", Reward = "VIP" },
	[395] = { Code = "4OQCU4W3", Reward = "VIP" },
	[396] = { Code = "7MBKO086", Reward = "VIP" },
	[397] = { Code = "M64FFPX6", Reward = "VIP" },
	[398] = { Code = "481XCJDT", Reward = "VIP" },
	[399] = { Code = "9BIKKTBU", Reward = "VIP" },
	[400] = { Code = "TTSTWATK", Reward = "VIP" },
	[401] = { Code = "Y1UINTKD", Reward = "VIP" },
	[402] = { Code = "8MR8D3BE", Reward = "VIP" },
	[403] = { Code = "Z3GLT2KN", Reward = "VIP" },
	[404] = { Code = "GZVXKS9K", Reward = "VIP" },
	[405] = { Code = "08KHTPD7", Reward = "VIP" },
	[406] = { Code = "14C2Y52M", Reward = "VIP" },
	[407] = { Code = "I7JULYBD", Reward = "VIP" },
	[408] = { Code = "7VR3YRDB", Reward = "VIP" },
	[409] = { Code = "N4RZIAE3", Reward = "VIP" },
	[410] = { Code = "29VWZCPO", Reward = "VIP" },
	[411] = { Code = "GYY44TXG", Reward = "VIP" },
	[412] = { Code = "HGNTT2UG", Reward = "VIP" },
	[413] = { Code = "60KZNFQP", Reward = "VIP" },
	[414] = { Code = "XVYOAH54", Reward = "VIP" },
	[415] = { Code = "145XJ3ZL", Reward = "VIP" },
	[416] = { Code = "KJ0CTSCG", Reward = "VIP" },
	[417] = { Code = "YDAT5704", Reward = "VIP" },
	[418] = { Code = "ET0ECGNR", Reward = "VIP" },
	[419] = { Code = "RCRVF7HB", Reward = "VIP" },
	[420] = { Code = "MI7BE4QM", Reward = "VIP" },
	[421] = { Code = "PLDYPQU6", Reward = "VIP" },
	[422] = { Code = "XD6Y0TLA", Reward = "VIP" },
	[423] = { Code = "FHA7W109", Reward = "VIP" },
	[424] = { Code = "ZJ6V268L", Reward = "VIP" },
	[425] = { Code = "T5MPFAVU", Reward = "VIP" },
	[426] = { Code = "IVQFGDA0", Reward = "2xCash" },
	[427] = { Code = "IF1C81MZ", Reward = "2xCash" },
	[428] = { Code = "X2BXEKJ3", Reward = "2xCash" },
	[429] = { Code = "U7VK1MCC", Reward = "2xCash" },
	[430] = { Code = "P5BA4WQA", Reward = "2xCash" },
	[431] = { Code = "OZV24I1M", Reward = "2xCash" },
	[432] = { Code = "ECTXNLA1", Reward = "2xCash" },
	[433] = { Code = "93247GZR", Reward = "2xCash" },
	[434] = { Code = "DWGFK46R", Reward = "2xCash" },
	[435] = { Code = "FF9HXH2F", Reward = "2xCash" },
	[436] = { Code = "6U0WKZZM", Reward = "2xCash" },
	[437] = { Code = "Y9E7GBC9", Reward = "2xCash" },
	[438] = { Code = "J3LMVTV0", Reward = "2xCash" },
	[439] = { Code = "J5PXWZH3", Reward = "2xCash" },
	[440] = { Code = "DLKF1ZW0", Reward = "2xCash" },
	[441] = { Code = "GPV818U4", Reward = "2xCash" },
	[442] = { Code = "PGFCM7X5", Reward = "2xCash" },
	[443] = { Code = "I4GK0ZKF", Reward = "2xCash" },
	[444] = { Code = "GFWK918G", Reward = "2xCash" },
	[445] = { Code = "03PO6269", Reward = "2xCash" },
	[446] = { Code = "O4Y8X0QS", Reward = "2xCash" },
	[447] = { Code = "OYEPR498", Reward = "2xCash" },
	[448] = { Code = "WNH09X6J", Reward = "2xCash" },
	[449] = { Code = "LYZUCFKX", Reward = "2xCash" },
	[450] = { Code = "M8R96551", Reward = "2xCash" },
	[451] = { Code = "BK7YXQQ2", Reward = "2xCash" },
	[452] = { Code = "TN5RAI7O", Reward = "2xCash" },
	[453] = { Code = "UXTOPGMK", Reward = "2xCash" },
	[454] = { Code = "IPBJZBQN", Reward = "2xCash" },
	[455] = { Code = "VJ8F8XZF", Reward = "2xCash" },
	[456] = { Code = "ACYZD2RL", Reward = "2xCash" },
	[457] = { Code = "9XO0F40U", Reward = "2xCash" },
	[458] = { Code = "UDNMT2B0", Reward = "2xCash" },
	[459] = { Code = "27RXFWGP", Reward = "2xCash" },
	[460] = { Code = "42UFZJDJ", Reward = "2xCash" },
	[461] = { Code = "WA1GEA65", Reward = "2xCash" },
	[462] = { Code = "4LM2MG7X", Reward = "2xCash" },
	[463] = { Code = "XU3TV27R", Reward = "2xCash" },
	[464] = { Code = "R8F54DC3", Reward = "2xCash" },
	[465] = { Code = "4A8DP8C3", Reward = "2xCash" },
	[466] = { Code = "KDDMD7WB", Reward = "2xCash" },
	[467] = { Code = "OQLIBAIP", Reward = "2xCash" },
	[468] = { Code = "M6D93MQ6", Reward = "2xCash" },
	[469] = { Code = "V0BUZE8I", Reward = "2xCash" },
	[470] = { Code = "ZWZMXTUL", Reward = "2xCash" },
	[471] = { Code = "PI28LN0B", Reward = "2xCash" },
	[472] = { Code = "FB6BH30M", Reward = "2xCash" },
	[473] = { Code = "KSMO8BAQ", Reward = "2xCash" },
	[474] = { Code = "QEHN8WCX", Reward = "2xCash" },
	[475] = { Code = "PFRAJJW6", Reward = "2xCash" },
	[476] = { Code = "PVZT7LCJ", Reward = "2xCash" },
	[477] = { Code = "57NXTPK8", Reward = "2xCash" },
	[478] = { Code = "CUO5F2GA", Reward = "2xCash" },
	[479] = { Code = "5TX7Y2WA", Reward = "2xCash" },
	[480] = { Code = "I6UYGFES", Reward = "2xCash" },
	[481] = { Code = "9G5QUK1Y", Reward = "2xCash" },
	[482] = { Code = "8EZ9OEIL", Reward = "2xCash" },
	[483] = { Code = "Y2KAWO4R", Reward = "2xCash" },
	[484] = { Code = "SVXTO11B", Reward = "2xCash" },
	[485] = { Code = "RKUYM5I1", Reward = "2xCash" },
	[486] = { Code = "HZZVVVCH", Reward = "2xCash" },
	[487] = { Code = "BX95ETUY", Reward = "2xCash" },
	[488] = { Code = "7R75UZV4", Reward = "2xCash" },
	[489] = { Code = "1REMDIJG", Reward = "2xCash" },
	[490] = { Code = "N9K537BB", Reward = "2xCash" },
	[491] = { Code = "819NN9FF", Reward = "2xCash" },
	[492] = { Code = "NF05ZHRD", Reward = "2xCash" },
	[493] = { Code = "1HL0QTC3", Reward = "2xCash" },
	[494] = { Code = "NQV9J0AH", Reward = "2xCash" },
	[495] = { Code = "SGF2E6M7", Reward = "2xCash" },
	[496] = { Code = "LAWFRHWU", Reward = "2xCash" },
	[497] = { Code = "BUE0TS0Q", Reward = "2xCash" },
	[498] = { Code = "GR66HY75", Reward = "2xCash" },
	[499] = { Code = "8QYN92ZR", Reward = "2xCash" },
	[500] = { Code = "415FTHKP", Reward = "2xCash" },
}

return module]]></ProtectedString>
						<string name="ScriptGuid">{480514D6-6CEB-46BE-BB4C-572401E4BF10}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Codes_Unique.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX95C0C8DD2FDB4B33BD7D384C1E0E4D0E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Utils</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX8235E9EA13D3467988D4970CA0A1C527">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- Export Hall of Fame 2025 (_2) to enriched CSV
-- Columns:
-- leaderboard,rank,userId,username,displayName,score,country

local DataStoreService = game:GetService("DataStoreService")
local UserService = game:GetService("UserService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Country_Mod = require(
	ReplicatedStorage:WaitForChild("Data_Mods_F"):WaitForChild("Country_Mod")
)

local LEADERBOARD_KEYS = {
	"Best Elo",
	"Total Wins",
	"Win Streak",
	"Knockouts",
	"Submissions Wins",
	"Gym Training",
	"Ranked Wins"
}

local SUFFIX = "_2" -- Hall of Fame 2025
local PAGE_SIZE = 100
local MAX_RANK = 100

local csvLines = {}
table.insert(csvLines, "leaderboard,rank,userId,username,displayName,score,country")

-- Cache user infos to avoid extra calls
local userCache = {}

local function getUserInfo(userId)
	if userCache[userId] then
		return userCache[userId]
	end

	local username = "Unknown"
	local displayName = "Unknown"

	local success, result = pcall(function()
		return UserService:GetUserInfosByUserIdsAsync({ userId })
	end)

	if success and result and result[1] then
		username = result[1].Username or username
		displayName = result[1].DisplayName or displayName
	end

	userCache[userId] = { username, displayName }
	return username, displayName
end

local function deserializeScoreAndCountry(serialized)
	local str = tostring(serialized)
	if #str < 5 then
		return tonumber(str), "Unknown"
	end

	local score = tonumber(string.sub(str, 1, #str - 4))
	local countryId = tonumber(string.sub(str, -4))
	local country = Country_Mod.Get_Country_Index_From_Number(countryId) or "Unknown"

	return score, country
end

local function exportLeaderboard(baseName)
	print("[EXPORT] Reading:", baseName)

	local store = DataStoreService:GetOrderedDataStore(baseName .. SUFFIX)

	local ok, pages = pcall(function()
		return store:GetSortedAsync(false, PAGE_SIZE)
	end)
	if not ok then
		warn("[EXPORT] Failed:", baseName)
		return
	end

	local rank = 1

	while true do
		for _, entry in ipairs(pages:GetCurrentPage()) do
			if rank > MAX_RANK then
				return
			end

			local userId = tonumber(entry.key)
			local serialized = entry.value

			local username, displayName = getUserInfo(userId)
			local score, country = deserializeScoreAndCountry(serialized)

			table.insert(csvLines, string.format(
				"%s,%d,%d,%s,%s,%d,%s",
				baseName,
				rank,
				userId,
				username,
				displayName,
				score,
				country
				))

			rank += 1
		end

		if pages.IsFinished then
			break
		end

		pcall(function()
			pages:AdvanceToNextPageAsync()
		end)

		task.wait(0.3) -- throttle safety
	end
end

for _, name in ipairs(LEADERBOARD_KEYS) do
	exportLeaderboard(name)
end

print("===== HALL OF FAME 2025 CSV BEGIN =====")
for _, line in ipairs(csvLines) do
	print(line)
end
print("===== HALL OF FAME 2025 CSV END =====")

print("[EXPORT] Done. Copy logs into hall_of_fame_2025.csv")
]]></ProtectedString>
						<string name="ScriptGuid">{CDCD24D8-D8FD-4D58-B51F-D56E226497ED}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Export_HallOfFame_2025.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX75E9AFE2A1E84A4292DFAD34674F53BB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tests</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX23687BC7BDE04C0594D682866D62B7B1">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Elo_Mod_Compute_Elo.spec.lua
-- Compute_Elo tests with detailed logging

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TestService = game:GetService("TestService")

local Elo_Mod = require(ReplicatedStorage.Data_Mods_F.Elo_Mod)

-- ===== Helpers =====

local function logResult(modeName, w0, l0, w1, l1)
	local winGain = w1 - w0
	local loseLoss = l0 - l1

	print(string.format(
		"[Compute_Elo] Mode=%s | Winner %d → %d (+%d) | Loser %d → %d (-%d)",
		modeName,
		w0, w1, winGain,
		l0, l1, loseLoss
		))
end

local function assertWinnerLoser(w0, l0, w1, l1)
	-- Winner must not lose Elo
	assert(w1 >= w0, "Winner Elo should not decrease")

	-- Loser must not gain Elo
	assert(l1 <= l0, "Loser Elo should not increase")

	-- Hard cap must be respected
	assert(w1 <= Elo_Mod.ELO_MAX, "Winner Elo exceeds hard cap")

	local winDelta = w1 - w0
	local loseDelta = l0 - l1

	-- Symmetry only applies below soft cap and below hard cap
	local symmetryApplies =
		w0 < Elo_Mod.SOFT_CAP_ELO and
		w1 < Elo_Mod.ELO_MAX

	if symmetryApplies then
		assert(
			winDelta == loseDelta,
			"Elo gain/loss should be symmetrical below soft cap"
		)
	end

	-- Ensure minimum Elo movement when not capped
	if w0 < Elo_Mod.ELO_MAX then
		assert(
			winDelta >= 1 or w1 == Elo_Mod.ELO_MAX,
			"Winner should gain at least 1 Elo unless capped"
		)
	end
end

-- ===== Test matrix =====

local eloPairs = {
	{ winner = 400, loser = 400 },
	{ winner = 400, loser = 450 },
	{ winner = 450, loser = 400 },
	{ winner = 1000, loser = 1000 },
	{ winner = 1200, loser = 800  },
	{ winner = 800,  loser = 1200 },
	{ winner = 2000,  loser = 2000 },
	{ winner = 2100,  loser = 2000 },
	{ winner = 2500,  loser = 2500 },
	{ winner = 2700,  loser = 2700 },
	{ winner = 2900,  loser = 2900 },
	{ winner = 3000,  loser = 3000 }
}

local modes = {
	Elo_Mod.EloMode.Standard,
	--Elo_Mod.EloMode.League,
	--Elo_Mod.EloMode.Tournament,
	Elo_Mod.EloMode.Ranked,
}

-- ===== Tests =====

print("=== START Compute_Elo tests ===")

for _, mode in ipairs(modes) do
	for _, pair in ipairs(eloPairs) do
		local w0 = pair.winner
		local l0 = pair.loser

		local w1, l1 = Elo_Mod.Compute_Elo(w0, l0, mode)

		logResult(mode.Name, w0, l0, w1, l1)
		assertWinnerLoser(w0, l0, w1, l1)
	end
end

print("=== END Compute_Elo tests ===")
TestService:Message("Compute_Elo unit tests passed (all modes & configurations)")
]]></ProtectedString>
							<string name="ScriptGuid">{EA270439-9F1B-444E-A364-DD266427D764}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Elo_Mod_Compute_Elo.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF40809F56AE547A2B936DFD6DA02410C">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- League_Event_Console.lua
-- Manual admin console to control weekly league tournaments


local Players 					= game:GetService("Players")
local ServerScriptService 		= game:GetService("ServerScriptService")
local MemoryStoreService 		= game:GetService("MemoryStoreService")

local PlayerUtils				= require(game.ReplicatedStorage.Modules.PlayerUtils)
local Tournament_Manager 		= require(ServerScriptService.League_Service:WaitForChild("Tournament_Manager"))

local League_Event_Console = {}



local function countDict(t)
	local n = 0
	for _ in pairs(t or {}) do
		n += 1
	end
	return n
end


-- =========================
-- COMMANDS
-- =========================
function League_Event_Console:StartTournament(player)

	if Tournament_Manager.IsTournamentActive then
		warn("[LEAGUE_CONSOLE] Tournament already active")
		return
	end

	print("[LEAGUE_CONSOLE] Starting tournament manually")
	Tournament_Manager:StartAllDivisions()
end

function League_Event_Console:EndTournament(player)

	if not Tournament_Manager.IsTournamentActive then
		warn("[LEAGUE_CONSOLE] No active tournament to stop")
		return
	end

	print("[LEAGUE_CONSOLE] Ending tournament manually")
	Tournament_Manager:EndAllDivisions()
end

function League_Event_Console:Status(player)

	print("========== TOURNAMENT STATUS ==========")
	print("Active:", Tournament_Manager.IsTournamentActive)

	for division, data in pairs(Tournament_Manager.Divisions or {}) do
		print(string.format(
			"- %s | State=%s | Registered=%d | Queue=%d",
			division,
			data.State or "?",
			countDict(data.Registered),
			data.Queue and #data.Queue or 0
			))
	end

	print("======================================")
end

function League_Event_Console:DumpTournamentServers(player, division)
	print("===== TournamentServers:", division, "=====")
	
	division = division or "Bronze"

	local map = MemoryStoreService:GetSortedMap("TournamentServers:" .. division)

	local ok, entries = pcall(function()
		return map:GetRangeAsync(Enum.SortDirection.Ascending, 100)
	end)

	if not ok then
		warn("MemoryStore read failed")
		return
	end

	if #entries == 0 then
		print("(empty)")
		return
	end

	for i, e in ipairs(entries) do
		local s = e.value
		print(string.format(
			"#%d key=%s players=%s/%s lastHB=%s age=%ds",
			i,
			e.key,
			tostring(s.players),
			tostring(s.capacity),
			tostring(s.lastHeartbeat),
			os.time() - (s.lastHeartbeat or 0)
			))
	end

	print("====================================")
end


-- =========================
-- CHAT COMMANDS
-- =========================
Players.PlayerAdded:Connect(function(player)
	player.Chatted:Connect(function(msg)
		if not PlayerUtils.isAdmin(player) then 
			return 
		end

		local raw = msg

		print("[LEAGUE_CONSOLE] Player Chatted:", raw)

		if msg == "!league start" then
			League_Event_Console:StartTournament(player)

		elseif msg == "!league stop" then
			League_Event_Console:EndTournament(player)

		elseif msg == "!league status" then
			League_Event_Console:Status(player)

		elseif msg:match("^!league%s+dump") then
			local parts = string.split(raw, " ")
			local division = parts[3] or "Bronze"

			League_Event_Console:DumpTournamentServers(player, division)

		else
			print("blah")
			print(msg)
		end
	end)
end)

return League_Event_Console
]]></ProtectedString>
							<string name="ScriptGuid">{0D9AEB38-C6F8-4FD7-BDCD-7AB180C86EB1}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">League_Event_Console.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX61E20FA74F8449F985AEC851927A0553">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local DataStoreService = game:GetService("DataStoreService")
local LeagueStore = DataStoreService:GetDataStore("LeagueDS")

-- Replace with your UserId
local userId = 8520250426 
local key = "LEAGUE_" .. tostring(userId)

local data = LeagueStore:GetAsync(key)
if not data then
	error("No data found for " .. key)
end

data.Division = "Bronze"
data.LP = 0
data.LastUpdated = os.time()

LeagueStore:SetAsync(key, data)
print("Division reset to Bronze for", key)
]]></ProtectedString>
							<string name="ScriptGuid">{3172A3C8-FAE4-4B1E-8922-C5F126247D73}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">RestoreDivision.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXF5614FBEAFBA4CB782AD3844A79B6518">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Moderation</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX15A2C0AB8BBF459097FDE6254B19091B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- ServerScriptService/Moderation/CheatersLeaderboardsPurge.server.lua

local DataStoreService = game:GetService("DataStoreService")

---------------------------------------------------------------------
-- EDIT THIS LIST – banned UserIds
---------------------------------------------------------------------
local BANNED_USERS = {
	-- 123456789,
}
---------------------------------------------------------------------

-- Must match LeaderboarKeys in GlobalLeaderBoards.lua
local LEADERBOARD_KEYS = {
	"Best Elo",
	"Total Wins",
	"Win Streak",
	"Knockouts",
	"Submissions Wins",
	"Gym Training",
	"Ranked Wins",
	"Punch Score",
}

local function getAllScopes()
	local now = os.date("*t")
	local scopes = {}

	-- Weekly
	table.insert(scopes, "_W_" .. os.date("%Y_%W"))

	-- Monthly
	table.insert(scopes, "_M_" .. now.year .. "_" .. string.format("%02d", now.month))

	-- AllTime (legacy handling)
	if now.year == 2025 then
		table.insert(scopes, "_2")
	else
		table.insert(scopes, "_A")
	end

	return scopes
end

local function removeFromStore(store, userId)
	for i = 1, 5 do
		local success, err = pcall(function()
			store:RemoveAsync(userId)
		end)

		if success then
			print("[Purge] Removed", userId, "from", store.Name)
			return
		end

		warn("[Purge] Failed:", store.Name, "User:", userId, "Try:", i, "Err:", err)
		task.wait(1)
	end
end

local function purgeUser(userId)
	print("[Purge] Processing banned user:", userId)

	local scopes = getAllScopes()

	for _, baseKey in ipairs(LEADERBOARD_KEYS) do
		for _, scope in ipairs(scopes) do
			local storeName = baseKey .. scope
			local store = DataStoreService:GetOrderedDataStore(storeName)
			removeFromStore(store, userId)
		end
	end
end

task.spawn(function()
	print("[Purge] Starting purge...")
	for _, userId in ipairs(BANNED_USERS) do
		purgeUser(userId)
	end
	print("[Purge] Completed.")
end)
]]></ProtectedString>
							<string name="ScriptGuid">{6E1E76DF-5303-4D0C-BE9D-B219F6B74F4D}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CheatersLeaderboardsPurge.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXD5EFCB3F7FFF4367B601257FFD78CAE2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UGC</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA8CFD0698A784E329D93109D483B616E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Monetization/UGC_Data_Generator.server.lua
--
--  Description:
--      Pre-generates all UGC item metadata to avoid expensive calls to
--      MarketplaceService:GetProductInfo(). This script fetches prices,
--      names, and thumbnails once, then outputs a Lua table ready to be
--      used as a replacement for Monetization_Mod.UGC_Data.
--
--      Features:
--          • Safe wrapper around GetProductInfo (pcall protected)
--          • Automatic construction of a clean Lua data table
--          • Generates ID, Name, Price, and Thumbnail URL per UGC item
--          • Intended for offline precomputation / debug console usage
--
--  Last Modified: 2025-11-29 by Darkzeb
--  Version: V2025-11
--
--  Dependencies:
--      Services:
--          - MarketplaceService
--          - ReplicatedStorage
--
--      Modules:
--          - Data_Mods_F/Monetization_Mod
--
--  Notes:
--      • This script only *prints* the generated table. It does NOT save it.
--      • Prices default to 0 if the request fails.
--======================================================================

local MPS = game:GetService("MarketplaceService")
local RS = game:GetService("ReplicatedStorage")

local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local Monetization_Mod = require(Data_Mods_F:WaitForChild("Monetization_Mod"))

local UGC_Data = Monetization_Mod.Get_All_UGC_Data()

local function safeGetInfo(id)
	local ok, info = pcall(function()
		return MPS:GetProductInfo(id)
	end)
	if ok then return info end
	warn("FAILED to fetch product info for ID:", id)
	return { PriceInRobux = 0 }
end

local output = {}
table.insert(output, "return {")

for key, values in pairs(UGC_Data) do
	local id = values.ID
	local name = values.Name
	local info = safeGetInfo(id)
	local price = info.PriceInRobux or 0
	local thumbnail = "rbxthumb://type=Asset&Id=" .. tostring(id) .. "&w=150&h=150"

	-- Format a Lua entry
	local line = string.format(
		"\t[%q] = { Name = %q, ID = %d, Price = %d, Thumbnail = %q },",
		key, name, id, price, thumbnail
	)

	table.insert(output, line)
end

table.insert(output, "}")

-- Print final output
print(table.concat(output, "\n"))
]]></ProtectedString>
							<string name="ScriptGuid">{6231A63A-40A8-4FA3-B093-823CCC28BFE7}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Get_All_UGCs.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXBEAB7D1380A64DC1A8543BD9661FD6AD">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ServerStorage</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXA34100F1318C42D38E82A58AD9493945">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Rewards</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXA78DA41B738F4DAC92394B6499448233">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[return function(player)
	local playerData = player:FindFirstChild("Player_Data")

	if playerData then
		playerData.Cash2x.Value = true
	end
end]]></ProtectedString>
						<string name="ScriptGuid">{9578A285-DBF4-4742-A9F9-03B1B3B303BA}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">2xCash.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX118C348504024354BF3EDF0BD44C6A60">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[return function(player)
	local playerData = player:FindFirstChild("Player_Data")

	if playerData then
		playerData.Coins.Value += 3000
	end
end]]></ProtectedString>
						<string name="ScriptGuid">{EE9F6340-20FD-4BC6-BA14-727F7AB44A68}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">HugeMoneyPack.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXAA6DA7A32FAC40CC8B9F0C47B402FBEE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[return function(player)
	local playerData = player:FindFirstChild("Player_Data")

	if playerData then
		playerData.Gems.Value += 500
	end
end]]></ProtectedString>
						<string name="ScriptGuid">{C11EDBB0-9911-4ACE-AD66-9DD3347FF18D}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">LargediamondsPack.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX80954C5381FF46D5AF3900C058DA92BE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[return function(player)
	local playerData = player:FindFirstChild("Player_Data")

	if playerData then
		playerData.Vip.Value = true
	end
end]]></ProtectedString>
						<string name="ScriptGuid">{7F145E24-84F5-41DF-981F-7939D3981A4C}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">VIP.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX14C29F34FE504D75AADDFDB58D8DA79D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Debug</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXEB123B6E212A45019D5150FC95759694">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">AdminConsole</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX1C9476F3A89E492AB08D07E9A0D92C36">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local player = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local remote = ReplicatedStorage:WaitForChild("Debug"):WaitForChild("DatastoreRemote")


-- get the ScreenGui, not the Frame
local gui = script.Parent
local frame = gui.Frame

-- Hide at start
gui.Enabled = false

player.Chatted:Connect(function(msg)
	if msg:lower() == "!console" then
		gui.Enabled = not gui.Enabled
	end
end)

local storeBox = frame.StoreBox
local keyBox = frame.KeyBox
local valueBox = frame.ValueBox
local output = frame.Output.TextLabel

local HttpService = game:GetService("HttpService")

local function log(msg)
	output.Text = output.Text .. "\n" .. msg
end

frame.ListBtn.MouseButton1Click:Connect(function()
	local result = remote:InvokeServer("list", storeBox.Text)
	if result.success then
		log("Keys: " .. table.concat(result.data, ", "))
	else
		log("Error: " .. tostring(result.message))
	end
end)

frame.GetBtn.MouseButton1Click:Connect(function()
	local result = remote:InvokeServer("get", storeBox.Text, keyBox.Text)
	if result.success then
		log("Value: " .. HttpService:JSONEncode(result.data))
	else
		log("Error: " .. tostring(result.message))
	end
end)

frame.SetBtn.MouseButton1Click:Connect(function()
	local result = remote:InvokeServer("set", storeBox.Text, keyBox.Text, valueBox.Text)
	log(result.success and "Value set" or "Set failed")
end)

frame.RemoveBtn.MouseButton1Click:Connect(function()
	local result = remote:InvokeServer("remove", storeBox.Text, keyBox.Text)
	log(result.success and "Key removed" or "Remove failed")
end)]]></ProtectedString>
							<string name="ScriptGuid">{FB51D89A-6137-4D84-83DA-74B5FBDE809D}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">LocalScript.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX4236F1BBD7494F3DACB4AE2762C829E7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GymEventConsole</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXD761DC9D9AC2422E8DC19FEBCAD0FA5B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local RS = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local gui = script.Parent
local Frame = gui.Main_F
local Launch_Test_B = Frame.Launch_B
local Count_Down_L = Frame.Countdown_L

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Gym_Reward_Testing = Channels.CS_Remote_Events.Gym_Reward_Testing


-- Hide at start
gui.Enabled = false

player.Chatted:Connect(function(msg)
	if msg:lower() == "!gymevent" then
		gui.Enabled = not gui.Enabled
	end
end)

Launch_Test_B.MouseButton1Click:Connect(function()
	if Launch_Test_B.Active then		
		Gym_Reward_Testing:FireServer()
	end
end)

Gym_Reward_Testing.OnClientEvent:Connect(function(active, i)
	Launch_Test_B.Visible = not active
	local msg = ""
	if active then
		if i==0 then
			msg = "Will start soon..."
		else
			msg = "⏳ Remaining time : " .. i .. "s"
		end
	end
	Count_Down_L.Text = msg
end)
]]></ProtectedString>
							<string name="ScriptGuid">{DB425A5A-54C9-4BCA-BE2D-7D5C199B11B4}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Gym_Event_Test_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX9BBF1180088140D19A15559A7ABDE0C4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Training_Bots</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXB626584EF8974402A89B781886AB93AA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Halloween</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX71026661B3614D2ABC503C928927E489">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Skeleton_Zombie</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX2031B0CF6499421A805906D941415862">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
								<string name="ScriptGuid">{3B164332-14BC-4D58-B01E-EA66B67D475A}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animate.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXC886B4DF324E49B9A854C4C94C978FBD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Init_AI_Training_Bot</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX676785507B074C3F8015D2D0B81B0C35">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local Init_E = script.Parent
local Char = Init_E.Parent

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Overhead_Display 			= Channels.SC_Remote_Events.Overhead_Display
local Got_Hit_Effect 			= Channels.SC_Remote_Events.Got_Hit_Effect
local AI_Training_Cage_Clinch	= Channels.Bindable_Events.AI_Training_Cage_Clinch
local AI_Training_Submission 	= Channels.Bindable_Events.AI_Training_Submission
local Ragdoll_Player			= Channels.Bindable_Events.Ragdoll_Player

local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")
local Head = Char:WaitForChild("Head")
local Fight_Data_F = Char:WaitForChild("Fight_Data")
local Stamina_V = Fight_Data_F:WaitForChild("Staminia") -- adjust name if it's 'Stamina'

-- Direct stamina regeneration for bot (server-side)
local function Reload_Stamina()
	while Stamina_V.Value < 40 do
		Stamina_V.Value = math.min(Stamina_V.Value + 1, 100) -- regen step, adjust as needed
		task.wait(0.1)
	end
end
local Fight_UI = Char:WaitForChild("Fighting_UI")
local Health_V = Fight_Data_F:WaitForChild("Health")
local Stam_V = Fight_Data_F:WaitForChild("Staminia")
local Block_Power_V = Fight_Data_F:WaitForChild("Block Power")
local Strike_Power_V = Fight_Data_F:WaitForChild("Strike Power")

local Fight_Walkspeed = 12
local Is_Active = false
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Get_Fighting_UI()
	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
		local Main_F = Fight_UI:FindFirstChild("Main_F") 
		local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
		if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
			return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
		end
	end

	return nil, nil
end

local function Reset_AI()
	Disconnect_Cons()

	Health_V.Value = 100
	Stam_V.Value = 100
	Block_Power_V.Value = 30
	Strike_Power_V.Value = 6

	if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
		HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
	end

	if(Hum ~= nil)then
		Hum.AutoRotate = false
		Hum.WalkSpeed = 12
		Hum.JumpPower = 0

		Animation_Mod.Reset_Character_Animations(Char)

		Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
	end

	Char:SetAttribute("Is_Fighting", false)
	Is_Active = false
end

local function Core_AI_Handle(T_Plr, T_Char)
	local T_HRP = T_Char:WaitForChild("HumanoidRootPart")
	local T_Fight_Data = T_Plr:FindFirstChild("Fight_Data")
	local T_Health_V = T_Fight_Data:WaitForChild("Health")
	local T_Stam_V = T_Fight_Data:WaitForChild("Staminia")
	local T_Block_Power_V = T_Fight_Data:WaitForChild("Block Power")
	local T_Strike_Power_V = T_Fight_Data:WaitForChild("Strike Power")
	local Is_Submission = false

	Char:SetAttribute("Is_Fighting", true)
	Reset_AI()
	Is_Active = true

	task.wait(3)
	if(Is_Active == false)then
		return
	end

	--Fight Data Changes
	table.insert(Cons, Health_V.Changed:Connect(function()
		if(Char ~= nil and Health_V.Value <= 0)then
			Ragdoll_Player:Fire(Char)
		end
	end))

	local function Create_BG()
		local OldG = HRP:FindFirstChildWhichIsA("BodyGyro")
		if(OldG ~= nil)then
			OldG:Destroy()
		end

		local bodyG = Instance.new("BodyGyro", HRP)
		bodyG.P = 1000
		bodyG.MaxTorque = Vector3.new(0, 1000, 0)
		bodyG.D = 10

		return bodyG
	end
	local BG = Create_BG()

	local function Movement_Handle()
		local function Update_Player_Movement()
			local function Get_Target_Position()
				if(T_HRP ~= nil)then
					local Move_Speed = T_HRP.Velocity
					local Def_Pos = T_HRP.Position + T_HRP.CFrame.LookVector * 3.5

					if(math.floor(Move_Speed.Magnitude) <= 0)then
						return Def_Pos, T_HRP.Position
					else
						local Ping = T_Plr:GetNetworkPing()
						local Dir = Move_Speed.Unit
						local Speed = Move_Speed.Magnitude
						local Extrapolated_Pos = Def_Pos + Dir * (Speed * Ping)
						local Travel_Time = ((Extrapolated_Pos - HRP.Position).Magnitude) / Hum.WalkSpeed
						return Extrapolated_Pos + Dir * (Hum.WalkSpeed * Travel_Time), Extrapolated_Pos
					end
				end

				return HRP.Position, HRP.Position + HRP.CFrame.LookVector * 3
			end
			local Move_Pos, Look_Pos = Get_Target_Position()

			BG.CFrame = CFrame.new(HRP.Position, Look_Pos)
			Hum:MoveTo(Move_Pos)
		end

		table.insert(Cons, RunService.Stepped:Connect(function()
			if(BG ~= nil and HRP ~= nil and Hum ~= nil and Hum.PlatformStand == false and T_Plr ~= nil and T_HRP ~= nil)then
				if(T_Health_V ~= nil and T_Health_V.Value > 0 and Is_Submission == false)then
					Update_Player_Movement()
				else
					Hum:MoveTo(HRP.Position)
				end
			end
		end))

		table.insert(Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
			if(Hum.PlatformStand == true)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			else
				BG.P = 1000
				BG.MaxTorque = Vector3.new(0, 1000, 0)
				BG.D = 10
			end
		end))
	end
	Movement_Handle()

	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
		Damage_UIG.Offset = Vector2.new(0, -0.5)
		Damage_Bar_Img.Visible = false
	end

	local function Create_Anim_Arr_Data(Anim_Track_Data)
		local D = {}
		for Key, Anim_Track in next, Anim_Track_Data do
			table.insert(D, Anim_Track)
		end
		return D
	end

	local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	local Combo_Strike_Index = 1
	local Combo_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(T_Plr, Hum, "Bot Combo")
	local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)

	local Debounce_Striking = false
	local Debounce_Dodge = false
	local Debounce_Blocking = false
	local Debounce_Takedown = false
	local Is_Hit = false

	local function Striking_Movement_Handle()
		--> Update Movement, Moving Forward or Backwards | Moving Left to Right | Standing Idle
		--> Track Humanoid MoveDirection
		table.insert(Cons, Hum:GetPropertyChangedSignal("WalkToPoint"):Connect(function()
			local Move_Speed = math.floor(HRP.Velocity.Magnitude)
			if(Move_Speed > 3 and Anim_Track_Data['Shuffle Forward'].IsPlaying == false)then
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				Anim_Track_Data['Shuffle Forward']:Play()
				Anim_Track_Data['Shuffle Forward']:AdjustSpeed(-1)

			elseif(Move_Speed <= 3 and 
				(Anim_Track_Data['Shuffle Forward'].IsPlaying == true or 
					Anim_Track_Data['Shuffle Side'].IsPlaying == true))then

				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
			end
		end))

		Anim_Track_Data['Idle']:Play()
		Anim_Track_Data['Idle']:AdjustSpeed(0.5)
	end
	Striking_Movement_Handle()

	local function On_Hit_Effects()
		--[[
			* When Health goes Down!
				> Camera Shake Effects
					-> Quick Shake
				> Apply Hit Effects
					-> Reset all Animations, Play the Hit One
				> Set Debounce till Hit Effect goes Away
		]]--

		local Prev_Health = Health_V.Value
		local Hit_Anim_Track = Striking_Anim_Tracks['Taking Hit']

		local function Show_Sweat_Effects()
			if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
				local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
				local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
				if(PE ~= nil)then
					PE:Emit(25)
				end
			end
		end

		table.insert(Cons, Health_V.Changed:Connect(function()
			local Current_V = Health_V.Value
			if(Current_V < Prev_Health and Is_Hit == false)then
				Is_Hit = true

				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Show_Sweat_Effects()

				task.spawn(function()
					Animation_Mod.Play_Animation_Track(Hit_Anim_Track)
					Is_Hit = false
				end)
			end

			Prev_Health = Current_V
		end))
	end
	On_Hit_Effects()

	local function Blocking_Effects()
		--[[
			* On Sheild Blocking Power goes down (Greater than 0) and Debounce_Blocking == true
			* Get the Opponent Handed Type
				> Play the Coresponding Animation
		]]--

		local Prev_Blocking = Block_Power_V.Value
		local Tween_Health_Con = nil
		local Tween_Stam_Con = nil
		local Tween_Block_Con = nil
		Block_Power_V:SetAttribute("Is_Blocking", false)

		local function Reset_Healing_Cons()
			if(Tween_Health_Con ~= nil)then
				Tween_Health_Con:Cancel()
				Tween_Health_Con = nil
			end

			if(Tween_Stam_Con ~= nil)then
				Tween_Stam_Con:Cancel()
				Tween_Stam_Con = nil
			end
		end

		local function Set_Healing_Cons()
			local Health_Time = math.clamp((100 - Health_V.Value) * 0.6, 0.6, 60)
			local Tween_Full_Health = TweenInfo.new(Health_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
			Tween_Health_Con = TS:Create(Health_V, Tween_Full_Health, {Value = 100})
			Tween_Health_Con:Play()

			local Stam_Time = math.clamp((100 - Stam_V.Value) * 0.1, 0.1, 10)
			local Tween_Full_Stam = TweenInfo.new(Stam_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)	
			Tween_Stam_Con = TS:Create(Stam_V, Tween_Full_Stam, {Value = 100})
			Tween_Stam_Con:Play()
		end

		table.insert(Cons, Block_Power_V.AttributeChanged:Connect(function(Attrib_Key)
			if(Attrib_Key == "Is_Blocking" and Block_Power_V:GetAttribute("Is_Blocking") ~= nil)then
				Reset_Healing_Cons()
				if(Block_Power_V:GetAttribute("Is_Blocking") == true)then
					Set_Healing_Cons()
				end
			end
		end))


		local function Update_Fight_Block_UI()
			if(Fight_UI ~= nil and Block_Power_V ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil and 
				Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then

				local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
				local Img = Sheild_F:FindFirstChild("Shield_Img")
				local Txt = Sheild_F:FindFirstChild("Shield_Txt")

				if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
					local UIG = Img:FindFirstChildWhichIsA("UIGradient")
					local Block_Power = Block_Power_V.Value
					local Dif =  math.clamp(Block_Power / 30, 0, 1)
					local Offset_Pos_Y = (1 - Dif) - 0.5

					UIG.Offset = Vector2.new(0, Offset_Pos_Y)
					Txt.Text = Block_Power .. ""
					if(Dif <= 0.25)then
						Txt.TextColor3 = Color3.new(1, 0, 0)
					else
						Txt.TextColor3 = Color3.new(1, 1, 1)
					end

				end
			end

		end

		table.insert(Cons, Block_Power_V.Changed:Connect(function()
			local Current_V = Block_Power_V.Value
			if(Current_V > 0 and Current_V < Prev_Blocking and Debounce_Blocking == true)then
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Striking_Anim_Tracks['Body Block Left'])

				if(Block_Power_V.Value < 30)then
					if(Tween_Block_Con ~= nil)then
						Tween_Block_Con:Cancel()
						Tween_Block_Con = nil
					end

					local Block_Time = math.clamp((30 - Block_Power_V.Value) * 0.2667, 0.2667, 8)
					local Tween_Block_Power = TweenInfo.new(Block_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 6)
					Tween_Block_Con = TS:Create(Block_Power_V, Tween_Block_Power, {Value = 30})
					Tween_Block_Con:Play()
					Tween_Block_Con.Completed:Wait()
					Tween_Block_Con = nil
				end
			end

			Update_Fight_Block_UI()
			Prev_Blocking = Current_V

		end))

	end
	Blocking_Effects()

	local function Get_Core_Strike_Handles()
		local Funcs = {}

		local function Has_Enough_Stam(Min_V)
			if(Stam_V ~= nil and Stam_V.Value >= Min_V)then
				Stam_V.Value -= Min_V
				return true
			end
			return false
		end

		local function Get_Player_To_Hit()
			local Whitelist_Chars = {T_Char}
			local Overlap_P = OverlapParams.new()
			Overlap_P.MaxParts = 1
			Overlap_P.FilterType = Enum.RaycastFilterType.Include
			Overlap_P.FilterDescendantsInstances = {Whitelist_Chars}

			local function Create_Region_CF()
				local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
				local Distance = (Speed + 3)
				local Head_Dir = Head.CFrame.LookVector
				local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

				local cframe = HRP.CFrame * CFrame.new(0, 0, -3)
				return cframe
			end
			local Spawn_CF = Create_Region_CF()
			local Hitbox_Size = Vector3.new(4, 8, 4)

			local function Create_Hitbox_Part()
				local P = Instance.new("Part", game.Workspace)
				P.Name = "Hitbox_Part"
				P.Anchored = true
				P.CanCollide = false
				P.Transparency = 0.5
				P.Color = Color3.new(1, 0, 0)
				P.Material = Enum.Material.SmoothPlastic
				P.Size = Hitbox_Size
				P.CFrame = Spawn_CF

				Debris:AddItem(P, 5)
			end
			--Create_Hitbox_Part()

			local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
			if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
				local function Get_Char_From_BP()
					for i = 1, #Whitelist_Chars do
						local C = Whitelist_Chars[i]
						if(C ~= nil and Region_Data[1]:IsDescendantOf(C))then
							return C
						end
					end

					return Whitelist_Chars[1]
				end

				return Get_Char_From_BP()
			end

			return nil
		end

		local function Get_Punch_Power()
			local Tween_Punch_Power_Back = TweenInfo.new(1.75, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
			local Strike_Power = Strike_Power_V.Value
			Strike_Power_V.Value = 0
			TS:Create(Strike_Power_V, Tween_Punch_Power_Back, {Value = 6}):Play()
			return Strike_Power
		end

		local function Get_Target_Fight_Data(Hit_Char)
			local Hit_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
			if(Hit_Plr ~= nil)then
				return Hit_Plr:FindFirstChild("Fight_Data")
			else
				return Hit_Char:FindFirstChild("Fight_Data")
			end
		end

		function Funcs.Strike_Handle()
			if Stamina_V.Value < 20 then Reload_Stamina() end
			--[[
				* Play Woosh Sound Effect locally
				* Play Animation
				* Tell the Server that you are Striking
			]]--

			Debounce_Striking = true
			-- AI is Striking!
			SE_Mod.PlaySFX(Char, "Punch_Woosh_SE")

			local function Play_Strike_Animation()
				local Track = Combo_Anim_Arr[Combo_Strike_Index]
				local Key = Track:GetAttribute("Strike_Key") or "A"

				task.spawn(function()
					if(HRP ~= nil and Has_Enough_Stam(10))then
						local Base_Punch_Power = Get_Punch_Power()
						local Hit_Char = Get_Player_To_Hit()
						local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Key)
						local Power_Inc = Strike_Data['Power Multi'] or 0
						local Punch_Power = math.ceil(Base_Punch_Power * (1  + Power_Inc))
						--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Strikes", 1)

						if(Hit_Char ~= nil)then
							local Hit_Fight_Data = Get_Target_Fight_Data(Hit_Char)
							if(Hit_Fight_Data ~= nil and Hit_Fight_Data:FindFirstChild("Health") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Block Power") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Staminia") ~= nil)then

								local T_Health = Hit_Fight_Data:FindFirstChild("Health")
								local T_Block_Power = Hit_Fight_Data:FindFirstChild("Block Power")
								local T_Staminia = Hit_Fight_Data:FindFirstChild("Staminia")

								local function Is_Dodging_Check()
									local Is_Dodging = T_Staminia:GetAttribute("Is_Dodging")
									if(Is_Dodging ~= nil and Is_Dodging == true)then
										local Target_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if(Target_Plr ~= nil)then
											Stats_Manager_Mod.Add_To_Player_Stats_Data(Target_Plr, "Dodged Strikes", 1)
										end

										return true
									end
									return false
								end

								local function Is_Blocking_Check()
									local Is_Block = T_Block_Power:GetAttribute("Is_Blocking")
									if(Is_Block ~= nil and Is_Block == true)then
										T_Block_Power.Value -= Punch_Power
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.fromRGB(170, 85, 255))

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										if(T_Block_Power.Value < 0)then
											local Dif = math.abs(T_Block_Power.Value)
											T_Health.Value = math.clamp(T_Health.Value - Dif, 0, 100)
											T_Block_Power.Value = 0

											SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
											--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)

											Overhead_Display:FireAllClients(Hit_Char, "-" .. Dif, Color3.new(1, 0, 0))

										else
											SE_Mod.PlaySFX(HRP, "Blocked_Hit_SE")	
										end

										return true
									end

									return false
								end

								if(Is_Dodging_Check())then
									--Play Dodging Text
									Overhead_Display:FireAllClients(Hit_Char, "Dodged", Color3.fromRGB(35, 244, 68))
								elseif(Is_Blocking_Check())then
									--Play Blocking 
								else
									--Apply the Hit
									local function Apply_Strike()
										T_Health.Value = math.clamp(T_Health.Value - Punch_Power, 0, 100)
										SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
										--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.new(1, 0, 0))
										--Punch_Hit_VFX:FireClient(Plr, Hit_Char)
										--Play Damage Val Show

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										local T_HRP = Hit_Char:FindFirstChild("HumanoidRootPart")
										if(T_HRP ~= nil)then
											local Hit_Force = 625 -- Was 350 then 500
											local Dir = HRP.CFrame.LookVector 
											T_HRP:ApplyImpulse(Dir * Hit_Force * T_HRP:GetMass())
										end
									end
									Apply_Strike()
								end
							end

						end
					end
				end)

				Combo_Strike_Index += 1
				if(Combo_Strike_Index > #Combo_Anim_Arr)then
					Combo_Strike_Index = 1
				end

				Animation_Mod.Stop_Animation_Tracks(Combo_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Track)
			end
			task.spawn(Play_Strike_Animation)
			task.wait(0.5)

			Debounce_Striking = false
		end

		local Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left']
		local Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		local Back_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		function Funcs.Dodge_Handle(Dodge_Type)
			--[[
				* Get the Type First
					-> First Index? Just play the Slip Animation
					-> 2nd Index? Play the Dodge Animation AND apply Force to the Player in the direction
				
					-> Tell the Server that you are Dodging and should reduce Staminia Value
			]]--

			Debounce_Dodge = true
			-- AI is Dodging

			local function Apply_Force(Dir)
				HRP:ApplyImpulse(Dir * (Fight_Walkspeed * 65) * HRP:GetMass())
			end

			task.spawn(function()
				if(Has_Enough_Stam(5))then
					--Play the Sound Effect
					--Toggle Value
					SE_Mod.PlaySFX(HRP, "Missed_SE")
					Stam_V:SetAttribute("Is_Dodging", true)
					task.wait(0.5)
					Stam_V:SetAttribute("Is_Dodging", false)
				end
			end)
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})

			local function Increment_Anim()
				if(Dodge_Type == "Dodge Left")then
					if(Left_Dodge_Ani == Striking_Anim_Tracks['Slip Left'])then
						Left_Dodge_Ani = Striking_Anim_Tracks['Headblock Left']
					else
						Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left'] 
					end
				else
					--Right
					if(Right_Dodge_Ani == Striking_Anim_Tracks['Slip Right'])then
						Right_Dodge_Ani = Striking_Anim_Tracks['Headblock Right']
					else
						Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right'] 
					end
				end
			end

			if(Dodge_Type == "Dodge Left")then
				--Left
				if(Left_Dodge_Ani == Striking_Anim_Tracks['Headblock Left'])then
					--Apply_Force(HRP.CFrame.RightVector * -1)
				end
				Apply_Force(HRP.CFrame.RightVector * -1)
				Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Right")then
				--Right
				if(Right_Dodge_Ani == Striking_Anim_Tracks['Headblock Right'])then
					--Apply_Force(HRP.CFrame.RightVector)
				end
				Apply_Force(HRP.CFrame.RightVector)
				Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Back")then
				Apply_Force(HRP.CFrame.LookVector * -1)
				Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
			end

			Debounce_Dodge = false
		end

		local function Toggle_Sheild_Icon(Is_Enabled)
			local Main_F =  Fight_UI:FindFirstChild("Main_F")
			if(Main_F ~= nil and Main_F:FindFirstChild("Shield_F") ~= nil)then
				local SF = Main_F:FindFirstChild("Shield_F")
				SF.Visible = true
				
				local Img = SF:FindFirstChild("Shield_Img")
				if(Img ~= nil)then
					if(Is_Enabled)then
						Img.Image = "rbxassetid://130871917395731"
					else
						Img.Image = "rbxassetid://125284121534949"
					end
				end
			end
		end

		local function Toggle_Heal_PE(Is_Enabled)
			local PE = HRP:GetChildren()
			for i = 1, #PE do
				if(PE[i] ~= nil and PE[i].Name == "Heal_PE" and PE[i]:IsA("ParticleEmitter"))then
					PE[i].Enabled = Is_Enabled
				end
			end

			Toggle_Sheild_Icon(Is_Enabled)
		end

		local Low_Block_Con = nil
		local function Disable_Blocking_Handle()
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed
			end

			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Block_Power_V:SetAttribute("Is_Blocking", false)
			Toggle_Heal_PE(false)

			Debounce_Blocking = false
		end

		local function Play_Blocking_Animation()
			local Anim_Track = Striking_Anim_Tracks['Main Block']
			if(Anim_Track ~= nil)then
				Anim_Track:Play()
				Anim_Track:AdjustSpeed(1)
				task.wait(Anim_Track.Length * 0.9)

				if(Anim_Track ~= nil and Debounce_Blocking == true)then
					Anim_Track:AdjustSpeed(0)
				end
			end
		end

		function Funcs.Disable_Blocking_Handle()
			-- AI is turning off Blocking
			Disable_Blocking_Handle()
		end

		function Funcs.Blocking_Handle()
			Debounce_Blocking = true
			-- AI Is Blocking

			if(Hum ~= nil)then
				Hum.WalkSpeed = 8
			end

			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			Low_Block_Con = Block_Power_V.Changed:Connect(function()
				if(Block_Power_V.Value <= 0 and Debounce_Blocking == true)then
					if(Low_Block_Con ~= nil)then
						Low_Block_Con:Disconnect()
						Low_Block_Con = nil
					end

					Disable_Blocking_Handle()
				end
			end)
			table.insert(Cons, Low_Block_Con)
			task.spawn(Play_Blocking_Animation)

			if(Block_Power_V ~= nil and Block_Power_V.Value > 0)then
				Block_Power_V:SetAttribute("Is_Blocking", true)
				Toggle_Heal_PE(true)
			end
		end

		function Funcs.Get_Hitbox_Res()
			return (Get_Player_To_Hit() ~= nil)
		end		

		function Funcs.Get_Dodge_Type()
			local function Get_Ray_Distance_Data()
				local Origin = HRP.Position
				local Ray_Parm = RaycastParams.new()
				Ray_Parm.FilterType = Enum.RaycastFilterType.Exclude
				Ray_Parm.FilterDescendantsInstances = {Char, T_Char}

				local function Get_Ray_Dist(Dir)
					local Ray_Res = game.Workspace:Raycast(Origin, Dir * 10, Ray_Parm)
					if(Ray_Res ~= nil and Ray_Res.Distance ~= nil)then
						return Ray_Res.Distance
					end
					return 15
				end

				return {
					{
						['Type'] = "Dodge Back",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.LookVector * -1)
					},

					{
						['Type'] = "Dodge Left",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector * -1)
					},

					{
						['Type'] = "Dodge Right",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector)
					},

				}
			end
			local Ray_Dist_Arr = Get_Ray_Distance_Data()

			table.sort(Ray_Dist_Arr, function(A, B)
				return A['Distance'] > B['Distance']
			end)

			return Ray_Dist_Arr[1]['Type']
		end

		function Funcs.Is_Player_Striking_You()
			if(T_Strike_Power_V ~= nil and T_Strike_Power_V.Value < 4)then
				return true
			end
			return false
		end

		return Funcs
	end
	local Core_Strike_Funcs = Get_Core_Strike_Handles()

	--[[
		Core AI Decision Making goes here
		
		* If within Striking Distance ~ 5 Studs
			* If Player is Striking too, Dodge Left Right or Back (Max 2 Dodges)
			* Has to Strike (Max 3 Strikes)
				* Dodge Back if Strike (or left or Right)
		* Default to Blocking Handle
	]]--

	local function Submission_Handle(Is_Submitting, Attacking_Char)
		Animation_Mod.Reset_Character_Animations(Char)
		if(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end

		if(Is_Submitting)then
			Is_Submission = true
			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end

			if(HRP ~= nil)then
				--HRP.Anchored = true
				--HRP.CFrame *= CFrame.new(Vector3.new(0, 0.15, 0))
			end

			--> Play Animation
			--> Get Submission Character & Player
			--> Get their Takedown and Submission Data

			--> If Attacking Player, Set HRP CFrame Position
			--> Play Take Down Animation

			--> Play Submission Animation
			--> Play Submission Loop Animation

			local function Get_Takedown_Submission_Tracks()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)
				return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Receiving ID'], Submission_Data['Receiving ID'], Submission_Data['Receiving Loop ID'])
			end
			local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()

			Takedown_Track.Priority = Enum.AnimationPriority.Action2
			Animation_Mod.Play_Animation_Track(Takedown_Track, true)

			task.wait(0.25)

			Submission_Track.Priority = Enum.AnimationPriority.Action3
			Animation_Mod.Play_Animation_Track(Submission_Track)

			Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
		else
			Is_Hit = false

			if(HRP ~= nil)then
				HRP.Anchored = false
			end

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
			Is_Submission = false
		end
	end

	table.insert(Cons, AI_Training_Submission.Event:Connect(function(AI_Char, Attacking_Char, Is_Submitting)
		if(AI_Char == Char)then
			Submission_Handle(Is_Submitting, Attacking_Char)
		end
	end))


	local function Clinch_Handle(Animation_Sequence_Data, Is_Attacking)
		local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(Char)

			if(Debounce_Blocking == true)then
				task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
			end

			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
		end
		Freeze_Character()

		local function Play_Strike_Sequences()
			local Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
			Animation_Mod.Play_Animation_Track(Clinch_Tracks_Data['Init_Clinch'], true)
			task.spawn(Animation_Mod.Play_Animation_Track, Clinch_Tracks_Data['Loop_Clinch'])
			task.wait(1)

			for i = 1, #Animation_Sequence_Data do
				local Strike_Key = Animation_Sequence_Data[i]
				local Strike_Track = Clinch_Tracks_Data[Strike_Key]

				if(Strike_Track ~= nil)then
					--Play Flash, Play Hit Sound Effect, Quick Camera Shake
					Animation_Mod.Play_Animation_Track(Strike_Track)
					--wait(0.5)
				end
			end

		end
		Play_Strike_Sequences()

		local function Clinch_Reset_Handle()
			Animation_Mod.Reset_Character_Animations(Char)
			Is_Hit = false

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
		end	
		Clinch_Reset_Handle()
	end

	table.insert(Cons, AI_Training_Cage_Clinch.Event:Connect(function(AI_Char, Sequence_Keys, Is_Attacking)
		if(AI_Char == Char)then
			Clinch_Handle(Sequence_Keys, Is_Attacking)
		end
	end))


	local Strike_Count, Dodge_Count = 0, 0
	local function Main_AI_Logic_Gate()
		if(Health_V.Value > 0 and Is_Hit == false and T_Health_V ~= nil and T_Health_V.Value > 0)then
			if(Core_Strike_Funcs.Get_Hitbox_Res())then -- Within Strike Zone
				local Is_Player_Hitting_You = Core_Strike_Funcs.Is_Player_Striking_You()
				if(Is_Player_Hitting_You)then
					--Take the HIts until you're below 20 Block Power
					-- Dodge? or Strike
					if(Block_Power_V.Value > 10)then
						if(Dodge_Count < 2 or Strike_Count >= 3)then
							--Dodge
							if(Debounce_Dodge == false and Stam_V.Value >= 5)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								local Dodge_Type = Core_Strike_Funcs.Get_Dodge_Type()
								Core_Strike_Funcs.Dodge_Handle(Dodge_Type)

								Dodge_Count += 1
								if(Strike_Count >= 3)then
									Strike_Count = 0
								end
							end

						else
							--Strike
							if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								Core_Strike_Funcs.Strike_Handle()
								Strike_Count += 1
								if(Dodge_Count >= 2)then
									Dodge_Count = 0
								end
							end
						end
					elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
						--Not within Strike Zone, resort to Blocking
						Core_Strike_Funcs.Blocking_Handle()
					end
				else
					--Strike
					if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
						if(Debounce_Blocking == true)then
							task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
						end

						Core_Strike_Funcs.Strike_Handle()
						Strike_Count += 1
						if(Dodge_Count >= 2)then
							Dodge_Count = 0
						end
					end
				end
			elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
				--Not within Strike Zone, resort to Blocking
				Core_Strike_Funcs.Blocking_Handle()
			end

		elseif(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end
	end

	while Is_Active do
		if(Is_Submission == false)then
			Main_AI_Logic_Gate()
		end
		task.wait(0.5)
	end
end

Init_E.Event:Connect(function(T_Plr, T_Char,OtherStuff)	
	if(Is_Active == false and T_Plr ~= nil and T_Char ~= nil)then
		Core_AI_Handle(T_Plr, T_Char)
	elseif(Is_Active)then
		Reset_AI()
	end
end)]]></ProtectedString>
									<string name="ScriptGuid">{4977CC66-2ED3-49F0-91BE-F843F690B558}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AI_Training_Bot_Handle.server.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX5C1E15D4A66F44DF900378879CB457D3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Stiches_Zombie</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX5BB5E19D6CEF49009651DA27CE5AC5C4">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
								<string name="ScriptGuid">{1AB27FFA-90A3-4BD3-860A-891AE319005E}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animate.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX664B02B12B2D4EF4B5F7727353531F93">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Init_AI_Training_Bot</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXB0C5652D791C4C22B01EFD49FF165E15">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local Init_E = script.Parent
local Char = Init_E.Parent

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Overhead_Display 			= Channels.SC_Remote_Events.Overhead_Display
local Got_Hit_Effect 			= Channels.SC_Remote_Events.Got_Hit_Effect
local AI_Training_Cage_Clinch	= Channels.Bindable_Events.AI_Training_Cage_Clinch
local AI_Training_Submission 	= Channels.Bindable_Events.AI_Training_Submission
local Ragdoll_Player			= Channels.Bindable_Events.Ragdoll_Player

local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")
local Head = Char:WaitForChild("Head")
local Fight_Data_F = Char:WaitForChild("Fight_Data")
local Stamina_V = Fight_Data_F:WaitForChild("Staminia") -- adjust name if it's 'Stamina'

-- Direct stamina regeneration for bot (server-side)
local function Reload_Stamina()
	while Stamina_V.Value < 40 do
		Stamina_V.Value = math.min(Stamina_V.Value + 1, 100) -- regen step, adjust as needed
		task.wait(0.1)
	end
end
local Fight_UI = Char:WaitForChild("Fighting_UI")
local Health_V = Fight_Data_F:WaitForChild("Health")
local Stam_V = Fight_Data_F:WaitForChild("Staminia")
local Block_Power_V = Fight_Data_F:WaitForChild("Block Power")
local Strike_Power_V = Fight_Data_F:WaitForChild("Strike Power")

local Fight_Walkspeed = 12
local Is_Active = false
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Get_Fighting_UI()
	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
		local Main_F = Fight_UI:FindFirstChild("Main_F") 
		local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
		if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
			return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
		end
	end

	return nil, nil
end

local function Reset_AI()
	Disconnect_Cons()

	Health_V.Value = 100
	Stam_V.Value = 100
	Block_Power_V.Value = 30
	Strike_Power_V.Value = 6

	if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
		HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
	end

	if(Hum ~= nil)then
		Hum.AutoRotate = false
		Hum.WalkSpeed = 12
		Hum.JumpPower = 0

		Animation_Mod.Reset_Character_Animations(Char)

		Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
	end

	Char:SetAttribute("Is_Fighting", false)
	Is_Active = false
end

local function Core_AI_Handle(T_Plr, T_Char)
	local T_HRP = T_Char:WaitForChild("HumanoidRootPart")
	local T_Fight_Data = T_Plr:FindFirstChild("Fight_Data")
	local T_Health_V = T_Fight_Data:WaitForChild("Health")
	local T_Stam_V = T_Fight_Data:WaitForChild("Staminia")
	local T_Block_Power_V = T_Fight_Data:WaitForChild("Block Power")
	local T_Strike_Power_V = T_Fight_Data:WaitForChild("Strike Power")
	local Is_Submission = false

	Char:SetAttribute("Is_Fighting", true)
	Reset_AI()
	Is_Active = true

	task.wait(3)
	if(Is_Active == false)then
		return
	end

	--Fight Data Changes
	table.insert(Cons, Health_V.Changed:Connect(function()
		if(Char ~= nil and Health_V.Value <= 0)then
			Ragdoll_Player:Fire(Char)
		end
	end))

	local function Create_BG()
		local OldG = HRP:FindFirstChildWhichIsA("BodyGyro")
		if(OldG ~= nil)then
			OldG:Destroy()
		end

		local bodyG = Instance.new("BodyGyro", HRP)
		bodyG.P = 1000
		bodyG.MaxTorque = Vector3.new(0, 1000, 0)
		bodyG.D = 10

		return bodyG
	end
	local BG = Create_BG()

	local function Movement_Handle()
		local function Update_Player_Movement()
			local function Get_Target_Position()
				if(T_HRP ~= nil)then
					local Move_Speed = T_HRP.Velocity
					local Def_Pos = T_HRP.Position + T_HRP.CFrame.LookVector * 3.5

					if(math.floor(Move_Speed.Magnitude) <= 0)then
						return Def_Pos, T_HRP.Position
					else
						local Ping = T_Plr:GetNetworkPing()
						local Dir = Move_Speed.Unit
						local Speed = Move_Speed.Magnitude
						local Extrapolated_Pos = Def_Pos + Dir * (Speed * Ping)
						local Travel_Time = ((Extrapolated_Pos - HRP.Position).Magnitude) / Hum.WalkSpeed
						return Extrapolated_Pos + Dir * (Hum.WalkSpeed * Travel_Time), Extrapolated_Pos
					end
				end

				return HRP.Position, HRP.Position + HRP.CFrame.LookVector * 3
			end
			local Move_Pos, Look_Pos = Get_Target_Position()

			BG.CFrame = CFrame.new(HRP.Position, Look_Pos)
			Hum:MoveTo(Move_Pos)
		end

		table.insert(Cons, RunService.Stepped:Connect(function()
			if(BG ~= nil and HRP ~= nil and Hum ~= nil and Hum.PlatformStand == false and T_Plr ~= nil and T_HRP ~= nil)then
				if(T_Health_V ~= nil and T_Health_V.Value > 0 and Is_Submission == false)then
					Update_Player_Movement()
				else
					Hum:MoveTo(HRP.Position)
				end
			end
		end))

		table.insert(Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
			if(Hum.PlatformStand == true)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			else
				BG.P = 1000
				BG.MaxTorque = Vector3.new(0, 1000, 0)
				BG.D = 10
			end
		end))
	end
	Movement_Handle()

	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
		Damage_UIG.Offset = Vector2.new(0, -0.5)
		Damage_Bar_Img.Visible = false
	end

	local function Create_Anim_Arr_Data(Anim_Track_Data)
		local D = {}
		for Key, Anim_Track in next, Anim_Track_Data do
			table.insert(D, Anim_Track)
		end
		return D
	end

	local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	local Combo_Strike_Index = 1
	local Combo_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(T_Plr, Hum, "Bot Combo")
	local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)

	local Debounce_Striking = false
	local Debounce_Dodge = false
	local Debounce_Blocking = false
	local Debounce_Takedown = false
	local Is_Hit = false

	local function Striking_Movement_Handle()
		--> Update Movement, Moving Forward or Backwards | Moving Left to Right | Standing Idle
		--> Track Humanoid MoveDirection
		table.insert(Cons, Hum:GetPropertyChangedSignal("WalkToPoint"):Connect(function()
			local Move_Speed = math.floor(HRP.Velocity.Magnitude)
			if(Move_Speed > 3 and Anim_Track_Data['Shuffle Forward'].IsPlaying == false)then
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				Anim_Track_Data['Shuffle Forward']:Play()
				Anim_Track_Data['Shuffle Forward']:AdjustSpeed(-1)

			elseif(Move_Speed <= 3 and 
				(Anim_Track_Data['Shuffle Forward'].IsPlaying == true or 
					Anim_Track_Data['Shuffle Side'].IsPlaying == true))then

				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
			end
		end))

		Anim_Track_Data['Idle']:Play()
		Anim_Track_Data['Idle']:AdjustSpeed(0.5)
	end
	Striking_Movement_Handle()

	local function On_Hit_Effects()
		--[[
			* When Health goes Down!
				> Camera Shake Effects
					-> Quick Shake
				> Apply Hit Effects
					-> Reset all Animations, Play the Hit One
				> Set Debounce till Hit Effect goes Away
		]]--

		local Prev_Health = Health_V.Value
		local Hit_Anim_Track = Striking_Anim_Tracks['Taking Hit']

		local function Show_Sweat_Effects()
			if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
				local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
				local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
				if(PE ~= nil)then
					PE:Emit(25)
				end
			end
		end

		table.insert(Cons, Health_V.Changed:Connect(function()
			local Current_V = Health_V.Value
			if(Current_V < Prev_Health and Is_Hit == false)then
				Is_Hit = true

				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Show_Sweat_Effects()

				task.spawn(function()
					Animation_Mod.Play_Animation_Track(Hit_Anim_Track)
					Is_Hit = false
				end)
			end

			Prev_Health = Current_V
		end))
	end
	On_Hit_Effects()

	local function Blocking_Effects()
		--[[
			* On Sheild Blocking Power goes down (Greater than 0) and Debounce_Blocking == true
			* Get the Opponent Handed Type
				> Play the Coresponding Animation
		]]--

		local Prev_Blocking = Block_Power_V.Value
		local Tween_Health_Con = nil
		local Tween_Stam_Con = nil
		local Tween_Block_Con = nil
		Block_Power_V:SetAttribute("Is_Blocking", false)

		local function Reset_Healing_Cons()
			if(Tween_Health_Con ~= nil)then
				Tween_Health_Con:Cancel()
				Tween_Health_Con = nil
			end

			if(Tween_Stam_Con ~= nil)then
				Tween_Stam_Con:Cancel()
				Tween_Stam_Con = nil
			end
		end

		local function Set_Healing_Cons()
			local Health_Time = math.clamp((100 - Health_V.Value) * 0.6, 0.6, 60)
			local Tween_Full_Health = TweenInfo.new(Health_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
			Tween_Health_Con = TS:Create(Health_V, Tween_Full_Health, {Value = 100})
			Tween_Health_Con:Play()

			local Stam_Time = math.clamp((100 - Stam_V.Value) * 0.1, 0.1, 10)
			local Tween_Full_Stam = TweenInfo.new(Stam_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)	
			Tween_Stam_Con = TS:Create(Stam_V, Tween_Full_Stam, {Value = 100})
			Tween_Stam_Con:Play()
		end

		table.insert(Cons, Block_Power_V.AttributeChanged:Connect(function(Attrib_Key)
			if(Attrib_Key == "Is_Blocking" and Block_Power_V:GetAttribute("Is_Blocking") ~= nil)then
				Reset_Healing_Cons()
				if(Block_Power_V:GetAttribute("Is_Blocking") == true)then
					Set_Healing_Cons()
				end
			end
		end))


		local function Update_Fight_Block_UI()
			if(Fight_UI ~= nil and Block_Power_V ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil and 
				Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then

				local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
				local Img = Sheild_F:FindFirstChild("Shield_Img")
				local Txt = Sheild_F:FindFirstChild("Shield_Txt")

				if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
					local UIG = Img:FindFirstChildWhichIsA("UIGradient")
					local Block_Power = Block_Power_V.Value
					local Dif =  math.clamp(Block_Power / 30, 0, 1)
					local Offset_Pos_Y = (1 - Dif) - 0.5

					UIG.Offset = Vector2.new(0, Offset_Pos_Y)
					Txt.Text = Block_Power .. ""
					if(Dif <= 0.25)then
						Txt.TextColor3 = Color3.new(1, 0, 0)
					else
						Txt.TextColor3 = Color3.new(1, 1, 1)
					end

				end
			end

		end

		table.insert(Cons, Block_Power_V.Changed:Connect(function()
			local Current_V = Block_Power_V.Value
			if(Current_V > 0 and Current_V < Prev_Blocking and Debounce_Blocking == true)then
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Striking_Anim_Tracks['Body Block Left'])

				if(Block_Power_V.Value < 30)then
					if(Tween_Block_Con ~= nil)then
						Tween_Block_Con:Cancel()
						Tween_Block_Con = nil
					end

					local Block_Time = math.clamp((30 - Block_Power_V.Value) * 0.2667, 0.2667, 8)
					local Tween_Block_Power = TweenInfo.new(Block_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 6)
					Tween_Block_Con = TS:Create(Block_Power_V, Tween_Block_Power, {Value = 30})
					Tween_Block_Con:Play()
					Tween_Block_Con.Completed:Wait()
					Tween_Block_Con = nil
				end
			end

			Update_Fight_Block_UI()
			Prev_Blocking = Current_V

		end))

	end
	Blocking_Effects()

	local function Get_Core_Strike_Handles()
		local Funcs = {}
		
		local function Has_Enough_Stam(Min_V)
			if(Stam_V ~= nil and Stam_V.Value >= Min_V)then
				Stam_V.Value -= Min_V
				return true
			end
			return false
		end

		local function Get_Player_To_Hit()
			local Whitelist_Chars = {T_Char}
			local Overlap_P = OverlapParams.new()
			Overlap_P.MaxParts = 1
			Overlap_P.FilterType = Enum.RaycastFilterType.Include
			Overlap_P.FilterDescendantsInstances = {Whitelist_Chars}

			local function Create_Region_CF()
				local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
				local Distance = (Speed + 3)
				local Head_Dir = Head.CFrame.LookVector
				local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

				local cframe = HRP.CFrame * CFrame.new(0, 0, -3)
				return cframe
			end
			local Spawn_CF = Create_Region_CF()
			local Hitbox_Size = Vector3.new(4, 8, 4)

			local function Create_Hitbox_Part()
				local P = Instance.new("Part", game.Workspace)
				P.Name = "Hitbox_Part"
				P.Anchored = true
				P.CanCollide = false
				P.Transparency = 0.5
				P.Color = Color3.new(1, 0, 0)
				P.Material = Enum.Material.SmoothPlastic
				P.Size = Hitbox_Size
				P.CFrame = Spawn_CF

				Debris:AddItem(P, 5)
			end
			--Create_Hitbox_Part()

			local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
			if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
				local function Get_Char_From_BP()
					for i = 1, #Whitelist_Chars do
						local C = Whitelist_Chars[i]
						if(C ~= nil and Region_Data[1]:IsDescendantOf(C))then
							return C
						end
					end

					return Whitelist_Chars[1]
				end

				return Get_Char_From_BP()
			end

			return nil
		end

		local function Get_Punch_Power()
			local Tween_Punch_Power_Back = TweenInfo.new(1.75, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
			local Strike_Power = Strike_Power_V.Value
			Strike_Power_V.Value = 0
			TS:Create(Strike_Power_V, Tween_Punch_Power_Back, {Value = 6}):Play()
			return Strike_Power
		end

		local function Get_Target_Fight_Data(Hit_Char)
			local Hit_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
			if(Hit_Plr ~= nil)then
				return Hit_Plr:FindFirstChild("Fight_Data")
			else
				return Hit_Char:FindFirstChild("Fight_Data")
			end
		end

		function Funcs.Strike_Handle()
			if Stamina_V.Value < 20 then Reload_Stamina() end
			--[[
				* Play Woosh Sound Effect locally
				* Play Animation
				* Tell the Server that you are Striking
			]]--

			Debounce_Striking = true
			-- AI is Striking!
			SE_Mod.PlaySFX(Char, "Punch_Woosh_SE")

			local function Play_Strike_Animation()
				local Track = Combo_Anim_Arr[Combo_Strike_Index]
				local Key = Track:GetAttribute("Strike_Key") or "A"

				task.spawn(function()
					if(HRP ~= nil and Has_Enough_Stam(10))then
						local Base_Punch_Power = Get_Punch_Power()
						local Hit_Char = Get_Player_To_Hit()
						local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Key)
						local Power_Inc = Strike_Data['Power Multi'] or 0
						local Punch_Power = math.ceil(Base_Punch_Power * (1  + Power_Inc))
						--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Strikes", 1)

						if(Hit_Char ~= nil)then
							local Hit_Fight_Data = Get_Target_Fight_Data(Hit_Char)
							if(Hit_Fight_Data ~= nil and Hit_Fight_Data:FindFirstChild("Health") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Block Power") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Staminia") ~= nil)then

								local T_Health = Hit_Fight_Data:FindFirstChild("Health")
								local T_Block_Power = Hit_Fight_Data:FindFirstChild("Block Power")
								local T_Staminia = Hit_Fight_Data:FindFirstChild("Staminia")

								local function Is_Dodging_Check()
									local Is_Dodging = T_Staminia:GetAttribute("Is_Dodging")
									if(Is_Dodging ~= nil and Is_Dodging == true)then
										local Target_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if(Target_Plr ~= nil)then
											Stats_Manager_Mod.Add_To_Player_Stats_Data(Target_Plr, "Dodged Strikes", 1)
										end

										return true
									end
									return false
								end

								local function Is_Blocking_Check()
									local Is_Block = T_Block_Power:GetAttribute("Is_Blocking")
									if(Is_Block ~= nil and Is_Block == true)then
										T_Block_Power.Value -= Punch_Power
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.fromRGB(170, 85, 255))

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										if(T_Block_Power.Value < 0)then
											local Dif = math.abs(T_Block_Power.Value)
											T_Health.Value = math.clamp(T_Health.Value - Dif, 0, 100)
											T_Block_Power.Value = 0

											SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
											--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)

											Overhead_Display:FireAllClients(Hit_Char, "-" .. Dif, Color3.new(1, 0, 0))

										else
											SE_Mod.PlaySFX(HRP, "Blocked_Hit_SE")	
										end

										return true
									end

									return false
								end

								if(Is_Dodging_Check())then
									--Play Dodging Text
									Overhead_Display:FireAllClients(Hit_Char, "Dodged", Color3.fromRGB(35, 244, 68))
								elseif(Is_Blocking_Check())then
									--Play Blocking 
								else
									--Apply the Hit
									local function Apply_Strike()
										T_Health.Value = math.clamp(T_Health.Value - Punch_Power, 0, 100)
										SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
										--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.new(1, 0, 0))
										--Punch_Hit_VFX:FireClient(Plr, Hit_Char)
										--Play Damage Val Show

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										local T_HRP = Hit_Char:FindFirstChild("HumanoidRootPart")
										if(T_HRP ~= nil)then
											local Hit_Force = 625 -- Was 350 then 500
											local Dir = HRP.CFrame.LookVector 
											T_HRP:ApplyImpulse(Dir * Hit_Force * T_HRP:GetMass())
										end
									end
									Apply_Strike()
								end
							end

						end
					end
				end)

				Combo_Strike_Index += 1
				if(Combo_Strike_Index > #Combo_Anim_Arr)then
					Combo_Strike_Index = 1
				end

				Animation_Mod.Stop_Animation_Tracks(Combo_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Track)
			end
			task.spawn(Play_Strike_Animation)
			task.wait(0.5)

			Debounce_Striking = false
		end

		local Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left']
		local Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		local Back_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		function Funcs.Dodge_Handle(Dodge_Type)
			--[[
				* Get the Type First
					-> First Index? Just play the Slip Animation
					-> 2nd Index? Play the Dodge Animation AND apply Force to the Player in the direction
				
					-> Tell the Server that you are Dodging and should reduce Staminia Value
			]]--

			Debounce_Dodge = true
			-- AI is Dodging

			local function Apply_Force(Dir)
				HRP:ApplyImpulse(Dir * (Fight_Walkspeed * 65) * HRP:GetMass())
			end

			task.spawn(function()
				if(Has_Enough_Stam(5))then
					--Play the Sound Effect
					--Toggle Value
					SE_Mod.PlaySFX(HRP, "Missed_SE")
					Stam_V:SetAttribute("Is_Dodging", true)
					task.wait(0.5)
					Stam_V:SetAttribute("Is_Dodging", false)
				end
			end)
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})

			local function Increment_Anim()
				if(Dodge_Type == "Dodge Left")then
					if(Left_Dodge_Ani == Striking_Anim_Tracks['Slip Left'])then
						Left_Dodge_Ani = Striking_Anim_Tracks['Headblock Left']
					else
						Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left'] 
					end
				else
					--Right
					if(Right_Dodge_Ani == Striking_Anim_Tracks['Slip Right'])then
						Right_Dodge_Ani = Striking_Anim_Tracks['Headblock Right']
					else
						Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right'] 
					end
				end
			end

			if(Dodge_Type == "Dodge Left")then
				--Left
				if(Left_Dodge_Ani == Striking_Anim_Tracks['Headblock Left'])then
					--Apply_Force(HRP.CFrame.RightVector * -1)
				end
				Apply_Force(HRP.CFrame.RightVector * -1)
				Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Right")then
				--Right
				if(Right_Dodge_Ani == Striking_Anim_Tracks['Headblock Right'])then
					--Apply_Force(HRP.CFrame.RightVector)
				end
				Apply_Force(HRP.CFrame.RightVector)
				Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Back")then
				Apply_Force(HRP.CFrame.LookVector * -1)
				Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
			end

			Debounce_Dodge = false
		end

		local function Toggle_Sheild_Icon(Is_Enabled)
			local Main_F =  Fight_UI:FindFirstChild("Main_F")
			if(Main_F ~= nil and Main_F:FindFirstChild("Shield_F") ~= nil)then
				local SF = Main_F:FindFirstChild("Shield_F")
				SF.Visible = true
				
				local Img = SF:FindFirstChild("Shield_Img")
				if(Img ~= nil)then
					if(Is_Enabled)then
						Img.Image = "rbxassetid://130871917395731"
					else
						Img.Image = "rbxassetid://125284121534949"
					end
				end
			end
		end

		local function Toggle_Heal_PE(Is_Enabled)
			local PE = HRP:GetChildren()
			for i = 1, #PE do
				if(PE[i] ~= nil and PE[i].Name == "Heal_PE" and PE[i]:IsA("ParticleEmitter"))then
					PE[i].Enabled = Is_Enabled
				end
			end

			Toggle_Sheild_Icon(Is_Enabled)
		end

		local Low_Block_Con = nil
		local function Disable_Blocking_Handle()
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed
			end

			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Block_Power_V:SetAttribute("Is_Blocking", false)
			Toggle_Heal_PE(false)

			Debounce_Blocking = false
		end

		local function Play_Blocking_Animation()
			local Anim_Track = Striking_Anim_Tracks['Main Block']
			if(Anim_Track ~= nil)then
				Anim_Track:Play()
				Anim_Track:AdjustSpeed(1)
				task.wait(Anim_Track.Length * 0.9)

				if(Anim_Track ~= nil and Debounce_Blocking == true)then
					Anim_Track:AdjustSpeed(0)
				end
			end
		end

		function Funcs.Disable_Blocking_Handle()
			-- AI is turning off Blocking
			Disable_Blocking_Handle()
		end

		function Funcs.Blocking_Handle()
			Debounce_Blocking = true
			-- AI Is Blocking

			if(Hum ~= nil)then
				Hum.WalkSpeed = 8
			end

			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			Low_Block_Con = Block_Power_V.Changed:Connect(function()
				if(Block_Power_V.Value <= 0 and Debounce_Blocking == true)then
					if(Low_Block_Con ~= nil)then
						Low_Block_Con:Disconnect()
						Low_Block_Con = nil
					end

					Disable_Blocking_Handle()
				end
			end)
			table.insert(Cons, Low_Block_Con)
			task.spawn(Play_Blocking_Animation)

			if(Block_Power_V ~= nil and Block_Power_V.Value > 0)then
				Block_Power_V:SetAttribute("Is_Blocking", true)
				Toggle_Heal_PE(true)
			end
		end

		function Funcs.Get_Hitbox_Res()
			return (Get_Player_To_Hit() ~= nil)
		end		

		function Funcs.Get_Dodge_Type()
			local function Get_Ray_Distance_Data()
				local Origin = HRP.Position
				local Ray_Parm = RaycastParams.new()
				Ray_Parm.FilterType = Enum.RaycastFilterType.Exclude
				Ray_Parm.FilterDescendantsInstances = {Char, T_Char}

				local function Get_Ray_Dist(Dir)
					local Ray_Res = game.Workspace:Raycast(Origin, Dir * 10, Ray_Parm)
					if(Ray_Res ~= nil and Ray_Res.Distance ~= nil)then
						return Ray_Res.Distance
					end
					return 15
				end

				return {
					{
						['Type'] = "Dodge Back",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.LookVector * -1)
					},

					{
						['Type'] = "Dodge Left",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector * -1)
					},

					{
						['Type'] = "Dodge Right",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector)
					},

				}
			end
			local Ray_Dist_Arr = Get_Ray_Distance_Data()

			table.sort(Ray_Dist_Arr, function(A, B)
				return A['Distance'] > B['Distance']
			end)

			return Ray_Dist_Arr[1]['Type']
		end

		function Funcs.Is_Player_Striking_You()
			if(T_Strike_Power_V ~= nil and T_Strike_Power_V.Value < 4)then
				return true
			end
			return false
		end

		return Funcs
	end
	local Core_Strike_Funcs = Get_Core_Strike_Handles()

	--[[
		Core AI Decision Making goes here
		
		* If within Striking Distance ~ 5 Studs
			* If Player is Striking too, Dodge Left Right or Back (Max 2 Dodges)
			* Has to Strike (Max 3 Strikes)
				* Dodge Back if Strike (or left or Right)
		* Default to Blocking Handle
	]]--

	local function Submission_Handle(Is_Submitting, Attacking_Char)
		Animation_Mod.Reset_Character_Animations(Char)
		if(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end

		if(Is_Submitting)then
			Is_Submission = true
			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end

			if(HRP ~= nil)then
				--HRP.Anchored = true
				--HRP.CFrame *= CFrame.new(Vector3.new(0, 0.15, 0))
			end

			--> Play Animation
			--> Get Submission Character & Player
			--> Get their Takedown and Submission Data

			--> If Attacking Player, Set HRP CFrame Position
			--> Play Take Down Animation

			--> Play Submission Animation
			--> Play Submission Loop Animation

			local function Get_Takedown_Submission_Tracks()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)
				return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Receiving ID'], Submission_Data['Receiving ID'], Submission_Data['Receiving Loop ID'])
			end
			local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()

			Takedown_Track.Priority = Enum.AnimationPriority.Action2
			Animation_Mod.Play_Animation_Track(Takedown_Track, true)

			task.wait(0.25)

			Submission_Track.Priority = Enum.AnimationPriority.Action3
			Animation_Mod.Play_Animation_Track(Submission_Track)

			Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
		else
			Is_Hit = false

			if(HRP ~= nil)then
				HRP.Anchored = false
			end

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
			Is_Submission = false
		end
	end

	table.insert(Cons, AI_Training_Submission.Event:Connect(function(AI_Char, Attacking_Char, Is_Submitting)
		if(AI_Char == Char)then
			Submission_Handle(Is_Submitting, Attacking_Char)
		end
	end))


	local function Clinch_Handle(Animation_Sequence_Data, Is_Attacking)
		local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(Char)

			if(Debounce_Blocking == true)then
				task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
			end

			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
		end
		Freeze_Character()

		local function Play_Strike_Sequences()
			local Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
			Animation_Mod.Play_Animation_Track(Clinch_Tracks_Data['Init_Clinch'], true)
			task.spawn(Animation_Mod.Play_Animation_Track, Clinch_Tracks_Data['Loop_Clinch'])
			task.wait(1)

			for i = 1, #Animation_Sequence_Data do
				local Strike_Key = Animation_Sequence_Data[i]
				local Strike_Track = Clinch_Tracks_Data[Strike_Key]

				if(Strike_Track ~= nil)then
					--Play Flash, Play Hit Sound Effect, Quick Camera Shake
					Animation_Mod.Play_Animation_Track(Strike_Track)
					--wait(0.5)
				end
			end

		end
		Play_Strike_Sequences()

		local function Clinch_Reset_Handle()
			Animation_Mod.Reset_Character_Animations(Char)
			Is_Hit = false

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
		end	
		Clinch_Reset_Handle()
	end

	table.insert(Cons, AI_Training_Cage_Clinch.Event:Connect(function(AI_Char, Sequence_Keys, Is_Attacking)
		if(AI_Char == Char)then
			Clinch_Handle(Sequence_Keys, Is_Attacking)
		end
	end))


	local Strike_Count, Dodge_Count = 0, 0
	local function Main_AI_Logic_Gate()
		if(Health_V.Value > 0 and Is_Hit == false and T_Health_V ~= nil and T_Health_V.Value > 0)then
			if(Core_Strike_Funcs.Get_Hitbox_Res())then -- Within Strike Zone
				local Is_Player_Hitting_You = Core_Strike_Funcs.Is_Player_Striking_You()
				if(Is_Player_Hitting_You)then
					--Take the HIts until you're below 20 Block Power
					-- Dodge? or Strike
					if(Block_Power_V.Value > 10)then
						if(Dodge_Count < 2 or Strike_Count >= 3)then
							--Dodge
							if(Debounce_Dodge == false and Stam_V.Value >= 5)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								local Dodge_Type = Core_Strike_Funcs.Get_Dodge_Type()
								Core_Strike_Funcs.Dodge_Handle(Dodge_Type)

								Dodge_Count += 1
								if(Strike_Count >= 3)then
									Strike_Count = 0
								end
							end

						else
							--Strike
							if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								Core_Strike_Funcs.Strike_Handle()
								Strike_Count += 1
								if(Dodge_Count >= 2)then
									Dodge_Count = 0
								end
							end
						end
					elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
						--Not within Strike Zone, resort to Blocking
						Core_Strike_Funcs.Blocking_Handle()
					end
				else
					--Strike
					if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
						if(Debounce_Blocking == true)then
							task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
						end

						Core_Strike_Funcs.Strike_Handle()
						Strike_Count += 1
						if(Dodge_Count >= 2)then
							Dodge_Count = 0
						end
					end
				end
			elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
				--Not within Strike Zone, resort to Blocking
				Core_Strike_Funcs.Blocking_Handle()
			end

		elseif(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end
	end

	while Is_Active do
		if(Is_Submission == false)then
			Main_AI_Logic_Gate()
		end
		task.wait(0.5)
	end
end

Init_E.Event:Connect(function(T_Plr, T_Char,OtherStuff)	
	if(Is_Active == false and T_Plr ~= nil and T_Char ~= nil)then
		Core_AI_Handle(T_Plr, T_Char)
	elseif(Is_Active)then
		Reset_AI()
	end
end)]]></ProtectedString>
									<string name="ScriptGuid">{2D3F740C-DB22-49B1-B3FE-8351F3D5D209}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AI_Training_Bot_Handle.server.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXD0056128776244298029C31FD3B3DFE1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Bones_Zombie</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX5A0AE4230A8F42F7A00092E478FFA25E">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
								<string name="ScriptGuid">{7D18CC90-0F2D-4B63-A446-A6D2AB7976C8}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animate.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXCDA286D859514724812629A78AD86CA6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Init_AI_Training_Bot</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX1827387A76CC4BAE84B0B1C95E18FF86">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local Init_E = script.Parent
local Char = Init_E.Parent

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Overhead_Display 			= Channels.SC_Remote_Events.Overhead_Display
local Got_Hit_Effect 			= Channels.SC_Remote_Events.Got_Hit_Effect
local AI_Training_Cage_Clinch	= Channels.Bindable_Events.AI_Training_Cage_Clinch
local AI_Training_Submission 	= Channels.Bindable_Events.AI_Training_Submission
local Ragdoll_Player			= Channels.Bindable_Events.Ragdoll_Player

local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")
local Head = Char:WaitForChild("Head")
local Fight_Data_F = Char:WaitForChild("Fight_Data")
local Stamina_V = Fight_Data_F:WaitForChild("Staminia") -- adjust name if it's 'Stamina'

-- Direct stamina regeneration for bot (server-side)
local function Reload_Stamina()
	while Stamina_V.Value < 40 do
		Stamina_V.Value = math.min(Stamina_V.Value + 1, 100) -- regen step, adjust as needed
		task.wait(0.1)
	end
end
local Fight_UI = Char:WaitForChild("Fighting_UI")
local Health_V = Fight_Data_F:WaitForChild("Health")
local Stam_V = Fight_Data_F:WaitForChild("Staminia")
local Block_Power_V = Fight_Data_F:WaitForChild("Block Power")
local Strike_Power_V = Fight_Data_F:WaitForChild("Strike Power")

local Fight_Walkspeed = 12
local Is_Active = false
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Get_Fighting_UI()
	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
		local Main_F = Fight_UI:FindFirstChild("Main_F") 
		local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
		if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
			return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
		end
	end

	return nil, nil
end

local function Reset_AI()
	Disconnect_Cons()

	Health_V.Value = 100
	Stam_V.Value = 100
	Block_Power_V.Value = 30
	Strike_Power_V.Value = 6

	if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
		HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
	end

	if(Hum ~= nil)then
		Hum.AutoRotate = false
		Hum.WalkSpeed = 12
		Hum.JumpPower = 0

		Animation_Mod.Reset_Character_Animations(Char)

		Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
	end

	Char:SetAttribute("Is_Fighting", false)
	Is_Active = false
end

local function Core_AI_Handle(T_Plr, T_Char)
	local T_HRP = T_Char:WaitForChild("HumanoidRootPart")
	local T_Fight_Data = T_Plr:FindFirstChild("Fight_Data")
	local T_Health_V = T_Fight_Data:WaitForChild("Health")
	local T_Stam_V = T_Fight_Data:WaitForChild("Staminia")
	local T_Block_Power_V = T_Fight_Data:WaitForChild("Block Power")
	local T_Strike_Power_V = T_Fight_Data:WaitForChild("Strike Power")
	local Is_Submission = false

	Char:SetAttribute("Is_Fighting", true)
	Reset_AI()
	Is_Active = true

	task.wait(3)
	if(Is_Active == false)then
		return
	end

	--Fight Data Changes
	table.insert(Cons, Health_V.Changed:Connect(function()
		if(Char ~= nil and Health_V.Value <= 0)then
			Ragdoll_Player:Fire(Char)
		end
	end))

	local function Create_BG()
		local OldG = HRP:FindFirstChildWhichIsA("BodyGyro")
		if(OldG ~= nil)then
			OldG:Destroy()
		end

		local bodyG = Instance.new("BodyGyro", HRP)
		bodyG.P = 1000
		bodyG.MaxTorque = Vector3.new(0, 1000, 0)
		bodyG.D = 10

		return bodyG
	end
	local BG = Create_BG()

	local function Movement_Handle()
		local function Update_Player_Movement()
			local function Get_Target_Position()
				if(T_HRP ~= nil)then
					local Move_Speed = T_HRP.Velocity
					local Def_Pos = T_HRP.Position + T_HRP.CFrame.LookVector * 3.5

					if(math.floor(Move_Speed.Magnitude) <= 0)then
						return Def_Pos, T_HRP.Position
					else
						local Ping = T_Plr:GetNetworkPing()
						local Dir = Move_Speed.Unit
						local Speed = Move_Speed.Magnitude
						local Extrapolated_Pos = Def_Pos + Dir * (Speed * Ping)
						local Travel_Time = ((Extrapolated_Pos - HRP.Position).Magnitude) / Hum.WalkSpeed
						return Extrapolated_Pos + Dir * (Hum.WalkSpeed * Travel_Time), Extrapolated_Pos
					end
				end

				return HRP.Position, HRP.Position + HRP.CFrame.LookVector * 3
			end
			local Move_Pos, Look_Pos = Get_Target_Position()

			BG.CFrame = CFrame.new(HRP.Position, Look_Pos)
			Hum:MoveTo(Move_Pos)
		end

		table.insert(Cons, RunService.Stepped:Connect(function()
			if(BG ~= nil and HRP ~= nil and Hum ~= nil and Hum.PlatformStand == false and T_Plr ~= nil and T_HRP ~= nil)then
				if(T_Health_V ~= nil and T_Health_V.Value > 0 and Is_Submission == false)then
					Update_Player_Movement()
				else
					Hum:MoveTo(HRP.Position)
				end
			end
		end))

		table.insert(Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
			if(Hum.PlatformStand == true)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			else
				BG.P = 1000
				BG.MaxTorque = Vector3.new(0, 1000, 0)
				BG.D = 10
			end
		end))
	end
	Movement_Handle()

	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
		Damage_UIG.Offset = Vector2.new(0, -0.5)
		Damage_Bar_Img.Visible = false
	end

	local function Create_Anim_Arr_Data(Anim_Track_Data)
		local D = {}
		for Key, Anim_Track in next, Anim_Track_Data do
			table.insert(D, Anim_Track)
		end
		return D
	end

	local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	local Combo_Strike_Index = 1
	local Combo_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(T_Plr, Hum, "Bot Combo")
	local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)

	local Debounce_Striking = false
	local Debounce_Dodge = false
	local Debounce_Blocking = false
	local Debounce_Takedown = false
	local Is_Hit = false

	local function Striking_Movement_Handle()
		--> Update Movement, Moving Forward or Backwards | Moving Left to Right | Standing Idle
		--> Track Humanoid MoveDirection
		table.insert(Cons, Hum:GetPropertyChangedSignal("WalkToPoint"):Connect(function()
			local Move_Speed = math.floor(HRP.Velocity.Magnitude)
			if(Move_Speed > 3 and Anim_Track_Data['Shuffle Forward'].IsPlaying == false)then
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				Anim_Track_Data['Shuffle Forward']:Play()
				Anim_Track_Data['Shuffle Forward']:AdjustSpeed(-1)

			elseif(Move_Speed <= 3 and 
				(Anim_Track_Data['Shuffle Forward'].IsPlaying == true or 
					Anim_Track_Data['Shuffle Side'].IsPlaying == true))then

				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
			end
		end))

		Anim_Track_Data['Idle']:Play()
		Anim_Track_Data['Idle']:AdjustSpeed(0.5)
	end
	Striking_Movement_Handle()

	local function On_Hit_Effects()
		--[[
			* When Health goes Down!
				> Camera Shake Effects
					-> Quick Shake
				> Apply Hit Effects
					-> Reset all Animations, Play the Hit One
				> Set Debounce till Hit Effect goes Away
		]]--

		local Prev_Health = Health_V.Value
		local Hit_Anim_Track = Striking_Anim_Tracks['Taking Hit']

		local function Show_Sweat_Effects()
			if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
				local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
				local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
				if(PE ~= nil)then
					PE:Emit(25)
				end
			end
		end

		table.insert(Cons, Health_V.Changed:Connect(function()
			local Current_V = Health_V.Value
			if(Current_V < Prev_Health and Is_Hit == false)then
				Is_Hit = true

				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Show_Sweat_Effects()

				task.spawn(function()
					Animation_Mod.Play_Animation_Track(Hit_Anim_Track)
					Is_Hit = false
				end)
			end

			Prev_Health = Current_V
		end))
	end
	On_Hit_Effects()

	local function Blocking_Effects()
		--[[
			* On Sheild Blocking Power goes down (Greater than 0) and Debounce_Blocking == true
			* Get the Opponent Handed Type
				> Play the Coresponding Animation
		]]--

		local Prev_Blocking = Block_Power_V.Value
		local Tween_Health_Con = nil
		local Tween_Stam_Con = nil
		local Tween_Block_Con = nil
		Block_Power_V:SetAttribute("Is_Blocking", false)

		local function Reset_Healing_Cons()
			if(Tween_Health_Con ~= nil)then
				Tween_Health_Con:Cancel()
				Tween_Health_Con = nil
			end

			if(Tween_Stam_Con ~= nil)then
				Tween_Stam_Con:Cancel()
				Tween_Stam_Con = nil
			end
		end

		local function Set_Healing_Cons()
			local Health_Time = math.clamp((100 - Health_V.Value) * 0.6, 0.6, 60)
			local Tween_Full_Health = TweenInfo.new(Health_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
			Tween_Health_Con = TS:Create(Health_V, Tween_Full_Health, {Value = 100})
			Tween_Health_Con:Play()

			local Stam_Time = math.clamp((100 - Stam_V.Value) * 0.1, 0.1, 10)
			local Tween_Full_Stam = TweenInfo.new(Stam_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)	
			Tween_Stam_Con = TS:Create(Stam_V, Tween_Full_Stam, {Value = 100})
			Tween_Stam_Con:Play()
		end

		table.insert(Cons, Block_Power_V.AttributeChanged:Connect(function(Attrib_Key)
			if(Attrib_Key == "Is_Blocking" and Block_Power_V:GetAttribute("Is_Blocking") ~= nil)then
				Reset_Healing_Cons()
				if(Block_Power_V:GetAttribute("Is_Blocking") == true)then
					Set_Healing_Cons()
				end
			end
		end))


		local function Update_Fight_Block_UI()
			if(Fight_UI ~= nil and Block_Power_V ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil and 
				Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then

				local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
				local Img = Sheild_F:FindFirstChild("Shield_Img")
				local Txt = Sheild_F:FindFirstChild("Shield_Txt")

				if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
					local UIG = Img:FindFirstChildWhichIsA("UIGradient")
					local Block_Power = Block_Power_V.Value
					local Dif =  math.clamp(Block_Power / 30, 0, 1)
					local Offset_Pos_Y = (1 - Dif) - 0.5

					UIG.Offset = Vector2.new(0, Offset_Pos_Y)
					Txt.Text = Block_Power .. ""
					if(Dif <= 0.25)then
						Txt.TextColor3 = Color3.new(1, 0, 0)
					else
						Txt.TextColor3 = Color3.new(1, 1, 1)
					end

				end
			end

		end

		table.insert(Cons, Block_Power_V.Changed:Connect(function()
			local Current_V = Block_Power_V.Value
			if(Current_V > 0 and Current_V < Prev_Blocking and Debounce_Blocking == true)then
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Striking_Anim_Tracks['Body Block Left'])

				if(Block_Power_V.Value < 30)then
					if(Tween_Block_Con ~= nil)then
						Tween_Block_Con:Cancel()
						Tween_Block_Con = nil
					end

					local Block_Time = math.clamp((30 - Block_Power_V.Value) * 0.2667, 0.2667, 8)
					local Tween_Block_Power = TweenInfo.new(Block_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 6)
					Tween_Block_Con = TS:Create(Block_Power_V, Tween_Block_Power, {Value = 30})
					Tween_Block_Con:Play()
					Tween_Block_Con.Completed:Wait()
					Tween_Block_Con = nil
				end
			end

			Update_Fight_Block_UI()
			Prev_Blocking = Current_V

		end))

	end
	Blocking_Effects()

	local function Get_Core_Strike_Handles()
		local Funcs = {}
	
		local function Has_Enough_Stam(Min_V)
			if(Stam_V ~= nil and Stam_V.Value >= Min_V)then
				Stam_V.Value -= Min_V
				return true
			end
			return false
		end

		local function Get_Player_To_Hit()
			local Whitelist_Chars = {T_Char}
			local Overlap_P = OverlapParams.new()
			Overlap_P.MaxParts = 1
			Overlap_P.FilterType = Enum.RaycastFilterType.Include
			Overlap_P.FilterDescendantsInstances = {Whitelist_Chars}

			local function Create_Region_CF()
				local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
				local Distance = (Speed + 3)
				local Head_Dir = Head.CFrame.LookVector
				local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

				local cframe = HRP.CFrame * CFrame.new(0, 0, -3)
				return cframe
			end
			local Spawn_CF = Create_Region_CF()
			local Hitbox_Size = Vector3.new(4, 8, 4)

			local function Create_Hitbox_Part()
				local P = Instance.new("Part", game.Workspace)
				P.Name = "Hitbox_Part"
				P.Anchored = true
				P.CanCollide = false
				P.Transparency = 0.5
				P.Color = Color3.new(1, 0, 0)
				P.Material = Enum.Material.SmoothPlastic
				P.Size = Hitbox_Size
				P.CFrame = Spawn_CF

				Debris:AddItem(P, 5)
			end
			--Create_Hitbox_Part()

			local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
			if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
				local function Get_Char_From_BP()
					for i = 1, #Whitelist_Chars do
						local C = Whitelist_Chars[i]
						if(C ~= nil and Region_Data[1]:IsDescendantOf(C))then
							return C
						end
					end

					return Whitelist_Chars[1]
				end

				return Get_Char_From_BP()
			end

			return nil
		end

		local function Get_Punch_Power()
			local Tween_Punch_Power_Back = TweenInfo.new(1.75, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
			local Strike_Power = Strike_Power_V.Value
			Strike_Power_V.Value = 0
			TS:Create(Strike_Power_V, Tween_Punch_Power_Back, {Value = 6}):Play()
			return Strike_Power
		end

		local function Get_Target_Fight_Data(Hit_Char)
			local Hit_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
			if(Hit_Plr ~= nil)then
				return Hit_Plr:FindFirstChild("Fight_Data")
			else
				return Hit_Char:FindFirstChild("Fight_Data")
			end
		end

		function Funcs.Strike_Handle()
			if Stamina_V.Value < 20 then Reload_Stamina() end
			--[[
				* Play Woosh Sound Effect locally
				* Play Animation
				* Tell the Server that you are Striking
			]]--

			Debounce_Striking = true
			-- AI is Striking!
			SE_Mod.PlaySFX(Char, "Punch_Woosh_SE")
			
			local function Play_Strike_Animation()
				local Track = Combo_Anim_Arr[Combo_Strike_Index]
				local Key = Track:GetAttribute("Strike_Key") or "A"

				task.spawn(function()
					if(HRP ~= nil and Has_Enough_Stam(10))then
						local Base_Punch_Power = Get_Punch_Power()
						local Hit_Char = Get_Player_To_Hit()
						local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Key)
						local Power_Inc = Strike_Data['Power Multi'] or 0
						local Punch_Power = math.ceil(Base_Punch_Power * (1  + Power_Inc))
						--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Strikes", 1)

						if(Hit_Char ~= nil)then
							local Hit_Fight_Data = Get_Target_Fight_Data(Hit_Char)
							if(Hit_Fight_Data ~= nil and Hit_Fight_Data:FindFirstChild("Health") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Block Power") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Staminia") ~= nil)then

								local T_Health = Hit_Fight_Data:FindFirstChild("Health")
								local T_Block_Power = Hit_Fight_Data:FindFirstChild("Block Power")
								local T_Staminia = Hit_Fight_Data:FindFirstChild("Staminia")

								local function Is_Dodging_Check()
									local Is_Dodging = T_Staminia:GetAttribute("Is_Dodging")
									if(Is_Dodging ~= nil and Is_Dodging == true)then
										local Target_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if(Target_Plr ~= nil)then
											Stats_Manager_Mod.Add_To_Player_Stats_Data(Target_Plr, "Dodged Strikes", 1)
										end

										return true
									end
									return false
								end

								local function Is_Blocking_Check()
									local Is_Block = T_Block_Power:GetAttribute("Is_Blocking")
									if(Is_Block ~= nil and Is_Block == true)then
										T_Block_Power.Value -= Punch_Power
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.fromRGB(170, 85, 255))

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										if(T_Block_Power.Value < 0)then
											local Dif = math.abs(T_Block_Power.Value)
											T_Health.Value = math.clamp(T_Health.Value - Dif, 0, 100)
											T_Block_Power.Value = 0

											SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
											--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)

											Overhead_Display:FireAllClients(Hit_Char, "-" .. Dif, Color3.new(1, 0, 0))

										else
											SE_Mod.PlaySFX(HRP, "Blocked_Hit_SE")	
										end

										return true
									end

									return false
								end

								if(Is_Dodging_Check())then
									--Play Dodging Text
									Overhead_Display:FireAllClients(Hit_Char, "Dodged", Color3.fromRGB(35, 244, 68))
								elseif(Is_Blocking_Check())then
									--Play Blocking 
								else
									--Apply the Hit
									local function Apply_Strike()
										T_Health.Value = math.clamp(T_Health.Value - Punch_Power, 0, 100)
										SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
										--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.new(1, 0, 0))
										--Punch_Hit_VFX:FireClient(Plr, Hit_Char)
										--Play Damage Val Show

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										local T_HRP = Hit_Char:FindFirstChild("HumanoidRootPart")
										if(T_HRP ~= nil)then
											local Hit_Force = 625 -- Was 350 then 500
											local Dir = HRP.CFrame.LookVector 
											T_HRP:ApplyImpulse(Dir * Hit_Force * T_HRP:GetMass())
										end
									end
									Apply_Strike()
								end
							end

						end
					end
				end)

				Combo_Strike_Index += 1
				if(Combo_Strike_Index > #Combo_Anim_Arr)then
					Combo_Strike_Index = 1
				end

				Animation_Mod.Stop_Animation_Tracks(Combo_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Track)
			end
			task.spawn(Play_Strike_Animation)
			task.wait(0.5)

			Debounce_Striking = false
		end

		local Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left']
		local Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		local Back_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		function Funcs.Dodge_Handle(Dodge_Type)
			--[[
				* Get the Type First
					-> First Index? Just play the Slip Animation
					-> 2nd Index? Play the Dodge Animation AND apply Force to the Player in the direction
				
					-> Tell the Server that you are Dodging and should reduce Staminia Value
			]]--

			Debounce_Dodge = true
			-- AI is Dodging

			local function Apply_Force(Dir)
				HRP:ApplyImpulse(Dir * (Fight_Walkspeed * 65) * HRP:GetMass())
			end

			task.spawn(function()
				if(Has_Enough_Stam(5))then
					--Play the Sound Effect
					--Toggle Value
					SE_Mod.PlaySFX(HRP, "Missed_SE")
					Stam_V:SetAttribute("Is_Dodging", true)
					task.wait(0.5)
					Stam_V:SetAttribute("Is_Dodging", false)
				end
			end)
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})

			local function Increment_Anim()
				if(Dodge_Type == "Dodge Left")then
					if(Left_Dodge_Ani == Striking_Anim_Tracks['Slip Left'])then
						Left_Dodge_Ani = Striking_Anim_Tracks['Headblock Left']
					else
						Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left'] 
					end
				else
					--Right
					if(Right_Dodge_Ani == Striking_Anim_Tracks['Slip Right'])then
						Right_Dodge_Ani = Striking_Anim_Tracks['Headblock Right']
					else
						Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right'] 
					end
				end
			end

			if(Dodge_Type == "Dodge Left")then
				--Left
				if(Left_Dodge_Ani == Striking_Anim_Tracks['Headblock Left'])then
					--Apply_Force(HRP.CFrame.RightVector * -1)
				end
				Apply_Force(HRP.CFrame.RightVector * -1)
				Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Right")then
				--Right
				if(Right_Dodge_Ani == Striking_Anim_Tracks['Headblock Right'])then
					--Apply_Force(HRP.CFrame.RightVector)
				end
				Apply_Force(HRP.CFrame.RightVector)
				Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Back")then
				Apply_Force(HRP.CFrame.LookVector * -1)
				Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
			end

			Debounce_Dodge = false
		end

		local function Toggle_Sheild_Icon(Is_Enabled)
			local Main_F =  Fight_UI:FindFirstChild("Main_F")
			if(Main_F ~= nil and Main_F:FindFirstChild("Shield_F") ~= nil)then
				local SF = Main_F:FindFirstChild("Shield_F")
				SF.Visible = true
				
				local Img = SF:FindFirstChild("Shield_Img")
				if(Img ~= nil)then
					if(Is_Enabled)then
						Img.Image = "rbxassetid://130871917395731"
					else
						Img.Image = "rbxassetid://125284121534949"
					end
				end
			end
		end

		local function Toggle_Heal_PE(Is_Enabled)
			local PE = HRP:GetChildren()
			for i = 1, #PE do
				if(PE[i] ~= nil and PE[i].Name == "Heal_PE" and PE[i]:IsA("ParticleEmitter"))then
					PE[i].Enabled = Is_Enabled
				end
			end

			Toggle_Sheild_Icon(Is_Enabled)
		end

		local Low_Block_Con = nil
		local function Disable_Blocking_Handle()
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed
			end

			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Block_Power_V:SetAttribute("Is_Blocking", false)
			Toggle_Heal_PE(false)

			Debounce_Blocking = false
		end

		local function Play_Blocking_Animation()
			local Anim_Track = Striking_Anim_Tracks['Main Block']
			if(Anim_Track ~= nil)then
				Anim_Track:Play()
				Anim_Track:AdjustSpeed(1)
				task.wait(Anim_Track.Length * 0.9)

				if(Anim_Track ~= nil and Debounce_Blocking == true)then
					Anim_Track:AdjustSpeed(0)
				end
			end
		end

		function Funcs.Disable_Blocking_Handle()
			-- AI is turning off Blocking
			Disable_Blocking_Handle()
		end

		function Funcs.Blocking_Handle()
			Debounce_Blocking = true
			-- AI Is Blocking

			if(Hum ~= nil)then
				Hum.WalkSpeed = 8
			end

			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			Low_Block_Con = Block_Power_V.Changed:Connect(function()
				if(Block_Power_V.Value <= 0 and Debounce_Blocking == true)then
					if(Low_Block_Con ~= nil)then
						Low_Block_Con:Disconnect()
						Low_Block_Con = nil
					end

					Disable_Blocking_Handle()
				end
			end)
			table.insert(Cons, Low_Block_Con)
			task.spawn(Play_Blocking_Animation)

			if(Block_Power_V ~= nil and Block_Power_V.Value > 0)then
				Block_Power_V:SetAttribute("Is_Blocking", true)
				Toggle_Heal_PE(true)
			end
		end

		function Funcs.Get_Hitbox_Res()
			return (Get_Player_To_Hit() ~= nil)
		end		

		function Funcs.Get_Dodge_Type()
			local function Get_Ray_Distance_Data()
				local Origin = HRP.Position
				local Ray_Parm = RaycastParams.new()
				Ray_Parm.FilterType = Enum.RaycastFilterType.Exclude
				Ray_Parm.FilterDescendantsInstances = {Char, T_Char}

				local function Get_Ray_Dist(Dir)
					local Ray_Res = game.Workspace:Raycast(Origin, Dir * 10, Ray_Parm)
					if(Ray_Res ~= nil and Ray_Res.Distance ~= nil)then
						return Ray_Res.Distance
					end
					return 15
				end

				return {
					{
						['Type'] = "Dodge Back",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.LookVector * -1)
					},

					{
						['Type'] = "Dodge Left",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector * -1)
					},

					{
						['Type'] = "Dodge Right",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector)
					},

				}
			end
			local Ray_Dist_Arr = Get_Ray_Distance_Data()

			table.sort(Ray_Dist_Arr, function(A, B)
				return A['Distance'] > B['Distance']
			end)

			return Ray_Dist_Arr[1]['Type']
		end

		function Funcs.Is_Player_Striking_You()
			if(T_Strike_Power_V ~= nil and T_Strike_Power_V.Value < 4)then
				return true
			end
			return false
		end

		return Funcs
	end
	local Core_Strike_Funcs = Get_Core_Strike_Handles()

	--[[
		Core AI Decision Making goes here
		
		* If within Striking Distance ~ 5 Studs
			* If Player is Striking too, Dodge Left Right or Back (Max 2 Dodges)
			* Has to Strike (Max 3 Strikes)
				* Dodge Back if Strike (or left or Right)
		* Default to Blocking Handle
	]]--

	local function Submission_Handle(Is_Submitting, Attacking_Char)
		Animation_Mod.Reset_Character_Animations(Char)
		if(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end

		if(Is_Submitting)then
			Is_Submission = true
			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end

			if(HRP ~= nil)then
				--HRP.Anchored = true
				--HRP.CFrame *= CFrame.new(Vector3.new(0, 0.15, 0))
			end

			--> Play Animation
			--> Get Submission Character & Player
			--> Get their Takedown and Submission Data

			--> If Attacking Player, Set HRP CFrame Position
			--> Play Take Down Animation

			--> Play Submission Animation
			--> Play Submission Loop Animation

			local function Get_Takedown_Submission_Tracks()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)
				return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Receiving ID'], Submission_Data['Receiving ID'], Submission_Data['Receiving Loop ID'])
			end
			local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()

			Takedown_Track.Priority = Enum.AnimationPriority.Action2
			Animation_Mod.Play_Animation_Track(Takedown_Track, true)

			task.wait(0.25)

			Submission_Track.Priority = Enum.AnimationPriority.Action3
			Animation_Mod.Play_Animation_Track(Submission_Track)

			Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
		else
			Is_Hit = false

			if(HRP ~= nil)then
				HRP.Anchored = false
			end

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
			Is_Submission = false
		end
	end

	table.insert(Cons, AI_Training_Submission.Event:Connect(function(AI_Char, Attacking_Char, Is_Submitting)
		if(AI_Char == Char)then
			Submission_Handle(Is_Submitting, Attacking_Char)
		end
	end))


	local function Clinch_Handle(Animation_Sequence_Data, Is_Attacking)
		local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(Char)

			if(Debounce_Blocking == true)then
				task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
			end

			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
		end
		Freeze_Character()

		local function Play_Strike_Sequences()
			local Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
			Animation_Mod.Play_Animation_Track(Clinch_Tracks_Data['Init_Clinch'], true)
			task.spawn(Animation_Mod.Play_Animation_Track, Clinch_Tracks_Data['Loop_Clinch'])
			task.wait(1)

			for i = 1, #Animation_Sequence_Data do
				local Strike_Key = Animation_Sequence_Data[i]
				local Strike_Track = Clinch_Tracks_Data[Strike_Key]

				if(Strike_Track ~= nil)then
					--Play Flash, Play Hit Sound Effect, Quick Camera Shake
					Animation_Mod.Play_Animation_Track(Strike_Track)
					--wait(0.5)
				end
			end

		end
		Play_Strike_Sequences()

		local function Clinch_Reset_Handle()
			Animation_Mod.Reset_Character_Animations(Char)
			Is_Hit = false

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
		end	
		Clinch_Reset_Handle()
	end

	table.insert(Cons, AI_Training_Cage_Clinch.Event:Connect(function(AI_Char, Sequence_Keys, Is_Attacking)
		if(AI_Char == Char)then
			Clinch_Handle(Sequence_Keys, Is_Attacking)
		end
	end))


	local Strike_Count, Dodge_Count = 0, 0
	local function Main_AI_Logic_Gate()
		if(Health_V.Value > 0 and Is_Hit == false and T_Health_V ~= nil and T_Health_V.Value > 0)then
			if(Core_Strike_Funcs.Get_Hitbox_Res())then -- Within Strike Zone
				local Is_Player_Hitting_You = Core_Strike_Funcs.Is_Player_Striking_You()
				if(Is_Player_Hitting_You)then
					--Take the HIts until you're below 20 Block Power
					-- Dodge? or Strike
					if(Block_Power_V.Value > 10)then
						if(Dodge_Count < 2 or Strike_Count >= 3)then
							--Dodge
							if(Debounce_Dodge == false and Stam_V.Value >= 5)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								local Dodge_Type = Core_Strike_Funcs.Get_Dodge_Type()
								Core_Strike_Funcs.Dodge_Handle(Dodge_Type)

								Dodge_Count += 1
								if(Strike_Count >= 3)then
									Strike_Count = 0
								end
							end

						else
							--Strike
							if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								Core_Strike_Funcs.Strike_Handle()
								Strike_Count += 1
								if(Dodge_Count >= 2)then
									Dodge_Count = 0
								end
							end
						end
					elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
						--Not within Strike Zone, resort to Blocking
						Core_Strike_Funcs.Blocking_Handle()
					end
				else
					--Strike
					if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
						if(Debounce_Blocking == true)then
							task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
						end

						Core_Strike_Funcs.Strike_Handle()
						Strike_Count += 1
						if(Dodge_Count >= 2)then
							Dodge_Count = 0
						end
					end
				end
			elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
				--Not within Strike Zone, resort to Blocking
				Core_Strike_Funcs.Blocking_Handle()
			end

		elseif(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end
	end

	while Is_Active do
		if(Is_Submission == false)then
			Main_AI_Logic_Gate()
		end
		task.wait(0.5)
	end
end

Init_E.Event:Connect(function(T_Plr, T_Char,OtherStuff)	
	if(Is_Active == false and T_Plr ~= nil and T_Char ~= nil)then
		Core_AI_Handle(T_Plr, T_Char)
	elseif(Is_Active)then
		Reset_AI()
	end
end)]]></ProtectedString>
									<string name="ScriptGuid">{27DBEF23-2222-47B1-A76D-0CEBA120BBE7}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AI_Training_Bot_Handle.server.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX5D2D2AF5086E4D9FB28050E957B470A7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Standard</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX192F5DC392EB41BBA8869D66D07D27C9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Training_Bot</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX37EB3B9F37CC44ACB236D3B5C5A4D53F">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
								<string name="ScriptGuid">{66EED0B6-447C-4181-A8EB-D618E98C93B7}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animate.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX481A32A75DB444579052F45E11D8CAC9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Female_Bot</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX8E3DAA391E3248258EEAEE4213611E8E">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
								<string name="ScriptGuid">{7A3CA9E5-21DE-45FA-8B6B-00FBB1989504}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animate.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX6B14EF4837454688A229F1679F6CFC71">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Coach_Bot</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX2A712D0D6E4D4E0CB4EE839C8B0FEC02">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
								<string name="ScriptGuid">{B8921837-10BF-4F66-ADF0-E1BD60FA28D4}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animate.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX4ED916306E0B4754A8D97DA76DBEB81D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Avatars</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX7E1101D2F3C84E29B4DC4271C906F0A3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Male_StarterCharacter</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX315F70A5D76743E2BAC6FAAE0A56CF36">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
							<string name="ScriptGuid">{23F91056-DE78-4162-BEA2-47EF142F3859}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Animate.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX9F14B4637D794AE69B77AAE704B1BEEF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Female_StarterCharacter</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX7361AC11B98F40B792C6B16F9BC39185">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
							<string name="ScriptGuid">{296F6BA3-1107-404F-B136-F4507E1EC352}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Animate.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX1CFE007B1F5145AE9865A101BBC829F3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Archives</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX641F7C57A80E42DF886B54DF8E47760E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Male_StarterCharacter_old</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX3921FAF0C3A348BFAA087D12BBCC1855">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Modernized Animate.lua (R15) – 100% backward-compatible version
-- Changes:
--   - Replaced Humanoid:LoadAnimation() → Animator:LoadAnimation()
--   - Ensured Animator exists
--   - Added safe loop exit on death
--   - Converted all globals to locals
--   - Used :Disconnect() instead of :disconnect()
--   - Guarded LocalPlayer usage

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop")
end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun")
end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2
local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil
local PreloadedAnims = {}
local animTable = {}

local animNames = {
	idle = {
		{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
		{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
		{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 },
	},
	walk = {
		{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 },
	},
	run = {
		{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 },
	},
	swim = {
		{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 },
	},
	swimidle = {
		{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 },
	},
	jump = {
		{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 },
	},
	fall = {
		{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 },
	},
	climb = {
		{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 },
	},
	sit = {
		{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 },
	},
	toolnone = {
		{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 },
	},
	toolslash = {
		{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 },
	},
	toollunge = {
		{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 },
	},
	wave = {
		{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 },
	},
	point = {
		{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 },
	},
	dance = {
		{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 },
	},
	dance2 = {
		{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 },
	},
	dance3 = {
		{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 },
	},
	laugh = {
		{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 },
	},
	cheer = {
		{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 },
	},
}

local emoteNames = {
	wave = false,
	point = false,
	dance = true,
	dance2 = true,
	dance3 = true,
	laugh = false,
	cheer = false,
}

math.randomseed(tick())

-- Ensure animator exists
local animator = Humanoid:FindFirstChildOfClass("Animator")
if not animator then
	animator = Instance.new("Animator")
	animator.Parent = Humanoid
end

local function findExistingAnimationInSet(set, anim)
	if not set or not anim then return 0 end
	for idx = 1, set.count, 1 do
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	return 0
end

local function configureAnimationSet(name, fileList)
	if animTable[name] then
		for _, connection in pairs(animTable[name].connections) do
			connection:Disconnect()
		end
	end
	animTable[name] = { count = 0, totalWeight = 0, connections = {} }

	local allowCustomAnimations = true
	pcall(function()
		allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations
	end)

	local config = script:FindFirstChild(name)
	if allowCustomAnimations and config then
		table.insert(animTable[name].connections, config.ChildAdded:Connect(function() configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:Connect(function() configureAnimationSet(name, fileList) end))
		for _, childPart in pairs(config:GetChildren()) do
			if childPart:IsA("Animation") then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if weightObject then newWeight = weightObject.Value end
				animTable[name].count += 1
				local idx = animTable[name].count
				animTable[name][idx] = { anim = childPart, weight = newWeight }
				animTable[name].totalWeight += newWeight
				table.insert(animTable[name].connections, childPart.Changed:Connect(function() configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:Connect(function() configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:Connect(function() configureAnimationSet(name, fileList) end))
			end
		end
	end

	if animTable[name].count <= 0 then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {
				anim = Instance.new("Animation"),
				weight = anim.weight,
			}
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name].count += 1
			animTable[name].totalWeight += anim.weight
		end
	end

	for _, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			local id = animType[idx].anim.AnimationId
			if not PreloadedAnims[id] then
				animator:LoadAnimation(animType[idx].anim)
				PreloadedAnims[id] = true
			end
		end
	end
end

local function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if fileList then configureAnimationSet(child.Name, fileList) end
end

script.ChildAdded:Connect(scriptChildModified)
script.ChildRemoved:Connect(scriptChildModified)

for name, fileList in pairs(animNames) do
	configureAnimationSet(name, fileList)
end

local toolAnim, toolAnimTime = "None", 0
local jumpAnimTime, jumpAnimDuration = 0, 0.31
local toolTransitionTime, fallTransitionTime = 0.1, 0.2
local currentlyPlayingEmote = false

local function stopAllAnimations()
	local oldAnim = currentAnim
	if emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false then oldAnim = "idle" end
	if currentlyPlayingEmote then oldAnim = "idle" currentlyPlayingEmote = false end
	currentAnim = ""
	if currentAnimKeyframeHandler then currentAnimKeyframeHandler:Disconnect() end
	if currentAnimTrack then currentAnimTrack:Stop() currentAnimTrack:Destroy() currentAnimTrack = nil end
	if runAnimKeyframeHandler then runAnimKeyframeHandler:Disconnect() end
	if runAnimTrack then runAnimTrack:Stop() runAnimTrack:Destroy() runAnimTrack = nil end
	return oldAnim
end

-- [All the remaining functions and event handlers stay identical, only updated for local scope and Animator use]

local function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			return getRigScale()
		end
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if not AnimationSpeedDampeningObject then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) *
				AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	return speedScaled / heightScale
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5
	local normalizedRunSpeed = 1
	local runSpeed = rootMotionCompensation(speed)
	local walkAnimationWeight, runAnimationWeight, timeWarp =
		smallButNotZero, smallButNotZero, 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight, timeWarp = 1, runSpeed / normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fade = (runSpeed - normalizedWalkSpeed) /
			(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight, runAnimationWeight = 1 - fade, fade
	else
		timeWarp, runAnimationWeight = runSpeed / normalizedRunSpeed, 1
	end

	if currentAnimTrack then
		currentAnimTrack:AdjustWeight(walkAnimationWeight)
		currentAnimTrack:AdjustSpeed(timeWarp)
	end
	if runAnimTrack then
		runAnimTrack:AdjustWeight(runAnimationWeight)
		runAnimTrack:AdjustSpeed(timeWarp)
	end
end

local function setAnimationSpeed(speed)
	if currentAnim == "walk" then
		setRunSpeed(speed)
	elseif currentAnimTrack and speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(speed)
	end
end

local function keyFrameReachedFunc(frameName)
	if frameName ~= "End" then return end
	if currentAnim == "walk" then
		if userNoUpdateOnLoop then
			if runAnimTrack and not runAnimTrack.Looped then runAnimTrack.TimePosition = 0 end
			if currentAnimTrack and not currentAnimTrack.Looped then currentAnimTrack.TimePosition = 0 end
		else
			if runAnimTrack then runAnimTrack.TimePosition = 0 end
			if currentAnimTrack then currentAnimTrack.TimePosition = 0 end
		end
	else
		local repeatAnim = currentAnim
		if emoteNames[repeatAnim] == false then repeatAnim = "idle" end
		if currentlyPlayingEmote then
			if currentAnimTrack and currentAnimTrack.Looped then return end
			repeatAnim = "idle"
			currentlyPlayingEmote = false
		end
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.15, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

local function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight)
	local idx = 1
	while roll > animTable[animName][idx].weight do
		roll -= animTable[animName][idx].weight
		idx += 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	if anim == currentAnimInstance then return end
	if currentAnimTrack then currentAnimTrack:Stop(transitionTime) currentAnimTrack:Destroy() end
	if runAnimTrack then runAnimTrack:Stop(transitionTime) runAnimTrack:Destroy() end
	currentAnimSpeed = 1

	currentAnimTrack = animator:LoadAnimation(anim)
	currentAnimTrack.Priority = Enum.AnimationPriority.Core
	currentAnimTrack:Play(transitionTime)
	currentAnim, currentAnimInstance = animName, anim

	if currentAnimKeyframeHandler then currentAnimKeyframeHandler:Disconnect() end
	currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:Connect(keyFrameReachedFunc)

	if animName == "walk" then
		local runIdx = rollAnimation("run")
		runAnimTrack = animator:LoadAnimation(animTable["run"][runIdx].anim)
		runAnimTrack.Priority = Enum.AnimationPriority.Core
		runAnimTrack:Play(transitionTime)
		if runAnimKeyframeHandler then runAnimKeyframeHandler:Disconnect() end
		runAnimKeyframeHandler = runAnimTrack.KeyframeReached:Connect(keyFrameReachedFunc)
	end
end

function playAnimation(animName, transitionTime, humanoid)
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim
	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

local function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-- Tool animation management
local toolAnimName, toolAnimTrack, toolAnimInstance, currentToolAnimKeyframeHandler = "", nil, nil, nil
local function toolKeyFrameReachedFunc(frameName)
	if frameName == "End" then playToolAnimation(toolAnimName, 0.0, Humanoid) end
end

function playToolAnimation(animName, transitionTime, humanoid, priority)
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim
	if anim == toolAnimInstance then return end

	if toolAnimTrack then toolAnimTrack:Stop() toolAnimTrack:Destroy() transitionTime = 0 end
	toolAnimTrack = animator:LoadAnimation(anim)
	if priority then toolAnimTrack.Priority = priority end
	toolAnimTrack:Play(transitionTime)
	toolAnimName, toolAnimInstance = animName, anim
	if currentToolAnimKeyframeHandler then currentToolAnimKeyframeHandler:Disconnect() end
	currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:Connect(toolKeyFrameReachedFunc)
end

local function stopToolAnimations()
	if currentToolAnimKeyframeHandler then currentToolAnimKeyframeHandler:Disconnect() end
	if toolAnimTrack then toolAnimTrack:Stop() toolAnimTrack:Destroy() end
	toolAnimName, toolAnimInstance, toolAnimTrack = "", nil, nil
end

-- State change handlers
local function onRunning(speed)
	local heightScale = userAnimateScaleRun and getHeightScale() or 1
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0,0,0)
	local threshold = movedDuringEmote and (Humanoid.WalkSpeed/heightScale) or 0.75
	if speed > threshold * heightScale then
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / 16.0)
		pose = "Running"
	elseif emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
		playAnimation("idle", 0.2, Humanoid)
		pose = "Standing"
	end
end

local function onDied() pose = "Dead" end
local function onJumping() playAnimation("jump", 0.1, Humanoid); jumpAnimTime = jumpAnimDuration; pose="Jumping" end
local function onClimbing(speed)
	if userAnimateScaleRun then speed /= getHeightScale() end
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 5)
	pose="Climbing"
end
local function onFreeFall()
	if jumpAnimTime <= 0 then playAnimation("fall", 0.2, Humanoid) end
	pose="FreeFall"
end
local function onSeated() pose="Seated" end
local function onSwimming(speed)
	if userAnimateScaleRun then speed /= getHeightScale() end
	if speed > 1 then playAnimation("swim", 0.4, Humanoid); setAnimationSpeed(speed/10); pose="Swimming"
	else playAnimation("swimidle", 0.4, Humanoid); pose="Standing" end
end

Humanoid.Died:Connect(onDied)
Humanoid.Running:Connect(onRunning)
Humanoid.Jumping:Connect(onJumping)
Humanoid.Climbing:Connect(onClimbing)
Humanoid.FreeFalling:Connect(onFreeFall)
Humanoid.Seated:Connect(onSeated)
Humanoid.Swimming:Connect(onSwimming)

-- Safe chat emote trigger
local player = game:GetService("Players").LocalPlayer
if player then
	player.Chatted:Connect(function(msg)
		local emote = ""
		if msg:sub(1,3)=="/e " then emote=msg:sub(4)
		elseif msg:sub(1,7)=="/emote " then emote=msg:sub(8) end
		if pose=="Standing" and emoteNames[emote]~=nil then
			playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		end
	end)
end

-- Emote bindable
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	if pose ~= "Standing" then return end
	if emoteNames[emote] ~= nil then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		return true, currentAnimTrack
	elseif typeof(emote)=="Instance" and emote:IsA("Animation") then
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)
		return true, currentAnimTrack
	end
	return false
end

-- Initial idle
if Character.Parent then playAnimation("idle", 0.1, Humanoid); pose="Standing" end

-- Animation loop with safe termination
local alive = true
Humanoid.Died:Connect(function() alive = false end)

local lastTick = 0
while Character.Parent and alive do
	local _, currentGameTime = task.wait(0.1)
	local deltaTime = currentGameTime - lastTick
	lastTick = currentGameTime
	if jumpAnimTime > 0 then jumpAnimTime -= deltaTime end
	if pose=="FreeFall" and jumpAnimTime<=0 then playAnimation("fall",0.2,Humanoid)
	elseif pose=="Seated" then playAnimation("sit",0.5,Humanoid)
	elseif pose=="Running" then playAnimation("walk",0.2,Humanoid)
	elseif pose=="Dead" then stopAllAnimations() end
end
]]></ProtectedString>
							<string name="ScriptGuid">{8496F18F-294C-44FE-A101-25828F9E3289}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Animate.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXD44B05C94A0847A48323A81EB73CD242">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">LeaguePortal</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXD3D12DECAB7248F092F1E9FC0B9E142E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Union</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXBB813CFC30014A1FA9020FF923DBC6D4">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[while true do
	script.Parent.CFrame = script.Parent.CFrame * CFrame.fromEulerAnglesXYZ(0.07,0,0)
	wait(0.01)
end
]]></ProtectedString>
								<string name="ScriptGuid">{B7AD7AFD-E134-445F-8C8F-D06C7CD48BE3}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Rotation.server.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXED08050E04C344C08DAABEEEC0DA70B2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">TemplateUIs</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXB880A7641447421DAB4F71A08AB9F40E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Invite_Buttons_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA87A4952D76A43978D0FB7666C1E336C">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS 						= game:GetService("ReplicatedStorage")
local TS 						= game:GetService("TweenService")
local Plr 						= game.Players.LocalPlayer
local Char 						= Plr.Character or Plr.CharacterAdded:Wait()

-- Modules
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Fight_Params_Mod 			= require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local SE_Mod 					= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Bots_Mod 					= require(Data_Mods_F:WaitForChild("Bots_Mod"))

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Create_Training_Bot		= Channels.CS_Remote_Functions.Create_Training_Bot
local Send_Invite_Notification	= Channels.CS_Remote_Functions.Send_Invite_Notification
local Display_Data				= Channels.Bindable_Events.Display_Data

-- UI References
local Buttons_F = script.Parent:WaitForChild("Buttons_F")
local Cons = {}

function Setup(Button_Data)	
	local uis = game:GetService("UserInputService")
	local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)	
	local Debounce_C = false

	for _, Button in ipairs(Button_Data) do
		local B = Buttons_F:WaitForChild(Button.Name)
		B.Visible = Button.Visible
		if Button.Visible == true then
			B:WaitForChild("Selected").MouseButton1Click:Connect(function()
				if(Debounce_C == false)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(B, Tween_Click, {Size = UDim2.new(0.61875, 0, 0.3, 0)}):Play()
					Button.Callback()
					task.wait(0.25)
					Debounce_C = false
				end
			end)
			B.Xbox.Visible = uis.GamepadEnabled
		end
	end

	-- Gamepad input support
	table.insert(Cons,uis.InputBegan:Connect(function(inp, bool)  
		if bool == true then
			return
		end

		for _, Button in pairs(Button_Data) do
			local B = Buttons_F:WaitForChild(Button.Name)
			if Button.Visible then
				if inp.KeyCode == Button.Gamepad_Button then
					Button.Callback()
				end
			end
		end
	end))
end

function Destroy()
	for _, con in pairs(Cons) do
		con:Disconnect()
	end
	Cons = {}
end

local Error_Color = Color3.fromRGB(225, 0, 0)
local Message_Color = Color3.fromRGB(0, 170, 0)
local Cage_M = script.Parent:WaitForChild("Cage_M").Value
local No_bots = script.Parent:WaitForChild("No_Bots").Value
local Button_Data = {
	{
		Name = "Invite_Friends_B",
		Callback = function() 
			local success, err = Send_Invite_Notification:InvokeServer(Cage_M.Name)
			if not success and err then
				Display_Data:Fire(err, Error_Color)
			end
			SE_Mod.Play_Voice_Over("Matchmaking")
			Display_Data:Fire("Invite sent to all other players in the room ...", Message_Color)	
		end,
		Gamepad_Button = Enum.KeyCode.DPadLeft,
		Visible = not Plr:GetAttribute("IsTutorialRunning"),
	},
	{
		Name = "Bot_Fight_B",
		Callback = function() 
			local isTutorial = Plr:GetAttribute("IsTutorialRunning") 
			local Cage_Type = isTutorial and Fight_Params_Mod.CageType.TUTORIAL or Fight_Params_Mod.CageType.STANDARD
			local Cage_Name = Cage_M.Name
			local Bot_Profile = isTutorial and Bots_Mod.profiles.COACH or Bots_Mod.profiles.NORMAL
			
			local res = Create_Training_Bot:InvokeServer(Cage_Type, Cage_Name, Bot_Profile)
			if res.success == false then
				Display_Data:Fire(res.err, Error_Color)
			end	
		end,
		Gamepad_Button = Enum.KeyCode.DPadRight,
		Visible = not No_bots
	}
}

Setup(Button_Data)
]]></ProtectedString>
							<string name="ScriptGuid">{507FA5F1-2450-4EB5-8405-345A21C09853}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Invite_Buttons_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX1450A15684FA48C49A716AC8C8042EC0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Scoreboard_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX0DCD1C119F4D4D9BB506A8CA9B339BF2">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local RS 						= game.ReplicatedStorage

local PlayerUtils				= require(RS.Modules.PlayerUtils)
local Score_Display_Mod			= require(RS.Design.ScoreDisplay)
--- UI Ref
local Main_F 					= script.Parent.Main_F
local Round_Count_Txt			= Main_F.Round_Counter_F.Round_Counter_Txt
local Scores_Txt 				= Main_F.Scores_F.Score_Txt

-- Variables
local Active_Fight_V, Fight_Char_V, Round_Count_V, Round_Wins_V = nil, nil, nil, nil
local Cage_Type = nil

local function Setup_References()
	local Cage = script.Parent.Parent.Parent
	local Fight_Data = Cage:FindFirstChild("Fight_Data_F")
	if not Fight_Data then
		warn("Fight_Data_F not found in parent")
		return 
	end
	Active_Fight_V = Fight_Data:FindFirstChild("Active_Fight")
	Fight_Char_V = {Fight_Data:FindFirstChild("Fight_Char_1"), Fight_Data:FindFirstChild("Fight_Char_2")}
	Round_Count_V = Fight_Data:FindFirstChild("Round_Count")
	Round_Wins_V = Fight_Data:FindFirstChild("Round_Wins")
	
	Cage_Type = Cage:GetAttribute("Cage_Type")
end


local function Get_Bar_UI(Bar)
	return {
		Loader = Bar:FindFirstChild("Loader",true),
		Txt = Bar:FindFirstChild("Txt",true),
	}
end

local function Get_Fighter_UI(i) 
	return {
		Thumbnail_Img = Main_F.Stats['Fighter'..i..'_Stats']:FindFirstChild("Thumbnail",true),
		Health_Bar = Get_Bar_UI(Main_F.Stats['Fighter'..i..'_Stats']:FindFirstChild('HealthBar',true)),
		Stamina_Bar = Get_Bar_UI(Main_F.Stats['Fighter'..i..'_Stats']:FindFirstChild('StaminaBar',true)),
		Wins_Txt = Main_F.Scores_F['Fighter'..i..'_Wins']
	}
end

local Fighters_UI = {
	Get_Fighter_UI(1),
	Get_Fighter_UI(2)
}

local function Update_Fighter_UI(i)
	local Char = Fight_Char_V[i].Value
	if Char ~= nil then 
		local Plr = Char['_PLAYER_VALUE_'].Value
		local Fight_Data_F = Plr ~= -1 and Plr:FindFirstChild("Fight_Data") or Char:FindFirstChild("Fight_Data")

		local Player_Health = Fight_Data_F:FindFirstChild("Health").Value
		local Player_Stamina= Fight_Data_F:FindFirstChild("Staminia").Value
		
		Fighters_UI[i].Health_Bar.Loader.Size = UDim2.fromScale(Player_Health / 100, 1)
		Fighters_UI[i].Health_Bar.Txt.Text =  tostring(Player_Health)
		
		Fighters_UI[i].Stamina_Bar.Loader.Size = UDim2.fromScale(Player_Stamina / 100, 1)
		Fighters_UI[i].Stamina_Bar.Txt.Text =  tostring(Player_Stamina)
	end 
end

local Fighters_Cons = {}

--local function Disconnect_Fighters_Cons()
--	for i = 1, #Fighters_Cons do
--		if(Fighters_Cons[i] ~= nil)then
--			Fighters_Cons[i]:Disconnect()
--		end
--	end
--	Fighters_Cons = {}
--end

local function Setup_Figther_UI(i)
	local Char = Fight_Char_V[i].Value
	local Plr = Char['_PLAYER_VALUE_'].Value
	local Fight_Data_F = Plr ~= -1 and Plr:FindFirstChild("Fight_Data") or Char:FindFirstChild("Fight_Data")
	
	local Player_Health_V = Fight_Data_F:FindFirstChild("Health")
	local Player_Stamina_V= Fight_Data_F:FindFirstChild("Staminia")
	
	table.insert(Fighters_Cons, Player_Health_V.Changed:Connect(function() 
		Update_Fighter_UI(i)
		end))
	table.insert(Fighters_Cons, Player_Stamina_V.Changed:Connect(function() 
		Update_Fighter_UI(i)
	end))
	
	Update_Fighter_UI(i)
	
	local Player_Image =  Plr ~= -1 and PlayerUtils.Get_Player_Image(Plr.UserId) or "rbxassetid://134663290660847"
	Fighters_UI[i].Thumbnail_Img.Image = Player_Image 
end

local function Update_Scoreboard()
	Main_F.Visible = Active_Fight_V.Value
	if Active_Fight_V.Value == true and Fight_Char_V[1].Value ~= nil and Fight_Char_V[2].Value ~= nil then 
		local score_fighter_1, score_fighter_2, score = Score_Display_Mod.Get_Wins_Labels(
			Round_Wins_V.Value, 
			Fight_Char_V[1].Value.Name,
			Fight_Char_V[2].Value.Name,
			Cage_Type)
		
		Round_Count_Txt.Text = "ROUND "..Round_Count_V.Value
		Scores_Txt.Text = score
		Fighters_UI[1].Wins_Txt.Text = score_fighter_1
		Fighters_UI[2].Wins_Txt.Text = score_fighter_2
		
		Update_Fighter_UI(1)
		Update_Fighter_UI(2)
	end
end

local function Init()
	Setup_References()

	Active_Fight_V.Changed:Connect(Update_Scoreboard)
	Round_Wins_V.Changed:Connect(Update_Scoreboard)
	Setup_Figther_UI(1)
	Setup_Figther_UI(2)

	Update_Scoreboard()
end

--local surfaceGui = script.Parent
--surfaceGui.AncestryChanged:Connect(Init)
Init()

]]></ProtectedString>
							<string name="ScriptGuid">{C96D8F40-1BF9-46F4-896D-5B54E5A40CB3}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Scoreboard_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>