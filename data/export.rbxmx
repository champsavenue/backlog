<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXF81FF8BE366347398DCDF0B2B726FA34">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">_ScriptExport</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX679661D1100146988DADA6824A5D8728">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Workspace</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX9A764ACCD42B44469080375FCB88DAB2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[SEB
	- remove warn into Utils.SecureRemote and SecureFunction

ADNAN	
	- 
		
ORIANE
	-]]></ProtectedString>
					<string name="ScriptGuid">{0A957D4E-04DE-4A21-81C0-BF0E544FF4BD}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">TO_CHECK_BEFORE_RELEASE.server.lua</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX10C8C3734A094C938FB08910886F788D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main_World_F</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXD8747FF0C8854B4088044AF482C486E8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Environment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX3669ECA0C7034F21A077C89078AD04A6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Art</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXD4627A50A3804B0DAC882FEDEF31767B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Shop</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX0618EB2EA5F442618F266A0557253892">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Shop_Improvement</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBXA74FB0F7B3714168AEB66C7F0A2547D6">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">ShopTxtTopRight</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX54503BF87CDB47F3A93AB19A5A926125">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ShopTxtLights</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX82546E048147487496431864A2977C4C">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
												<string name="ScriptGuid">{3991B7DF-8535-4B6B-9CE7-A6914E8E6E3D}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ApplyLights.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBXF2F75685A5C744EDBA0B7057C412889C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Arrow</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX6E59E145471D4072AC815C90FF7A75DE">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ArrowBodyTransparent</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBXCCCB1C801D8548788D1ED2FA06164381">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")

-- Constants
local OFFSET_STUDS = -30
local MOVE_TIME = 2.0
local HOLD_TIME = 0.25
local RESET_PAUSE = 1.0
local EASING_STYLE = Enum.EasingStyle.Sine
local EASING_DIR = Enum.EasingDirection.InOut
local FADE_DECALS_AND_TEXTURES = true

-- Locate model
local model = script:FindFirstAncestorOfClass("Model")
assert(model, "This script must be parented under the Model you want to tween.")

-- Collect parts and decals/textures
local parts, decalsOrTextures = {}, {}
for _, d in ipairs(model:GetDescendants()) do
	if d:IsA("BasePart") then
		parts[#parts + 1] = d
	elseif FADE_DECALS_AND_TEXTURES and (d:IsA("Decal") or d:IsA("Texture")) then
		decalsOrTextures[#decalsOrTextures + 1] = d
	end
end

-- Cache original transparency
local originalTransparency = {}
for _, obj in ipairs(parts) do originalTransparency[obj] = obj.Transparency end
for _, obj in ipairs(decalsOrTextures) do originalTransparency[obj] = obj.Transparency end

local function resetVisuals()
	for obj, t in pairs(originalTransparency) do
		if obj and obj.Parent then
			obj.Transparency = t
		end
	end
end

local homeCF = model:GetPivot()

local function tweenTransparency(targetTransparency)
	local tweens = {}
	local info = TweenInfo.new(MOVE_TIME, EASING_STYLE, EASING_DIR)
	for _, obj in ipairs(parts) do
		if obj.Parent then
			tweens[#tweens + 1] = TweenService:Create(obj, info, { Transparency = targetTransparency })
		end
	end
	for _, obj in ipairs(decalsOrTextures) do
		if obj.Parent then
			tweens[#tweens + 1] = TweenService:Create(obj, info, { Transparency = targetTransparency })
		end
	end
	for _, tw in ipairs(tweens) do tw:Play() end
	return tweens
end

local function runOnce()
	local proxy = Instance.new("CFrameValue")
	proxy.Value = homeCF
	local connection = proxy:GetPropertyChangedSignal("Value"):Connect(function()
		if model.Parent then
			model:PivotTo(proxy.Value)
		end
	end)

	local goalCF = homeCF * CFrame.new(0, 0, OFFSET_STUDS)
	local info = TweenInfo.new(MOVE_TIME, EASING_STYLE, EASING_DIR)
	local moveTween = TweenService:Create(proxy, info, { Value = goalCF })

	-- Run movement + fade together
	moveTween:Play()
	tweenTransparency(1)
	moveTween.Completed:Wait()

	task.wait(HOLD_TIME)

	-- Reset
	connection:Disconnect()
	model:PivotTo(homeCF)
	resetVisuals()
	proxy:Destroy()

	task.wait(RESET_PAUSE)
end

while task.wait() do
	runOnce()
end
]]></ProtectedString>
												<string name="ScriptGuid">{F5416E0F-722F-409F-8285-7A351022AA78}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">move.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="Folder" referent="RBX84208BA047354E85921D92516E92A5B5">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ShopTxt</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBXC38312FA97A947C280944C5B06AE3897">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ShopTxtLights</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBX76D3A1B7AC4541AE91444BE974CED9A0">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
													<string name="ScriptGuid">{550514C8-1158-4368-B870-E628DD79CA19}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">ApplyLights.server.lua</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="ModuleScript" referent="RBX3B2989030DF6477A9ECF78DEBF6FB72C">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
													<string name="ScriptGuid">{66ED64A8-5DD8-4613-9C05-514B7A76F042}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">ApplyLights.server.lua (2)</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
											<Item class="Folder" referent="RBXB0F9ED044403418DBECE98CE4562D2B3">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">ShopText</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX2D070BAD8625482485A4288551F457A1">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local parent = script.Parent.Parent 

local tweenInfo = TweenInfo.new(
	1,                      
	Enum.EasingStyle.Linear,  
	Enum.EasingDirection.InOut,
	0, false, 0
)

local rng = Random.new()

local EXCLUDE_CYAN_HALF_WIDTH = 0.04
local CYAN_HUE = 0.5  

local function hueInBand(h, center, half)
	-- circular distance on the hue ring
	local d = math.abs(((h - center + 0.5) % 1) - 0.5)
	return d <= half
end

local function randomDiscoColor()
	local h
	repeat
		h = rng:NextNumber(0, 1)
	until not hueInBand(h, CYAN_HUE, EXCLUDE_CYAN_HALF_WIDTH)
	return Color3.fromHSV(h, 1, 1)
end

while true do
	local goal = {Color = randomDiscoColor()}
	for _, obj in ipairs(parent:GetDescendants()) do
		if obj:IsA("MeshPart") then
			local tween = TweenService:Create(obj, tweenInfo, goal)
			tween:Play()
		end
		if obj:IsA("SpotLight") then
			local tween = TweenService:Create(obj, tweenInfo, goal)
			tween:Play()
		end
	end
	task.wait(5) 
end
]]></ProtectedString>
														<string name="ScriptGuid">{D9B26E4A-F38D-47EE-9F90-E0FD6C430362}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">DiscoLights.server.lua</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBXF0201D0EF6D24E4B8D3EC7B33E035DCF">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">ShopTxtTopFront</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX60B76BC351FC40B88C1CB65C74C1EAC5">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">ShopTxtLights</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX54F3EE197D2141379317C532A2172CB1">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
												<string name="ScriptGuid">{F745F52B-0B97-4F65-9C53-4D1933EF3742}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ApplyLights.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX8EA50F958799403FA286AB5CE1C389F4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Gameplay</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXBAD082D5CCF74B1EB364E72069042803">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Objects</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXA3A79B14BC7E44A0A08D0944D3A1F72E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">TeleportPads</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX845C5C92DF2D43A48AC055B887A7E1A6">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local inside = {}    -- [userId] = zone actuelle
local lastZone = {}  -- [userId] = zone d'où il vient

local function isInZone(hrp, zone)
	if not hrp or not zone or not zone:IsA("BasePart") then return false end
	local rel = hrp.Position - zone.Position
	return math.abs(rel.X) <= zone.Size.X / 2
		and math.abs(rel.Y) <= zone.Size.Y / 2
		and math.abs(rel.Z) <= zone.Size.Z / 2
end

local function warpPlayer(player, fromZone, toPad)
	local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
	local toZone = toPad:FindFirstChild("TeleportZone")
	if not hrp or not toZone then return end

	local pos = toZone.Position + Vector3.new(0, 3, 0)
	local lookAt = pos + hrp.CFrame.LookVector
	player.Character:PivotTo(CFrame.new(pos, lookAt))

	hrp.AssemblyLinearVelocity = Vector3.new()
	hrp.AssemblyAngularVelocity = Vector3.new()

	inside[player.UserId] = toZone
	lastZone[player.UserId] = fromZone
end

RunService.Heartbeat:Connect(function()
	for _, player in pairs(game.Players:GetPlayers()) do
		local char = player.Character
		local hrp = char and char:FindFirstChild("HumanoidRootPart")
		if not hrp then continue end

		local currentZone = inside[player.UserId]

		for _, teleporter in pairs(script.Parent:GetChildren()) do
			if not teleporter:IsA("Model") then continue end
			local zone = teleporter:FindFirstChild("TeleportZone")
			local linkedValue = zone and zone:FindFirstChild("LinkedPad")
			if not zone or not linkedValue or not linkedValue.Value then continue end

			local inZone = isInZone(hrp, zone)

			-- Entrée dans une zone
			if inZone and currentZone ~= zone then
				-- bloquer retour instantané
				if linkedValue.Value == lastZone[player.UserId] then
					-- ignore ce TP, joueur vient juste de cette zone
					continue
				end
				warpPlayer(player, zone, linkedValue.Value)
				break
			end

			-- Sortie d'une zone
			if not inZone and currentZone == zone then
				inside[player.UserId] = nil
			end
		end
	end
end)
]]></ProtectedString>
									<string name="ScriptGuid">{138569D6-5CD1-4A10-BF9A-031A28148F76}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Teleport.server.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX3CA2B7843D154883855E6066335918E4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Rankings</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX0145757304F049C18DCB465DA4159A4A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">1_Stand</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBXFA278EB20E5C4968BB28034B1BA40F53">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Spotlight</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBXAE0DF6FCA24544A59D19F2D0C7B36352">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Model</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX0A25608F19B44113AF97B305B2C1A3B0">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
												<string name="ScriptGuid">{D0092FFE-E8AA-4587-8385-06F4A4568B17}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ApplyLights.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXDE219F2020834E1788F6473D49F288B6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">2_Stand</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX9944252114A047779B021967D1848822">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Spotlight</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBXECFFB5F93BCD446E97A2E12F8143B5F4">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Model</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBXB1E26EF44957485F939076D878DCB8FA">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
												<string name="ScriptGuid">{01A701BD-807A-4EB8-A4F9-38A9472656E1}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ApplyLights.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXA0C7F291AD574082A6E4C4E2F1063EF1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">3_Stand</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX4500509D351F4B4EA914ADB64FBDBF35">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Spotlight</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBXA61DBB3ED6D644708F543CF0B8380827">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Model</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX0E653FB9760A4D3792B2E9C1D2E5B1FB">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local parent = script.Parent  -- parent of your MeshPart
local DL = require(game.ReplicatedStorage.Data_Mods_F.DiscoLights_Mod)
local myObj=DL.new(parent:GetDescendants())
myObj:StartLights()]]></ProtectedString>
												<string name="ScriptGuid">{5B530399-EADF-4600-B926-218ED568153E}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">ApplyLights.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXF1B0A9975F87416BB30AF9BEE14BB710">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Shop</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX5213392841444915B41C7057A0E55D41">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Offers_Data</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXCE82CB7C2DF743B49C1C4F625DE1B896">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Display_Podium_Left</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXE104B2E9449F41709AF2EF6E5F3B1C4B">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[local Color_Mod = require( game.ReplicatedStorage.Data_Mods_F:WaitForChild("PodiumColors_Mod"))
local colorObj=Color_Mod.new(script.Parent, "S1", {

	{
		Name = {"Region/Base","Region/RingAlpha","RegionLite/Base","RegionLite/RingAlpha"},
		Use  = "NeonEffectColor",
	},
	{
		Name = "TextLabel",
		Use  = "RibbonGradient", -- multi-stop, UIGradient with Rotation=40
	}
},
{
	CanSetText=true,
	TextObjName="TextLabel",
	Text="EXCLUSIVE OFFER!"
})]]></ProtectedString>
										<string name="ScriptGuid">{D0F6E35E-77F1-402B-A8A9-882F85789FCF}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Display_Podium_Left_ColorAdjustemt.server.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Folder" referent="RBX6A8D71D17F4F45C68494194DFCD5AE55">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">OfferAttachment</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBXB3F49E54BB7A44979A633964A9FCF280">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/OffersService.lua
--
--  Description:
--      Handles cloth offers for players. Manages showing offers, saving
--      and loading offer states via DataStoreService, and syncing offer
--      data with clients using RemoteEvents and RemoteFunctions.
--
--      Key features:
--        - Trigger offers when player interacts with GateToEnterPrompt
--        - Store active and expired cloth offers per player
--        - Fire RemoteEvents to client to display offers
--        - Retrieve current cloth offer for a player
--        - Update player's offer attributes and state
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-3 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Remotes/Offers/UGC/ShowOfferSignalBind (RemoteEvent)
--          * Remotes/Offers/GetCurrentClothOffer (RemoteFunction)
--          * Remotes/Offers/ClothItemIdSignal (RemoteEvent)
--      - Roblox Services:
--          * DataStoreService (Player offer state persistence)
--      - Player Instances:
--          * Attributes: ClothItemData_Type, ClothItemData_Key
--          * ActiveOffer and expiredItems in DataStore
--
--  Notes:
--      - Uses DataStore "PlayerOfferState" to persist offer data
--      - Maintains a max of 30 expired items per player
--      - Dynamically updates player attributes when a new offer is claimed
--      - Offers are uniquely identified by Key + Kind
--      - Handles both server-triggered and client-triggered events
--
--======================================================================
-- Services
local RS 					 = game:GetService("ReplicatedStorage")
local DSS 					 = game:GetService("DataStoreService")
local OfferStore 			 = DSS:GetDataStore("PlayerOfferState")
local RunService 			 = game:GetService("RunService")
-- Modules
local OfferConfig 			 = require(game.ReplicatedStorage:WaitForChild("Data_Mods_F"):WaitForChild("Offers_Config"))

-- Events
local Channels 			   	 = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local ShowOfferSignalBind	 = Channels.Offers.ShowOfferSignalBind
local GetCurrentClothOffer	 = Channels.Offers.GetCurrentClothOffer
local ClothItemIdSignal 	 = Channels.Offers.ClothItemIdSignal

local parent = script.Parent
local GateToEnterPrompt=parent.Prompt
GateToEnterPrompt.ActionText	= OfferConfig.Podiums.LeftPodium.prompt

local isMoving=false

function UpDownGlove(target, opts)
	opts = opts or {}
	isMoving=true
	local amplitude       = tonumber(opts.amplitude) or 2      -- vertical travel (studs)
	local freq            = tonumber(opts.freq)      or 0.2    -- bob cycles per second
	local spinDegPerStep  = tonumber(opts.spinDegPerStep) or 0.5

	-- accept either a Model or a BasePart; if nil, fall back to self.ClonedObjBasePart / self.Model
	--target = target or self.Model or self.ClonedObjBasePart
	if not target then return end

	local isModel = target:IsA("Model")
	local getCF   = function()
		return isModel and target:GetPivot() or target.CFrame
	end
	local setCF   = function(cf)
		if isModel then
			target:PivotTo(cf)
		else
			target.CFrame = cf
		end
	end

	local originCF = getCF()
	local t0       = os.clock()
	local spin     = 0
	local spinStep = math.rad(spinDegPerStep)

	isMoving= true
	while isMoving and target do
		local t = os.clock() - t0
		local y = (math.sin(2 * math.pi * freq * t) + 1) * (amplitude / 2)  -- 0..amplitude

		spin += spinStep
		setCF(originCF * CFrame.new(0,y, .1) * CFrame.Angles(0, spin, 0))

		RunService.Heartbeat:Wait()
	end
end







GateToEnterPrompt.Triggered:Connect(function(player)

	local Itype = player:GetAttribute("ClothItemData_Type")
	local IKey = player:GetAttribute("ClothItemData_Key")
	ShowOfferSignalBind:Fire(player,Itype,IKey)

end)




local function loadOfferState(plr)
	local key = "ClothOffer_" .. plr.UserId

	local ok, err = pcall(function()
		return OfferStore:GetAsync(key)
	end)
	if ok and err then
		return err
	else
		--print("Failed to load offer state for", plr.UserId, err)
	end
	return nil
end

local function saveOfferState(plr, offerAC)
	local key = "ClothOffer_" .. plr.UserId
	local now=os.time() 
	local ok, err = pcall(function()
		OfferStore:UpdateAsync(key, function(old)
			old = old or {}
			old.expiredItems = old.expiredItems or {}
			local prev = old.ActiveOffer

			if prev then
				local expCount = #old.expiredItems
				if expCount == 30 then
					old.expiredItems={}
				else
					table.insert(old.expiredItems, {
						Key = prev.CurrentKey,
						EndedAt = now,
						EndReason ="expired",
					})
				end
			end

			old.ActiveOffer = {
				CurrentKey =offerAC.Key.."_"..offerAC.Kind,
				EndsAt = offerAC.EndsAt,
			}
			return old
		end)
	end)

	if not ok then
		warn("Failed to save offer state:", err)
	end
end

GetCurrentClothOffer.OnServerInvoke=function(player)
	local PP =	loadOfferState(player)
	task.wait()
	if PP then
		local data =string.split(PP.ActiveOffer.CurrentKey,"_")	
		local ofer = OfferConfig.GetAndCreateClothOfferOnKey(player,data[1],data[2],PP.EndsAt or nil)
	end
	return nil
end

ClothItemIdSignal.OnServerEvent:Connect(function(plr, offer)
	local Itype = plr:SetAttribute("ClothItemData_Type",offer.Kind)
	local IKey = plr:SetAttribute("ClothItemData_Key",offer.Key)
	local profile = loadOfferState(plr)
	
	if profile ~= nil and profile.ActiveOffer ~= nil then

		local data =string.split(profile.ActiveOffer.CurrentKey,"_")	
		if offer.Kind == data[2] and offer.Key == data[1] then
			return
		end
	end
	saveOfferState(plr, offer)
end)]]></ProtectedString>
											<string name="ScriptGuid">{438CEC78-BF21-45ED-8B42-0BD84F0FD518}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Display_Podium_Left.server.lua</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="Folder" referent="RBX937007CDB6F54F8CA72C7A57B62142EE">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">RegionLite</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX28326270026F4ACE99DFCF2A0DE7D6BF">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">RingAlpha</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBXF36ECEB501484C90BF2A8809D25173AA">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
												<string name="ScriptGuid">{CDE2DF27-7840-45AE-9E19-460C2771C1CC}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Rotate.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="Folder" referent="RBXB26C9DE6DE034DF3BB47169A058F4EB1">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Base</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX26D314488D074A2DBF0379525C6626AA">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
												<string name="ScriptGuid">{DC920CD4-63B3-41E1-A710-EC6DA2AEC81D}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Rotate.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXE6E23A0566E849EBA5C31A896827F14E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">UGCPodiums</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX014F6AC96DF84E99AA04B6EED00F1A71">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">1-Display_Podium</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBXE70487EB07A54197A2C91A35B8468D0F">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[local Color_Mod = require( game.ReplicatedStorage.Data_Mods_F:WaitForChild("PodiumColors_Mod"))

local colorObj=Color_Mod.new(script.Parent, "S2", {
	{
		Name = {"Region/Base","Region/RingAlpha","RegionLite/Base","RegionLite/RingAlpha"},
		Use  = "NeonEffectColor",
	},
	{
		Name ="TextLabel",
		Use  = "RibbonGradient",
	},
},
{
	CanSetText=true,
	TextObjName="TextLabel",
	Text="UGC EPIC CREATIONS"
})]]></ProtectedString>
											<string name="ScriptGuid">{A5EC8EDD-7E78-47DA-AC32-A6E86BAA97EF}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">1-Display_Podium_ColorAdjustemt.server.lua</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="Folder" referent="RBXAD1F4C49D15C4A8B89058E40CAB4A4A9">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">RegionLite</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBX611A8469A9A94DBBAB192EA8462C1047">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">RingAlpha</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBX33A9F93D671E4B008C4808AC184E9900">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
													<string name="ScriptGuid">{E716B557-A05B-43C1-86EB-3AFA8088C55E}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Rotate.server.lua</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
										<Item class="Folder" referent="RBX28D1198597944316809DD1D71330EA1A">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Base</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBX3D8C469E6B96483AAE87C341082B116E">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
													<string name="ScriptGuid">{D994B802-3DA5-4F1B-8FE4-E52ED05A66B9}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Rotate.server.lua</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX5B68853F699E426B888BFAE83C20231D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Display_Podium_Right</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX3B058770CF584F5D91CB23ED5AC8B5A4">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[
local Color_Mod = require( game.ReplicatedStorage.Data_Mods_F:WaitForChild("PodiumColors_Mod"))

local colorObj=Color_Mod.new(script.Parent, "S3", {
	{
		Name = {"Region/Base","Region/RingAlpha","RegionLite/Base","RegionLite/RingAlpha"},
		Use  = "NeonEffectColor",
	},
	{
		Name ="TextLabel",
		Use  = "RibbonGradient",
	},
},
{
	CanSetText=true,
	TextObjName="TextLabel",
	Text="GET NEW EQUIPMENT"
})]]></ProtectedString>
										<string name="ScriptGuid">{F6FEACF7-1FF0-4ECB-AB0C-0DE9955BEF83}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Display_Podium_Right_ColorAdjustemt.server.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Folder" referent="RBXBCE83F984082499690DBC5F5135BE230">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">OfferAttachment</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX630DA375BEE74C2486E3B65FF3AEB54A">
										<Properties>
											<Content name="LinkedSource"><null></null></Content>
											<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/CoinGatePurchase.lua
--
--  Description:
--      Handles in-game purchases when a player interacts with the
--      GateToEnterPrompt. Uses MarketplaceService to prompt the
--      purchase of DevProducts (Coins or Gems) based on player's
--      current internal currency.
--
--      Key features:
--        - Checks player's Coins to determine which DevProduct to prompt
--        - Triggers MarketplaceService purchase prompt on player interaction
--        - Supports dynamic selection between Coins and Gems products
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-13 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * MarketplaceService (for DevProduct purchases)
--      - Player Instances:
--          * Player.Player_Data.Coins (used to check player's balance)
--
--  Notes:
--      - DevProduct IDs:
--          * Coins: 3306908329
--          * Gems: 3306910278
--      - Purchase logic uses a coin limit (cointLimit = 5000) to decide
--        which product to prompt
--      - Triggered when player interacts with GateToEnterPrompt
--======================================================================

-- Services
local RunService 				= game:GetService("RunService")
local RS 						= game:GetService("ReplicatedStorage")

-- Modules
local Data_Mods_F 				= RS:WaitForChild("Data_Mods_F")
local Offers_Config 			= require(Data_Mods_F:WaitForChild("Offers_Config"))
local Channels 					= require(game.ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Channels"))
local Open_Shop					= Channels.SC_Remote_Events.Open_Shop

local parent 					= script.Parent
local GateToEnterPrompt 		= parent.Prompt
GateToEnterPrompt.ActionText	= Offers_Config.Podiums.RightPodium.prompt

local isMoving					= false
local IsShort					= false

function UpDownGlove(target, opts)
	opts = opts or {}
	isMoving=true
	local amplitude       = tonumber(opts.amplitude) or 2      -- vertical travel (studs)
	local freq            = tonumber(opts.freq)      or 0.2    -- bob cycles per second
	local spinDegPerStep  = tonumber(opts.spinDegPerStep) or 0.5

	-- accept either a Model or a BasePart; if nil, fall back to self.ClonedObjBasePart / self.Model
	--target = target or self.Model or self.ClonedObjBasePart
	if not target then return end

	local isModel = target:IsA("Model")
	local getCF   = function()
		return isModel and target:GetPivot() or target.CFrame
	end
	local setCF   = function(cf)
		if isModel then
			target:PivotTo(cf)
		else
			target.CFrame = cf
		end
	end

	local originCF = getCF()
	local t0       = os.clock()
	local spin     = 0
	local spinStep = math.rad(spinDegPerStep)

	isMoving= true
	while isMoving and target do
		local t = os.clock() - t0
		local y = (math.sin(2 * math.pi * freq * t) + 1) * (amplitude / 2)  -- 0..amplitude

		spin += spinStep
		setCF(originCF * CFrame.new(0,y, .1) * CFrame.Angles(0, spin, 0))

		RunService.Heartbeat:Wait()
	end
end



task.spawn(function()
	UpDownGlove(parent.Parent.Display)
end)

local function ApplyDisplay()
	local disp =parent.Parent.Display
	for _,item in pairs(disp:GetDescendants()) do
		if item:IsA("MeshPart") then
			item.Transparency=1
		end
	end
	local showable = IsShort and disp:FindFirstChild("Short") or disp:FindFirstChild("Gloves")
	for _,item in pairs(showable:GetDescendants()) do
		if item:IsA("MeshPart") then
			item.Transparency=0
		end
	end
	
end

task.spawn(function()
	while true do
		ApplyDisplay()
		task.wait(30)
		IsShort =( not IsShort )
	end
end)

GateToEnterPrompt.Triggered:Connect(function(player)
	Open_Shop:FireClient(player, IsShort and "Shorts" or "Gloves")
end)]]></ProtectedString>
											<string name="ScriptGuid">{A9A2297A-69C0-44B5-8FF4-D71910FE6E58}</string>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Display_Podium_Right.server.lua</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="Folder" referent="RBX1102AD71A2B94F36BD0E5E9A55F6C60C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">RegionLite</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX67787F6B67794F1D8DBA56E03FC01688">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">RingAlpha</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBXFBBB9CAD643C410686F7C3F773B6A951">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
												<string name="ScriptGuid">{16FFA136-606D-48BF-824E-B37AD0EAF0B1}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Rotate.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
									<Item class="Folder" referent="RBX40FFEF9C7F954560B7EBDDCE36F20BE2">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Base</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX64918BDFCBEC4CFA95D091C48656311D">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
												<string name="ScriptGuid">{87E09D95-D41A-4FAF-BDC7-D227154F237D}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Rotate.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX9D121638E4E740BABE9F23322DF045A4">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local parent = script.Parent.Parent  -- parent of your MeshPart

-- Tween settings
local tweenInfo = TweenInfo.new(
	1,                      -- duration for each color change
	Enum.EasingStyle.Linear,  -- smooth change
	Enum.EasingDirection.InOut,
	0, false, 0
)

-- Function to make a random bright color
local function randomDiscoColor()
	return Color3.fromHSV(math.random(), 1, 1) -- random hue, full saturation, full brightness
end

while true do
	for _, obj in ipairs(parent:GetDescendants()) do
		if obj:IsA("MeshPart") then
			local goal = {Color = randomDiscoColor()}
			local tween = TweenService:Create(obj, tweenInfo, goal)
			tween:Play()
		end
	end
	task.wait(1) -- sync with tween duration
end
]]></ProtectedString>
												<string name="ScriptGuid">{1FAFD768-0CEA-40CC-BF1C-A7BDE45FA665}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">DiscoLights.server.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX6D20024C897C4209B6427C05897125E0">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ReplicatedFirst</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX5FF4A04329BD45C487419A2D76A0F664">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local Players 				= game:GetService("Players")
local player 				= Players.LocalPlayer
local TweenService 			= game:GetService("TweenService")
local ContentProvider 		= game:GetService("ContentProvider")
local RunService 			= game:GetService("RunService")
local ThemeManagerModule 	= game.ReplicatedStorage:WaitForChild("Design", 1):WaitForChild("ThemeManager", 1)
local ThemeManager 			= require(ThemeManagerModule)
local StartupUIManager 		= require(game.ReplicatedStorage.Modules.StartupUIManager)

--  UIs to preload
local CriticalUIs = {
	"Shop/Offer_UI",
	"Menus/Rewards_UI"
}

-- UI references
local ui = script:WaitForChild("Loading_UI", 5)
if not ui then return warn("[LoadingUI] Missing Loading_UI") end
ui.Parent = player:WaitForChild("PlayerGui", 5)
ui.Enabled = true

local canvas = ui:WaitForChild("CanvasGroup")
local Logo = canvas:WaitForChild("Logo")
local ScalingLogo = Logo:WaitForChild("Frame")
ScalingLogo.Size = UDim2.new(1, 0, 0, 0)

local FightImages = {
	canvas:WaitForChild("FightImage1"),
	canvas:WaitForChild("FightImage2"),
}

local splashscreens = ThemeManager.getAttribute("splashscreens")

-- === Helpers ===
local function safePreload(instances, timeoutSec)
	local done, ok = false, false
	task.spawn(function()
		ok = pcall(function() ContentProvider:PreloadAsync(instances) end)
		done = true
	end)
	local t0 = time()
	while not done and time() - t0 < (timeoutSec or 3) do
		RunService.Heartbeat:Wait()
	end
	return ok or done
end

local function setImage(imgObj, assetId)
	if not imgObj then return false end
	local ok, err = pcall(function() imgObj.Image = assetId end)
	if not ok then warn("[LoadingUI] Failed to set image:", assetId, err) end
	return ok
end

-- === UI Animations ===
local function showInitialImage()
	for _,img in ipairs(FightImages) do img.Visible = false end

	math.randomseed(os.time() + tonumber(tostring({}):sub(8), 16))
	
	local chosenImage = splashscreens[math.random(1, #splashscreens)]
	setImage(FightImages[1], chosenImage)

	safePreload({FightImages[1], ScalingLogo}, 2.0)

	FightImages[1].Visible = true
	TweenService:Create(ScalingLogo, TweenInfo.new(0.3), {
		Size = UDim2.new(1, 0, 0.25, 0)
	}):Play()
end

local function startCarousel()
	task.spawn(function()
		local frames = {FightImages[1], FightImages[2]}
		local idx, previous = 1, FightImages[1]

		while ui and ui.Parent do
			task.wait(3)

			local frame = frames[idx]
			frame.Position = UDim2.new(0.55, 0, 0.5, 0)
			frame.ImageTransparency = 1
			setImage(frame, splashscreens[math.random(1, #splashscreens)])

			if previous then
				TweenService:Create(previous, TweenInfo.new(0.3), {ImageTransparency = 1}):Play()
			end
			TweenService:Create(frame, TweenInfo.new(3, Enum.EasingStyle.Linear), {
				Position = UDim2.new(0.45, 0, 0.5, 0),
				ImageTransparency = 0
			}):Play()

			previous = frame
			idx = (idx % #frames) + 1
		end
	end)
end

local function exitLoading()
	task.spawn(function()
		for i = 1, 4 do
			task.wait(0.15 + math.random()*0.05)
			TweenService:Create(ScalingLogo, TweenInfo.new(0.2), {
				Size = UDim2.new(1, 0, i/4, 0)
			}):Play()
		end
		task.wait(0.6)
		TweenService:Create(canvas, TweenInfo.new(0.25), {GroupTransparency = 1}):Play()
		task.wait(0.4)
		if ui then ui:Destroy() end
	end)
end


local function preloadCriticalUIs()
	local PlayerGui = player:WaitForChild("PlayerGui")
	local toPreload = {}

	local function getUIByPath(root, path)
		local current = root
		for segment in string.gmatch(path, "[^/]+") do
			current = current:FindFirstChild(segment)
			if not current then
				return nil
			end
		end
		return current
	end

	for _, path in ipairs(CriticalUIs) do
		local uiObj = getUIByPath(PlayerGui, path)
		if uiObj then
			for _, d in ipairs(uiObj:GetDescendants()) do
				if d:IsA("ImageLabel") or d:IsA("ImageButton") or d:IsA("Sound") then
					table.insert(toPreload, d)
				end
			end
		else
			warn(string.format("[LoadingUI] Critical UI not found: %s", path))
		end
	end

	if #toPreload > 0 then
		safePreload(toPreload, 3.0)
	end
end



-- === Main Flow ===
local MIN_DISPLAY_TIME = 3  -- seconds
local startTime = os.clock()

showInitialImage()
startCarousel()
preloadCriticalUIs()

-- === Background Audio Preload (non-blocking) ===
task.spawn(function()
	local function collectSounds(folder)
		local list = {}
		for _, obj in ipairs(folder:GetDescendants()) do
			if obj:IsA("Sound") then
				table.insert(list, obj)
			end
		end
		return list
	end

	local AudioFolder = game.ReplicatedStorage:FindFirstChild("Audio")
	if AudioFolder then
		local sounds = collectSounds(AudioFolder)
		if #sounds > 0 then
			pcall(function()
				ContentProvider:PreloadAsync(sounds)
			end)
		end
	end
end)

-- Ensure minimum display duration before exit
local elapsed = os.clock() - startTime
if elapsed < MIN_DISPLAY_TIME then
	task.wait(MIN_DISPLAY_TIME - elapsed)
end

exitLoading()

task.defer(function()
	--StartupUIManager.start()
	game.ReplicatedStorage.Channels_F.Bindable_F.Events.Game_Loading_Finished:Fire()
end)]]></ProtectedString>
					<string name="ScriptGuid">{8697679C-4F74-4875-AE7A-395C380FE267}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">LoadingScreen.client.lua</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX1EA61B9A93D0465EAD09EA0A2B2A3BEC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">LoadingScreen</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX80A9225079794869985AADF5696E14AF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Loading_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXCB931784B1BA43AFACFD5B49EE7C05EF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CanvasGroup</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX706F542CCAFB4B2CB489D118BFA52260">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">TextLabel</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX9BA48E215B124BB2AFFC9B1327DB0FF4">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local textOne = script.Parent
local textTwo = textOne:WaitForChild("TextLabel")

local updateDelay = 1/5

local iterator = 1

while textOne do
	local text = `Loading{string.rep(".",iterator%4)}`
	textOne.Text = text
	textTwo.Text = text
	task.wait(updateDelay)
	iterator += 1
end]]></ProtectedString>
									<string name="ScriptGuid">{9B28FE5C-98E2-4112-B632-8CE83AD81044}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalScript.client.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX93CBD4CEC6384765B88018E816E990B3">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">StarterPlayer</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX57C92C93FD694996BDCA78D5365471F6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">StarterPlayerScripts</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX8825AAD9977F4FFA85FEEB77035A2EF9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Ranked_Wall_Handle.lua
--
--  Description:
--      Handles the ranked arena access wall for players.
--      Displays a progress bar based on the player's total wins and
--      removes the wall once the required wins threshold is reached.
--
--  Author(s): Exclusible, Darkzeb
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage/Channels_F/Bindable_F/Events
--      - ReplicatedStorage/Channels_F/Bindable_F/RF
--      - StarterPlayerScripts/Player_Data ("Total Wins")
--
--  Notes:
--      - Wall disappears once Total Wins >= Wins_Requirement
--      - Sends a notification to the player when access is granted
--      - Wins_Requirement can be adjusted via the script variable
--
--======================================================================


local RS 						= game:GetService("ReplicatedStorage")

local Data_Mods_F 				= RS:WaitForChild("Data_Mods_F")
local Fight_Params_Mod			= require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Display_Data 				= Channels.Bindable_Events.Display_Data
local Player_Can_Access_Arena 	= Channels.Bindable_Functions.Player_Can_Access_Arena

local Workspace 				= game:GetService("Workspace")
local Players 					= game:GetService("Players")
local Plr 						= Players.LocalPlayer
local PD						= Plr:WaitForChild("Player_Data")
local Total_Wins_V 				= PD:WaitForChild("Total Wins")
local Wall_Template 			= script:WaitForChild("Ranked_Arena_Wall")

--==================================================
-- Configuration
--==================================================
local WALL_POSITION = CFrame.new(-342.939, 103.164, 144.812)


--==================================================
-- Create and manage arena wall
--==================================================
local function CreateArenaWall()
	local wall = Wall_Template:Clone()
	wall.Name = "Ranked_Arena_Wall"
	wall.CFrame = WALL_POSITION
	wall.Parent = Workspace

	local ui = wall:WaitForChild("SurfaceGui")
	local bar = ui.Main_F.Prog_Bar_F.Bar_F

	-- Updates the progress bar fill based on win ratio
	local function UpdateBar()
		local ratio = math.clamp((Total_Wins_V.Value or 0) / Fight_Params_Mod.Ranked_Arena_Required_Wins, 0, 1)
		bar:TweenSize(UDim2.new(ratio, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.35, true)
	end

	UpdateBar()

	-- Handle dynamic updates and removal when unlocked
	local connection
	connection = Total_Wins_V.Changed:Connect(function()
		if Total_Wins_V.Value < Fight_Params_Mod.Ranked_Arena_Required_Wins then
			UpdateBar()
			return
		end

		if connection then
			connection:Disconnect()
			connection = nil
		end

		if wall and wall.Parent then
			wall:Destroy()
		end

		Display_Data:Fire("🏆 You can now engage in Ranked Fights at The Arena!", Color3.fromRGB(255, 170, 0))
	end)
end

--==================================================
-- Remote: Check if player can access the arena
--==================================================
Player_Can_Access_Arena.OnInvoke = function()
	return (Total_Wins_V and Total_Wins_V.Value >= Fight_Params_Mod.Ranked_Arena_Required_Wins)
end

--==================================================
-- Initialization
--==================================================
task.defer(function()
	if Total_Wins_V.Value < Fight_Params_Mod.Ranked_Arena_Required_Wins then
		CreateArenaWall()
	end
end)]]></ProtectedString>
						<string name="ScriptGuid">{0C6C7DA8-845A-43D2-B7E2-93A9E0AB65C2}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Ranked_Wall_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX29C5BEC2A7C64DDDB8A7527B06553FEE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Damage_OverheadDisplay_Client.lua
--
--  Description:
--      Displays animated floating damage numbers above the target's head 
--      whenever the client receives a damage event from the server.
--      Each damage number fades in, rises slightly, and then fades out 
--      before being cleaned up automatically.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-10-304 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events/Overhead_Display
--      - Script:
--          * Damage_TMP (BillboardGui template with Damage_Detail TextLabel)
--      - Roblox Services:
--          * TweenService (for animations)
--          * Debris (for cleanup, though manual destroy is used)
--          * Players (LocalPlayer)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Receives damage info from server via Overhead_Display event
--      - Randomizes small rotation and movement offsets for natural variation
--      - Uses three sequential tweens: fade-in, rise, fade-out
--      - Safely cleans up the BillboardGui instance after display
--      - Can be extended to support crit indicators, heal effects, or fonts
--
--======================================================================

local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local RS = game:GetService("ReplicatedStorage")

local Channels 			= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Overhead_Display 	= Channels.SC_Remote_Events.Overhead_Display

local Damage_TMP = script:WaitForChild("Damage_TMP")

--==================================================
-- Tween settings
--==================================================
local TWEEN_IN = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local TWEEN_MOVE = TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
local TWEEN_OUT = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)

local POS_OPTIONS = {
	{Rotation = -10, EndPos = Vector3.new(-5, 10, 0)},
	{Rotation = 0,   EndPos = Vector3.new(0, 10, 0)},
	{Rotation = 10,  EndPos = Vector3.new(5, 10, 0)},
}

--==================================================
-- Core: Display floating damage
--==================================================
local function ApplyDamageUI(targetModel, damageText, color)
	local head = targetModel:FindFirstChild("Head")
	if not head then return end

	local posData = POS_OPTIONS[math.random(1, #POS_OPTIONS)]
	local clone = Damage_TMP:Clone()
	local label = clone:WaitForChild("Damage_Detail")

	label.Text = tostring(damageText)
	label.TextColor3 = color
	label.Rotation = posData.Rotation
	label.TextTransparency = 1
	label.TextStrokeTransparency = 1

	clone.Adornee = head
	clone.Parent = head
	clone.ExtentsOffset = Vector3.new(0, 2.75, 0)
	clone.Enabled = true
	clone.AlwaysOnTop = targetModel == game.Players.LocalPlayer.Character

	-- Fade in + float upward
	TweenService:Create(label, TWEEN_IN, {
		TextTransparency = 0,
		TextStrokeTransparency = 0
	}):Play()

	TweenService:Create(clone, TWEEN_MOVE, {
		ExtentsOffset = posData.EndPos
	}):Play()

	-- Fade out after float
	task.delay(1.5, function()
		if not clone or not clone.Parent then return end

		TweenService:Create(label, TWEEN_OUT, {
			TextTransparency = 1,
			TextStrokeTransparency = 1,
			TextColor3 = Color3.new(1, 1, 1)
		}):Play()

		-- Cleanup automatically after fade out
		Debris:AddItem(clone, 1)
	end)
end

Overhead_Display.OnClientEvent:Connect(function(targetChar, damageTxt, damageCol)
	if targetChar and targetChar:FindFirstChild("Head") then
		ApplyDamageUI(targetChar, damageTxt, damageCol)
	end
end)
]]></ProtectedString>
						<string name="ScriptGuid">{346C59A9-C4C2-419A-86E8-EC16485D39EB}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Overhead_Display_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX424EA66CC0724E3091AD2207AFDB31B5">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Player_DeviceDetector_Client.lua
--
--  Description:
--      Detects the player's current device type (Mobile, Console, or PC) 
--      using UserInputService capabilities and reports it back to the server 
--      via RemoteEvents when requested.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events/Update_Player_Device
--          * Channels_F/Client_Server_F/Events/Set_Player_Device
--      - Roblox Services:
--          * UserInputService (to detect input device type)
--          * Players (LocalPlayer)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Device detection logic priority:
--          1. TouchEnabled → "Mobile"
--          2. GamepadEnabled → "Console"
--          3. Otherwise → "PC"
--      - Server triggers Update_Player_Device; client responds with device type
--      - Useful for adaptive UI or gameplay behavior per platform
--
--======================================================================
local RS 					= game:GetService("ReplicatedStorage")

local PlayerUtils			= require(RS:WaitForChild("Modules"):WaitForChild("PlayerUtils"))
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Update_Player_Device 	= Channels.SC_Remote_Events.Update_Player_Device
local Game_Startup_Ready 	= Channels.SC_Remote_Events.Game_Startup_Ready
local Set_Player_Device		= Channels.CS_Remote_Events.Set_Player_Device
local Game_Loading_Finished	= Channels.Bindable_Events.Game_Loading_Finished

local StartupUIManager 		= require(game.ReplicatedStorage.Modules.StartupUIManager)


local loadingFinished = false
local gameReadyPayload = nil
local started = false

local function tryStart()
	if started then return end
	if loadingFinished and gameReadyPayload then
		started = true
		StartupUIManager.start(gameReadyPayload.firstTime)
	end
end

Game_Loading_Finished.Event:Connect(function()
	loadingFinished = true
	tryStart()
end)

Game_Startup_Ready.OnClientEvent:Connect(function(payload)
	gameReadyPayload = payload
	tryStart()
end)

--==================================================
-- Listen for player device change
--==================================================
Update_Player_Device.OnClientEvent:Connect(function()
	local playerDevice = PlayerUtils.GetPlayerDevice()
	Set_Player_Device:FireServer(playerDevice)
end)]]></ProtectedString>
						<string name="ScriptGuid">{63BF81F8-0C0A-4862-B66A-183AD3AA2982}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">General_Client_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX77AF7C6BF8214F94B0C79D648BE6787F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/UGC_Offers_Client.lua
--
--  Description:
--      Handles client-side display and timing of UGC (User Generated Content)
--      offers shown on world podiums. Listens to remote events from the server
--      to update podiums with active offers, countdown timers, and status messages.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Remotes/Offers/UGC
--              - SendUGCOfferToClient (RemoteEvent)
--              - ShowMessage (RemoteEvent)
--          * OfferItems/UGCItems (folder containing displayable UGC assets)
--          * Channels_F/Bindable_F/Events/Display_Data
--          * Script.UGCClientHelper (module handling countdown logic)
--      - Workspace:
--          * Main_World_F/Objects/Offers_Data/UGCPodiums
--              - Each podium must contain:
--                  * OfferAttachment with BillboardGui and Prompt
--                  * Item (container for the displayed UGC object)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Dynamically updates podium visuals when receiving new UGC offer data
--      - Creates and manages independent countdown timers for each podium
--      - On offer expiration, automatically requests new data from the server
--      - Displays colored success/error messages via the Display_Data event
--      - Cleans up old models and disables prompts before reloading new offers
--
--======================================================================

-- Services
local RS = game:GetService("ReplicatedStorage")

-- Events
local Channels 			   	= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local SendUGCOfferToClient 	= Channels.Offers.SendUGCOfferToClient
local ShowMessage 			= Channels.Offers.ShowMessage
local Display_Data 			= Channels.Bindable_Events.Display_Data


--====================================================
-- References
--====================================================
local Main_World_F 		 = game.Workspace:WaitForChild("Main_World_F")
local Gameplay 			 = Main_World_F:WaitForChild("Gameplay")
local Offers_Data 		 = Gameplay:WaitForChild("Shop"):WaitForChild("Offers_Data")
local PodiumsFolder      = Offers_Data:WaitForChild("UGCPodiums")

local UGCItemsFolder     = RS:WaitForChild("Models"):WaitForChild("UGC"):WaitForChild("OfferItems"):WaitForChild("UGCItems")
local UGCTimmer          = require(script:WaitForChild("UGCClientHelper"))

local TimmerObjects = {}

--====================================================
-- Utility: Safe clear function
--====================================================
local function clearChildrenSafe(container)
	if not container or not container:IsDescendantOf(game) then return end
	container:ClearAllChildren()
end


SendUGCOfferToClient.OnClientEvent:Connect(function(offerData, podiumID)
	if not podiumID then return end

	-- Stop any previous countdown
	local existingTimer = TimmerObjects[podiumID]
	if existingTimer then
		pcall(function() existingTimer:StopCountdown() end)
		TimmerObjects[podiumID] = nil
	end

	local podium = PodiumsFolder:FindFirstChild(podiumID)
	if not podium then return end

	local offerAttachment = podium:FindFirstChild("OfferAttachment")
	if not offerAttachment then return end

	local prompt = offerAttachment:FindFirstChild("Prompt")
	local itemContainer = podium:FindFirstChild("Item")

	if not itemContainer or not prompt then return end

	-- Clean podium before loading new offer
	clearChildrenSafe(itemContainer)
	prompt.Enabled = false

	if not offerData then
		return
	end

	-- Clone and position new UGC item
	local showableItem = UGCItemsFolder:FindFirstChild(offerData.RefName)
	local showablePart
	if showableItem then
		showablePart = showableItem:Clone()
		showablePart.Parent = itemContainer
		showablePart.CFrame = offerAttachment.WorldCFrame * CFrame.new(0, 3, 0)
	end

	-- Enable prompt and start countdown
	prompt.Enabled = true
	prompt.ObjectText = tostring(offerData.Title) .. "!"

	local timerObj = UGCTimmer.new(nil, podiumID, showablePart,offerData.Key)
	TimmerObjects[podiumID] = timerObj

	timerObj:StartCountdown(offerData.EndsAt, function(podiumName)
		-- Refresh when timer ends
		SendUGCOfferToClient:FireServer(podiumName)
	end)

end)

--====================================================
-- Message Display
--====================================================
local function showMessage(message, isSuccess)
	local prefix = isSuccess and "" or ""
	local color = isSuccess and Color3.fromRGB(35, 244, 68) or Color3.new(1, 0, 0)
	Display_Data:Fire(prefix .. tostring(message), color)
end

ShowMessage.OnClientEvent:Connect(showMessage)

]]></ProtectedString>
						<string name="ScriptGuid">{5A73D69F-AF93-45C8-88D1-50B4C1078BA3}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Display_Podium_UGC_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX6592EB8E1076419DB3652BF9AD5EA169">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Display_Podium_UGC_Handle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX425027688D344761876D1D5F4BAF1315">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Display_Podium_UGC_Handle/UGCClientHelper.lua
--
--  Description:
--      Handles countdown timers and rotation for UGC items displayed
--      on podiums in the game. Provides a class-like structure to:
--        - Start and stop countdowns for limited-time offers
--        - Rotate displayed UGC objects continuously
--        - Update GUI text with formatted remaining time
--        - Trigger callbacks when offers expire
--
--      Key features:
--        - Supports multiple podiums independently
--        - Manages asynchronous countdown threads safely
--        - Includes formatting for days, hours, minutes, and seconds
--        - Stops countdowns and rotation when offers end
--
--  Author(s): Adnan
--
--  Last Modified: 2025-09-30 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - None external (pure Lua module)
--      - Expects:
--          * TextObject (GUI TextLabel) for displaying countdown
--          * ClonedObjBasePart (UGC item BasePart) for rotation
--          * PodiumName (string identifier for the podium)
--
--  Notes:
--      - Uses task.spawn for asynchronous updates
--      - RotateObject rotates the object 0.5° per frame around Y-axis
--      - Countdown can be safely restarted; previous threads are invalidated
--      - onExpire callback is called when countdown reaches zero
--======================================================================

local Channels 			   = require(game.ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Channels"))
local Shop_Item_Purchased = Channels.SC_Remote_Events.Shop_Item_Purchased

local UGCCH = {}

UGCCH.__index = UGCCH

function UGCCH.new(textObject,podiumName,obj,Key)
	local self = setmetatable({}, UGCCH)
	self.TextObject = textObject
	self.PodiumName = podiumName
	self.countdownThread =nil
	self.countdownRev = 0  
	self.ClonedObjBasePart=obj
	self.IsObjectRotating=false
	self.onExpire=nil
	self.Key=Key
	self.PurchasedCon = Shop_Item_Purchased.OnClientEvent:Connect(function(ItemType,key)
		local data=string.split(ItemType,"_")
		if data[1]~="UGC" then
			return
		end	

		if self.Key == key then
			self.onExpire(self.PodiumName)
			self.onExpire=nil
			self:StopCountdown()
		end
	end)
	return self
end


local function formatDHMS(rem: number): string
	rem = math.max(0, rem)
	local d = math.floor(rem / 86400)
	local h = math.floor((rem % 86400) / 3600)
	local m = math.floor((rem % 3600) / 60)
	local s = rem % 60

	if d > 0 then
		return string.format("LIMITED TIME OFFER\n%dd %dh %dm", d, h, m)
	elseif h > 0 then
		return string.format("LIMITED TIME OFFER\n%dh %dm %ds", h, m, s)
	else
		return string.format("LIMITED TIME OFFER\n%dm %ds", m, s)
	end
end
local function SetText(txtObj,txt)
	if txtObj then
		txtObj.Text = txt
	end
end

local RunService = game:GetService("RunService")

function UGCCH:RotateObject()
	if not self.ClonedObjBasePart then return end
	local part = self.ClonedObjBasePart
	local originCF = part.CFrame              -- starting pose
	local t0 = os.clock()
	local spin = 0                            -- accumulated yaw
	local spinPerStep = math.rad(0.5)         -- same as before
	local amplitude = 2                       -- max up offset
	local freq = 0.2                            -- cycles per second (bobbing speed)

	self.IsObjectRotating = true
	while self.IsObjectRotating and part do
		-- elapsed time
		local t = os.clock() - t0

		-- 0..2 offset: (sin + 1) maps from [-1,1] to [0,2]
		local y = (math.sin(2*math.pi*freq * t) + 1) * (amplitude/2)

		-- accumulate spin
		spin += spinPerStep

		-- rebuild transform from origin: origin -> up offset -> yaw
		part.CFrame = originCF * CFrame.new(0, y, 0) * CFrame.Angles(0, spin, 0)

		RunService.Heartbeat:Wait()
	end
end

function UGCCH:StopCountdown()
	self.countdownRev += 1
	SetText(self.TextObject,"")
	self.IsObjectRotating = false

end

function  UGCCH:StartCountdown(endsAt: number,onExpire)
	-- Validate input

	if typeof(endsAt) ~= "number" or endsAt <= 0 then
		onExpire(self.PodiumName)
		self.onExpire=nil
		self:StopCountdown()
		return
	end
	self.onExpire = onExpire
	task.spawn(function() self:RotateObject() end)
	self.countdownRev += 1
	local myRev = self.countdownRev
	self.countdownThread = task.spawn(function()
		while myRev == self.countdownRev do


			local now = os.time()
			local rem = math.max(0, endsAt - now)

			if rem <= 0 then
				SetText(self.TextObject, "OFFER ENDED")
				onExpire(self.PodiumName)
				self.onExpire=nil
				if myRev == self.countdownRev then
					self.countdownRev += 1
				end
				break
			end
			SetText(self.TextObject, formatDHMS(rem))

			task.wait(1)
		end

		if myRev == self.countdownRev then
			self.countdownThread = nil
		end
	end)
end


return UGCCH
]]></ProtectedString>
							<string name="ScriptGuid">{913799AF-150E-4140-94E0-933609FB59E4}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UGCClientHelper.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXF5B11866A474443C91687E05D708F43D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Display_Podium_UGC_Handle.lua
--
--  Description:
--      Handles the client-side display of limited-time cloth offers.
--      Manages showing 3D cloth models on podiums, updating countdown
--      timers, and syncing with server offer data via RemoteEvents and
--      RemoteFunctions.
--
--      Key features:
--        - Requests current and new cloth offers from the server
--        - Displays the offer model on podiums with proper positioning
--        - Anchors models to prevent physics issues
--        - Starts and updates a countdown timer until the offer expires
--        - Fires RemoteEvents to notify server of displayed cloth items
--        - Handles automatic refresh when a new offer is available
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-13 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Remotes/Offers/GetCurrentClothOffer (RemoteFunction)
--          * Remotes/Offers/GetNewClothOffer (RemoteFunction)
--          * Remotes/Offers/ClothItemIdSignal (RemoteEvent)
--          * Clothing_F (Folder containing cloth models)
--      - Workspace:
--          * Offers_Data (Folder containing podiums and GUI elements)
--      - Player Instances:
--          * LocalPlayer (used to track current client session)
--
--  Notes:
--      - Countdown format: "LIMITED TIME OFFER\nXd Xh Xm" etc.
--      - Supports Shorts and Gloves display with proper positioning
--      - Ensures only one active countdown at a time
--      - Dynamically cleans and replaces podium items
--      - Uses task.spawn and task.wait for asynchronous updates
--      - setData flag prevents repeated loading of the same offer
--======================================================================
task.wait(1)
-- Services
local RS  = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Events
local Channels 			   = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local GetCurrentClothOffer = Channels.Offers.GetCurrentClothOffer
local GetNewClothOffer     = Channels.Offers.GetNewClothOffer
local ClothItemIdSignal    = Channels.Offers.ClothItemIdSignal
local Shop_Item_Purchased = Channels.SC_Remote_Events.Shop_Item_Purchased
-- Workspace references
local Main_World_F = workspace:WaitForChild("Main_World_F")
local Gameplay = Main_World_F:WaitForChild("Gameplay")
local OfferFolder =Gameplay:WaitForChild("Shop"):WaitForChild("Offers_Data")
local ClothsFolder = game.ReplicatedStorage:WaitForChild("Models"):WaitForChild("Clothing_F")
local ClothShowableItemPlace = OfferFolder.Display_Podium_Left.Item

local LeftHandPos  = Vector3.new(-291.284, 97.812, -328.563)
local RightHandPos = Vector3.new(-289.072, 97.812, -328.563)

local setData = false
local countdownRev = 0
local countdownThread = nil
local PingServerForNewCloth
local CurrentOfferItem=nil
--====================================================
-- Utility Functions
--====================================================

local function stopCountdown()
	countdownRev += 1
	-- billboard text handling was removed (disabled in original)
end

local function startCountdown(endsAt: number)
	if typeof(endsAt) ~= "number" or endsAt <= 0 then
		stopCountdown()
		return
	end

	countdownRev += 1
	local myRev = countdownRev

	if countdownThread then
		task.cancel(countdownThread)
	end

	countdownThread = task.spawn(function()
		while myRev == countdownRev do
			local now = os.time()
			local rem = math.max(0, endsAt - now)

			if rem <= 0 then
				if typeof(PingServerForNewCloth) == "function" then
					pcall(PingServerForNewCloth)
				end
				break
			end

			-- text update intentionally disabled (consistent with original)
			task.wait(1)
		end
	end)
end

local function SetPosition(ObjectMesh, pos)
	if not ObjectMesh then return end
	local rotOnly = ObjectMesh.CFrame - ObjectMesh.CFrame.Position
	ObjectMesh.CFrame = CFrame.new(pos) * rotOnly
end

local function AnchoredModel(model)
	for _, descendant in ipairs(model:GetDescendants()) do
		if descendant:IsA("BasePart") then
			descendant.Anchored = true
			--	descendant.Parent = model
		end
		--if descendant:IsA("WeldConstraint") then
		--	descendant:Destroy()
		--end
	end
end

--====================================================
-- Unified floating animation (replaces UpDownShort/Glove)
--====================================================
local function FloatModel(target: Instance, opts)
	if not target then return end
	opts = opts or {}
	local amplitude = opts.amplitude or 2
	local freq = opts.freq or 0.2
	local axis = opts.axis or Vector3.new(0, 1, 0)

	local isModel = target:IsA("Model")
	local getCF = function() return isModel and target:GetPivot() or target.CFrame end
	local setCF = function(cf)
		if isModel then target:PivotTo(cf) else target.CFrame = cf end
	end

	local originCF = getCF()
	local t0 = os.clock()
	local conn

	conn = RunService.Heartbeat:Connect(function()
		if not target or not target.Parent then
			conn:Disconnect()
			return
		end

		local t = os.clock() - t0
		local offset = math.sin(2 * math.pi * freq * t) * (amplitude / 2)
		setCF(originCF * CFrame.new(axis * offset))
	end)

	return conn
end

local isMoving=false

function UpDownGlove(target, opts)
	opts = opts or {}
	isMoving=true
	local amplitude       = tonumber(opts.amplitude) or 2      -- vertical travel (studs)
	local freq            = tonumber(opts.freq)      or 0.2    -- bob cycles per second
	local spinDegPerStep  = tonumber(opts.spinDegPerStep) or 0.5

	-- accept either a Model or a BasePart; if nil, fall back to self.ClonedObjBasePart / self.Model
	--target = target or self.Model or self.ClonedObjBasePart
	if not target then return end

	local isModel = target:IsA("Model")
	local getCF   = function()
		return isModel and target:GetPivot() or target.CFrame
	end
	local setCF   = function(cf)
		if isModel then
			target:PivotTo(cf)
		else
			target.CFrame = cf
		end
	end

	local originCF = getCF()
	local t0       = os.clock()
	local spin     = 0
	local spinStep = math.rad(spinDegPerStep)

	isMoving= true
	while isMoving and target do
		local t = os.clock() - t0
		local y = (math.sin(2 * math.pi * freq * t) + 1) * (amplitude / 2)  -- 0..amplitude

		spin += spinStep
		setCF(originCF * CFrame.new(0,y, .1) * CFrame.Angles(0, spin, 0))

		RunService.Heartbeat:Wait()
	end
end


--====================================================
-- Offer Handling
--====================================================

PingServerForNewCloth = function()
	-- cleanup previous display
	ClothShowableItemPlace.Parent.OfferAttachment.Prompt.Enabled=false
	ClothShowableItemPlace.Parent.OfferAttachment.BillboardGui.TextLabel.Visible=false

	ClothShowableItemPlace:ClearAllChildren()
	isMoving=false
	local CurrentOfferData
	if not setData then
		CurrentOfferData = GetCurrentClothOffer:InvokeServer()
	end

	task.wait()


	local item = CurrentOfferData and CurrentOfferData.offer or GetNewClothOffer:InvokeServer()
	for _,item in ipairs(ClothShowableItemPlace:GetChildren()) do
		item:Destroy()
	end
	if not item then 
		CurrentOfferItem=nil
		return
	end

	local folderName = (item.Kind == "Shorts") and "Shorts_F" or "Gloves_F"
	local ClothItemsParent = ClothsFolder:WaitForChild(folderName)
	local showableItem = ClothItemsParent:FindFirstChild(item.Title)

	if not showableItem then return end

	local showableItemModel = showableItem:Clone()
	showableItemModel.Parent = ClothShowableItemPlace
	ClothItemIdSignal:FireServer(item)
	CurrentOfferItem=item
	showableItemModel:ScaleTo(2)
	if showableItemModel then

		ClothShowableItemPlace.Parent.OfferAttachment.Prompt.Enabled=true
		ClothShowableItemPlace.Parent.OfferAttachment.BillboardGui.TextLabel.Visible=true
	end

	if item.Kind == "Shorts" then
		AnchoredModel(showableItemModel)
		showableItemModel:MoveTo(Vector3.new(-290.355, 98.235, -328.298))
		task.defer(function() FloatModel(showableItemModel, { axis = Vector3.new(0, 1, 0) }) end)

	else
		showableItemModel:FindFirstChild("LeftHand").Anchored=true
		showableItemModel:FindFirstChild("RightHand").Anchored=true
		showableItemModel:MoveTo(Vector3.new(0, 0, 0))
		SetPosition(showableItemModel:FindFirstChild("LeftHand"), LeftHandPos)
		SetPosition(showableItemModel:FindFirstChild("RightHand"), RightHandPos)
		--showableItemModel.PrimaryPart = showableItemModel:FindFirstChild("LeftHand")
		

			task.defer(function() FloatModel(showableItemModel, { axis = Vector3.new(0, 0, 1) }) end)
	end




	startCountdown(item.EndsAt)
end

--====================================================
-- Initialization
--====================================================

task.defer(PingServerForNewCloth)

ClothItemIdSignal.OnClientEvent:Connect(function()
	task.wait(1)
	setData = true
	PingServerForNewCloth()
end)

Shop_Item_Purchased.OnClientEvent:Connect(function(ItemType,key)
	local data=string.split(ItemType,"_")
	if data[1]~="Cloth" then
		return
	end	
	if CurrentOfferItem and CurrentOfferItem.Key == key then
		task.wait(1)
		setData = true
		PingServerForNewCloth()
	end
end)]]></ProtectedString>
						<string name="ScriptGuid">{D3B7BE53-AA89-454D-B926-3CA4E38AD811}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Display_Podium_Left_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0745ABFC34A0437887309AEF87D27449">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Chat_Customization_Client.lua
--
--  Description:
--      Enhances the Roblox TextChatService system by adding dynamic player 
--      tags, server announcements, and periodic gameplay tips.
--      Features:
--        * Custom prefixes for VIPs, Rookies, and Top 3 leaderboard players
--        * Colored and formatted server messages
--        * Client-side typing status query via BindableFunction
--        * Automated rotating gameplay tips in chat
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events
--              - Top3_Players_Updated
--              - Server_Chat
--          * Channels_F/Bindable_F/RF/Is_Chatbox_Typing
--          * Channels_F/Bindable_F/Events
--      - Roblox Services:
--          * TextChatService
--          * Players (LocalPlayer)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Requires TextChatService enabled (not LegacyChat)
--      - VIP and Rookie tags depend on player attributes:
--            "Is_VIP", "Is_Ultimate_VIP_Sub", "Rookie"
--      - Leaderboard ranks updated from server via "Top3_Players_Updated"
--      - Server messages formatted through <font> HTML color tags
--      - Chat tips rotate every 120s, starting 60s after join
--      - Safe pcall-style access for TextChatService instances
--
--======================================================================

local RS 					= game:GetService("ReplicatedStorage")
local TCS 					= game:GetService("TextChatService")
local TextChannels 			= TCS:WaitForChild("TextChannels")
local SystemChannel			 = TextChannels:WaitForChild("RBXSystem")
local Players 				= game:GetService("Players")

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Top3_Players_Updated 	= Channels.SC_Remote_Events.Top3_Players_Updated
local Is_Chatbox_Typing		= Channels.Bindable_Functions.Is_Chatbox_Typing
local Server_Chat			= Channels.SC_Remote_Events.Server_Chat

local VIP_Tag 				= "[👑 VIP]"
local VIP_Color 			= "rgb(255,175,0)"
local Rookie_Tag 			= "[Rookie]"
local Rookie_Color			= "rgb(205,127,50)"

local Workspace 			= game:GetService("Workspace")
local Main_World_F 			= Workspace:WaitForChild("Main_World_F")
local Gameplay				= Main_World_F:WaitForChild("Gameplay")
local workspaceRankings		 = Gameplay:WaitForChild("Objects"):WaitForChild("Rankings")

local TOP_COLORS = {
	[1] = "rgb(255,215,0)",   -- Gold
	[2] = "rgb(192,192,192)", -- Silver
	[3] = "rgb(205,127,50)",  -- Bronze
}

local TopPlayers = {}

--==================================================
-- Utility: Reset avatar displays
--==================================================
local function ClearAvatars()
	for _, stand in ipairs(workspaceRankings:GetChildren()) do
		local avatarFolder = stand:FindFirstChild("Avatar")
		if avatarFolder then
			avatarFolder:ClearAllChildren()
		end
	end
end

local function AddPrefix(t, color, text)
	t[#t+1] = string.format("<font color='%s'>%s</font>", color, text)
end

--==================================================
-- Utility: Validate userId and resolve username
--==================================================
local function IsValidUserId(userId)
	if typeof(userId) ~= "number" or userId <= 0 or userId % 1 ~= 0 then
		return false
	end
	local ok, result = pcall(function()
		return Players:GetNameFromUserIdAsync(userId)
	end)
	return ok and result ~= nil and result ~= "", result
end

--==================================================
-- Update leaderboard avatars
--==================================================
Top3_Players_Updated.OnClientEvent:Connect(function(newTop)
	ClearAvatars()
	table.clear(TopPlayers)

	for rank = 1, 3 do
		local userId = newTop[rank]
		TopPlayers[rank] = userId  -- store directly

		-- skip empty slots or invalid default (-1)
		if not userId or userId == -1 then
			continue
		end

		-- resolve username
		local isValid, name = IsValidUserId(userId)
		if not isValid then continue end

		-- get stand components
		local stand = workspaceRankings:FindFirstChild(rank .. "_Stand")
		if not stand then continue end

		local posPoint = stand:FindFirstChild("Top")
		local avatarFolder = stand:FindFirstChild("Avatar")
		if not (posPoint and avatarFolder) then continue end

		-- spawn avatar
		local ok, model = pcall(function()
			return Players:CreateHumanoidModelFromUserId(userId)
		end)

		if ok and model then
			model.Name = name
			model:ScaleTo(1.5)
			model:PivotTo(posPoint.CFrame)
			model.Parent = avatarFolder

			task.delay(0.5, function()
				local root = model:FindFirstChild("HumanoidRootPart")
				if root then root.Anchored = true end
			end)
		else
			warn("Failed to load avatar for userId:", userId, "Error:", model)
		end
	end
end)

--==================================================
-- Chat message prefix customization
--==================================================
TCS.OnIncomingMessage = function(msg: TextChatMessage)
	local source = msg.TextSource
	if not source then return end

	local sender = Players:GetPlayerByUserId(source.UserId)
	if not sender then return end

	local prefix = {}

	-- VIP tags
	if sender:GetAttribute("Is_VIP") or sender:GetAttribute("Is_Ultimate_VIP_Sub") then
		AddPrefix(prefix, VIP_Color, VIP_Tag)
	end

	-- Rookie tag
	if sender:GetAttribute("Rookie") then
		AddPrefix(prefix, Rookie_Color, Rookie_Tag)
	end

	-- Top 3 tag
	for rank, uid in pairs(TopPlayers) do
		if uid == sender.UserId then
			
			local color = TOP_COLORS[rank] or "rgb(255,255,255)"
			table.insert(prefix, string.format("<font color='%s'>[TOP #%d]</font>", color, rank))
			break
		end
	end

	if #prefix > 0 then
		local props = Instance.new("TextChatMessageProperties")
		props.PrefixText = table.concat(prefix, " ") .. " " .. msg.PrefixText
		return props
	end
end

--==================================================
-- Utility: Convert Color3 → font tag
--==================================================
local function ColorToFontTag(color: Color3)
	local r, g, b = math.floor(color.R * 255), math.floor(color.G * 255), math.floor(color.B * 255)
	return string.format("<font color='rgb(%d,%d,%d)'>", r, g, b)
end

--==================================================
-- Server → client chat messages
--==================================================
Server_Chat.OnClientEvent:Connect(function(txt, color)
	local prefix = ColorToFontTag(color)
	SystemChannel:DisplaySystemMessage(prefix .. "[SERVER] " .. txt .. "</font>")
end)

--==================================================
-- Check if player is typing in chat
--==================================================
Is_Chatbox_Typing.OnInvoke = function()
	local bar = TCS:FindFirstChildOfClass("ChatInputBarConfiguration")
	return bar and bar.IsFocused or false
end

local tipsRoutine = nil

--==================================================
-- Rotating gameplay tips
--==================================================
local function StartServerTips()
	if tipsRoutine then return end
	
	local tips = {
		"Find out latest MMA Fighters features through the tutorial, see '?'",
		"The longer you play, the more you are rewarded, see Rewards",
		"Earn more luck by inviting your friends!",
	}
	local TIP_COLOR = "#FFFF00" -- Yellow

	local function DisplayTip(txt)
		local formatted = string.format("<font color='%s'><b>[TIP]</b> %s</font>", TIP_COLOR, txt)
		SystemChannel:DisplaySystemMessage(formatted)
	end

	tipsRoutine = task.spawn(function()
		task.wait(60)
		local index = 1
		while true do
			DisplayTip(tips[index])
			index = (index % #tips) + 1
			task.wait(120)
		end
	end)
end
StartServerTips()]]></ProtectedString>
						<string name="ScriptGuid">{22921FD7-88F8-435C-8B34-85A88AC75481}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Custom_Chat_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX608F754FBB12482187871A87B51A4F5C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Shop_OpenTrigger_Client.lua
--
--  Description:
--      Detects when the player's character enters predefined collider 
--      zones around shop areas, and fires a BindableEvent to open the 
--      corresponding Shop UI. Each collider group under "OpenColliders"
--      represents a specific shop type or section.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/Shop/OpenColliders
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/Open_Shop
--      - PlayerGui:
--          * Shop_UI
--      - Roblox Services:
--          * Players (LocalPlayer)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - All colliders are made invisible (Transparency = 1)
--      - When player’s HumanoidRootPart touches a collider, fires 
--        the Open_Shop event with the collider group name as parameter
--      - Assumes each collider group represents a distinct shop category
--      - Relies on BindableEvents for decoupled UI control
--
--======================================================================

-- Services
local RS 				= game:GetService("ReplicatedStorage")
local Plr 				= game.Players.LocalPlayer
local Channels 			= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Open_Shop_UI 		= Channels.Bindable_Events.Open_Shop_UI

-- UI References
local Main_World_F 		= game.Workspace:WaitForChild("Main_World_F")
local Gameplay 			= Main_World_F:WaitForChild("Gameplay")
local Shop_F 			= Gameplay:WaitForChild("Shop")
local OpenColliders 	= Shop_F:WaitForChild("OpenColliders")

function On_Init()
	for i, openType in pairs(OpenColliders:GetChildren()) do
		for _, collider in pairs(openType:GetDescendants()) do
			if collider:IsA("BasePart") == false then
				continue
			end
			
			collider.Transparency = 1
			collider.Touched:Connect(function(part)
				if part.Name == "HumanoidRootPart" and part.Parent == Plr.Character then
					Open_Shop_UI:Fire(openType.Name)
				end
			end)
		end
	end
end
On_Init()]]></ProtectedString>
						<string name="ScriptGuid">{3B6642F9-8C1B-45BC-8BE3-09D30B4DFFCF}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Colliders_Open_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX22F034A4D98F44748F33DF521F10878F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- Services
local RS  = game:GetService("ReplicatedStorage")
local MPS = game:GetService("MarketplaceService")


-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Display_Data 				= Channels.Bindable_Events.Display_Data
local ShowAvatarAndGetTriggerRE = Channels.UGC_Pack.ShowAvatarAndGetTriggerRE
local ApplyAccessoriesRE 		=  Channels.UGC_Pack.ApplyAccessoriesRE

-- Workspace references
local UGCPacks = RS.Models.UGC.OfferItems.UGCPacks
local Main_World_F = workspace:WaitForChild("Main_World_F")
local Gameplay = Main_World_F:WaitForChild("Gameplay")
local OfferFolder =Gameplay:WaitForChild("Shop"):WaitForChild("Offers_Data")

local WorkSpacePlacement = OfferFolder.UGCAvatar
local avatarLocFol = OfferFolder.UGCAvatarLoc


MPS.PromptBulkPurchaseFinished:Connect(function(player, status, results)
	if status == Enum.MarketplaceBulkPurchasePromptStatus.Completed then
		local idList={}
		for i, itemInfo in ipairs(results) do
			-- Each entry may contain assetId or bundleId, plus a purchaseResult Enum
			local assetId = itemInfo.assetId or "N/A"
			local bundleId = itemInfo.bundleId or "N/A"
			local purchaseResult = tostring(itemInfo.purchaseResult)
			table.insert(idList,assetId)
		end
		local Txt = "✅ Items purchased you can apply on your avatar!"
		Display_Data:Fire(Txt, Color3.fromRGB(35, 244, 68))
		ApplyAccessoriesRE:FireServer(idList)
	end

end)
local Color_Mod = require( game.ReplicatedStorage.Data_Mods_F:WaitForChild("PodiumColors_Mod"))
local TextData = {
	["Guy_Pack1"]={
		
		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="START THE FIGHT!"
		}
	},
	["Guy_Pack2"]={
		
		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="BURN YOUR LIMIT"
		}
	}
	,
	["Guy_Pack3"]={
	
		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="DOMINATE THE ARENA"
		}
	},
	["Guy_Pack4"]={
		
		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="MASTER YOUR POWER"
		}
	},
	["Guy_Pack5"]={

		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="START THE FIGHT!"
		}
	},
	["Guy_Pack6"]={

		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="BURN YOUR LIMIT"
		}
	}
	,
	["Guy_Pack7"]={

		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="DOMINATE THE ARENA"
		}
	},
	["Guy_Pack8"]={

		scheem="S2",
		Items={

			{
				Name ="TextLabel",
				Use  = "RibbonGradient",
			},
		},
		text={
			CanSetText=true,
			TextObjName="TextLabel",
			Text="MASTER YOUR POWER"
		}
	}
}

ShowAvatarAndGetTriggerRE.OnClientEvent:Connect(function(PackNames)

	for _,placed in pairs(WorkSpacePlacement:GetChildren()) do
		placed:Destroy()
	end
	task.wait(1)
	local plr = game.Players.LocalPlayer
	local character = plr.Character or plr.CharacterAdded:Wait()

	local count = 1

	for i,PackName in ipairs(PackNames) do

		if (PackName=="")  then
			return
		end

		local ItemName = "Guy_"..PackName

		local Guy = UGCPacks:FindFirstChild(ItemName)
		if Guy then
			local loc = avatarLocFol:FindFirstChild("Loc"..count)
			if loc then
				local clone = Guy:Clone()
				count+=1
				clone.Parent = WorkSpacePlacement

				clone:PivotTo(loc.CFrame)

				local guyTextData=TextData[ItemName]
				local colorObj=Color_Mod.new(
					clone,guyTextData.scheem,guyTextData.Items,guyTextData.text
				)
				local prompt=clone:FindFirstChild("ProximityPrompt")
				prompt.Triggered:Connect(function(player)
					ShowAvatarAndGetTriggerRE:FireServer(PackName)
				end)
			end
		end
	end
end)]]></ProtectedString>
						<string name="ScriptGuid">{D2661AD3-058E-41DF-AE71-B7A16933B6AB}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Client_UGC_Pack_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX581FD7C6B42840CE9E123BD67E5F54DA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/GameAnalytics_Init_Client.lua
--
--  Description:
--      Initializes the GameAnalytics client SDK for telemetry and event 
--      tracking within the Roblox experience. This script ensures the 
--      GameAnalytics client module is properly required and started on 
--      the player's client.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * GameAnalytics  (manual import or via Rojo)
--          * OR Packages/GameAnalytics (if using Wally)
--      - Roblox Services:
--          * ReplicatedStorage
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Supports both Wally package-based and manual module placement
--      - Ensure GameAnalytics credentials/config are initialized separately
--      - Call `GameAnalytics:initClient()` only once per client session
--
--======================================================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local GameAnalytics = require(ReplicatedStorage.Modules.GameAnalytics)
GameAnalytics:initClient()]]></ProtectedString>
						<string name="ScriptGuid">{FAC9C9CE-C2D8-462D-A921-DBC768784CB9}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Client_GA_Init.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB6E448EE2A384F76AB98D8FCFD379E8A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Fight_SpawnEffects_Client.lua
--
--  Description:
--      Handles spinning animations and combat visual effects for fight cages:
--        * Continuously rotates the "Rot_Part" of each fighter spawn circle
--        * Initializes rotation tweens on all existing cages at startup
--        * Reacts to server events to display punch impact visual and haptic effects
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/Fight_Cages_F
--              - Each cage must contain submodels "Fighter_1" and "Fighter_2"
--                each having a "Rot_Part" for spinning visual effect
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events/Show_Punch_Effects
--          * Channels_F/Server_Client_F/Events/Got_Hit_Effect
--      - Roblox Services:
--          * TweenService (for rotation)
--          * Debris (for cleanup of temporary haptic effects)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Uses infinite Tween rotation with linear easing for spawn circle spin
--      - Punch impact events emit short ParticleEmitter bursts from target head
--      - Haptic feedback triggered on local client using UINotification type
--      - Automatically initializes all fight cages on startup and listens for new ones
--
--======================================================================
local RS = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Show_Punch_Effects 	= Channels.SC_Remote_Events.Show_Punch_Effects
local Got_Hit_Effect 		= Channels.SC_Remote_Events.Got_Hit_Effect

local Main_World_F = game.Workspace:WaitForChild("Main_World_F")
local Objects = Main_World_F:WaitForChild("Gameplay"):WaitForChild("Objects")
local Fight_Cages_F = Objects:WaitForChild("Fight_Cages_F")

local Tween_Rot = TweenInfo.new(5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, math.huge, false, 0)

--==================================================
-- Helper: Setup rotation tween for a given fighter
--==================================================
local function Set_Up_Rot_Effects(FighterModel)
	if not FighterModel then return end
	local Rot_P = FighterModel:FindFirstChild("Rot_Part")
	if not Rot_P then return end

	local tween = TweenService:Create(Rot_P, Tween_Rot, {
		CFrame = Rot_P.CFrame * CFrame.Angles(0, math.rad(179), 0)
	})
	tween:Play()
end

--==================================================
-- Setup rotation effects for an entire fight model
--==================================================
local function Set_Up_Fight_Model_Effects(FightModel)
	if not FightModel then return end
	Set_Up_Rot_Effects(FightModel:FindFirstChild("Fighter_1"))
	Set_Up_Rot_Effects(FightModel:FindFirstChild("Fighter_2"))
end

--==================================================
-- Initialize all cages on startup
--==================================================
local function Init_Fight_Model_Effects()
	task.defer(function()
		for _, FM in ipairs(Fight_Cages_F:GetChildren()) do
			Set_Up_Fight_Model_Effects(FM)
		end
	end)
end

--==================================================
-- Listen for new cages dynamically
--==================================================
Fight_Cages_F.ChildAdded:Connect(function(C)
	if C:IsA("Model") then
		Set_Up_Fight_Model_Effects(C)
	end
end)

--==================================================
-- Show punch visual effects
--==================================================
Show_Punch_Effects.OnClientEvent:Connect(function(Hit_Char)
	local Head = Hit_Char and Hit_Char:FindFirstChild("Head")
	local Hit_VFX = Head and Head:FindFirstChild("Hit_VFX")
	if not Hit_VFX then return end

	for _, PE in ipairs(Hit_VFX:GetChildren()) do
		if PE:IsA("ParticleEmitter") then
			PE:Emit(2)
		end
	end
end)

--==================================================
-- Trigger haptic feedback effect
--==================================================
Got_Hit_Effect.OnClientEvent:Connect(function()
	local hep = Instance.new("HapticEffect")
	hep.Name = "PUNCHED"
	hep.Type = Enum.HapticEffectType.UINotification
	hep.Parent = workspace
	hep:Play()
	Debris:AddItem(hep, 3)
end)

--==================================================
-- Run initialization
--==================================================
Init_Fight_Model_Effects()]]></ProtectedString>
						<string name="ScriptGuid">{968325A5-272F-49E5-90C1-A1BC3B2647C2}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Client_Effects_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB1C6D394CB094ACC87644F076F4C3439">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")

local function ClearAllBlurs()
	for _, child in ipairs(Lighting:GetChildren()) do
		if child:IsA("BlurEffect") then
			child:Destroy()
		end
	end
end

local plr = Players.LocalPlayer

plr.CharacterAdded:Connect(function()
	ClearAllBlurs()
end)]]></ProtectedString>
						<string name="ScriptGuid">{8ABF52E7-4D08-492B-ADB1-E2BB4DD37089}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Clean_Blur_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCB55E4877E554E60B4E4BA34195C7945">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayer/StarterCharacterScripts/Tutorial_Handle.client.lua
--
--  Description:
--      Manages the interactive tutorial flow for new players. 
--      Displays step-by-step guidance with titles, messages, camera
--      transitions, destination trails, and UI panel openings. 
--      Resets tutorial state when completed or closed.
--
--  Author(s): Exclusible, Oriane
--
--  Last Modified: 2025-09-30 by Oriane
--
--  Version: V2025-09
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/Tutorial_Parts_F (contains camera positions & destinations)
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/Display_Tuto_Message
--          * Channels_F/Bindable_F/Events/Toggle_Cutscene
--          * Channels_F/Bindable_F/Events/Set_Trail
--          * Channels_F/Bindable_F/Events/Remove_Trail
--          * Channels_F/Bindable_F/Events/Open_Combos
--          * Channels_F/Bindable_F/Events/Open_Equipment
--          * Channels_F/Bindable_F/Events/Open_Skill_Tree
--          * Channels_F/Bindable_F/Events/Start_Tour
--          * Channels_F/Bindable_F/Events/Next_Tutorial_Step
--          * Channels_F/Bindable_F/Events/Close_Tutorial
--          * Channels_F/Bindable_F/Events/Toggle_Fight_Mode
--          * Channels_F/Bindable_F/Events/Disable_Fight_Mode
--          * Channels_F/Bindable_F/Events/Close_Fight_Result
--          * Channels_F/Bindable_F/Events/Toggle_Commands_Panel
--          * Server_Client_F/Events/End_Fight
--      - Roblox Services:
--          * TweenService
--          * Players
--          * Lighting
--
--  Notes:
--      - Each tutorial step is defined in Full_Tour_Steps with:
--          * title, txt, camera_key, destination_key, open_panel_event
--      - Camera smoothly tweens to tutorial markers
--      - Trails guide players to destinations
--      - Panels open dynamically per step definition
--      - Tutorial can be closed anytime, resetting camera & trail
--
--======================================================================
-- Services
local RS = game:GetService("ReplicatedStorage")

-- Modules
local Data_Mods_F 			= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Tutorial_Mod			= require(Data_Mods_F:WaitForChild("Tutorial_Mod"))
local Tour_Mod 				= require(script.Tour)
local Basic_Fight_Mod 		= require(script.Basic_Fight)

-- Events
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Start_Cage_Tutorial	= Channels.Bindable_Events.Start_Cage_Tutorial
local Start_Tour			= Channels.Bindable_Events.Start_Tour
local Next_Tutorial_Step	= Channels.Bindable_Events.Next_Tutorial_Step
local Close_Tutorial		= Channels.Bindable_Events.Close_Tutorial


local Step_Index = 0
local Steps_Data = nil 
local Step_Handler, Stop_Handler = nil

local function Tutorial_Handle()
	if Steps_Data~=nil and Step_Handler ~= nil then
		Step_Index +=1
		local step = Steps_Data[Step_Index]
		Step_Handler(step)
	end
	
end

local function Tutorial_Close()
	if Stop_Handler ~= nil then
		Stop_Handler()
	end
	
	Step_Index = 0
	Steps_Data = nil
	Step_Handler = nil
end

local function Init_Tutorial(type)
	Step_Index = 0
	if type == "Tour" then
		Steps_Data = Tutorial_Mod.Tour_Steps
		Step_Handler = Tour_Mod.Handle_Step
		Stop_Handler = Tour_Mod.Handle_Stop
		Tutorial_Handle()
	elseif type == "Cage" then
		Steps_Data = Tutorial_Mod.Basic_Fight_Steps
		Step_Handler = Basic_Fight_Mod.Handle_Step
		Stop_Handler = Basic_Fight_Mod.Handle_Stop
		Tutorial_Handle()
	else
		warn("Invalid tutorial type"..type)
	end
end

Start_Tour.Event:Connect(function()
	Init_Tutorial("Tour")
end)

Start_Cage_Tutorial.Event:Connect(function()
	Init_Tutorial("Cage")
end)

Next_Tutorial_Step.Event:Connect(function()
	if Step_Index > 0 then
		if Step_Index < #Steps_Data then
			Tutorial_Handle()
		else
			Tutorial_Close()
			Close_Tutorial:Fire()
		end
	else
		warn("Tutorial not running")
	end
end)

Close_Tutorial.Event:Connect(function()
	Tutorial_Close()
end)

]]></ProtectedString>
						<string name="ScriptGuid">{A96C56B0-C5A8-4D06-B9A1-4D6F5409D9D1}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tutorial_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX21DDAC46827444EF925600014ABA6FD5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tutorial_Handle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX9BCC8B4F445643AD88326ED0509628D8">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F 	= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Tutorial_Mod 			= require(Data_Mods_F:WaitForChild("Tutorial_Mod"))

-- Channels
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local Display_Tuto_Message 	= Channels.Bindable_Events.Display_Tuto_Message
local Display_Tuto_Indicator = Channels.Bindable_Events.Display_Tuto_Indicator

local Toggle_Cutscene		= Channels.Bindable_Events.Toggle_Cutscene

local Set_Trail_E			= Channels.Bindable_Events.Set_Trail
local Remove_Trail_E		= Channels.Bindable_Events.Remove_Trail

local Toggle_Commands_Panel	= Channels.Bindable_Events.Toggle_Commands_Panel
local Toggle_Fight_Mode		= Channels.Bindable_Events.Toggle_Fight_Mode
local Disable_Fight_Mode	= Channels.Bindable_Events.Disable_Fight_Mode
local Close_Fight_Result	= Channels.Bindable_Events.Close_Fight_Result
local End_Fight				= Channels.SC_Remote_Events.End_Fight
local Fight_Set_Up			= Channels.SC_Remote_Events.Fight_Set_Up

local Tour = {}

--[[
	* Every step of the tutorial is describe with a object following this structure
	{
		title= "", -- Title of the Step
		txt="", -- Text of the Step
		camera_key="", -- Key of object for position and orientation of camera (see Workspace.Main_World_F.Gameplay.Objects.Tutorial_Parts_F)
		destination_key="", -- Key of object for position trail destination (see Workspace.Main_World_F.Gameplay.Objects.Tutorial_Parts_F)
		open_panel_event = "" -- Name of the event to open the panel
	}
	
	* Camera, Destination and Panel fields are optional
	* If a step has no camera_key, the camera will not move
	* If a step has no destination_key, the trail will show
	* If a step has no open_panel_event, no panel will open
]]--

-- Local function

local Tour_Running = false
local Tuto_Blur = nil
local Trail_color = Color3.fromRGB(35, 244, 68)

local Tutorial_Parts_F = Tutorial_Mod:GetTutorialPartsFolder()

local function Go_To_Camera(Key)
	local Tween_Cam = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
	Toggle_Cutscene:Fire(true)

	Tuto_Blur = Instance.new("BlurEffect", game.Lighting)
	Tuto_Blur.Name = "Tutorial_Blurr"
	Tuto_Blur.Size = 0

	local Camera_CFrame = Tutorial_Parts_F:FindFirstChild(Key).CFrame

	if(Camera_CFrame == nil)then
		warn("Missing Tutorial camera for key:"..Key)
		return
	end

	Cam.CameraType = Enum.CameraType.Scriptable
	TS:Create(Cam, Tween_Cam, {CFrame = Camera_CFrame}):Play()
end

local function Camera_Back_To_Player()
	if(Tuto_Blur ~= nil) then 
		Tuto_Blur:Destroy()
	end
	Toggle_Cutscene:Fire(false)
	Cam.CameraType = Enum.CameraType.Custom
	Cam.CameraSubject = Hum
end

local function Show_Message(Title, Txt)
	Display_Tuto_Message:Fire(Title, Txt)
end

local function Show_Trail(Destination_Key)
	local Destination_Position = Tutorial_Parts_F:FindFirstChild(Destination_Key).Position
	Set_Trail_E:Fire(Destination_Position, Trail_color)
end

local function Remove_Trail()
	Remove_Trail_E:Fire()
end

local function Apply_Hint_Indicator(Should_Show, Hint_Data)
	--print("Apply_Hint_Indicator: ",Should_Show, Hint_Data)
	Display_Tuto_Indicator:Fire(Should_Show, Hint_Data)
end

local function Open_Panel(Event_Name)
	local event = Channels.Bindable_Events[Event_Name]
	if event then
		event:Fire()
	else
		warn("[Open_Panel] Unknown event: " .. tostring(Event_Name))
	end
end


local function Close_Commands_Panel()
	if Tour_Running then
		Toggle_Commands_Panel:Fire(false)
	end
end

-- Public functions
function Tour.Handle_Step(Step_Data)
	Tour_Running = true
	local step = Step_Data
	
	-- show modal message
	Show_Message(step["title"], step["txt"])

	-- camera tween
	if step["camera_key"] ~= nil and step["camera_key"] ~= "" then 
		Go_To_Camera(step["camera_key"]) 
	else
		Camera_Back_To_Player()
	end

	-- trail to destination
	if step["destination_key"] ~= nil and step["destination_key"] ~= "" then 
		Show_Trail(step["destination_key"]) 
	else
		Remove_Trail() 
	end

	-- open panel
	if step["open_panel_event"] ~= nil and step["open_panel_event"] ~= "" then
		Open_Panel(step["open_panel_event"])
	end

	-- apply hand indicator depending on position and orientation
	if step["hint"] ~=nil and step["hint"] ~= "" then
		Apply_Hint_Indicator(true, step["hint"])
	else
		Apply_Hint_Indicator(false)
	end
end

function Tour.Handle_Stop()
	Tour_Running = false
	Camera_Back_To_Player()
	Remove_Trail()
	Apply_Hint_Indicator(false)
end


-- Connections

Toggle_Fight_Mode.Event:Connect(function()
	if Tour_Running then
		wait(0.1)
		local is_fighting = Char:GetAttribute("Is_Fighting")
		Toggle_Commands_Panel:Fire(is_fighting)
	end
end)

Fight_Set_Up.OnClientEvent:Connect(function()
	wait(0.05)
	if Tour_Running then
		Toggle_Commands_Panel:Fire(true)
	end
end)

End_Fight.OnClientEvent:Connect(function(Target_Char)
	Close_Commands_Panel()
end)

Disable_Fight_Mode.Event:Connect(function()
	Close_Commands_Panel()
end)

Close_Fight_Result.Event:Connect(function()
	Close_Commands_Panel()
end)


return Tour
]]></ProtectedString>
							<string name="ScriptGuid">{C991459A-B53F-4DF6-BB53-19C06356AEE0}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Tour.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX99C5BDAE5E0C4E1BA4F86BD30B62B52E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")

-- Modules
local Data_Mods_F 			= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Cage_Factory 			= require(Data_Mods_F:WaitForChild("Cage_Factory"))
local Fight_Params_Mod 		= require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))

-- Channels
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Next_Tutorial_Step 			= Channels.Bindable_Events.Next_Tutorial_Step
local Start_Tour					= Channels.Bindable_Events.Start_Tour
local Get_Fights_Keys				= Channels.Bindable_Functions.Get_Fights_Keys
local Disable_Fight_Mode  	        = Channels.Bindable_Events.Disable_Fight_Mode
local Display_InCage_Message 		= Channels.Bindable_Events.Display_InCage_Message
local Blinking_UIStroke    			= Channels.Bindable_Events.Display_InCage_UIStroke
local Blinking_ImageStroke  		= Channels.Bindable_Events.Display_InCage_ImageStroke
local Display_InCage_Indicator     	= Channels.Bindable_Events.Display_InCage_Indicator

local Create_Training_Bot			= Channels.CS_Remote_Functions.Create_Training_Bot
local Destroy_Training_Bot			= Channels.CS_Remote_Functions.Destroy_Training_Bot

local Basic_Fight = {}

local Is_Running = false
local Tuto_Cage_Name = ""
local Fight_Keys = {}
local Condition_Conn = nil

-- Local Function
local function Visible_Fight_Inputs(data) 
	for name, value in data do
		if Fight_Keys[name] then
			Fight_Keys[name].Visible = value
		end
	end
end

local function Apply_Stroke(stroke_data)
	local device  = Fight_Keys.Device
	
	for Keybind_Name, Keybind_Data in pairs(stroke_data) do
		if Fight_Keys[Keybind_Name] then
			local Keybind_Frame = Fight_Keys[Keybind_Name]
			-- Display stroke
			if Keybind_Frame:FindFirstChild("Action") then
				Keybind_Frame = Keybind_Frame.Action
			end
			
			local Template = Keybind_Data["Stroke_Template"]
			local Y_Offset = Keybind_Data["Y_Offset"]
			local Hand_Indicator_Data = Keybind_Data["Hand_Indicator"]
			if not Template then
				if Keybind_Data["Mobile"] and device == "Mobile" then
					Template 				=  Keybind_Data["Mobile"]["Stroke_Template"]
					Y_Offset 				= Keybind_Data["Mobile"]["Y_Offset"]
					Hand_Indicator_Data 	= Keybind_Data["Mobile"]["Hand_Indicator"]
				elseif Keybind_Data["Other"] and device ~= "Mobile" then
					Template 				= Keybind_Data["Other"]["Stroke_Template"]
					Y_Offset 				= Keybind_Data["Other"]["Y_Offset"]
					Hand_Indicator_Data 	= Keybind_Data["Other"]["Hand_Indicator"]
				end
			end	
			
			if Template then
				Blinking_ImageStroke:Fire(Keybind_Frame,Template, Y_Offset)
			end
			
			if Hand_Indicator_Data then
				Display_InCage_Indicator:Fire(Keybind_Frame, Hand_Indicator_Data)
			end
		end
	end
end

local function Remove_Stroke()
	Blinking_UIStroke:Fire(nil)
	Blinking_ImageStroke:Fire(nil, nil)
	Display_InCage_Indicator:Fire(nil,nil)
end


local function Reset_Next_Condition()
	if Condition_Conn ~= nil then
		Condition_Conn:Disconnect()
		Condition_Conn = nil
	end
end

local function Apply_Next_Condition(condition_data)
	Reset_Next_Condition()

	if condition_data["CharAttribute"] ~= nil then
		task.delay(condition_data["Delay"], function()
			if Char:GetAttribute(condition_data["CharAttribute"]) == condition_data["ExpectedValue"] then
				Next_Tutorial_Step:Fire()
			else 
				Condition_Conn = Char.AttributeChanged:Connect(function(attributeName)
					if attributeName == condition_data["CharAttribute"] then
						if Char:GetAttribute(condition_data["CharAttribute"]) == condition_data["ExpectedValue"] then
							Condition_Conn:Disconnect()
							Next_Tutorial_Step:Fire()
						end
					end
				end)
			end
		end)
	elseif condition_data == "TakedownAvailable" then 
		
		local Tuto_Cage = Cage_Factory:getCageFolder(Fight_Params_Mod.CageType.TUTORIAL):FindFirstChild(Tuto_Cage_Name)
		local Takedown_Tracker = Tuto_Cage:FindFirstChild("Fight_Data_F"):FindFirstChild("Takedown_Track")
		if Takedown_Tracker.Value then
			Next_Tutorial_Step:Fire()
		else 
			Condition_Conn = Takedown_Tracker.Changed:Connect(function()
				if Takedown_Tracker.Value then
					Condition_Conn:Disconnect()
					Next_Tutorial_Step:Fire()
				end
			end)
		end
	end
end


-- Public functions

function Basic_Fight.Handle_Step(Step_Data)
	if not Is_Running then 
		-- Create Cage and bot
		local res = Create_Training_Bot:InvokeServer(Fight_Params_Mod.CageType.TUTORIAL)
		if not res.success then
			warn(res.err) 
			return
		else
			Tuto_Cage_Name = res.cageName
			Is_Running=true
			Fight_Keys = Get_Fights_Keys:Invoke()
			while not Fight_Keys.Damage_Bar.Visible do
				wait(0.5)
			end
		end	
	end
	
	Display_InCage_Message:Fire(Step_Data)
	
	if Step_Data["visible_keys"] ~= nil then
		Visible_Fight_Inputs(Step_Data["visible_keys"])
	end
	
	if Step_Data["highlight"] ~= nil then
		Apply_Stroke(Step_Data["highlight"])
	else
		Remove_Stroke()
	end

	if Step_Data["next_condition"] ~= nil then
		Apply_Next_Condition(Step_Data["next_condition"])
	else
		Reset_Next_Condition()
	end
end

function Basic_Fight.Handle_Stop()
	if Is_Running and Tuto_Cage_Name ~= "" then
		-- Destroy Cage and bot
		local res = Destroy_Training_Bot:InvokeServer(Tuto_Cage_Name)
	end

	Remove_Stroke()
	Reset_Next_Condition()
	
	Disable_Fight_Mode:Fire()
	Is_Running = false
	
	local End_Conn = nil 
	End_Conn = Plr.AttributeChanged:Connect(function(attributeName)
		if attributeName == "IsTutorialRunning" then
			if Plr:GetAttribute(attributeName) == false then
				Start_Tour:Fire()
				End_Conn:Disconnect()
			end
		end
	end)
end

return Basic_Fight
]]></ProtectedString>
							<string name="ScriptGuid">{954D2682-0CA7-4E0C-B050-7A99E6238ABE}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Basic_Fight.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX7689EFAA2174403C8A9735F6818DE41F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">StarterCharacterScripts</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXA0EBB97633C44846BC9E6BEB7DFCB7F2">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Trail_Beam_Client.lua
--
--  Description:
--      Handles the visual Beam effect between the player's character 
--      (HumanoidRootPart) and a target position. The beam color and position 
--      are updated through BindableEvents, allowing dynamic control from 
--      other client-side or replicated scripts.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/Beam (template Beam object)
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/Set_Trail
--          * Channels_F/Bindable_F/Events/Remove_Trail
--      - Roblox Services:
--          * Players (LocalPlayer)
--          * Lighting (for BlurEffect detection)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Creates and reuses a cloned Beam attached to the player
--      - Generates target attachment parts dynamically for trail visualization
--      - Automatically disables and cleans up when Lighting adds a BlurEffect
--      - Trail color and visibility are controlled via BindableEvents
--      - Beam color defined by received Color3, default orange when created
--
--======================================================================


local RS = game:GetService("ReplicatedStorage")

local Channels 		= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Remove_Trail 	= Channels.Bindable_Events.Remove_Trail
local Set_Trail 	= Channels.Bindable_Events.Set_Trail


local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Main_world_F = workspace:WaitForChild("Main_World_F")
local Gameplay = Main_world_F:WaitForChild("Gameplay")
local Objects = Gameplay:WaitForChild("Objects")
local GymObjects = Objects:WaitForChild("GymObjects")
local Beam = GymObjects:WaitForChild("Beam")

local function Create_Attachment(Main_P)
	local A = Main_P:FindFirstChild("Trail_Attachment")
	if(A == nil)then
		A = Instance.new("Attachment", Main_P)
		A.Name = "Trail_Attachment"
	end

	return A
end

local function Create_Beam()
	local B = Beam:Clone()
	B.Parent = Char
	B.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 170, 0)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 170, 0))
	}
	B.Attachment0 = Create_Attachment(HRP)

	return B
end
local Beam = Create_Beam()

local function Delete_A1_Part()
	if(Beam ~= nil and Beam.Attachment1 ~= nil and Beam.Attachment1.Parent ~= nil)then
		Beam.Attachment1.Parent:Destroy()
		Beam.Attachment1 = nil
	end
end

local function Set_Trail_Handle(Pos, Col)
	if(Beam.Enabled == true)then
		Delete_A1_Part()
		Beam.Enabled = false
	end

	local function Create_A1_Part()
		local P = Instance.new("Part", game.Workspace)
		P.Name = "Trail_Target_Part"
		P.Transparency = 1
		P.Material = Enum.Material.SmoothPlastic
		P.CanCollide = false
		P.CanTouch = false
		P.Anchored = true
		P.Size = Vector3.new(1, 1, 1)
		P.CFrame = CFrame.new(Pos) * CFrame.Angles(0, 0, 0)

		return P
	end
	local A1_Part = Create_A1_Part()

	Beam.Attachment1 = Create_Attachment(A1_Part)
	Beam.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Col),
		ColorSequenceKeypoint.new(1, Col)
	}
	Beam.Enabled = true
end

Set_Trail.Event:Connect(function(Pos, Col)
	if(Beam ~= nil)then
		Set_Trail_Handle(Pos, Col)
	end
end)

Remove_Trail.Event:Connect(function()
	if(Beam ~= nil and Beam.Enabled == true)then
		Delete_A1_Part()
		Beam.Enabled = false
	end
end)

game.Lighting.ChildAdded:Connect(function(C)
	if(C ~= nil and C:IsA("BlurEffect") and Beam ~= nil and Beam.Enabled == true)then
		Beam.Enabled = false
		Delete_A1_Part()
	end
end)
]]></ProtectedString>
						<string name="ScriptGuid">{5A871FB1-08B9-4F9E-AAE1-55C4623A1FEE}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Trail_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA43BECC4767042E8972E0BF93A00D17F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Toggle_Reset_Client.lua
--
--  Description:
--      Handles dynamic enabling or disabling of the "Reset Character" button
--      in the Roblox menu, based on BindableEvents from ReplicatedStorage.
--      Ensures SetCore("ResetButtonCallback") succeeds even when CoreGui 
--      initialization is delayed.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/Toggle_Reset
--      - Roblox Services:
--          * StarterGui (SetCore API)
--          * Players (LocalPlayer)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Re-attempts SetCore until success (CoreGui ready)
--      - Default behavior enables ResetButton at startup
--      - Can be toggled externally via BindableEvent:Fire(bool)
--
--======================================================================
local RS 			= game:GetService("ReplicatedStorage")

local StarterGUI	= game:GetService("StarterGui")

local Channels 		= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_Reset 	= Channels.Bindable_Events.Toggle_Reset

local function Toggle_Reset_Call_Back(Enable)
	local function Async()
		local success = pcall(function() 
			StarterGUI:SetCore("ResetButtonCallback", Enable) 
		end)
		
		if(success)then
			return true
		end
		return false
	end
	
	while Async() == false do
		task.wait(1)
	end
end

Toggle_Reset.Event:Connect(function(Is_Enabled)
	task.spawn(Toggle_Reset_Call_Back, Is_Enabled)
end)

task.spawn(Toggle_Reset_Call_Back, true)
]]></ProtectedString>
						<string name="ScriptGuid">{28D605E0-B346-40E4-A359-FED38547166A}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Toggle_Reset_Button.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2D87696462824D399BE6DF9222092C2D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Arena_Ambience_Client.lua
--
--  Description:
--      Controls the arena ambience based on the player's position. When the 
--      player crosses a defined Z-axis threshold, the arena ambience activates:
--          * Crowd and arena background sound effects play
--          * Main background sound fades out
--          * Random camera flash effects emit from audience seats
--      Ambience stops automatically when the player leaves the region.
--		Once a Players Character passes this Z Value turn it on until the Player Leaves
--		When inside, Play the Crowd Ambient Sound Effect
--		Play the Lighting Spark Effects over all the Seats
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/RF/Player_Can_Access_Arena
--          * Data_Mods_F/Sound_Mod
--      - Workspace:
--          * Main_World_F/Map/Arena_Seating_F (audience seating models)
--      - Script:
--          * Flash_PE (ParticleEmitter template for camera flashes)
--      - Roblox Services:
--          * Debris (for temporary cleanup)
--          * Players (LocalPlayer)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Uses HumanoidRootPart Z-position to determine if player is inside arena
--      - Plays or stops layered audio effects dynamically
--      - Randomly selects audience seats to emit camera flashes
--      - Continues ambience while Is_Within_Arena_Region == true
--      - Reverts to normal background ambience when player exits region
--
--======================================================================
local RS = game:GetService("ReplicatedStorage")
local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Player_Can_Access_Arena 	= Channels.Bindable_Functions.Player_Can_Access_Arena

local Debris = game:GetService("Debris")
local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")

local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Flash_PE = script:WaitForChild("Flash_PE")

local Is_Within_Arena_Region = false
local Pos_Min = 120

local function Effects_Handle()
	SE_Mod.PlaySFX(Plr, "Crowd_SE")	
	SE_Mod.PlayMusic(Plr, "Arena_BG_SE")

	
	local Can_Access_Arena = Player_Can_Access_Arena:Invoke()
	if(Can_Access_Arena)then
		SE_Mod.Play_Voice_Over("Entering_Arena")
	else
		SE_Mod.Play_Voice_Over("Locked_Arena")
	end
	
	local function Flash_Camera_From_Seats()
		--10% of Seating
		--Pick Random Seats, Create Flash Parts, Debris, Emit Flash Particle on them
		local function Get_Arena_Seating()
			local World_F = game.Workspace:FindFirstChild("Main_World_F")
			if(World_F ~= nil and World_F:FindFirstChild("Environment") ~= nil)then
				local Environment = World_F:FindFirstChild("Environment")
				local Seating_F = Environment:FindFirstChild("Arena_Seating_F", true)
				if(Seating_F ~= nil)then
					return Seating_F:GetChildren()
				end
			end
			return {}
		end
		local Seats_Arr = Get_Arena_Seating()
		local Amount = 100 -- Can Change
		
		if(Seats_Arr ~= nil and #Seats_Arr > Amount)then
			local function Play_Camera_Flash()
				local Seat_Index = math.random(1, #Seats_Arr)
				local Seat_M = Seats_Arr[Seat_Index]
				if(Seat_M ~= nil and Seat_M:FindFirstChild("Chair_SeatColor") ~= nil)then
					table.remove(Seats_Arr, Seat_Index)
					
					local Main_P = Seat_M:FindFirstChild("Chair_SeatColor")
					local A = Instance.new("Attachment", Main_P)
					A.Name = "Flash_A"
					A.Visible = false
					A.CFrame = CFrame.new(0, 0.775, 0) * CFrame.Angles(0, 0, 0)
					
					local Emit_Count = math.random(2, 8)
					local PE = Flash_PE:Clone()
					PE.Parent = A
					PE:Emit(Emit_Count)
					
					Debris:AddItem(A, 0.25)
				end
			end
			
			for i = 1, Amount do
				Play_Camera_Flash()
				if(i % 2 == 0)then
					task.wait(0.02)
				end
			end
			
			return
		end
		
		task.wait(1)
	end
	
	
	while Is_Within_Arena_Region do
		Flash_Camera_From_Seats()
	end

	SE_Mod.PlayMusic(Plr, "Standard_Main_BG_SE")
end

function On_Init_Check()
	SE_Mod.PlayMusic(Plr, "Arena_BG_SE")
	
	local function Is_Within_Region()
		if(HRP ~= nil and HRP.Position.Z > Pos_Min)then
			return true
		end
		return false
	end
	
	if ThemeManager.getCurrentTheme() == "Halloween" then
		SE_Mod.PlayMusic(Plr, "Halloween_Main_BG_SE")
	else
		SE_Mod.PlayMusic(Plr, "Standard_Main_BG_SE")
	end
	
	while task.wait(0.5) do
		local Is_In_Region = Is_Within_Region()
		if(Is_In_Region and Is_Within_Arena_Region == false)then
			Is_Within_Arena_Region = true
			task.spawn(Effects_Handle)
			
		elseif(Is_In_Region == false and Is_Within_Arena_Region == true)then
			Is_Within_Arena_Region = false
		end
	end
end
On_Init_Check()]]></ProtectedString>
						<string name="ScriptGuid">{3C34C3CC-609F-471F-B2A7-57997E671122}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Ranked_Arena_Effects_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX59F54EE6C1304EFB939A564C96FEE09B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/FixCamera_Client.lua
--
--  Description:
--      Temporarily switches the player's camera to Scriptable mode to focus
--      on a specific CFrame received from the server, then restores normal
--      control. Used typically for teleport or cinematic transitions.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/TeleportPads/RemoteEvents/FixCamera
--      - Roblox Services:
--          * Workspace (CurrentCamera)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Waits for all folders to exist before connecting
--      - Briefly offsets camera behind the target CFrame then restores control
--      - Uses Scriptable → Custom transition to avoid abrupt snapping
--
--======================================================================


local folder = workspace:WaitForChild("Main_World_F"):WaitForChild("Gameplay"):WaitForChild("Objects"):WaitForChild("TeleportPads")
local fixCameraEvent = folder:WaitForChild("RemoteEvents"):WaitForChild("FixCamera")

fixCameraEvent.OnClientEvent:Connect(function(cf)
	local camera = workspace.CurrentCamera
	camera.CameraType = Enum.CameraType.Scriptable
	camera.CFrame = CFrame.new(
		cf.Position - cf.LookVector * 10 + Vector3.new(0, 5, 0),
		cf.Position
	)
	task.wait(0.1)
	camera.CameraType = Enum.CameraType.Custom
end)]]></ProtectedString>
						<string name="ScriptGuid">{00226B79-EFC6-45D1-BDD0-1415F234799D}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CameraFix.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5B6C8EBE1FAE4D61AF19049DB836FE72">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Cage_Visibility_Client.lua
--
--  Description:
--      Dynamically adjusts the transparency of nearby MMA cage elements 
--      based on the player's position and camera orientation. When the player
--      is fighting inside a cage, obstructing parts become more transparent
--      to improve visibility.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/Fight_Cages_F
--              - Each cage must contain a "MMA_Cage" model with expected parts:
--                CageFence, CornerTrim, PaddingCorner, PaddingFenceDoor,
--                FenceDoor, PaddingFence, FenceFrame
--      - Roblox Services:
--          * RunService (RenderStepped)
--          * Players (LocalPlayer)
--          * Workspace (CurrentCamera, Raycast)
--
--  Notes:
--      - Executes client-side only (LocalScript)
--      - Uses raycasting from camera to determine which cage obstructs view
--      - Cages not currently intersecting camera view remain fully visible
--      - Player attribute "Is_Fighting" determines if logic is active
--      - Transparency transitions are instantaneous (non-tweened)
--
--======================================================================


local RS = game:GetService("RunService")
local Plr = game.Players.LocalPlayer
local Char =  Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Main_World_F = game.Workspace:WaitForChild("Main_World_F")
local Objects = Main_World_F:WaitForChild("Gameplay"):WaitForChild("Objects")
local Fight_Cages_F = Objects:WaitForChild("Fight_Cages_F")
local Cam = game.Workspace.CurrentCamera

local Part_Names = {"CageFence", "CornerTrim", "PaddingCorner", "PaddingFenceDoor", "FenceDoor", 
	"PaddingFence", "FenceFrame"}
local Selected_M = nil

local function Get_Whitelist()
	local Cages_M = {}
	local All_Fight_Cages = Fight_Cages_F:GetChildren()
	for i = 1, #All_Fight_Cages do
		local FCM = All_Fight_Cages[i]
		if(FCM ~= nil and FCM:FindFirstChild("MMA_Cage") ~= nil)then
			table.insert(Cages_M, FCM:FindFirstChild("MMA_Cage"))
		end
	end
	
	return Cages_M
end

local function Get_Cage_M()
	local Dist = (Cam.CFrame.Position - HRP.Position).Magnitude
	local Dir = Cam.CFrame.LookVector
	local Raycast_Parm = RaycastParams.new()
	Raycast_Parm.FilterDescendantsInstances = Get_Whitelist()
	Raycast_Parm.FilterType = Enum.RaycastFilterType.Include

	local Ray_Res = game.Workspace:Raycast(Cam.CFrame.Position, Dir * Dist, Raycast_Parm)
	if(Ray_Res ~= nil and Ray_Res.Instance ~= nil and 
		Ray_Res.Instance:FindFirstAncestorWhichIsA("Model") ~= nil)then
		
		return Ray_Res.Instance:FindFirstAncestorWhichIsA("Model")
	end
	
	return nil
end

local function Toggle_Cage_Parts(M, Is_Visible)
	for i = 1, #Part_Names do
		local PN = Part_Names[i]
		local P = M:FindFirstChild(PN)
		if(P ~= nil)then
			if(Is_Visible)then
				if(PN == "CageFence")then
					P.Transparency = 0.6
				else
					P.Transparency = 0
				end
			else
				P.Transparency = 0.75
			end
		end
	end
end

RS.RenderStepped:Connect(function()
	local Is_Fighting = Char:GetAttribute("Is_Fighting") or false
	if(Is_Fighting)then
		local Cage_M = Get_Cage_M()
		if(Cage_M ~= nil and Cage_M ~= Selected_M)then
			if(Selected_M ~= nil)then
				Toggle_Cage_Parts(Selected_M, true)
			end

			Toggle_Cage_Parts(Cage_M, false)
			Selected_M = Cage_M

		elseif(Cage_M == nil and Selected_M ~= nil)then
			Toggle_Cage_Parts(Selected_M, true)
			Selected_M = nil
		end
	elseif(Selected_M ~= nil)then
		Toggle_Cage_Parts(Selected_M, true)
		Selected_M = nil
	end
end)]]></ProtectedString>
						<string name="ScriptGuid">{6586083B-E830-4BE5-A44F-2C5E9B2FBB1A}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Cage_Camera_Handle.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX36339FAB0E3C4F4D8ACD92DA1EC73191">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">StarterCharacter</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX2DE5350B7B7346BEBFEA336F52F337DD">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- Modernized Animate.lua (R15) – 100% backward-compatible version
-- Changes:
--   - Replaced Humanoid:LoadAnimation() → Animator:LoadAnimation()
--   - Ensured Animator exists
--   - Added safe loop exit on death
--   - Converted all globals to locals
--   - Used :Disconnect() instead of :disconnect()
--   - Guarded LocalPlayer usage

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop")
end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun")
end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2
local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil
local PreloadedAnims = {}
local animTable = {}

local animNames = {
	idle = {
		{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
		{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
		{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 },
	},
	walk = {
		{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 },
	},
	run = {
		{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 },
	},
	swim = {
		{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 },
	},
	swimidle = {
		{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 },
	},
	jump = {
		{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 },
	},
	fall = {
		{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 },
	},
	climb = {
		{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 },
	},
	sit = {
		{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 },
	},
	toolnone = {
		{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 },
	},
	toolslash = {
		{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 },
	},
	toollunge = {
		{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 },
	},
	wave = {
		{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 },
	},
	point = {
		{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 },
	},
	dance = {
		{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 },
	},
	dance2 = {
		{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 },
	},
	dance3 = {
		{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 },
	},
	laugh = {
		{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 },
	},
	cheer = {
		{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 },
	},
}

local emoteNames = {
	wave = false,
	point = false,
	dance = true,
	dance2 = true,
	dance3 = true,
	laugh = false,
	cheer = false,
}

math.randomseed(tick())

-- Ensure animator exists
local animator = Humanoid:FindFirstChildOfClass("Animator")
if not animator then
	animator = Instance.new("Animator")
	animator.Parent = Humanoid
end

local function findExistingAnimationInSet(set, anim)
	if not set or not anim then return 0 end
	for idx = 1, set.count, 1 do
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	return 0
end

local function configureAnimationSet(name, fileList)
	if animTable[name] then
		for _, connection in pairs(animTable[name].connections) do
			connection:Disconnect()
		end
	end
	animTable[name] = { count = 0, totalWeight = 0, connections = {} }

	local allowCustomAnimations = true
	pcall(function()
		allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations
	end)

	local config = script:FindFirstChild(name)
	if allowCustomAnimations and config then
		table.insert(animTable[name].connections, config.ChildAdded:Connect(function() configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:Connect(function() configureAnimationSet(name, fileList) end))
		for _, childPart in pairs(config:GetChildren()) do
			if childPart:IsA("Animation") then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if weightObject then newWeight = weightObject.Value end
				animTable[name].count += 1
				local idx = animTable[name].count
				animTable[name][idx] = { anim = childPart, weight = newWeight }
				animTable[name].totalWeight += newWeight
				table.insert(animTable[name].connections, childPart.Changed:Connect(function() configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:Connect(function() configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:Connect(function() configureAnimationSet(name, fileList) end))
			end
		end
	end

	if animTable[name].count <= 0 then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {
				anim = Instance.new("Animation"),
				weight = anim.weight,
			}
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name].count += 1
			animTable[name].totalWeight += anim.weight
		end
	end

	for _, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			local id = animType[idx].anim.AnimationId
			if not PreloadedAnims[id] then
				animator:LoadAnimation(animType[idx].anim)
				PreloadedAnims[id] = true
			end
		end
	end
end

local function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if fileList then configureAnimationSet(child.Name, fileList) end
end

script.ChildAdded:Connect(scriptChildModified)
script.ChildRemoved:Connect(scriptChildModified)

for name, fileList in pairs(animNames) do
	configureAnimationSet(name, fileList)
end

local toolAnim, toolAnimTime = "None", 0
local jumpAnimTime, jumpAnimDuration = 0, 0.31
local toolTransitionTime, fallTransitionTime = 0.1, 0.2
local currentlyPlayingEmote = false

local function stopAllAnimations()
	local oldAnim = currentAnim
	if emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false then oldAnim = "idle" end
	if currentlyPlayingEmote then oldAnim = "idle" currentlyPlayingEmote = false end
	currentAnim = ""
	if currentAnimKeyframeHandler then currentAnimKeyframeHandler:Disconnect() end
	if currentAnimTrack then currentAnimTrack:Stop() currentAnimTrack:Destroy() currentAnimTrack = nil end
	if runAnimKeyframeHandler then runAnimKeyframeHandler:Disconnect() end
	if runAnimTrack then runAnimTrack:Stop() runAnimTrack:Destroy() runAnimTrack = nil end
	return oldAnim
end

-- [All the remaining functions and event handlers stay identical, only updated for local scope and Animator use]

local function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			return getRigScale()
		end
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if not AnimationSpeedDampeningObject then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) *
				AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	return speedScaled / heightScale
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5
	local normalizedRunSpeed = 1
	local runSpeed = rootMotionCompensation(speed)
	local walkAnimationWeight, runAnimationWeight, timeWarp =
		smallButNotZero, smallButNotZero, 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight, timeWarp = 1, runSpeed / normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fade = (runSpeed - normalizedWalkSpeed) /
			(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight, runAnimationWeight = 1 - fade, fade
	else
		timeWarp, runAnimationWeight = runSpeed / normalizedRunSpeed, 1
	end

	if currentAnimTrack then
		currentAnimTrack:AdjustWeight(walkAnimationWeight)
		currentAnimTrack:AdjustSpeed(timeWarp)
	end
	if runAnimTrack then
		runAnimTrack:AdjustWeight(runAnimationWeight)
		runAnimTrack:AdjustSpeed(timeWarp)
	end
end

local function setAnimationSpeed(speed)
	if currentAnim == "walk" then
		setRunSpeed(speed)
	elseif currentAnimTrack and speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(speed)
	end
end

local function keyFrameReachedFunc(frameName)
	if frameName ~= "End" then return end
	if currentAnim == "walk" then
		if userNoUpdateOnLoop then
			if runAnimTrack and not runAnimTrack.Looped then runAnimTrack.TimePosition = 0 end
			if currentAnimTrack and not currentAnimTrack.Looped then currentAnimTrack.TimePosition = 0 end
		else
			if runAnimTrack then runAnimTrack.TimePosition = 0 end
			if currentAnimTrack then currentAnimTrack.TimePosition = 0 end
		end
	else
		local repeatAnim = currentAnim
		if emoteNames[repeatAnim] == false then repeatAnim = "idle" end
		if currentlyPlayingEmote then
			if currentAnimTrack and currentAnimTrack.Looped then return end
			repeatAnim = "idle"
			currentlyPlayingEmote = false
		end
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.15, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

local function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight)
	local idx = 1
	while roll > animTable[animName][idx].weight do
		roll -= animTable[animName][idx].weight
		idx += 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	if anim == currentAnimInstance then return end
	if currentAnimTrack then currentAnimTrack:Stop(transitionTime) currentAnimTrack:Destroy() end
	if runAnimTrack then runAnimTrack:Stop(transitionTime) runAnimTrack:Destroy() end
	currentAnimSpeed = 1

	currentAnimTrack = animator:LoadAnimation(anim)
	currentAnimTrack.Priority = Enum.AnimationPriority.Core
	currentAnimTrack:Play(transitionTime)
	currentAnim, currentAnimInstance = animName, anim

	if currentAnimKeyframeHandler then currentAnimKeyframeHandler:Disconnect() end
	currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:Connect(keyFrameReachedFunc)

	if animName == "walk" then
		local runIdx = rollAnimation("run")
		runAnimTrack = animator:LoadAnimation(animTable["run"][runIdx].anim)
		runAnimTrack.Priority = Enum.AnimationPriority.Core
		runAnimTrack:Play(transitionTime)
		if runAnimKeyframeHandler then runAnimKeyframeHandler:Disconnect() end
		runAnimKeyframeHandler = runAnimTrack.KeyframeReached:Connect(keyFrameReachedFunc)
	end
end

function playAnimation(animName, transitionTime, humanoid)
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim
	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

local function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-- Tool animation management
local toolAnimName, toolAnimTrack, toolAnimInstance, currentToolAnimKeyframeHandler = "", nil, nil, nil
local function toolKeyFrameReachedFunc(frameName)
	if frameName == "End" then playToolAnimation(toolAnimName, 0.0, Humanoid) end
end

function playToolAnimation(animName, transitionTime, humanoid, priority)
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim
	if anim == toolAnimInstance then return end

	if toolAnimTrack then toolAnimTrack:Stop() toolAnimTrack:Destroy() transitionTime = 0 end
	toolAnimTrack = animator:LoadAnimation(anim)
	if priority then toolAnimTrack.Priority = priority end
	toolAnimTrack:Play(transitionTime)
	toolAnimName, toolAnimInstance = animName, anim
	if currentToolAnimKeyframeHandler then currentToolAnimKeyframeHandler:Disconnect() end
	currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:Connect(toolKeyFrameReachedFunc)
end

local function stopToolAnimations()
	if currentToolAnimKeyframeHandler then currentToolAnimKeyframeHandler:Disconnect() end
	if toolAnimTrack then toolAnimTrack:Stop() toolAnimTrack:Destroy() end
	toolAnimName, toolAnimInstance, toolAnimTrack = "", nil, nil
end

-- State change handlers
local function onRunning(speed)
	local heightScale = userAnimateScaleRun and getHeightScale() or 1
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0,0,0)
	local threshold = movedDuringEmote and (Humanoid.WalkSpeed/heightScale) or 0.75
	if speed > threshold * heightScale then
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / 16.0)
		pose = "Running"
	elseif emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
		playAnimation("idle", 0.2, Humanoid)
		pose = "Standing"
	end
end

local function onDied() pose = "Dead" end
local function onJumping() playAnimation("jump", 0.1, Humanoid); jumpAnimTime = jumpAnimDuration; pose="Jumping" end
local function onClimbing(speed)
	if userAnimateScaleRun then speed /= getHeightScale() end
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 5)
	pose="Climbing"
end
local function onFreeFall()
	if jumpAnimTime <= 0 then playAnimation("fall", 0.2, Humanoid) end
	pose="FreeFall"
end
local function onSeated() pose="Seated" end
local function onSwimming(speed)
	if userAnimateScaleRun then speed /= getHeightScale() end
	if speed > 1 then playAnimation("swim", 0.4, Humanoid); setAnimationSpeed(speed/10); pose="Swimming"
	else playAnimation("swimidle", 0.4, Humanoid); pose="Standing" end
end

Humanoid.Died:Connect(onDied)
Humanoid.Running:Connect(onRunning)
Humanoid.Jumping:Connect(onJumping)
Humanoid.Climbing:Connect(onClimbing)
Humanoid.FreeFalling:Connect(onFreeFall)
Humanoid.Seated:Connect(onSeated)
Humanoid.Swimming:Connect(onSwimming)

-- Safe chat emote trigger
local player = game:GetService("Players").LocalPlayer
if player then
	player.Chatted:Connect(function(msg)
		local emote = ""
		if msg:sub(1,3)=="/e " then emote=msg:sub(4)
		elseif msg:sub(1,7)=="/emote " then emote=msg:sub(8) end
		if pose=="Standing" and emoteNames[emote]~=nil then
			playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		end
	end)
end

-- Emote bindable
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	if pose ~= "Standing" then return end
	if emoteNames[emote] ~= nil then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		return true, currentAnimTrack
	elseif typeof(emote)=="Instance" and emote:IsA("Animation") then
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)
		return true, currentAnimTrack
	end
	return false
end

-- Initial idle
if Character.Parent then playAnimation("idle", 0.1, Humanoid); pose="Standing" end

-- Animation loop with safe termination
local alive = true
Humanoid.Died:Connect(function() alive = false end)

local lastTick = 0
while Character.Parent and alive do
	local _, currentGameTime = task.wait(0.1)
	local deltaTime = currentGameTime - lastTick
	lastTick = currentGameTime
	if jumpAnimTime > 0 then jumpAnimTime -= deltaTime end
	if pose=="FreeFall" and jumpAnimTime<=0 then playAnimation("fall",0.2,Humanoid)
	elseif pose=="Seated" then playAnimation("sit",0.5,Humanoid)
	elseif pose=="Running" then playAnimation("walk",0.2,Humanoid)
	elseif pose=="Dead" then stopAllAnimations() end
end]]></ProtectedString>
						<string name="ScriptGuid">{6554129E-A815-4239-A808-28CB717EEB23}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Animate.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX4A54BAA8030249748EDF833EFBEA22BE">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">StarterGui</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXA32540C7155041A7A6FBA9830EEC9A95">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Shop</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX4C431089FE134C51A1F3636C7F2EF2CA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Offer_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXDB1D5DA215CC40BDAAB8DC805EEE31AF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")

local Plr = game.Players.LocalPlayer
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F 			= RS:WaitForChild("Data_Mods_F")
local StartupUIManager		= require(RS:WaitForChild("Modules"):WaitForChild("StartupUIManager"))
local SE_Mod 				= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local MenuButtons_Mod   	= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Display_Data_E 		= Channels.Bindable_Events.Display_Data
local Toggle_Side_Buttons 	= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Starter_Pack 	= Channels.Bindable_Events.Open_Starter_Pack

local GetActiveOffers		= Channels.Offers.GetActiveOffers
local RequestPurchase 		= Channels.Offers.RequestPurchase
local SendOfferToClient		= Channels.Offers.SendOfferToClient

-- UI References
local Main_Frame = script.Parent:WaitForChild("Main_F")

local HeaderHolder = Main_Frame:WaitForChild("Header")
local Exit_B = HeaderHolder:WaitForChild("Exit_B")


local Body = Main_Frame:WaitForChild("Body")

local Content = Body:WaitForChild("Stroke"):WaitForChild("Content")
local Purchase_B = Content:WaitForChild("Claim_B")

local oldPriceTxt = Content:WaitForChild("OldPrice")
local newPriceTxt = Content:WaitForChild("NewPrice")
local ramingTimeTxt = Content:WaitForChild("TextLabel"):WaitForChild("TimeRaming")
local amountTxt = Content:WaitForChild("Amount")
local DiscountTxt = Content:WaitForChild("Discount")

local GetNowTxt = Purchase_B:WaitForChild("Get"):WaitForChild("txt")
local Title = HeaderHolder:WaitForChild("Title")

local ItemIcon = Content:WaitForChild("TextLabel"):WaitForChild("Icon")

local ItemVPIconFrame = Content:WaitForChild("TextLabel"):WaitForChild("ViewportFrame")
local ItemVPIconWM = ItemVPIconFrame:WaitForChild("WorldModel")


local Debounce = false
local Debounce_E = false
local Debounce_UI = false
local currentOffer -- table with productKey, endsAt, etc.
local countdownConn
local pulseTween
local isSeverCall=false
local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Remove_UI()
	Disconnect_Cons()
	Main_Frame:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	task.wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Starter_Pack_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_Frame.Visible = false
	Main_Frame.Position = UDim2.new(0.5, 0, 0.675, 0)

	Toggle_Side_Buttons:Fire(true, true)

	Debounce = false
	Debounce_E = false
	Debounce_UI = false

	-- notify StartupUIManager to move to the next UI
	StartupUIManager.notifyClose("StarterGui.Shop.Offer_UI")
end

local countdownThread

local function stopCountdown()
	if countdownThread then
		task.cancel(countdownThread)
		countdownThread = nil
	end
end

local function formatDHMS(rem)
	rem = math.max(0, rem)
	local d = math.floor(rem / 86400)
	local h = math.floor((rem % 86400) / 3600)
	local m = math.floor((rem % 3600) / 60)
	local s = rem % 60
	if d > 0 then
		return string.format("LIMITED TIME OFFER %dd %dh %dm", d, h, m)
	elseif h > 0 then
		return string.format("LIMITED TIME OFFER %dh %dm %ds", h, m, s)
	else
		return string.format("LIMITED TIME OFFER %dm %ds", m, s)
	end
end

local function startCountdown()
	stopCountdown()
	local endsAt = currentOffer and currentOffer.EndsAt
	if typeof(endsAt) ~= "number" or endsAt <= 0 then
		ramingTimeTxt.Text = ""
		return
	end

	countdownThread = task.spawn(function()
		while true do
			local now = os.time()
			local rem = math.max(0, math.floor(endsAt - now))

			if rem <= 0 then
				ramingTimeTxt.Text = "Offer ended"
				stopCountdown()
				return
			end

			ramingTimeTxt.Text = formatDHMS(rem)
			if not script.Parent then
				stopCountdown()
				return
			end
			task.wait(1)
		end
	end)
end

local function SetUpViewPortIcon(offer)
	local function SetPosition(ObjectMesh,pos)
		local rotOnly = ObjectMesh.CFrame - ObjectMesh.CFrame.Position
		ObjectMesh.CFrame = CFrame.new(pos) * rotOnly
	end
	local function AnchoredModel(model)
		for _, descendant in ipairs(model:GetDescendants()) do
			if descendant:IsA("BasePart") then
				descendant.Anchored = true
			end
		end
	end

	ItemVPIconWM:ClearAllChildren()
	local oldCam = ItemVPIconFrame:FindFirstChildOfClass("Camera")
	if oldCam then
		oldCam:Destroy()
	end

	local LeftHandPos= Vector3.new(-0.741, 0, -1.972)
	local RightHandPos= Vector3.new(0.061, -0, -1.972)

	local ShortsModelPostion= Vector3.new(0, 0.8, -2)

	local ClothsFolder = game.ReplicatedStorage.Models.Clothing_F
	local ClothItemsParent
	if offer.Kind == "Shorts" then
		ClothItemsParent = ClothsFolder:WaitForChild("Shorts_F")
	else
		ClothItemsParent = ClothsFolder:WaitForChild("Gloves_F")
	end
	local showableItem = ClothItemsParent:FindFirstChild(offer.Title)
	if showableItem then
		local showableItemModel = showableItem:Clone()
		showableItemModel.Parent=ItemVPIconWM

		local camera = Instance.new("Camera")
		ItemVPIconFrame.CurrentCamera = camera
		camera.Parent = ItemVPIconFrame
		camera.CFrame=CFrame.new(0,0,0)

		if offer.Kind == "Shorts" then

			AnchoredModel(showableItemModel)
			showableItemModel:PivotTo(CFrame.new(ShortsModelPostion) *  CFrame.Angles(math.rad(-90), 0, 0) * CFrame.Angles(0, math.rad(180), math.rad(180)))
		else
			
			showableItemModel:FindFirstChild("LeftHand").Anchored=true
			showableItemModel:FindFirstChild("RightHand").Anchored=true
			showableItemModel:MoveTo(Vector3.new(0, 0, 0))
			SetPosition(showableItemModel:FindFirstChild("LeftHand"), LeftHandPos)
			SetPosition(showableItemModel:FindFirstChild("RightHand"), RightHandPos)

		end
	end
end

local function fillUIFromOffer(offer)

	if  offer.Kind=="Gloves" or  offer.Kind=="Shorts" then
		ItemVPIconFrame.Visible=true
		ItemIcon.Visible=false
		SetUpViewPortIcon(offer)
	else
		ItemVPIconFrame.Visible=false
		ItemIcon.Visible=true
		ItemIcon.Image   = offer.ItemIcon or ""
	end

	if offer.Amount == nil or offer.Amount == "" then
		amountTxt.Visible = false
	else
		amountTxt.Visible = true
		amountTxt.Text   = tostring(offer.Amount or 0)
	end

	if offer.Kind=="Shorts" or offer.Kind=="Gloves" then
		newPriceTxt.IngameCU.Visible=false
		oldPriceTxt.IngameCU.Visible=false
		oldPriceTxt.GemCU.Visible=true
		newPriceTxt.GemCU.Visible=true
	else
		oldPriceTxt.GemCU.Visible=false
		newPriceTxt.GemCU.Visible=false
		newPriceTxt.IngameCU.Visible=true
		oldPriceTxt.IngameCU.Visible=true
	end
	Title.Text = string.upper(tostring(offer.Title or "Special Offer"))
	newPriceTxt.Text = tostring(offer.NewPrice or "")
	oldPriceTxt.Text = tostring(offer.OldPrice or "")
	DiscountTxt.Text = tostring(math.floor(((offer.OldPrice - offer.NewPrice) / (offer.OldPrice))*100)or 0).."%"
	startCountdown(offer.EndsAt or 0)
end

SendOfferToClient.OnClientEvent:Connect(function(offer)
	isSeverCall=true
	currentOffer = offer
	fillUIFromOffer(currentOffer)
	Open_Starter_Pack:Fire()
end)

local function GetOfferPanel()
	local offers = GetActiveOffers:InvokeServer()
	if not offers or #offers == 0 then
		return false
	end
	currentOffer = offers[1]
	fillUIFromOffer(currentOffer)
	return true
end

local function ensureUIScale(guiObject)
	local s = guiObject:FindFirstChildOfClass("UIScale")
	if not s then
		s = Instance.new("UIScale")
		s.Scale = 1
		s.Parent = guiObject
	end
	return s
end

local function startPulse()
	if pulseTween and pulseTween.PlaybackState == Enum.PlaybackState.Playing then return end
	local s = ensureUIScale(GetNowTxt)
	local ti = TweenInfo.new(0.7, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, math.huge, true, 0)
	pulseTween = TS:Create(s, ti, { Scale = 1.05 })
	pulseTween:Play()
end

local function stopPulse()
	if pulseTween then
		pulseTween:Cancel()
		pulseTween = nil
	end
	local s = GetNowTxt:FindFirstChildOfClass("UIScale")
	if s then s.Scale = 1 end
end

local function Show_UI()
	if not isSeverCall then
		if not GetOfferPanel() then
			Main_Frame.Visible = false
			return 
		end
	end

	startPulse()
	

	local function Reset_Display()
		Disconnect_Cons()
		Main_Frame.Visible = false
		Main_Frame.Position = UDim2.new(0.5, 0, 0.675, 0)
		local Starter_Pack_Blur = game.Lighting:FindFirstChild("Starter_Pack_Blurr")
		if(Starter_Pack_Blur ~= nil)then
			Starter_Pack_Blur:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()

	local function Purchase_Button()
		table.insert(Cons, Purchase_B.MouseButton1Click:Connect(function()
			if Debounce == true then return end
			Debounce = true
			SE_Mod.PlaySFX(Plr, "Click_SE")
			TS:Create(Purchase_B, Tween_Click, {Size = UDim2.new(0.21, 0, 0.27075, 0)}):Play()
			if currentOffer and (currentOffer.ProductKey ) then
				if os.time() > (currentOffer.EndsAt or 0) then
					Display_Data_E:Fire("? Offer is Expired!", Color3.new(1, 0, 0))
					return
				end
				RequestPurchase:FireServer(currentOffer.Kind, currentOffer.ProductKey)
			else
				Display_Data_E:Fire("? Offer is not available!", Color3.new(1, 0, 0))
			end
			task.wait(0.25)
			Debounce = false
			Open_Starter_Pack:Fire()
		end))
	end
	Purchase_Button()

	MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, function()
		Remove_UI()
		stopPulse()
		stopCountdown()
	end)

	local function Display_UI()
		Main_Frame.Visible = true
		Main_Frame:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Starter_Pack_Blurr"
		Toggle_Side_Buttons:Fire(false, true)
		Debounce_UI = true
		Debounce = false
		Debounce_E = false
	end
	Display_UI()
end

Open_Starter_Pack.Event:Connect(function()
	if(Debounce_UI == false)then
		Show_UI()
	else
		Remove_UI()
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{E019E6C1-64E6-49EF-8513-98B5BBFA75D4}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Offer_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX6E36DDEE4E1A4F92B30CA38625E0E7B0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CreatorCode</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX73CC8305A9B9438AAFD68AF3DB1E4A48">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterGui/CreatorCode_UI_Handle.lua
--
--  Description:
--      Handles the Creator Code interface and integrates it with in-game
--      monetization events (MTX). This script manages code validation,
--      UI feedback, and transitions when purchases or redemptions occur.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-04 by Darkzeb
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * CreatorCodes (table of valid creator codes)
--          * Channels_F/Client_Server_F/Events/Set_Creator_Reward_Code
--          * Channels_F/Bindable_F/Events:
--

-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local MarketPlaceService = game:GetService("MarketplaceService")

local CreatorCodes = require(game.ReplicatedStorage.Modules.CreatorCodes)

local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes MTX_Prompted
local MTX_Finished 				= Channels.Bindable_Events.MTX_Finished
local MTX_Prompted 				= Channels.Bindable_Events.MTX_Prompted
local Set_Creator_Reward_Code	= Channels.CS_Remote_Events.Set_Creator_Reward_Code
local isMenuActive=false

MarketPlaceService.PromptProductPurchaseFinished:Connect(function()

	MTX_Finished:Fire()
end)

MarketPlaceService.PromptGamePassPurchaseFinished:Connect(function()
	
	MTX_Finished:Fire()
end)

MarketPlaceService.PromptPurchaseFinished:Connect(function()
	
	MTX_Finished:Fire()
	
end)

-- UI References
local InnerFrame = script.Parent.InnerFrame
local CreatorCodeFrame = InnerFrame.CreatorCodeFrame
local TextBox = CreatorCodeFrame.CodeField.TextBox

local animating = false

CreatorCodeFrame.Submit.Activated:Connect(function()
	if animating == true then
		return
	end
	
	local code = TextBox.Text
	local lastTextColor = TextBox.TextColor3
	
	local codeIndex = nil
	local found = false
	for i, v in pairs(CreatorCodes) do
		if string.lower(v.Name) == string.lower(code) then
			code = v.Name
			codeIndex = i
			
			found = true
			break
		end
	end
	
	TextBox.TextEditable = false
	animating = true
	if found == true then
		Set_Creator_Reward_Code:FireServer(codeIndex)
		
		TextBox.TextColor3 = Color3.fromRGB(0, 255, 0)
		TextBox.Text = "Code ok!"
		
		task.wait(1.5)
		
		TextBox.Text = code
		TextBox.TextColor3 = lastTextColor
	else
		Set_Creator_Reward_Code:FireServer(nil)
		
		TextBox.TextColor3 = Color3.fromRGB(255, 0, 0)
		TextBox.Text = "Code not ok!"

		task.wait(1.5)

		TextBox.Text = ""
		TextBox.TextColor3 = lastTextColor
	end
	animating = false
	TextBox.TextEditable = true
end)


local showMenu = function(t: number?)
	t = t or 1
	TS:Create(
		InnerFrame, 
		TweenInfo.new(t, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0),
		{
			Position = UDim2.new(0.5, 0, 0.5, 0), 
			AnchorPoint = Vector2.new(0.5, 0.5)
		}
	):Play()
	isMenuActive=true
end

local hideMenu = function(t: number?)
	t = t or 0.25
	TS:Create(
		InnerFrame, 
		TweenInfo.new(t, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0),
		{
			Position = UDim2.new(0.5, 0, 1.1, 0), 
			AnchorPoint = Vector2.new(0.5, 0)
		}
	):Play()
	isMenuActive=false
end
hideMenu(0)

MTX_Prompted.Event:Connect(function()
	if isMenuActive then
		return
	end
	showMenu()
	
	local function Trim(s)
		return (s:gsub("^%s*(.-)%s*$", "%1"))
	end

	task.delay(20, function()
		if isMenuActive and Trim(TextBox.Text) == "" then
			MTX_Finished:Fire()
		end
	end)
	
end)
MTX_Finished.Event:Connect(function()
	hideMenu()
end)

local cam = game.Workspace.CurrentCamera
cam:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	local vpSize = cam.ViewportSize
	
	local posMin = CreatorCodeFrame.AbsolutePosition
	local posMax = posMin + Vector2.new(CreatorCodeFrame.Size.X.Scale * InnerFrame.AbsoluteSize.X, 0) + Vector2.new(5, 0)
	
	local delta = 0
	if posMax.X >= vpSize.X then
		delta = posMax.X - vpSize.X
	end
	
	CreatorCodeFrame.Size = UDim2.new(CreatorCodeFrame.Size.X.Scale, -delta, CreatorCodeFrame.Size.Y.Scale, 0)
end)

local plrData = game.Players.LocalPlayer:WaitForChild("Player_Data")
plrData:WaitForChild("Creator Code")

local data = CreatorCodes[plrData["Creator Code"].Value]
if data ~= nil then
	TextBox.Text = data.Name
end]]></ProtectedString>
							<string name="ScriptGuid">{B6E8B799-A4C6-443B-830B-54DBDFF0E882}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CreatorCodeHandle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX245FB44A9DEA484C97E02CB76783422B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Shop_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX994C8E7E0A0647E58AF9C5988DA89819">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Cam = game.Workspace.CurrentCamera

local Owned_Passes_V = PD:WaitForChild("Owned Gamepasses")
local Cash_V = PD:WaitForChild("Coins")
local Gems_V = PD:WaitForChild("Gems")

-- Modules
local Data_Mods_F 			= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Monetization_Mod 		= require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Utils 				= require(game.ReplicatedStorage.Modules.Utils)
local Core_Frame_Handlers 	= require(script:WaitForChild("Core_Frame_Handlers"))
local Core_Utils 			= require(script:WaitForChild("Core_Utils"))
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local MenuButtons_Mod		= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local SE_Mod 				= require(Data_Mods_F:WaitForChild("Sound_Mod"))


-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 		= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Shop_UI 				= Channels.Bindable_Events.Open_Shop_UI
local Change_Shop_UIFrames 		= Channels.Bindable_Events.Change_Shop_UIFrames
local Display_Data_E 			= Channels.Bindable_Events.Display_Data

local Crate_Display 			= Channels.CS_Remote_Events.Crate_Display
local Server_Message_Crate 		= Channels.CS_Remote_Events.Server_Message_Crate
local Crate_Action_Request		= Channels.CS_Remote_Functions.Crate_Action_Request

local Show_Crate_Effects		= Channels.SC_Remote_Events.Show_Crate_Effects
local Grant_Free_Crate			= Channels.SC_Remote_Events.Grant_Free_Crate
local Open_Shop					= Channels.SC_Remote_Events.Open_Shop
local Convert_Feedback 			= Channels.SC_Remote_Events.Convert_Feedback
local Shop_Purchase_Rejected	= Channels.SC_Remote_Events.Shop_Purchase_Rejected
local Shop_Item_Purchased		= Channels.SC_Remote_Events.Shop_Item_Purchased


-- UI References
local Main_World_F 				= game.Workspace:WaitForChild("Main_World_F")
local Gameplay 					= Main_World_F:WaitForChild("Gameplay")
local Crates					= Gameplay:WaitForChild("Shop"):WaitForChild("Crates")
local ClothsFolder 				= game.ReplicatedStorage:WaitForChild("Models"):WaitForChild("Clothing_F")

-- Base frames
local Main_F 					= script.Parent.Main_F
local Data_Main_F 				= Main_F:WaitForChild("Data_Main_F")
local Top_Tab_Buttons_F 		= Data_Main_F.Top_Tab_Buttons_F
local Exit_B 					= Main_F.Header.Exit_B
local Player_Cash_Display 		= Data_Main_F:WaitForChild("Player_Currency"):WaitForChild("Cash_B")
local Player_Gems_Display 		= Data_Main_F:WaitForChild("Player_Currency"):WaitForChild("Gems_B")

-- Equipments section
local Equipments_F 				= Data_Main_F:WaitForChild("Equipments_F")
local Shorts_Display_F 			= Equipments_F:WaitForChild("Shorts_Display_F")
local Gloves_Display_F 			= Equipments_F:WaitForChild("Gloves_Display_F")
local Crates_Display_F 			= Equipments_F:WaitForChild("Crates_Display_F")

-- Crates / Items preview
local Crate_Data_F 				= Data_Main_F:WaitForChild("Crate_Data_F")
local Item_Preview_F 			= script.Parent.Item_Preview_F

-- Store section
local Shop_Store_F 				= Data_Main_F:WaitForChild("Shop_Store_F")
local Gamepass_Display_F		= Shop_Store_F:WaitForChild("Gamepass_Display_F")
local Merch_Display_F			= Shop_Store_F:WaitForChild("Merch_Display_F")

-- Currency section
local Currency_F 				= Data_Main_F:WaitForChild("Currency_F")
local Cash_F 					= Currency_F:WaitForChild("Cash_F")
local Gems_F 					= Currency_F:WaitForChild("Gems_F")
local Exchange_F 				= Currency_F:WaitForChild("Exchange_F")

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local tweenInfo = TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)

local Debounce_UI = false
local Debounce_C = false
local Debounce_E = false
local Debounce_S = false

local Reset_Button_Colors=nil
local TopTab_Button_Click=nil

local Cons = {}
local Top_Tabs_Cons = {}

local Tabs_Data = {
	{
		Main_Tab = "Equipments_F",
		SubButtons = {
			"Gloves_B",
			"Shorts_B",
			"Crates_B"
		},
		Handlers = {
			Gloves_B = Core_Frame_Handlers.Gloves.Handle,
			Shorts_B = Core_Frame_Handlers.Shorts.Handle,
			Crates_B = Core_Frame_Handlers.Crates.Handle
		},
		MainFrames = {
			Gloves_B = Gloves_Display_F,
			Shorts_B = Shorts_Display_F,
			Crates_B = Crates_Display_F
		}
	},
	{
		Main_Tab = "Currency_F",
		SubButtons = {
			"Exchange_B",
			"Cash_B",
			"Gems_B"
		},
		Handlers = {
			Exchange_B = Core_Frame_Handlers.Exchange.Handle,
			Cash_B = Core_Frame_Handlers.Cash.Handle,
			Gems_B = Core_Frame_Handlers.Gems.Handle
		},
		MainFrames = {
			Exchange_B = Exchange_F,
			Cash_B = Cash_F,
			Gems_B = Gems_F
		}
	},
	{
		Main_Tab = "Shop_Store_F",
		SubButtons = {
			"Merch_B",
			"Passes_B"
		},
		Handlers = {
			Merch_B = Core_Frame_Handlers.Merch.Handle,
			Passes_B = Core_Frame_Handlers.Passes.Handle
		},
		MainFrames = {
			Merch_B = Merch_Display_F,
			Passes_B = Gamepass_Display_F
		}
	},
	{
		Main_Tab = "Skills_F",
		SubButtons = {
			"Emotes_B",
			"SpecialPunch_B"
		},
		Handlers = {} -- tu pourras les brancher plus tard
	}
}

local function TriggerTransactionEffects()
	local function AnimateCurrency(container)
		if not container then return end

		local originalSize = container.Size
		local popSize = originalSize + UDim2.new(0, 6, 0, 6)

		local tweenIn  = TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		local tweenOut = TweenInfo.new(0.15, Enum.EasingStyle.Sine, Enum.EasingDirection.In)

		-- detect internal text if any
		local textObj = container:FindFirstChild("Data_Txt")
			or container:FindFirstChild("TextLabel")
			or container:FindFirstChildWhichIsA("TextLabel")

		-- pop
		TS:Create(container, tweenIn, { Size = popSize }):Play()
		if textObj then
			TS:Create(textObj, tweenIn, { TextColor3 = Color3.fromRGB(255, 230, 120) }):Play()
		end

		task.delay(0.15, function()
			TS:Create(container, tweenOut, { Size = originalSize }):Play()
			if textObj then
				TS:Create(textObj, tweenOut, { TextColor3 = Color3.fromRGB(255, 255, 255) }):Play()
			end
		end)
	end

	SE_Mod.PlaySFX(Plr, "Cash_SE")
	AnimateCurrency(Player_Gems_Display)
	AnimateCurrency(Player_Cash_Display)
end

local function Find_MainTab_By_SubButton(subButton)
	if type(subButton) ~= "string" then return nil end
	for _, tab in ipairs(Tabs_Data) do
		for _, btn in ipairs(tab.SubButtons or {}) do
			if btn == subButton then
				return tab.Main_Tab, tab -- also return the tab table if you need more data
			end
		end
	end
	return nil,nil
end

local function Find_Buttons_By_Tab(TabName)
	if type(TabName) ~= "string" then return nil end
	for _, tab in ipairs(Tabs_Data) do

		if tab.Main_Tab == TabName then
			return tab.SubButtons
		end
	end
	return nil
end

local function Select_Main_Tab(SelectedTab)
	for _, tab in ipairs(Tabs_Data) do
		local tabFrame = Data_Main_F:FindFirstChild(tab.Main_Tab)
		if tabFrame.Name == SelectedTab then
			tabFrame.Visible = true
		else
			tabFrame.Visible = false
		end
	end
end

local function Change_Peers_Fill_Effect(PeersParent,Selected)

	for _,btn in ipairs(PeersParent:GetChildren()) do
		if btn ~=nil and btn:IsA("Frame") or btn:IsA("ImageButton") then
			if btn.Name == Selected then
				btn.BackgroundTransparency=0
			else
				btn.BackgroundTransparency=1
			end
		end
	end
end

local function Load_Merch()	
	local Merch_Data = Monetization_Mod.Get_All_UGC_Data()

	local X, Y = 0.12, 0.25

	for key, values in pairs(Merch_Data) do

		-- Skip if already created
		local existing = Merch_Display_F.Tabs_F:FindFirstChild(values.Name)
		if existing and existing:GetAttribute("Key") == key then
			continue
		end

		local template = Merch_Display_F.Item_Tab_TMP:Clone()
		template.Name = values.Name
		template:SetAttribute("Key", key)

		-- Name
		template.Item_Name_F.Item_Name_Txt.Text = string.upper(values.Name)

		-- Price (cached)
		template.Price_F.Robux_F.Data_Txt.Text = Utils.Format_Number(values.Price)

		-- Thumbnail (cached)
		template.Item_Img.Image = values.Thumbnail

		-- Position
		template.Position = UDim2.new(X, 0, Y, 0)
		template.Parent = Merch_Display_F.Tabs_F
		template.Visible = true

		X += 0.245
		if X > 0.9 then
			X = 0.12
			Y += 0.5
		end
	end
end
Load_Merch()

local function Change_Frames(Key)
	if not Key then
		-- Hide all subframes
		for _, tab in ipairs(Tabs_Data) do
			for _, frame in pairs(tab.MainFrames or {}) do
				if frame and (frame:IsA("Frame") or frame:IsA("ScrollingFrame")) then
					frame.Visible = false
				end
			end
		end
		return
	end

	for _, tab in ipairs(Tabs_Data) do
		for subButton, frame in pairs(tab.MainFrames or {}) do
			if frame and (frame:IsA("Frame") or frame:IsA("ScrollingFrame")) then
				frame.Visible = (subButton == Key .. "_B") -- visible only for selected key
			end
		end

		-- Call the right handler if it exists
		local handler = (tab.Handlers or {})[Key .. "_B"]
		if handler then
			handler({
				Cash_F = Cash_F,
				Gems_F = Gems_F,
				Gamepass_Display_F = Gamepass_Display_F,
				Merch_Display_F = Merch_Display_F,
				Crates_Display_F = Crates_Display_F,
				Crate_Data_F = Crate_Data_F,
				Item_Preview_F = Item_Preview_F,
				Exchange_F = Exchange_F,
				Gloves_Display_F = Gloves_Display_F,
				Shorts_Display_F = Shorts_Display_F,
				Cash_V = Cash_V,
				Gems_V = Gems_V,
				Owned_Passes_V = Owned_Passes_V,
				Main_F = Main_F,
				Exit_B = Exit_B,
				Cons = Cons,
				Player_Cash_Display = Player_Cash_Display,
				Player_Gems_Display = Player_Gems_Display,
				TriggerTransactionEffects = TriggerTransactionEffects
			})
			return
		end
	end

	warn("No handler found for Key:", Key)
end

local function Track_Player_Cash_Gems()
	local function Update_Button_Val(B, Amount_V)
		local Data_Txt = B:FindFirstChildWhichIsA("TextLabel")
		if(Data_Txt ~= nil)then
			Data_Txt.Text = Utils.NumToString(Amount_V) .. ""
			local Tween_Bounce = TweenInfo.new(0.125, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, true, 0)
			Data_Txt.Position = UDim2.new(0.975, 0, 0.5, 0)
			TS:Create(Data_Txt, Tween_Bounce, {Position = UDim2.new(0.975, 0, 0, 0)}):Play()
		end
	end

	table.insert(Cons, Cash_V.Changed:Connect(function()
		Update_Button_Val(Player_Cash_Display, Cash_V.Value)
	end))
	Update_Button_Val(Player_Cash_Display, Cash_V.Value)

	table.insert(Cons, Gems_V.Changed:Connect(function()
		Update_Button_Val(Player_Gems_Display, Gems_V.Value)
	end))
	Update_Button_Val(Player_Gems_Display, Gems_V.Value)
end

local function Remove_UI()
	Core_Utils.Disconnect_Cons(Cons)

	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	task.wait(0.25)

	Change_Frames(nil)
	local Blur = game.Lighting:FindFirstChild("Shop_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Toggle_Side_Buttons:Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Display_UI(Default_Display_Type)	
	local function Reset_Display()
		Core_Utils.Disconnect_Cons(Cons)
		Change_Frames(nil)

		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)
		Item_Preview_F.Visible = false
		Item_Preview_F.Size = UDim2.new(0, 0, 0, 0)

		Cam.FieldOfView = 70
		local Blur = game.Lighting:FindFirstChild("Shop_Blurr")
		if(Blur ~= nil)then
			Blur:Destroy()
		end

	end
	Reset_Display()

	local function Bottom_Bar_Handle()
		local All_B = {}
		for _,Item in ipairs(Data_Main_F:GetDescendants()) do
			if Item:IsA("Frame") and Item.name=="Side_Tabs_F" then
				for _, btn in ipairs(Item:GetChildren()) do
					if btn:IsA("Frame") then
						table.insert(All_B,btn)
					end
				end
			end
		end

		Reset_Button_Colors = function(New_Selected)
			local function Update_Button_Text_Color(B)
				local Data_Txt = B:FindFirstChildWhichIsA("TextLabel")
				if(Data_Txt ~= nil) then
					Data_Txt.TextColor3 = Color3.new(1, 1, 1)					
				end
			end

			for i = 1, #All_B do
				local B = All_B[i]
				if(B ~= nil and B:IsA("Frame"))then
					Update_Button_Text_Color(B)
				end
			end
		end

		local function Button_Handle(B)
			local Data_Type = string.gsub(B.Name, "_B", "")
			local Selected = B:FindFirstChild("Selected")

			table.insert(Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")
					Debounce_E = false
				end
			end))


			table.insert(Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false) then

					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(B, Tween_Click, {Size = UDim2.new(0.13125, 0, 0.5625, 0)}):Play()

					Reset_Button_Colors(B)
					Change_Peers_Fill_Effect(B.Parent,B.Name)
					Change_Frames(Data_Type)

					task.wait(0.25)
					Debounce_C = false
				end
			end))

			--On Init
			if(Data_Type == Default_Display_Type)then
				local tabName, tabData = Find_MainTab_By_SubButton(B.Name)
				local TabBtnName = string.gsub(tabName, "_F", "")
				Select_Main_Tab(tabName)
				Change_Peers_Fill_Effect(Top_Tab_Buttons_F,TabBtnName)
				Change_Peers_Fill_Effect(B.Parent,B.Name)
				Reset_Button_Colors(B)
				Change_Frames(Data_Type)
			end
		end

		for i = 1, #All_B do
			local B = All_B[i]
			if(B ~= nil and B:IsA("Frame"))then
				Button_Handle(B)
			end
		end		
	end
	Bottom_Bar_Handle()

	MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)

	local function Display_Handle()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Shop_Blurr"

		Toggle_Side_Buttons:Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_Handle()

	Track_Player_Cash_Gems()
end

local function Top_Tabs_Bind()
	for _, btn in ipairs(Top_Tab_Buttons_F:GetChildren()) do
		if btn:IsA("ImageButton") then
			local Def_S = UDim2.new(0.22, 0, 1.0, 0)
			local Hover_S = UDim2.new(0.24, 0, 1.1, 0)
			local Click_S = UDim2.new(0.15, 0, 0.75, 0)
			

			-- Hover animation
			table.insert(Top_Tabs_Cons, btn.MouseEnter:Connect(function()
				if Main_F.Visible then
					SE_Mod.PlaySFX(Plr, "Hover_SE")
					btn:TweenSize(Hover_S, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true)
				end
			end))

			table.insert(Top_Tabs_Cons, btn.MouseLeave:Connect(function()
				if Main_F.Visible then
					btn:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true)
				end
			end))
			TopTab_Button_Click = function(btn)

				local ButtonNames = Find_Buttons_By_Tab(btn.Name .. "_F")
				local TabName = btn.Name .. "_F"
				Select_Main_Tab(TabName)

				local firstSubButton = ButtonNames and ButtonNames[1]
				if firstSubButton then
					local key = string.gsub(firstSubButton, "_B", "")
					Change_Frames(key)

					-- Highlight top tab
					Change_Peers_Fill_Effect(Top_Tab_Buttons_F, btn.Name)

					-- Highlight correct subbutton in the sidebar
					local sideTabs = Data_Main_F:FindFirstChild(TabName)
					if sideTabs and sideTabs:FindFirstChild("Side_Tabs_F") then
						Change_Peers_Fill_Effect(sideTabs.Side_Tabs_F, firstSubButton)
					end
				end

			end
			-- Click logic
			table.insert(Top_Tabs_Cons, btn.MouseButton1Click:Connect(function()
				if Main_F.Visible then
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TopTab_Button_Click(btn)
					TS:Create(btn, Tween_Click, { Size = Click_S }):Play()
					task.wait(0.25)
				end
			end))
		end
	end
end
Top_Tabs_Bind()

Convert_Feedback.OnClientEvent:Connect(function(newCash, newGems)
	if typeof(newCash) == "number" then
		Cash_V.Value = newCash
	end
	if typeof(newGems) == "number" then
		Gems_V.Value = newGems
	end
end)

Change_Shop_UIFrames.Event:Connect(function(Button,isUpperTab)
	if isUpperTab then
		TopTab_Button_Click(Button)
	else

		Reset_Button_Colors(Button)
		Change_Peers_Fill_Effect(Button.Parent,Button.Name)
		local Data_Type = string.gsub(Button.Name, "_B", "")
		Change_Frames(Data_Type)
	end
end)

Open_Shop_UI.Event:Connect(function(Type)
	if(Debounce_UI == false)then
		if(Type == nil)then
			Type = "Gloves"
		end
		Display_UI(Type)
	else
		Remove_UI()
	end	
end)

Open_Shop.OnClientEvent:Connect(function(Type)
	if(Debounce_UI == false)then
		if(Type == nil)then
			Type = "Gloves"
		end
		Display_UI(Type)
	end	
end)

Show_Crate_Effects.OnClientEvent:Connect(function(crateModel, gloveModel, color)

	local Crate_Owner = workspace:WaitForChild(crateModel.Name) 

	if (Crate_Owner ~= nil) then

		local VFXParts = crateModel:WaitForChild("VFX_Parts_F")
		local effect_cons = {}
		Core_Utils.Emit_VFX(VFXParts.emit6)
		task.wait(1)
		Core_Utils.Emit_VFX(VFXParts.emit1)
		Core_Utils.Emit_VFX(VFXParts.emit2)
		Core_Utils.Emit_VFX(VFXParts.emit3)
		task.wait(3)
		Core_Utils.Emit_VFX(VFXParts.emit7)
		task.wait(1)

		local glove_Owner
		for _, glove in pairs(Crates:GetChildren()) do
			if (glove and glove:GetAttribute("Owner") == crateModel.Name) then
				glove_Owner = glove
			end
		end

		if (glove_Owner ~= nil) then
			local rootPart = Crate_Owner:WaitForChild("HumanoidRootPart")
			local startCFrame = glove_Owner:GetPivot()
			local endCFrame = startCFrame + Vector3.new(0, 6, 0) 
			endCFrame = endCFrame * CFrame.Angles(0, math.rad(180), 0) 
			local cfValue = Instance.new("CFrameValue")
			cfValue.Value = startCFrame

			table.insert(effect_cons,cfValue:GetPropertyChangedSignal("Value"):Connect(function()
				glove_Owner:PivotTo(cfValue.Value)
			end))

			local tween = TS:Create(cfValue, tweenInfo, { Value = endCFrame })
			--// crate opened
			Core_Utils.Color_VFX(VFXParts.vfxpart3, color)
			Core_Utils.Color_VFX(VFXParts.emit7, color)
			Core_Utils.Toggle_VFX(VFXParts.vfxpart3, true)
			Core_Utils.Toggle_VFX(VFXParts.emit7, true)
			tween:Play()
			task.wait(6)

			local fadeTweens = {}
			for _, part in pairs(glove_Owner:GetDescendants()) do
				if part:IsA("BasePart") then
					local fadeTween = TS:Create(part, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.In), { Transparency = 1 })
					table.insert(fadeTweens, fadeTween)
				end
			end

			startCFrame = glove_Owner:GetPivot()
			endCFrame = rootPart.CFrame * CFrame.new(0, 2, 0)
			endCFrame = endCFrame * CFrame.Angles(0, math.rad(180), 0) 

			cfValue.Value = startCFrame

			local moveTween = TS:Create(cfValue, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.In), { Value = endCFrame })

			moveTween:Play()

			for _, t in pairs(fadeTweens) do
				t:Play()
			end

			task.wait(.8)

			Core_Utils.Toggle_VFX(VFXParts.vfxpart3, false)
			Core_Utils.Toggle_VFX(VFXParts.emit7, false)
			Core_Utils.Disconnect_Cons(effect_cons)
			cfValue:Destroy()
			table.clear(fadeTweens)
		end
	end

end)

Grant_Free_Crate.OnClientEvent:Connect(function(Crate_Data)
	local function Get_Rarity(Item)
		if (Item and Item["Rarity"]) then
			local Color = nil
			local Fraction = nil
			if (Item["Rarity"] == 0.7) then -- bronze
				Color = Color3.fromRGB(255, 203, 112)
				Fraction = "7 in 10"
			elseif (Item["Rarity"] == 0.15) then -- silver
				Color = Color3.fromRGB(217, 217, 217)
				Fraction = "3 in 20"
			elseif (Item["Rarity"] == 0.1) then -- gold
				Color = Color3.fromRGB(255, 170, 0)
				Fraction = "1 in 10"
			elseif (Item["Rarity"] == 0.01) then -- diamond
				Color = Color3.fromRGB(170, 255, 255)
				Fraction = "1 in 100"
			elseif (Item["Rarity"] == 0.0001) then -- platinum
				Color = Color3.fromRGB(255, 170, 255)
				Fraction = "1 in 1,000"
			end
			return Item["Rarity"], Color, Fraction
		end
	end

	local function Open_Crate(Item, Rarity, Color)
		if (ClothsFolder:FindFirstChild(Item["Name"], true)) then
			Crate_Display:FireServer(ClothsFolder:FindFirstChild(Item["Name"], true), Rarity, Color)
		end	

	end

	if(Cash_V.Value >= Crate_Data["PriceCoins"]) then

		local b,c = Crate_Action_Request:InvokeServer(Crate_Data.Name, "Coins")

		if b == true then

			local itemm = nil
			for a, v in pairs(Crate_Data["Items"]) do
				if (v["Name"] == c) then
					itemm = v
					break
				end
			end

			local rarity,color,fraction = Get_Rarity(itemm)

			Open_Crate(itemm, rarity, color)

			local txt = Plr.Name.." unlocked "..c.." ("..fraction.." rarity)"
			Server_Message_Crate:FireServer(txt, color)
			task.wait()
		end

		task.wait(.25)
	end
end)

Shop_Item_Purchased.OnClientEvent:Connect(function(type, key)
	TriggerTransactionEffects()
end)

Shop_Purchase_Rejected.OnClientEvent:Connect(function(reason, message, color)
	if reason == "NOT_ENOUGH_GEMS" then
		Display_Data_E:Fire(message, color) 
		Display_UI("Gems")
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{8C57E4AA-0091-4304-A2C9-4AAD7981AADF}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Shop_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX8120BE58FD4147B7952DDE7BB2D08B78">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Shop_Handle</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX9C213944D5474FF582DB6A2992DEFFD3">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Core_Utils.lua
-- Shared utility functions used by Client_Shop_Handle and Core_Frame_Handlers

local Core_Utils = {}

-- Disconnect all active connections
function Core_Utils.Disconnect_Cons(C)
	for i = 1, #C do
		if C[i] then
			C[i]:Disconnect()
		end
	end
	table.clear(C)
end

-- Multiply a UDim2 by a scalar (used in animations)
function Core_Utils.MultiUDim2(ud, scalar)
	return UDim2.new(
		ud.X.Scale * scalar,
		ud.X.Offset * scalar,
		ud.Y.Scale * scalar,
		ud.Y.Offset * scalar
	)
end

-- Standard button sizing for UI elements
function Core_Utils.Get_Size_Data(T)
	if string.match(T.Name, "Mega_Huge") then
		local def = UDim2.new(0.45, 0, 0.875, 0)
		local hover = UDim2.new(0.4725, 0, 0.91875, 0)
		local click = UDim2.new(0.3375, 0, 0.65625, 0)
		return def, hover, click
	else
		local def = UDim2.new(0.2, 0, 0.425, 0)
		local hover = UDim2.new(0.23, 0, 0.48875, 0)
		local click = UDim2.new(0.15, 0, 0.31875, 0)
		return def, hover, click
	end
end

-- Colorize all ParticleEmitters in a VFX part
function Core_Utils.Color_VFX(vfx_part, color)
	for _, particle in pairs(vfx_part:GetDescendants()) do
		if particle:IsA("ParticleEmitter") then
			particle.Color = ColorSequence.new(color)
		end
	end
end

-- Toggle all ParticleEmitters in a VFX part
function Core_Utils.Toggle_VFX(vfx_part, toggle)
	for _, particle in pairs(vfx_part:GetDescendants()) do
		if particle:IsA("ParticleEmitter") then
			particle.Enabled = toggle
		end
	end
end

-- Emit all ParticleEmitters once, using their EmitCount attribute
function Core_Utils.Emit_VFX(vfx_part)
	for _, particle in pairs(vfx_part:GetDescendants()) do
		if particle:IsA("ParticleEmitter") then
			particle:Emit(particle:GetAttribute("EmitCount"))
		end
	end
end

return Core_Utils
]]></ProtectedString>
								<string name="ScriptGuid">{B9E98368-841E-456D-A1B7-D554EFFC08DF}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Core_Utils.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXDBA9A42B9BD04FAD8384F8A331E1CC2C">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local Core_Frame_Handlers = {}

-- Services
local TS 	= game:GetService("TweenService")
local MPS 	= game:GetService("MarketplaceService")
local RS 	= game:GetService("ReplicatedStorage")
local Plr 	= game.Players.LocalPlayer
local PD 	= Plr:WaitForChild("Player_Data")
local Cam 	= game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = RS:WaitForChild("Data_Mods_F")

local Core_Utils 				= require(script.Parent:WaitForChild("Core_Utils"))
local Utils 					= require(game.ReplicatedStorage.Modules.Utils)
local MenuButtons_Mod			= require(game.ReplicatedStorage.Design.MenuButtons)

local Monetization_Mod 			= require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Crate_Mod 				= require(Data_Mods_F:WaitForChild("Crate_Mod"))
local Offers_Config 			= require(Data_Mods_F:WaitForChild("Offers_Config"))

local Clothing_Mod 				= require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local ClothsFolder 				= game.ReplicatedStorage:WaitForChild("Models"):WaitForChild("Clothing_F")

local SE_Mod 					= require(Data_Mods_F:WaitForChild("Sound_Mod"))

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local Crate_Display 			= Channels.CS_Remote_Events.Crate_Display
local Crate_Action_Request		= Channels.CS_Remote_Functions.Crate_Action_Request
local Server_Message_Crate 		= Channels.CS_Remote_Events.Server_Message_Crate
local Convert_Cash_To_Gems 		= Channels.CS_Remote_Events.Convert_Cash_To_Gems
local Purchase_Cloth_Item 		= Channels.CS_Remote_Events.Purchase_Cloth_Item

local Toggle_Side_Buttons 		= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Shop_UI 				= Channels.Bindable_Events.Open_Shop_UI
local Display_Data_E 			= Channels.Bindable_Events.Display_Data
local MTX_Prompted 				= Channels.Bindable_Events.MTX_Prompted

local Convert_Feedback			= Channels.SC_Remote_Events.Convert_Feedback

-- UI 
local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

local Debounce_C = false
local Debounce_E = false
local Debounce_S = false
local Debounce_UI = false

local Crate_Preview_Cons = {}
local BuyConnections = {}

-- HANDLER FUNCTIONS
local function Cash_Handle(context)
	local Cash_Cons = {}
	local mainFrame = context.Cash_F
	local Tabs = mainFrame:GetChildren()

	local function Update_Tab_Cash_Amounts()
		local function Update_Tab_Amount(T)
			local Dev_Key = T:GetAttribute("Key")

			-- update the boost amount
			local Boost_Amount_Txt = T:FindFirstChild("Boost_Amount_Txt")

			local cash_amount = Monetization_Mod.Get_Cash_Pack_Amount(Dev_Key)
			if(Boost_Amount_Txt ~= nil and Dev_Key ~= nil and cash_amount ~= nil)then
				Boost_Amount_Txt.Text = "+ " .. Utils.NumToString(cash_amount)
			end

			-- update the price =
			local Boost_Price = T:FindFirstChild("Price_F"):FindFirstChild("TextLabel")

			local pack_price = Monetization_Mod.Get_Cash_Pack_Price(Dev_Key)
			if(Boost_Price ~= nil and Dev_Key ~= nil and pack_price ~= nil)then
				Boost_Price.Text = Utils.NumToString(pack_price)
			end
		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil and T:IsA("Frame"))then
				Update_Tab_Amount(T)
			end
		end
	end
	Update_Tab_Cash_Amounts()

	table.insert(Cash_Cons, context.Cash_V.Changed:Connect(function()
		Update_Tab_Cash_Amounts()
	end))

	local function Init_Tab_Click_Handles()
		local function Tab_Handle(T)
			local Selected = T:FindFirstChild("Selected")
			local Key = T:GetAttribute("Key") or "A"
			local Dev_ID = Monetization_Mod.Get_ID_From_Key(false, Key)
			local Def_S, Hover_S, Click_S = Core_Utils.Get_Size_Data(T)
			T.Size = Def_S

			table.insert(Cash_Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false and mainFrame.Visible == true)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")

					T:TweenSize(Hover_S, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					Debounce_E = false
				end
			end))

			table.insert(Cash_Cons, Selected.MouseLeave:Connect(function()
				if(mainFrame.Visible == true)then
					T:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
				end
			end))

			table.insert(Cash_Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false and mainFrame.Visible == true)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(T, Tween_Click, {Size = Click_S}):Play()

					MPS:PromptProductPurchase(Plr, Dev_ID)
					MTX_Prompted:Fire()

					task.wait(0.25)
					Debounce_C = false
				end
			end))	
		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil and T:IsA("Frame"))then
				Tab_Handle(T)
			end
		end

		mainFrame.Visible = true
	end
	Init_Tab_Click_Handles()

	table.insert(Cash_Cons, mainFrame:GetPropertyChangedSignal("Visible"):Connect(function()
		if(context.Cash_F.Visible == false)then
			Core_Utils.Disconnect_Cons(Cash_Cons)
		end
	end))
end

local function Gems_Handle(context)
	local Gems_Cons = {}
	local mainFrame = context.Gems_F
	local Tabs = mainFrame:GetChildren()

	local function Update_Tab_Gems_Amounts()

		local function Update_Tab_Amount(T)
			local Dev_Key = T:GetAttribute("Key")

			-- update the boost amount
			local Boost_Amount_Txt = T:FindFirstChild("Boost_Amount_Txt")

			local gems_amount = Monetization_Mod.Get_Gems_Pack_Amount(Dev_Key)
			if(Boost_Amount_Txt ~= nil and Dev_Key ~= nil and gems_amount ~= nil)then
				Boost_Amount_Txt.Text = "+ " .. Utils.NumToString(gems_amount)
			end

			-- update the price =
			local Boost_Price = T:FindFirstChild("Price_F"):FindFirstChild("TextLabel")

			local pack_price = Monetization_Mod.Get_Gems_Pack_Price(Dev_Key)
			if(Boost_Price ~= nil and Dev_Key ~= nil and pack_price ~= nil)then
				Boost_Price.Text = Utils.NumToString(pack_price)
			end

		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil and T:IsA("Frame"))then
				Update_Tab_Amount(T)
			end
		end
	end
	Update_Tab_Gems_Amounts()

	local function Init_Tab_Click_Handles()
		local function Tab_Handle(T)
			local Selected = T:FindFirstChild("Selected")
			local Key = T:GetAttribute("Key") or "A"
			local Dev_ID = Monetization_Mod.Get_ID_From_Key(false, Key)
			local Def_S, Hover_S, Click_S = Core_Utils.Get_Size_Data(T)
			T.Size = Def_S

			table.insert(Gems_Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false and mainFrame.Visible == true)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")

					T:TweenSize(Hover_S, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					Debounce_E = false
				end
			end))

			table.insert(Gems_Cons, Selected.MouseLeave:Connect(function()
				if(mainFrame.Visible == true)then
					T:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
				end
			end))

			table.insert(Gems_Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false and mainFrame.Visible == true)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(T, Tween_Click, {Size = Click_S}):Play()

					MPS:PromptProductPurchase(Plr, Dev_ID)
					MTX_Prompted:Fire()

					task.wait(0.25)
					Debounce_C = false
				end
			end))	
		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil and T:IsA("Frame"))then
				Tab_Handle(T)
			end
		end

		mainFrame.Visible = true
	end
	Init_Tab_Click_Handles()

	table.insert(Gems_Cons, mainFrame:GetPropertyChangedSignal("Visible"):Connect(function()
		if(mainFrame.Visible == false)then
			Core_Utils.Disconnect_Cons(Gems_Cons)
		end
	end))
end

local function Gamepasses_Handle(context)
	local GP_Cons = {}
	local mainFrame = context.Gamepass_Display_F


	local Tabs = mainFrame:GetChildren()

	local function Update_Owned_Gamepass_Tabs()
		local function Update_Tab(T)
			local GP_Key = T:GetAttribute("GP_Key")
			local Action_F = T:FindFirstChild("Action_F")
			local Owned_F = Action_F:FindFirstChild("Owned_F")
			local Buy_F = Action_F:FindFirstChild("Buy_F")

			if(GP_Key ~= nil and Monetization_Mod.Does_Player_Own_Gamepass_Key(Plr, GP_Key))then
				Owned_F.Visible = true
				Buy_F.Visible = false
			else
				Buy_F.Visible = true
				Owned_F.Visible = false
			end
		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil and T:IsA("Frame"))then
				Update_Tab(T)
			end
		end
	end
	Update_Owned_Gamepass_Tabs()

	table.insert(GP_Cons, MPS.PromptGamePassPurchaseFinished:Connect(function(player, gamePassId, bought)
		if bought then
			local GP_Key = Monetization_Mod.Get_Key_From_ID(true, gamePassId)
			
			if(context.Owned_Passes_V ~= nil)then
				local Keys = string.split(context.Owned_Passes_V.Value, ",")
				Keys[#Keys + 1] = GP_Key
				context.Owned_Passes_V.Value = table.concat(Keys, ",")
			end
			
			Update_Owned_Gamepass_Tabs()
		end
	end))

	local function Init_Tab_Click_Handles()
		local function Tab_Handle(T)
			local Selected = T:FindFirstChild("Selected")
			local Key = T:GetAttribute("GP_Key") or "A"
			local GP_ID = Monetization_Mod.Get_ID_From_Key(true, Key)
			local GP_Data = Monetization_Mod.Get_Data_From_Key(true, Key)
			local Stroke = T:FindFirstChild("UIStroke")
			local Gamepass_Img = T:FindFirstChild("Gamepass_Img")
			local GP_Name_Txt = T:FindFirstChild("Gamepass_Name_Txt")
			local Action_F = T:FindFirstChild("Action_F")
			local Owned_F = Action_F:FindFirstChild("Owned_F")
			local Buy_F = Action_F:FindFirstChild("Buy_F")
			local Buy_B = Buy_F:FindFirstChild("Buy_B")
			local Def_S = UDim2.new(0.975, -5, 0.3875, 0)
			local Click_S = UDim2.new(0.73125, -5, 0.290625, 0)

			T.Size = Def_S
			Gamepass_Img.Image = GP_Data['Icon'] .. ""
			Gamepass_Img.ImageColor3 = Color3.new(1, 1, 1)
			GP_Name_Txt.TextColor3 = Color3.new(1, 1, 1)
			Stroke.Color = Color3.new(1, 1, 1)

			table.insert(GP_Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false and mainFrame.Visible == true)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")

					Gamepass_Img.ImageColor3 = Color3.fromRGB(150, 150, 150)
					GP_Name_Txt.TextColor3 = Color3.fromRGB(150, 150, 150)
					Stroke.Color = Color3.fromRGB(35, 244, 68)

					Debounce_E = false
				end
			end))

			table.insert(GP_Cons, Selected.MouseLeave:Connect(function()
				if(mainFrame.Visible == true)then
					Gamepass_Img.ImageColor3 = Color3.new(1, 1, 1)
					GP_Name_Txt.TextColor3 = Color3.new(1, 1, 1)
					Stroke.Color = Color3.new(1, 1, 1)
				end
			end))

			table.insert(GP_Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false and mainFrame.Visible == true)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(T, Tween_Click, {Size = Click_S}):Play()

					if(Owned_F.Visible == false)then
						MPS:PromptGamePassPurchase(Plr, GP_ID)
						
						
						--MTX_Prompted:Fire()
					else
						local Txt = "✔️ You already own this Gamepass!"
						Display_Data_E:Fire(Txt, Color3.fromRGB(35, 244, 68))
					end

					task.wait(0.25)
					Debounce_C = false
				end
			end))	
		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil and T:IsA("Frame"))then
				Tab_Handle(T)
			end
		end

		mainFrame.CanvasPosition = Vector2.new(0, 0)
		mainFrame.Visible = true
	end
	Init_Tab_Click_Handles()

	table.insert(GP_Cons, mainFrame:GetPropertyChangedSignal("Visible"):Connect(function()
		if(mainFrame.Visible == false)then
			Core_Utils.Disconnect_Cons(GP_Cons)
		end
	end))

end

local function Merch_Handle(context)
	local Merch_Cons = {}
	local mainFrame = context.Merch_Display_F
	local Tabs = mainFrame.Tabs_F:GetChildren()

	local function styleMerchCard(card)
		-- Gradient background (sleek dark)
		local gradient = Instance.new("UIGradient")
		gradient.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 25)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(55, 55, 55))
		}
		gradient.Rotation = 90
		gradient.Parent = card

		-- Subtle stroke (neutral gray tone)
		local glow = Instance.new("UIStroke")
		glow.Thickness = 1.5
		glow.Transparency = 0.5
		glow.Color = Color3.fromRGB(180, 180, 180)
		glow.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		glow.Parent = card

	end

	local function enhanceViewport(vf)
		if not vf then return end

		-- Light tuning
		vf.LightColor = Color3.fromRGB(255, 245, 230)
		vf.Ambient = Color3.fromRGB(200, 200, 200)

		-- Gentle color correction for better contrast
		local cam = vf:FindFirstChildOfClass("Camera")
		if cam then
			local cc = Instance.new("ColorCorrectionEffect")
			cc.Brightness = 0.15
			cc.Contrast = 0.25
			cc.Saturation = 0.15
			cc.Parent = cam
		end
	end

	local function Init_Tab_Click_Handles()
		local function Tab_Handle(T)
			local Selected = T:FindFirstChild("Selected")
			local Key = T:GetAttribute("Key") or "A"
			local Dev_ID = Monetization_Mod.Get_ID_From_Key_UGC(Key)
			local Def_S, Hover_S, Click_S = Core_Utils.Get_Size_Data(T)
			T.Size = Def_S

			-- Apply visual style
			styleMerchCard(T)
			enhanceViewport(T:FindFirstChild("VF"))

			-- Hover animation
			table.insert(Merch_Cons, Selected.MouseEnter:Connect(function()
				if not mainFrame.Visible then return end
				if not Debounce_E then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")

					T:TweenSize(Hover_S, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.15, true)
					local stroke = T:FindFirstChildOfClass("UIStroke")
					if stroke then stroke.Transparency = 0 end
					task.wait(0.15)
					Debounce_E = false
				end
			end))

			table.insert(Merch_Cons, Selected.MouseLeave:Connect(function()
				if not mainFrame.Visible then return end
				T:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.15, true)
				local stroke = T:FindFirstChildOfClass("UIStroke")
				if stroke then stroke.Transparency = 0.5 end
			end))

			-- Purchase click
			table.insert(Merch_Cons, Selected.MouseButton1Click:Connect(function()
				if not mainFrame.Visible or Debounce_C then return end
				Debounce_C = true
				SE_Mod.PlaySFX(Plr, "Click_SE")
				TS:Create(T, Tween_Click, {Size = Click_S}):Play()
				MPS:PromptPurchase(Plr, Dev_ID)
				task.wait(0.25)
				Debounce_C = false
			end))
		end

		for _, T in ipairs(Tabs) do
			if T:IsA("Frame") then
				Tab_Handle(T)
			end
		end

		mainFrame.Visible = true
	end

	Init_Tab_Click_Handles()

	table.insert(Merch_Cons, mainFrame:GetPropertyChangedSignal("Visible"):Connect(function()
		if not mainFrame.Visible then
			Core_Utils.Disconnect_Cons(Merch_Cons)
		end
	end))

end

local function Crates_Handle(context)
	local Crate_Cons = {}
	local Crates_Display_F = context.Crates_Display_F
	local Crate_Data_F = context.Crate_Data_F
	local Item_Preview_F = context.Item_Preview_F

	local Tabs = Crates_Display_F:GetChildren()
	Crate_Data_F.Visible = false
	Item_Preview_F.Visible = false

	Crates_Display_F.Tabs_F:ClearAllChildren()
	Crates_Display_F.Visible = true

	--// setup the crate frames displaying the items in that crate frame, rarity, etc...
	local Crates = Crate_Mod.Get_Crate_Data_Arr()

	local x,y = 0.165,0.275

	local function Get_Rarity(Item)
		if (Item and Item["Rarity"]) then
			local Color = nil
			local Fraction = nil
			if (Item["Rarity"] == 0.7) then -- bronze
				Color = Color3.fromRGB(255, 203, 112)
				Fraction = "70% chance"
			elseif (Item["Rarity"] == 0.15) then -- silver
				Color = Color3.fromRGB(217, 217, 217)
				Fraction = "15% chance"
			elseif (Item["Rarity"] == 0.1) then -- gold
				Color = Color3.fromRGB(255, 170, 0)
				Fraction = "10% chance"
			elseif (Item["Rarity"] == 0.01) then -- diamond
				Color = Color3.fromRGB(170, 255, 255)
				Fraction = "1% chance"
			elseif (Item["Rarity"] == 0.0001) then -- platinum
				Color = Color3.fromRGB(255, 170, 255)
				Fraction = "0.01% chance"
			end
			return Item["Rarity"], Color, Fraction
		end
	end

	local function Open_Crate(Item, Rarity, Color)
	
		if (ClothsFolder:FindFirstChild(Item["Name"], true)) then

			--// UI Stuff
			Item_Preview_F:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)

			task.wait(0.25)

			Core_Utils.Disconnect_Cons(Crate_Cons)
			Crate_Data_F.Visible = false
			context.Exit_B.Visible = true
			Crates_Display_F.Visible = false
			Item_Preview_F.Visible = false

			Core_Utils.Disconnect_Cons(context.Cons)
			context.Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
			TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

			task.wait(0.25)

			local Blur = game.Lighting:FindFirstChild("Shop_Blurr")
			if(Blur ~= nil)then
				Blur:Destroy()
			end
			Cam.FieldOfView = 70

			context.Main_F.Visible = false
			context.Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

			Toggle_Side_Buttons:Fire(true, true)

			Debounce_UI = false
			Debounce_C = false
			Debounce_E = false
			Debounce_S = false

			--// Crate Stuff
			if (ClothsFolder:FindFirstChild(Item["Name"], true)) then
				Crate_Display:FireServer(ClothsFolder:FindFirstChild(Item["Name"], true), Rarity, Color)
			end
		end	
	end

	local function Tab_Handle(T, crate_values)
		local Selected = T:FindFirstChild("Selected")
		local Def_S = UDim2.new(0.3, 0,0.5, 0)
		T.Size = Def_S

		table.insert(Crate_Cons, Selected.MouseEnter:Connect(function()
			if(Debounce_E == false and Crates_Display_F.Visible == true)then
				Debounce_E = true
				SE_Mod.PlaySFX(Plr, "Hover_SE")

				T:TweenSize(Core_Utils.MultiUDim2(T.Size, 1.03), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
				Debounce_E = false
			end
		end))

		table.insert(Crate_Cons, Selected.MouseLeave:Connect(function()
			if(Crates_Display_F.Visible == true)then
				T:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
			end
		end))

		table.insert(Crate_Cons, Selected.MouseButton1Click:Connect(function()
			if(Debounce_C == false and Crates_Display_F.Visible == true)then
				Debounce_C = true
				SE_Mod.PlaySFX(Plr, "Click_SE")
				TS:Create(T, Tween_Click, {Size = Core_Utils.MultiUDim2(T.Size, 0.85)}):Play()

				local t_X,t_Y = 0.125,0.25

				Crate_Data_F.Items_F.Tabs_F:ClearAllChildren()

				task.wait()

				Crate_Data_F.Title_Text.Text = crate_values["Name"]:upper()
				Crate_Data_F.Bottom_Bar_F.Gems_B.Data_Txt.Text = Utils.Format_Number(crate_values["PriceGems"])

				Core_Utils.Disconnect_Cons(Crate_Preview_Cons)	
				Crate_Preview_Cons = {} 

				table.insert(Crate_Preview_Cons, Crate_Data_F.Bottom_Bar_F.Gems_B.Selected.MouseButton1Click:Connect(function()
					task.wait()
					if Debounce_S then return end
					Debounce_S = true

					local playerGems = context.Gems_V.Value
					local price = crate_values["PriceGems"]

					if playerGems >= price then
						local success, won_item = Crate_Action_Request:InvokeServer(crate_values.Name, "Gems")

						if success and won_item then
							local selectedItem = nil
							for _, v in pairs(crate_values["Items"]) do
								if v["Name"] == won_item then
									selectedItem = v
									break
								end
							end

							if selectedItem then
								local rarity, color, fraction = Get_Rarity(selectedItem)
								Open_Crate(selectedItem, rarity, color)
								context.TriggerTransactionEffects()
								
								task.delay(10, function()
									local msg_for_player = "🎁 You unlocked " .. won_item .. " (" .. fraction .. " rarity)"
									Display_Data_E:Fire(msg_for_player, Color3.fromRGB(255, 215, 0))
								end)


								local msg_for_chat = Plr.Name .. " unlocked " .. won_item .. " (" .. fraction .. " rarity)"
								Server_Message_Crate:FireServer(msg_for_chat, color)
							end
						end
					else
						Display_Data_E:Fire("❌ You don't have enough Gems!", Color3.fromRGB(225, 0, 0))
						Open_Shop_UI:Fire("Gems")
						-- Open_InsufficientFunds_UI:Fire(true, price - playerGems)
					end

					task.wait(0.25)
					Debounce_S = false
				end))

				--// Crate Data Stuff
				local allRarities = {}
				local tempKeys = {}

				for i,v in pairs(crate_values["Items"]) do
					allRarities[i] = v["Rarity"]
				end

				for key, _ in pairs(allRarities) do
					table.insert(tempKeys, key)
				end

				table.sort(tempKeys, function(a, b)
					return allRarities[a] < allRarities[b]
				end)


				for _, item in ipairs(tempKeys) do 
					if (Clothing_Mod.Get_Gloves_Data(crate_values["Items"][item]["Name"]) or Clothing_Mod.Get_Shorts_Data(crate_values["Items"][item]["Name"]) ) then
						--// Load Template
						local Rarity, Color, Fraction = Get_Rarity(crate_values["Items"][item])
						local tmp_Item = Crate_Data_F.Items_F.Item_Tab_TMP:Clone()
						tmp_Item.Name = crate_values["Items"][item]["Name"]
						tmp_Item.Item_Name_F.Item_Name_Txt.Text = string.upper(crate_values["Items"][item]["Name"])
						tmp_Item.Position = UDim2.new(t_X, 0, t_Y, 0)
						tmp_Item.BackgroundColor3 = Color
						tmp_Item.UIStroke.Color = Color
						tmp_Item.Parent = Crate_Data_F.Items_F.Tabs_F
						tmp_Item.Visible = true

						--// VF
						local display = ClothsFolder:FindFirstChild(crate_values["Items"][item]["Name"], true):Clone()
						local Viewport_Camera = Instance.new("Camera")
						if (display:FindFirstChild("LeftHand")) then
							for _, hand in pairs(display:GetChildren()) do
								if (hand.Name == "LeftHand") then
									if (display:FindFirstChild("LeftHandM") == nil) then
										local model = Instance.new("Model")
										model.Name = "LeftHandM"
										model.Parent = display
										hand.Parent = model
									elseif (display:FindFirstChild("LeftHandM") ~= nil) then
										hand.Parent = display:FindFirstChild("LeftHandM")
									end
								elseif (hand.Name == "RightHand") then
									if (display:FindFirstChild("RightHandM") == nil) then
										local model = Instance.new("Model")
										model.Name = "RightHandM"
										model.Parent = display
										hand.Parent = model
									elseif (display:FindFirstChild("RightHandM") ~= nil) then
										hand.Parent = display:FindFirstChild("RightHandM")
									end
								end
							end
							display:WaitForChild("RightHandM"):PivotTo(CFrame.new(0.245, 0, -0) * CFrame.Angles(0, math.rad(90), 0))
							display:WaitForChild("LeftHandM"):PivotTo(CFrame.new(-0.645, 0, 0) * CFrame.Angles(0, math.rad(90), 0))
							display:PivotTo(CFrame.new(0,0,0))
							tmp_Item.VF.CurrentCamera = Viewport_Camera
							display.Parent = tmp_Item.VF.WM
							tmp_Item.VF.WM:PivotTo(CFrame.new(0,0,0)* CFrame.Angles(0,math.rad(90),0)) -- * CFrame.Angles(math.rad(180),0,0)
							Viewport_Camera.Parent = tmp_Item.VF
							Viewport_Camera.CFrame = CFrame.new(0, -0.15, 1.3)
						elseif (display:FindFirstChild("LowerTorso")) then
							display:PivotTo(CFrame.new(0,0,0))
							tmp_Item.VF.CurrentCamera = Viewport_Camera
							display.Parent = tmp_Item.VF.WM
							tmp_Item.VF.WM:PivotTo(CFrame.new(0,0,0)) 
							Viewport_Camera.Parent = tmp_Item.VF
							Viewport_Camera.CFrame = CFrame.new(0, 0, 2)
						end

						t_X += 0.25

						if t_X >= 0.9 then
							t_X = 0.125
							t_Y += 0.525
						end

						table.insert(Crate_Preview_Cons, tmp_Item.Selected.MouseButton1Click:Connect(function()
							--// setup the item preview thing
							if (Item_Preview_F.Main_Data_F.VF:FindFirstChildOfClass("Camera")) then
								Item_Preview_F.Main_Data_F.VF.WM:ClearAllChildren()
								Item_Preview_F.Main_Data_F.VF:FindFirstChildOfClass("Camera"):Destroy()	
							end

							MenuButtons_Mod.Setup_Exit_X_Button(Crate_Preview_Cons, Item_Preview_F.Main_Data_F.Exit_B, function()
								Item_Preview_F:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true)
								Item_Preview_F.Visible = false
							end)

							local display2 = ClothsFolder:FindFirstChild(crate_values["Items"][item]["Name"], true):Clone()
							local Viewport_Camera2 = Instance.new("Camera")
							if (display2:FindFirstChild("LeftHand")) then

								-- Wrap parts into LeftHandM / RightHandM models
								for _, part in ipairs(display2:GetChildren()) do
									if part:IsA("BasePart") and (part.Name == "LeftHand" or part.Name == "RightHand") then
										local groupName = part.Name .. "M"
										local group = display2:FindFirstChild(groupName) or Instance.new("Model")
										group.Name = groupName
										group.Parent = display2
										part.Parent = group
										part.Anchored = true
									end
								end

								local left  = display2:FindFirstChild("LeftHandM")
								local right = display2:FindFirstChild("RightHandM")

								if left and right then
									-- reset the model pivot
									display2.Parent = Item_Preview_F.Main_Data_F.VF.WM
									display2:PivotTo(CFrame.new(0,0,0))
									Item_Preview_F.Main_Data_F.VF.WM:PivotTo(CFrame.new(0,0,0)) 
									Item_Preview_F.Main_Data_F.VF.CurrentCamera = Viewport_Camera2
									Viewport_Camera2.Parent = Item_Preview_F.Main_Data_F.VF
									Viewport_Camera2.CFrame = CFrame.new(0, -0.15, 1.6)

									-- reduce spacing (crates preview space was too large)
									local OFFSET = 0.5

									-- initial pose: thumbs inward (same as Equipment and Shop)
									left:PivotTo(CFrame.new(-OFFSET, 0, 0) * CFrame.Angles(0, math.rad(90), 0))
									right:PivotTo(CFrame.new( OFFSET, 0, 0) * CFrame.Angles(0, math.rad(-90), 0))

									-- apply unified hover rotation
									Utils.SetupRotation(left, 3)
									Utils.SetupRotation(right, -3)
								end

							elseif (display2:FindFirstChild("LowerTorso")) then
								local torso = display2:FindFirstChild("LowerTorso")
								if torso then
									display2.PrimaryPart = torso
									display2.PrimaryPart.PivotOffset = CFrame.new(0, 0, 0)
								else
									warn("[Shop Preview] LowerTorso not found for:", display2.Name)
								end
								display2:PivotTo(CFrame.new(0,0,0))
								Item_Preview_F.Main_Data_F.VF.CurrentCamera = Viewport_Camera2
								display2.Parent = Item_Preview_F.Main_Data_F.VF.WM
								Item_Preview_F.Main_Data_F.VF.WM:PivotTo(CFrame.new(0,0,0)) 
								Viewport_Camera2.Parent = Item_Preview_F.Main_Data_F.VF
								Viewport_Camera2.CFrame = CFrame.new(0, -0.5, 2)
							end

							Item_Preview_F.Main_Data_F.Item_Name_Txt.Text = crate_values["Items"][item]["Name"]
							Item_Preview_F.Main_Data_F.Rare_F.Visible = true
							Item_Preview_F.Main_Data_F.Rare_F.Rare_Data_Txt.Text = Fraction
							Item_Preview_F.Main_Data_F.Rare_F.Rare_Data_Txt.TextColor3 = Color

							local buyButton = Item_Preview_F.Main_Data_F.Buy_B
							buyButton.Visible = false

							Item_Preview_F.Visible = true		

							Item_Preview_F:TweenSize(UDim2.new(1, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
						end))
					end
				end


				Crate_Data_F.Visible = true
				context.Exit_B.Visible = false
				Crates_Display_F.Visible = false
				Item_Preview_F.Visible = false

				MenuButtons_Mod.Setup_Exit_X_Button(Crate_Preview_Cons, Crate_Data_F.Exit_B, function()
					Item_Preview_F.Visible = false
					Crate_Data_F.Visible = false
					Crates_Display_F.Visible = true
					context.Exit_B.Visible = true
				end)

				task.wait(0.25)
				Debounce_C = false
			end
		end))
	end

	for i = 1, #Crates do
		--// setup crate
		local Crates_Info = Crates[i]
		if(Crates_Display_F.Crate_Tab_TMP:FindFirstChild(Crates_Info["Name"]) == nil) then

			--// Crate Tabs
			local tmp = Crates_Display_F.Crate_Tab_TMP:Clone()
			tmp.Name = Crates_Info["Name"]
			tmp.Crate_Name_F.Crate_Name_Txt.Text = string.upper(Crates_Info["Name"])
			tmp.Price_F.Gems_F.Data_Txt.Text = Utils.Format_Number(Crates_Info["PriceGems"])			
			tmp.BackgroundColor3 = Crates_Info["Color_BG"]
			tmp.UIStroke.Color = Crates_Info["Color_BG"]
			tmp.Position = UDim2.new(x,0,y,0)
			tmp.Parent = Crates_Display_F.Tabs_F
			tmp.Visible = true
			x += 0.315
			if x >= 0.8 then
				x = 0.165
				y += 0.535
			end


			local Shorts={}
			local Gloves={}
			local ShortCount=0
			local GloveCount=0
			local function SplitShortAndGloves(dict)
				for k,item in pairs(dict) do
					local itemData =	ClothsFolder:FindFirstChild(item.Name, true)
					if itemData.Parent.Name=="Gloves_F" then
						GloveCount+=1
						table.insert(Gloves, item)
					else
						ShortCount+=1
						table.insert(Shorts, item)
					end
				end
			end
			SplitShortAndGloves(Crates_Info.Items)

			local function getLastN(list, n)
				local total = #list
				local result = {}
				local startIndex = math.max(1, total - n + 1)

				for i = startIndex, total do
					table.insert(result, list[i])
				end

				return result
			end
			local function ReplaceGloves(gloveItems)
				local glovesParent = tmp.VF_Glove.WM.Model

				for slotIndex, itemData in ipairs(gloveItems) do
					local gloveTempModel = glovesParent:FindFirstChild(slotIndex .. "_Glove")
					if not gloveTempModel then
						warn("Glove placeholder not found for slot:", slotIndex)
						continue
					end

					local template = ClothsFolder:FindFirstChild(itemData.Name, true)
					if not template then
						warn("Glove template not found for item:", itemData.Name)
						continue
					end

					local newGloveModel = template:Clone()

					local leftHand = newGloveModel:FindFirstChild("LeftHand")
					if leftHand then
						leftHand:Destroy()
					end

					local pivot = gloveTempModel:GetPivot()
					newGloveModel.Parent = glovesParent
					newGloveModel:PivotTo(pivot)

					if newGloveModel:FindFirstChild("RightHand") and gloveTempModel:FindFirstChild("RightHand") then
						newGloveModel.RightHand.CFrame = gloveTempModel.RightHand.CFrame
					end

					gloveTempModel:Destroy()
				end

				tmp.VF_Glove.Visible = true
			end
			local function ReplaceShorts(shortItems)
				local shortsParent = tmp.VF_Short.WM.Model

				for slotIndex, itemData in ipairs(shortItems) do
					local shortTempModel = shortsParent:FindFirstChild(slotIndex .. "_Short")
					if not shortTempModel then
						warn("Short placeholder not found for slot:", slotIndex)
						continue
					end

					local template = ClothsFolder:FindFirstChild(itemData.Name, true)
					if not template then
						warn("Short template not found for item:", itemData.Name)
						continue
					end

					local newShortModel = template:Clone()
					newShortModel.PrimaryPart=nil
					local pivot = shortTempModel:GetPivot()
					newShortModel.Parent = shortsParent
					newShortModel:PivotTo(pivot)
					newShortModel.LeftUpperLeg.CFrame = shortTempModel.LeftUpperLeg.CFrame
					newShortModel.LowerTorso.CFrame = shortTempModel.LowerTorso.CFrame
					newShortModel.RightUpperLeg.CFrame = shortTempModel.RightUpperLeg.CFrame

					shortTempModel:Destroy()
				end

				tmp.VF_Short.Visible = true
			end
			local isGloves = GloveCount >= ShortCount
			if isGloves and GloveCount < 3 and ShortCount >= 2 then
				isGloves = false
			end

			if isGloves then
				ReplaceGloves(getLastN(Gloves, 3))
			else
				ReplaceShorts(getLastN(Shorts, 2))
			end

			--// Crate Functions Clicking etc..
			Tab_Handle(tmp, Crates_Info)
		end
	end

	table.insert(Crate_Cons, Crates_Display_F:GetPropertyChangedSignal("Visible"):Connect(function()
		if(Crates_Display_F.Visible == false and Crate_Data_F.Visible == false)then
			Core_Utils.Disconnect_Cons(Crate_Cons)
			Crate_Data_F.Visible = false
			Item_Preview_F.Visible = false
		end
	end))
end

local function Exchange_Handle(context)
	local mainFrame = context.Exchange_F

	local Cash_V = PD:WaitForChild("Coins")
	local Gems_V = PD:WaitForChild("Gems")
	local Data_Box_F = mainFrame:WaitForChild("Data_Box_F")

	local Input = Data_Box_F:WaitForChild("CashInput")
	local Result = Data_Box_F:WaitForChild("ResultLabel")
	local Confirm = Data_Box_F:WaitForChild("ConfirmButton")

	local convertion_settings = Monetization_Mod.Get_Conversion_Settings()
	local RATE = convertion_settings.RATE
	local FEE = convertion_settings.FEE
	local MIN_CASH = 1 / RATE

	-- Helper: animate message display (fade-in only)
	local function showMessage(text)
		Result.Text = text
		Result.TextTransparency = 1
		local fadeIn = TS:Create(Result, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextTransparency = 0})
		fadeIn:Play()
	end

	-- Helper to toggle confirm state
	local function setConfirmEnabled(state)
		Confirm.Active = state
		Confirm.AutoButtonColor = state
		Confirm.BackgroundTransparency = state and 0 or 0.5
	end

	setConfirmEnabled(false)

	local function validateInput()
		local text = Input.Text
		if text == "" then
			Result.Text = ""
			setConfirmEnabled(false)
			return nil
		end

		local amount = tonumber(text)
		if not amount or amount < MIN_CASH then
			showMessage("Minimum " .. tostring(MIN_CASH) .. " cash required.")
			setConfirmEnabled(false)
			return nil
		end

		local gemsRaw = amount / MIN_CASH
		local gems = math.floor(gemsRaw * (1 - FEE))
		if amount >= MIN_CASH and gems < 1 then
			gems = 1
		end

		if gems < 1 then
			showMessage("Not enough for 1 gem.")
			setConfirmEnabled(false)
			return nil
		end

		Result.Text = string.format("You will receive: %d 💎 (%.0f%% fee)", gems, FEE * 100)
		setConfirmEnabled(true)
		return amount
	end

	-- Live validation
	Input:GetPropertyChangedSignal("Text"):Connect(validateInput)

	Confirm.MouseButton1Click:Connect(function()
		local amount = validateInput()
		if not amount then return end

		if Cash_V.Value < amount then
			showMessage("Not enough cash.")
			return
		end

		-- Fire to server
		Convert_Cash_To_Gems:FireServer(amount)

		showMessage("⏳ Processing...")
		Input.Text = ""
		setConfirmEnabled(false)
	end)

	Convert_Feedback.OnClientEvent:Connect(function(newCash, newGems)
		context.TriggerTransactionEffects()
		local message = string.format("✅ You received %d 💎!", newGems)
		showMessage(message)
	end)

	mainFrame.Visible = true
end

local function Emotes_Handle()
	-- TODO when emotes will be sold
end

local function SpecialPunch_Handle()
	-- TODO when special punches will be sold
end

local function Fill_Cloth_Display(context, IsGlove,panel)
	panel.Tabs_F:ClearAllChildren()

	local function Show_Item_Preview(context, itemKey, itemName, isGlove, price, callback)
		local previewFrame = context.Item_Preview_F

		local buyButton = previewFrame.Main_Data_F.Buy_B
		local Rare_F = previewFrame.Main_Data_F.Rare_F
		Rare_F.Visible = false
		local viewport = previewFrame.Main_Data_F.VF
		local wm = viewport:WaitForChild("WM")

		-- Cleanup
		wm:ClearAllChildren()
		local oldCam = viewport:FindFirstChildOfClass("Camera")
		if oldCam then oldCam:Destroy() end

		-- Disconnect any previous connection for this button
		if BuyConnections[buyButton] then
			BuyConnections[buyButton]:Disconnect()
			BuyConnections[buyButton] = nil
		end

		local itemModel = ClothsFolder:FindFirstChild(itemName, true)
		if not itemModel then
			warn("Item model not found:", itemName)
			return
		end

		local display = itemModel:Clone()
		display.Parent = wm

		-- Create camera
		local cam = Instance.new("Camera")
		cam.Parent = viewport
		viewport.CurrentCamera = cam

		-- Orientation and camera distance aligned with Crates_Handle
		if display:FindFirstChild("LeftHand") then
			-- Gloves
			for _, part in pairs(display:GetChildren()) do
				if part:IsA("BasePart") and (part.Name == "LeftHand" or part.Name == "RightHand") then
					local groupName = part.Name .. "M"
					local group = display:FindFirstChild(groupName) or Instance.new("Model")
					group.Name = groupName
					group.Parent = display
					part.Parent = group
					part.Anchored = true
				end
			end

			if display:FindFirstChild("LeftHandM") and display:FindFirstChild("RightHandM") then
				display:PivotTo(CFrame.new(0, 0, 0))

				local OFFSET = 0.5

				display.LeftHandM:PivotTo(CFrame.new(-OFFSET, 0, 0))
				display.RightHandM:PivotTo(CFrame.new( OFFSET, 0, 0))

				Utils.SetupRotation(display.LeftHandM, 3)
				Utils.SetupRotation(display.RightHandM, -3)
			end

			cam.CFrame = CFrame.new(0, -0.15, 1.6)

			---- Shorts
		elseif display:FindFirstChild("LowerTorso") then	
			local torso = display:FindFirstChild("LowerTorso")
			if torso then
				display.PrimaryPart = torso
				display.PrimaryPart.PivotOffset = CFrame.new(0, 0, 0)
			else
				warn("[Shop Preview] LowerTorso not found for:", display.Name)
			end
			display.Parent = previewFrame.Main_Data_F.VF.WM
			previewFrame.Main_Data_F.VF.WM:PivotTo(CFrame.new(0,0,0)) 
			display:PivotTo(CFrame.new(0,0,0))
			previewFrame.Main_Data_F.VF.CurrentCamera = cam
			cam.Parent = previewFrame.Main_Data_F.VF
			cam.CFrame = CFrame.new(0, -0.5, 2)
		end

		viewport.LightColor = Color3.fromRGB(255, 255, 240)
		viewport.Ambient = Color3.fromRGB(200, 200, 200)

		-- Name & price
		previewFrame.Main_Data_F.Item_Name_Txt.Text = string.upper(itemName)
		buyButton.buy_label.Text = string.format("BUY FOR %d 💎", price)
		buyButton.Visible = true

		BuyConnections[buyButton] = buyButton.MouseButton1Click:Connect(function()
			Purchase_Cloth_Item:FireServer(isGlove, itemKey)
			if callback then callback() end
			previewFrame.Visible = false
		end)

		local function Close_Preview()
			previewFrame:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true)
			previewFrame.Visible = false
		end

		MenuButtons_Mod.Setup_Exit_X_Button(context.Cons, previewFrame.Main_Data_F.Exit_B, Close_Preview)
		previewFrame.Background_Select.MouseButton1Click:Connect(function()
			Close_Preview()
		end)

		previewFrame.Visible = true
		previewFrame:TweenSize(UDim2.new(1, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true)
	end

	local DataTable ={}

	if IsGlove then
		DataTable = Clothing_Mod.Get_All_Gloves_Data()
	else
		DataTable = Clothing_Mod.Get_All_Shorts_Data()
	end


	local sortedKeys = {}
	for key, _ in pairs(DataTable) do
		table.insert(sortedKeys, key)
	end

	table.sort(sortedKeys, function(a, b)
		local priceA = Offers_Config.GetClothDataByKey(a, IsGlove)["Gems"] or 0
		local priceB = Offers_Config.GetClothDataByKey(b, IsGlove)["Gems"] or 0
		return priceA > priceB
	end)

	local t_X, t_Y = 0.125, 0.25
	local Def_S = UDim2.new(0.22, 0, 0.475, 0)
	local Hover_S = UDim2.new(0.24, 0, 0.48875, 0)
	local Click_S = UDim2.new(0.15, 0, 0.31875, 0)

	for _, Key in ipairs(sortedKeys) do
		local item = DataTable[Key]
		if item then
			local offerPriceData = Offers_Config.GetClothDataByKey(Key, IsGlove)
			local Color = Clothing_Mod.Get_Rarity_Color(offerPriceData.Rarity)

			local tmp_Item = panel.Item_Tab_TMP:Clone()
			tmp_Item.Name = item
			tmp_Item.Item_Name_F.Item_Name_Txt.Text = string.upper(item)
			tmp_Item.Position = UDim2.new(t_X, 0, t_Y, 0)
			tmp_Item.UIStroke.Color = Color
			tmp_Item.Price_F.Gems_F.Data_Txt.Text = offerPriceData["Gems"]
			tmp_Item.Parent = panel.Tabs_F
			tmp_Item.Owned.Visible = IsGlove and Clothing_Mod.Player_Owns_Gloves_Key(Plr, Key)
				or Clothing_Mod.Player_Owns_Shorts_Key(Plr, Key)
			tmp_Item.Visible = true

			--// VF
			local display = ClothsFolder:FindFirstChild(item, true):Clone()
			local Viewport_Camera = Instance.new("Camera")

			if (display:FindFirstChild("LeftHand")) and (display:FindFirstChild("RightHand")) then
				-- Wrap hands into small models for independent rotation
				local leftModel = Instance.new("Model")
				leftModel.Name = "LeftHandM"
				display.LeftHand.Parent = leftModel
				leftModel.Parent = display

				local rightModel = Instance.new("Model")
				rightModel.Name = "RightHandM"
				display.RightHand.Parent = rightModel
				rightModel.Parent = display

				-- Ensure WM exists
				if not tmp_Item.VF:FindFirstChild("WM") then
					local wm = Instance.new("WorldModel")
					wm.Name = "WM"
					wm.Parent = tmp_Item.VF
				end

				-- Scale down both hands globally 
				display:ScaleTo(0.85)

				-- Center both models in front of the camera
				Utils.AlignGloves(leftModel, rightModel)

				-- Attach to WorldModel
				display.Parent = tmp_Item.VF.WM

				-- Camera
				local Viewport_Camera = Instance.new("Camera")
				Viewport_Camera.CFrame = CFrame.new(0, 0, 2)
				Viewport_Camera.Parent = tmp_Item.VF
				tmp_Item.VF.CurrentCamera = Viewport_Camera

				-- Enhanced lighting simulation
				tmp_Item.VF.LightColor = Color3.fromRGB(255, 255, 235)  -- light warmer tone
				tmp_Item.VF.Ambient = Color3.fromRGB(200, 200, 200)      -- overall ambient brightness
				tmp_Item.VF.ImageColor3 = Color3.new(1, 1, 1)            -- no dimming
				tmp_Item.VF.ImageTransparency = 0    

				Utils.SetupHoverRotation(tmp_Item, leftModel, 3)
				Utils.SetupHoverRotation(tmp_Item, rightModel, -3)

			elseif (display:FindFirstChild("LowerTorso")) then
				local torso = display:FindFirstChild("LowerTorso")
				if torso then
					display.PrimaryPart = torso
					display.PrimaryPart.PivotOffset = CFrame.new(0, 0, 0)
				else
					warn("[Shop Preview] LowerTorso not found for:", display.Name)
				end
				display:PivotTo(CFrame.new(0,0,0))
				tmp_Item.VF.CurrentCamera = Viewport_Camera
				display.Parent = tmp_Item.VF.WM
				tmp_Item.VF.WM:PivotTo(CFrame.new(0,0,0)) 
				Viewport_Camera.Parent = tmp_Item.VF
				Viewport_Camera.CFrame = CFrame.new(0, 0, 2)
			end

			t_X += 0.25

			if t_X >= 0.9 then
				t_X = 0.125
				t_Y += 0.525
			end
			table.insert(context.Cons, tmp_Item.MouseEnter:Connect(function()
				if(Debounce_E == false and panel.Visible == true)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")

					tmp_Item:TweenSize(Hover_S, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					Debounce_E = false
				end
			end))

			table.insert(context.Cons, tmp_Item.MouseLeave:Connect(function()
				if(panel.Visible == true)then
					tmp_Item:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
				end
			end))

			table.insert(context.Cons, tmp_Item.Selected.MouseButton1Click:Connect(function()
				if not Debounce_C and panel.Visible then
					Debounce_C = true

					local alreadyOwned = IsGlove
						and Clothing_Mod.Player_Owns_Gloves_Key(Plr, Key)
						or Clothing_Mod.Player_Owns_Shorts_Key(Plr, Key)

					if alreadyOwned then
						SE_Mod.PlaySFX(Plr, "Hover_SE")
						Debounce_C = false
						return -- stop here (no purchase)
					end

					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(tmp_Item, Tween_Click, {Size = Click_S}):Play()

					local itemName = DataTable[Key]
					Show_Item_Preview(context, Key, itemName, IsGlove, offerPriceData["Gems"], function()
						task.delay(0.3, function()
							local ownsNow = IsGlove
								and Clothing_Mod.Player_Owns_Gloves_Key(Plr, Key)
								or Clothing_Mod.Player_Owns_Shorts_Key(Plr, Key)
							if ownsNow and tmp_Item:FindFirstChild("Owned") then
								tmp_Item.Owned.Visible = true
							end
						end)
					end)

					task.wait(0.25)
					Debounce_C = false
				end
			end))

		end
	end
	panel.Visible=true
end

--------------------------------------------------------------------
-- ✅ EXPORT HANDLERS (required by Client_Shop_Handle)
--------------------------------------------------------------------

-- Currency
Core_Frame_Handlers.Cash = { Handle = Cash_Handle }
Core_Frame_Handlers.Gems = { Handle = Gems_Handle }
Core_Frame_Handlers.Exchange = { Handle = Exchange_Handle }

-- Gamepasses
Core_Frame_Handlers.Passes = { Handle = Gamepasses_Handle }

-- UGC / Merch
Core_Frame_Handlers.Merch = { Handle = Merch_Handle }

-- Crates
Core_Frame_Handlers.Crates = { Handle = Crates_Handle }

-- Shorts / Gloves (clothing)
Core_Frame_Handlers.Shorts = {
	Handle = function(ctx)
		-- false → Shorts
		ctx.Item_Preview_F = ctx.Item_Preview_F 
		Fill_Cloth_Display(ctx, false, ctx.Shorts_Display_F)
	end
}

Core_Frame_Handlers.Gloves = {
	Handle = function(ctx)
		-- true → Gloves
		ctx.Item_Preview_F = ctx.Item_Preview_F 
		Fill_Cloth_Display(ctx, true, ctx.Gloves_Display_F)
	end
}

return Core_Frame_Handlers]]></ProtectedString>
								<string name="ScriptGuid">{74E84413-258F-49F2-B0A2-0705433B85C3}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Core_Frame_Handlers.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX79DEE25AA626421AAA01F63EABC1A5F7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">System</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX440DE98E86764EFF8224ACEE5B07080C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterGui/System/Check_Screen_Orientation.lua
--
--  Description:
--      Prevents to play the game in portrait mode
--
--  Author(s): Exclusible, Darkzeb
--
--  Last Modified: 2025-10-30 by Darkzeb
--
--  Version: V2025-
--
--======================================================================

local StarterGui 		= game:GetService("StarterGui")
local Players 			= game:GetService("Players")
local RunService 		= game:GetService("RunService")
local UserInputService 	= game:GetService("UserInputService")
local camera 			= workspace.CurrentCamera
local player 			= Players.LocalPlayer
local playerGui 		= player:WaitForChild("PlayerGui")

StarterGui.ScreenOrientation = Enum.ScreenOrientation.LandscapeLeft

-- Main ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "OrientationWarning"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

-- Blocker (invisible button to block all interactions)
local blocker = Instance.new("TextButton")
blocker.Size = UDim2.new(1, 0, 1, 0)
blocker.BackgroundTransparency = 1
blocker.Text = ""
blocker.Visible = false
blocker.Modal = true -- 🚫 empêche toute autre interaction
blocker.Parent = screenGui

-- Background overlay
local frame = Instance.new("Frame")
frame.Size = UDim2.new(1, 0, 1, 0)
frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
frame.BackgroundTransparency = 0.5
frame.Visible = false
frame.Parent = blocker -- ⚠️ mettre dans blocker pour bloquer en même temps

-- Center container
local container = Instance.new("Frame")
container.AnchorPoint = Vector2.new(0.5, 0.5)
container.Position = UDim2.new(0.5, 0, 0.5, 0)
container.Size = UDim2.new(0.8, 0, 0.4, 0)
container.BackgroundTransparency = 1
container.Parent = frame

-- Icon
local icon = Instance.new("ImageLabel")
icon.AnchorPoint = Vector2.new(0.5, 0.5)
icon.Position = UDim2.new(0.5, 0, 0.3, 0)
icon.Size = UDim2.new(0.2, 0, 0.4, 0)
icon.BackgroundTransparency = 1
icon.Image = "rbxassetid://6035047409"
icon.ImageColor3 = Color3.fromRGB(255, 255, 255)
icon.Parent = container

-- Text
local textLabel = Instance.new("TextLabel")
textLabel.AnchorPoint = Vector2.new(0.5, 0)
textLabel.Position = UDim2.new(0.5, 0, 0.65, 0)
textLabel.Size = UDim2.new(1, 0, 0.3, 0)
textLabel.BackgroundTransparency = 1
textLabel.Text = "Please rotate your device to landscape 📱↔️"
textLabel.TextScaled = true
textLabel.Font = Enum.Font.GothamBold
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
textLabel.Parent = container

-- Function to check orientation
local function checkOrientation()
	local size = camera.ViewportSize
	local isPortrait = size.X < size.Y

	-- sécuriser l'accès aux UI si elles existent
	local offerUI = playerGui:FindFirstChild("Shop"):FindFirstChild("Offer_UI")
	local dailyRewardUI = playerGui:FindFirstChild("Menus"):FindFirstChild("Daily_Rewards_UI")

	if RunService:IsStudio() then
		blocker.Visible = isPortrait
		frame.Visible = isPortrait
	else
		if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled then
			blocker.Visible = isPortrait
			frame.Visible = isPortrait
		else
			blocker.Visible = false
			frame.Visible = false
		end
	end

	-- forcer le blocage/désactivation des popups
	if offerUI then
		offerUI.Enabled = not isPortrait
	end
	if dailyRewardUI then
		dailyRewardUI.Enabled = not isPortrait
	end
end


-- Initial check
task.wait(1)
checkOrientation()

-- Update on screen resize/orientation change
camera:GetPropertyChangedSignal("ViewportSize"):Connect(checkOrientation)]]></ProtectedString>
						<string name="ScriptGuid">{3743C44B-136B-4EE1-91E2-9F47FE47EE7A}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Check_Screen_Orientation.client.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXAEA0151204734705A2EC2A0DA4C81346">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Hole_Transition_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXBB4DAB23CDEE49EBBE514544009A32B3">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")

-- Modules
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Transition_Hole_UI = Channels.Bindable_Events.Transition_Hole_UI
local Transition_Fade_UI = Channels.Bindable_Events.Transition_Fade_UI
local Transition_Hole    = Channels.SC_Remote_Events.Transition_Hole
local Transition_Fade    = Channels.SC_Remote_Events.Transition_Fade

local Main_F = script.Parent.Main
local Fade_F =  script.Parent.Fade_F
local Debounce_Effect = false


local function Set_Color(BG_Col)
	Main_F.ImageColor3 = BG_Col
	local Tabs = Main_F:GetChildren()
	for i = 1, #Tabs do
		if(Tabs[i]:IsA("Frame"))then
			Tabs[i].BackgroundColor3 = BG_Col
		end
	end
end

local function Apply_Effect()
	Main_F.Visible = false
	Main_F.Size = UDim2.new(3, 0, 3, 0)
	Main_F.Visible = true
	Main_F:TweenSize(UDim2.new(0.0125, 0, 0.3, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quart, 0.375, true, nil)
	task.wait(0.5)
	Main_F:TweenSize(UDim2.new(3, 0, 3, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quad, 0.375, true, nil)
	task.wait(0.375)
	Main_F.Visible = false
	Main_F.Size = UDim2.new(3, 0, 3, 0)
end

Transition_Hole.OnClientEvent:Connect(function(BG_Col)
	if(Debounce_Effect == false)then
		Debounce_Effect = true
		Set_Color(BG_Col)
		Apply_Effect()
		Debounce_Effect = false
	end
end)

Transition_Hole_UI.Event:Connect(function(BG_Col)
	if(Debounce_Effect == false)then
		Debounce_Effect = true
		Set_Color(BG_Col)
		Apply_Effect()
		Debounce_Effect = false
	end
end)

local function Launch_Transition_Fade(Tween_Time, Delay_Time)
	local Tween_I = TweenInfo.new(Tween_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
	Fade_F.Visible = false
	Fade_F.BackgroundTransparency = 1
	Fade_F.Visible = true
	TS:Create(Fade_F, Tween_I, {BackgroundTransparency = 0}):Play()
	task.wait(Delay_Time)
	TS:Create(Fade_F, Tween_I, {BackgroundTransparency = 1}):Play()
	task.wait(Tween_Time)
	Fade_F.Visible = false
end

Transition_Fade.OnClientEvent:Connect(function(Tween_Time, Delay_Time)
	Launch_Transition_Fade(Tween_Time, Delay_Time)
end)

Transition_Fade_UI.Event:Connect(function(Tween_Time, Delay_Time)
	Launch_Transition_Fade(Tween_Time, Delay_Time)
end)
]]></ProtectedString>
							<string name="ScriptGuid">{8FFC3B65-AC3A-4A23-A924-EC12A5843749}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Hole_Transition_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX784E98A3D9E445A7B0E2A7E9DF6D8062">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Sound_Effects_F</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXFC71C1A3F6D24FB4A68A306845A75BE5">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Sound_Effects_V = PD:WaitForChild("Sound Effects")
local Channels 	= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_BG_Volume = Channels.Bindable_Events.Toggle_BG_Volume

local Sound_Groups_F = game.ReplicatedStorage:WaitForChild("Audio"):WaitForChild("Sound_Groups")
local Sound_Effect_Group = Sound_Groups_F:WaitForChild("Sound_Effects")
local Missed_Hit_SE_Group = Sound_Groups_F:WaitForChild("Missed_Hit_Sound_Effects")
local BG_SE_Group = Sound_Groups_F:WaitForChild("BG_Sound")
local BG_V = PD:WaitForChild("Background Music")

local function Update_Sound_Group()
	if(Sound_Effects_V ~= nil and Sound_Effects_V.Value == true)then
		Sound_Effect_Group.Volume = 1
		Missed_Hit_SE_Group.Volume = 2
	else
		Sound_Effect_Group.Volume = 0
		Missed_Hit_SE_Group.Volume = 0
	end
end
Update_Sound_Group()

Sound_Effects_V.Changed:Connect(function()
	Update_Sound_Group()
end)


local function Update_BG_Sound_Group()
	if(BG_V ~= nil and BG_V.Value == true)then
		BG_SE_Group.Volume = 0.5
	else
		BG_SE_Group.Volume = 0
	end
end
Update_BG_Sound_Group()

BG_V.Changed:Connect(function()
	Update_BG_Sound_Group()
end)

Toggle_BG_Volume.Event:Connect(function(Toggle_On)
	if(Toggle_On and BG_V ~= nil and BG_V.Value == true)then
		BG_SE_Group.Volume = 0.5
	else
		BG_SE_Group.Volume = 0
	end
end)

]]></ProtectedString>
							<string name="ScriptGuid">{36629E55-AAD1-4C3B-8E95-1D826FCAC479}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Sound_Effect_Settings_Toggle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX41BD3609F2F44E3ABAA9291A7ED1A345">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Settings_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX624AF1F05D5B4A9EAC178299B94AE9E4">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")

local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 	= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Settings 		= Channels.Bindable_Events.Open_Settings
local Close_Settings_E 		= Channels.Bindable_Events.Close_Settings
local Save_Settings_E		= Channels.CS_Remote_Events.Save_Settings

-- UI References
local Main_F = script.Parent.Main_F
local Data_F = Main_F.Data_F
local Exit_B = Main_F.Header.Exit_B
local Main_Data_F = Data_F.Main_Data_F

local Debounce_C = false
local Debounce_E = false
local Debounce_UI = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Get_Server_Settings_Data()
	local Tabs = Main_Data_F:GetChildren()
	local Data = {}

	local function Get_Data_From_Key(Key)
		local V = PD:FindFirstChild(Key)
		if(V ~= nil)then
			return V.Value
		end
		return false
	end

	for i = 1, #Tabs do
		local T = Tabs[i]
		if(T ~= nil)then
			local Key = T.Name
			Data[Key] = Get_Data_From_Key(Key)
		end
	end

	return Data
end

local function Get_Client_Settings_Data()
	local Tabs = Main_Data_F:GetChildren()
	local Data = {}

	local function Get_Data_From_Tab(T)
		local Toggle_F = T:FindFirstChild("Toggle_F")
		if(Toggle_F ~= nil and Toggle_F.BackgroundColor3 == Color3.fromRGB(35, 244, 68))then
			return true
		end
		return false
	end

	for i = 1, #Tabs do
		local T = Tabs[i]
		if(T ~= nil)then
			Data[T.Name] = Get_Data_From_Tab(T)
		end
	end

	return Data
end

local function Save_Settings()
	local newSettings = Get_Client_Settings_Data()
	Save_Settings_E:FireServer(newSettings)
	local SFX_Enabled  = newSettings["Sound Effects"]
	local Music_Enabled  = newSettings["Background Music"]
	
	game.SoundService:SetAttribute("SFX_Enabled", SFX_Enabled)
	game.SoundService:SetAttribute("Music_Enabled", Music_Enabled)
	
	local hum = Plr.Character:WaitForChild("Humanoid")
	if hum then
		hum:SetAttribute("DisableSounds", not SFX_Enabled)
		hum:SetAttribute("DisableFootstepSounds", not SFX_Enabled)
	end
end

local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	Main_Data_F.CanvasPosition = Vector2.new(0, 0)

	task.spawn(function()
		Save_Settings()
	end)

	task.wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Settings_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Toggle_Side_Buttons:Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Display_UI()

	local function Reset_Display()
		Disconnect_Cons()
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.575, 0)
		Main_Data_F.CanvasPosition = Vector2.new(0, 0)

		local Stats_Blurr = game.Lighting:FindFirstChild("Settings_Blurr")
		if(Stats_Blurr ~= nil)then
			Stats_Blurr:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()

	local function Set_Up_Data_Tabs()
		local Tabs = Main_Data_F:GetChildren()
		local Settings_Data = Get_Server_Settings_Data()

		local function Tab_Handle(T)
			local Key = T.Name
			local Key_Txt = T:FindFirstChild("Settings_Key_Txt")
			local Toggle_F = T:FindFirstChild("Toggle_F")
			local Bar_F = Toggle_F:FindFirstChild("Bar_F")
			local Selected = Toggle_F:FindFirstChild("Selected")

			local function Update_Toggle_Display(Is_Enabled)
				if(Is_Enabled)then
					Toggle_F.BackgroundColor3 = Color3.fromRGB(35, 244, 68)
					Bar_F:TweenPosition(UDim2.new(0.775, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
				else
					Toggle_F.BackgroundColor3 = Color3.new(1, 0, 0)
					Bar_F:TweenPosition(UDim2.new(0.225, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
				end
			end
			Update_Toggle_Display(Settings_Data[Key])
			Key_Txt.TextColor3 = Color3.new(1, 1, 1)

			table.insert(Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")

					Key_Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					Debounce_E = false
				end
			end))

			table.insert(Cons, Selected.MouseLeave:Connect(function()
				Key_Txt.TextColor3 = Color3.new(1, 1, 1)
			end))	

			table.insert(Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")

					local Current_V = (Toggle_F.BackgroundColor3 == Color3.fromRGB(35, 244, 68))
					Update_Toggle_Display(not Current_V)

					Save_Settings()

					task.wait(0.375)
					Debounce_C = false
				end
			end))
		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil)then
				Tab_Handle(T)
			end
		end
	end
	Set_Up_Data_Tabs()

	MenuButtons_Mod.Setup_Exit_X_Button({}, Exit_B, function()
		Close_Settings_E:Fire()
		Remove_UI()
	end)

	local function Display_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Settings_Blurr"

		Toggle_Side_Buttons:Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

Open_Settings.Event:Connect(function(value)
	if(Debounce_UI == false and value == true)then
		Display_UI()
	elseif ( Debounce_UI == true and value == false) then
		Remove_UI()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{E62F0410-7328-488B-8B05-584FA5C7F49D}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Settings_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXF23931901D3D475BB072142A0815FE8A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Elo_Limit_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX0C0DB195F6144EDF972C1BE14835C04A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Elo_Rank_Dif 			= Channels.SC_Remote_Events.Elo_Rank_Dif

-- UI references
local Main_F = script.Parent.Main_F
local Main_Tab_F = Main_F.Main_Tab_F
local Rank_Data_F = Main_Tab_F.Rank_Data_F
local Your_Elo_F = Rank_Data_F.Your_Elo_F
local Your_Elo_Img = Your_Elo_F.Elo_Img
local Other_Elo_F = Rank_Data_F.Current_Elo_F
local Other_Elo_Img = Other_Elo_F.Elo_Img

local Debounce_UI = false

local Player_Thumbnail_Data = {

}
local function Get_Player_Thumbnail(ID)
	if(Player_Thumbnail_Data[ID] ~= nil)then
		return Player_Thumbnail_Data[ID]
	else
		local Type = Enum.ThumbnailType.HeadShot
		local Size = Enum.ThumbnailSize.Size420x420

		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				Data = game.Players:GetUserThumbnailAsync(ID, Type, Size)
			end)

			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end

		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				Player_Thumbnail_Data[ID] = D
				return D
			end
		end

		return "rbxassetid://100127687172105"
	end
end

local function Special_Txt(T, C)
	local RGB_Txt = string.format("rgb(%d, %d, %d)", C.R * 255, C.G * 255, C.B * 255)
	return [[<font color="]] .. RGB_Txt .. [[">]] .. T .. [[</font>]]
end

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

local function Display_Effects(Other_Plr)
	Debounce_UI = true

	SE_Mod.PlaySFX(Plr, "Elo_Error_SE")
	
	local function Reset_Display()
		Main_F.Visible = false
		Main_F.BackgroundTransparency = 1
		Main_Tab_F.Position = UDim2.new(0.5, 0, -0.25, 0)
		Main_F.Visible = true
	end
	Reset_Display()
	
	if(Other_Plr ~= nil)then
		local function Update_Elo_Difference_Display()
			local Your_Elo_Data, Your_Elo_Val = Elo_Mod.Get_Player_Rank_Data(Plr)
			local Other_Elo_Data, Other_Elo_Val = Elo_Mod.Get_Player_Rank_Data(Other_Plr)
			
			local function Compile_Range_Txt(D)
				local Range_Min, Range_Max = D['Elo Range'].Min, D['Elo Range'].Max
				local Txt = Format_Number(Range_Min) .. " - inf"
				if(D['Index'] <= 5)then
					Txt = Format_Number(Range_Min) .. " - " .. Format_Number(Range_Max)
				end
				
				return Special_Txt(Txt, D['Color'])
			end
			Rank_Data_F:FindFirstChild("Elo_Range_Txt").Text = Compile_Range_Txt(Your_Elo_Data) .. " | " .. Compile_Range_Txt(Other_Elo_Data)
			Rank_Data_F:FindFirstChild("Your_Img").Image = Get_Player_Thumbnail(Plr.UserId)
			Rank_Data_F:FindFirstChild("Other_Img").Image = Get_Player_Thumbnail(Other_Plr.UserId)
			
			Your_Elo_Img.Image = Your_Elo_Data['Icon']
			Your_Elo_Img.ImageColor3 = Your_Elo_Data['Color']
			Your_Elo_F:FindFirstChild("Elo_Txt").Text = Format_Number(Your_Elo_Val) .. ""
			
			Other_Elo_Img.Image = Other_Elo_Data['Icon']
			Other_Elo_Img.ImageColor3 = Other_Elo_Data['Color']
			Other_Elo_F:FindFirstChild("Elo_Txt").Text = Format_Number(Other_Elo_Val) .. ""
			
			Rank_Data_F.Visible = true
		end
		Update_Elo_Difference_Display()
	else
		Rank_Data_F.Visible = false
	end
	
	local function Show_Effects()
		local Tween_Trans = TweenInfo.new(0.375, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
		TS:Create(Main_F, Tween_Trans, {BackgroundTransparency = 0.5}):Play()
		Main_Tab_F:TweenPosition(UDim2.new(0.5, 0, 0.475, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.5, true, nil)
		task.wait(0.5)
		Main_Tab_F:TweenPosition(UDim2.new(0.5, 0, 0.5125, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 2.5, true, nil)
		task.wait(2.5)	
		Main_Tab_F:TweenPosition(UDim2.new(0.5, 0, 1.1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.5, true, nil)
		task.wait(0.125)
		TS:Create(Main_F, Tween_Trans, {BackgroundTransparency = 1}):Play()
		task.wait(0.5)
	end
	Show_Effects()

	Reset_Display()
	
	Debounce_UI = false
end

Elo_Rank_Dif.OnClientEvent:Connect(function(Other_Plr)
	if(Debounce_UI == false)then
		Display_Effects(Other_Plr)
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{AA0D5C56-D6E2-4A74-B2A9-66E03BC810FF}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Elo_Limit_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX1C68B931842E46828087A94C1320A453">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Emotes_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX859755175DA44DD99ED0AB03E9866D83">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Selected_Emotes_V = PD:WaitForChild("Current Emotes")
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animations_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Emotes_Data = Animations_Mod.Get_Combinations("Emotes")

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Emote_Slot_Request = Channels.CS_Remote_Functions.Emote_Slot_Request
local Open_Emotes_UI 	 = Channels.Bindable_Events.Open_Emotes_UI
local Open_Emotes 		 = Channels.SC_Remote_Events.Open_Emotes

-- UI references
local Emotes_F = script.Parent.Main_F
local Backdrop_Effects_F = Emotes_F.Frame_Backdrops_F
local Edit_Emotes_F = Emotes_F.Edit_Emotes_F
local Emote_Select_F = Emotes_F.Emote_Select_F
local Emote_List_F = Emote_Select_F.Emote_List_F
local Tabs_F = Emote_List_F.Tabs_F
local TMP_Tab = Emote_List_F.TMP_Tab

local Debounce_E = false
local Debounce_C = false
local Debounce_T = false
local Debounce_UI = false

local Edit_Mode = false
local Selected_Slot

local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Remove_UI()
	Disconnect_Cons()
	Emotes_F:TweenPosition(UDim2.new(0.6575, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

	local Is_Fighting = Char:GetAttribute("Is_Fighting")
	if(Is_Fighting ~= nil and Is_Fighting == true)then
		UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
		UIS.MouseIconEnabled = false
	end

	task.wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Emotes_Blur")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	
	Emotes_F.Edit_Emotes_F:TweenSize(UDim2.new(0.173, 0, 0.297, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, false, nil)
	Emotes_F.Edit_Emotes_F.TextLabel.Text = "Edit Emotes"
	Emotes_F.Edit_Emotes_F.TextLabel.TextColor3 = Color3.fromRGB(255,255,255)
	Emotes_F.Visible = false
	Emotes_F.Position = UDim2.new(0.6575, 0, 0.675, 0)
	Emote_Select_F.Visible = false
	Emote_List_F.CanvasPosition = Vector2.new(0, 0)
	Tabs_F:ClearAllChildren()

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
	Debounce_T = false
	Edit_Mode = false
	Selected_Slot = nil
end
Remove_UI()

local function Show_UI()

	local function Reset_Backdrop_Imgs()
		local All_Backdrop_Tabs = Backdrop_Effects_F:GetChildren()
		for i = 1, #All_Backdrop_Tabs do
			local T = All_Backdrop_Tabs[i]
			if(T ~= nil and T:IsA("ImageLabel"))then
				T.ImageColor3 = Color3.new(1, 1, 1)
			end
		end
	end

	local function Reset_Display()
		Disconnect_Cons()
		Emotes_F.Edit_Emotes_F:TweenSize(UDim2.new(0.173, 0, 0.297, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, false, nil)
		Emotes_F.Edit_Emotes_F.TextLabel.Text = "Edit Emotes"
		Emotes_F.Edit_Emotes_F.TextLabel.TextColor3 = Color3.fromRGB(255,255,255)
		Emotes_F.Visible = false
		Emotes_F.Position = UDim2.new(0.6575, 0, 0.575, 0)
		Emote_Select_F.Visible = false
		Emote_List_F.CanvasPosition = Vector2.new(0, 0)
		Tabs_F:ClearAllChildren()
		Reset_Backdrop_Imgs()

		local Emotes_Blur = game.Lighting:FindFirstChild("Emotes_Blur")
		if(Emotes_Blur ~= nil)then
			Emotes_Blur:Destroy()
		end
	end
	Reset_Display()

	--// load all the emotes they have selected
	--//setup buttons when clicked play emote and close menu
	--// setup edit menu load all the emotes they own, and when clicked assign that emote to that selected slot edit menu >select slot > select emote > save
	local Emote_Slots = Emotes_F:GetChildren()
	local EmotesSelected = Selected_Emotes_V.Value:split(",")

	local function LoadEmotes()
		--// setup all the buttons binds
		--// clear old ones
		Emote_List_F.CanvasPosition = Vector2.new(0, 0)
		Tabs_F:ClearAllChildren()

		local X = 0.25
		local Y = 0.25
		for key, values in pairs(Emotes_Data) do
			if (Animations_Mod.Player_Owns_Emote_Key(Plr, key) == true or values["Price"] <= 0) then
				local tmp = Emote_List_F.TMP_Tab:Clone()
				tmp.Name = key
				tmp.Main_Txt.Text = values["Name"]
				tmp.Emote_Img.Image = values['Icon']
				tmp.Visible = true
				tmp.Position = UDim2.new(X,0,Y,0)
				tmp.Parent = Emote_List_F.Tabs_F
				
				--// setup when pressed change slot to new emote selected and send request to server for confirmation.
				table.insert(Cons, tmp.Selected.MouseButton1Click:Connect(function()
					if (Selected_Slot) then
						local Server_Response = Emote_Slot_Request:InvokeServer(Selected_Slot, key)
						if (Server_Response == true) then
							EmotesSelected[tonumber(Selected_Slot:match("%d+"))] = key
							Emotes_F[Selected_Slot].Emote_Name_Txt.Text = values["Name"]
							Emotes_F[Selected_Slot].Emote_Icon.Image = values["Icon"]
							Emote_Select_F.Visible = false
						else
							Emote_Select_F.Visible = false
						end
					end
				end))

				X += 0.48
				if X > 0.74 then
					X = 0.25
					Y += 0.54
				end
			end
		end

		Emote_Select_F.Visible = true
	end

	for i = 1, #Emote_Slots do
		local S = Emote_Slots[i]
		if(S ~= nil and S:IsA("Frame") and string.match(S.Name, "T") ~= nil)then
			--print(EmotesSelected)
			if (EmotesSelected[1] ~= "") then
				local ES_Selected = EmotesSelected[tonumber(S.Name:match("%d+"))]
				if (ES_Selected ~= nil and Emotes_Data[ES_Selected] ~= nil) then


					S.Emote_Name_Txt.Text = Emotes_Data[ES_Selected]["Name"]
					S.Emote_Icon.Image = Emotes_Data[EmotesSelected[tonumber(S.Name:match("%d+"))]]["Icon"]

					table.insert(Cons, S.Selected.MouseButton1Click:Connect(function() --// debounce and play anim 
						if(Debounce_T == false and Edit_Mode == false) then
							Debounce_T = true
							Animations_Mod.Reset_Character_Animations(Char)
							task.wait()
							Animations_Mod.Play_Emote_Track_From_Key(Plr, Hum, EmotesSelected[tonumber(S.Name:match("%d+"))], false)
							task.wait(.1)
							Debounce_T = false
							Reset_Display()
						elseif (Debounce_T == false and Edit_Mode == true) then
							if (Emote_Select_F.Visible == false) then
								Debounce_T = true
								Selected_Slot = S.Name
								LoadEmotes()
								task.wait(.1)
								Debounce_T = false
							elseif (Emote_Select_F.Visible == true) then
								Debounce_T = true
								Selected_Slot = nil
								Emote_Select_F.Visible = false
								task.wait(.1)
								Debounce_T = false
							end

						end	
					end))

				end
			end

		end
	end

	--LoadEmotes()

	table.insert(Cons, Emotes_F.Edit_Emotes_F.Selected.MouseButton1Click:Connect(function()
		if(Edit_Mode == false) then -- starting editing
			Edit_Mode = true
			Emotes_F.Edit_Emotes_F:TweenSize(UDim2.new(0.173, 0, 0.31, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, false, nil)
			Emotes_F.Edit_Emotes_F.TextLabel.Text = "Save"
			TS:Create(Emotes_F.Edit_Emotes_F.TextLabel, TweenInfo.new(.25, Enum.EasingStyle.Linear), {TextColor3 = Color3.fromRGB(52, 255, 29)}):Play()
		elseif (Edit_Mode == true) then -- check if anything was changed and save
			Edit_Mode = false
			Emotes_F.Edit_Emotes_F:TweenSize(UDim2.new(0.173, 0, 0.297, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, false, nil)
			Emotes_F.Edit_Emotes_F.TextLabel.Text = "Edit Emotes"
			TS:Create(Emotes_F.Edit_Emotes_F.TextLabel, TweenInfo.new(.25, Enum.EasingStyle.Linear), {TextColor3 = Color3.fromRGB(255, 255, 255)}):Play()
		end
	end))

	local function Display_UI()
		Emotes_F.Visible = true
		Emotes_F:TweenPosition(UDim2.new(0.6575, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Emotes_Blur"
		Blur.Enabled = false

		local Is_Fighting = Char:GetAttribute("Is_Fighting")
		if(Is_Fighting ~= nil and Is_Fighting == true)then
			UIS.MouseBehavior = Enum.MouseBehavior.Default
			UIS.MouseIconEnabled = true
		end

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

Open_Emotes_UI.Event:Connect(function()
	if(Debounce_UI == false)then
		Show_UI()
	else
		Remove_UI()
	end
end)

Open_Emotes.OnClientEvent:Connect(function()
	if(Debounce_UI == false)then
		Show_UI()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{3CEC4F01-DDEA-4CBE-BB65-620875234AF5}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Emotes_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXCA5EA34CDE164353888370BCA2A276A6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Changelog_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXE392CFB5FD33480D86AC7A1B9A733D77">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local Cam = workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 	= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Changelog		= Channels.Bindable_Events.Open_Changelog
local Close_Changelog		= Channels.Bindable_Events.Close_Changelog

-- UI references
local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local Debounce_UI = false

local gui = script.Parent
local frame = gui:WaitForChild("Main_F")

--------------------------------------------------------------------
-- Changelog Carousel
--------------------------------------------------------------------
local bodyFrame = frame:WaitForChild("Body")
local dataFrame = bodyFrame:WaitForChild("Data_F") 
local leftBtn = frame:WaitForChild("Left_B")
local rightBtn = frame:WaitForChild("Right_B")
local header = frame:WaitForChild("Header")
local versionLabel = header:WaitForChild("Title")
local Exit_B = header:WaitForChild("Exit_B")

local changelogData = require(RS:WaitForChild("Data_Mods_F"):WaitForChild("Changelog_Mod")) 

-- limiter à 5 versions max
local versions = {}
for i = 1, math.min(5, #changelogData) do
	table.insert(versions, changelogData[i])
end

local currentIndex = 1
local maxItems = 8

local function displayVersion(index)
	local data = versions[index]
	if not data then return end

	-- update header
	versionLabel.Text = data.version

	-- clear old lines
	for _, child in ipairs(dataFrame:GetChildren()) do
		if child:IsA("TextLabel") then
			child:Destroy()
		end
	end

	-- create up to 8 items
	for i, change in ipairs(data.changes) do
		if i > maxItems then break end
		local item = Instance.new("TextLabel")
		item.Size = UDim2.new(1, 0, 0.8, 0)
		item.BackgroundTransparency = 1
		item.TextXAlignment = Enum.TextXAlignment.Left
		item.Font = Enum.Font.Nunito
		item.TextSize = 44
		item.TextScaled = true
		item.TextColor3 = Color3.new(1, 1, 1)
		item.Text = change
		item.Parent = dataFrame
	end

	-- fix button visibility logic
	if #versions <= 1 then
		leftBtn.Visible = false
		rightBtn.Visible = false
	else
		-- LEFT = older, RIGHT = newer
		leftBtn.Visible = index < #versions
		rightBtn.Visible = index > 1
	end
end

local function goLeft()
	SE_Mod.PlaySFX(Plr, "Click_SE")
	currentIndex = currentIndex + 1
	if currentIndex > #versions then currentIndex = 1 end
	displayVersion(currentIndex)
end

local function goRight()
	SE_Mod.PlaySFX(Plr, "Click_SE")
	currentIndex = currentIndex - 1
	if currentIndex < 1 then currentIndex = #versions end
	displayVersion(currentIndex)
end

leftBtn.MouseButton1Click:Connect(goLeft)
rightBtn.MouseButton1Click:Connect(goRight)

--------------------------------------------------------------------
-- UI Animations
--------------------------------------------------------------------
local function Remove_UI()
	frame:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	task.wait(0.25)
	local Blur = game.Lighting:FindFirstChild("Rewards_Blurr")
	if Blur then Blur:Destroy() end
	Cam.FieldOfView = 70
	gui.Enabled = false
	frame.Position = UDim2.new(0.5, 0, 0.675, 0)
	Toggle_Side_Buttons:Fire(true, true)
	Debounce_UI = false

	-- warn topmenu
	Close_Changelog:Fire()
	
end

local function Display_UI()
	gui.Enabled = true
	frame.Position = UDim2.new(0.5, 0, 0.675, 0)
	frame.Visible = true
	frame:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
	local Blur = Instance.new("BlurEffect")
	Blur.Name = "Rewards_Blurr"
	Blur.Parent = game.Lighting
	Toggle_Side_Buttons:Fire(false, true)
	Debounce_UI = true

	-- afficher première version au lancement
	currentIndex = 1
	displayVersion(currentIndex)
end

MenuButtons_Mod.Setup_Exit_X_Button({}, Exit_B, Remove_UI)

Open_Changelog.Event:Connect(function()
	if not Debounce_UI then
		Display_UI()
	end
end)

Close_Changelog.Event:Connect(function()
	if Debounce_UI then
		Remove_UI()
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{5CDF2D3B-FA62-401A-8141-C4E54BC164B8}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Changelog_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX6C564A01E80F47E8BD2BC343B6FCF883">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Player_List_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA60E1BD8FB9F44D6AA349ED560BEF9DE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Is_Chatbox_Typing 	= Channels.Bindable_Functions.Is_Chatbox_Typing 
local Open_Stats 			= Channels.Bindable_Events.Open_Stats

local Toggle_Player_List 	= Channels.Bindable_Events.Toggle_Player_List
local Toggle_Side_Buttons   = Channels.Bindable_Events.Toggle_Side_Buttons

local Update_Player_List 	= Channels.SC_Remote_Events.Update_Player_List

-- UI References
local Main_F = script.Parent.Main_F
local List_F = Main_F.Data_F
local Tabs_F = List_F.Tabs_F
local TMP_Tab = List_F.TMP_Tab

local Debounce_E = false
local Debounce_C = false
local Debounce_UI = false

local function Core_List_Handle()
	
	local function Format_Number(n)
		n = tostring(n)
		return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
	end
	
	local function Get_Player_Data_Vals(Plr)
		local PD = Plr:WaitForChild("Player_Data")
		if(PD ~= nil)then
			return PD:WaitForChild("Elo"), PD:WaitForChild("Win Streak"), 
				PD:WaitForChild("Punch Knockout Wins"), PD:WaitForChild("Leg Knockout Wins")
		end
		
		return nil, nil, nil, nil
	end
	
	local function Update_Win_Streak_Crown()
		local All_T = Tabs_F:GetChildren()
		table.sort(All_T, function(A, B)
			local A_Streak = A:GetAttribute("Win_Streak") or 0
			local B_Streak = B:GetAttribute("Win_Streak") or 0
			return A_Streak > B_Streak
		end)
		
		for i = 1, #All_T do
			local T = All_T[i]
			if(T ~= nil and T:IsA("Frame") and T:FindFirstChild("Streak_F") ~= nil)then
				local Streak_F = T:FindFirstChild("Streak_F")
				local Crown_Icon = Streak_F:FindFirstChild("Crown_Img")
				if(Crown_Icon ~= nil)then
					Crown_Icon.Visible = (i == 1)
				end
			end
		end
	end
	
	local function Update_Elo_Order()
		local Y_Pos = 0
		local All_T = Tabs_F:GetChildren()
		table.sort(All_T, function(A, B)
			local A_Elo = A:GetAttribute("Elo") or 0
			local B_Elo = B:GetAttribute("Elo") or 0
			return A_Elo > B_Elo
		end)
		
		for i = 1, #All_T do
			local T = All_T[i]
			if(T ~= nil and T:IsA("Frame"))then
				T.Position = UDim2.new(0, 0, Y_Pos, 0)
				Y_Pos += 0.15
			end
		end
	end
	
	local function Create_Player_Tab(Plr)
		local Elo_V, Win_Streak_V, Punch_KO_V, Kick_KO_V = Get_Player_Data_Vals(Plr)
		if(Elo_V ~= nil and Win_Streak_V ~= nil and Punch_KO_V ~= nil and Kick_KO_V ~= nil)then
			local Tab = TMP_Tab:Clone()
			Tab.Parent = Tabs_F
			Tab.Name = "Tab_" .. Plr.UserId
			Tab.Position = UDim2.new(1, 0, 0, 0)
			Tab:SetAttribute("Elo", Elo_V.Value or 400)
			Tab:SetAttribute("Win_Streak", Win_Streak_V.Value or 0)
			
			local Elo_Key, Elo_Data = Elo_Mod.Get_Elo_Data_From_Val(Elo_V.Value)
			local Selected = Tab:WaitForChild("Selected")
			local Elo_Txt = Tab:WaitForChild("Elo_F"):WaitForChild("Elo_Txt")
			local Name_F = Tab:WaitForChild("Plr_Name_F")
			local Elo_Icon = Name_F:WaitForChild("Elo_Img")
			local Name_Txt = Name_F:WaitForChild("Plr_Name_Txt")
			local Streak_F = Tab:WaitForChild("Streak_F")
			local Crown_Icon = Streak_F:WaitForChild("Crown_Img")
			local Streak_Txt = Streak_F:WaitForChild("Streak_Txt")
			local KO_Txt = Tab:WaitForChild("KO_F"):WaitForChild("KO_Txt")
			
			Name_Txt.Text = Plr.DisplayName .. ""
			Name_Txt.TextColor3 = Color3.new(1, 1, 1)
			Crown_Icon.Visible = false
			Streak_Txt.Text = Format_Number(Win_Streak_V.Value) .. ""
			KO_Txt.Text = Format_Number(Punch_KO_V.Value + Kick_KO_V.Value) .. ""
			Elo_Icon.Image = Elo_Data['Icon']
			Elo_Icon.ImageColor3 = Elo_Data['Color']
			Elo_Txt.Text = Format_Number(Elo_V.Value) .. ""
			Elo_Txt.TextColor3 = Elo_Data['Color']
			Tab.BackgroundColor3 = Elo_Data['Color']
			
			Punch_KO_V.Changed:Connect(function()
				KO_Txt.Text = Format_Number(Punch_KO_V.Value + Kick_KO_V.Value) .. ""
			end)
			
			Kick_KO_V.Changed:Connect(function()
				KO_Txt.Text = Format_Number(Punch_KO_V.Value + Kick_KO_V.Value) .. ""
			end)
			
			Win_Streak_V.Changed:Connect(function()
				local New_V = Win_Streak_V.Value or 0
				Tab:SetAttribute("Win_Streak", New_V)
				Streak_Txt.Text = Format_Number(New_V) .. ""
				Update_Win_Streak_Crown()
			end)
			
			Elo_V.Changed:Connect(function()
				local New_V = Elo_V.Value or 400
				local Elo_Key, Elo_Data = Elo_Mod.Get_Elo_Data_From_Val(New_V)
				Tab:SetAttribute("Elo", New_V)
				Elo_Icon.Image = Elo_Data['Icon']
				Elo_Icon.ImageColor3 = Elo_Data['Color']
				Elo_Txt.Text = Format_Number(New_V) .. ""
				Elo_Txt.TextColor3 = Elo_Data['Color']
				Tab.BackgroundColor3 = Elo_Data['Color']
				Update_Elo_Order()
			end)
			
			Selected.MouseEnter:Connect(function()
				if(Debounce_E == false)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")
					Name_Txt.TextColor3 = Color3.fromRGB(34, 244, 68)
					Name_Txt:TweenPosition(UDim2.new(0.25, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
					
					Debounce_E = false
				end
			end)
			
			Selected.MouseLeave:Connect(function()
				Name_Txt.TextColor3 = Color3.new(1, 1, 1)
				Name_Txt:TweenPosition(UDim2.new(0.25, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
			end)
			
			Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					
					Open_Stats:Fire(Plr)
					
					task.wait(0.25)
					Debounce_C = false
				end
			end)
			
			Tab.Visible = true
		end
	end
	
	local function Remove_Tab(Plr)
		local Tab = Tabs_F:FindFirstChild("Tab_" .. Plr.UserId)
		if(Tab ~= nil)then
			Tab:Destroy()
		end
		
		Update_Elo_Order()
		Update_Win_Streak_Crown()
	end
	
	local function On_Init()
		local All_P = game.Players:GetPlayers()
		for i = 1, #All_P do
			local Plr = All_P[i]
			if(Plr ~= nil and Tabs_F:FindFirstChild("Tab_" .. Plr.UserId) == nil)then
				Create_Player_Tab(Plr)
			end
		end
		
		Update_Win_Streak_Crown()
		Update_Elo_Order()
		
		game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
		Debounce_UI = true
	end
	On_Init()
	
	Update_Player_List.OnClientEvent:Connect(function(Plr, Did_Join)
		if(Did_Join == true and Tabs_F:FindFirstChild("Tab_" .. Plr.UserId) == nil)then
			Create_Player_Tab(Plr)
		elseif(Did_Join == false)then
			Remove_Tab(Plr)
		end
	end)
end
Core_List_Handle()

local function Toggle_Player_List_Handle()
	local function Toggle_Display(Should_Show)
		Debounce_UI = not Should_Show
		local Frame_Position = Should_Show and UDim2.new(1, 0, 0, 0) or UDim2.new(1, 275, 0, 0)
		Main_F:TweenPosition(Frame_Position, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.75, true, nil)
	end
	
	UIS.InputBegan:Connect(function(input, GPE)
		if((input.KeyCode == Enum.KeyCode.Tab or input.KeyCode == Enum.KeyCode.ButtonR3) and 
			Is_Chatbox_Typing:Invoke() == false)then
			
			Toggle_Display(Debounce_UI)
		end
	end)
	
	Toggle_Player_List.Event:Connect(function(Should_Show)
		Toggle_Display(Should_Show)
	end)

	Toggle_Side_Buttons.Event:Connect(function(Should_Show)	
		if Should_Show then
			if game.Players.LocalPlayer:GetAttribute("IsTutorialRunning") then
				return
			end
		end
		Main_F.Parent.Enabled = Should_Show
	end)
end
Toggle_Player_List_Handle()]]></ProtectedString>
							<string name="ScriptGuid">{CA412024-2C5A-4637-B3B0-EAAFF9A9745B}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Player_List_UI.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX52FDF04F6D574CC183A02D7881E4E778">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">White_Crate_Fade_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX32D90AA694024A1D9343918C2E8CB963">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")

-- Modules
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Show_White_Fade 		= Channels.Bindable_Events.Show_White_Fade

local Main_F = script.Parent.Main_F

local function Reset_UI(T)
	Main_F.Visible = false
	Main_F.Size = UDim2.new(1, 0, 1, 0)
	
	for i = 1, #T do
		if(T[i] ~= nil)then
			T[i].BackgroundTransparency = 1
		end
	end
end

local function Show_UI_Effects()
	local T = Main_F:GetChildren()
	Reset_UI(T)
	Main_F.Visible = true
	
	local function Show_White_Fade()
		local Tween_In = TweenInfo.new(0.075, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
		
		for i = 1, #T do
			if(T[i] ~= nil)then
				TS:Create(T[i], Tween_In, {BackgroundTransparency = 0}):Play()
			end
		end
		
		wait(0.075)
	end
	Show_White_Fade()
	
	local function Remove_Fade()
		local Tween_Remove = TweenInfo.new(0.075, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
		Main_F:TweenSize(UDim2.new(2, 0, 2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.075, true, nil)
		
		for i = 1, #T do
			if(T[i] ~= nil)then
				TS:Create(T[i], Tween_Remove, {BackgroundTransparency = 1}):Play()
			end
		end
		
		wait(0.075)
	end
	Remove_Fade()
	
	Reset_UI(T)
end

local function Set_Frame_Colors(Col)
	local All_T = Main_F:GetChildren()
	for i = 1, #All_T do
		local T = All_T[i]
		if(T ~= nil and T:IsA("Frame"))then
			T.BackgroundColor3 = Col
		end
	end
end

Show_White_Fade.Event:Connect(function(Col)
	Set_Frame_Colors(Col)
	Show_UI_Effects()
end)
]]></ProtectedString>
							<string name="ScriptGuid">{16E5CA2F-2CD0-4C74-8CDA-C432A88B5A86}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Crate_White_Fade_Client.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXC4AC3BDFBFD24A97BE7376B38EBA248E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Notification_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX8F513E30C846456F9C180389E34C061B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")
local Plr = game.Players.LocalPlayer

-- Modules
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod 			= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Display_Data_Client 		= Channels.Bindable_Events.Display_Data
local Display_Data_From_Server  = Channels.SC_Remote_Events.Display_Data

-- UI References
local Tabs_F = script.Parent.Tabs_F
local TMP = script.Parent.Txt_TMP
local Msg_Stack = {}
local Debounce_Msgs = false
local IsRunning = false

local function RecomputePositions()
	local children = Tabs_F:GetChildren()
	table.sort(children, function(a,b)
		return a.LayoutOrder < b.LayoutOrder
	end)

	for i, tab in ipairs(children) do
		local targetY = 0.875 - ((i - 1) * 0.12)
		TS:Create(tab, TweenInfo.new(0.25, Enum.EasingStyle.Quint), {
			Position = UDim2.new(0.5, 0, targetY, 0)
		}):Play()
	end
end

local function Create_New_Tab(Txt, Col)
	local Tab = TMP:Clone()
	Tab.Name = "Notif_" .. tick()
	Tab.LayoutOrder = tick()
	Tab.Text = Txt
	Tab.TextColor3 = Col or Color3.new(1,1,1)

	Tab.Parent = Tabs_F
	Tab.Size = UDim2.new(0.5, 0, 0, 0)
	Tab.Position = UDim2.new(0.5, 0, 0.875, 0)
	Tab.Visible = true

	SE_Mod.PlaySFX(Plr, "Click_SE")

	TS:Create(Tab, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0.5, 0, 0.1, 0)
	}):Play()

	-- Recompute all positions after adding
	RecomputePositions()

	task.delay(5, function()
		if not Tab.Parent then return end

		TS:Create(Tab, TweenInfo.new(0.2, Enum.EasingStyle.Quint, Enum.EasingDirection.In), {
			Size = UDim2.new(0,0,0,0)
		}):Play()

		Debris:AddItem(Tab, 0.2)

		task.delay(0.21, function()
			RecomputePositions()
		end)
	end)
end

local function Process_Msg()
	if IsRunning then return end
	IsRunning = true

	while #Msg_Stack > 0 do
		local m = table.remove(Msg_Stack, 1)
		Create_New_Tab(m.Text, m.Color)
		task.wait(0.2) -- petite latence pour éviter l'overlap à la frame
	end

	IsRunning = false
end

local function Process_Event(Txt, Color)
	local Data = {
		['Text'] = Txt,
		['Color'] = Color
	}
	table.insert(Msg_Stack, Data)

	if(Debounce_Msgs == false)then
		Process_Msg()
	end
end

Display_Data_Client.Event:Connect(function(Txt, Color)
	Process_Event(Txt, Color)
end)

Display_Data_From_Server.OnClientEvent:Connect(function(Txt, Color)
	Process_Event(Txt, Color)
end)]]></ProtectedString>
							<string name="ScriptGuid">{2EA0E12A-FF93-485F-BF56-6D4168DE230B}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Notification_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXCC18321034B847639350022DE084F7DA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Menus</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXC837AA4484EE40349D5DB57491C6500D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Codes_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX0CCE9EB4F13D49A0AEB190AA2B0C41A0">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Display_Data_E 		= Channels.Bindable_Events.Display_Data
local Toggle_Side_Buttons 	= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Codes			= Channels.Bindable_Events.Open_Codes
local Redeem_Code 			= Channels.CS_Remote_Functions.Redeem_Code

-- UI references
local Codes_F = script.Parent.Main_F
local Header = Codes_F:WaitForChild("Header")
local Exit_B = Header:WaitForChild("Exit_B")
local Body = Codes_F:WaitForChild("Body")
local Content = Body:WaitForChild("Stroke"):WaitForChild("Content")
local Redeem_B = Content.Send_Code_B
local Data_Txt = Content.Data_Box_F.Data_Txt_Box

-- UI states
local Debounce_E = false
local Debounce_C = false
local Debounce_UI = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Remove_UI()
	Disconnect_Cons()
	Codes_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	task.wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Codes_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Codes_F.Visible = false
	Codes_F.Position = UDim2.new(0.5, 0, 0.675, 0)
	Data_Txt.Text = ""

	Toggle_Side_Buttons:Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Show_UI()

	local function Reset_Display()
		Disconnect_Cons()
		Codes_F.Visible = false
		Codes_F.Position = UDim2.new(0.5, 0, 0.575, 0)
		Data_Txt.Text = ""

		local Codes_Blur = game.Lighting:FindFirstChild("Codes_Blurr")
		if(Codes_Blur ~= nil)then
			Codes_Blur:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()

	local function Redeem_Button()
		Redeem_B.Size = UDim2.new(0.28, 0, 0.361, 0)
		
		table.insert(Cons, Redeem_B.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				SE_Mod.PlaySFX(Plr, "Click_SE")
				TS:Create(Redeem_B, Tween_Click, {Size = UDim2.new(0.21, 0, 0.27075, 0)}):Play()

				if(Data_Txt.Text ~= "")then
					local Code = string.upper(Data_Txt.Text)
					
					local Server_Response = Redeem_Code:InvokeServer(Code)
					Display_Data_E:Fire(Server_Response)
				else
					Display_Data_E:Fire("❌ Enter your Code!", Color3.new(1, 0, 0))
				end

				task.wait(0.25)
				Debounce_C = false
			end
		end))
	end
	--Redeem_Button()
	MenuButtons_Mod.Setup_Base_Button(Cons, Redeem_B, function()
		if(Data_Txt.Text ~= "")then
			local Code = string.upper(Data_Txt.Text)

			local Server_Response = Redeem_Code:InvokeServer(Code)
			Display_Data_E:Fire(Server_Response)
		else
			Display_Data_E:Fire("❌ Enter your Code!", Color3.new(1, 0, 0))
		end
	end)
	
	MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)

	local function Display_UI()
		Codes_F.Visible = true
		Codes_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Codes_Blurr"

		Toggle_Side_Buttons:Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

Open_Codes.Event:Connect(function()
	
	if(Debounce_UI == false)then
		Show_UI()
	else
		Remove_UI()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{CA3D289E-2551-4495-B167-0D550F07440F}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Codes_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX40CCA5FEB9E441FB91692FFE0BF61EDF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Avatar_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX11A62139B998481AB60770D6D5FA9A2E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local Cam = game.Workspace.CurrentCamera

-- Modules
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
-- Require submodules
local EquipmentPanel = require(script:WaitForChild("EquipmentPanel"))
local CombosPanel = require(script:WaitForChild("CombosPanel"))
local PlayerInfosPanel = require(script:WaitForChild("PlayerInfosPanel"))

local Channels = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 		= Channels.Bindable_Events.Toggle_Side_Buttons
local Toggle_Tutorial_OK_Button = Channels.Bindable_Events.Toggle_Tutorial_OK_Button
local Open_Combos 				= Channels.Bindable_Events.Open_Combos
local Open_Equipment 			= Channels.Bindable_Events.Open_Equipment
local Open_Appearance 			= Channels.Bindable_Events.Open_Appearance
local Save_Appearance 			= Channels.CS_Remote_Events.Save_Appearance

-- Data
local PD = Plr:WaitForChild("Player_Data")

-- UI References
local Core_UI = script.Parent.Main_F
local Exit_B = Core_UI.Header.Exit_B
local Header = Core_UI.Header
local Main_Data_F = Core_UI.Main_Data_F
local Top_Change_Buttons_F = Main_Data_F.Top_Change_Buttons_F
local Combination_F = Main_Data_F.Combination_F
local Combination_Select_F = Core_UI.Combination_Select_F
local Equipment_F = Main_Data_F.Equipment_F
local Appearance_F = Main_Data_F.Appearance_F

local Tabs_Data = {
	["equipment tab"] = {
		Frame =  Main_Data_F:WaitForChild("Equipment_F"),
		Show_Function = EquipmentPanel.Show
	}, 
	["combos tab"] = {
		Frame =Main_Data_F:WaitForChild("Combination_F"),
		Show_Function = CombosPanel.Show
	},
	["appearance tab"] = {
		Frame = Main_Data_F:WaitForChild("Appearance_F"),
		Show_Function = PlayerInfosPanel.Show
	}
}

-- Debounce variables
local Debounce_UI = false
local Debounce_C = false
local Debounce_E = false

-- Connections table
local Cons = {}
local function Disconnect_Cons()
    for i = 1, #Cons do
        if Cons[i] ~= nil then
            Cons[i]:Disconnect()
        end
    end
    table.clear(Cons)
end

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

local function PositionWithAnimationPreview()
    Main_Data_F:TweenPosition(UDim2.new(0.33, 0 ,0.53, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
    Header:TweenPosition(UDim2.new(0.33, 0,0.11, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
end

local function InitialPositions()
    Main_Data_F:TweenPosition(UDim2.new(0.5, 0, 0.53, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
    Header:TweenPosition(UDim2.new(0.5, 0, 0.11, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
end


local function Toggle_Player_Controls(Is_Enabled)
	local Plr_Scripts_F = Plr:FindFirstChild("PlayerScripts")
	if(Plr_Scripts_F ~= nil and Plr_Scripts_F:FindFirstChild("PlayerModule") ~= nil)then
		local P_Mod = require(Plr_Scripts_F:FindFirstChild("PlayerModule"))
		local Controls = P_Mod:GetControls()

		if(Controls ~= nil)then
			if(Is_Enabled)then
				Controls:Enable()
			else
				Controls:Disable()
			end
		end
	end
end

local function onCharacterAdded(newCharacter,Plr)
	task.wait(1)

	local humanoid = newCharacter:WaitForChild("Humanoid", 5)
	local cam = workspace.CurrentCamera

	if humanoid and cam then
		cam.CameraSubject = humanoid
		task.wait(1)
		Toggle_Player_Controls(false)
		task.wait(1)
		Toggle_Player_Controls(true)
	end
	
end

if Plr.Character then
	onCharacterAdded(Plr.Character,Plr)
end
Plr.CharacterAdded:Connect(onCharacterAdded)

local function Before_Closing_Tab()
	InitialPositions()
	Combination_Select_F.Visible = false
	
	task.spawn(function()
		Save_Appearance:FireServer(
			Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text, 
			Appearance_F.Country_F.Country_Txt.Text, 
			Appearance_F.Skin_Tone_F.Skin_Tone_Txt.Text,
			nil)
	end)
	
	
	task.wait(0.25)
end

local function Remove_UI()
    Disconnect_Cons()
    Core_UI:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
    TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	Before_Closing_Tab()
	
	task.spawn(function()
		Save_Appearance:FireServer(
			nil,nil,nil,Plr: WaitForChild("Player_Data",5):FindFirstChild("IsMale").Value)
	end)

	
    Core_UI.Visible = false
    Core_UI.Position = UDim2.new(0.5, 0, 0.675, 0)
    Combination_Select_F.Visible = false
    local Blur = game.Lighting:FindFirstChild("Inventory_Blurr")
    if Blur ~= nil then
        Blur:Destroy()
    end
    Cam.FieldOfView = 70
    Toggle_Side_Buttons:Fire(true, true)
    Toggle_Tutorial_OK_Button:Fire(true)
    Debounce_UI = false
end

local function Set_Init_Cam_Effects()
	Disconnect_Cons()
	Core_UI.Visible = false
	Core_UI.Position = UDim2.new(0.5, 0, 0.575, 0)
	local Inv_Blurr = game.Lighting:FindFirstChild("Inventory_Blurr")
	if Inv_Blurr ~= nil then
		Inv_Blurr:Destroy()
	end
	Cam.FieldOfView = 70
	Core_UI.Visible = true
	Core_UI:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
	local Blur = Instance.new("BlurEffect", game.Lighting)
	Blur.Name = "Inventory_Blurr"
	Toggle_Side_Buttons:Fire(false, true)
	Toggle_Tutorial_OK_Button:Fire(false)
end


-- Build context for submodules
local context = {
	-- Player Data
	PD = PD,
	-- UI References
    Equipment_F = Equipment_F,
    Combination_F = Combination_F,
    Combination_Select_F = Combination_Select_F,
	Appearance_F = Appearance_F,
	-- UI Functions
    InitialPositions = InitialPositions,
	PositionWithAnimationPreview = PositionWithAnimationPreview,
	Remove_UI = Remove_UI
}

-- Set up combinations and equipment panels
CombosPanel:SetUp(context)
EquipmentPanel:SetUp(context)
PlayerInfosPanel:SetUp(context)

-- Display UI function
local function Display_UI(open)
    if Core_UI.Visible == false then
        
		Set_Init_Cam_Effects()
		
		-- Tabs and Exit buttons handlers based on Tabs table
		for Tab_B_Name, Tab_Data in pairs(Tabs_Data) do
			local Tab_B = Top_Change_Buttons_F:FindFirstChild(Tab_B_Name)
			if Tab_B:IsA("ImageButton") then
				MenuButtons_Mod.Setup_Tab_Button(Cons, Tab_B, Top_Change_Buttons_F, Tabs_Data, Before_Closing_Tab)
			end	
		end
		
		MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)
		
		-- Activated the called tab
		if open == "Avatar" then
			MenuButtons_Mod.Activate_Tab("equipment tab", Top_Change_Buttons_F, Tabs_Data, Before_Closing_Tab) 
		elseif open == "Combos" then
			MenuButtons_Mod.Activate_Tab("combos tab", Top_Change_Buttons_F, Tabs_Data, Before_Closing_Tab) 
		elseif open == "Appearance" then
			MenuButtons_Mod.Activate_Tab("appearance tab", Top_Change_Buttons_F, Tabs_Data, Before_Closing_Tab) 
		end
    end
end

-- Connect open events
Open_Combos.Event:Connect(function()
    if Debounce_UI == false then
        Debounce_UI = true
        Display_UI("Combos")
    else
        Remove_UI()
    end
end)

Open_Equipment.Event:Connect(function()
    if Debounce_UI == false then
        Debounce_UI = true
        Display_UI("Avatar")
    else
        Remove_UI()
    end
end)

Open_Appearance.Event:Connect(function()
    if Debounce_UI == false then
        Debounce_UI = true
        Display_UI("Appearance")
    else
        Remove_UI()
    end
end)]]></ProtectedString>
							<string name="ScriptGuid">{0EF4D8B6-7346-41E7-92C7-5A791677C460}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Avatar_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX9A3858101B274B368C1EC4406EB3020F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Avatar_Handle</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXDAE0D27A85584EAB97AB24C51E6555C3">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--====================================================--
-- // COMBOS PANEL MODULE
-- // Handles Combo UI, Animation Previews & Data Sync
--====================================================--

local CombosPanel = {}

--------------------------------------------------------
-- // SERVICES & DEPENDENCIES
--------------------------------------------------------
local RS   = game:GetService("ReplicatedStorage")
local Plr  = game.Players.LocalPlayer

--------------------------------------------------------
-- // CHANNELS & EVENTS
--------------------------------------------------------
local Channels              = require(RS.Modules.Channels)
local Reset_Sequence        = Channels.CS_Remote_Events.Reset_Sequence
local Display_Data_E        = Channels.Bindable_Events.Display_Data
local Combo_Action_Request  = Channels.CS_Remote_Functions.Combo_Action_Request

--------------------------------------------------------
-- // MODULES & DATA
--------------------------------------------------------
local Data_Mods_F   = RS:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))

local Combination_Data = Animation_Mod.Get_Combinations("Combination")
local Punch_Data       = Animation_Mod.Get_Combinations("Punch")
local Kick_Data        = Animation_Mod.Get_Combinations("Kick")
local Emotes_Data      = Animation_Mod.Get_Combinations("Emotes")
local Submission_Data  = Animation_Mod.Get_Combinations("Submission")
local Takedown_Data    = Animation_Mod.Get_Combinations("Takedown")

--------------------------------------------------------
-- // STATE VARIABLES
--------------------------------------------------------
local cons = {}
local Selected_Combo, Selected_Strike, Selected_Action = nil, nil, nil
local Selected_Player_Data_Entry, Selected_Action_Type = nil, nil
local Debounce_S, Debounce_R, Debounce_T = false, false, false
local context = nil
local Combo_Main_F, Side_Tabs_F, Preview_F = nil, nil, nil
local Reset_F = nil

--------------------------------------------------------
-- // DEFAULT COMBOS
--------------------------------------------------------
local Default_Strikes = {
	['Punch Combo'] = "C,A,B,C,A,G",
	['Kick Combo']  = "F,D,E,F,J,H",
	['Submission Key'] = "A",
	['Fight Intro Key']   = "A",
	['Fight Outro Key']   = "A",
}

--------------------------------------------------------
-- // UTILITY FUNCTIONS
--------------------------------------------------------

-- Disconnect all event connections
local function DisconnectCons()
	for _, c in ipairs(cons) do
		c:Disconnect()
	end
	table.clear(cons)
end

-- Stop all animations on animator
local function StopAnimations(animator)
	for _, tr in pairs(animator:GetPlayingAnimationTracks()) do
		tr:Stop()
		tr:Destroy()
	end
end

-- Play an animation and return its track
local function PlayAnimation(animator, animId)
	StopAnimations(animator)
	local anim = Instance.new("Animation")
	anim.AnimationId = "rbxassetid://" .. tostring(animId)
	local track = animator:LoadAnimation(anim)
	track.Looped = true
	track:Play()
	return anim, track
end

-- Display locked UI for locked actions
local function HandleLockUI(frame, value)
	frame.Visible = true
	--frame.Combo_Name_Txt.Text = value["Name"]
	Display_Data_E:Fire("❗ This Move is Currently Locked! Unlock it via Achievement or Shop!", Color3.fromRGB(225, 0, 0))
	frame.Price_F.Visible = false
	
	--if value["Price"] > 0 then
	--	frame.Price_F.Visible = true
	--	frame.Price_F.Price_Txt = value["Price"]
	--end
end

local function Remove_Strike_Selection()
	if Selected_Combo and Selected_Strike then
		Combo_Main_F[Selected_Combo][Selected_Strike].Action_Title_Selected.Visible = false
		Selected_Strike = nil
	end
end

local function Close_Preview_F()
	Preview_F.Visible = false
	Remove_Strike_Selection()
	Selected_Combo, Selected_Strike, Selected_Action = nil, nil, nil
	context.InitialPositions()
end

local function Activate_Tab(Tab_Name, Frame_Name, Player_Data_Entry, Action_Type)
	for _, tab in ipairs(Side_Tabs_F:GetChildren()) do
		if tab:IsA("ImageButton") then
			tab.BackgroundTransparency = (tab.Name == Tab_Name) and 0 or 1
		end
	end

	for _, frame in ipairs(Combo_Main_F:GetChildren()) do
		if frame:IsA("Frame") then
			frame.Visible = (frame.Name == Frame_Name)
		end
	end

	Close_Preview_F()
	if Player_Data_Entry and Action_Type then 
		Selected_Action_Type = Action_Type
		Selected_Player_Data_Entry = Player_Data_Entry
		Reset_F.Visible = true
	else
		Selected_Action_Type = nil
		Selected_Player_Data_Entry = nil
		Reset_F.Visible = false
	end
	Selected_Combo = Frame_Name
	Selected_Strike = nil
end

-- Update UI frame text/icons with action data
local function Get_Icon_Indication(Action_Data)
	if not Action_Data["Icon"] then
		if Action_Data["Punch"] then
			return "rbxassetid://79720394914031"
		else
			return "rbxassetid://136568604314712"
		end
	else 
		return Action_Data["Icon"]
	end
end

local function Get_Time_Indication(Action_Data)
	if not Action_Data["Time Length"] then
		return ""
	else
		local Time_Length = Action_Data["Time Length"]
		if Time_Length<0.5 then
			return "⏱️🟩⬜⬜"
		elseif Time_Length <0.61 then
			return "⏱️🟩🟩⬜"
		else
			return "⏱️🟩🟩🟩"
		end
	end
end

local function Get_Damage_Indication(Action_Data)
	if not Action_Data["Damage"] then
		return ""
	else 
		return "-"..Action_Data["Damage"].."Pts 💥"
	end
end

local function Update_Action_Frame(Action_Frame, Action_Data)
	if (Action_Data) then
		Action_Frame.Action_Name_Txt.Text = Action_Data["Name"]
		Action_Frame.Icon_Img.Image = Get_Icon_Indication(Action_Data)
		Action_Frame.Action_Multi_Txt.Text  = Get_Damage_Indication(Action_Data)
		Action_Frame.Action_Length_Txt.Text = Get_Time_Indication(Action_Data)
	end
end

--------------------------------------------------------
-- // DATA MAPPING
--------------------------------------------------------

local function Get_Action_Data_List(Action_Type)
	if(Action_Type == "Punch") then
		return Punch_Data
	elseif(Action_Type == "Kick") then
		return Kick_Data
	elseif(Action_Type == "Strike") then
		return Combination_Data
	elseif(Action_Type == "Takedown") then
		return Takedown_Data
	elseif(Action_Type == "Submission") then
		return Submission_Data
	elseif(Action_Type == "Emote") then
		return Emotes_Data
	end
end

local function Get_Action_Data_From_Key(Action_Type, Action_Key)
	return Get_Action_Data_List(Action_Type)[Action_Key]
end

local function Get_Action_ID(action_type, value)
	if action_type == "Submission" then
		return value["Submission ID"]
	elseif action_type == "Takedown" then
		return value["Takedown ID"]
	else
		return value["ID"]
	end
end


local function Reset_Selected_Combo()

	if Selected_Player_Data_Entry ~= nil then
		local Default_Value = Default_Strikes[Selected_Player_Data_Entry]
		Reset_Sequence:FireServer(Selected_Player_Data_Entry, Default_Value)

		local strikes = Default_Value:split(",")
		for i, Action_Key in ipairs(strikes) do
			local Action_Data = Get_Action_Data_From_Key(Selected_Action_Type, Action_Key)
			Update_Action_Frame(Combo_Main_F[Selected_Combo]["Action_F_"..i], Action_Data)
		end
	end
end
--------------------------------------------------------
-- // ACTION BUTTONS & PREVIEW
--------------------------------------------------------
local function GenerateActionTabs(actionType)
	local animator = Preview_F.Animation_Preview_F.VF.WM.Model.Humanoid:FindFirstChild("Animator")
	local overview = Preview_F.Animation_Preview_F
	
	local listData = Get_Action_Data_List(Selected_Action_Type)
	
	for key, value in pairs(listData) do
		if value then
			local unlocked = Animation_Mod.Player_Owns_Action(Plr, actionType, key) or value["Price"] == 0
			local Action_Button = Preview_F.Action_Select_F.Action_Data_F.Tab_TMP:Clone()
			Action_Button.Name = value["Name"]
			Action_Button.Strike_Name_Txt.Text = (unlocked and "" or "🔒 ").. value["Name"]
			Action_Button.Parent = Preview_F.Action_Select_F.Action_Data_F.Tabs_F
			Action_Button.Visible = true
			table.insert(cons, Action_Button.Selected.MouseButton1Click:Connect(function()
				if Debounce_T then return end
				Debounce_T = true

				local Locked_F = Preview_F.Animation_Preview_F.Locked_F
				if unlocked then
					Locked_F.Visible = false
					Selected_Action = key
				else
					HandleLockUI(Locked_F, value)
					Selected_Action = nil
				end

				for _, tab in ipairs(Preview_F.Action_Select_F.Action_Data_F.Tabs_F:GetChildren()) do
					if tab:IsA("Frame") then
						tab:FindFirstChild("Selection").Visible = false
					end
				end
				Action_Button:FindFirstChild("Selection").Visible = true
				
				local id = Get_Action_ID(actionType, value)
				local anim, track = PlayAnimation(animator, id)
				overview.Action_Multi_Txt.Text  = Get_Damage_Indication(value)
				overview.Action_Length_Txt.Text = Get_Time_Indication(value)
				track:AdjustSpeed(actionType == "Submission" or actionType == "Takedown" and 0 or 0.5)

				task.wait(0.5)
				Debounce_T = false
			end))
		end
	end
end


--------------------------------------------------------
-- // COMBO PREVIEW HANDLER
--------------------------------------------------------

function CombosPanel:Load_Combination()
	local animator = Preview_F.Animation_Preview_F.VF.WM.Model.Humanoid:FindFirstChild("Animator")
	local overview = Preview_F.Animation_Preview_F

	-- Clear old tabs & animations
	for _, c in ipairs(Preview_F.Action_Select_F.Action_Data_F.Tabs_F:GetChildren()) do
		if c:IsA("Frame") then c:Destroy() end
		overview.Action_Multi_Txt.Text  = "" 
		overview.Action_Length_Txt.Text = ""
	end
	StopAnimations(animator)
	DisconnectCons()

	-- Load proper list based on combo type
	if not Selected_Combo then return end
	GenerateActionTabs(Selected_Action_Type)

	-- Equip / Close handlers
	table.insert(cons, Preview_F.Equip_B.MouseButton1Click:Connect(function()
		if context.Click_SE then context.Click_SE:Play() end
		if Selected_Action then
			local Strike_Index = tonumber(Selected_Strike:match("%d+"))
			local result = Combo_Action_Request:InvokeServer(Selected_Player_Data_Entry, Strike_Index, Selected_Action_Type, Selected_Action)
			if result then
				local Action_Data = Get_Action_Data_From_Key(Selected_Action_Type, Selected_Action)
				Update_Action_Frame(Combo_Main_F[Selected_Combo][Selected_Strike], Action_Data)
			end
		end
	end))

	table.insert(cons, Preview_F.Close_B.MouseButton1Click:Connect(function()
		Close_Preview_F()
	end))
end


--------------------------------------------------------
-- // COMBO FRAME CREATION
--------------------------------------------------------

local function Setup_Action_Frame(Action_Key, Player_Data_Entry, Container_Frame, Action_Type, Action_Template, Action_Name, Order)
	
	local Action_Data = Get_Action_Data_From_Key(Action_Type, Action_Key)
	
	local Action_Frame = Action_Template:Clone()
	Action_Frame.Parent = Container_Frame
	Action_Frame.Name = "Action_F_"..Action_Name
	Action_Frame.LayoutOrder = Order
	Action_Frame.Action_Title.text.Text = Action_Name
	Action_Frame.Action_Title_Selected.text.Text = Action_Frame.Action_Title.text.Text
	Action_Frame.Action_Title_Selected.Visible = false
	Update_Action_Frame(Action_Frame, Action_Data)
	Action_Frame.Visible = true

	Action_Frame.Selected.MouseButton1Click:Connect(function()
		if Debounce_S then return end
		Debounce_S = true
		Remove_Strike_Selection()

		Selected_Strike, Selected_Combo = Action_Frame.Name, Container_Frame.Name
		Selected_Player_Data_Entry, Selected_Action_Type = Player_Data_Entry , Action_Type
		CombosPanel:Load_Combination()
		Combo_Main_F[Selected_Combo][Selected_Strike].Action_Title_Selected.Visible = true

		context.PositionWithAnimationPreview()
		task.wait(0.7)
		Preview_F.Visible = true
		Debounce_S = false
	end)
end

local function Setup_Combo_Frame(Combo_Value, Player_Data_Entry, Combo_Frame, Action_Type, Action_Template)
	local strikes = Combo_Value:split(",")
	for i, Action_Key in ipairs(strikes) do
		Setup_Action_Frame(Action_Key, Player_Data_Entry, Combo_Frame, Action_Type, Action_Template, i, i)
	end
end

--------------------------------------------------------
-- // INITIAL SETUP
--------------------------------------------------------

function CombosPanel:SetUp(ctx)
	context = ctx
	Combo_Main_F = context.Combination_F.Main_Data_F
	Side_Tabs_F  = context.Combination_F.Side_Tabs_F
	Preview_F    = context.Combination_Select_F
	Reset_F 	 = Combo_Main_F.Reset_F

	-- Player data
	local Player_Punch_Combo      = context.PD:FindFirstChild("Punch Combo").Value
	local Player_Kick_Combo       = context.PD:FindFirstChild("Kick Combo").Value
	local Player_Intro_Action     = context.PD:FindFirstChild("Fight Intro Key").Value
	local Player_Takedown_Action  = context.PD:FindFirstChild("Takedown Key").Value
	local Player_Outro_Action     = context.PD:FindFirstChild("Fight Outro Key").Value


	-- UI references
	local Punch_Combo_F = Combo_Main_F.Punch_Combo_F
	local Kick_Combo_F  = Combo_Main_F.Kick_Combo_F
	local Animations_F  = Combo_Main_F.Animations_F
	local Action_Template = Combo_Main_F.TMP_Tab

	-- Setup frames
	Setup_Combo_Frame(Player_Punch_Combo, "Punch Combo", Punch_Combo_F, "Punch", Action_Template)
	Setup_Combo_Frame(Player_Kick_Combo, "Kick Combo", Kick_Combo_F, "Kick", Action_Template)
	
	Setup_Action_Frame(Player_Intro_Action, "Fight Intro Key", Animations_F, "Emote",  Action_Template, "FIGHT INTRO", 1)
	Setup_Action_Frame(Player_Takedown_Action, "Submission Key", Animations_F, "Submission", Action_Template, "SUBMISSION", 3)
	Setup_Action_Frame(Player_Outro_Action, "Fight Outro Key", Animations_F, "Emote",  Action_Template, "FIGHT OUTRO", 4)

	-- Tab button handlers
	MenuButtons_Mod.Setup_Base_Button({}, Side_Tabs_F["punch"],       function()      Activate_Tab("punch", "Punch_Combo_F", "Punch Combo", "Punch") end)
	MenuButtons_Mod.Setup_Base_Button({}, Side_Tabs_F["kick"],        function()      Activate_Tab("kick", "Kick_Combo_F", "Kick Combo", "Kick") end)
	MenuButtons_Mod.Setup_Base_Button({}, Side_Tabs_F["animations"],  function()      Activate_Tab("animations", "Animations_F") end)
	
	--Setup Reset button
	MenuButtons_Mod.Setup_Colored_Button({}, Reset_F.Reset_B, Color3.new(0.772549, 0, 0),  Reset_Selected_Combo)

	-- Activate default tab
	Activate_Tab("punch", "Punch_Combo_F", "Punch Combo", "Punch")
end

--------------------------------------------------------
-- // RETURN MODULE
--------------------------------------------------------
return CombosPanel
]]></ProtectedString>
								<string name="ScriptGuid">{8C1C6A4D-0FDA-4265-8821-CFFF597EB59E}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">CombosPanel.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF866D35ECB3D40229304442C406E41A0">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")

-- References
local Plr = game.Players.LocalPlayer

-- Modules
local Data_Mods_F 		= RS:WaitForChild("Data_Mods_F")
local Utils 			= require(game.ReplicatedStorage.Modules.Utils)
local Clothing_Mod 		= require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Offers_Config 	= require(Data_Mods_F:WaitForChild("Offers_Config"))
local Sound_Mod 	= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))


local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Avatar_Clothing_Request 	= Channels.CS_Remote_Functions.Avatar_Clothing_Request
local Open_Shop_UI 				= Channels.Bindable_Events.Open_Shop_UI


local ctx = nil
local Equipment_F = nil

-- Catalog of Items
local Gloves = game.ReplicatedStorage.Models.Clothing_F.Gloves_F
local Shorts = game.ReplicatedStorage.Models.Clothing_F.Shorts_F

-- Sorted and Personal data on items
local Gloves_Data = nil
local Shorts_Data = nil

local EquipmentPanel = {}

local cons = {}

local function DisconnectCons()
	for _, c in ipairs(cons) do
		c:Disconnect()
	end
	table.clear(cons)
end

--// Sorting Method

local function sortItems(data, playerOwnsFunc, currentKey, isGlove)
	local items = {}
	for key, value in pairs(data) do
		local offer = Offers_Config.GetClothDataByKey(key, isGlove)
		local rarity = offer and offer.Rarity or "Common"
		table.insert(items, {
			key = key,
			name = value,
			owned = playerOwnsFunc(key),
			rarity = rarity,
		})
	end

	table.sort(items, function(a, b)
		if a.key == currentKey then return true end
		if b.key == currentKey then return false end
		if a.owned ~= b.owned then return a.owned end
		return Clothing_Mod.Get_Rarity_Order(a.rarity) < Clothing_Mod.Get_Rarity_Order(b.rarity)
	end)

	return items
end

local function Get_Sorted_Gloves_Data()
	return sortItems(
		Clothing_Mod.Get_Gloves_Data(),
		function(key) return Clothing_Mod.Player_Owns_Gloves_Key(Plr, key) end,
		Clothing_Mod.Get_Player_Current_Gloves(Plr),
		true
	)
end

local function Get_Sorted_Shorts_Data()
	return sortItems(
		Clothing_Mod.Get_Shorts_Data(),
		function(key) return Clothing_Mod.Player_Owns_Shorts_Key(Plr, key) end,
		Clothing_Mod.Get_Player_Current_Shorts(Plr),
		false
	)
end

Gloves_Data = Get_Sorted_Gloves_Data()
Shorts_Data = Get_Sorted_Shorts_Data()

function EquipmentPanel:Load_Equipment(equipment_type)
    -- Clear existing tabs and disconnect previous connections
	for _, child in ipairs(Equipment_F.Main_Data_F.Tabs_F:GetChildren()) do
        if child:IsA("Frame") then
            child:Destroy()
        end
    end
    DisconnectCons()

	if equipment_type == "Gloves" then
		Gloves_Data = Get_Sorted_Gloves_Data()
		
        local c = 0
		--for index, value in pairs(Gloves_Data) do
		for _, item in ipairs(Gloves_Data) do
			local index = item.key
			local value = item.name
			local owned = item.owned				
			
            c = c + 1
			local temp = Equipment_F.Main_Data_F.TMP_Tab:Clone()
			temp.Parent = Equipment_F.Main_Data_F.Tabs_F
            temp.LayoutOrder = c
            if index == "K" or index == "K1" then
                temp.LayoutOrder = 5
            end
            temp.Name = index
            temp = temp.Frame
			temp.Name_F.Name_Txt.Text = value
			
			local rarityColor = Clothing_Mod.Get_Rarity_Color(item.rarity)
			temp.UIStroke.Color = rarityColor
			
			local owns = Clothing_Mod.Player_Owns_Gloves_Key(Plr, index)
			if not owns then
				temp.Locked_F.Visible = true
			end
			
			temp.Visible = true
            local display = Gloves:FindFirstChild(value):Clone()
            local Viewport_Camera = Instance.new("Camera")
            if display:FindFirstChild("LeftHand") then
                for _, part in pairs(display:GetChildren()) do
                    if part:IsA("BasePart") and (part.Name == "LeftHand" or part.Name == "RightHand") then
                        local groupName = part.Name .. "M"
                        local group = display:FindFirstChild(groupName) or Instance.new("Model")
                        group.Name = groupName
                        group.Parent = display
                        part.Parent = group
                        part.Anchored = true
                    end
                end
                if display:FindFirstChild("LeftHandM") and display:FindFirstChild("RightHandM") then
					display:PivotTo(CFrame.new(0,0,0))
					display:ScaleTo(0.85)
					Utils.AlignGloves(display.LeftHandM, display.RightHandM)
					
                    for _, modelName in ipairs({"LeftHandM", "RightHandM"}) do
                        local model = display[modelName]
                        local hitbox = Instance.new("Part")
                        hitbox.Name = "Hitbox"
                        hitbox.Size = model:GetExtentsSize()
                        hitbox.CFrame = model:GetPivot()
                        hitbox.Anchored = true
                        hitbox.Transparency = 1
                        hitbox.CanCollide = false
                        hitbox.Parent = model
                        model.PrimaryPart = hitbox
                        for _, part in ipairs(model:GetChildren()) do
                            if part:IsA("BasePart") and part ~= model.PrimaryPart then
                                local weld = Instance.new("WeldConstraint")
                                weld.Part0 = model.PrimaryPart
                                weld.Part1 = part
                                weld.Parent = model.PrimaryPart
                                part.Anchored = false
                            end
                        end
					end
					
					Utils.AlignGloves(display.LeftHandM, display.RightHandM)
		
					if owns then
						Utils.SetupHoverRotation(temp, display.LeftHandM, 3)
						Utils.SetupHoverRotation(temp, display.RightHandM, -3)
					end
				end
				
                temp.VF.CurrentCamera = Viewport_Camera
                display.Parent = temp.VF.WorldModel
                temp.VF.WorldModel:PivotTo(CFrame.new(0,0,0))
                Viewport_Camera.Parent = temp.VF
                Viewport_Camera.CFrame = CFrame.new(0, -0.15, 1.6)
            end
			
			table.insert(cons, temp.Selected.MouseButton1Click:Connect(function()
				if Clothing_Mod.Get_Player_Current_Gloves(Plr) ~= index then
					if owns  then
	                    local result = Avatar_Clothing_Request:InvokeServer(equipment_type, index)
						if result == true then
							Sound_Mod.Play_Voice_Over("New_Look")
							
							Gloves_Data =  Get_Sorted_Gloves_Data()
							for i, item in ipairs(Gloves_Data) do
								local Frame = Equipment_F.Main_Data_F.Tabs_F:FindFirstChild(item.key)
								if(Frame) then
									Frame.LayoutOrder = i
								end
							end
												
							-- Reset all UIStroke to rarity color + normal thickness
							for _, child in ipairs(Equipment_F.Main_Data_F.Tabs_F:GetChildren()) do
								if child:IsA("Frame") then
									local itemList = (equipment_type == "Gloves") and Gloves_Data or Shorts_Data
									for _, i in ipairs(itemList) do
										if i.key == child.Name then			
											local rarityColor = Clothing_Mod.Get_Rarity_Color(i.rarity)
											child.Frame.UIStroke.Color = rarityColor
											child.Frame.UIStroke.Thickness = 2
											break
										end
									end
								end
							end

							-- Highlight the selected one
							temp.UIStroke.Thickness = 5			
						end
					else
						pcall(ctx.Remove_UI)
						Open_Shop_UI:Fire("Gloves")
					end
				end
            end))
		end
		
        local current = Clothing_Mod.Get_Player_Current_Gloves(Plr)
		
		local tab = Equipment_F.Main_Data_F.Tabs_F:FindFirstChild(current)
        if tab then
			tab.Frame.UIStroke.Thickness = 5
        end
	elseif equipment_type == "Shorts" then
		Shorts_Data = Get_Sorted_Shorts_Data()
        local c = 0
		
		for _, item in ipairs(Shorts_Data) do
			local index = item.key
			local value = item.name
			local owned = item.owned
		
		
			c = c + 1
			local temp = Equipment_F.Main_Data_F.TMP_Tab:Clone()
			temp.Parent = Equipment_F.Main_Data_F.Tabs_F
            temp.LayoutOrder = c
            temp.Name = index
            temp = temp.Frame
			temp.Name_F.Name_Txt.Text = value
		
			local rarityColor = Clothing_Mod.Get_Rarity_Color(item.rarity)
			temp.UIStroke.Color = rarityColor

			
			local owns = Clothing_Mod.Player_Owns_Shorts_Key(Plr, index)
			if not owns then
				temp.Locked_F.Visible = true
			end
			
            temp.Visible = true
            local display = Shorts:FindFirstChild(value):Clone()
            local Viewport_Camera = Instance.new("Camera")
            if display:FindFirstChild("LowerTorso") then
                display.PrimaryPart = display:FindFirstChild("LowerTorso")
            end
            display:PivotTo(CFrame.new(0,0,0))
            temp.VF.CurrentCamera = Viewport_Camera
            display.Parent = temp.VF.WorldModel
            temp.VF.WorldModel:PivotTo(CFrame.new(0,0,0))
            Viewport_Camera.Parent = temp.VF
            Viewport_Camera.CFrame = CFrame.new(0,-0.2,2)

			
			table.insert(cons, temp.Selected.MouseButton1Click:Connect(function()
				if Clothing_Mod.Get_Player_Current_Shorts(Plr) ~= index then
	                if owns then
	                    local result = Avatar_Clothing_Request:InvokeServer(equipment_type, index)
						if result == true then
							Sound_Mod.Play_Voice_Over("New_Look")
							
							Shorts_Data =  Get_Sorted_Shorts_Data()
							for i, item in ipairs(Shorts_Data) do
								local Frame = Equipment_F.Main_Data_F.Tabs_F:FindFirstChild(item.key)
								if(Frame) then
									Frame.LayoutOrder = i
								end
							end

							for _, child in ipairs(Equipment_F.Main_Data_F.Tabs_F:GetChildren()) do
								if child:IsA("Frame") then
									local itemList = (equipment_type == "Gloves") and Gloves_Data or Shorts_Data
									for _, i in ipairs(itemList) do
										if i.key == child.Name then
											
											local rarityColor = Clothing_Mod.Get_Rarity_Color(i.rarity)
											child.Frame.UIStroke.Color = rarityColor
											child.Frame.UIStroke.Thickness = 2
											break
										end
									end
								end
							end
							temp.UIStroke.Thickness = 5
						end
					else
						pcall(ctx.Remove_UI)
						Open_Shop_UI:Fire("Shorts")
					end
				end
            end))
        end
		
		-- Update UIStroke for the current shorts
		local current = Clothing_Mod.Get_Player_Current_Shorts(Plr)
		local tab = Equipment_F.Main_Data_F.Tabs_F:FindFirstChild(current)
        if tab then
			tab.Frame.UIStroke.Thickness = 5
        end
    end
end

local function Activate_Tab( Tab_Name, equipment_type)
	for _,tab in ipairs(ctx.Equipment_F.Top_Tabs_F:GetChildren()) do
		if tab:IsA("ImageButton") then
			if tab.Name == Tab_Name then
				tab.BackgroundTransparency = 0
			else
				tab.BackgroundTransparency = 1
			end
		end
	end

	EquipmentPanel:Load_Equipment(equipment_type)
end

function EquipmentPanel:SetUp(context)
	ctx = context
	Equipment_F = ctx.Equipment_F
	
    local UIGridLayout = Instance.new("UIGridLayout")
	UIGridLayout.Parent = Equipment_F.Main_Data_F.Tabs_F
    UIGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
    UIGridLayout.CellSize = UDim2.new(0.315, 0, 0.5, 0)
    UIGridLayout.CellPadding = UDim2.new(0.02, 0, 0.04, 0)
	
	MenuButtons_Mod.Setup_Base_Button({}, Equipment_F.Top_Tabs_F["Gloves Tab"], function() Activate_Tab( "Gloves Tab", "Gloves") end)
	MenuButtons_Mod.Setup_Base_Button({}, Equipment_F.Top_Tabs_F["Shorts Tab"], function() Activate_Tab( "Shorts Tab", "Shorts") end)
	
	Activate_Tab( "Gloves Tab","Gloves")
end

function EquipmentPanel:Show(ctx)
	Activate_Tab( "Gloves Tab","Gloves")
end

return EquipmentPanel
]]></ProtectedString>
								<string name="ScriptGuid">{BDEFE8CF-99BC-4E76-B75F-A1B0A427729A}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">EquipmentPanel.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC455518220C44A159CCC61F6053E9542">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local PlayerInfosPanel = {}

-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")

-- References
local Plr  = game.Players.LocalPlayer

-- Modules
local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local Country_Mod = require(Data_Mods_F:WaitForChild("Country_Mod"))
local Skin_Tone_Mod = require(Data_Mods_F:WaitForChild("Skin_Tone_Mod"))

-- Data
local Country_Data 				= Country_Mod.Get_Country_Data()

-- Variables
local context = nil
local Appearance_F = nil
local cons = {}
local Can_Edit = false
local Toggle_DropDown = false

local function DisconnectCons()
    for _, c in ipairs(cons) do
        c:Disconnect()
    end
    table.clear(cons)
end

-- Body type change constraints
local MAX_DISTANCE_FROM_SPAWN = 50 

local function IsPlayerNearSpawn(player: Player): boolean
	local character = player.Character
	if not character then return false end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return false end

	local spawn = workspace
		:WaitForChild("Main_World_F")
		:WaitForChild("Environment")
		:WaitForChild("Spawns")
		:WaitForChild("SpawnLocation")
	if not spawn or not spawn:IsA("BasePart") then return false end

	return (hrp.Position - spawn.Position).Magnitude <= MAX_DISTANCE_FROM_SPAWN
end

local function SetButtonEnabled(button: GuiButton, enabled: boolean)
	button.Active = enabled
	button.AutoButtonColor = enabled
	button.BackgroundTransparency = enabled and 0 or 0.4
end


local function BodyType_Implementation(BodyType_F)
	-- cache Player_Data once
	local playerData = Plr:WaitForChild("Player_Data", 5)
	if not playerData then
		warn("Player_Data not found for", Plr.Name)
		return
	end

	local isMaleValue = playerData:FindFirstChild("IsMale")
	if not isMaleValue then
		warn("IsMale value not found for", Plr.Name)
		return
	end

	-- current state (default true)
	local isMale = isMaleValue.Value

	-- cache buttons once
	local male_B   = BodyType_F:WaitForChild("Frame"):WaitForChild("Male_B")
	local female_B = BodyType_F:WaitForChild("Frame"):WaitForChild("Female_B")

	local function ChangeEffect(newIsMale)
		if not IsPlayerNearSpawn(Plr) then
			warn("Player too far from spawn to change body type")
			return
		end
		
		isMale = newIsMale
		isMaleValue.Value = newIsMale
	
		male_B.UIStroke.Enabled   = newIsMale
		female_B.UIStroke.Enabled = not newIsMale
	end

	-- init UI
	ChangeEffect(isMale)

	--local function UpdateUXState()
	--	local canEdit = IsPlayerNearSpawn(Plr)

	--	SetButtonEnabled(male_B, canEdit)
	--	SetButtonEnabled(female_B, canEdit)

	--	hintTxt.Visible = not canEdit
	--end

	--UpdateUXState()

	-- TODO uncomment once body switch workflow will be ok
	--table.insert(cons, male_B.MouseButton1Click:Connect(function()
	--	ChangeEffect(true)
	--end))

	--table.insert(cons, female_B.MouseButton1Click:Connect(function()
	--	ChangeEffect(false)
	--end))
	
	--table.insert(cons, RunService.Heartbeat:Connect(function()
	--	UpdateUXState()
	--end))
end

function PlayerInfosPanel:Load_Appearance()
    local Bio_V = context.PD:WaitForChild("Bio")
	local SkinTone_V = context.PD:WaitForChild("Skin Tone")
	DisconnectCons()
	
    local country, img = Country_Mod.Get_Player_Country_Data(Plr)
    local Skin_Data = Skin_Tone_Mod.Get_Skin_Tone_Data()
    Appearance_F.Country_F.Country_Flag_Img.Image = img
    Appearance_F.Country_F.Country_Txt.Text = country
    Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text = Bio_V.Value or ""
    Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
    Appearance_F.Drop_Down_Data_F.Size = UDim2.new(0.375,0,0,0)
	Appearance_F.Drop_Down_Data_F.Visible = false
	
	BodyType_Implementation (Appearance_F.BodyType_F)
	
    if SkinTone_V.Value then
        local strData = string.split(SkinTone_V.Value, ",")
        local R,G,B = tonumber(strData[1]), tonumber(strData[2]), tonumber(strData[3])
        for name, color in pairs(Skin_Data) do
            local r = math.round(color.R*255)
            local g = math.round(color.G*255)
            local b = math.round(color.B*255)
            if r == R and g == G and b == B then
                Appearance_F.Skin_Tone_F.Skin_Tone_Txt.Text = name
                Appearance_F.Skin_Tone_F.BackgroundColor3 = Color3.fromRGB(R,G,B)
                break
            end
        end
    end
    local ogText = Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text
    table.insert(cons, Appearance_F.Bio_F.Data_F.Data_Box_Txt:GetPropertyChangedSignal("Text"):Connect(function()
        local textLen = string.len(Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text)
        if Can_Edit then
            if textLen >= 25 then
                Can_Edit = false
                ogText = Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text
                Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text = ogText
                task.wait()
            end
        else
            if textLen < 25 then
                Can_Edit = true
            elseif textLen >= 25 then
                Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text = ogText
                task.wait()
            end
        end
    end))
    -- Country dropdown
    table.insert(cons, Appearance_F.Country_F.Dropdown_B.MouseButton1Click:Connect(function()
        if not Toggle_DropDown then
            Toggle_DropDown = true
            Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
            Appearance_F.Drop_Down_Data_F.Position = UDim2.new(1,0,0.225,0)
            Appearance_F.Drop_Down_Data_F.Size = UDim2.new(0.375,0,0,0)
            Appearance_F.Drop_Down_Data_F.Visible = true
            local y = 0
            local keys = {}
            for k in pairs(Country_Data) do
                table.insert(keys, k)
            end
            table.sort(keys)
            for _, country_name in pairs(keys) do
                local image = Country_Data[country_name]
                local TMP = Appearance_F.Drop_Down_Data_F.TMP_Tab:Clone()
                TMP.Name = country_name
                TMP.Data_Txt.Text = country_name
                TMP.Country_Flag_Img.Image = image
                TMP.Position = UDim2.new(0,0,y,0)
                TMP.Parent = Appearance_F.Drop_Down_Data_F.Tabs_F
                TMP.Visible = true
                table.insert(cons, TMP.Selected.MouseButton1Click:Connect(function()
                    Toggle_DropDown = false
                    TS:Create(Appearance_F.Country_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut), {Rotation = 0}):Play()
                    Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
                    task.wait(.2)
                    Appearance_F.Drop_Down_Data_F.Visible = false
                    Appearance_F.Country_F.Country_Flag_Img.Image = image
                    Appearance_F.Country_F.Country_Txt.Text = country_name
                end))
                y = y + 0.3
            end
            Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
            TS:Create(Appearance_F.Country_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut), {Rotation = 180}):Play()
        elseif Toggle_DropDown and Appearance_F.Country_F.Dropdown_B.Rotation == 180 then
            Toggle_DropDown = false
            TS:Create(Appearance_F.Country_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut), {Rotation = 0}):Play()
            Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
            task.wait(.2)
            Appearance_F.Drop_Down_Data_F.Visible = false
			Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
        end
    end))
    -- Skin tone dropdown
    table.insert(cons, Appearance_F.Skin_Tone_F.Dropdown_B.MouseButton1Click:Connect(function()
        if not Toggle_DropDown then
            Toggle_DropDown = true
            Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
            Appearance_F.Drop_Down_Data_F.Position = UDim2.new(1,0,0.475,0)
            Appearance_F.Drop_Down_Data_F.Size = UDim2.new(0.375,0,0,0)
            Appearance_F.Drop_Down_Data_F.Visible = true
            local y = 0
            local Skin_Data = Skin_Tone_Mod.Get_Skin_Tone_Data()
            for color_name, color in pairs(Skin_Data) do
                local TMP = Appearance_F.Drop_Down_Data_F.TMP_Tab:Clone()
                TMP.Name = color_name
                TMP.Data_Txt.Text = color_name
                TMP.BackgroundColor3 = color
                TMP.Country_Flag_Img.Visible = false
                TMP.Position = UDim2.new(0,0,y,0)
                TMP.Parent = Appearance_F.Drop_Down_Data_F.Tabs_F
                TMP.Visible = true
                table.insert(cons, TMP.Selected.MouseButton1Click:Connect(function()
                    Toggle_DropDown = false
                    TS:Create(Appearance_F.Skin_Tone_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut), {Rotation = 0}):Play()
                    Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
                    task.wait(.2)
                    Appearance_F.Drop_Down_Data_F.Visible = false
                    Appearance_F.Skin_Tone_F.BackgroundColor3 = color
                    Appearance_F.Skin_Tone_F.Skin_Tone_Txt.Text = color_name
                end))
                y = y + 0.3
            end
            Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
            TS:Create(Appearance_F.Skin_Tone_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut), {Rotation = 180}):Play()
        elseif Toggle_DropDown and Appearance_F.Skin_Tone_F.Dropdown_B.Rotation == 180 then
            Toggle_DropDown = false
            TS:Create(Appearance_F.Skin_Tone_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut), {Rotation = 0}):Play()
            Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375,0,0,0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
            task.wait(.2)
            Appearance_F.Drop_Down_Data_F.Visible = false
			Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
        end
    end))
end

function PlayerInfosPanel:SetUp(ctx)
	context = ctx
	Appearance_F = context.Appearance_F
end

function PlayerInfosPanel:Show()
	PlayerInfosPanel:Load_Appearance()
end

return PlayerInfosPanel
]]></ProtectedString>
								<string name="ScriptGuid">{5AE2268E-968A-41F5-BE35-326B641A5C78}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">PlayerInfosPanel.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXD25584F48CFA446899FE12D2C3970D66">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Main_F</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX353DA808CECD417BA345276073835864">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Combination_Select_F</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXF88F8C1202B242CC98507A561F1ACDD8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Animation_Preview_F</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX42BB8FD507D4427C815AB3F9D2355891">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">VF</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBXD9356A511EDA42479A436B7833997D72">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">WM</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBXD59FA99839E74285B0436F4E98A1FBFA">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Model</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="ModuleScript" referent="RBXD999563E301C45A6B2D0484E9EFE634B">
												<Properties>
													<Content name="LinkedSource"><null></null></Content>
													<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end


local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1


	local deltaTime = currentTime - lastTick
	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

	if (jumpAnimTime > 0) then
		jumpAnimTime = jumpAnimTime - deltaTime
	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			animStringValueObject.Parent = nil -- message received, delete StringValue
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end


-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
													<string name="ScriptGuid">{6466BD9E-40E6-480C-ACED-98B0A2CB3D02}</string>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Animate.client.lua</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
											</Item>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX28879201B79D4D628645BBAE4C6AA943">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Main_Data_F</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXB6F1A0428F4E47FCAE26C57FFE7B2B2A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Appearance_F</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX98AD27AF963E4BD4B4B3702EAA733350">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Gender_Preview_F</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX6E6542B7FB414EA5888417342A5DE77D">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Male_VF</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBXBCF6F4622B5B4A39AB704DAF0CB09297">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">WM</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="Folder" referent="RBX1679F0833653457D90D6EA3D80975309">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Model_M</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX6F5BA334975A420DA966BD147D16FD4F">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end


local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1


	local deltaTime = currentTime - lastTick
	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

	if (jumpAnimTime > 0) then
		jumpAnimTime = jumpAnimTime - deltaTime
	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			animStringValueObject.Parent = nil -- message received, delete StringValue
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end


-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
														<string name="ScriptGuid">{35965196-694A-4738-9DCE-1C1061BAFF2F}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Animate.client.lua</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
										</Item>
									</Item>
									<Item class="Folder" referent="RBX8CE8A469E62C46CF83A5861091B6770D">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Female_VF</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBXD4A64B59C5204658BB6303A8CF489841">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">WM</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="Folder" referent="RBX1A194F735E724AD09ABD4452E70C9BFB">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Model_F</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="ModuleScript" referent="RBX7D04190A781A443BB7315FD8A0C5F3FB">
													<Properties>
														<Content name="LinkedSource"><null></null></Content>
														<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
														<string name="ScriptGuid">{084D95C5-3109-494B-8A44-FBEACEE80BE0}</string>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">Animate.client.lua</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
												</Item>
											</Item>
										</Item>
									</Item>
								</Item>
								<Item class="Folder" referent="RBX77190A2393594158B61509661284A189">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">BodyType_F</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX2CC8D1B79141426F992AC269AD179645">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Frame</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="Folder" referent="RBXADB6BD30CAD04C77AD2365E92D96FBDC">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Female_B</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="Folder" referent="RBX226C15DD25B14E248E5F4B0C470D4960">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Female_VF</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="Folder" referent="RBX5D4E705D566A4DE7902A619D51CA78E9">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">WM</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
													<Item class="Folder" referent="RBX38369B4B67A5407AA95A995D301025D0">
														<Properties>
															<BinaryString name="AttributesSerialize"></BinaryString>
															<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
															<bool name="DefinesCapabilities">false</bool>
															<string name="Name">Model_F</string>
															<int64 name="SourceAssetId">-1</int64>
															<BinaryString name="Tags"></BinaryString>
														</Properties>
														<Item class="ModuleScript" referent="RBXF78B8457012F451AA3C89A762DA68C39">
															<Properties>
																<Content name="LinkedSource"><null></null></Content>
																<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
																<string name="ScriptGuid">{9FF3CC10-9414-4325-9DAA-A49BEA72B794}</string>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<bool name="DefinesCapabilities">false</bool>
																<string name="Name">Animate.client.lua</string>
																<int64 name="SourceAssetId">-1</int64>
																<BinaryString name="Tags"></BinaryString>
															</Properties>
														</Item>
													</Item>
												</Item>
											</Item>
										</Item>
										<Item class="Folder" referent="RBX5C019B8F501B49BB8E4732E76B417BF9">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">Male_B</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
											<Item class="Folder" referent="RBX31200E66748C41DF91C531F942A5A90A">
												<Properties>
													<BinaryString name="AttributesSerialize"></BinaryString>
													<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
													<bool name="DefinesCapabilities">false</bool>
													<string name="Name">Male_VF</string>
													<int64 name="SourceAssetId">-1</int64>
													<BinaryString name="Tags"></BinaryString>
												</Properties>
												<Item class="Folder" referent="RBX857A7FD1038D4A4D9E71962B0D277989">
													<Properties>
														<BinaryString name="AttributesSerialize"></BinaryString>
														<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
														<bool name="DefinesCapabilities">false</bool>
														<string name="Name">WM</string>
														<int64 name="SourceAssetId">-1</int64>
														<BinaryString name="Tags"></BinaryString>
													</Properties>
													<Item class="Folder" referent="RBX17BBB12934C3448BB0900929B3FDF3CF">
														<Properties>
															<BinaryString name="AttributesSerialize"></BinaryString>
															<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
															<bool name="DefinesCapabilities">false</bool>
															<string name="Name">Model_M</string>
															<int64 name="SourceAssetId">-1</int64>
															<BinaryString name="Tags"></BinaryString>
														</Properties>
														<Item class="ModuleScript" referent="RBX67980802C3104F53920D82F55EEB00DD">
															<Properties>
																<Content name="LinkedSource"><null></null></Content>
																<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end


local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1


	local deltaTime = currentTime - lastTick
	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

	if (jumpAnimTime > 0) then
		jumpAnimTime = jumpAnimTime - deltaTime
	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			animStringValueObject.Parent = nil -- message received, delete StringValue
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end


-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
																<string name="ScriptGuid">{26413EE7-F519-4CD9-A25C-651544ACE6AB}</string>
																<BinaryString name="AttributesSerialize"></BinaryString>
																<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
																<bool name="DefinesCapabilities">false</bool>
																<string name="Name">Animate.client.lua</string>
																<int64 name="SourceAssetId">-1</int64>
																<BinaryString name="Tags"></BinaryString>
															</Properties>
														</Item>
													</Item>
												</Item>
											</Item>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX7FB225C8F26A4979958E1A112D0EF750">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">League_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXD874B35AB3A848479CC3DA0C00BBE5CE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- StarterGui/Menus/League_UI/Client_League_Handle.client.lua
-- ==========================================================
-- TYPE: LocalScript (Client)
-- Unified handler for League + Tournament UI
-- ==========================================================

-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- Centralized UI handler
local UI_Handler = require(RS.Data_Mods_F.UI_LeagueTournament_Handler)

local MenuButtons_Mod 				= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 			= Channels.Bindable_Events.Toggle_Side_Buttons
local Tournament_Register			= Channels.CS_Remote_Events.Tournament_Register
local Tournament_Leave				= Channels.CS_Remote_Events.Tournament_Leave
local Tournament_Update 			= Channels.SC_Remote_Events.Tournament_Update
local Open_Leagues 					= Channels.Bindable_Events.Open_Leagues

-- UI references
local PlayerGui = player:WaitForChild("PlayerGui")
local MenusFolder = PlayerGui:WaitForChild("Menus")
local LeagueUI = MenusFolder:WaitForChild("League_UI")

local MainFrame = LeagueUI:WaitForChild("Main_F")
local Body = MainFrame:WaitForChild("Body")
local Exit_B = MainFrame:WaitForChild("Header"):WaitForChild("Exit_B")

-- League section
local LeagueSection = Body:WaitForChild("League_Section")
local LeagueLabel = LeagueSection:WaitForChild("LeagueLabel")
local RankLabel = LeagueSection:WaitForChild("RankLabel")
local WinsLabel = LeagueSection:WaitForChild("WinsLabel")

-- Tournament section
local TournamentSection = Body:WaitForChild("Tournament_Section")
local RegisterButton = TournamentSection:WaitForChild("Register_B")
local LeaveButton = TournamentSection:WaitForChild("Leave_B")
local TournamentStatus = TournamentSection:WaitForChild("StatusLabel")

-- Bind UI to centralized handler
UI_Handler:BindUI("LeagueTournament", LeagueUI)


local Cam = workspace.CurrentCamera
local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local Debounce_UI = false
local Cons = {}

-- ==========================================================
-- LOCAL STATE
-- ==========================================================
local isRegistered = false

local function updateTournamentStatus()
	if isRegistered then
		TournamentStatus.Text = "✅ Registered for Tournament"
	else
		TournamentStatus.Text = "❌ Not Registered"
	end
end

Tournament_Update.OnClientEvent:Connect(function(data)
	if data.Status == "Registered" then
		isRegistered = true
	elseif data.Status == "Unregistered" then
		isRegistered = false
	end
	updateTournamentStatus()
end)

-- ==========================================================
-- BUTTON HANDLERS
-- ==========================================================
MenuButtons_Mod.Setup_Base_Button(Cons, RegisterButton,function()
	if not isRegistered then
		Tournament_Register:FireServer()
		isRegistered = true
		updateTournamentStatus()
	end
end)

MenuButtons_Mod.Setup_Base_Button(Cons, LeaveButton,function()
	if isRegistered then
		Tournament_Leave:FireServer()
		isRegistered = false
		updateTournamentStatus()
	end
end)

-- ==========================================================
-- INITIAL DISPLAY
-- ==========================================================
updateTournamentStatus()

local stats = UI_Handler:GetCurrentLeague()
if stats then
	LeagueLabel.Text = ("Division: %s"):format(stats.Division or "Unranked")
	RankLabel.Text = ("Rank: %s"):format(stats.Rank or "-")
	WinsLabel.Text = ("Wins: %d"):format(stats.Wins or 0)
end


--====================================================
-- UI handling
--====================================================

local function Remove_UI()
	MainFrame:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	task.wait(0.25)

	local Blur = Lighting:FindFirstChild("Rewards_Blurr")
	if Blur then Blur:Destroy() end
	Cam.FieldOfView = 70
	LeagueUI.Enabled = false
	MainFrame.Position = UDim2.new(0.5, 0, 0.675, 0)
	Toggle_Side_Buttons:Fire(true, true)
	Debounce_UI = false
end

local function Display_UI()
	LeagueUI.Enabled = true
	MainFrame.Position = UDim2.new(0.5, 0, 0.675, 0)
	MainFrame.Visible = true
	MainFrame:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

	local Blur = Instance.new("BlurEffect")
	Blur.Name = "Rewards_Blurr"
	Blur.Parent = Lighting

	Toggle_Side_Buttons:Fire(false, true)
	Debounce_UI = true		
end

MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)

Open_Leagues.Event:Connect(function()
	if not Debounce_UI then
		Display_UI()
	else
		Remove_UI()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{F08E5A39-8606-4761-8066-1CF50AC14401}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_League_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX541519D5DCBF4A6186BC91D09CE3952C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Servers_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX01471E752CE040A3947341EC67027D0A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Cam = game.Workspace.CurrentCamera
local Plr = game.Players.LocalPlayer

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

local MenuButtons_Mod				= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))

local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Get_All_Server_Data			= Channels.CS_Remote_Functions.Get_All_Server_Data
local Update_All_Server_Data		= Channels.SC_Remote_Events.Update_All_Server_Data
local Teleport_To_Server			= Channels.CS_Remote_Functions.Teleport_To_Server
local Display_Data_E 				= Channels.Bindable_Events.Display_Data
local Toggle_Side_Buttons 			= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Servers 					= Channels.Bindable_Events.Open_Servers

-- UI References
local Main_F = script.Parent.Main_F
local Main_Data_F = Main_F.Main_Data_F
local Rank_B = Main_Data_F.Buttons_F.Rank_B
local Ranked_Wins_B = Main_Data_F.Buttons_F.Ranked_Wins_B
local Wins_B = Main_Data_F.Buttons_F.Wins_B
local Server_Size_B = Main_Data_F.Buttons_F.Server_Size_B
local Exit_B = Main_F.Header.Exit_B 
local Data_F = Main_Data_F.Data_F
local Tabs_F = Data_F.Tabs_F
local TMP_Tab = Data_F.Server_TMP
local Sort_Buttons = {Rank_B, Ranked_Wins_B, Server_Size_B, Wins_B}

local Debounce_C = false
local Debounce_E = false
local Debounce_UI = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if Cons[i] ~= nil then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local Core_Servers_Data = {}
task.spawn(function()
	Core_Servers_Data = Get_All_Server_Data:InvokeServer()	
end)

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

-- Transform dictionary into sorted array
local function Sort_Data_Handle(Data, Key)
	local Key_Vals = {
		['Rank'] = "Average Elo",
		['Ranked Wins'] = "Average Ranked Wins",
		['Wins'] = "Average Wins",
		['Server Size'] = "Server Size"
	}

	local Main_Key = Key_Vals[Key]

	if not Main_Key then
		return {}
	end

	local sorted = {}
	for _, v in pairs(Data) do
		table.insert(sorted, v)
	end

	table.sort(sorted, function(A, B)
		local A_Val = A[Main_Key] or 0
		local B_Val = B[Main_Key] or 0
		if Main_Key == "Server Size" then
			A_Val = #A[Main_Key]
			B_Val = #B[Main_Key]
		end
		return A_Val > B_Val
	end)

	return sorted
end

local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	task.wait(0.25)

	Tabs_F:ClearAllChildren()
	Data_F.CanvasPosition = Vector2.new(0, 0)

	local Blur = game.Lighting:FindFirstChild("Servers_Blurr")
	if Blur ~= nil then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Toggle_Side_Buttons:Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Display_UI()
	local function Reset_UI()
		Disconnect_Cons()
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)
		Tabs_F:ClearAllChildren()
		Data_F.CanvasPosition = Vector2.new(0, 0)
		Cam.FieldOfView = 70
		local Blur = game.Lighting:FindFirstChild("Servers_Blurr")
		if Blur ~= nil then
			Blur:Destroy()
		end
	end
	Reset_UI()

	local function Activate_Tab(Tab_Name)
		for _, B in ipairs(Sort_Buttons) do
			if B.Name == Tab_Name then
				B.BackgroundTransparency = 0 
			else
				B.BackgroundTransparency = 1
			end
		end
	end

	local function Populate_Data_Tabs(Sort_Type)
		local Tween_Scroll = TweenInfo.new(0.375, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
		local X_Pos, Y_Pos = 0.165, 0.225

		Tabs_F:ClearAllChildren()

		local uiGrid = Instance.new("UIGridLayout")
		uiGrid.CellPadding = UDim2.new(0.005, 0, 0.05, 0)
		uiGrid.CellSize = UDim2.new(0.32, 0, 0.35, 0)
		uiGrid.SortOrder = Enum.SortOrder.LayoutOrder
		uiGrid.Parent = Tabs_F

		local function Create_Server_Tab(Data, i)
			local Avg_Elo = Data['Average Elo'] or 0
			local Server_ID = Data['Server ID'] or -1
			local Ranked_Wins_V = Data['Average Ranked Wins'] or 0
			local Wins_V = Data['Average Wins'] or 0
			local Player_List = Data['Server Size'] or {}
			local Elo, Elo_Data = Elo_Mod.Get_Elo_Data_From_Val(Avg_Elo)

			local Tab = TMP_Tab:Clone()
			local Join_B = Tab:WaitForChild("Join_B")
			local Join_Txt = Join_B:FindFirstChildWhichIsA("TextLabel")
			local Elo_Txt = Tab:WaitForChild("Elo_F"):WaitForChild("Elo_Num_Txt")
			local Elo_Img = Tab:WaitForChild("Elo_Img")
			local Server_Size_Txt = Tab:WaitForChild("Server_Size_Txt")

			Tab.Parent = Tabs_F
			Tab.Name = "Server_" .. Server_ID
			Tab.LayoutOrder = i

			Elo_Txt.Text = Format_Number(Avg_Elo)
			Elo_Txt.TextColor3 = Elo_Data['Color']
			Elo_Img.Image = Elo_Data['Icon']
			Elo_Img.ImageColor3 = Elo_Data['Color']

			Tab:WaitForChild("Ranked_Wins_Txt").Text = Format_Number(Ranked_Wins_V)
			Tab:WaitForChild("Wins_Txt").Text = Format_Number(Wins_V)

			Server_Size_Txt.Text = #Player_List .. " / 25"
			if (#Player_List >= 25 or #Player_List == 0 or table.find(Player_List, Plr.UserId) ~= nil) then
				Server_Size_Txt.TextColor3 = Color3.new(1, 0, 0)
			else
				Server_Size_Txt.TextColor3 = Color3.new(1, 1, 1)
			end

			-- Join button handlers
			table.insert(Cons, Join_B.MouseEnter:Connect(function()
				if not Debounce_E then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")
					Join_B.ImageColor3 = Color3.fromRGB(150, 150, 150)
					Join_Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					Debounce_E = false
				end
			end))

			table.insert(Cons, Join_B.MouseLeave:Connect(function()
				Join_B.ImageColor3 = Color3.new(1, 1, 1)
				Join_Txt.TextColor3 = Color3.new(1, 1, 1)
			end))

			table.insert(Cons, Join_B.MouseButton1Click:Connect(function()
				if not Debounce_C then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(Join_B, Tween_Click, {Size = UDim2.new(0.35625, 0, 0.225, 0)}):Play()

					if Server_Size_Txt.TextColor3 == Color3.new(1, 0, 0) then
						Display_Data_E:Fire("? This Server is unavailable right now! Try Again later!", Color3.fromRGB(225, 0, 0))
					else
						local Did_Teleport = Teleport_To_Server:InvokeServer(Server_ID)
						if Did_Teleport == false then
							Display_Data_E:Fire("? Failed to Teleport! Try another Server!", Color3.fromRGB(225, 0, 0))
						end
					end

					task.wait(0.25)
					Debounce_C = false
				end
			end))

			Tab.Position = UDim2.new(X_Pos, 0, Y_Pos, 0)
			Tab.Visible = true
			X_Pos += 0.33
			if X_Pos >= 1 then
				X_Pos = 0.165
				Y_Pos += 0.4125
			end
		end

		local sorted_data = Sort_Data_Handle(Core_Servers_Data, Sort_Type)
		for i, S_Data in pairs(sorted_data) do
			if S_Data and S_Data['Server Size'] then
				--print("DEBUG create tab for", S_Data["Server ID"], "players:", #S_Data["Server Size"])
				Create_Server_Tab(S_Data, i)
			else
				--print("DEBUG skipping entry", S_Data)
			end
		end

		TS:Create(Data_F, Tween_Scroll, {CanvasPosition = Vector2.new(0, 0)}):Play()
	end

	local function Sort_Button_Handle()

		local function Button_Handle(B)
			local Key = string.gsub(B.Name, "_B", "")
			local Txt = B:FindFirstChildWhichIsA("TextLabel")
			Key = string.gsub(Key, "_", " ")

			Txt.TextColor3 = Color3.new(1, 1, 1)
			B.Size = UDim2.new(0.086, 0, 0.066, 0)

			table.insert(Cons, B.MouseEnter:Connect(function()
				if not Debounce_E then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")
					Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					Debounce_E = false
				end
			end))

			table.insert(Cons, B.MouseLeave:Connect(function()
				Txt.TextColor3 = Color3.new(1, 1, 1)
			end))

			table.insert(Cons, B.MouseButton1Click:Connect(function()
				if not Debounce_C then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(B, Tween_Click, {Size = UDim2.new(0.0645, 0, 0.0495, 0)}):Play()
					Activate_Tab(B.Name)
					Populate_Data_Tabs(Key)
					task.wait(0.25)
					Debounce_C = false
				end
			end))
		end

		for _, B in ipairs(Sort_Buttons) do
			if B and B:IsA("ImageButton") then
				Button_Handle(B)
			end
		end
	end
	Sort_Button_Handle()
	
	Activate_Tab("Rank_B")
	Populate_Data_Tabs("Rank")

	MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)

	local function Display_Main_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Servers_Blurr"
		Toggle_Side_Buttons:Fire(false, true)
		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_Main_UI()
end

Open_Servers.Event:Connect(function()
	if not Debounce_UI then
		Display_UI()
	else
		Remove_UI()
	end
end)

Update_All_Server_Data.OnClientEvent:Connect(function(New_Data)
	Core_Servers_Data = New_Data
end)
]]></ProtectedString>
							<string name="ScriptGuid">{68DB3079-2023-4BCD-BBF6-83E85D8C7AE6}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Servers_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX6F032B90254F4A63964124AF28A641CB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Skill_Tree_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXFF505BD74F9E4FE6A0CFF9E6EBE5C577">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer

local PD = Plr:WaitForChild("Player_Data")
local Char = Plr.Character

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Skill_Tree_Mod = require(Data_Mods_F:WaitForChild("Skill_Tree_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

local MenuButtons_Mod				= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))

local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Redeem_Skill_Tree_Reward		= Channels.CS_Remote_Functions.Redeem_Skill_Tree_Reward
local Toggle_Side_Buttons 			= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Skill_Tree 				= Channels.Bindable_Events.Open_Skill_Tree
local Display_Data_E 				= Channels.Bindable_Events.Display_Data

-- UI References
local Main_F = script.Parent.Main_F
local Exit_B = Main_F.Exit_B
local Data_F = Main_F.Data_F
local Tabs_F = Data_F.Tabs_F
local Update_Tabs_E = script.Parent.Update_Tabs

local Debounce_UI = false
local Debounce_C = false
local Debounce_E = false

local UNLOCKED_TRANSPARENCY = 0.8

local Skill_Tree_Data, Reward_Data = Skill_Tree_Mod.Get_All_Skill_Tree_Data()
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

local function Format_Time(sec)
	return math.floor(sec / 3600)
end

local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.25, true, nil)
	task.wait(0.25)
	
	Main_F.Visible = false
	
	Debounce_C = false
	Debounce_E = false
	Debounce_UI = false
	
	Toggle_Side_Buttons:Fire(true)
end

local function Show_Skill_Tree()
	local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
	
	local function Reset_Display()
		Main_F.Visible = false
		Main_F.Size = UDim2.new(0, 0, 0, 0)
		Data_F.Position = UDim2.new(0.5, 0, 0.5, 0)
	end
	Reset_Display()
	
	local function Tree_Button_Configs()
		--[[
			* Assess each Button
			- Have you unlocked it yet? Add Check
			- Can you redeem it? Show the Reward
			- Can you see it? Show the Locked and Requirements
			- Can't see it? Visible  = false
		]]--

		local Owned_Rewards = Skill_Tree_Mod.Compile_Skill_Tree_Data(Plr)
		
		local Reward_Vectors = {
			['Cash'] = "rbxassetid://119234133505316",
			['Gems'] = "rbxassetid://101452762537147",
			['Cash Pack'] = "rbxassetid://15365698744",
			['Ranked Move'] = "rbxassetid://107665571679632",
			['Crate'] = "rbxassetid://113984353478299",
			['Ranked Strike'] = "rbxassetid://83651269157787",
			['Emotes'] = "rbxassetid://96813195617891"
		}
		
		local Skill_Vectors = {
			['Total Wins'] = "rbxassetid://108423557329774",
			['Ranked Wins'] = "rbxassetid://84882681331411",
			['Punch Knockout Wins'] = "rbxassetid://110581737976151",
			['Leg Knockout Wins'] = "rbxassetid://136568604314712",
			['Submissions Wins'] = "rbxassetid://104272697213386",
			['Total Playtime'] = "rbxassetid://104629740938145"
		}
		
		local Skill_Txt = {
			['Total Wins'] = {" Wins!", " Win!"},
			['Ranked Wins'] = {" Ranked Wins!", " Ranked Win!"},
			['Punch Knockout Wins'] = {" KO's!", " KO!"},
			['Leg Knockout Wins'] = {" Kick KO's!", " Kick KO!"},
			['Submissions Wins'] = {" Submissions!", " Submission!"},
			['Total Playtime'] = {" Hours!", " Hour!"},
		}
		
		local function Get_Reward_Txt(R_Data)
			if(R_Data['Reward'] == "Crate")then
				return "Free Crate!"
			elseif(R_Data['Reward'] == "Emotes")then
				return "Special Emote!"
			elseif(R_Data['Reward'] == "Ranked Move")then
				return "Special Combo!"
			elseif(R_Data['Reward'] == "Ranked Strike")then
				return "Special Strike!"
			elseif(R_Data['Reward'] == "Cash Pack")then
				return "Cash Pack!"
			else
				local Amount = R_Data['Amount']
				local Text = R_Data['Reward']
				if math.round(Amount) == 1 then
					warn(Text)
					Text = string.sub(Text, 1, string.len(Text) - 1)
					warn(Text)
					warn()
				end

				return "+" .. Amount .. " " .. Text .. "!"
			end
		end
		
		local function Adjust_Frame_Position(Tab)
			--get the Difference Away from the Center Position
				--Center Position = Current Data_F Position
			local T_Pos = Tab.Position
			local X_Dif = 0.5 - T_Pos.X.Scale
			local Y_Dif = 0.5 - T_Pos.Y.Scale
			local X_Pos = 0.5 + X_Dif
			local Y_Pos = 0.5 + Y_Dif
			
			local New_Pos = UDim2.new(X_Pos, 0, Y_Pos, 0)
			Data_F:TweenPosition(New_Pos, Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
		end

		local function Configure_Data_Type(TF)
			local Key = TF.Name
			local Tabs = TF:GetChildren()
			
			local function Process_Tab(Tab)
				local Selected = Tab:FindFirstChild("Selected")
				local Main_Img = Tab:FindFirstChild("Main_Img")
				local Main_Txt = Tab:FindFirstChild("Main_Txt")
				local Tree_Index = string.gsub(Tab.Name, "Tab_", "")
				Tree_Index = tonumber(Tree_Index)
				
				local function Already_Claimed()
					if(Owned_Rewards ~= nil and Owned_Rewards[Key] ~= nil and #Owned_Rewards[Key] > 0 and 
						table.find(Owned_Rewards[Key], Tree_Index) ~= nil)then
						
						return true
					end
					return false
				end

				if(Already_Claimed())then
					--> Show the Claimed Status
					Main_Img.Image = "rbxassetid://122099475285175"
					Main_Img.ImageColor3 = Color3.new(1, 1, 1)
					
					Main_Txt.Text = "Claimed!"
					Main_Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					
					Tab.Image = "rbxassetid://104891328720619"
					Tab.ImageColor3 = Color3.new(1, 1, 1)
					
					Tab.Visible = true
					Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					
					Tab:SetAttribute("Process_Data", "Claimed")
					return "Claimed"
				end


				local function Can_Redeem_Button()
					--> Check Requirements
					local D_Val = PD:FindFirstChild(Key)
					local Max_Amount = Skill_Tree_Data[Key][Tree_Index] or math.huge
					
					if(D_Val ~= nil and D_Val.Value >= Max_Amount) then
						return true
					end
					return false
				end

				if(Can_Redeem_Button()) then
					--> Show the Reward avaiable
					local R_Data = Skill_Tree_Mod.Get_Reward_Data_Arr(Key)[Tree_Index]
					Main_Img.Image = Reward_Vectors[R_Data['Reward']]
					Main_Img.ImageColor3 = Color3.new(1, 1, 1)

					Main_Txt.Text = Get_Reward_Txt(R_Data)
					Main_Txt.TextColor3 = Color3.new(1, 1, 1)

					Tab.Image = "rbxassetid://138946019587089"
					Tab.ImageColor3 = Color3.new(1, 1, 1)
					
					Tab.Visible = true
					Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					
					Tab:SetAttribute("Process_Data", "Redeem")
					return "Redeem"
				end


				local function Can_See_On_Progress()
					--> If Ranked Wins or Total Wins, get the next 2 from their most Selected
					--> If not, get the next one
					local function Get_Starting_Index()
						local Max = 0
						local Redeemed_Vals = Owned_Rewards[Key] or {}
						
						for i = 1, #Redeemed_Vals do
							local Val = Redeemed_Vals[i]
							if(Val ~= nil)then
								local Num = tonumber(Val) 
								if(Num ~= nil and Num > Max)then
									Max = Num
								end
							end
						end
						
						return Max
					end
					local Start_Index = Get_Starting_Index()
					local Max_Index = Start_Index + 1
					
					if(Start_Index > 0 and (Key == "Total Wins" or Key == "Ranked Wins"))then
						Max_Index += 1
					end
					
					if(Tree_Index <= Max_Index)then
						return true
					end
					
					return false
				end
				
				if(Can_See_On_Progress())then
					--> Unknown					
					Main_Img.Image = Skill_Vectors[Key]
					Main_Img.ImageColor3 = Color3.new(1, 1, 1)

					if Key == "Total Playtime" then
						local hours = Format_Time(Skill_Tree_Data[Key][Tree_Index])
						local Txt = (hours <= 1) and Skill_Txt[Key][2] or Skill_Txt[Key][1]
						Main_Txt.Text = hours .. Txt
					else
						local Txt = Skill_Txt[Key]
						Txt = (math.round(Skill_Tree_Data[Key][Tree_Index]) <= 1.25) and Txt[2] or Txt[1]
						Main_Txt.Text = Format_Number(Skill_Tree_Data[Key][Tree_Index]) .. Txt
					end
					
					Main_Txt.TextColor3 = Color3.new(1, 1, 1)

					Tab.Image = "rbxassetid://138946019587089"
					Tab.ImageColor3 = Color3.new(1, 1, 1)
					
					Tab.Visible = true
					Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					
					Tab:SetAttribute("Process_Data", "Show")
					return "Show"
				else
					--Tab.Visible = false
					--Tab.Size = UDim2.new(0, 0, 0, 0)
					--Tab:SetAttribute("Process_Data", "N/A")
					--return nil
					-- LOCKED: affichage grisé/disabled
					
					Main_Img.Image = Skill_Vectors[Key]
					Main_Img.ImageColor3 = Color3.fromRGB(170,170,170)
					Main_Img.ImageTransparency = UNLOCKED_TRANSPARENCY

					local Txt = Skill_Txt[Key]
					
					if Key == "Total Playtime" then
						local hours = Format_Time(Skill_Tree_Data[Key][Tree_Index])
						local Txt = (hours <= 1) and Skill_Txt[Key][2] or Skill_Txt[Key][1]
						Main_Txt.Text = hours .. Txt
					else
						local Txt = Skill_Txt[Key]
						Txt = (math.round(Skill_Tree_Data[Key][Tree_Index]) <= 1.25) and Txt[2] or Txt[1]
						Main_Txt.Text = Format_Number(Skill_Tree_Data[Key][Tree_Index]) .. Txt
					end
					
					Main_Txt.TextColor3 = Color3.fromRGB(180,180,180)
					Main_Txt.TextTransparency = UNLOCKED_TRANSPARENCY

					Tab.Image = "rbxassetid://138946019587089"
					Tab.ImageColor3 = Color3.fromRGB(130,130,130)
					Tab.ImageTransparency = UNLOCKED_TRANSPARENCY + 0.05

					Tab.Visible = true
					Tab.Size = UDim2.new(0.125, 0, 0.25, 0)
					Tab:SetAttribute("Process_Data", "Locked")
					return "Locked"
				end
			end
			
			local function Tab_Handle(Tab)
				local Selected = Tab:FindFirstChild("Selected")
				local Main_Img = Tab:FindFirstChild("Main_Img")
				local Main_Txt = Tab:FindFirstChild("Main_Txt")
				local Tree_Index = string.gsub(Tab.Name, "Tab_", "")
				Tree_Index = tonumber(Tree_Index)
				
				Tab.Visible = false
				Tab.Size = UDim2.new(0, 0, 0, 0)
				Tab.Image = "rbxassetid://138946019587089"
				Tab.ImageColor3 = Color3.new(1, 1, 1)
				
				local Process_Data = Process_Tab(Tab)
				
				local function Click_Handle()
					local Process_D = Tab:GetAttribute("Process_Data")
					if(Process_D ~= nil and Process_D ~= "N/A")then
						if(Process_D == "Redeem")then
							--Bulk Action, Grant the Reward!
							--> Tell the Server
							--> If True, Update the Skill Tree Display and all Tab Status
							--> False?, Error Message
							
							local Res, Txt = Redeem_Skill_Tree_Reward:InvokeServer(Key, Tree_Index)
							if(Res)then
								local Is_Crate = (Main_Txt.Text == "Free Crate!")
								Display_Data_E:Fire(Txt, Color3.fromRGB(255, 170, 0))
								
								Owned_Rewards = Skill_Tree_Mod.Compile_Skill_Tree_Data(Plr)
								for i = 1, #Tabs do
									local T = Tabs[i]
									if(T ~= nil)then
										Process_Tab(T)
									end
								end
								
								--if you unlocked a Crate, remove the UI
								if(Is_Crate and Debounce_UI)then
									Remove_UI()
								end
			
							else
								local Txt = "❗ Failed to Redeem! Keep working to Unlock this Reward!"
								Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
							end
							
						elseif(Process_D == "Claimed")then
							local Txt = "✔️ You've already Claimed this Reward!"
							Display_Data_E:Fire(Txt, Color3.fromRGB(35, 244, 68))
						elseif(Process_D == "Show")then
							local Txt = "❗ Keep working to Unlock your next Reward!"
							Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
						elseif(Process_D == "Locked") then
							local Txt = "🔒 Continue pour débloquer cette récompense."
							Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
						end
					end
				end
				
				table.insert(Cons, Selected.MouseEnter:Connect(function()
					if(Debounce_E == false and Tab.Visible == true)then
						Debounce_E = true
						SE_Mod.PlaySFX(Plr, "Hover_SE")
						Tab:TweenSize(UDim2.new(0.175, 0, 0.3, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
						Tab.ImageColor3 = Color3.fromRGB(35, 244, 68)
						
						Debounce_E = false
					end
				end))
				
				table.insert(Cons, Selected.MouseLeave:Connect(function()
					if(Tab.Visible == true)then
						Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
						Tab.ImageColor3 = Color3.new(1, 1, 1)	
					end
				end))
				
				table.insert(Cons, Selected.MouseButton1Click:Connect(function()
					if(Debounce_C == false and Tab.Visible == true)then
						Debounce_C = true
						SE_Mod.PlaySFX(Plr, "Click_SE")
						TS:Create(Tab, Tween_Click, {Size = UDim2.new(0.09375, 0, 0.1875, 0)}):Play()
						Adjust_Frame_Position(Tab)
						
						Click_Handle()
						
						task.wait(0.25)
						Debounce_C = false
					end
				end))	
				
				table.insert(Cons, Update_Tabs_E.Event:Connect(function()
					Process_Data = Process_Tab(Tab)
				end))
				
				if(Process_Data ~= nil)then
					Tab.Visible = true
					Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
				end
			end
			
			for i = 1, #Tabs do
				local T = Tabs[i]
				if(T ~= nil)then
					Tab_Handle(T)
				end
			end
		end
		
		local Tab_Data_F = Tabs_F:GetChildren()
		for i = 1, #Tab_Data_F do
			local TF = Tab_Data_F[i]
			if(TF ~= nil)then
				Configure_Data_Type(TF)
			end
		end
		
	end
	Tree_Button_Configs()
	
	MenuButtons_Mod.Setup_Base_Button(Cons, Exit_B, Remove_UI, Exit_B.Selected)
	
	local function Display_UI()
		Main_F.Visible = true
		Main_F:TweenSize(UDim2.new(1, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)

		Debounce_C = false
		Debounce_E = false
		Debounce_UI = true
		
		Toggle_Side_Buttons:Fire(false)		
	end
	Display_UI()
end

Open_Skill_Tree.Event:Connect(function()
	if(Debounce_UI == false)then
		Show_Skill_Tree()
	else
		Remove_UI()
	end
end)

function Auto_Open_Handle()
	
	local function Prompt_Open_Handle()
		local function Is_Player_Not_Fighting()
			local Is_Fighting = Char:GetAttribute("Is_Fighting")
			if(Is_Fighting == nil or (Is_Fighting ~= nil and Is_Fighting == false))then
				return true
			end
			return false
		end
		
		repeat task.wait(1) until Is_Player_Not_Fighting() == true	
		
		if(Debounce_UI == false)then
			Show_Skill_Tree()
		end
	end
	
	for Skill_Key, Requirement_Vals_Arr in next, Skill_Tree_Data do
		local Data_Val = PD:WaitForChild(Skill_Key)
		Data_Val.Changed:Connect(function()
			local V = Data_Val.Value
			if(table.find(Requirement_Vals_Arr, V) ~= nil and Debounce_UI == false)then
				Prompt_Open_Handle()
			end
			Update_Tabs_E:Fire()
		end)
	end
end
Auto_Open_Handle()]]></ProtectedString>
							<string name="ScriptGuid">{B253904B-E10D-4148-BB36-41D9B77B2EC9}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Skill_Tree_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXC7972CA1DABB4965BDD2BA7D5786B3E8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Main_F</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX1D2065A30A5B4DFC8B0E8247DFBC721C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Exit_B</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXC93B77A341844FC8819E3B7E953FBE64">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Xbox</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX69124974A42741F49C3A9117B89220BF">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local updateXbox = function()
	local Mapped_Key = uis:GetStringForKeyCode(Enum.KeyCode.ButtonX)
	if(Mapped_Key == "ButtonX")then
		script.Parent.Image = "rbxassetid://115257536194509"
	else
		--PS5
		script.Parent.Image = "rbxassetid://137985933701432"
	end
	
	script.Parent.Visible = uis.GamepadEnabled
end

if uis.GamepadEnabled then
	updateXbox(true)
else
	updateXbox(false)
end
local conn2 = uis.GamepadConnected:Connect(function()
	if uis.GamepadEnabled then
		updateXbox(true)
	else
		updateXbox(false)
	end
end)
local conn2 = uis.GamepadDisconnected:Connect(function()
	if uis.GamepadEnabled then
		updateXbox(true)
	else
		updateXbox(false)
	end
end)]]></ProtectedString>
										<string name="ScriptGuid">{1E1CC367-FF26-4DE3-A883-CF634D2F41D9}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">LocalScript.client.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX33C754A251B2479293AB41C2F6483981">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">HUD</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX39E4CCE612424870A82BFDAE30A772AE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local Players:Players = game:GetService("Players")
local Player = Players.LocalPlayer

local Vendor:Folder = RS:FindFirstChild("Vendor")

local BindCurrency = require(script.BindCurrency)
local BindTopbar = require(script.BindTopbar)
local BindTools = require(script.BindTools)
local BindMenu = require(script.BindMenu)

local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 			= Channels.Bindable_Events.Toggle_Side_Buttons

local HUD:ScreenGui = script.Parent
local CurrencyFrame:Frame = HUD:WaitForChild("CurrencyIndicators")
local ToolsFrame:Frame = HUD:WaitForChild("Tools")
local MenuFrame:Frame = HUD:WaitForChild("Menu")

local function ToggleMenu(toggleValue:boolean, affectsBottomBar:boolean)
	if toggleValue then
		if Player:GetAttribute("IsTutorialRunning") then
			return
		end
	end
	CurrencyFrame.Visible = toggleValue
	MenuFrame.Visible = toggleValue
	
	if affectsBottomBar == true then
		ToolsFrame.Visible = toggleValue
	end
end

local function Init()
	Toggle_Side_Buttons.Event:Connect(ToggleMenu)
	task.spawn(BindCurrency,CurrencyFrame)
	task.spawn(BindTools,ToolsFrame)
	task.spawn(BindMenu,MenuFrame)
	task.spawn(BindTopbar)
end

Init()]]></ProtectedString>
							<string name="ScriptGuid">{2EAD9E0F-1D6C-4D93-8FAB-6AC11A81AD87}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">HUD_Handler.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXD8706549239C411EB404BD7332E22F86">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">HUD_Handler</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX11F5DCF9F0AB46E9A1AAD9D16F19DC80">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local RS = game:GetService("ReplicatedStorage")
local SS = game:GetService("SocialService")
local VCS = game:GetService("VoiceChatService")
local Plr = game.Players.LocalPlayer

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Prompt_Invite			= Channels.Bindable_Events.Prompt_Invite
local Voice_Chat_Prompt		= Channels.Bindable_Events.Voice_Chat_Prompt
local Display_Data_E 		= Channels.Bindable_Events.Display_Data

local Invite_Options = Instance.new("ExperienceInviteOptions")
Invite_Options.PromptMessage = "Invite your Friends for +10% Luck!"
Invite_Options.InviteMessageId = "bc7cffbc-7709-214a-8ecb-b6452021927d"

local function Display_Invite_UI(Show_Msg)
	local function Can_Send_Invite()
		local function Async()
			local success, errormessage = pcall(function()
				return SS:CanSendGameInviteAsync(Plr)
			end)

			if(success)then
				return true
			end
			return false
		end

		for i = 1, 3 do
			local D = Async()
			if(D)then
				return D
			end
		end

		return false
	end

	if(Show_Msg)then
		Display_Data_E:Fire("❤️ Invite your Friends to earn more Luck!", Color3.new(1, 1, 0))
	end

	if(Can_Send_Invite())then
		local function Show_Invite()
			local function Async()
				local success, errormessage = pcall(function()
					SS:PromptGameInvite(Plr, Invite_Options)
				end)

				if(success)then
					return true
				end
				return false
			end

			for i = 1, 3 do
				local D = Async()
				if(D)then
					return
				end
			end
		end
		Show_Invite()
	end
end

Prompt_Invite.Event:Connect(function()
	Display_Invite_UI(true)
end)


local function VC_Prompt()
	local function Can_Prompt_VC()
		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				VCS:IsVoiceEnabledForUserIdAsync(Plr.UserId)
			end)
			
			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end
		
		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				return D
			end
		end	
		
		return false
	end
	
	if(Can_Prompt_VC() == false)then
		local Txt = "❗ You must enable your Voice Chat within your Roblox Settings!"
		Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
	else
		local Txt = "🎤 Trash Talk with Voice Chat!"
		Display_Data_E:Fire(Txt, Color3.fromRGB(0, 170, 255))
	end
end

Voice_Chat_Prompt.Event:Connect(function()
	VC_Prompt()
end)]]></ProtectedString>
								<string name="ScriptGuid">{A9AB921F-9F3E-4630-A9B2-44633BEADB11}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Friend_Invite_Handle.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX018D32B4252F461B8571339AB4BA1784">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local Players:Players = game:GetService("Players")
local Player = Players.LocalPlayer

local PlayerDataDir:Folder = Player:WaitForChild("Player_Data")
local PlayerCash:NumberValue = PlayerDataDir:WaitForChild("Coins")
local PlayerGems:NumberValue = PlayerDataDir:WaitForChild("Gems")

-- Modules
local Utils = require(game.ReplicatedStorage.Modules.Utils)
local Find = require(RS.Vendor.Find)

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Open_Shop_UI 			= Channels.Bindable_Events.Open_Shop_UI

return function(currencyFrame:Frame, self)
	local function SetupCurrency(valueObject:NumberValue,index:string)
		local targetFrame:Frame = currencyFrame:WaitForChild(index)
		Find(targetFrame,"Currency",function(currencyField:TextLabel)
			currencyField.Text = Utils.NumToString(valueObject.Value)
			valueObject.Changed:Connect(function()
				currencyField.Text = Utils.NumToString(valueObject.Value)
			end)
		end)

		Find(targetFrame,"AddCurrency",function(addButton:ImageButton)
			addButton.Activated:Connect(function()
				Open_Shop_UI:Fire(index)
			end)
		end)
	end

	SetupCurrency(PlayerCash,"Cash")
	SetupCurrency(PlayerGems,"Gems")
end]]></ProtectedString>
								<string name="ScriptGuid">{9945A711-90B7-4950-839A-F3070A85CBAD}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">BindCurrency.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX529F78E7FB5E4C3887411C55195F2172">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local Players:Players = game:GetService("Players")
local Player = Players.LocalPlayer
local PlayerDataDir:Folder = Player:WaitForChild("Player_Data")
local PlayerCash:NumberValue = PlayerDataDir:WaitForChild("Coins")
local PlayerGems:NumberValue = PlayerDataDir:WaitForChild("Gems")

-- Modules
local Spr = require(RS.Vendor.Spr)

local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local EventsList = {
	['SkillTree'] = Channels.Bindable_Events.Open_Skill_Tree,
	['Servers'] = Channels.Bindable_Events.Open_Servers,
	['Fighter'] =Channels.Bindable_Events.Open_Equipment,
	['Combo'] = Channels.Bindable_Events.Open_Combos,
	['Codes'] = Channels.Bindable_Events.Open_Codes,
	['Stats'] = Channels.Bindable_Events.Open_Stats,
	['Shop'] = Channels.Bindable_Events.Open_Shop_UI,
	['SessionRewards'] = Channels.Bindable_Events.Open_Session_Rewards,
	['Leagues'] = Channels.Bindable_Events.Open_Leagues,
}

local function CreateButton(root:Frame)
	local newButton = Instance.new("ImageButton")
	newButton.Size = UDim2.fromScale(1,1)
	newButton.BackgroundTransparency = 1
	newButton.ImageTransparency = 1
	newButton.Parent = root
	return newButton
end

return function(menuFrame:Frame)
	local function SetupButton(entryFrame:Frame)
		local mainEntry:Frame = entryFrame:FindFirstChild("Entry")
		if not mainEntry then
			return
		end

		local entryButton:ImageButton = CreateButton(mainEntry)
		local animationLocked = false

		entryButton.MouseEnter:Connect(function()
			if animationLocked then
				return
			end
			Spr.target(mainEntry,0.6,3,{
				Size = UDim2.fromScale(1.1,1.1)
			})
		end)

		entryButton.MouseLeave:Connect(function()
			if animationLocked then
				return
			end
			Spr.target(mainEntry,0.6,3,{
				Size = UDim2.fromScale(1,1)
			})
		end)

		entryButton.Activated:Connect(function()
			animationLocked = true

			Spr.target(mainEntry,0.6,3,{
				Size = UDim2.fromScale(0.9,0.9)
			})

			task.delay(1/8,function()
				animationLocked = false
				Spr.target(mainEntry,0.6,3,{
					Size = UDim2.fromScale(1,1)
				})
			end)

			if(EventsList[entryFrame.Name] ~= nil)then
				EventsList[entryFrame.Name]:Fire()
			end
		end)
	end

	local skillTreeFrame:Frame = menuFrame:FindFirstChild("SkillTree")
	local mainFrame:Frame = menuFrame:FindFirstChild("MainFrame")
	if mainFrame then
		for _, entryFrame:Frame in mainFrame:GetChildren() do
			if not entryFrame:IsA("Frame") then
				continue
			end

			task.spawn(SetupButton,entryFrame)
		end
	end
	if skillTreeFrame then
		task.spawn(SetupButton,skillTreeFrame)
	end
end
]]></ProtectedString>
								<string name="ScriptGuid">{4013A95C-4F03-4354-83AC-25C53095C95C}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">BindMenu.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE10295F8F95045C8B40F04E8C551D9CD">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local UserInputService:UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Player:Player = Players.LocalPlayer

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Animations_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Emotes_Data = Animations_Mod.Get_Combinations("Emotes")

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local Open_Emotes_UI = Channels.Bindable_Events.Open_Emotes_UI
local ToggleFightMode = Channels.Bindable_Events.Toggle_Fight_Mode
local DisableFightMode = Channels.Bindable_Events.Disable_Fight_Mode
local ToggleFightButton = Channels.Bindable_Events.Toggle_Fight_Button
local ToggleToolsButtons = Channels.Bindable_Events.Toggle_Tools_Buttons
local OnSubmissionHandle = Channels.Bindable_Events.On_Submission_Handle
local Is_Chatbox_Typing = Channels.Bindable_Functions.Is_Chatbox_Typing 

local Spr = require(RS.Vendor.Spr)
local Main_world_F = workspace:WaitForChild("Main_World_F")
local Gameplay = Main_world_F:WaitForChild("Gameplay")
local Objects = Gameplay:WaitForChild("Objects")
local GymObjects = Objects:WaitForChild("GymObjects")
local Gym_Entry = GymObjects:WaitForChild("Gym_Entry")
local Gym_Exit = GymObjects:WaitForChild("Gym_Exit")

local function CreateButton(root:Frame)
	local newButton = Instance.new("ImageButton")
	newButton.Size = UDim2.fromScale(1,1)
	newButton.BackgroundTransparency = 1
	newButton.ImageTransparency = 1
	newButton.Parent = root
	return newButton
end

return function(toolsFrame:Frame)
	local emotesFrame:Frame = toolsFrame:WaitForChild("Emotes")
	local fightFrame:Frame = toolsFrame:WaitForChild("Fight")

	local emotesKeybind:Frame = emotesFrame:WaitForChild("Keybind")
	local fightKeybind:Frame = fightFrame:WaitForChild("Keybind")

	local emotesKey:TextLabel = emotesKeybind:WaitForChild("Keybind"):WaitForChild("Txt")
	local fightKey:TextLabel = fightKeybind:WaitForChild("Keybind"):WaitForChild("Txt")
	
	local emotesButton = CreateButton(emotesFrame)
	local fightButton = CreateButton(fightFrame)
	
	local function SetupButton(rootFrame:Frame,callback)
		local newButton = CreateButton(rootFrame)
		local animLocked = false
		newButton.MouseEnter:Connect(function()
			if animLocked then
				return
			end
			Spr.target(rootFrame,0.6,3,{
				Size = UDim2.fromScale(1.1,1.1)
			})
		end)
		newButton.MouseLeave:Connect(function()
			if animLocked then
				return
			end
			Spr.target(rootFrame,0.6,3,{
				Size = UDim2.fromScale(1,1)
			})
		end)
		newButton.Activated:Connect(function()
			animLocked = true
			Spr.target(rootFrame,0.6,3,{
				Size = UDim2.fromScale(0.9,0.9)
			})
			task.delay(1/5,function()
				animLocked = false
				Spr.target(rootFrame,0.6,3,{
					Size = UDim2.fromScale(1,1)
				})
				callback()
			end)
		end)
	end

	local function Keycode_Display_Handle()
		if(UserInputService.TouchEnabled)then
			emotesKeybind.Visible = false
			fightKeybind.Visible = false
		else
			if(UserInputService.GamepadEnabled)then
				fightKey.Text = "L1"
				emotesKey.Text = "R1"
			else
				fightKey.Text = "1"
				emotesKey.Text = "2"
			end

			emotesKeybind.Visible = true
			fightKeybind.Visible = true
		end
	end

	Keycode_Display_Handle()
	--UserInputService.LastInputTypeChanged:Connect(Keycode_Display_Handle)

	if(UserInputService.TouchEnabled == false)then
		UserInputService.InputBegan:Connect(function(input, GPE)
			if (Is_Chatbox_Typing:Invoke() == true) or not toolsFrame.Visible then
				return
			end
			
			if toolsFrame.Visible then
				if ((input.KeyCode == Enum.KeyCode.One or input.KeyCode == Enum.KeyCode.ButtonL1)) then
					if(fightFrame.Visible) then
						SE_Mod.PlaySFX(nil, "Click_SE")
						ToggleFightMode:Fire()
					end
				elseif(input.KeyCode == Enum.KeyCode.Two or input.KeyCode == Enum.KeyCode.ButtonR1)then
					if(emotesFrame.Visible) then
						SE_Mod.PlaySFX(nil, "Click_SE")
						Open_Emotes_UI:Fire()
					end
				end
			end
		end)
	end
	
	SetupButton(emotesFrame,function()
		Open_Emotes_UI:Fire()
	end)
	SetupButton(fightFrame,function()
		ToggleFightMode:Fire()
	end)
	
	
	local function Toggle_Fight_Button(Is_Enabled)
		fightFrame.Visible = Is_Enabled
	end
	
	Toggle_Fight_Button(false)

	local function Toggle_Whole_Menu(Is_Enabled)
		toolsFrame.Visible = Is_Enabled
	end
	
	ToggleFightButton.Event:Connect(function(Is_Enabled)
		Toggle_Fight_Button(Is_Enabled)
	end)
	
	ToggleToolsButtons.Event:Connect(function(Should_Show)
		Toggle_Whole_Menu(Should_Show)
	end)

	OnSubmissionHandle.Event:Connect(function(Is_Attacking, Is_Submission)
		local state = not (Is_Attacking or Is_Submission)
		Toggle_Whole_Menu(state)
	end)

	-- Detect is the player enter the gym
	local fight_button_enabled=false
	Gym_Entry.Touched:Connect(function(hit)
		if(not fight_button_enabled) then
			local character = hit.Parent
			local player = game.Players:GetPlayerFromCharacter(character)
			if player and player == game.Players.LocalPlayer then
				fight_button_enabled=true
				Toggle_Fight_Button(true)
			end
		end
	end)

	-- Detect is the player leave the gym
	Gym_Exit.Touched:Connect(function(hit)
		if(fight_button_enabled) then
			local character = hit.Parent
			local player = game.Players:GetPlayerFromCharacter(character)
			if player and player == game.Players.LocalPlayer then
				fight_button_enabled = false
				Toggle_Fight_Button(false)
				
				if character:getAttribute("Is_Fighting") then
					DisableFightMode:Fire()
				end
			end
		end
	end)

end]]></ProtectedString>
								<string name="ScriptGuid">{AF3F4E06-8635-4DFF-9F6D-F41968ADD148}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">BindTools.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX54B193BF86EC454E8B6BEF2E1E471A71">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterGui/HUD/HUD_Handler/BindTopbar.client.lua
--
--  Description:
--      Sets up and manages custom topbar buttons using TopbarPlus.
--      Provides quick access to settings, invites, changelog, tutorial,
--      and player list toggling. Handles open/close events for UI panels
--      and synchronizes button states accordingly.
--
--  Author(s): Exclusible, Darkzeb, Oriane
--
--  Last Modified: 2025-09-30 by Oriane
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/Open_Settings
--          * Channels_F/Bindable_F/Events/Close_Settings
--          * Channels_F/Bindable_F/Events/Prompt_Invite
--          * Channels_F/Bindable_F/Events/Show_Tutorial_Launcher
--          * Channels_F/Bindable_F/Events/Close_Tutorial
--          * Channels_F/Bindable_F/Events/Voice_Chat_Prompt
--          * Channels_F/Bindable_F/Events/Toggle_Player_List
--          * Channels_F/Bindable_F/Events/Toggle_TopBar
--          * Channels_F/Bindable_F/Events/Open_Changelog
--          * Channels_F/Bindable_F/Events/Close_Changelog
--          * Channels_F/Bindable_F/Events/Close_DailyRewards
--          * Vendor/TopbarPlus (preferred)
--          * TopbarPlus (fallback in ReplicatedStorage)
--      - Roblox Services:
--          * ReplicatedStorage
--          * TweenService
--
--  Notes:
--      - Requires TopbarPlus (v3 Icon API)
--      - Buttons auto-sync with UI states (deselect when closed externally)
--      - ToggleTopBar event controls visibility of all buttons
--      - Designed for client-side use only (StarterPlayerScripts)
--
--======================================================================

-- Services
local RS = game:GetService("ReplicatedStorage")
local CS = game:GetService("CollectionService")

-- Modules

local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local Open_Settings 		= Channels.Bindable_Events.Open_Settings
local Prompt_Invite 		= Channels.Bindable_Events.Prompt_Invite
local Show_Tutorial_Launcher 	= Channels.Bindable_Events.Show_Tutorial_Launcher
local Close_Tutorial 		= Channels.Bindable_Events.Close_Tutorial
local Toggle_Player_List 	= Channels.Bindable_Events.Toggle_Player_List
local Toggle_TopBar 		= Channels.Bindable_Events.Toggle_TopBar
local Open_Changelog 		= Channels.Bindable_Events.Open_Changelog
local Close_Changelog 		= Channels.Bindable_Events.Close_Changelog
local Close_Settings 		= Channels.Bindable_Events.Close_Settings
local Close_DailyRewards 	= Channels.Bindable_Events.Close_DailyRewards

local function findTopbarPlus()
	-- Priorité: Packages/TopbarPlus (Wally) -> ReplicatedStorage/TopbarPlus (modèle)
	local pkg = RS:FindFirstChild("Vendor")
	if pkg and pkg:FindFirstChild("TopbarPlus") then
		return pkg.TopbarPlus
	end
	return RS:FindFirstChild("TopbarPlus")
end


local TopbarPlusModule = findTopbarPlus()
assert(TopbarPlusModule, "TopBarPlus module not found. Place it in ReplicatedStorage or ReplicatedStorage/Packages.")

local TopbarPlus = require(TopbarPlusModule) -- retourne l’API v3 (Icon)

return function()
	-- clean top bar is already exixting, remove it
	local icons = TopbarPlus.getIcons()
	for _, icon in pairs(icons) do
		icon:Destroy()
	end
	
	-- Settings button
	local settingsButton = TopbarPlus.new()
		:align("Left")
		:setLabel("⚙️", "Deselected")
		:setLabel("❌", "Selected")
		:setCaption("Settings")

	settingsButton.toggled:Connect(function(isSelected)
		Open_Settings:Fire(isSelected)
	end)

	Close_Settings.Event:Connect(function()
		settingsButton:deselect()
	end)

	-- Invite button
	local inviteButton = TopbarPlus.new():setImage("rbxassetid://13436732683"):align("Left")
	inviteButton.toggled:Connect(function()
		Prompt_Invite:Fire()
	end)

	-- Bouton What's New (changelog) en premier
	local changelogButton = TopbarPlus.new()
		:align("Left")
		:setCaption("What's New")  
		:setLabel("📰","Deselected")
		:setLabel("❌","Selected")

	changelogButton.toggled:Connect(function(isSelected)
		if isSelected then
			Open_Changelog:Fire()
		else
			Close_Changelog:Fire()
		end
	end)

	Close_Changelog.Event:Connect(function()
		changelogButton:deselect()
	end)

	-- Tutorial button
	local helpButton = TopbarPlus.new()
		:align("Left")
		:setCaption("Tutorial")
		:setLabel("❔", "Deselected")
		:setLabel("❌", "Selected")

	local widget =	helpButton["cachedNamesToInstances"]["Widget"]
	CS:AddTag(widget, "TutorialButton")
	widget.ClipsDescendants=false
	widget.Parent.ClipsDescendants=false

	helpButton.toggled:Connect(function(isSelected)
		if isSelected then
			Show_Tutorial_Launcher:Fire()
		else
			Close_Tutorial:Fire()
		end
	end)

	Close_Tutorial.Event:Connect(function()
		helpButton:deselect()
	end)

	Show_Tutorial_Launcher.Event:Connect(function()
		helpButton:select()
	end)

	-- List button on the right side
	local listButton = TopbarPlus.new():setImage("rbxassetid://100127687172105"):align("Right")
	listButton.toggled:Connect(function(isSelected)
		Toggle_Player_List:Fire(isSelected)
	end)


	local visible = true
	Toggle_TopBar.Event:Connect(function(bool)
		if bool == nil then
			visible = not visible
		else
			visible = bool
		end

		inviteButton:setEnabled(visible)
		settingsButton:setEnabled(visible)
		changelogButton:setEnabled(visible)
		helpButton:setEnabled(visible)
		listButton:setEnabled(visible)
	end)

	-- Quand l’UI dailyrewards se ferme
	Close_DailyRewards.Event:Connect(function()
		-- commented until we find a satisfying way to pulse with TopBar plus button
		--highlightButton(changelogButton, 5)
		--highlightButton(helpButton, 5)
	end)
end

]]></ProtectedString>
								<string name="ScriptGuid">{45623E2F-2B3E-4EA8-9958-2531FD97DA03}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">BindTopbar.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXF06A011420234CEFB406C7D0D5A37E91">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CurrencyIndicators</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX0F4969BB69374C71AE075D0D4DC7CA6D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIScale</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXA369AA84B23548C8BC404596725D44F0">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local function getDevice()
	if (uis.TouchEnabled == true and uis.KeyboardEnabled == false) then
		return "Mobile"
	elseif (uis.GamepadEnabled == true) then
		return "Console"
	else
		return "PC"
	end
end

while task.wait(1) do
	local device = getDevice()
	if device ~= "Mobile" then
		script.Parent.Scale = 0.8
	else
		script.Parent.Scale = 1
	end
end]]></ProtectedString>
									<string name="ScriptGuid">{90E633FB-23F9-43BF-BC84-961A8712352A}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalScript.client.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXFCCF7F0268114184A597F1E18AC5F2BF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">HalloweenShop</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX20450BDBC50A4155B23DFECF37FA63E1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Entry</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBXFD282BDC3AFD4983B34230C59DAD4F96">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Button</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX1A7CB83A46AE49938FE6A90AE3BDD06E">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Button</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBXF283FEB048334BFEA7E3C824159BD2F0">
											<Properties>
												<Content name="LinkedSource"><null></null></Content>
												<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local gradient = script.Parent.Brush:WaitForChild("UIGradient")

local function tweenTo(offset, callback)
	local tween = TweenService:Create(
		gradient,
		TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut),
		{ Offset = offset }
	)
	tween.Completed:Connect(callback)
	tween:Play()
end

local function loop()
	tweenTo(Vector2.new(1, 0), function()
		tweenTo(Vector2.new(-1, 0), loop)
	end)
end

loop()
]]></ProtectedString>
												<string name="ScriptGuid">{1CBFFA5E-E88F-4024-B1F7-0DF59261DAC4}</string>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<string name="Name">AnimateGradient.client.lua</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX4AEA3EDD9A3845A38BC2651AED9C5F45">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Tools</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXB4ADA5AB97074541B57EE76A64A87444">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIScale</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX0A1D404864F544EE9C90301EA1064227">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local function getDevice()
	if (uis.TouchEnabled == true and uis.KeyboardEnabled == false) then
		return "Mobile"
	elseif (uis.GamepadEnabled == true) then
		return "Console"
	else
		return "PC"
	end
end

while task.wait(1) do
	local device = getDevice()
	if device ~= "Mobile" then
		script.Parent.Scale = 0.6
	else
		script.Parent.Scale = 1
	end
end]]></ProtectedString>
									<string name="ScriptGuid">{52B37F9C-AA0C-44E8-AFBC-3F18159460FA}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalScript.client.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX2CF989500CE946AE9859C56ADAF68225">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Menu</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXD0FB9CE3BA694D80A6BB0DB55A0F0276">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UIScale</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX7A9F41ED51214F668B876585B97349B0">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local function getDevice()
	if (uis.TouchEnabled == true and uis.KeyboardEnabled == false) then
		return "Mobile"
	elseif (uis.GamepadEnabled == true) then
		return "Console"
	else
		return "PC"
	end
end

while task.wait(1) do
	local device = getDevice()
	if device ~= "Mobile" then
		script.Parent.Scale = 0.8
	else
		script.Parent.Scale = 1
	end
end]]></ProtectedString>
									<string name="ScriptGuid">{D547A242-952A-452F-93A2-9C7D84253571}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalScript.client.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX8B6B486E6F9343D487AA19CC024943FD">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Player_Stats_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXD2A3DE39AA504319B9D39B3AC7BAF3DF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Cam = game.Workspace.CurrentCamera
local Plr = game.Players.LocalPlayer

-- Modules
local Data_Mods_F 					= RS:WaitForChild("Data_Mods_F")
local Elo_Mod						= require(Data_Mods_F:WaitForChild("Elo_Mod"))
local SE_Mod 						= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Country_Mod 					= require(Data_Mods_F:WaitForChild("Country_Mod"))
local Stats_Manager_Mod 			= require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local MenuButtons_Mod 				= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 			= Channels.Bindable_Events.Toggle_Side_Buttons
local Open_Stats 					= Channels.Bindable_Events.Open_Stats
local Open_Appearance 				= Channels.Bindable_Events.Open_Appearance

-- UI References
local Main_F = script.Parent.Main_F
local Stats_Main_F = Main_F.Stats_Main_F
local Exit_B = Main_F.Header.Exit_B
local Player_Display_F = Stats_Main_F.Player_Display_F
local Edit_Info_B = Player_Display_F.Edit_Info_B
local Player_Img = Player_Display_F.Player_Img
local Bio_Txt = Player_Display_F.Bio_Txt
local Player_Info_F = Player_Display_F.Player_Info_F
local Player_Name_Txt = Player_Info_F.P_Name_Txt
local Player_DisplayName_Txt = Player_Info_F.P_DisplayName_Txt
local Current_Elo_F = Player_Display_F.Current_Elo_F
local Elo_Img = Current_Elo_F.Elo_Img
local Elo_Txt = Current_Elo_F.Elo_Txt
local Main_Stats_F = Stats_Main_F.Main_Stats_F

local Debounce_C = false
local Debounce_E = false
local Debounce_UI = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end


local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	task.wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Stats_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Toggle_Side_Buttons:Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Setup_Main(T_Plr)
	if T_Plr.Name == Plr.Name then
		Edit_Info_B.Size = UDim2.new(0.225, 0, 0.15, 0)
		
		table.insert(Cons, Edit_Info_B.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				SE_Mod.PlaySFX(Plr, "Click_SE")
				TS:Create(Edit_Info_B, Tween_Click, {Size = UDim2.new(0.16875, 0, 0.1125, 0)}):Play()
				
				Remove_UI()
				Open_Appearance:Fire()
				
				task.wait(0.25)
				Debounce_C = false
			end
		end))
		
		Edit_Info_B.Visible = true
	else
		Edit_Info_B.Visible = false
	end
	
	local PD = T_Plr:WaitForChild("Player_Data")
	local data = Stats_Manager_Mod.Create_Fight_Data_Structure(T_Plr.Character)
	local Range, Amount = Elo_Mod.Get_Player_Rank_Data(T_Plr)
	local country, img = Country_Mod.Get_Player_Country_Data(T_Plr)
	
	--// Player Info
	Player_Name_Txt.Text = T_Plr.DisplayName
	Player_DisplayName_Txt.Text = "@"..T_Plr.Name
	Player_Info_F.Image = img
	Elo_Img.ImageColor3 = Range['Color']
	Elo_Img.Image = Range["Icon"]
	Elo_Txt.Text = Format_Number(Amount)
	Player_Img.Image = game.Players:GetUserThumbnailAsync(T_Plr.UserId, Enum.ThumbnailType.AvatarThumbnail, Enum.ThumbnailSize.Size420x420)
	
	--// Main Stats
	Main_Stats_F.Strike_Percentage_F.Data_Val_Txt.Text = tostring(math.floor((data["Strikes Landed"]-1)/(data["Total Strikes"]-1) * 100)).."%"
	Main_Stats_F.Dodged_Strikes_F.Data_Val_Txt.Text = Format_Number(data["Dodged Strikes"])
	Main_Stats_F.Total_Takedowns_F.Data_Val_Txt.Text = Format_Number(data["Takedowns Landed"]).."/"..Format_Number(data["Takedowns Attempted"])
	Main_Stats_F.Total_Submissions_F.Data_Val_Txt.Text = Format_Number(data["Submissions Finished"]).."/"..Format_Number(data["Submissions Attempted"])
	Main_Stats_F.Total_Knockouts_F.Data_Val_Txt.Text = Format_Number(data["Leg Knockout Wins"] + data["Punch Knockout Wins"])
	Main_Stats_F.Total_Wins_F.Data_Val_Txt.Text = Format_Number(PD["Total Wins"].Value).."/"..Format_Number(PD["Total Matches"].Value)
	Main_Stats_F.Total_Ranked_Wins_F.Data_Val_Txt.Text = Format_Number(PD["Ranked Wins"].Value).."/"..Format_Number(PD["Ranked Matches"].Value)
	Main_Stats_F.Win_Streak_F.Data_Val_Txt.Text = Format_Number(PD["Win Streak"].Value)
	
	
	if (T_Plr:WaitForChild("Player_Data"):WaitForChild("Bio").Value ~= "") then
		Bio_Txt.Text = T_Plr:WaitForChild("Player_Data"):WaitForChild("Bio").Value
	else
		Bio_Txt.Text = "No Bio"
	end

end

local function Show_UI(T_Plr)
	local function Reset_Display()
		Disconnect_Cons()
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.575, 0)

		local Stats_Blurr = game.Lighting:FindFirstChild("Stats_Blurr")
		if(Stats_Blurr ~= nil)then
			Stats_Blurr:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()
	
	Setup_Main(T_Plr)
	
	MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)

	local function Display_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Stats_Blurr"

		Toggle_Side_Buttons:Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

Open_Stats.Event:Connect(function(T_Plr)
	if(Debounce_UI == false)then
		if(T_Plr == nil)then
			T_Plr = Plr
		end
		
		Show_UI(T_Plr)
	else
		Remove_UI()
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{D97C669D-6088-4DF9-8BBD-4082E9F64854}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Player_Stats_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX5AE749C04692442EA480F3BED3422F1E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Rewards_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXCD13D203395D413683026C58511DF4A8">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local Cam = game.Workspace.CurrentCamera
local PD = Plr:WaitForChild("Player_Data")

-- Modules
local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local MenuButtons_Mod = require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local StartupUIManager	= require(RS:WaitForChild("Modules"):WaitForChild("StartupUIManager"))

local Channels = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
-- Require submodules
local DailyRewards = require(script:WaitForChild("DailyReward"))
local QuestRewards = require(script:WaitForChild("QuestsReward"))
local SessionsRewards = require(script:WaitForChild("SessionReward"))

-- Use centralized references from Channels.Remotes
local Toggle_Side_Buttons 		= Channels.Bindable_Events.Toggle_Side_Buttons
local Toggle_Tutorial_OK_Button = Channels.Bindable_Events.Toggle_Tutorial_OK_Button
local Open_Daily_Rewards 		= Channels.Bindable_Events.Open_Daily_Rewards
local Open_Session_Rewards 		= Channels.Bindable_Events.Open_Session_Rewards
local Close_DailyRewards		= Channels.Bindable_Events.Close_DailyRewards

-- UI References
local Core_UI = script.Parent.Main_F
local Exit_B = Core_UI.Header.Exit_B
local Main_Data_F = Core_UI.Main_Data_F
local Tabs_Buttons_F = Main_Data_F.Tabs_Buttons_F
local Tabs_Data = {
	["daily tab"] = {
		Frame =  Main_Data_F:WaitForChild("DailyRewards_F"),
		Show_Function = DailyRewards.Show
	}, 
	["quest tab"] = {
		Frame =Main_Data_F:WaitForChild("QuestRewards_F"),
		Show_Function = QuestRewards.Show
	},
	["session tab"] = {
		Frame = Main_Data_F:WaitForChild("SessionRewards_F"),
		Show_Function = SessionsRewards.Show
	}
}

-- Debounce variables
local Debounce_UI = false
local Debounce_C = false
local Debounce_E = false

-- Connections table
local Cons = {}
local function Disconnect_Cons()
    for i = 1, #Cons do
        if Cons[i] ~= nil then
            Cons[i]:Disconnect()
        end
    end
    table.clear(Cons)
end

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)

local function Remove_UI()
    Disconnect_Cons()
    Core_UI:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
    TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

    Core_UI.Visible = false
    Core_UI.Position = UDim2.new(0.5, 0, 0.675, 0)

    local Blur = game.Lighting:FindFirstChild("Rewards_Blurr")
    if Blur ~= nil then
        Blur:Destroy()
    end
    Cam.FieldOfView = 70
    Toggle_Side_Buttons:Fire(true, true)
    Toggle_Tutorial_OK_Button:Fire(true)
	Debounce_UI = false
	
	-- notify StartupUIManager to move to the next UI
	StartupUIManager.notifyClose("StarterGui.Menus.Rewards_UI")
end

local function Set_Init_Cam_Effects()
	Disconnect_Cons()
	Core_UI.Visible = false
	Core_UI.Position = UDim2.new(0.5, 0, 0.575, 0)
	local Inv_Blurr = game.Lighting:FindFirstChild("Rewards_Blurr")
	if Inv_Blurr ~= nil then
		Inv_Blurr:Destroy()
	end
	Cam.FieldOfView = 70
	Core_UI.Visible = true
	Core_UI:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
	local Blur = Instance.new("BlurEffect", game.Lighting)
	Blur.Name = "Rewards_Blurr"
	Toggle_Side_Buttons:Fire(false, true)
	Toggle_Tutorial_OK_Button:Fire(false)
end

-- Build context for submodules
local context = {
	PD = PD,
	 
	DailyRewards_F = Main_Data_F:WaitForChild("DailyRewards_F"), 
	QuestRewards_F = Main_Data_F:WaitForChild("QuestRewards_F"),
	SessionRewards_F =Main_Data_F:WaitForChild("SessionRewards_F")
}

-- Set up combinations and equipment panels
DailyRewards:SetUp(context)
QuestRewards:SetUp(context)
SessionsRewards:SetUp(context)

-- Display UI function
local function Display_UI(open)
    if not Core_UI.Visible then
        
		Set_Init_Cam_Effects()
		
		-- Tabs and Exit buttons handlers based on Tabs table
		for Tab_B_Name, Tab_Data in pairs(Tabs_Data) do
			local Tab_B = Tabs_Buttons_F:FindFirstChild(Tab_B_Name)
			if Tab_B:IsA("ImageButton") then
				MenuButtons_Mod.Setup_Tab_Button(Cons, Tab_B, Tabs_Buttons_F, Tabs_Data)
			end	
		end
		
		MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, Remove_UI)
		
		-- Activated the called tab
		if open == "Daily Rewards" then
			MenuButtons_Mod.Activate_Tab("daily tab", Tabs_Buttons_F, Tabs_Data) 
		elseif open == "Session Rewards" then
			MenuButtons_Mod.Activate_Tab("session tab", Tabs_Buttons_F, Tabs_Data)
		elseif open == "Quest Rewards" then
			MenuButtons_Mod.Activate_Tab("quest tab", Tabs_Buttons_F, Tabs_Data)
		end
    end
end

-- Connect open events
Open_Daily_Rewards.Event:Connect(function()
    if Debounce_UI == false then
        Debounce_UI = true
		Display_UI("Daily Rewards")
		
    else
        Remove_UI()
    end
end)

Open_Session_Rewards.Event:Connect(function()
    if Debounce_UI == false then
        Debounce_UI = true
		Display_UI("Session Rewards")
    else
        Remove_UI()
    end
end)]]></ProtectedString>
							<string name="ScriptGuid">{5187AA72-838C-4238-9D60-56CD90976471}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Rewards_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXEAB3776A53184878BEA1A05862BCC824">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Rewards_Handle</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX328EDD441CFD46139E48A121D83AEC44">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local DailyReward = {}

--------------------------------------------------------
-- // SERVICES & DEPENDENCIES
--------------------------------------------------------
local TS   = game:GetService("TweenService")
local RS   = game:GetService("ReplicatedStorage")
local Plr  = game.Players.LocalPlayer

--------------------------------------------------------
-- // CHANNELS & EVENTS
--------------------------------------------------------
local Channels              = require(RS.Modules.Channels)

local Display_Data_E 				= Channels.Bindable_Events.Display_Data
local Claim_Daily_Reward			= Channels.CS_Remote_Functions.Claim_Daily_Reward

--------------------------------------------------------
-- // MODULES & DATA
--------------------------------------------------------
local Data_Mods_F   = RS:WaitForChild("Data_Mods_F")

local Rewards_Mod 					= require(Data_Mods_F:WaitForChild("Rewards_Mod"))
local SE_Mod 		= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

--------------------------------------------------------
-- // STATE VARIABLES
--------------------------------------------------------
local context = nil
local tab_cons = {}
local Debounce_E = false
local Debounce_C = false
local Main_Data_F = nil
local D7_Tab = nil

--------------------------------------------------------
-- // UTILITY FUNCTIONS
--------------------------------------------------------

-- Disconnect all event connections
local function DisconnectCons()
	for _, c in ipairs(tab_cons) do
		c:Disconnect()
	end
	table.clear(tab_cons)
end

--------------------------------------------------------
-- // INITIAL SETUP
--------------------------------------------------------

function DailyReward:SetUp(ctx)
	context = ctx
	DisconnectCons()
	-- UI References
	Main_Data_F = context.DailyRewards_F.Data_F.Main_Data_F
	D7_Tab = context.DailyRewards_F.Data_F.Day_7

	local Claimed_Keys = Rewards_Mod.Get_Claimed_Daily_Player_Rewards(Plr)
	local Claim_Streak = Rewards_Mod.Get_Player_Retention_Streak(Plr)

	local function Claim_Reward_Handle(T, Key)
		local Reward_Data = Rewards_Mod.Get_Specific_Daily_Reward(Key)
		local PB = T:FindFirstChild("Claim_B")
		local Status_Txt = PB:FindFirstChildWhichIsA("TextLabel")
		local Reward_Img = T:FindFirstChild("Reward_Img")
		local Claimed_Img = T:FindFirstChild("Claimed_Img")
		local Claimed_Indicator = T:FindFirstChild("ClaimedIndicator")

		local Did_Claim = Claim_Daily_Reward:InvokeServer(Key)
		if(Did_Claim)then
			SE_Mod.PlaySFX(Plr, "Sold_SE")
			Display_Data_E:Fire("🎉 Successfully Claimed & Earned " .. Reward_Data['Name'], Color3.fromRGB(170, 255, 0))
			Claimed_Keys = Rewards_Mod.Get_Claimed_Daily_Player_Rewards(Plr)

			Status_Txt.Text = "Claimed!"
			Reward_Img.ImageColor3 = Color3.fromRGB(100, 100, 100)
			Claimed_Img.Visible = true
			Claimed_Indicator.Visible = true
			PB.Visible = false
		else
			Display_Data_E:Fire("❌ Failed to Claim this Reward!", Color3.new(1, 0, 0))
		end
	end

	local function Init_Tab_Update()
		local function Update_Tab(T)
			local PB = T:FindFirstChild("Claim_B")
			local Status_Txt = PB:FindFirstChildWhichIsA("TextLabel")
			local Selected = T:FindFirstChild("Selected")
			local Reward_Img = T:FindFirstChild("Reward_Img")
			local Claimed_Img = T:FindFirstChild("Claimed_Img")
			local Day_Txt = T:FindFirstChild("Day_Txt")
			local Claimed_Indicator = T:FindFirstChild("ClaimedIndicator")
			local Key = string.gsub(T.Name, "Day_", "")
			Key = tonumber(Key)
			Day_Txt.Text = "Day " .. Key

			if(table.find(Claimed_Keys, Key .. "") ~= nil)then
				Status_Txt.Text = "Claimed!"
				Reward_Img.ImageColor3 = Color3.fromRGB(100, 100, 100)
				Claimed_Img.Visible = true
				Claimed_Indicator.Visible = true
				PB.Visible = false
			else
				Reward_Img.ImageColor3 = Color3.new(1, 1, 1)
				Claimed_Img.Visible = false
				Claimed_Indicator.Visible = false
				PB.Visible = true
				if(Claim_Streak >= Key)then
					Status_Txt.Text = "CLAIM!"
				else
					Status_Txt.Text = "Soon" --"Day " .. Key
				end
			end

			table.insert(tab_cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false)then
					Debounce_E = true
					SE_Mod.PlaySFX(Plr, "Hover_SE")
					PB.ImageColor3 = Color3.fromRGB(150, 150, 150)

					Debounce_E = false
				end
			end))

			table.insert(tab_cons, Selected.MouseLeave:Connect(function()
				PB.ImageColor3 = Color3.new(1, 1, 1)
			end))	


			local function Get_Click_Size()
				if(T.Parent == Main_Data_F)then
					return UDim2.new(0.178125, 0, 0.46875, 0)
				else
					return UDim2.new(0.136875, 0, 0.46875, 0)
				end
			end

			table.insert(tab_cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")

					TS:Create(T, Tween_Click, {Size = Get_Click_Size()}):Play()

					if(Status_Txt.Text == "Claimed!")then
						Display_Data_E:Fire("✔️ You've already Claimed this Reward!", Color3.fromRGB(0, 225, 0))
					elseif(Status_Txt.Text ~= "CLAIM!")then
						Display_Data_E:Fire("❌ You can't Claim this Reward yet!", Color3.new(1, 0, 0))
					else
						Claim_Reward_Handle(T, Key)
					end

					task.wait(0.25)
					Debounce_C = false
				end
			end))	
		end

		local Tabs = Main_Data_F:GetChildren()
		for i, v in pairs(Tabs) do
			if v.ClassName == "ImageLabel" then
				Update_Tab(v)
			end
		end
		--Update Day 7 Reward Tab
		Update_Tab(D7_Tab)
	end
	Init_Tab_Update()
end

function DailyReward:Show()
	
end

--------------------------------------------------------
-- // RETURN MODULE
--------------------------------------------------------
return DailyReward
]]></ProtectedString>
								<string name="ScriptGuid">{A8B60A88-6C61-41E0-AC64-316F0BB5CEA2}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">DailyReward.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3091817C2B594A4F9C1B26D81C49B7AC">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[

local SessionReward = {}

--------------------------------------------------------
-- // SERVICES & DEPENDENCIES
--------------------------------------------------------
local RS   = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Plr  = game.Players.LocalPlayer

--------------------------------------------------------
-- // CHANNELS & EVENTS
--------------------------------------------------------
local Channels              = require(RS.Modules.Channels)
local ProgressRE     		= Channels.SC_Remote_Events.Session_Reward_Progress
local ClaimRF       		= Channels.CS_Remote_Functions.Claim_Session_Reward
local GetProgressRF  		= Channels.CS_Remote_Functions.Get_Session_Progress

--------------------------------------------------------
-- // MODULES & DATA
--------------------------------------------------------
local Data_Mods_F   = RS:WaitForChild("Data_Mods_F")
local ThemeManager 			= require(game.ReplicatedStorage.Design.ThemeManager)
local SE_Mod 		= require(Data_Mods_F:WaitForChild("Sound_Mod"))


--------------------------------------------------------
-- // STATE VARIABLES
--------------------------------------------------------
local context = nil
local tab_cons = {}
local rows = {}
local thresholds, claimed = {}, {}
local elapsed, lastServerElapsed, lastUpdateTime = 0, 0, 0
local claimsDone, maxClaimsToday = 0, 0

--------------------------------------------------------
-- // UTILITY FUNCTIONS
--------------------------------------------------------

-- Disconnect all event connections
local function DisconnectCons()
	for _, c in ipairs(tab_cons) do
		c:Disconnect()
	end
	table.clear(tab_cons)
end

--====================================================
-- Utilities
--====================================================
local function fmt(sec)
	sec = math.floor(tonumber(sec) or 0)
	if sec < 60 then
		return "<1 min"
	end
	return string.format("%d min", math.floor(sec / 60))
end

local function updateButton(row, unlocked, remaining, isClaimed, canClaim)
	local btn = row.btn
	if not btn then return end

	if isClaimed or (maxClaimsToday > 0 and claimsDone >= maxClaimsToday) then
		btn.Text = "Claimed"
		btn.Active = false
		btn.AutoButtonColor = false
		btn.BackgroundColor3 =  ThemeManager.getColorAttribute("menus.CallToAction_Disabled_Color") --Color3.fromRGB(56, 33, 9)
	elseif not unlocked then
		btn.Text = "Locked (" .. fmt(remaining) .. ")"
		btn.Active = false
		btn.AutoButtonColor = false
		btn.BackgroundColor3 =  ThemeManager.getColorAttribute("menus.CallToAction_Disabled_Color") --Color3.fromRGB(56, 33, 9)
	else
		btn.Text = "CLAIM!"
		btn.Active = true
		btn.AutoButtonColor = true
		btn.BackgroundColor3 =  ThemeManager.getColorAttribute("menus.CallToAction_Color") -- Color3.fromRGB(35, 244, 68)
	end
end

--====================================================
-- Rendering
--====================================================
local function render()
	for i, th in ipairs(thresholds) do
		local row = rows[i]
		if not row then break end

		local unlocked = elapsed >= th.t
		local remaining = math.max(0, th.t - elapsed)
		local label = row.label
		if label then
			local base = (th.reward and th.reward.label) or tostring(th.t) .. "s"
			label.Text = base
		end

		updateButton(row, unlocked, remaining, claimed[th.t], unlocked)
	end
end

--------------------------------------------------------
-- // INITIAL SETUP
--------------------------------------------------------

function SessionReward:SetUp(ctx)
	context = ctx
	DisconnectCons()
	-- UI References
	local frame = ctx.SessionRewards_F
	local holder = frame.Main_Data_F.Holder
	
	--====================================================
	-- Setup rows
	--====================================================
	for i = 1, 4 do
		local r = holder:FindFirstChild("Row" .. i)
		if r then
			rows[i] = {
				container = r,
				label = r:FindFirstChild("Label") or r:FindFirstChild("TextLabel"),
				btn = r:FindFirstChild("Button") or r:FindFirstChildWhichIsA("TextButton"),
			}
		end
	end

	--====================================================
	-- Claim button handlers
	--====================================================
	for i, row in ipairs(rows) do
		if row.btn then
			row.btn.MouseButton1Click:Connect(function()
				local th = thresholds[i]
				if not th then return end
				if claimed[th.t] or (maxClaimsToday > 0 and claimsDone >= maxClaimsToday) or elapsed < th.t then return end

				local res = ClaimRF:InvokeServer(th.t)
				if res and res.ok then
					claimed[th.t] = true
					claimsDone += 1
					SE_Mod.PlaySFX(Plr, "Sold_SE")
					render()
				end
			end)
		end
	end

	--====================================================
	-- Server progress updates
	--====================================================
	table.insert(tab_cons,ProgressRE.OnClientEvent:Connect(function(payload)
		if not payload then return end

		thresholds = payload.thresholds or thresholds
		lastServerElapsed = payload.elapsed or 0
		lastUpdateTime = os.clock()
		elapsed = lastServerElapsed
		claimsDone = payload.count or 0
		maxClaimsToday = payload.maxClaims or 0

		claimed = {}
		if typeof(payload.claimedTimes) == "string" and payload.claimedTimes ~= "" then
			for _, s in ipairs(string.split(payload.claimedTimes, ",")) do
				local n = tonumber(s)
				if n then claimed[n] = true end
			end
		end

		render()
	end))

	--====================================================
	-- Frame-based update (smoothed)
	--====================================================
	local frameUpdateInterval = 0.5
	local lastRender = 0

	table.insert(tab_cons,RunService.RenderStepped:Connect(function()
		if lastServerElapsed <= 0 then return end
		local now = os.clock()
		elapsed = lastServerElapsed + (now - lastUpdateTime)
		if now - lastRender >= frameUpdateInterval then
			render()
			lastRender = now
		end
	end))
end

function SessionReward:Show()
	-- Refresh state from server
	local payload = GetProgressRF:InvokeServer()
	if payload then
		thresholds = payload.thresholds or thresholds
		lastServerElapsed = payload.elapsed or 0
		lastUpdateTime = os.clock()
		elapsed = lastServerElapsed
		claimsDone = payload.count or 0
		maxClaimsToday = payload.maxClaims or 0

		claimed = {}
		if typeof(payload.claimedTimes) == "string" and payload.claimedTimes ~= "" then
			for _, s in ipairs(string.split(payload.claimedTimes, ",")) do
				local n = tonumber(s)
				if n then claimed[n] = true end
			end
		end
	end

	render()
end

--------------------------------------------------------
-- // RETURN MODULE
--------------------------------------------------------
return SessionReward
]]></ProtectedString>
								<string name="ScriptGuid">{C6A690B7-AABD-455F-8D07-CC7C24917F40}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">SessionReward.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXDBEDF4FEBCAE4CCABE59CDAF7F4FFD78">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local QuestsReward = {}

--------------------------------------------------------
-- // SERVICES & DEPENDENCIES
--------------------------------------------------------
local TS   = game:GetService("TweenService")
local RS   = game:GetService("ReplicatedStorage")
local Plr  = game.Players.LocalPlayer
local Cam  = game.Workspace.CurrentCamera

--------------------------------------------------------
-- // CHANNELS & EVENTS
--------------------------------------------------------
local Channels              = require(RS.Modules.Channels)

--------------------------------------------------------
-- // MODULES & DATA
--------------------------------------------------------
local Data_Mods_F   = RS:WaitForChild("Data_Mods_F")

--------------------------------------------------------
-- // STATE VARIABLES
--------------------------------------------------------
local context = nil
local tab_cons = {}

--------------------------------------------------------
-- // UTILITY FUNCTIONS
--------------------------------------------------------

-- Disconnect all event connections
local function DisconnectCons()
	for _, c in ipairs(tab_cons) do
		c:Disconnect()
	end
	table.clear(tab_cons)
end

--------------------------------------------------------
-- // INITIAL SETUP
--------------------------------------------------------

function QuestsReward:SetUp(ctx)
	context = ctx
	DisconnectCons()

end

function QuestsReward:Show()

end

--------------------------------------------------------
-- // RETURN MODULE
--------------------------------------------------------
return QuestsReward
]]></ProtectedString>
								<string name="ScriptGuid">{90E2C22E-C398-47CE-BABA-EE8C2B9791AF}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">QuestsReward.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXC7833E64B64542EBA3A59DF45D8EF4A6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Player</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX52019C4BBD1A43769A08C7E0E20D2A6A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Gym_Training_Handle_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX9E2236CC4FA14F6EBD2F3FBDD90D348A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[[
	* Server tells the Client that they are starting to train
	* Make sure the Player is not currently Fighting, Force them out Fight Mode if they are in it
	* Toggle Away Side Button UI's, add a Blurr to make sure you can't open anything up
]]--

-- Services
local TS = game:GetService("TweenService")
local RS = game:GetService("ReplicatedStorage")
local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Animation_Objs_F = game.ReplicatedStorage:WaitForChild("Animation_Objs_F")

local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes

local Toggle_Reset 					= Channels.Bindable_Events.Toggle_Reset
local Toggle_Fight_Mode  	        = Channels.Bindable_Events.Toggle_Fight_Mode
local Set_Fight_Mode_Lock 			= Channels.Bindable_Events.Set_Fight_Mode_Lock
local Toggle_Tools_Buttons 			= Channels.Bindable_Events.Toggle_Tools_Buttons

local Workout_Rep					= Channels.CS_Remote_Events.Workout_Rep
local Exit_Machine					= Channels.CS_Remote_Events.Exit_Machine

local Init_Gym_Training				= Channels.SC_Remote_Events.Init_Gym_Training

local Exit_B = script.Parent.Exit_B
local Selected = Exit_B.Selected
local Data_Txt = Exit_B.Main_Txt
local Stroke = Exit_B.UIStroke

local Debounce_C = false
local Debounce_E = false

local Destructor = nil

local Animations = {
	["Treadmill"] = {
		ID = 116881737461921,
		Looped = true,
		Speed = 1,
	},
	["SquatRack"] = {
		ID = 139820058119859,
		Looped = true,
		Speed = 0.4,
	},
	["Pusher"] = {
		ID = 123283345540993,
		Looped = true,
		Speed = 0.7,
	},
	["Dumbells"] = {
		ID = 129314989044360,
		Looped = true,
		Speed = 0.4,
	},
	["BenchPress"] = {
		ID = 100020893468451,
		Looped = true,
		Speed = 0.4,
	},
	["BenchPress2"] = {
		ID = 100020893468451,
		Looped = true,
		Speed = 0.4,
	},
	["GymFloorMat"] = {
		ID = 128818857460265,
		Looped = true,
		Speed = 0.4,
	},
	--["SquatRack"] = {
	--	ID = 000,
	--	Looped = true,
	--},
}

local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			if typeof(Cons[i]) == "function" then
				Cons[i]()
				Cons[i] = nil
			else
				Cons[i]:Disconnect()
			end
		end
	end
	table.clear(Cons)
end

local function Reset_Char_Animations(Char)
	local Hum = Char:FindFirstChild("Humanoid")
	if(Hum ~= nil)then
		local animator = Hum:WaitForChild("Animator") :: Animator
		local Ani_Tracks = animator:GetPlayingAnimationTracks()
		for i = 1, #Ani_Tracks do
			if(Ani_Tracks[i] ~= nil and string.match(Ani_Tracks[i].Name, "_Gym") == nil)then
				Ani_Tracks[i]:Stop()
				Ani_Tracks[i]:Destroy()
			end
		end
	end
end

local function Remove_UI()
	Plr.Character:WaitForChild("Humanoid").WalkSpeed = 16
	Plr.Character:WaitForChild("Humanoid").JumpPower = 50
	Plr.Character:WaitForChild("HumanoidRootPart").Anchored = false
	Reset_Char_Animations(Plr.Character)
	Disconnect_Cons()
	Exit_B:TweenPosition(UDim2.new(0.5, 0, 1.15, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
	--Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true)
	Toggle_Tools_Buttons:Fire(true)
	Toggle_Reset:Fire(true)
	
	if Destructor ~= nil then
		Destructor()
		Destructor = nil
	end
	
	task.wait(0.75)
	
	local Old_Blur = game.Lighting:FindFirstChild("Gym_Blurr")
	if(Old_Blur ~= nil)then
		Old_Blur:Destroy()
	end
	Exit_B.Position = UDim2.new(0.5, 0, 1.15, 0)
	--Exit_B.Visible = false
	
	Debounce_C = false
	Debounce_E = false
end
Remove_UI()

local function Get_Animation_Track(Name, ID)
	local function Create_Animation_Object()
		local Ani_Obj = Animation_Objs_F:FindFirstChild(Name .. "_Gym")
		if(Ani_Obj == nil)then
			Ani_Obj = Instance.new("Animation", Animation_Objs_F)
			Ani_Obj.Name = Name .. "_Ani"
			Ani_Obj.AnimationId = "rbxassetid://" .. ID
		end
		return Ani_Obj
	end
	local Ani_Obj = Create_Animation_Object()
	return Hum:LoadAnimation(Ani_Obj)
end

local function Preload_Animation_Tracks()
	local Track_Data = {
		
	}
	
	for Anim_Name, Ani_Data in next, Animations do
		local Track = Get_Animation_Track(Anim_Name, Ani_Data['ID'])
		Track.Looped = Ani_Data['Looped']
		Track_Data[Anim_Name] = Track
	end
	
	return Track_Data
end
local Preloaded_Anim_Tracks = Preload_Animation_Tracks()

local function Get_Anim_Track(Ani_Name)
	if(Preloaded_Anim_Tracks[Ani_Name] == nil)then
		local Data = Animations[Ani_Name]
		local Track = Get_Animation_Track(Ani_Name, Data['ID'])
		Track.Looped = Data['Looped']
		Preloaded_Anim_Tracks[Ani_Name] = Track
	end
	
	return Preloaded_Anim_Tracks[Ani_Name]
end

local function Show_UI()
	local function Reset_Handle()
		Disconnect_Cons()
		--Exit_B.Visible = false
		Exit_B.Position = UDim2.new(0.5, 0, 1.15, 0)
		
		local Old_Blur = game.Lighting:FindFirstChild("Gym_Blurr")
		if(Old_Blur ~= nil)then
			Old_Blur:Destroy()
		end
	end
	Reset_Handle()
	
	task.spawn(function()
		if (Char:GetAttribute("Is_Fighting")) then
			Toggle_Fight_Mode:Fire()
		end
		--Disable_Fight_Mode:Fire(true)
		--On_Submission_Handle:Fire(true, true)
		Set_Fight_Mode_Lock:Fire(true)
		
		Toggle_Reset:Fire(false)
	end)
	
	local function Setup_Training()
		for _, machine in pairs(workspace.Main_World_F.Gameplay.Objects.GymObjects.Machines:GetChildren()) do
			if (machine ~= nil and machine:FindFirstChild("Stats")) then
				if (machine:FindFirstChild("Stats"):FindFirstChild("Player_Using") ~= nil and machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == Plr.Name) then
					if (Animations[machine.Name]) then
						
						Reset_Char_Animations(Plr.Character)
						task.wait()
						local Anim_Track = Get_Anim_Track(machine.Name)
						if(Anim_Track ~= nil)then
							Anim_Track.Looped = Animations[machine.Name].Looped
							Anim_Track.Priority = Enum.AnimationPriority.Action
							Anim_Track:Play()
							Anim_Track:AdjustSpeed(Animations[machine.Name].Speed)
						end
						
						Cons[#Cons + 1] = function()
							if (Anim_Track ~= nil) then
								Anim_Track:Stop()
								Anim_Track = nil
							end
						end
						
						if (machine:FindFirstChild("Barbell") ~= nil or machine:FindFirstChild("Dumbells") ~= nil or machine.Name == "GymFloorMat") then
							table.insert(Cons, Anim_Track.DidLoop:Connect(function()
								task.wait()
								Workout_Rep:FireServer()
							end))
						end 
						
					end
					
					game:GetService("ProximityPromptService").Enabled = false
					Destructor = function()
						--On_Submission_Handle:Fire(false, false)
						Set_Fight_Mode_Lock:Fire(false)
						game:GetService("ProximityPromptService").Enabled = true
					end
					break
				end
			end
		end
	end
	Setup_Training()
	
	local function Display_Button()
		Exit_B.Visible = true
		Exit_B:TweenPosition(UDim2.new(0.5, 0, 0.925, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Gym_Blurr"
		Blur.Size = 0

		if (Char:GetAttribute("Is_Fighting")) then
			Toggle_Fight_Mode:Fire()
		end
		Toggle_Tools_Buttons:Fire(false)

		SE_Mod.Play_Voice_Over("Training")

		Debounce_C = false
		Debounce_E = false

		Plr.Character:WaitForChild("Humanoid").WalkSpeed = 0
		Plr.Character:WaitForChild("Humanoid").JumpPower = 0
		Plr.Character.PrimaryPart.AssemblyLinearVelocity = Vector3.zero
		Plr.Character.PrimaryPart.Anchored = true

		task.wait(.5)
		Plr.Character:WaitForChild("Humanoid").WalkSpeed = 0
		Plr.Character:WaitForChild("Humanoid").JumpPower = 0
		--Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false)
	end
	Display_Button()
	

	local function Button_Handle()
		local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

		Exit_B.Size = UDim2.new(0.15, 0, 0.0875, 0)
		Stroke.Color = Color3.fromRGB(35, 244, 68)
		Data_Txt.TextColor3 = Color3.new(1, 1, 1)

		table.insert(Cons, Selected.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				SE_Mod.PlaySFX(Plr, "Hover_SE")

				Stroke.Color = Color3.new(1, 0, 0)
				Data_Txt.TextColor3 = Color3.new(1, 0, 0)
				Exit_B:TweenSize(UDim2.new(0.1725, 0, 0.100625, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.25, true, nil)

				Debounce_E = false
			end
		end))

		table.insert(Cons, Selected.MouseLeave:Connect(function()
			Exit_B:TweenSize(UDim2.new(0.15, 0, 0.0875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.25, true, nil)
			Stroke.Color = Color3.fromRGB(35, 244, 68)
			Data_Txt.TextColor3 = Color3.new(1, 1, 1)
		end))

		local activated = function()
			if(Debounce_C == false)then
				Debounce_C = true
				SE_Mod.PlaySFX(Plr, "Click_SE")
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.1125, 0, 0.065625, 0)}):Play()

				task.spawn(function()
					Exit_Machine:FireServer()
				end)

				task.wait(0.25)
				Debounce_C = false
			end
		end

		table.insert(Cons, Selected.Activated:Connect(function()
			activated()
		end))
		table.insert(Cons, game:GetService("UserInputService").InputBegan:Connect(function(inp, bool)
			if bool == true then
				return
			end

			if inp.KeyCode == Enum.KeyCode.ButtonX then
				activated()
			elseif inp.KeyCode == Enum.KeyCode.X then
				activated()
			end
		end))
	end
	Button_Handle()
end


Init_Gym_Training.OnClientEvent:Connect(function(bool)
	if(bool == true)then
		Show_UI()
	else
		Remove_UI()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{B2B40CD7-0675-49B9-8FFB-B3FA35F0CBDA}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Training_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX13279E56391049BE9A371C603D7F3BB3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Exit_B</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXD8ECF19D7EBD468FA67DAB2B9814012D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Xbox</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXCFCBCCC0081F47868431385FFC2B97DD">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local updateXbox = function()
	local Mapped_Key = uis:GetStringForKeyCode(Enum.KeyCode.ButtonX)
	if(Mapped_Key == "ButtonX")then
		script.Parent.Image = "rbxassetid://115257536194509"
	else
		--PS5
		script.Parent.Image = "rbxassetid://137985933701432"
	end
	
	script.Parent.Visible = uis.GamepadEnabled
end

if uis.GamepadEnabled then
	updateXbox(true)
else
	updateXbox(false)
end
local conn2 = uis.GamepadConnected:Connect(function()
	if uis.GamepadEnabled then
		updateXbox(true)
	else
		updateXbox(false)
	end
end)
local conn2 = uis.GamepadDisconnected:Connect(function()
	if uis.GamepadEnabled then
		updateXbox(true)
	else
		updateXbox(false)
	end
end)]]></ProtectedString>
									<string name="ScriptGuid">{FC8D13FB-BA84-4A9A-968C-1A31B52D8F24}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalScript.client.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX23787AB4E2994B5694A561A59052B95D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">PC</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX7E1F68019DF640DCA211884B44358222">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local updatePC = function()
	if uis.KeyboardEnabled == true and uis.GamepadEnabled == false then
		script.Parent.Visible = true
	else
		script.Parent.Visible = false
	end
end

updatePC()
while task.wait(1) do
	updatePC()
end]]></ProtectedString>
									<string name="ScriptGuid">{B5FD1829-1877-442B-81DB-5308F3CBF9FB}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">LocalScript.client.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXDAE7841442264BBC85D1BD01B0B81DEC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Fight</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX6207DD47B8044D32BC4DF27E63E3903A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_Intro_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXDF76936F04774A599A0B3CBDBAFC346D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--> Display the Transition, Fight Data, Reset your Fight Handle and Disable it=
--> Force you into Fight Handle

-- Services
local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effects_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Bots_Mod = require(game.ReplicatedStorage.Data_Mods_F.Bots_Mod)
local BOTS_FOLDER = Bots_Mod.getBotsWorkspaceFolder()
local Utils = require(game.ReplicatedStorage.Modules.Utils)
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Controls = require(game.Players.LocalPlayer.PlayerScripts:WaitForChild("PlayerModule")):GetControls()

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Toggle_Reset 				= Channels.Bindable_Events.Toggle_Reset

local Set_Fight_Mode_Lock 		= Channels.Bindable_Events.Set_Fight_Mode_Lock
local Disable_Fight_Mode 		= Channels.Bindable_Events.Disable_Fight_Mode
local Close_Fight_Result 		= Channels.Bindable_Events.Close_Fight_Result
local Toggle_Side_Buttons 		= Channels.Bindable_Events.Toggle_Side_Buttons
local Toggle_Tools_Buttons 		= Channels.Bindable_Events.Toggle_Tools_Buttons
local Toggle_TopBar 			= Channels.Bindable_Events.Toggle_TopBar
local Transition_Fade 			= Channels.Bindable_Events.Transition_Fade_UI
local New_Round_Display 		= Channels.Bindable_Events.New_Round_Display
local Toggle_Fight_Mode 		= Channels.Bindable_Events.Toggle_Fight_Mode
local Toggle_Cutscene 			= Channels.Bindable_Events.Toggle_Cutscene


local Fight_Set_Up				= Channels.SC_Remote_Events.Fight_Set_Up
local Fight_Intro_Finished		= Channels.CS_Remote_Events.Fight_Intro_Finished
local Ready_To_Fight			= Channels.CS_Remote_Events.Ready_To_Fight

-- UI References
local Transiton_Tabs_F = script.Parent.Teleport_Transition_F
local Left_F, Right_F = Transiton_Tabs_F.Left_F, Transiton_Tabs_F.Right_F
local Covers_F = script.Parent.Covers_F
local Top_F, Bottom_F = Covers_F.Top_F, Covers_F.Bottom_F
local Player_Fight_Data_F = script.Parent.Main_F
local Top_Fight_Data_F = Player_Fight_Data_F.Top_F
local Rank_Img = Top_Fight_Data_F.Rank_Img
local Stats_Fight_Data_F = Player_Fight_Data_F.Stats_F.Data_Tabs_F

local Debounce_Display = false
local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Toggle_Player_Controls(Is_Enabled)
	local Plr_Scripts_F = Plr:FindFirstChild("PlayerScripts")
	if(Plr_Scripts_F ~= nil and Plr_Scripts_F:FindFirstChild("PlayerModule") ~= nil)then
		local P_Mod = require(Plr_Scripts_F:FindFirstChild("PlayerModule"))
		local Controls = P_Mod:GetControls()
		
		if(Controls ~= nil)then
			if(Is_Enabled)then
				Controls:Enable()
			else
				Controls:Disable()
			end
		end
	end
end

local function Set_Up_Fight(Cage_M, isBot, Target_Char, Target_HRP)
	Debounce_Display = true
	Toggle_Reset:Fire(false)

	local Is_Ranked = (Cage_M:GetAttribute("Cage_Type") or "") == "RANKED"
	local Ranked_CS_F =(Is_Ranked and Cage_M:FindFirstChild("Ranked_Cutscene_Parts_F")) or nil
	
	local function Init_Reset()
		Left_F.Visible = false
		Right_F.Visible = false
		Player_Fight_Data_F.Visible = false
		Left_F.Position = UDim2.new(-1, 0, 0, 0)
		Right_F.Position = UDim2.new(1, 0, 0, 0)
		
		Top_F.Visible = false
		Bottom_F.Visible = false
		Top_F.Position = UDim2.new(0, 0, -0.15, 0)
		Bottom_F.Position = UDim2.new(0, 0, 1.15, 0)
		Player_Fight_Data_F.Position = UDim2.new(0.5, 0, 1.5, 0)
		
		Left_F.Visible = true
		Right_F.Visible = true
		Top_F.Visible = true
		Bottom_F.Visible = true
		Player_Fight_Data_F.Visible = true
		
		Set_Fight_Mode_Lock:Fire(true)		
		Disable_Fight_Mode:Fire(true)
		Close_Fight_Result:Fire()
		Toggle_Side_Buttons:Fire(false)
		Toggle_Tools_Buttons:Fire(false)
		Toggle_TopBar:Fire(false)
		
	end
	Init_Reset()
	
	local function Configure_Name_Tag_Handle(C)
		local Name_Tag = C:FindFirstChild("Name_Tag_UI")
		local Toggle_Tabs = {"UIStroke", "Rank_F", "Connection_Img", "Device_Img", "Country_Img", 
			"Player_Name_Txt"}
		
		if(Name_Tag ~= nil and Name_Tag:FindFirstChild("Main_F") ~= nil)then
			local Main_F = Name_Tag:FindFirstChild("Main_F")
			
			for i = 1, #Toggle_Tabs do
				local Tab = Main_F:FindFirstChild(Toggle_Tabs[i])
				if(Tab ~= nil)then
					if(Tab:IsA("UIStroke"))then
						Tab.Enabled = false
					else
						Tab.Visible = false
					end
				end
			end
			
			Main_F.BackgroundTransparency = 1
			
			if(C ~= Char)then
				Name_Tag.StudsOffset = Vector3.new(0, 3, 0)
			end
			
			Name_Tag.Enabled = false
		end
	end
	Configure_Name_Tag_Handle(Char)
	Configure_Name_Tag_Handle(Target_Char)

	
	local function Show_Transition()
		--local Woosh_SE = Sound_Effects_Mod.PlaySFX(Plr, "Transition_Woosh_SE")
		Sound_Effects_Mod.PlaySFX(Plr, "Transition_Woosh_SE")
		--if(Woosh_SE ~= nil)then
		--	Woosh_SE:Play()
		--end
		
		Left_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
		Right_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
		
		wait(1)
		--On_Submission_Handle:Fire(true, true)
		Toggle_Side_Buttons:Fire(false)
		Toggle_Tools_Buttons:Fire(false)
		Toggle_TopBar:Fire(false)
		
		--if(Woosh_SE ~= nil)then
		--	Woosh_SE:Play()
		--end
		Sound_Effects_Mod.PlaySFX(Plr, "Transition_Woosh_SE")
		
		Left_F:TweenPosition(UDim2.new(-1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
		Right_F:TweenPosition(UDim2.new(1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)

		wait(0.375)
		
		Left_F.Visible = false
		Right_F.Visible = false
		Left_F.Position = UDim2.new(-1, 0, 0, 0)
		Right_F.Position = UDim2.new(1, 0, 0, 0)
	end
	Show_Transition()
	
	local function Update_Stats_Display(C)
		local C_Plr = game.Players:GetPlayerFromCharacter(C)
		local Tabs_Txt = Stats_Fight_Data_F:GetChildren()
		
		if(C_Plr ~= nil and C_Plr:FindFirstChild("Player_Data") ~= nil)then
			local PD = C_Plr:FindFirstChild("Player_Data")
			
			local function Get_Values(Key)
				local V = PD:FindFirstChild(Key)
				if(V ~= nil)then
					return V.Value
				end
				return 0
			end
			
			local function Get_Win_Percentage()
				local Wins_V = Get_Values("Total Wins")
				local Matches_V = Get_Values("Total Matches")
				if(Is_Ranked)then
					Wins_V = Get_Values("Ranked Wins")
					Matches_V = Get_Values("Ranked Matches")
				end
				
				local Dif = math.clamp(Wins_V / Matches_V, 0, 1) * 100
				if tostring(Dif) == "nan" then
					return "0%"
				end
				return math.floor(Dif) .. "%"
			end
			
			for i = 1, #Tabs_Txt do	
				local Txt = Tabs_Txt[i]
				if(Txt ~= nil)then
					local Key = Txt.Name
					if(Is_Ranked and Key == "Total Wins")then
						Key = "Ranked Wins"
					end
					
					local Data_V = PD:FindFirstChild(Key)
					if(Data_V ~= nil)then
						Txt.Text = Utils.NumToString(Data_V.Value) .. ""
					else
						Txt.Text = Get_Win_Percentage() 
					end
					
					if(Is_Ranked)then
						Txt.TextColor3 = Color3.fromRGB(255, 170, 0)
					else
						Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					end
				end
			end
			
			local Elo_Data = Elo_Mod.Get_Player_Rank_Data(C_Plr)
			Rank_Img.Image = Elo_Data['Icon'] or "rbxassetid://89194867048049"
			Rank_Img.ImageColor3 = Elo_Data['Color'] or Color3.fromRGB(170, 170, 127)
			Top_Fight_Data_F:FindFirstChild("Plr_Name_Txt").Text = C_Plr.DisplayName .. ""
			
		else
			--Bot
			for i = 1, #Tabs_Txt do	
				local Txt = Tabs_Txt[i]
				if(Txt ~= nil)then
					Txt.Text = "BOT"
					Txt.TextColor3 = Color3.fromRGB(170, 0, 0)
				end
			end
			
			local Elo_Data = Elo_Mod.Get_Player_Rank_Data(Plr)
			Rank_Img.Image = Elo_Data['Icon'] or "rbxassetid://89194867048049"
			Rank_Img.ImageColor3 = Elo_Data['Color'] or Color3.fromRGB(170, 170, 127)
			local displayName = Target_Char:GetAttribute("Display_Name") or "BOT"
			Top_Fight_Data_F:FindFirstChild("Plr_Name_Txt").Text = displayName			
		end
		
		Player_Fight_Data_F:TweenPosition(UDim2.new(0.5, 0, 0.875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.5, true, nil)
	end
	
	local function Intro_Cutscene()
		Top_F:TweenPosition(UDim2.new(0.5, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Bottom_F:TweenPosition(UDim2.new(0.5, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Toggle_Player_Controls(false)
		
		HRP.Anchored = true
		if(Is_Ranked and Ranked_CS_F ~= nil)then
			local function Play_Ranked_Cutscene()
				local Tween_Cam = TweenInfo.new(2.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
				Cam.CameraType = Enum.CameraType.Scriptable
				
				for i = 1, #Ranked_CS_F:GetChildren() do
					local P = Ranked_CS_F:FindFirstChild("P" .. i)
					if(P ~= nil)then
						if(i == 1)then
							Cam.CFrame = P.CFrame
						else
							TS:Create(Cam, Tween_Cam, {CFrame = P.CFrame}):Play()
							if(i == 3)then
								wait(2)
								Transition_Fade:Fire(0.5, 0.5)
								wait(0.5)
							else
								wait(2.5)
							end
						end
					end
				end
				
				-- Add on to this!
				-- Create a whole Walk out Sequence to display Player Stats on
				-- Spawn Players in Tunnels, have them Walk towards the Final Point
					--> Will Display Stats here instead of just having them Flex
					
			end
			Play_Ranked_Cutscene()
			
			if(HRP ~= nil and Hum ~= nil)then
				local function Move_Yourself()
					local Final_Pos = HRP.CFrame.Position + HRP.CFrame.LookVector * 110
					HRP.Anchored = false
					Hum.WalkSpeed = 10

					for i = 1, 2 do
						if(Hum ~= nil)then
							Hum:MoveTo(Final_Pos)
							wait(5)
						end
					end
				end
				task.spawn(Move_Yourself)
			end
			
			--Show yourself
			--Show the other Player
			
			local function Track_Player(T_HRP, T_Char)
				local Tween_Init = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
				local Orig_Pos = T_HRP.CFrame.Position
				local Init_Pos = Orig_Pos + T_HRP.CFrame.LookVector * ((0.75 * 10) + 7)
				local Init_Rot = CFrame.new(Init_Pos, Orig_Pos).Rotation
				local Init_CF = CFrame.new(Init_Pos) * Init_Rot
				
				Cam.CameraType = Enum.CameraType.Scriptable
				TS:Create(Cam, Tween_Init, {CFrame = Init_CF}):Play()
				wait(0.75)
				
				if(T_Char ~= nil and Char ~= nil and T_Char == Char)then
					Sound_Effects_Mod.Play_Voice_Over("Fighter_1_Intro")
				else
					Sound_Effects_Mod.Play_Voice_Over("Fighter_2_Intro")
				end
				
				local RS_Con = RunService.Stepped:Connect(function()
					if(Cam ~= nil and T_HRP ~= nil)then
						local Orig_Pos = T_HRP.CFrame.Position
						local Init_Pos = Orig_Pos + T_HRP.CFrame.LookVector * 7
						local Init_Rot = CFrame.new(Init_Pos, Orig_Pos).Rotation
						
						Cam.CFrame = CFrame.new(Init_Pos) * Init_Rot
					end
				end)
				table.insert(Cons, RS_Con)
			
				Update_Stats_Display(T_Char)
				
				wait(4.25)
				
				if(RS_Con ~= nil)then
					RS_Con:Disconnect()
					RS_Con = nil
				end
			end
			Track_Player(HRP, Char)
			
			if(Target_HRP ~= nil and Target_Char ~= nil)then
				Track_Player(Target_HRP, Target_Char)
			end
			
		else
			--Play Animation
			local Intro_Animation_Key = Plr:FindFirstChild("Player_Data"):FindFirstChild("Fight Intro Key").Value
			Animation_Mod.Play_Emote_Track_From_Key(Plr, Hum, Intro_Animation_Key, true)
			if isBot == true then
				local botHum = Target_Char:FindFirstChild("Humanoid")
				if botHum then
					Animation_Mod.Force_Play_Emote_Track_From_Key(botHum, "A", false)
				end
			end

			local RS_Con = nil
			local Tween_Init = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
			local Init_Pos = HRP.Position + HRP.CFrame.LookVector * 5
			local Look_CF = CFrame.new(Init_Pos, HRP.Position)
			local Follow_P = nil

			RS_Con = RunService.Stepped:Connect(function()
				if(Follow_P ~= nil and Cam ~= nil)then
					Cam.CFrame = CFrame.new(Cam.CFrame.Position, Follow_P.Position)
				end
			end)
			table.insert(Cons, RS_Con)

			Cam.CameraType = Enum.CameraType.Scriptable
			TS:Create(Cam, Tween_Init, {CFrame = CFrame.new(Init_Pos) * Look_CF.Rotation}):Play()
			wait(0.75)
			Follow_P = HRP
			Update_Stats_Display(Char)

			wait(3)

			if(Target_HRP ~= nil)then
				Follow_P = nil
				Init_Pos = Target_HRP.Position + Target_HRP.CFrame.LookVector * 5
				Look_CF = CFrame.new(Init_Pos, Target_HRP.Position)
				TS:Create(Cam, Tween_Init, {CFrame = CFrame.new(Init_Pos) * Look_CF.Rotation}):Play()
				Player_Fight_Data_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.25, true, nil)
				wait(0.75)
				if(Target_HRP ~= nil)then
					Follow_P = Target_HRP
				end

				Update_Stats_Display(Target_Char)

				wait(3)
				Follow_P = nil
			end

			if(RS_Con ~= nil)then
				RS_Con:Disconnect()
				RS_Con = nil
			end
		end
		
		Player_Fight_Data_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 1, true, nil)
		Top_F:TweenPosition(UDim2.new(0.5, 0, -0.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Bottom_F:TweenPosition(UDim2.new(0.5, 0, 1.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		
		Cam.CameraSubject = Hum
		Cam.CameraType = Enum.CameraType.Custom
		Cam.CFrame = Char:FindFirstChild("Head").CFrame
		Cam.FieldOfView = 70
		
		wait(1)

		Top_F.Visible = false
		Bottom_F.Visible = false
		Player_Fight_Data_F.Visible = false
		Toggle_Player_Controls(true)
		HRP.Anchored = false
	end
	
	Intro_Cutscene()
	
	New_Round_Display:Fire(1)
	
	wait(1.5) -- Temp Wait
	
	Toggle_Fight_Mode:Fire(Target_HRP, Cage_M, true)
	
	Fight_Intro_Finished:FireServer(Cage_M.Name)
	-- Server will now know we are ready for fight to actually start
	Ready_To_Fight:FireServer(Cage_M.Name)
	
	Debounce_Display = false
end

Fight_Set_Up.OnClientEvent:Connect(function(Cage_M, isBot, ...)
	workspace:SetAttribute("FIGHT_INTRO", true)
	local args = {...}
	local Target_Char, Target_HRP
	if isBot == true then
		local botName = args[1]
		repeat
			Target_Char = BOTS_FOLDER:FindFirstChild(botName)
			if Target_Char == nil then
				task.wait()
				continue
			else
				Target_HRP = Target_Char:FindFirstChild("HumanoidRootPart")
			end
		until Target_Char ~= nil and Target_HRP ~= nil
	else
		Target_Char, Target_HRP = args[1], args[2]
	end
	
	if(Debounce_Display == false) then
		Set_Up_Fight(Cage_M, isBot, Target_Char, Target_HRP)
	end
	workspace:SetAttribute("FIGHT_INTRO", nil)
end)

Toggle_Cutscene.Event:Connect(function(Is_Enabled)
	if(Is_Enabled)then
		Toggle_Side_Buttons:Fire(false)
		Toggle_Tools_Buttons:Fire(false)
		Toggle_TopBar:Fire(false)
		Top_F:TweenPosition(UDim2.new(0.5, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Bottom_F:TweenPosition(UDim2.new(0.5, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
	else
		Top_F:TweenPosition(UDim2.new(0.5, 0, -0.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Bottom_F:TweenPosition(UDim2.new(0.5, 0, 1.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Toggle_Side_Buttons:Fire(true)
		Toggle_Tools_Buttons:Fire(true)
		Toggle_TopBar:Fire(true)
	end
end)

game.Players.LocalPlayer.CharacterAdded:Connect(function() -- Fixes hard-lock after user resets in a match
	Toggle_Player_Controls(true)
end)
Toggle_Player_Controls(true)]]></ProtectedString>
							<string name="ScriptGuid">{23285777-CBE5-4C41-B608-E94E94F3A4E0}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Fight_Intro_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX093EA08139824A528A6AB162B4CF1FC1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_System_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX5E1C8777FC0A454E807BD9D9C8A8F9F2">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterPlayerScripts/Fight_System/Core/Client_Fight_Handle.client.lua
--
--  Description:
--      Central client controller for the entire Fight System.
--      Coordinates the camera rig, combat input handling, clinch
--      cutscenes, and submission mini-game. Acts as the main entry
--      point for initializing, enabling, and disabling fight mode.
--
--  Author(s): Exclusible, Oriane
--
--  Last Modified: 2025-10-08 by Oriane
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * TweenService
--          * RunService
--          * UserInputService
--          * Players
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events/End_Fight
--          * Channels_F/Bindable_F/Events/Toggle_Fight_Mode
--          * Channels_F/Bindable_F/Events/Disable_Fight_Mode
--          * Channels_F/Bindable_F/Events/Set_Fight_Mode_Lock
--          * Channels_F/Bindable_F/Events/Toggle_Binds
--          * Data_Mods_F/Animation_Mod
--          * Data_Mods_F/Sound_Mod
--      - Workspace:
--          * Main_World_F/Objects/Fight_Cages_F
--
--  Submodules:
--      * Combat_Inputs.lua       – Handles player attack, block, dodge, takedown inputs
--      * Camera_Rig.lua          – Manages camera rotation and player facing
--      * Clinch_Sequence.lua    – Controls cage clinch cinematic sequences
--      * Submission_Minigame.lua – Manages submission phase and tap-speed tracking
--
--  Notes:
--      - Initializes the entire fight logic and environment per round.
--      - Orchestrates the setup and teardown of all fight submodules.
--      - Maintains global state: Is_Hit, Is_Cage_Submission, and camera rig.
--      - Handles clean camera and animation resets after fights.
--      - Syncs client-side state with server fight events.
--      - Core dependency for all client fight interactions and UI updates.
--
--======================================================================
--// Player and Character
local Plr = game.Players.LocalPlayer

--// Character Components
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")

--// Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

--// Required Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

--// Logical Modules (split from this script)
local Combat_Inputs = require(script:WaitForChild("Combat_Inputs"))
local Camera_Rig = require(script:WaitForChild("Camera_Rig"))
local Client_Clinch_Sequence = require(script:WaitForChild("Client_Clinch_Sequence"))
local Client_Submission_Minigame = require(script:WaitForChild("Client_Submission_Minigame"))
local Fight_UI = require(script:WaitForChild("Fight_UI"))

----- REFERENCES -----


-- Events
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local End_Fight			  	= Channels.SC_Remote_Events.End_Fight
local Set_Fight_Mode_Lock 	= Channels.Bindable_Events.Set_Fight_Mode_Lock
local Toggle_Fight_Mode  	= Channels.Bindable_Events.Toggle_Fight_Mode
local Disable_Fight_Mode 	= Channels.Bindable_Events.Disable_Fight_Mode

----- OBJECTS -----
--// Workspace References
local Cam = game.Workspace.CurrentCamera

--// Variables
local Can_Enter_Fight = true
local Locked_In_Fight = false
local Fight_Walkspeed = 10
local Cam_FOV = 45
local Cam_Offset = Vector3.new(4, -3, -5)
local Min_Angle = math.rad(-35) 
local Max_Angle = math.rad(-25)
local Tween_Cam = TweenInfo.new(0.375, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
local RS_Con = nil
local Cons = {}

local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end

	RunService:UnbindFromRenderStep("UpdateLoop")

	table.clear(Cons)
end

local function Set_Cam_Adjustments(Is_Alone)
	if(Is_Alone)then
		TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
		TS:Create(Hum, Tween_Cam, {CameraOffset = Vector3.new(0, 0, 0)}):Play()
		Cam.CameraType = Enum.CameraType.Custom
	else
		TS:Create(Cam, Tween_Cam, {FieldOfView = Cam_FOV}):Play()
		TS:Create(Hum, Tween_Cam, {CameraOffset = Cam_Offset}):Play()
		Cam.CameraType = Enum.CameraType.Scriptable
	end
end

local function Reset_BG()
	if(RS_Con ~= nil)then
		RS_Con:Disconnect()
		RS_Con = nil
	end
	Disconnect_Cons()

	if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
		HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
	end

	if(Hum ~= nil)then
		Hum.AutoRotate = true
		Hum.WalkSpeed = 16
		Hum.JumpPower = 50

		Animation_Mod.Reset_Character_Animations(Char)

		Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
		Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, true)
		Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
	end

	Plr.CameraMaxZoomDistance = game.StarterPlayer.CameraMaxZoomDistance
	Plr.CameraMinZoomDistance = game.StarterPlayer.CameraMinZoomDistance

	Cam.CameraType = Enum.CameraType.Custom
	UIS.MouseBehavior = Enum.MouseBehavior.Default
	UIS.MouseIconEnabled = true
	UIS.MouseDeltaSensitivity = 1
	Hum.CameraOffset = Vector3.new(0, 0, 0)
	Cam.FieldOfView = 70
	Char:SetAttribute("Is_Fighting", false)
end

Disconnect_Cons()

Reset_BG()

Fight_UI.Update("No_Fight")

local fightInputLocked = false

Set_Fight_Mode_Lock.Event:Connect(function(bool: boolean)
	fightInputLocked = bool
end)


local function Initialize_Fight_System(Target_HRP, Cage_M)
    -- Shared state table used across modules to communicate hit and
    -- submission status.  These replicate the Is_Hit and
    -- Is_Cage_Submission flags from the original script.
    local state = {
        Is_Hit = false,
        Is_Cage_Submission = false,
    }

    -- Build environment with all required services, references and values.
    local env = {
        -- parameters 
        Fight_Walkspeed = Fight_Walkspeed,
        Cam_FOV = Cam_FOV,
        Cam_Offset = Cam_Offset,
        Min_Angle = Min_Angle,
        Max_Angle = Max_Angle,
        Tween_Cam = Tween_Cam,
		Cons = Cons,
		Cage_M = Cage_M,
		-- functions -- 
        Set_Cam_Adjustments = Set_Cam_Adjustments,
		Reset_BG = Reset_BG,
		
        -- Initial target root part can be nil if fighting free‑form
        Target_HRP = Target_HRP,
        state = state,
        RS_Con_ref = {},
    }

    -- Preload movement animation tracks for use in cut‑scenes and submissions.
    if Hum ~= nil then
        env.Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
    end

    -- Initialise camera rig; returns a BodyGyro which we store back in env.
    local bg = Camera_Rig.Setup(env)
    env.BG = bg

    -- Pull stepped connection from camera rig into global RS_Con for cleanup.
    if env.RS_Con_ref and env.RS_Con_ref.con then
        RS_Con = env.RS_Con_ref.con
    end

    -- Register combat input handlers, submission mini‑game and clinch sequence.
    Combat_Inputs.Setup(env)
	Client_Submission_Minigame.Setup(env)
	Client_Clinch_Sequence.Setup(env)
	Fight_UI.Setup(Cage_M)
end

Toggle_Fight_Mode.Event:Connect(function(Target_HRP, cage_M, forced: boolean?)
	if fightInputLocked == true and forced ~= true then
		return
	end

	if(Locked_In_Fight == false)then
		if(Char ~= nil and RS_Con == nil and Can_Enter_Fight == true)then
			Initialize_Fight_System(Target_HRP, cage_M)
			
			if(Target_HRP ~= nil)then
				Locked_In_Fight = true
				Fight_UI.Update("Cage_Fight")
				
			else 
				Fight_UI.Update("Free_Fight")
			end
		else
			Reset_BG()
			Fight_UI.Update("No_Fight_In_Gym")
		end
	end
end)


Disable_Fight_Mode.Event:Connect(function(forced: boolean?)
	if fightInputLocked == true and forced ~= true then
		return
	end

	Can_Enter_Fight = false
	Locked_In_Fight = false
	Reset_BG()
	Fight_UI.Update("No_Fight")

	wait(3)
	Can_Enter_Fight = true
end)

--// Event trigger at the end of a Cage fight
End_Fight.OnClientEvent:Connect(function(Target_Char)
	Reset_BG()

	Fight_UI.Update("No_Fight")
	Fight_UI.Reset_Name_Tag(Char)
	Fight_UI.Reset_Name_Tag(Target_Char)

	SE_Mod.PlaySFX(Plr, "Start_Fight_Bell_SE")

	Locked_In_Fight = false
	fightInputLocked = false
end)
]]></ProtectedString>
							<string name="ScriptGuid">{EE9D7629-FA23-4E9B-A6C0-8DF2F06E0ED1}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Fight_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX3AB0452D6626497C917EC7392B1764BC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Fight_Handle</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX17CFF41213814C22B4074788FF8CB484">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterGui/Fight_System_UI/Client_Fight_Handle/Combat_Inputs.lua
--
--  Description:
--      Handles all player combat inputs and related client-side logic.
--      Processes strikes, dodges, blocking, and takedowns for both 
--      desktop and mobile players. Manages camera feedback, animations,
--      sound effects, stamina usage, and hit effects for real-time fights.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-10-08 by Oriane
--
--  Version: V2025-10
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/CameraShaker
--          * Data_Mods_F/Animation_Mod
--          * Data_Mods_F/Sound_Mod
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Bindable_F/RF
--      - Workspace:
--          * Main_World_F/Objects/Fight_Cages_F
--      - Local_Events_F (script.Parent.Parent.Local_Events_F):
--          * Throwing_Strike
--          * Dodging_Strike
--          * Blocking_Strike
--          * Unblocking_Strike
--          * Release_Mobile_Blocking
--      - Player Instance:
--          * Fight_Data (Health, Block Power, Staminia, Strike Power)
--          * Character (Humanoid, HumanoidRootPart)
--
--  Notes:
--      - Detects player input (keyboard, gamepad, or touch) and translates 
--        them into combat actions.
--      - Syncs animations, stamina drain, and server-side fight events.
--      - Applies camera shakes, woosh effects, and hit feedback.
--      - Automatically adapts to mobile or desktop control schemes.
--      - Works in tandem with Client_Fight_Handle and Fight_UI_Handle.
--
--======================================================================


----- DEPENDENCIES -----

--// Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")

--// Required Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Cam_Shake_Mod = require(Data_Mods_F:WaitForChild("CameraShaker"))
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local Buttons_Mod = require(script.Parent:WaitForChild("Fight_Buttons_Mod"))

local Fight_UI = require(script.Parent:WaitForChild("Fight_UI"))


-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Show_White_Fade			= Channels.Bindable_Events.Show_White_Fade
local Release_Mobile_Blocking_E = Channels.Bindable_Events.Release_Mobile_Blocking
local Get_Mobile_Buttons_BF 	= Channels.CS_Remote_Functions.Get_Mobile_Buttons
local Throwing_Strike_E			= Channels.CS_Remote_Events.Throwing_Strike
local Dodging_Strike_E			= Channels.CS_Remote_Events.Dodging_Strike
local Unblocking_Strike_E 		= Channels.CS_Remote_Events.Unblocking_Strike
local Blocking_Strike_E  		= Channels.CS_Remote_Events.Blocking_Strike
local Is_Chatbox_Typing			= Channels.Bindable_Functions.Is_Chatbox_Typing

----- REFERENCES -----
--// Player and Character
local Plr = game.Players.LocalPlayer

--// Fight Values
local Fight_Data_F = Plr:WaitForChild("Fight_Data")

--// Character Components
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Cam = game.Workspace.CurrentCamera

local Combat_Inputs = {}

-- Main setup function.  This will register all of the connections and
-- initialise state used for combat input handling.  It is intended to be
-- called once per fight session from the main script after the character
-- and camera rig have been prepared.
function Combat_Inputs.Setup(env)
	-- Extract required objects from the environment table for readability
	local Cage_M = env.Cage_M
    local Fight_Walkspeed: number = env.Fight_Walkspeed
    local Cam_FOV: number = env.Cam_FOV
    local Cons: {any} = env.Cons
    local state = env.state
	
	-- Hard Reset Player Blocking Handle
	task.spawn(function()
		Unblocking_Strike_E:FireServer()
	end)

    -- Debounce flags specific to this module
    local Debounce_Striking = false
    local Debounce_Dodge = false
    local Debounce_Blocking = false
    local Debounce_Takedown = false

    -- Helper to build an array from a dictionary of animation tracks
    local function Create_Anim_Arr_Data(animTrackData)
        local arr = {}
        for _, animTrack in next, animTrackData do
            table.insert(arr, animTrack)
        end
        return arr
    end

    -- Retrieve references to the numeric values stored under Fight_Data_F.
    local function Get_Fight_Data_Vals()
        local vals = {}
        for _, v in ipairs(Fight_Data_F:GetChildren()) do
            if v then
                vals[v.Name] = v
            end
        end
        return vals
    end
    local fightDataVals = Get_Fight_Data_Vals()
    local Health_V = fightDataVals["Health"]
    local Blocking_Power_V = fightDataVals["Block Power"]
    local Staminia_V = fightDataVals["Staminia"]
    local Punch_Power_V = fightDataVals["Strike Power"]

    -- Pre-fetch the various animation tracks used for striking, movement and combos
    local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	
	local Combo_Punch_Index = 1
	local Combo_Punch_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(Plr, Hum, "Punch Combo")
	local Combo_Kick_Index = 1
	local Combo_Kick_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(Plr, Hum, "Kick Combo")
	
    local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)
	
	local Current_Move_Direction = Vector3.new(0, 0, 0)

    --[[
        Striking_Movement_Handle

        Handles transitioning between idle and shuffle animations based on
        humanoid movement direction.  It also adjusts the camera FOV to
        accentuate motion when the player is moving.  This behaviour is
        identical to that of the original script.
    ]]--
    local function Striking_Movement_Handle()
        -- Tweens for smoothly adjusting the camera FOV when moving or stopping
        local Cam_Move_Tween = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
        local Reset_Cam_Move_Tween = TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
        local Cam_Tween

        -- Listen for changes to the humanoid MoveDirection property
        table.insert(Cons, Hum:GetPropertyChangedSignal("MoveDirection"):Connect(function()
			local moveDir = Hum.MoveDirection
			Current_Move_Direction = moveDir
            if moveDir.Magnitude > 0 and Anim_Track_Data["Shuffle Forward"].IsPlaying == false then
                Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data["Idle"]})
                Anim_Track_Data["Shuffle Forward"]:Play()
                -- If the player is not being hit, zoom the camera slightly when moving
                if not state.Is_Hit then
                    if Cam_Tween ~= nil then
                        Cam_Tween:Cancel()
                        Cam_Tween = nil
                    end
                    Cam_Tween = TS:Create(Cam, Cam_Move_Tween, {FieldOfView = 55})
                    Cam_Tween:Play()
				end
				Char:SetAttribute("IsMoving", true)
            elseif moveDir.Magnitude <= 0 and (Anim_Track_Data["Shuffle Forward"].IsPlaying or Anim_Track_Data["Shuffle Side"].IsPlaying) then
                Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data["Idle"]})
                if not state.Is_Hit then
                    if Cam_Tween ~= nil then
                        Cam_Tween:Cancel()
                        Cam_Tween = nil
                    end
                    Cam_Tween = TS:Create(Cam, Reset_Cam_Move_Tween, {FieldOfView = Cam_FOV})
                    Cam_Tween:Play()
				end
				Char:SetAttribute("IsMoving", false)
            end
        end))

        -- Always start in the idle animation at half speed
        Anim_Track_Data["Idle"]:Play()
        Anim_Track_Data["Idle"]:AdjustSpeed(0.5)
    end
    Striking_Movement_Handle()

    --[[
        On_Hit_Effects

        Watches for reductions in the player's health and, when damage is
        detected, triggers camera shake, sweat effects and hit animations.  A
        debounce via state.Is_Hit prevents subsequent hits from retriggering
        effects until the current hit animation has finished.
    ]]--
    local function On_Hit_Effects()
        local prevHealth = Health_V.Value
        local hitAnimTrack = Striking_Anim_Tracks["Taking Hit"]

        -- Create a camera shake object on demand
        local function Cam_Shake()
            local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
                Cam.CFrame = Cam.CFrame * shakeCf
            end)
            return CS
        end
        local camShake = Cam_Shake()

        table.insert(Cons, Health_V.Changed:Connect(function()
            local currentVal = Health_V.Value
            if currentVal < prevHealth and not state.Is_Hit then
                state.Is_Hit = true
                camShake:Start()
                camShake:Shake(Cam_Shake_Mod.Presets.Bump)
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Fight_UI.Trigger_Sweat_Effect()
                task.spawn(function()
                    Animation_Mod.Play_Animation_Track(hitAnimTrack)
                    camShake:Stop()
                    -- Only reset the hit flag if the player is not in a submission hold
                    if not state.Is_Cage_Submission then
                        state.Is_Hit = false
                    end
                end)
            end
            prevHealth = currentVal
        end))
    end
    On_Hit_Effects()

    -- Utility to determine whether the targeted opponent is right handed.  This
    -- affects which blocking animation is played when the player successfully
    -- blocks a strike.  Returns true if the opponent is right handed or
    -- defaults to true when no information is available.
    local function Get_Target_Players_Hand()
        local targetHRP = env.Target_HRP
        if targetHRP and targetHRP.Parent and game.Players:GetPlayerFromCharacter(targetHRP.Parent) then
            local targetPlr = game.Players:GetPlayerFromCharacter(targetHRP.Parent)
            local targetPD = targetPlr:FindFirstChild("Player_Data")
            if targetPD and targetPD:FindFirstChild("Right Handed") then
                return targetPD:FindFirstChild("Right Handed").Value
            end
        end
        return true
    end

    -- Play the block loop animation while the player is holding block.  The
    -- original code uses a coroutine to avoid yielding in the main thread.
    local function Play_Blocking_Animation()
        local anim = Striking_Anim_Tracks["Main Block"]
        if anim then
            anim:Play()
            anim:AdjustSpeed(1)
            wait(anim.Length * 0.9)
            if anim and Debounce_Blocking then
                anim:AdjustSpeed(0)
            end
        end
    end

    --[[
        Blocking_Effects

        Listens for reductions in the blocking power value while the player
        maintains a block.  When damage is blocked, the appropriate body
        block animation is played depending on whether the opponent is
        right or left handed.  If the block key is still held down at the
        end of the animation then the block loop animation is restarted.
    ]]--
    local function Blocking_Effects()
        local prevBlocking = Blocking_Power_V.Value
        -- Helper to choose which body block animation to play based on the
        -- opponent's handedness.
        local function Get_Blocking_Animation()
            if Get_Target_Players_Hand() then
                return Striking_Anim_Tracks["Body Block Left"]
            else
                return Striking_Anim_Tracks["Body Block Right"]
            end
        end
        table.insert(Cons, Blocking_Power_V.Changed:Connect(function()
            local currentVal = Blocking_Power_V.Value
            if currentVal > 0 and currentVal < prevBlocking and Debounce_Blocking then
                Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
                Animation_Mod.Play_Animation_Track(Get_Blocking_Animation())
                if Debounce_Blocking then
                    task.spawn(Play_Blocking_Animation)
                end
            end
            prevBlocking = currentVal
        end))
    end
    Blocking_Effects()

    --[[
        Strike_Power_Handle

        Keeps the client side damage bar updated by firing a bindable event
        whenever the player's strike power value changes.  This replicates
        the behaviour of the original script which updated the UI whenever
        Punch_Power_V changed.
    ]]--
    local function Strike_Power_Handle()
		local function updateDamageBar()
			Fight_UI.Update_Damage_Bar(Punch_Power_V)
        end
        updateDamageBar()
        table.insert(Cons, Punch_Power_V.Changed:Connect(function()
            updateDamageBar()
        end))
    end
    Strike_Power_Handle()

    --[[
        Client_Striking_Handle

        Orchestrates all combat actions triggered by player input.  This
        includes striking, dodging, blocking and takedown attempts.  Input is
        processed differently on desktop versus mobile devices, but the
        underlying logic remains the same between platforms.
    ]]--
	local function Client_Striking_Handle()
		local Stamina_Params = Fight_Params_Mod.Stamina
		
		local function incrementIndex(value, max)
			local index = value+1
			if index > max then 
				index = 1 
			end
			return index
		end
		
        --[[
            Strike_Handle

            Handles a single punch.  Plays a random woosh sound, fires the
            server remote to signal a strike, plays the appropriate combo
            animation, and manages the combo index.  This function uses
            Debounce_Striking to prevent repeated strikes while a punch is
            already in progress.
        ]]--
		local function Strike_Handle(Is_Punch)
			if Staminia_V.Value >= Stamina_Params.Min_To_Hit and Punch_Power_V.Value > 0 and not Debounce_Striking then
	            Debounce_Striking = true
			
				SE_Mod.PlaySFX(Plr, "Wooshes_SE")
				
				local function playStrikeAnimation()
					
					local track = nil
					if(Is_Punch) then
						track = Combo_Punch_Anim_Arr[Combo_Punch_Index]
						Combo_Punch_Index = incrementIndex(Combo_Punch_Index,#Combo_Punch_Anim_Arr)
					else
						track = Combo_Kick_Anim_Arr[Combo_Kick_Index]
						Combo_Kick_Index = incrementIndex(Combo_Kick_Index, #Combo_Kick_Anim_Arr)
					end
					
	                local key = track:GetAttribute("Strike_Key") or "A"
	                task.spawn(function()
						Throwing_Strike_E:FireServer(key)
						Char:SetAttribute("LastFightAction", Is_Punch and "Punch" or "Kick")
	                end)

	                Animation_Mod.Stop_Animation_Tracks(Combo_Punch_Anim_Arr, {})
	                Animation_Mod.Play_Animation_Track(track)
				end
				playStrikeAnimation()
	            --task.spawn(playStrikeAnimation)
	            --wait(0.5)
				Debounce_Striking = false
			end
        end

        -- Local references to dodge animations.  These are toggled between
        -- slip and headblock variants after each dodge to replicate the
        -- alternating behaviour of the original code.
        local Left_Dodge_Ani = Striking_Anim_Tracks["Slip Left"]
        local Right_Dodge_Ani = Striking_Anim_Tracks["Slip Right"]
        local Back_Dodge_Ani = Striking_Anim_Tracks["Dodge Back"]

        --[[
            Dodge_Handle

            Executes a dodge manoeuvre of the specified type ("Dodge Left",
            "Dodge Right" or "Dodge Back").  The player is propelled in the
            appropriate direction using ApplyImpulse.  The dodge animation
            toggles between slip and headblock variants to add variation.
        ]]--
		local function Dodge_Handle(dodgeType: string)
			if Staminia_V.Value >= Stamina_Params.Min_To_Dodge  and not Debounce_Dodge then
	            Debounce_Dodge = true
	            -- Apply an impulse in the appropriate direction
	            local function applyForce(dir: Vector3)
	                local force = 68
	                if dodgeType == "Dodge Back" then
	                    force = 90
					end
					
	                HRP:ApplyImpulse(dir * (Fight_Walkspeed * force) * HRP:GetMass())
	            end
	            -- Inform the server that a dodge has occurred so that stamina can be reduced
	            task.spawn(function()
					Dodging_Strike_E:FireServer()
					Char:SetAttribute("LastFightAction", "Dodge")
	            end)
	            Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
	            Show_White_Fade:Fire(Color3.new(1, 1, 1))
	            if dodgeType == "Dodge Left" then
	                applyForce(HRP.CFrame.RightVector * -1)
	                Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
	            elseif dodgeType == "Dodge Right" then
	                applyForce(HRP.CFrame.RightVector)
	                Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
	            else
	                applyForce(HRP.CFrame.LookVector * -1)
	                Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
	            end
	            -- Toggle between slip and headblock variants on each call
	            local function incrementAnim()
	                if dodgeType == "Dodge Left" then
	                    if Left_Dodge_Ani == Striking_Anim_Tracks["Slip Left"] then
	                        Left_Dodge_Ani = Striking_Anim_Tracks["Headblock Left"]
	                    else
	                        Left_Dodge_Ani = Striking_Anim_Tracks["Slip Left"]
	                    end
	                elseif dodgeType == "Dodge Right" then
	                    if Right_Dodge_Ani == Striking_Anim_Tracks["Slip Right"] then
	                        Right_Dodge_Ani = Striking_Anim_Tracks["Headblock Right"]
	                    else
	                        Right_Dodge_Ani = Striking_Anim_Tracks["Slip Right"]
	                    end
	                end
	            end
	            incrementAnim()
				Debounce_Dodge = false
			end
        end

        -- Reference used to monitor blocking power draining to zero while
        -- blocking.  This connection is disconnected when blocking ends.
        local Low_Block_Con: RBXScriptConnection? = nil

        --[[
            Disable_Blocking_Handle

            Stops any blocking effects, resets the player's walk speed, stops
            animations and informs the server that the player has stopped
            blocking.  Also fires a local bindable event to ensure the
            mobile UI is updated appropriately.
        ]]--
        local function Disable_Blocking_Handle()
			if Debounce_Blocking then 
				if Low_Block_Con ~= nil then
	                Low_Block_Con:Disconnect()
	                Low_Block_Con = nil
	            end
	            if Hum then
	                Hum.WalkSpeed = Fight_Walkspeed
	            end
	            Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
	            Unblocking_Strike_E:FireServer()
				Release_Mobile_Blocking_E:Fire()
				Char:SetAttribute("LastFightAction", "Unblock")
				Debounce_Blocking = false
			end
        end

        -- Timestamp of the last block activation to throttle repeated blocks
        local lastBlock = os.clock()

        --[[
            Blocking_Handle

            Initiated when the player presses the block key.  Adjusts the
            player's walk speed, listens for the block power to drain to
            zero, plays the block animation and informs the server of the
            block state.
        ]]--
		local function Blocking_Handle()
			if Blocking_Power_V.Value > 0 and not Debounce_Blocking then
	            if os.clock() - lastBlock <= 0.15 then
	                return
	            end
	            lastBlock = os.clock()
	            Debounce_Blocking = true
	            if Hum then
	                Hum.WalkSpeed = Fight_Walkspeed * 0.2
	            end
	            if Low_Block_Con ~= nil then
	                Low_Block_Con:Disconnect()
	                Low_Block_Con = nil
	            end
	            Low_Block_Con = Blocking_Power_V.Changed:Connect(function()
	                if Blocking_Power_V.Value <= 0 and Debounce_Blocking then
	                    if Low_Block_Con ~= nil then
	                        Low_Block_Con:Disconnect()
	                        Low_Block_Con = nil
	                    end
	                    Disable_Blocking_Handle()
	                end
	            end)
	            table.insert(Cons, Low_Block_Con)
	            task.spawn(Play_Blocking_Animation)
				Blocking_Strike_E:FireServer()
				Char:SetAttribute("LastFightAction","Block")
			end
        end

        --[[
            Takedown_Handle

            Attempts to initiate a takedown manoeuvre.  This is only possible
            when the server indicates a takedown is permitted via values
            stored on the fight cage model.  When a valid takedown event is
            found it is fired and a voice over sound plays.  A short delay
            prevents repeated attempts.
        ]]--
		local function Takedown_Handle()
			if Staminia_V.Value >= Stamina_Params.Min_To_Takedown and not Debounce_Takedown then
				local Fight_Data = Cage_M:FindFirstChild("Fight_Data_F")
				local takedown_Tracker =  Fight_Data:FindFirstChild("Takedown_Track")
				local takedownE = Fight_Data:FindFirstChild("Takedown_E") -- Get_Takedown_Event()
				if takedown_Tracker.Value then
					Debounce_Takedown = true
					SE_Mod.Play_Voice_Over("Submission_Attempt")
					takedownE:FireServer()
					Char:SetAttribute("LastFightAction","Takedown")
					wait(1)
					Debounce_Takedown = false
				end
			end
		end
		
		-- Process Input 
		local function Process_Input(inputType)
			-- Check ability to strike, block, dodge, or takedown
			if Health_V.Value > 0 and not state.Is_Hit then
				if inputType == "Punching" or inputType == "Kicking" then
					task.spawn(Disable_Blocking_Handle)
					Strike_Handle(inputType == "Punching")
				elseif inputType == "Blocking" then
					Blocking_Handle()
				elseif inputType ==  "Dodge" or inputType == "Dodge Left" or inputType == "Dodge Right" or inputType == "Dodge Back" then
					task.spawn(Disable_Blocking_Handle)
					if inputType == "Dodge" then
						if Current_Move_Direction.Magnitude <= 0 then
							-- Random Dodge if the player is not currently moving
							local options = {"Dodge Left", "Dodge Right", "Dodge Back"}
							inputType = options[math.random(#options)]
						else 
							-- Directionnal Dodge if the player is moving
							local forward = Current_Move_Direction:Dot(Char.HumanoidRootPart.CFrame.LookVector)
							local right = Current_Move_Direction:Dot(Char.HumanoidRootPart.CFrame.RightVector)
							if math.abs(forward) > math.abs(right) then
								inputType = "Dodge Back"--f>0 and "Dodge Random" or "Dodge Back"
							else
								inputType = right>0 and "Dodge Right" or "Dodge Left"
							end
						end
					end
					Dodge_Handle(inputType)
				elseif inputType == "Takedown" then
					Takedown_Handle()
				elseif inputType =="Unblocking" then
					Disable_Blocking_Handle()
				end
			end
		end

        if not UIS.TouchEnabled then
			-- Listen for desktop and platforms input events (seeInput_Handle mapping)
			
			-- Input mapping helper for desktop platforms
			local function Input_Mapping(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.KeyCode == Enum.KeyCode.ButtonR2 then
					return "Punching"
				elseif input.UserInputType == Enum.UserInputType.MouseButton2 or input.KeyCode == Enum.KeyCode.ButtonL2 then
					return "Kicking"
				elseif input.KeyCode == Enum.KeyCode.E or input.KeyCode == Enum.KeyCode.ButtonA then
					return "Dodge"
				elseif input.KeyCode == Enum.KeyCode.Space or input.KeyCode == Enum.KeyCode.ButtonB then
					return "Blocking"
				elseif input.KeyCode == Enum.KeyCode.R or input.KeyCode == Enum.KeyCode.ButtonY then
					if (Cage_M) then
						return "Takedown"
					end
				end
				return "None"
			end
			
			table.insert(Cons, UIS.InputBegan:Connect(function(input, GPE)
				if not Is_Chatbox_Typing:Invoke() then
					local inputType = Input_Mapping(input)
					Process_Input(inputType)
				end
			end))
            table.insert(Cons, UIS.InputEnded:Connect(function(input, GPE)
				if not Is_Chatbox_Typing:Invoke() then
					if Input_Mapping(input) == "Blocking" then
						Process_Input("Unblocking")
					end
                end
            end))
        else
			-- Mobile interface support
			local function Click_Striking_Handle(b, inputType)
				Buttons_Mod.Button_Setup_OnClickDown(Cons, b, b:FindFirstChild("Selected"), { b:FindFirstChild("Icon_Img")}, 
					function () Process_Input(inputType) end,-- CallBack
					function () return not Debounce_Striking end -- Avaialble
				)
			end
			
			local function Click_Dodge_Handle(b, inputType)
				Buttons_Mod.Button_Setup_OnClickDown(Cons, b, b:FindFirstChild("Selected"), { b:FindFirstChild("Icon_Img")}, 
					function () Process_Input(inputType) end, -- CallBack	
					function () return not Debounce_Dodge end -- Available
				)
            end
            
			local function Press_Blocking_Handle(b)
				Buttons_Mod.Button_Setup_OnPress(Cons, b, b:FindFirstChild("Selected"), { b:FindFirstChild("Icon_Img")}, 
					function ()	Process_Input("Blocking") end,   -- CallBack Down
					function () Process_Input("Unblocking") end, -- CallBack Up
					Release_Mobile_Blocking_E                    -- Release Event
				)
			end
			
			local function Takedown_Handle_Mobile(b)
				if (Cage_M) then				
					Buttons_Mod.Button_Setup_OnClickDown(Cons, b, b:FindFirstChild("Selected"), { b:FindFirstChild("Icon_Img")}, 
						function () Process_Input("Takedown") end     -- CallBack
					)
					b.Visible  = false
					local Takedown_Tracker = Cage_M:FindFirstChild("Fight_Data_F"):FindFirstChild("Takedown_Track")
					table.insert(Cons,Takedown_Tracker.Changed:Connect(function()
						b.Visible = Takedown_Tracker.Value and Takedown_Tracker:GetAttribute(Plr.Name) > 0
					end))
				else 
					b.Visible = false
				end
			end
			
			local Mobile_Buttons = Get_Mobile_Buttons_BF:Invoke()
			for _, B in ipairs(Mobile_Buttons) do
				if     B.Name == "Punching_B"    then Click_Striking_Handle(B, "Punching")
				elseif B.Name == "Kicking_B"     then Click_Striking_Handle(B, "Kicking")
				elseif B.Name == "Dodge_B"     then Click_Dodge_Handle(B, "Dodge")
				--elseif B.Name == "Dodge_Left_B"  then Click_Dodge_Handle(B, "Dodge Left")
				--elseif B.Name == "Dodge_Right_B" then Click_Dodge_Handle(B, "Dodge Right")
				-- elseif B.Name == "Dodge_Back_B"  then Click_Dodge_Handle(B, "Dodge Back")
				elseif B.Name == "Block_B"       then Press_Blocking_Handle(B)
				elseif B.Name == "Takedown_B"    then Takedown_Handle_Mobile(B)
				--elseif B.Name == "CageControl_B" then return -- Add other minigames buttons here
				end
			end
        end
    end
    Client_Striking_Handle()
end

return Combat_Inputs]]></ProtectedString>
								<string name="ScriptGuid">{B5484E9D-BB1F-45D5-AD44-092168AF3064}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Combat_Inputs.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX6958E20C6A6244259878632BF61E21F1">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterGui/Fight_System_UI/Client_Fight_Handle/Camera_Rig.lua
--
--  Description:
--      Manages the player's combat camera rig during fight mode.
--      Creates and controls a BodyGyro to orient the player toward
--      their opponent, adjusts camera behavior, and locks mouse 
--      controls for precise third-person combat aiming.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-10-08 by Oriane
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * RunService
--          * UserInputService
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events/Set_Player_Fight_Opponent
--      - Player Instance:
--          * Character (Humanoid, HumanoidRootPart)
--
--  Notes:
--      - Automatically adjusts camera orientation toward the current target.
--      - Locks mouse to center during fights and disables jump/climb states.
--      - Dynamically updates BodyGyro torque based on platform state.
--      - Synchronizes with Client_Fight_Handle via shared environment (env).
--      - Provides smooth rotation, zoom, and angle transitions each frame.
--
--======================================================================


----- DEPENDENCIES -----

--// Services
local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")

----- REFERENCES -----
--// Player and Character
local Plr = game.Players.LocalPlayer

--// Character Components
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Cam = game.Workspace.CurrentCamera

local Camera_Rig = {}

function Camera_Rig.Setup(env)
	local Fight_Walkspeed: number = env.Fight_Walkspeed
	local Max_Angle: number = env.Max_Angle
    local Set_Cam_Adjustments = env.Set_Cam_Adjustments
    local Reset_BG = env.Reset_BG
    local Cons = env.Cons
    local state = env.state
    local RS_Con_ref = env.RS_Con_ref
    -- Target_HRP is a reference that may be reassigned by this module
    -- We capture it as a local upvalue so that modifications affect the original
    local Target_HRP = env.Target_HRP

    -- Reset any previous rig and create a new BodyGyro
    local function Create_BG()
        Reset_BG()
        -- Destroy any existing BodyGyro on the HRP
        local oldG = HRP:FindFirstChildWhichIsA("BodyGyro")
        if oldG then
            oldG:Destroy()
        end
        local bodyG = Instance.new("BodyGyro", HRP)
        bodyG.P = 1000
        bodyG.MaxTorque = Vector3.new(0, 1000, 0)
        bodyG.D = 10
        -- Configure player camera and input settings for fighting
        Plr.CameraMaxZoomDistance = 18
        Plr.CameraMinZoomDistance = 18
        UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
        UIS.MouseIconEnabled = false
        UIS.MouseDeltaSensitivity = 0.5
        if Hum then
            Hum.AutoRotate = false
            Hum.WalkSpeed = Fight_Walkspeed
            Hum.JumpPower = 0
            Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
            Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
            Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
        end
        Char:SetAttribute("Is_Fighting", true)
        return bodyG
    end
    local BG = Create_BG()
    -- Apply initial camera adjustments depending on whether a target exists
    Set_Cam_Adjustments((Target_HRP == nil))
    --[[EVENT NOT FIRED BY SERVER
    -- Listen for the server instructing us to lock onto a specific opponent
    table.insert(Cons, Set_Player_Fight_Opponent.OnClientEvent:Connect(function(opponentChar)
        if opponentChar and opponentChar:FindFirstChild("HumanoidRootPart") then
            env.Target_HRP = opponentChar:FindFirstChild("HumanoidRootPart")
        else
            env.Target_HRP = nil
        end
        Set_Cam_Adjustments((env.Target_HRP == nil))
    end))]]
    -- When the local player dies, clear the target and reset the camera rig
    table.insert(Cons, Hum.Died:Connect(function()
        env.Target_HRP = nil
        Reset_BG()
    end))
    -- Function to update the BodyGyro’s CFrame each step
    local function Update_BG()
        local lookPos = HRP.Position + (Cam.CFrame.LookVector * 25)
        if env.Target_HRP then
            lookPos = env.Target_HRP.Position
        end
        BG.CFrame = CFrame.new(HRP.Position, lookPos)
    end
    Update_BG()
    -- Stepped connection to continuously update the BodyGyro
	local rsCon = RunService.Stepped:Connect(function()
        if BG and Cam then
            Update_BG()
        end
    end)
    table.insert(Cons, rsCon)
    -- Expose the connection so the main script can disconnect it later
    if RS_Con_ref then
        RS_Con_ref.con = rsCon
    end
    -- Adjust the BodyGyro’s torque when the player enters or exits PlatformStand
    table.insert(Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
        if Hum.PlatformStand then
            BG.P = 0
            BG.MaxTorque = Vector3.new(0, 0, 0)
            BG.D = 0
        else
            BG.P = 1000
            BG.MaxTorque = Vector3.new(0, 1000, 0)
            BG.D = 10
        end
    end))
    -- Bind a RenderStep callback to smoothly rotate the camera towards the target
    local lastCFrame = Cam.CFrame
	RunService:BindToRenderStep("UpdateLoop", Enum.RenderPriority.Camera.Value - 1, function(dt)
        if env.Target_HRP then
            if Hum and Hum.WalkSpeed > 0 and HRP and not HRP.Anchored then
                local vec = (env.Target_HRP.Position - HRP.Position) * Vector3.new(1, 0, 1)
                if vec.Magnitude <= 0.001 then
                    vec = Vector3.zAxis
                end
                vec = vec.Unit
                local lerp = state.Is_Hit and 0.1 or 0.3
                local alpha = 1 - (1 - lerp) ^ (60 * dt)
                local targetCF = CFrame.new(HRP.Position, HRP.Position + vec) * CFrame.Angles(Max_Angle, 0, 0) * CFrame.new(3, 2, 13)
                Cam.CFrame = lastCFrame:Lerp(targetCF, alpha)
                lastCFrame = Cam.CFrame
            end
        end
    end)
    return BG
end

return Camera_Rig]]></ProtectedString>
								<string name="ScriptGuid">{241B1A02-8347-4C4A-88DE-A768FD40613B}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Camera_Rig.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE379DA7286E245C4A0CD98061F796DB8">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: StarterGui/Fight_System_UI/Client_Fight_Handle/Clinch_Sequence.lua
--
--  Description:
--      Handles the Cage Clinch cinematic sequence during fights.
--      Plays synchronized attack/defense animations, manages camera
--      transitions, screen flashes, and camera shakes for impactful
--      close-range combat moments.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-10-08 by Oriane
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * TweenService
--          * RunService
--          * UserInputService
--      - ReplicatedStorage:
--          * Data_Mods_F/CameraShaker
--          * Data_Mods_F/Animation_Mod
--          * Data_Mods_F/Sound_Mod
--          * Channels_F/Server_Client_F/Events/Cage_Clinch_Start
--          * Channels_F/Bindable_F/Events/Show_White_Fade
--      - Player Instance:
--          * Character (Humanoid, HumanoidRootPart)
--
--  Notes:
--      - Freezes player movement and disables inputs during the cut-scene.
--      - Locks the camera to a cinematic CFrame and narrows the FOV.
--      - Alternates between attacking and defending animation sets.
--      - Triggers flashes and camera shakes on each hit impact.
--      - Automatically resets the camera, animations, and fight state
--        once the clinch sequence finishes.
--      - Works in conjunction with Client_Fight_Handle and Combat_Inputs.
--
--======================================================================

----- DEPENDENCIES -----
--// Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")

--// Required Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Cam_Shake_Mod = require(Data_Mods_F:WaitForChild("CameraShaker"))
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Fight_UI = require(script.Parent:WaitForChild("Fight_UI"))

----- REFERENCES -----
--// Player and Character
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")

--// Character Components
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Cam = game.Workspace.CurrentCamera

--// Fight Values
local Fight_Data_F = Plr:WaitForChild("Fight_Data")

-- Events
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Cage_Clinch_Start 	= Channels.SC_Remote_Events.Cage_Clinch_Start
local Show_White_Fade 		= Channels.Bindable_Events.Show_White_Fade


local Clinch_Sequence = {}

function Clinch_Sequence.Setup(env)
    local Set_Cam_Adjustments = env.Set_Cam_Adjustments
    local state = env.state
    local BG = env.BG
    local Fight_Walkspeed: number = env.Fight_Walkspeed
    local Cam_FOV: number = env.Cam_FOV
    local Anim_Track_Data = env.Anim_Track_Data
    local Cons = env.Cons
    local Tween_Cam = env.Tween_Cam

    -- Precompute the clinch animation tracks for attacking and non‑attacking states
    local Attack_Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, true)
    local Non_Attack_Clinch_Tracks = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, false)

    -- Handler for the clinch cut‑scene
    local function Cage_Clinch_Handle(Animation_Sequence_Data: {string}, Is_Attacking: boolean, Camera_CF: CFrame)
        -- Freeze the character and hide UI hints
        local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(Char)
			Fight_UI.Update("Cinematic")
            state.Is_Hit = true
            state.Is_Cage_Submission = true
            if BG then
                BG.P = 0
                BG.MaxTorque = Vector3.new(0, 0, 0)
                BG.D = 0
            end
            if Hum then
                Hum.WalkSpeed = 0
            end
        end
        Freeze_Character()
        -- Lock the camera to the provided CFrame and narrow the FOV
        local function Lock_Camera()
            local Cam_Offset = HRP.CFrame:ToObjectSpace(Cam.CFrame)
            local initFOV = Cam.FieldOfView
            Cam.CameraType = Enum.CameraType.Scriptable
            TS:Create(Cam, Tween_Cam, {CFrame = Camera_CF, FieldOfView = 50}):Play()
            return Cam_Offset, initFOV
        end
        local Cam_CF_Offset, Init_Cam_FOV = Lock_Camera()
        -- Create a camera shake object
        local function Cam_Shake()
            local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
                Cam.CFrame = Cam.CFrame * shakeCf
            end)
            return CS
        end
        local camShake = Cam_Shake()
        -- Play the clinch strike animations and camera effects
        local function Play_Strike_Sequences()
            local function Get_Clinch_Tracks_Data()
                if Is_Attacking then
                    return Attack_Clinch_Tracks_Data
                else
                    return Non_Attack_Clinch_Tracks
                end
            end
            local clinchTracks = Get_Clinch_Tracks_Data()
            -- Play the initial clinch and loop animations
            Animation_Mod.Play_Animation_Track(clinchTracks['Init_Clinch'], true)
            task.spawn(Animation_Mod.Play_Animation_Track, clinchTracks['Loop_Clinch'])
            wait(1)
            -- Start camera shake and define flash effect per hit
            camShake:Start()
            local function Play_Clinch_Hit_Effects()
                local col = Color3.new(1, 0, 0)
                if Is_Attacking then
                    col = Color3.new(1, 1, 1)
                end
				Show_White_Fade:Fire(col)
                camShake:Shake(Cam_Shake_Mod.Presets.Bump)
            end
            for i = 1, #Animation_Sequence_Data do
                local strikeKey = Animation_Sequence_Data[i]
                local strikeTrack = clinchTracks[strikeKey]
                if strikeTrack then
                    Play_Clinch_Hit_Effects()
                    Animation_Mod.Play_Animation_Track(strikeTrack)
                end
            end
            camShake:Stop()
        end
        Play_Strike_Sequences()
        -- Reset the player and camera after the clinch sequence completes
        local function Clinch_Reset_Handle()
            local function Reset_Player_Camera()
                local tweenCamClinch = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.In, 0, false, 0)
                local camCF = HRP.CFrame:ToWorldSpace(Cam_CF_Offset)
                Cam.CameraType = Enum.CameraType.Scriptable
                TS:Create(Cam, tweenCamClinch, {CFrame = camCF, FieldOfView = Init_Cam_FOV}):Play()
                wait(0.75)
                Set_Cam_Adjustments((env.Target_HRP == nil))
            end
            task.spawn(Reset_Player_Camera)
			Animation_Mod.Reset_Character_Animations(Char)
			Fight_UI.Update("Cage_Fight")
            state.Is_Hit = false
            state.Is_Cage_Submission = false
            if Hum then
                if BG and not Hum.PlatformStand then
                    BG.P = 1000
                    BG.MaxTorque = Vector3.new(0, 1000, 0)
                    BG.D = 10
                end
                Hum.WalkSpeed = Fight_Walkspeed
                Anim_Track_Data['Idle']:Play()
                Anim_Track_Data['Idle']:AdjustSpeed(0.5)
                Cam.FieldOfView = Cam_FOV
            end
        end
        Clinch_Reset_Handle()
    end
    -- Connect the remote event to initiate the cage clinch cut‑scene
	table.insert(Cons, Cage_Clinch_Start.OnClientEvent:Connect(function(sequenceKeys, isAttacking, cameraCF)
        Cage_Clinch_Handle(sequenceKeys, isAttacking, cameraCF)
    end))
end

return Clinch_Sequence]]></ProtectedString>
								<string name="ScriptGuid">{2003EC5D-8924-4027-ACC2-6CB6969FA442}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Client_Clinch_Sequence.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXEC88140442AE4A198547E0A235569503">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[
--======================================================================
--  File: StarterPlayerScripts/Fight_System/Modules/Submission_Cut_Scene.lua
--
--  Description:
--      Manages the Submission cinematic sequence and minigame.
--      Coordinates attacking and defending animations, camera angles,
--      heartbeat effects, and tap-speed tracking for realistic
--      ground submission phases in fights.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-10-08 by Oriane
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * TweenService
--          * RunService
--          * UserInputService
--      - ReplicatedStorage:
--          * Data_Mods_F/Animation_Mod
--          * Data_Mods_F/Sound_Mod
--          * Channels_F/Server_Client_F/Events/Submission_Minigame
--          * Channels_F/Bindable_F/Events/Show_White_Fade
--          * Channels_F/Bindable_F/Events/Click_Rate_Inc
--          * Channels_F/Bindable_F/Events/Click_Rate_Reset
--          * Channels_F/Bindable_F/Events/Click_Rate_Update
--      - Player Instance:
--          * Character (Humanoid, HumanoidRootPart)
--          * PlayerGui (Submission UI elements)
--
--  Notes:
--      - Starts the submission sequence when triggered by the server.
--      - Plays contextual attack or defense animations based on player role.
--      - Displays click-rate-based progress bar for winning the submission.
--      - Applies heartbeat SFX and camera shake for intensity.
--      - Cleans up all UI and resets fight state on completion or interruption.
--      - Integrates with Client_Fight_Handle and Click_Rate_System.
--
--======================================================================

--// Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

--// Required Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Fight_UI = require(script.Parent:WaitForChild("Fight_UI"))

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local On_Submission_Handle			= Channels.Bindable_Events.On_Submission_Handle
local Unblocking_Strike			= Channels.CS_Remote_Events.Unblocking_Strike

----- REFERENCES -----
--// Player and Character
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")

--// Character Components
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Cam = game.Workspace.CurrentCamera

--// Objects
local Main_World_F = game.Workspace:WaitForChild("Main_World_F")
local Objects = Main_World_F:WaitForChild("Gameplay"):WaitForChild("Objects")
local Fight_Cages_F = Objects:WaitForChild("Fight_Cages_F")

local Submission_Minigame = {}

function Submission_Minigame.Setup(env)
    local Set_Cam_Adjustments = env.Set_Cam_Adjustments
	local Cage_M = env.Cage_M
    local BG = env.BG
    local state = env.state
    local Anim_Track_Data = env.Anim_Track_Data
    local Fight_Walkspeed: number = env.Fight_Walkspeed
    local Cam_FOV: number = env.Cam_FOV
    local Cam_Offset: Vector3 = env.Cam_Offset
    local Tween_Cam: TweenInfo = env.Tween_Cam
    local Cons = env.Cons

    -- Locals to preserve camera offset during submission sequences
    local Prev_Camera_Offset: CFrame? = nil
    local Cam_Tween_Local: TweenInfo = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
    local Cam_RS_Con: RBXScriptConnection? = nil

    -- Event handler for beginning and ending a submission sequence.  This
    -- function mirrors the On_Submission_Handle from the original script,
    -- updating state flags, playing animations and adjusting the camera.
    local function On_Submission_Handler(Is_Attacking: boolean, Is_Starting: boolean)
        -- Reset any current animations and update the UI hints
		Animation_Mod.Reset_Character_Animations(Char)
		Fight_UI.Update(Is_Starting and "Cinematic" or "Cage_Fight")
		Unblocking_Strike:FireServer()

        -- Disconnect any existing camera follow connection
        if Cam_RS_Con ~= nil then
            Cam_RS_Con:Disconnect()
            Cam_RS_Con = nil
        end

		if Is_Starting then
            -- Begin submission: mark hit state and submission state
            state.Is_Hit = true
            state.Is_Cage_Submission = true
            -- Disable body gyro torque so the camera doesn’t fight the animation
            if BG ~= nil then
                BG.P = 0
                BG.MaxTorque = Vector3.new(0, 0, 0)
                BG.D = 0
            end
            -- Prevent the player from moving during the submission
            if Hum ~= nil then
                Hum.WalkSpeed = 0
            end
            -- Slightly raise the defender’s root part when not attacking
            if HRP ~= nil then
                if not Is_Attacking then
                    HRP.CFrame = HRP.CFrame * CFrame.new(0, 0.15, 0)
                end
            end
            -- Helper to obtain the appropriate animation tracks for the
            -- takedown and submission based on who is the attacker
            local function Get_Takedown_Submission_Tracks()
                -- Identify the character that is initiating the submission
                local function Get_Fighting_Character()
                    for _, fm in ipairs(Fight_Cages_F:GetChildren()) do
                        if fm and fm:FindFirstChild("Fight_Data_F") then
                            local fd = fm:FindFirstChild("Fight_Data_F")
                            local char1 = fd:FindFirstChild("Fight_Char_1")
                            local char2 = fd:FindFirstChild("Fight_Char_2")
                            local submissionChar = fd:FindFirstChild("Submission_Hold_Character")
                            if Char and char1 and char2 and submissionChar and
                                (char1.Value == Char or char2.Value == Char) and
                                submissionChar.Value ~= nil then
                                return submissionChar.Value
                            end
                        end
                    end
                    return nil
                end
                local attackingChar = Get_Fighting_Character()
                local takedownData, submissionData = Animation_Mod.Get_Takedown_Submission_Data(attackingChar)
                if Is_Attacking then
                    return Animation_Mod.Get_Takedown_Submission_Tracks(Hum,
                        takedownData["Takedown ID"], submissionData["Submission ID"], submissionData["Submission Loop ID"])
                else
                    return Animation_Mod.Get_Takedown_Submission_Tracks(Hum,
                        takedownData["Receiving ID"], submissionData["Receiving ID"], submissionData["Receiving Loop ID"])
                end
            end
            local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()
            -- Initialise the camera for the submission sequence
            local function Play_Init_Camera_Effects()
                if Prev_Camera_Offset == nil and HRP ~= nil then
                    Prev_Camera_Offset = HRP.CFrame:ToObjectSpace(Cam.CFrame)
                end
                -- Find the humanoid (UpperTorso) of the opponent being submitted to look at
                local function Get_Receiving_HRP()
					if Cage_M and Cage_M:FindFirstChild("Fight_Data_F") then
						local fd = Cage_M:FindFirstChild("Fight_Data_F")
                        local submissionCharV = fd:FindFirstChild("Submission_Hold_Character")
                        local char1V = fd:FindFirstChild("Fight_Char_1")
                        local char2V = fd:FindFirstChild("Fight_Char_2")
                        if submissionCharV and char1V and char2V then
                            if char1V.Value ~= submissionCharV.Value then
                                local tHRP = char1V.Value:FindFirstChild("UpperTorso")
                                if tHRP then
                                    return tHRP
                                end
                            else
                                local tHRP = char2V.Value:FindFirstChild("UpperTorso")
                                if tHRP then
                                    return tHRP
                                end
                            end
                        end
                    end
                    return HRP
                end
                local tHRP = Get_Receiving_HRP()
                -- Compute a fixed offset relative to the target torso
                local offsetCF = CFrame.new(Vector3.new(4.31428, 5.22440, -5.47107))
                local finalPos = tHRP.CFrame:ToWorldSpace(offsetCF).Position
                    local rotCF = CFrame.new(finalPos, tHRP.Position)
                local finalCF = CFrame.new(finalPos) * rotCF.Rotation
                -- Move the camera into position and make it scriptable
                Cam.CameraType = Enum.CameraType.Scriptable
                TS:Create(Cam, Tween_Cam, {CFrame = finalCF}):Play()
                if Cam_RS_Con ~= nil then
                    Cam_RS_Con:Disconnect()
                    Cam_RS_Con = nil
                end
                Cam_RS_Con = RunService.Stepped:Connect(function()
                    if Cam and tHRP and Cam.CameraType == Enum.CameraType.Scriptable then
                        Cam.CFrame = CFrame.new(Cam.CFrame.Position, tHRP.Position)
                    end
                end)
                table.insert(Cons, Cam_RS_Con)
            end
            Play_Init_Camera_Effects()
            -- Play the takedown, then submission and loop animations in sequence
            Takedown_Track.Priority = Enum.AnimationPriority.Action2
            Animation_Mod.Play_Animation_Track(Takedown_Track, true)
            wait(0.25)
            Submission_Track.Priority = Enum.AnimationPriority.Action3
            Animation_Mod.Play_Animation_Track(Submission_Track)
            Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
        else
            -- End submission: reset hit state and submission state
            state.Is_Hit = false
            state.Is_Cage_Submission = false
            if HRP then
                HRP.Anchored = false
                -- Restore the camera to its previous relative offset
                local function Reset_Player_Camera()
                    if Prev_Camera_Offset == nil and HRP ~= nil then
                        Prev_Camera_Offset = CFrame.new() * CFrame.Angles(0, 0, 0)
                    end
                    if HRP then
                        local camCF = HRP.CFrame:ToWorldSpace(Prev_Camera_Offset)
                        Cam.CameraType = Enum.CameraType.Scriptable
                        TS:Create(Cam, Cam_Tween_Local, {CFrame = camCF}):Play()
                        TS:Create(Hum, Tween_Cam, {CameraOffset = Cam_Offset}):Play()
                        wait(0.75)
                        Set_Cam_Adjustments((env.Target_HRP == nil))
                    end
                end
                task.spawn(Reset_Player_Camera)
            end
            if Hum then
                if BG and Hum.PlatformStand == false then
                    BG.P = 1000
                    BG.MaxTorque = Vector3.new(0, 1000, 0)
                    BG.D = 10
                end
                Hum.WalkSpeed = Fight_Walkspeed
                Anim_Track_Data["Idle"]:Play()
                Anim_Track_Data["Idle"]:AdjustSpeed(0.5)
                Cam.FieldOfView = Cam_FOV
			end
			Char:SetAttribute("LastFightAction", "Submission")
        end
    end

    -- Connect the bindable event which triggers submission sequences
	table.insert(Cons, On_Submission_Handle.Event:Connect(function(isAttacking, isStarting)
		On_Submission_Handler(isAttacking, isStarting)
    end))
end

return Submission_Minigame]]></ProtectedString>
								<string name="ScriptGuid">{5B4D7CA5-3C4B-492B-93F5-E4B061ABBA3B}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Client_Submission_Minigame.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX179927CBF0F64CF48AA2D3D36B8287B9">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[----- DEPENDENCIES -----

--// Services
local RS = game:GetService("ReplicatedStorage")

--// Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))

----- REFERENCES -----
--// Player and Character
local Plr = script.Parent:FindFirstAncestorWhichIsA("Player")
local PD = Plr:WaitForChild("Player_Data")
local FD = Plr:WaitForChild("Fight_Data")

--// Character Components
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Head = Char:WaitForChild("Head")

--// Fighter UI References
local Fight_UI = Char:WaitForChild("Fighting_UI")
local Shield_Img = Fight_UI:WaitForChild("Main_F"):WaitForChild("Shield_F"):WaitForChild("Shield_Img")
local Inputs_UI = script.Parent.Parent:WaitForChild("Fight_Inputs_UI")
local Damage_Bar_F = Inputs_UI:WaitForChild("Damage_Bar_F")

Fight_UI.AlwaysOnTop = true

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

--// Bindables
local Toggle_Tools_Buttons		   = Channels.Bindable_Events.Toggle_Tools_Buttons
local Toggle_Fight_Button          = Channels.Bindable_Events.Toggle_Fight_Button
local Toggle_TopBar                = Channels.Bindable_Events.Toggle_TopBar
local Toggle_Side_Buttons          = Channels.Bindable_Events.Toggle_Side_Buttons
local Toggle_BG_Volume             = Channels.Bindable_Events.Toggle_BG_Volume
local Toggle_Fight_UI              = Channels.Bindable_Events.Toggle_Fight_UI
local Toggle_Takedown_Tracker      = Channels.Bindable_Events.Toggle_Takedown_Tracker
local Remove_Submission_UI         = Channels.Bindable_Events.Remove_Submission_UI
local Toggle_Key_Labels            = Channels.Bindable_Events.Toggle_Key_Labels

local Show_Shield_UI               = Channels.CS_Remote_Events.Show_Shield_UI
local Toggle_Healing_Effect        = Channels.CS_Remote_Events.Toggle_Healing_Effect


local Fight_UI = {}

----- Fighting UI attached to the player (Damage Bar and Shield) -----
local function Get_Fighting_UI()
	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
		local Main_F = Fight_UI:FindFirstChild("Main_F") 
		local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
		if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
			return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
		end
	end

	return nil, nil
end

local function Show_Damage_Bar(Should_Show)
	--local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	--if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
	--	Damage_UIG.Offset = Vector2.new(0, -0.5)
	--	Damage_Bar_Img.Visible = Should_Show
	--end
	Damage_Bar_F.Visible = Should_Show
end

local function Update_Damage_Bar_UI(Punch_Power_V)
	--local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	local Damage_UIG = Damage_Bar_F:FindFirstChild("Gauge_Filling"):FindFirstChildWhichIsA("UIGradient")
	local Punch_Power = Fight_Params_Mod.Punch_Power
	if(Damage_UIG ~= nil)then
		local Dif =  math.clamp(Punch_Power_V.Value/Punch_Power.Max_Value, 0, 1)
		local Gradient_Offset = 0.9 * Dif -- empirically determined based on filling asset image
		Damage_UIG.Offset = Vector2.new(Gradient_Offset, 0)
	end 
end


---- Name Tag -----
local function Reset_Name_Tag_Handle(C)
	if not C then
		return
	end
	
	local Name_Tag = C:FindFirstChild("Name_Tag_UI")
	local Toggle_Tabs = {"UIStroke", "Rank_F", "Connection_Img", "Device_Img", "Country_Img", 
		"Player_Name_Txt"}

	if(Name_Tag ~= nil and Name_Tag:FindFirstChild("Main_F") ~= nil)then
		local Main_F = Name_Tag:FindFirstChild("Main_F")

		for i = 1, #Toggle_Tabs do
			local Tab = Main_F:FindFirstChild(Toggle_Tabs[i])
			if(Tab ~= nil)then
				if(Tab:IsA("UIStroke"))then
					Tab.Enabled = true
				else
					Tab.Visible = true
				end
			end
		end

		Main_F.BackgroundTransparency = 0.125

		if(C ~= Char)then
			Name_Tag.StudsOffset = Vector3.new(0, -4, 0)
		end

		Name_Tag.Enabled = true
	end
end

----- Healing Effect -----
local function Toggle_Heal_PE(Is_Enabled)
	local All_C = HRP:GetChildren()
	for i = 1, #All_C do
		local C = All_C[i]
		if(C ~= nil and C.Name == "Heal_PE" and C:IsA("ParticleEmitter"))then
			C.Enabled = Is_Enabled
		end
	end

	if(Shield_Img ~= nil)then
		if(Is_Enabled)then
			Shield_Img.Image = "rbxassetid://130871917395731"
		else
			Shield_Img.Image = "rbxassetid://125284121534949"
		end
	end
end

----- Sweat Effect -----
local function Trigger_Sweat_Effect_Handle()
	if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
		local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
		local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
		if(PE ~= nil)then
			PE:Emit(25)
		end
	end
end

----- UI Update -----

function Update_To_Normal_UI(Active_Fight_Button)
	Toggle_Fight_UI:Fire(false)
	Toggle_Takedown_Tracker:Fire(false)
	Remove_Submission_UI:Fire()
	
	Toggle_BG_Volume:Fire(true)
	Toggle_TopBar:Fire(true)
	Toggle_Side_Buttons:Fire(true)
	Toggle_Tools_Buttons:Fire(true)
	Toggle_Fight_Button:Fire(Active_Fight_Button) --only Fight on tools buttons

	Toggle_Key_Labels:Fire(false)

	Show_Damage_Bar(false)
	task.spawn(function()
		Show_Shield_UI:FireServer(false)
	end)
end

function Update_To_Free_Fight_UI()
	-- Toggle_Fight_UI:Fire(false)
	-- Toggle_Takedown_Tracker:Fire(false)
	-- Remove_Submission_UI:Fire()

	
	-- Toggle_BG_Volume:Fire(true)
	Toggle_TopBar:Fire(false)
	Toggle_Side_Buttons:Fire(false)
	-- Toggle_Tools_Buttons:Fire(true)
	-- Toggle_Fight_Button:Fire(true)

	Toggle_Key_Labels:Fire(true)

	Show_Damage_Bar(true)
	task.spawn(function()
		Show_Shield_UI:FireServer(true)
	end)
end

function Update_To_Cage_Fight_UI(cage_M)
	Toggle_Fight_UI:Fire(true, cage_M)
	Toggle_Takedown_Tracker:Fire(true, cage_M)
	-- Remove_Submission_UI:Fire()

	Toggle_BG_Volume:Fire(false)
	Toggle_TopBar:Fire(false)
	Toggle_Side_Buttons:Fire(false)
	Toggle_Tools_Buttons:Fire(false)
	--Toggle_Fight_Button:Fire(false)

	Toggle_Key_Labels:Fire(true)
	
	Show_Damage_Bar(true)
	task.spawn(function()
		Show_Shield_UI:FireServer(true)
	end)
end

function Update_To_Cinematic_UI() 
	
	-- Toggle_Fight_UI:Fire(true)
	Toggle_Takedown_Tracker:Fire(false)
	-- Remove_Submission_UI:Fire()

	-- Toggle_BG_Volume:Fire(false)
	-- Toggle_TopBar:Fire(false)
	-- Toggle_Side_Buttons:Fire(false)
	-- Toggle_Tools_Buttons:Fire(false)
	--Toggle_Fight_Button:Fire(false)
	
	Toggle_Key_Labels:Fire(false)
	
	Show_Damage_Bar(false)
	task.spawn(function()
		Show_Shield_UI:FireServer(false)
	end)
end

function Update_To_Submission_UI()
	-- Toggle_Fight_UI:Fire(true)
	Toggle_Takedown_Tracker:Fire(false)
	-- Remove_Submission_UI:Fire()

	-- Toggle_Fight_Button:Fire(false)
	-- Toggle_BG_Volume:Fire(false)
	-- Toggle_TopBar:Fire(false)
	-- Toggle_Side_Buttons:Fire(false)

	Toggle_Key_Labels:Fire(false)

	Show_Damage_Bar(false)
	task.spawn(function()
		Show_Shield_UI:FireServer(false)
	end)
end

----- Module Functions -----

local Fight_State = ""
local Cage_M = nil
function Fight_UI.Setup(cage)
	Cage_M = cage
end

function Fight_UI.Update(State)
	-- warn(State)
	if Fight_State == State then
		return
	else
		Fight_State = State 
		if(Fight_State == "No_Fight") then
			Update_To_Normal_UI(false)
		elseif(Fight_State == "No_Fight_In_Gym") then
			Update_To_Normal_UI(true)
		elseif (Fight_State == "Free_Fight") then
			Update_To_Free_Fight_UI()
		elseif (Fight_State == "Cage_Fight") then
			Update_To_Cage_Fight_UI(Cage_M)
		elseif (Fight_State == "Cinematic") then
			Update_To_Cinematic_UI()
		elseif (Fight_State == "Submission")then
			Update_To_Submission_UI()
		end
	end
end

function Fight_UI.Reset_Name_Tag(C)
	Reset_Name_Tag_Handle(C)
end

function Fight_UI.Update_Damage_Bar(Punch_Power_V)
	Update_Damage_Bar_UI(Punch_Power_V)
end

function Fight_UI.Trigger_Sweat_Effect()
	Trigger_Sweat_Effect_Handle()
end

Toggle_Healing_Effect.OnClientEvent:Connect(function(Is_Enabled)
	Toggle_Heal_PE(Is_Enabled)
end)



return Fight_UI]]></ProtectedString>
								<string name="ScriptGuid">{8C78A260-9329-477D-8439-C4BEEE5E7554}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Fight_UI.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0FA11DD7F96F44A2861AAFAD7F2AB02A">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Buttons_Mod.lua
--
--  Description:
--      Centralized UI button handler module providing reusable animation
--      and interaction logic for ImageButtons and TextButtons.
--      Supports click, press/hold, and hover behaviors with color tweening
--      and sound feedback via Sound_Mod.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-11-01 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Sound_Mod (for UI click/hover sounds)
--      - Services:
--          * TweenService
--
--  Notes:
--      - Button_Setup_OnClickDown: one-shot click handler (plays click sound + size tween)
--      - Button_Setup_OnPress: press/release logic with optional external release events
--      - Button_Setup_OnHover: placeholder for hover logic extension
--      - Color and tween behavior are defined through constants for easy tuning
--
--======================================================================

local Buttons_Mod = {}

----- DEPENDENCIES -----
--// Services
local TS = game:GetService("TweenService")
--// Required Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

----- REFERENCES -----
--// Player and Character
local Plr = game.Players.LocalPlayer

----- VARIABLES -----
local Icon_Color_Down = Color3.new(0.0941176, 0.0941176, 0.0941176)
local Tween_Length = 0.125
local Reverse_Tween = TweenInfo.new(Tween_Length, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local OneWay_Tween = TweenInfo.new(Tween_Length/2, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Click_Size_Ratio = 0.75

--// Colors
local function Get_Initial_Color(imgs)
	local colors = {}
	for _, img in ipairs(imgs) do
		table.insert(colors, img.ImageColor3)
	end
	return colors
end
local function Apply_Colors(imgs, cols)
	for i, img in ipairs(imgs) do
		img.ImageColor3 = cols[i]
	end
end
local function Apply_Color(imgs, col)
	for i, img in ipairs(imgs) do
		img.ImageColor3 = col
	end
end

--// Tween
local function Get_Initial_Size(b)
	return b.Size
end

local function Get_Ratio_Size(initial_size, ratio)
	return UDim2.fromScale(
		initial_size.X.Scale * ratio,
		initial_size.Y.Scale * ratio
	)
end

local function Apply_Tween(b, Target_Size, Reverse)
	TS:Create(b, Reverse and Reverse_Tween or OneWay_Tween, {Size = Target_Size}):Play()
end

-- Setup Button for simple clicks 
function Buttons_Mod.Button_Setup_OnClickDown(Cons, Button, Selected, Icons, Callback_Down, Available)
	
	if Selected:IsA("TextButton") or Selected:IsA("ImageButton") then
		local Debounce_B = false
		Button.Visible = true
		local Initial_Colors = Get_Initial_Color(Icons)
		local Initial_Size = Get_Initial_Size(Button)
		local Clicked_Size = Get_Ratio_Size(Initial_Size, Click_Size_Ratio)
		
		if Callback_Down~= nil then
			table.insert(Cons, Selected.MouseButton1Down:Connect(function()
				if Available ~= nil and not Available() then 
					return 
				end
				
				if not Debounce_B and Button.Visible then
					Debounce_B = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					Apply_Color(Icons, Icon_Color_Down)
					Apply_Tween(Button, Clicked_Size, true)
					Callback_Down()
					Apply_Colors(Icons, Initial_Colors)
					Button.Size = Initial_Size
					Debounce_B = false
				end
			end))
		end
	end
end

-- Setup Button for pressed buttons
function Buttons_Mod.Button_Setup_OnPress(Cons, Button, Selected, Icons, Callback_Down, Callback_Up, Release_Event)
	if Selected:IsA("TextButton") or Selected:IsA("ImageButton") then
		local Debounce_B = false
		Button.Visible = true
		local Initial_Colors = Get_Initial_Color(Icons)
		local Initial_Size = Get_Initial_Size(Button)
		local Pressed_Size = Get_Ratio_Size(Initial_Size, Click_Size_Ratio)

		if Callback_Down~= nil then
			table.insert(Cons, Selected.MouseButton1Down:Connect(function()
				if not Debounce_B and Button.Visible then
					Debounce_B = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					Apply_Color(Icons, Icon_Color_Down)
					Apply_Tween(Button, Pressed_Size)
					Callback_Down()
				end
			end))
		end
		
		if Callback_Up ~= nil then
			
			local function Release_Handle()
				if Debounce_B then
					SE_Mod.PlaySFX(Plr, "Click_SE")
					Apply_Colors(Icons, Initial_Colors)
					Apply_Tween(Button, Initial_Size)
					Callback_Up()
					Debounce_B = false
				end
			end
			
			table.insert(Cons, Selected.MouseButton1Up:Connect(Release_Handle))
			table.insert(Cons, Selected.MouseLeave:Connect(Release_Handle))
			table.insert(Cons, Selected.InputEnded:Connect(Release_Handle))
			if Release_Event ~= nil then
				table.insert(Cons, Release_Event.Event:Connect(Release_Handle))
			end
		end
	end
end


-- Setup Button for Mouse Hover
function Buttons_Mod.Button_Setup_OnHover(Cons, Button, Selected, Icons)
	
end

return Buttons_Mod]]></ProtectedString>
								<string name="ScriptGuid">{505E13AE-A60C-4D61-B668-D042F7E0830A}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Fight_Buttons_Mod.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX996CC369F951478B9ED6408570C2ABB8">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Main_Fight_UI/Fight_Actions_Handle.server.lua
--
--  Description:
--      Server-side handler for all real-time combat actions.
--      Manages punches, blocking, dodging, stamina usage, hit-resolution,
--      force application, sounds, animations, and VFX.
--
--      Latest version includes:
--          • Unified hitbox system (players, bots, bags, mannequins)
--          • Factorized region detection & helpers
--          • Consolidated damage logic (block / dodge / direct hit)
--          • Improved regeneration handling (HP, Stamina, Block Power)
--          • Fully SecureRemote-protected strike inputs
--          • No gameplay or timing changes — behavior 100% preserved
--
--  Authors: Exclusible, Oriane, Seb
--  Last Modified: 2025-11-29 by Seb (refactor for optimization)
--  Version: V2025-09-Clean
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Modules: Utils, Channels
--          * Data_Mods_F: Animation_Mod, Sound_Mod,
--                        Stats_Manager_Mod, Fight_Params_Mod, Bots_Mod
--      - Workspace:
--          * Gameplay.Objects (Punching Bags, Manequins)
--          * Bots workspace folder (via Bots_Mod)
--      - Player Instance:
--          * Fight_Data (Health, Stamina, Block Power, Strike Power)
--          * Character (Humanoid, HRP, Head, Reset_Fight_Health_Data)
--
--  Notes:
--      - Clean refactor version (structure improved, no logic changes)
--      - All strike/block/dodge flows validated before execution
--======================================================================

----- SERVICES -----
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")

----- MODULES -----
local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Sound_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local Utils = require(RS.Modules:WaitForChild("Utils"))
local Channels = require(RS.Modules:WaitForChild("Channels"))

----- EVENTS -----
local Overhead_Display_E = Channels.SC_Remote_Events.Overhead_Display
local Punch_Hit_VFX = Channels.SC_Remote_Events.Show_Punch_Effects
local Got_Hit_Effect = Channels.SC_Remote_Events.Got_Hit_Effect
local Equipment_Strike = Channels.Bindable_Events.Equipment_Strike
local Unblocking_Strike = Channels.CS_Remote_Events.Unblocking_Strike
local Blocking_Strike = Channels.CS_Remote_Events.Blocking_Strike
local Dodging_Strike = Channels.CS_Remote_Events.Dodging_Strike
local Throwing_Strike = Channels.CS_Remote_Events.Throwing_Strike
local Toggle_Healing_Effect = Channels.CS_Remote_Events.Toggle_Healing_Effect

----- PLAYER -----
local Plr = script.Parent:FindFirstAncestorWhichIsA("Player")
local FD = Plr:WaitForChild("Fight_Data")

local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Head = Char:WaitForChild("Head")
local Reset_Fight_Health_Data_E = Char:WaitForChild("Reset_Fight_Health_Data")

----- FIGHT VALUES -----
local Health_V = FD:WaitForChild("Health")
local Block_Power_V = FD:WaitForChild("Block Power")
local Stam_V = FD:WaitForChild("Staminia")
local Strike_Power_V = FD:WaitForChild("Strike Power")

----- OBJECTS -----
local Main_World_F = workspace:WaitForChild("Main_World_F")
local Objects = Main_World_F.Gameplay.Objects
local GymObjects = Objects.GymObjects

local Boxing_Manequins = GymObjects.BoxingManequins:GetChildren()
local Punching_Bags = GymObjects.PunchingBags:GetChildren()

local Bots_Mod = require(RS.Data_Mods_F.Bots_Mod)
local BOTS_FOLDER = Bots_Mod.getBotsWorkspaceFolder()

----- FLAGS -----
local ResetOccur = false
local ConnectionToBP = nil
local SpCon = nil
local DAMAGE_COLOR = Color3.fromRGB(170, 85, 255)
local MAX_DAMAGE_COLOR = Color3.fromRGB(244, 244, 244)
local DODGE_COLOR = Color3.fromRGB(35, 244, 68)
local HITBOX_SIZE = Vector3.new(4, 8, 4)
local OVERLAP_PARAMS = OverlapParams.new()


----------------------------------------------------------------------
-- GENERAL HELPERS
----------------------------------------------------------------------

local function Verify_Player(p)
	return p == Plr and Char ~= nil and Hum ~= nil
end

local function Has_Enough_Stam(min)
	if Stam_V.Value >= min then
		Stam_V.Value -= min
		return true
	end
	return false
end

local function ComputeHitCFrame()
	return HRP.CFrame * CFrame.new(0, 0, -3) 
end

local function QueryHitbox(filterList)
	OVERLAP_PARAMS.MaxParts = 1
	OVERLAP_PARAMS.FilterType = Enum.RaycastFilterType.Include
	OVERLAP_PARAMS.FilterDescendantsInstances = filterList

	local region = workspace:GetPartBoundsInBox(ComputeHitCFrame(), HITBOX_SIZE, OVERLAP_PARAMS)
	return (region and region[1]) or nil
end

-- NEW: unified hitbox
local function Get_Any_Hit()
	local whitelist = {}

	-- players
	for _, p in ipairs(game.Players:GetPlayers()) do
		local c = p.Character
		if c and c ~= Char then
			local hum = c:FindFirstChildWhichIsA("Humanoid")
			if hum and hum.Health > 0 then
				table.insert(whitelist, c)
			end
		end
	end

	-- bots
	for _, bot in ipairs(BOTS_FOLDER:GetChildren()) do
		table.insert(whitelist, bot)
	end

	-- bags
	for _, b in ipairs(Punching_Bags) do
		table.insert(whitelist, b)
	end

	-- mannequins
	for _, m in ipairs(Boxing_Manequins) do
		table.insert(whitelist, m)
	end

	local part = QueryHitbox(whitelist)
	if not part then return nil end

	return part:FindFirstAncestorWhichIsA("Model")
end

----------------------------------------------------------------------
-- DAMAGE HELPERS
----------------------------------------------------------------------

local function Get_Damage_Color(v)
	local c0 = Color3.new(0.2, 0.2, 0.2)
	local c1 = Color3.new(1, 0, 0)
	return c0:Lerp(c1, math.clamp(v, 0, 1))
end

local function Play_Damage_Multi_Tween(delay)
	local params = Fight_Params_Mod.Punch_Power
	local info = TweenInfo.new(params.Reload_Time, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, delay)
	Strike_Power_V.Value = params.Min_Value
	TS:Create(Strike_Power_V, info, { Value = params.Max_Value }):Play()
end

local function Get_Target_Fight_Data(c)
	local plr = game.Players:GetPlayerFromCharacter(c)
	return plr and plr:FindFirstChild("Fight_Data") or c:FindFirstChild("Fight_Data")
end

----------------------------------------------------------------------
-- BOXING DUMMY
----------------------------------------------------------------------
local function Apply_Boxing_Dummy_Effects(dummy)
	local controller = dummy:FindFirstChildWhichIsA("AnimationController")
	if not controller then return end

	local aniId = 80256702338294
	local anim = dummy:FindFirstChild(aniId .. "_Ani") or Instance.new("Animation", dummy)
	anim.Name = aniId .. "_Ani"
	anim.AnimationId = "rbxassetid://" .. aniId

	local track = controller:LoadAnimation(anim)
	track.Looped = false
	track:Play()

	Sound_Mod.PlaySFX(HRP, "Punch_Hit_SE")
end

----------------------------------------------------------------------
-- HEALING / BLOCK REGEN
----------------------------------------------------------------------

local function Fight_Data_Growth_Handle()
	repeat task.wait() until Block_Power_V:GetAttribute("Is_Blocking") ~= nil

	local tHealth, tStam, tBlock
	local function ResetTweens()
		if tHealth then tHealth:Cancel(); tHealth = nil end
		if tStam then tStam:Cancel(); tStam = nil end
	end

	local function CreateReloadTween(valueObj, maxVal, factor)
		local delta = maxVal - valueObj.Value
		local t = math.clamp(delta, 0, Fight_Params_Mod.Health.Max_Value) * factor
		local info = TweenInfo.new(t, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
		return TS:Create(valueObj, info, { Value = maxVal })
	end

	local function StartHealing()
		local HP = Fight_Params_Mod.Health
		if HP.Reloading_Active then
			tHealth = CreateReloadTween(Health_V, HP.Max_Value, HP.Reload_Time_Factor)
			tHealth:Play()
		end
		local ST = Fight_Params_Mod.Stamina
		tStam = CreateReloadTween(Stam_V, ST.Max_Value, ST.Reload_Time_Factor)
		tStam:Play()
	end

	Block_Power_V.AttributeChanged:Connect(function(attr)
		if attr == "Is_Blocking" then
			ResetTweens()
			if Block_Power_V:GetAttribute("Is_Blocking") then
				StartHealing()
			end
		end
	end)

	if ResetOccur then
		Block_Power_V.Value = Fight_Params_Mod.Block_Power.Max_Value
		if tBlock then tBlock:Cancel(); tBlock = nil end
		return
	end

	local prev = Block_Power_V.Value
	if ConnectionToBP then
		ConnectionToBP:Disconnect()
	end

	ConnectionToBP = Block_Power_V.Changed:Connect(function()
		local last = prev
		prev = Block_Power_V.Value

		if Block_Power_V.Value < Fight_Params_Mod.Block_Power.Max_Value and Block_Power_V.Value < last then
			if tBlock then tBlock:Cancel(); tBlock = nil end
			if ResetOccur then
				Block_Power_V.Value = Fight_Params_Mod.Block_Power.Max_Value
				return
			end

			if SpCon then
				task.cancel(SpCon)
				Block_Power_V:SetAttribute("Is_Buffering", false)
			end

			Block_Power_V:SetAttribute("Is_Buffering", true)
			SpCon = task.spawn(function()
				task.wait(6)
				Block_Power_V:SetAttribute("Is_Buffering", false)
				local max = Fight_Params_Mod.Block_Power.Max_Value
				local time = math.clamp((max - Block_Power_V.Value) * 0.2667, 0.2667, 8)
				local info = TweenInfo.new(time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)

				tBlock = TS:Create(Block_Power_V, info, { Value = max })
				tBlock:Play()
				tBlock.Completed:Wait()
				tBlock = nil
			end)
		end
	end)

	Reset_Fight_Health_Data_E.Event:Connect(function()
		task.spawn(function()
			task.wait(3)
			ResetOccur = false
		end)

		ResetOccur = true
		if tBlock then tBlock:Cancel(); tBlock = nil end
		ResetTweens()

		Health_V.Value = Fight_Params_Mod.Health.Max_Value
		Stam_V.Value = Fight_Params_Mod.Stamina.Max_Value
		Block_Power_V.Value = Fight_Params_Mod.Block_Power.Max_Value
	end)
end
Fight_Data_Growth_Handle()

----------------------------------------------------------------------
-- DODGE
----------------------------------------------------------------------
Utils.SecureRemote(
	Dodging_Strike,
	function(P)
		local req = Fight_Params_Mod.Stamina.Min_To_Dodge
		if Verify_Player(P) and Has_Enough_Stam(req) then
			Sound_Mod.PlaySFX(HRP, "Missed_SE")
			Stam_V:SetAttribute("Is_Dodging", true)
			task.wait(0.5)
			Stam_V:SetAttribute("Is_Dodging", false)
		end
	end,
	{},
	{ 
		AllowMissingArgs = true, 
		MaxBurst = 5, 
		RateLimit = 10, 
		PunishThreshold = 50 
	}
)

----------------------------------------------------------------------
-- BLOCKING
----------------------------------------------------------------------
Blocking_Strike.OnServerEvent:Connect(function(player)
	if Verify_Player(player) and Block_Power_V.Value > 0 then
		Block_Power_V:SetAttribute("Is_Blocking", true)
		Toggle_Healing_Effect:FireClient(player, true)
	end
end)

Unblocking_Strike.OnServerEvent:Connect(function(P)
	if Verify_Player(P) then
		Block_Power_V:SetAttribute("Is_Blocking", false)
		Toggle_Healing_Effect:FireClient(P, false)
	end
end)

----------------------------------------------------------------------
-- MAIN PUNCH HANDLER
----------------------------------------------------------------------
Utils.SecureRemote(
	Throwing_Strike,

	function(P, Strike_Key, Dir)
		local req = Fight_Params_Mod.Stamina.Min_To_Hit

		if not (Verify_Player(P) and HRP and Animation_Mod.Player_Owns_Strike_Key(P, Strike_Key) and Has_Enough_Stam(req)) then
			return
		end

		-- unified hitbox
		local hitModel = Get_Any_Hit()

		local strikeData = Animation_Mod.Get_Strike_Combo_Data(Strike_Key)
		local dmgMulti = Strike_Power_V.Value
		Play_Damage_Multi_Tween(strikeData["Time Length"])

		local base = strikeData["Damage"]
		local punchPower = math.round(base * dmgMulti)

		Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Strikes", 1)
		Plr:SetAttribute("Did_Punch_Last", strikeData["Punch"])

		-- HIT?
		if hitModel then

			local fd = Get_Target_Fight_Data(hitModel)

			------------------------------------------------------------------
			-- HIT PLAYER
			------------------------------------------------------------------
			if fd then
				local H = fd["Health"]
				local BP = fd["Block Power"]
				local ST = fd["Staminia"]

				local function IsDodging()
					if ST:GetAttribute("Is_Dodging") then
						local tPlr = game.Players:GetPlayerFromCharacter(hitModel)
						if tPlr then
							Stats_Manager_Mod.Add_To_Player_Stats_Data(tPlr, "Dodged Strikes", 1)
						end
						return true
					end
					return false
				end

				local function IsBlocking()
					if BP:GetAttribute("Is_Blocking") then
						BP.Value -= punchPower

						Overhead_Display_E:FireAllClients(hitModel, `-{punchPower}`, DAMAGE_COLOR)

						local tPlr = game.Players:GetPlayerFromCharacter(hitModel)
						if tPlr then Got_Hit_Effect:FireClient(tPlr) end

						if BP.Value < 0 then
							local diff = math.abs(BP.Value)
							H.Value = math.clamp(H.Value - diff, 0, 100)
							BP.Value = 0

							Sound_Mod.PlaySFX(HRP, "Punch_Hit_SE")
							Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
							Overhead_Display_E:FireAllClients(hitModel, `-{diff}`, Get_Damage_Color(dmgMulti))
						else
							Sound_Mod.PlaySFX(HRP, "Blocked_Hit_SE")
						end
						return true
					end
					return false
				end

				if IsDodging() then
					Overhead_Display_E:FireAllClients(hitModel, "Dodged", DODGE_COLOR)

				elseif IsBlocking() then
					-- nothing

				else
					H.Value = math.clamp(H.Value - punchPower, 0, 100)
					Sound_Mod.PlaySFX(HRP, "Punch_Hit_SE")
					Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)

					if dmgMulti == Fight_Params_Mod.Punch_Power.Max_Value then
						Overhead_Display_E:FireAllClients(hitModel, "Max Damage!", MAX_DAMAGE_COLOR)
					end

					Overhead_Display_E:FireAllClients(hitModel, `-{punchPower}`, Get_Damage_Color(dmgMulti))
					Punch_Hit_VFX:FireClient(Plr, hitModel)

					local tPlr = game.Players:GetPlayerFromCharacter(hitModel)
					if tPlr then Got_Hit_Effect:FireClient(tPlr) end

					local tHRP = hitModel:FindFirstChild("HumanoidRootPart")
					if tHRP then
						local force = 625
						tHRP:ApplyImpulse(HRP.CFrame.LookVector * force * tHRP:GetMass())
					end
				end

				------------------------------------------------------------------
				-- HIT BAG / DUMMY
				------------------------------------------------------------------
			else
				-- dummy
				if hitModel:FindFirstChildWhichIsA("AnimationController") then
					Apply_Boxing_Dummy_Effects(hitModel)
					Equipment_Strike:Fire(Plr, hitModel)
					return
				end

				-- punching bag
				local bagHRP = hitModel:FindFirstChild("Handle") or hitModel:FindFirstChildWhichIsA("BasePart")
				if bagHRP then
					local force = 50
					bagHRP:ApplyImpulse(HRP.CFrame.LookVector * force * bagHRP:GetMass())
					Equipment_Strike:Fire(Plr, hitModel)
					Sound_Mod.PlaySFX(HRP, "Punch_Hit_SE")
					return
				end
			end

		end
	end,

	{ "string", "Vector3" },

	{
		AllowMissingArgs = true,
		MaxBurst = 15,
		RateLimit = 20,
		PunishThreshold = 50
	}
)]]></ProtectedString>
							<string name="ScriptGuid">{B2D979B8-0766-4FC5-BB62-8EF4B6B27302}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Fight_Actions_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX729981F07FB84EFA9E7105DBA3ACCCD0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Fight_Main_UI</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX1DBC474A3BA14447B0C01471F240C17A">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--// Services
local RS = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Player:Player = Players.LocalPlayer

local Char = Player.Character or Player.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")

-- Modules
local Data_Mods_F = RS:FindFirstChild("Data_Mods_F")
local Bots_Mod = require(game.ReplicatedStorage.Data_Mods_F.Bots_Mod)
local BOTS_FOLDER = Bots_Mod.getBotsWorkspaceFolder()
local Vendor:Folder = RS:FindFirstChild("Vendor")
local Trove = require(Vendor:FindFirstChild("Trove"))

-- Events
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local New_Round_Display 	= Channels.Bindable_Events.New_Round_Display
local Toggle_Fight_UI 		= Channels.Bindable_Events.Toggle_Fight_UI

local RoundChangeHandler = require(script.RoundChangeHandler)
local BindThumbnail = require(script.BindThumbnail)
local WrapStats = require(script.WrapStats)

local ScreenGui = script:FindFirstAncestorWhichIsA("ScreenGui")
local Fighters_Stats_F = ScreenGui:FindFirstChild("Fighters_Stats_F")

local MainFrame = Fighters_Stats_F:FindFirstChild("Frame")
local LocalUserFrame = MainFrame:FindFirstChild("LocalUser")
local OtherUserFrame = MainFrame:FindFirstChild("OtherUser")

local LocalUserThumbnail = LocalUserFrame:FindFirstChild("Thumbnail",true)
local OtherUserThumbnail = OtherUserFrame:FindFirstChild("Thumbnail",true)

local PlayerStats = WrapStats(LocalUserFrame)
local OtherStats = WrapStats(OtherUserFrame)

BindThumbnail(LocalUserThumbnail,Player)

local Debounce_UI = false
local ActiveTrove = Trove.new()

local function Disconnect_Cons()
	ActiveTrove:Clean()
end

local function Setup_Round_Change_Handle(Round_V)
	ActiveTrove:Connect(Round_V.Changed,function()
		if(Round_V.Value > 1)then
			task.delay(0.5,RoundChangeHandler.load,Round_V.Value)
		end
	end)
end

New_Round_Display.Event:Connect(RoundChangeHandler.load)

local function Get_Fight_Data_Vals(C_Name, root)
	local P_Char
	if root == nil then
		P_Char = game.Workspace:FindFirstChild(C_Name)
	else
		P_Char = root:FindFirstChild(C_Name)
	end
	if(P_Char ~= nil)then
		local Plr_Obj = game.Players:GetPlayerFromCharacter(P_Char)
		if(Plr_Obj ~= nil and Plr_Obj:FindFirstChild("Fight_Data") ~= nil)then
			local FD = Plr_Obj:FindFirstChild("Fight_Data")
			return FD:FindFirstChild("Health"), FD:FindFirstChild("Staminia")

		elseif(P_Char:FindFirstChild("Fight_Data") ~= nil)then
			local FD = P_Char:FindFirstChild("Fight_Data")
			return FD:FindFirstChild("Health"), FD:FindFirstChild("Staminia")
		end
	else
		if root == nil then
			return Get_Fight_Data_Vals(C_Name, BOTS_FOLDER)
		end
	end

	return nil, nil
end

local function Reset_Display()	
	ActiveTrove:Clean()
	ActiveTrove = Trove.new() 
	Fighters_Stats_F.Visible = false
	Debounce_UI = false
end

local function Get_Opponents_Names(fight_data)
	local Fight_Char_1 = fight_data:FindFirstChild("Fight_Char_1")
	local Fight_Char_2 = fight_data:FindFirstChild("Fight_Char_2")
	
	local Your_Name = Char.Name
	local Other_Name = ""
	
	if(Fight_Char_1.Value.Name == Your_Name)then
		Other_Name = Fight_Char_2.Value.Name
	else
		Other_Name = Fight_Char_1.Value.Name
	end
	
	BindThumbnail(OtherUserThumbnail,Other_Name)
	return Your_Name, Other_Name
end

local function Setup_Health_Stam_Handle(Your_Name, Other_Name)
	--Health and Stam display Tracking
	local Your_Health_V, Your_Stam_V = Get_Fight_Data_Vals(Your_Name)
	if(Your_Health_V ~= nil)then
		PlayerStats.UpdateHealth(Your_Health_V.Value)
		ActiveTrove:Connect(Your_Health_V.Changed,function()
			PlayerStats.UpdateHealth(Your_Health_V.Value)
		end)
	end

	if(Your_Stam_V ~= nil)then
		PlayerStats.UpdateStamina(Your_Stam_V.Value)

		ActiveTrove:Connect(Your_Stam_V.Changed,function()
			PlayerStats.UpdateStamina(Your_Stam_V.Value)
		end)
	end

	local Other_Health_V, Other_Stam_V = Get_Fight_Data_Vals(Other_Name)
	if(Other_Health_V ~= nil)then
		OtherStats.UpdateHealth(Other_Health_V.Value)
		ActiveTrove:Connect( Other_Health_V.Changed,function()
			OtherStats.UpdateHealth(Other_Health_V.Value)
		end)
	end

	if(Other_Stam_V ~= nil)then
		OtherStats.UpdateStamina(Other_Stam_V.Value)
		ActiveTrove:Connect( Other_Stam_V.Changed,function()
			OtherStats.UpdateStamina(Other_Stam_V.Value)
		end)
	end

	Fighters_Stats_F.Visible = true
end

Toggle_Fight_UI.Event:Connect(function(Should_Show, cage_M)
	if Should_Show then
		if not Debounce_UI then
			if(cage_M ~= nil) then 
				local Fight_Data_F = cage_M:FindFirstChild("Fight_Data_F")
				
				local Round_Count_V = Fight_Data_F:FindFirstChild("Round_Count") 
				local Your_Name, Other_Name = Get_Opponents_Names(Fight_Data_F)
				Disconnect_Cons()
				-- Display Stamina and Health bars
				Setup_Health_Stam_Handle(Your_Name, Other_Name)
				-- Display round number
				Setup_Round_Change_Handle(Round_Count_V)
			end
		end
	else
		-- 🔹 Forcer toujours la fermeture
		Reset_Display()
	end
end)

]]></ProtectedString>
								<string name="ScriptGuid">{9109B385-59BE-4760-84E7-530EB2010C32}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Fight_Main_UI_Handle.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXF4AC75335ACE420D9EF016243BB51049">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Fight_Main_UI_Handle</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX084CF2B119304C4799B9EFA78E99A4F0">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local ReplicatedStorage:ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players:Players = game:GetService("Players")
local Player:Player = Players.LocalPlayer

local Vendor:Folder = ReplicatedStorage:FindFirstChild("Vendor")


local Data_Mods_F = ReplicatedStorage:FindFirstChild("Data_Mods_F")
local Sound_Mod = require(Data_Mods_F:FindFirstChild("Sound_Mod"))

local Main_World_F = game.Workspace:WaitForChild("Main_World_F")
local Objects = Main_World_F:WaitForChild("Gameplay"):WaitForChild("Objects")
local Fight_Cages_F:Folder = Objects:WaitForChild("Fight_Cages_F")

local ScreenGui:ScreenGui = script:FindFirstAncestorWhichIsA("ScreenGui")

local Round_Change_F = ScreenGui.Round_Change_F
local Bottom_Move_F = Round_Change_F.Bottom_F
local Round_Main_F = Round_Change_F.Main_F
local Round_Main_Txt = Round_Main_F.Main_Txt

local RoundChangeHandler = {}

function RoundChangeHandler.load(Round_Num)
	local Char:Model? = Player.Character or Player.CharacterAdded:Wait()

	Sound_Mod.PlaySFX(Player, "Start_Fight_Bell_SE")
	Sound_Mod.Play_Voice_Over("Round_" .. Round_Num)

	local function Reset_Display()
		local function Get_Max_Rounds()
			local All_Cages_M = Fight_Cages_F:GetChildren()

			local function Is_Main_Cage(Cage_M)
				local FD = Cage_M:FindFirstChild("Fight_Data_F")
				if(FD ~= nil and FD:FindFirstChild("Fight_Char_1") ~= nil and 
					FD:FindFirstChild("Fight_Char_2") ~= nil)then

					local C1_V = FD:FindFirstChild("Fight_Char_1")
					local C2_V = FD:FindFirstChild("Fight_Char_2")
					if(C1_V.Value == Char or C2_V.Value == Char) then
						return true
					end
				end

				return false
			end

			for i = 1, #All_Cages_M do
				local Cage_M = All_Cages_M[i]
				if(Cage_M ~= nil and Is_Main_Cage(Cage_M))then
					local Is_Ranked = (Cage_M:GetAttribute("Cage_Type") or "") == "RANKED"	
					if(Is_Ranked ~= nil and Is_Ranked == true)then
						return 5
					end
				end
			end

			return 3
		end

		Round_Change_F.Visible = false
		Round_Main_F.Position = UDim2.new(1, 0, 0, 0)
		Bottom_Move_F.Position = UDim2.new(-1, 0, 0, 0)
		Round_Main_Txt.Text = "ROUND " .. Round_Num .. " OF " .. Get_Max_Rounds()
		Round_Main_Txt.Visible = true
		Round_Main_Txt.Position = UDim2.new(0.5, 0, 0.5, 0)
	end
	Reset_Display()

	local function Show_Main()
		Round_Change_F.Visible = true
		Bottom_Move_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		Round_Main_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		task.wait(0.25)
	end
	Show_Main()

	local function Slight_Move()
		Bottom_Move_F:TweenPosition(UDim2.new(0.125, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 1, true, nil)
		Round_Main_F:TweenPosition(UDim2.new(-0.125, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 1, true, nil)

		task.wait(1)
	end
	Slight_Move()

	local function Move_Out()
		Bottom_Move_F:TweenPosition(UDim2.new(1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		Round_Main_F:TweenPosition(UDim2.new(-1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		task.wait(0.25)	
	end
	Move_Out()

	Reset_Display()
end

return RoundChangeHandler]]></ProtectedString>
									<string name="ScriptGuid">{B727916D-46F5-4377-A8E2-8524E55DBA4C}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">RoundChangeHandler.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBE54FFB84AD34DD6B947A36E6FFED507">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Spr = require(ReplicatedStorage.Vendor.Spr)

local DEFAULT_SIZE = UDim2.fromScale(1,1)
local DEFAULT_TEXT = "100"

local COLOR_VALUES = {
	ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(135, 255, 154)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(35, 244, 68)),
	}), 
	ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 183, 3)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(251, 133, 0)),
	}), 
	ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 89, 94)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(222, 55, 69)),
	})
}

return function(statsFrame:Frame)
	local healthBar:Frame = statsFrame:FindFirstChild("HealthBar",true)
	local staminaBar:Frame = statsFrame:FindFirstChild("StaminaBar",true)

	local healthBarTxt:TextLabel = healthBar:FindFirstChild("Txt",true)
	local healthBarLoader:ImageLabel = healthBar:FindFirstChild("Loader",true)

	local staminaBarTxt:TextLabel = staminaBar:FindFirstChild("Txt",true)
	local staminaBarLoader:ImageLabel = staminaBar:FindFirstChild("Loader",true)

	local healthGradient = healthBarLoader:FindFirstChildWhichIsA("UIGradient")

	return {
		Reset = function()
			healthBarTxt.Text = DEFAULT_TEXT
			staminaBarTxt.Text = DEFAULT_TEXT
			healthBarLoader.Size = DEFAULT_SIZE
			staminaBarLoader.Size = DEFAULT_SIZE
			if healthGradient then
				healthGradient.Color = COLOR_VALUES[1]
			end
		end,
		UpdateHealth = function(value:number)
			if not (value and type(value) == "number") then
				warn("value param is not valid", value)
				return
			end

			healthBarTxt.Text = tostring(value)
			Spr.target(healthBarLoader, 0.6, 2, {
				Size = UDim2.fromScale(value / 100, 1) 
			})

			if healthGradient then
				if value >= 60 then
					healthGradient.Color = COLOR_VALUES[1]
				elseif value <= 39 then
					healthGradient.Color = COLOR_VALUES[3]
				else
					healthGradient.Color = COLOR_VALUES[2]
				end
			end
		end,

		UpdateStamina = function(value)
			if not (value and type(value) == "number") then
				warn("value param is not valid",value)
				return
			end

			staminaBarTxt.Text = tostring(value)
			Spr.target(staminaBarLoader,0.6,2,{
				Size = UDim2.fromScale(value/100,1)
			})
		end,
	}
end]]></ProtectedString>
									<string name="ScriptGuid">{03CF798B-B2C6-471E-88CD-333C3FF09C58}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">WrapStats.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF1F3DAF60A5643A19FED54D358D292FF">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local Players:Players = game:GetService("Players")


local DEFAULT_IMG = "rbxassetid://134663290660847"

local function tryGet(player:Player)
	local success,res =  pcall(function()
		return Players:GetUserThumbnailAsync(player.UserId,Enum.ThumbnailType.HeadShot,Enum.ThumbnailSize.Size150x150)
	end)

	if not success then
		return false
	end

	return true,res
end

return function(label:ImageLabel,player:Player|string)
	if not (label and typeof(label) == "Instance" and label:IsA("ImageLabel")) then
		return
	end

	if typeof(player) ~= "Instance" then
		if typeof(player) ~= "string" then
			label.Image = DEFAULT_IMG
			return
		end
		local foundPlayer = Players:FindFirstChild(player)
		if not foundPlayer then
			label.Image = DEFAULT_IMG
			return
		end
		
		player = foundPlayer
	end

	local success,thumbnail = tryGet(player)
	local tries = 0
	while (not success and tries < 2) do
		tries += 1
		success,thumbnail = tryGet(player)
		task.wait()
	end 

	if not success then
		label.Image = DEFAULT_IMG
		return

	end

	label.Image = thumbnail
end]]></ProtectedString>
									<string name="ScriptGuid">{283C9219-1BD8-49BB-A478-3069E47311D1}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">BindThumbnail.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXD78B674C50B546C3B9BC646BFC5A61CB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Submission_UI</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX57744994849D4836AA9E39DC8D7CF73C">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--Use to track Client Clicking Speed
	--> On Click Event
		--> Sent Rate Event
	--> Reset Rate Event
	
-- Services
local RS = game:GetService("ReplicatedStorage")

-- Events
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Click_Rate_Reset		= Channels.Bindable_Events.Click_Rate_Reset
local Click_Rate_Inc		= Channels.Bindable_Events.Click_Rate_Inc
local Click_Rate_Update		= Channels.Bindable_Events.Click_Rate_Update

local Start_Time, Total_Clicks = os.time(), 0

local function Round_Rate(Raw_Rate)
	local Boosted_Rate = math.ceil(Raw_Rate * 10)
	return Boosted_Rate / 10
end

Click_Rate_Reset.Event:Connect(function()
	Start_Time, Total_Clicks = os.time(), 0
end)

Click_Rate_Inc.Event:Connect(function()
	local Current_Time = os.time()
	if(Total_Clicks == 0)then
		Start_Time = Current_Time
		Total_Clicks = 1
	else
		Total_Clicks = Total_Clicks + 1
	end
	
	local Rate = Round_Rate(Total_Clicks / (Current_Time - Start_Time))
	Click_Rate_Update:Fire(Rate)
end)]]></ProtectedString>
								<string name="ScriptGuid">{963F6F5C-28B1-4A49-A15E-0E44E68D7821}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Click_Rate_System.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX135CBC21F70048C6A463FE8158FFC8DC">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TS = game:GetService("TweenService")

local myPlayer = game.Players.LocalPlayer
local Char = myPlayer.Character or myPlayer.CharacterAdded:Wait()
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

-- Events
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Show_White_Fade 		= Channels.Bindable_Events.Show_White_Fade
local Remove_Submission_UI	= Channels.Bindable_Events.Remove_Submission_UI
local Submission_Minigame_Update 	= Channels.SC_Remote_Events.Submission_Minigame_Update
local Click_Rate_Reset		= Channels.Bindable_Events.Click_Rate_Reset
local Click_Rate_Inc		= Channels.Bindable_Events.Click_Rate_Inc
local Click_Rate_Update		= Channels.Bindable_Events.Click_Rate_Update
local On_Submission_Handle	= Channels.Bindable_Events.On_Submission_Handle

--UI Elements
local fightingGui = script.Parent
local mainBarFrame = fightingGui:WaitForChild("Main_Bar_F")
local myPlayerBar = mainBarFrame:WaitForChild("Player_Bar_F")
local Click_Txt = mainBarFrame:WaitForChild("Click_Txt")

local opponentThumbnail = mainBarFrame:WaitForChild("Opponent_F")
local playerThumbnail = mainBarFrame:WaitForChild("Plr_F")

local inGame = false
local clickConnection = nil
local progressConnection = nil

local Player_Thumbnail_Data = {

}
local function Get_Player_Thumbnail(ID)
	if(Player_Thumbnail_Data[ID] ~= nil)then
		return Player_Thumbnail_Data[ID]
	else
		local Type = Enum.ThumbnailType.HeadShot
		local Size = Enum.ThumbnailSize.Size420x420

		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				Data = game.Players:GetUserThumbnailAsync(ID, Type, Size)
			end)

			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end

		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				Player_Thumbnail_Data[ID] = D
				return D
			end
		end

		return "rbxassetid://100127687172105"
	end
end

local function StartGame(flip : boolean, clickedEvent, P1, P2)
	local Update_Tween = TweenInfo.new(0.125, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
	TS:Create(Cam, Update_Tween, {FieldOfView = 70}):Play()
	
	clickConnection = UserInputService.InputBegan:Connect(function(input : InputObject, gpe : boolean)
		if gpe then	
			return
		end
		
		if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 or input.KeyCode == Enum.KeyCode.ButtonY then
			clickedEvent:FireServer()
		end
	end)
	
	progressConnection = clickedEvent.OnClientEvent:Connect(function(informationTable)
		Click_Rate_Inc:Fire()
		local range = Fight_Params_Mod.Submission_Minigame.Winning_Score - Fight_Params_Mod.Submission_Minigame.Loosing_Score 
		local progress = informationTable.gameProgress / range
		if flip then
			progress = 1 - progress
		end
		myPlayerBar.Size = UDim2.fromScale(progress, myPlayerBar.Size.Y.Scale)
		
		local FOV = math.clamp(70 - (25 * progress), 45, 70)
		TS:Create(Cam, Update_Tween, {FieldOfView = FOV}):Play()
		
	end)
	inGame = true
	
	local Submission_Char_V = clickedEvent.Parent
	local Is_Attacking = (Submission_Char_V.Value == Char)
	
	On_Submission_Handle:Fire(Is_Attacking, true)
	
	local function Display_Handle()
		Click_Rate_Reset:Fire()
		
		local function Update_Icon_Images()
			opponentThumbnail.Image = "rbxassetid://100127687172105"
			playerThumbnail.Image = "rbxassetid://100127687172105"
			
			if(P1 ~= nil)then
				local Image = Get_Player_Thumbnail(P1.UserId)
				if(P1 == myPlayer)then
					playerThumbnail.Image = Image
				else
					opponentThumbnail.Image = Image
				end
			end
			
			if(P2 ~= nil)then
				local Image = Get_Player_Thumbnail(P2.UserId)
				if(P2 == myPlayer)then
					playerThumbnail.Image = Image
				else
					opponentThumbnail.Image = Image
				end
			end
		end
		Update_Icon_Images()
		
		mainBarFrame.Visible = false
		mainBarFrame.Position = UDim2.new(0.5, 0, 1.25, 0)
		mainBarFrame:TweenPosition(UDim2.new(0.5, 0, 0.975, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
		mainBarFrame.Visible = true
	end
	
	Display_Handle()
	
	local function Show_Heart_Beat_Effects()
		-- TODO check regression on sound
		while inGame do
			SE_Mod.PlaySFX(Char, "Heartbeat_SE")
			for i = 1, 2 do
				if(inGame)then
					Show_White_Fade:Fire(Color3.fromRGB(255, 75, 75))
					task.wait(0.75)
				end
			end
			task.wait(1)
		end
	end
	task.spawn(Show_Heart_Beat_Effects)
end

local function EndGame()
	if clickConnection then
		clickConnection:Disconnect()
	end

	if progressConnection then
		progressConnection:Disconnect()
	end

	inGame = false

	mainBarFrame:TweenPosition(
		UDim2.new(0.5, 0, 1.25, 0),
		Enum.EasingDirection.In,
		Enum.EasingStyle.Back,
		0.375,
		true,
		function()
			mainBarFrame.Visible = false -- 🔑 force le masquage une fois le tween terminé
		end
	)

	On_Submission_Handle:Fire(false, false)
end


Submission_Minigame_Update.OnClientEvent:Connect(function(command : string, args : {}, clicked_Event)
	if command == "START" then
		if inGame then
			warn("Player in game already")
			return
		end
		
		StartGame(args.flip, clicked_Event, args.P1, args.P2)
	elseif command == "STOP" then
		EndGame()
	end
end)


Remove_Submission_UI.Event:Connect(function()
	-- Arrêter le mini-jeu
	EndGame()

	-- Forcer reset du texte et de la barre
	Click_Rate_Reset:Fire()
end)

Click_Rate_Update.Event:Connect(function(Rate)
	Click_Txt.Text = "Start Tapping!"--" (" .. Rate .. "/s)"
end)
]]></ProtectedString>
								<string name="ScriptGuid">{21761FAD-1781-4B29-9FD2-0AB25938EE6F}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Client_Submission_Handle.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX5F51DFEF8891404C9C0598BA930930CE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Fight_Inputs_UI</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX20BB8D89966E4DE8A64BE73151754E83">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Toggle_Key_Labels_E		= Channels.Bindable_Events.Toggle_Key_Labels
local Get_Fights_Keys			= Channels.Bindable_Functions.Get_Fights_Keys
local Get_Mobile_Buttons 		= Channels.CS_Remote_Functions.Get_Mobile_Buttons

-- UI References
local Inputs_UI = script.Parent

local KeybindsFrames = {
	Mobile = Inputs_UI:WaitForChild("Mobile_Buttons_F"),
	PC = Inputs_UI:WaitForChild("Key_Labels_F"),
	Console = Inputs_UI:WaitForChild("Key_Labels_G"),
	PS5 = Inputs_UI:WaitForChild("Key_Labels_PS5")
}

local bindsState = false

local function Get_Device()
	local device
	if UIS.TouchEnabled then
		device = "Mobile"
	else 
		if UIS.KeyboardEnabled and not UIS.GamepadEnabled then
			device = "PC"
		elseif UIS.GamepadEnabled then
			device = "Console"

			local Mapped_Key = UIS:GetStringForKeyCode(Enum.KeyCode.ButtonX)
			if(Mapped_Key ~= nil and Mapped_Key ~= "ButtonX")then
				device = "PS5"
			end
		else
			device = "Mobile"
		end
	end
	return device
end

local function UpdateKeybindsUI(state)
	if state == bindsState then
		return
	end

	bindsState = state
	local device = Get_Device()

	KeybindsFrames.Mobile.Visible = device == "Mobile" and bindsState == true
	KeybindsFrames.PC.Visible = device == "PC" and bindsState == true
	KeybindsFrames.Console.Visible = device == "Console" and bindsState == true
	KeybindsFrames.PS5.Visible = device == "PS5" and bindsState == true
end

Toggle_Key_Labels_E.Event:Connect(function(Should_Show)
	UpdateKeybindsUI(Should_Show)
end)

Get_Mobile_Buttons.OnInvoke = function()
	return KeybindsFrames.Mobile:GetChildren()
end

Get_Fights_Keys.OnInvoke = function()
	local device = Get_Device()
	
	local isMobile = device == "Mobile"
	local FrameSource = isMobile and KeybindsFrames.Mobile or KeybindsFrames[device]

	return {
		Device = device,
		
		Punch = isMobile and FrameSource:WaitForChild("Punching_B") or FrameSource:WaitForChild("Punch_F"),
		Kick = isMobile and FrameSource:WaitForChild("Kicking_B") or FrameSource:WaitForChild("Kick_F"),
		Block = isMobile and FrameSource:WaitForChild("Block_B") or FrameSource:WaitForChild("Block_F"),
		Dodge = isMobile and FrameSource:WaitForChild("Dodge_B") or FrameSource:WaitForChild("Dodge_F"),
		Takedown = isMobile and FrameSource:WaitForChild("Takedown_B") or FrameSource:WaitForChild("Takedown_F"),
		
		Damage_Bar = script.Parent:WaitForChild("Damage_Bar_F"),
		Damage_Bar_Gauge = script.Parent.Damage_Bar_F:WaitForChild("Gauge"),
		Takedown_Progress = script.Parent:WaitForChild("Takedown_Progress_F").Frame,

		Shield = Plr.Character.Fighting_UI.Main_F.Shield_F,
		Health_Bar = Plr.PlayerGui.Fight.Fight_System_UI:FindFirstChild("LocalUser", true):FindFirstChild("HealthBar", true),
		Stamina_Bar = Plr.PlayerGui.Fight.Fight_System_UI:FindFirstChild("LocalUser", true):FindFirstChild("StaminaBar", true),

		Direction = isMobile and script.Parent:WaitForChild("Mobile_Direction_F") or nil
	}
end]]></ProtectedString>
								<string name="ScriptGuid">{4CE86F94-13F7-4DE4-AF16-DA88D7B6C574}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Inputs_Keys_Handle.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA7F974EC24A546C6A9B164699B0B95A3">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[----- DEPENDENCIES -----

--// Services
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local Players:Players = game:GetService("Players")

--// Modules
local Vendor:Folder = RS:FindFirstChild("Vendor")
local Trove = require(Vendor:FindFirstChild("Trove"))

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Toggle_Takedown_Tracker	= Channels.Bindable_Events.Toggle_Takedown_Tracker

----- REFERENCES -----

--// Player and Character
local Player:Player = Players.LocalPlayer
local Char = Player.Character or Player.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")

--// Objects and GUI
local ScreenGui = script:FindFirstAncestorWhichIsA("ScreenGui")
local Takedown_Progress_F:Frame = ScreenGui:FindFirstChild("Takedown_Progress_F")
local Per_Data_Txt = Takedown_Progress_F.Frame.Per_Txt
local Key_Label_G = Takedown_Progress_F.Frame.Key_Label_G
local Key_Label_PS5 = Takedown_Progress_F.Frame.Key_Label_PS5
local Key_Label_PC = Takedown_Progress_F.Frame.Key_Label_PC
local Wheel = Takedown_Progress_F.Frame.Wheel
local Wheel_cursor = Takedown_Progress_F.Frame.Wheel_cursor

--// Variables
local Debounce_UI = false
local ActiveTrove = Trove.new()

local Max_Rotation_Wheel = 80
local Min_Rotation_Wheel = -80
local Rotation_Increment = 15

local function Reset_Display()	
	ActiveTrove:Clean()
	ActiveTrove = Trove.new() -- 🔹 recrée un Trove propre
	
	Takedown_Progress_F.Visible = false
	Debounce_UI = false
end


local function Setup_Takedown_Tracking_Handle(Tracking_Val)	

	local function Reset_UI()
		Takedown_Progress_F.Visible = false

		Per_Data_Txt.Text = "-"
		Per_Data_Txt.TextColor3 = Color3.fromRGB(200, 200, 200)

		Key_Label_G.Visible = false -- UserInputService.GamepadEnabled and not UserInputService.TouchEnabled
		Key_Label_PC.Visible = false -- not UserInputService.GamepadEnabled and not UserInputService.TouchEnabled
	end
	Reset_UI()

	Takedown_Progress_F.Visible = true
	
	local function Set_Up_Connections()
		local function Get_Tracker_Values()
			local Value, Your_Val, Other_Val = false, 0, 0

			for Plr_Name, Prog in next, Tracking_Val:GetAttributes() do
				if(Plr_Name == Char.Name)then
					Your_Val = Prog
				else
					Other_Val = Prog
				end
			end

			return Tracking_Val.Value, Your_Val, Other_Val
		end

		local function Update_Prog_Displays()
			local Value, Your_Val, Other_Val = Get_Tracker_Values()
			local Difference = Your_Val - Other_Val
			
			-- Update Text 
			if Difference>0 then
				Per_Data_Txt.TextColor3 = Color3.fromRGB(0, 255, 0)
				Per_Data_Txt.Text = "+"..Your_Val
			elseif Difference < 0 then
				Per_Data_Txt.TextColor3 = Color3.fromRGB(255, 0, 0)
				Per_Data_Txt.Text = "-"..Other_Val
			elseif Difference == 0 then
				Per_Data_Txt.TextColor3 = Color3.fromRGB(255, 255, 255)
				Per_Data_Txt.Text = "="
			end
			
			-- Update Wheel rotation
			
			local Wheel_Rotation = 0
			if Value then
				if Your_Val > 0 then
					Wheel_Rotation = Max_Rotation_Wheel
					local PS5 = false
					local Mapped_Key = UIS:GetStringForKeyCode(Enum.KeyCode.ButtonX)
					if (Mapped_Key ~= nil and Mapped_Key ~= "ButtonX")then
						PS5 = true
					end
					Key_Label_PS5.Visible = not UIS.TouchEnabled and UIS.GamepadEnabled and PS5
					Key_Label_G.Visible = not UIS.TouchEnabled and UIS.GamepadEnabled and not PS5
					Key_Label_PC.Visible = not UIS.TouchEnabled and not UIS.GamepadEnabled
				else 
					Wheel_Rotation = Min_Rotation_Wheel
				end
			else 
				Wheel_Rotation = math.clamp(Rotation_Increment * Difference, Min_Rotation_Wheel, Max_Rotation_Wheel)
				Key_Label_G.Visible = false 
				Key_Label_PS5.Visible = false 
				Key_Label_PC.Visible = false
			end
			Wheel.Rotation = Wheel_Rotation
			Wheel_cursor.Rotation =Wheel_Rotation
		end
		Update_Prog_Displays()

		ActiveTrove:Connect(Tracking_Val.AttributeChanged,function(Attrib_Key)
			Update_Prog_Displays()
		end)
	end
	Set_Up_Connections()

	Takedown_Progress_F.Visible = true
	Debounce_UI = true
end


Toggle_Takedown_Tracker.Event:Connect(function(Should_Show, cage_M)
	if Should_Show then
		if not Debounce_UI then
			if(cage_M ~= nil) then 
				local Fight_Data_F = cage_M:FindFirstChild("Fight_Data_F")
				local Takedown_Tracking_V = Fight_Data_F:FindFirstChild("Takedown_Track") 
				if Takedown_Tracking_V then
					Setup_Takedown_Tracking_Handle(Takedown_Tracking_V)
				end
			end
		end
	else
		-- 🔹 Forcer toujours la fermeture
		Reset_Display()
	end
end)

]]></ProtectedString>
								<string name="ScriptGuid">{E647FA0D-A9DE-40BF-B3A8-0905531C913F}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Takedown_Tracker_Handle.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX23AB76EC359248A197B83ECFA684CBF9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_Teleport_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXBAE72CD58342429FB27BD308F665C470">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local UIS = game:GetService("UserInputService")
local TS = game:GetService("TweenService")

local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Fight_Prompts_V = PD:WaitForChild("Fight Prompts")

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)
local Fight_Params_Mod 	= require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local MenuButtons_Mod 	= require(RS.Design.MenuButtons)
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Transition_Hole_UI 		= Channels.Bindable_Events.Transition_Hole_UI
local Open_Settings				= Channels.Bindable_Events.Open_Settings
local Fight_Spawn_Notification 	= Channels.SC_Remote_Events.Fight_Spawn_Notification

local Hide_B = script.Parent.Hide_B
local Main_F = script.Parent.Main_F
local Fight_B = Main_F.Fight_B
local Player_F = Main_F.Player_F
local Icon_F = Player_F.Icon_F
local Player_Img = Icon_F.Player_Img
local Rank_F = Player_F.Rank_F
local Rank_Img = Rank_F.Rank_Img
local Rank_Txt = Rank_F.Rank_Txt
local Player_Name = Player_F.Player_Name
local Arena_Tag = Main_F.Arena_Tag

local Debounce_UI = false
local Debounce_C = false

local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	
	table.clear(Cons)
end

local function Is_Player_Fighting()
	local Char = Plr.Character or Plr.CharacterAdded:Wait()
	local Is_Fighting = Char:GetAttribute("Is_Fighting")
	if(Is_Fighting ~= nil and Is_Fighting == true)then
		return true
	end

	return false
end

local Y_Pos_Data = {
	[true] = {
		[Main_F] = 0.525,
		[Hide_B] = 0.5875
	},
	
	[false] = { -- PC and Console Showing
		[Main_F] = 0.8625,
		[Hide_B] = 0.925
	},
}

local function Get_Y_Pos(B)
	return Y_Pos_Data[UIS.TouchEnabled][B]
end

local function Remove_Fight_Spawn()
	Disconnect_Cons()

	Main_F:TweenPosition(UDim2.new(-0.2, 0, Get_Y_Pos(Main_F), 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.25, true, nil)
	Hide_B:TweenPosition(UDim2.new(-0.15, 0, Get_Y_Pos(Hide_B), 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.25, true, nil)
end

local function Show_Fight_Spawn(Invite_Data)
	local function Reset_Display()
		Disconnect_Cons()
		
		Main_F.Position = UDim2.new(-0.2, 0, Get_Y_Pos(Main_F), 0)
		Hide_B.Position = UDim2.new(-0.15, 0, Get_Y_Pos(Hide_B), 0)
		
		Hide_B.Visible = false
		Main_F.Visible = false
	end
	Reset_Display()
	
	local function Update_Player_Display()
		local Rank_Col = Invite_Data['Rank Color'] or Color3.fromRGB(170, 170, 127)
		
		Player_Img.Image = Invite_Data['Player Icon'] or "rbxassetid://80237311442114"
		Rank_Img.Image = Invite_Data['Rank Icon'] or "rbxassetid://89194867048049"
		Rank_Img.ImageColor3 = Rank_Col
		Rank_Txt.Text = Invite_Data['Rank Value'] or "0"
		Rank_Txt.TextColor3 = Rank_Col
		Player_Name.Text = Invite_Data['Name'] or "Player"
		
		Main_F.UIStroke.Color = Invite_Data['Ranked_Fight'] and Color3.fromRGB(172, 0, 0) or Color3.fromRGB(170, 255, 0)
		Arena_Tag.Visible = Invite_Data['Ranked_Fight']
	end
	Update_Player_Display()
	
	local function Button_Handle()
		SE_Mod.PlaySFX(Plr, "Click_SE")
		
		local function Move_To_Fight_Spawn()
			Transition_Hole_UI:Fire(Color3.fromRGB(50, 50, 50))
			task.wait(0.5)
			
			local Char = Plr.Character
			local Spawn_CF = Invite_Data['Spawn_Location']
			if(Char ~= nil and Spawn_CF ~= nil and Is_Player_Fighting() == false and 
				Char:FindFirstChild("HumanoidRootPart") ~= nil)then
				
				local HRP = Char:FindFirstChild("HumanoidRootPart")
				HRP.CFrame = Spawn_CF
			end
		end
		
		MenuButtons_Mod.Setup_Base_Button(
			Cons, 
			Fight_B, 
			function() 
				Remove_Fight_Spawn()
				Move_To_Fight_Spawn()
			end,  
			Fight_B:FindFirstChild("Selected"))
		
		MenuButtons_Mod.Setup_Colored_Button(
			Cons, 
			Hide_B,
			Color3.new(1, 0, 0),
			Remove_Fight_Spawn , 
			Hide_B:FindFirstChild("Selected"))
	end
	Button_Handle()

	local function Display_UI()
		Main_F:TweenPosition(UDim2.new(0.025, 0, Get_Y_Pos(Main_F), 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.375, true, nil)
		Hide_B:TweenPosition(UDim2.new(0.075, 0, Get_Y_Pos(Hide_B), 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.375, true, nil)
		
		Main_F.Visible = true
		Hide_B.Visible = true
	end
	Display_UI()
	
	local function Removal_Handle()
		--local Char_V1 = Invite_Data['Char_V1']
		--local Main_Char_V = Invite_Data['Main_Char_V'] or Char_V1
		--if(Char_V1 ~= nil)then
		--	table.insert(Cons, Char_V1.Changed:Connect(function()
		--		if((Main_Char_V == Char_V1 and Char_V1.Value == nil) or 
		--			(Main_Char_V ~= Char_V1 and Char_V1.Value ~= nil))then

		--			Remove_Fight_Spawn()
		--		end
		--	end))
		--end

		--local Char_V2 = Invite_Data['Char_V2']
		--if(Char_V2 ~= nil)then
		--	table.insert(Cons, Char_V2.Changed:Connect(function()
		--		if((Main_Char_V == Char_V2 and Char_V2.Value == nil) or 
		--			(Main_Char_V ~= Char_V2 and Char_V2.Value ~= nil))then

		--			Remove_Fight_Spawn()
		--		end
		--	end))
		--end
		
		local Main_Char_V = Invite_Data['Main_Char_V']
		if(Main_Char_V ~= nil) then
			table.insert(Cons, Main_Char_V.Changed:Connect(function()
				if(Main_Char_V.Value==nil) then
					Remove_Fight_Spawn()
				end
			end))
		end

		local Active_V = Invite_Data['Active_V']
		if(Active_V ~= nil)then
			table.insert(Cons, Active_V.Changed:Connect(function()
				if(Active_V.Value == true)then
					Remove_Fight_Spawn()
				end
			end))
		end

		--
		local Char = Plr.Character
		if(Char ~= nil)then
			table.insert(Cons, Char.AttributeChanged:Connect(function(Attrib_Name)
				if(Attrib_Name ~= nil and Attrib_Name == "Is_Fighting" and Is_Player_Fighting())then
					Remove_Fight_Spawn()
				end
			end))
		end

	end
	Removal_Handle()
end

Fight_Spawn_Notification.OnClientEvent:Connect(function(Ignore_Plr, Invitation_Data)
	if(Debounce_UI == false and Fight_Prompts_V ~= nil and Fight_Prompts_V.Value == true and 
		Is_Player_Fighting() == false and Ignore_Plr ~= nil and Ignore_Plr ~= Plr)then
		local Total_Wins = PlayerUtils.GetPlayerVal(Plr, "Total Wins")
		if not Invitation_Data['Ranked_Fight'] 
			or (Invitation_Data['Ranked_Fight'] 
				and Total_Wins and Total_Wins.Value >= Fight_Params_Mod.Ranked_Arena_Required_Wins 
				and Elo_Mod.Adjacent_Elo_Ranks(Plr, Ignore_Plr)) then
			
			Debounce_UI = true
			Show_Fight_Spawn(Invitation_Data)

			task.wait(5)

			Debounce_UI = false
		end
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{DDDACCE1-7A17-4313-998B-8079053777F6}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Fight_Teleport_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXDCA337D9EA6D484CBE540D6CF14645CA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Staminia_Down_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX94572458C0164D2F84B1750AA0149C53">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local UIS = game:GetService("UserInputService")
local TS = game:GetService("TweenService")

local Plr = game.Players.LocalPlayer
local FD = Plr:WaitForChild("Fight_Data")
local Stam_V = FD:WaitForChild("Staminia")
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Cam_Shake_Mod = require(Data_Mods_F:WaitForChild("CameraShaker"))
local Sound_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))

-- UI References
local Main_F = script.Parent.Damage_F
local Backdrop_F = Main_F.Backdrop_F
local Stam_Txt = Main_F.Stam_Txt
local Key_Txt = Main_F.Key_Txt

local Is_Being_Shown = false
local Tween_Trans = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Out = TweenInfo.new(0.375, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)

local function Special_Txt(T, C)
	local RGB_Txt = string.format("rgb(%d, %d, %d)", C.R * 255, C.G * 255, C.B * 255)
	return [[<font color="]] .. RGB_Txt .. [[">]] .. T .. [[</font>]]
end

local function Cam_Shake()
	local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
		Cam.CFrame = Cam.CFrame * shakeCf
	end)
	return CS
end
local CamShake = Cam_Shake()

local function Remove_Display()
	CamShake:StopSustained(0.375)
	
	local Tabs = Backdrop_F:GetChildren()
	for i = 1, #Tabs do
		local T = Tabs[i]
		if(T ~= nil)then
			TS:Create(T, Tween_Out, {BackgroundTransparency = 1}):Play()
		end
	end

	TS:Create(Stam_Txt, Tween_Out, {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
	TS:Create(Key_Txt, Tween_Out, {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
	Is_Being_Shown = false
end

local function Show_Display()
	
	Sound_Mod.Play_Voice_Over("Low_Health")
	
	local function Reset_Handle()		
		Stam_Txt.TextTransparency = 1
		Stam_Txt.TextStrokeTransparency = 1
		Key_Txt.TextTransparency = 1
		Key_Txt.TextStrokeTransparency = 1
		
		if(UIS.GamepadEnabled)then
			Key_Txt.Text = "Press & Hold " .. Special_Txt("L2", Color3.fromRGB(35, 244, 68)) .. " to Heal!"
		elseif(UIS.TouchEnabled)then
			Key_Txt.Text = "Press & Hold the Button to Heal!"
		else
			Key_Txt.Text = "Press & Hold " .. Special_Txt("Space", Color3.fromRGB(35, 244, 68)) .. " to Heal!"
		end
		CamShake:StopSustained(0)
	end
	Reset_Handle()
	
	local function Show_Backdrop()
		local Tabs = Backdrop_F:GetChildren()
		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil)then
				T.BackgroundTransparency = 1
				TS:Create(T, Tween_Trans, {BackgroundTransparency = 0.375}):Play()
			end
		end
		
		TS:Create(Stam_Txt, Tween_Trans, {TextTransparency = 0, TextStrokeTransparency = 0}):Play()
		TS:Create(Key_Txt, Tween_Trans, {TextTransparency = 0, TextStrokeTransparency = 0}):Play()
		
		Sound_Mod.PlaySFX(Plr, "Heartbeat_SE")
		
		CamShake:Start()
		CamShake:ShakeSustain(Cam_Shake_Mod.Presets.RoughDriving)
		Is_Being_Shown = true
	end
	Show_Backdrop()
end

Stam_V.Changed:Connect(function()
	if(Stam_V.Value < 20 and Is_Being_Shown == false)then
		--Show
		Show_Display()
	elseif(Stam_V.Value >= 20 and Is_Being_Shown)then
		--Remove
		Remove_Display()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{0ACE76DB-BD20-4614-910F-1750ABA3089A}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Staminia_Effect_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX689C5D7A2AB34C5F95883FB14183CD53">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_Result_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX5BF35EB64791426EAA4DF031B6F6AB41">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")

local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local PG = Plr:WaitForChild("PlayerGui")
local PD = Plr:WaitForChild("Player_Data")
local Elo_V = PD:WaitForChild("Elo")
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Utils = require(game.ReplicatedStorage.Modules.Utils)


-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Toggle_Reset 				= Channels.Bindable_Events.Toggle_Reset
local Toggle_Side_Buttons 		= Channels.Bindable_Events.Toggle_Side_Buttons
local Close_Fight_Result 		= Channels.Bindable_Events.Close_Fight_Result
local Is_Chatbox_Typing			= Channels.Bindable_Functions.Is_Chatbox_Typing
local Fight_Data_Result			= Channels.SC_Remote_Events.Fight_Data_Result

-- UI References
local Main_F = script.Parent.Main_F
local Top_Data_F = Main_F.Top_Data_F
local Main_Data_F = Main_F.Data_Results_F
local Elo_Progress_F = Main_F.Elo_Progress_F
local Exit_B = Main_F.Exit_B

local Debounce_UI = false
local Debounce_C = false
local Debounce_E = false

local Tween_Cam = TweenInfo.new(0.75, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local Player_Thumbnail_Data = {
	
}
local function Get_Player_Thumbnail(ID)
	if(Player_Thumbnail_Data[ID] ~= nil)then
		return Player_Thumbnail_Data[ID]
	else
		local Type = Enum.ThumbnailType.HeadShot
		local Size = Enum.ThumbnailSize.Size420x420
		
		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				Data = game.Players:GetUserThumbnailAsync(ID, Type, Size)
			end)
			
			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end
		
		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				Player_Thumbnail_Data[ID] = D
				return D
			end
		end
		
		return "rbxassetid://100127687172105"
	end
end

local function Toggle_UI(Show)
	local UI_Paths = {
		"Fight/Fight_Teleport_UI",
		--"Player/Tool_Select_UI",
		--"Fight/Side_Button_UI",
		"System/Player_List_UI"
	}

	local function getUIByPath(root, path)
		local current = root
		for segment in string.gmatch(path, "[^/]+") do
			current = current:FindFirstChild(segment)
			if not current then return nil end
		end
		return current
	end

	for _, path in ipairs(UI_Paths) do
		local ui = getUIByPath(PG, path)
		if ui then
			ui.Enabled = Show
		else
			warn("[FightResult] UI not found:", path)
		end
	end
end


local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.375, true, nil)
	
	wait(0.375)
	
	local Old_Blur = game.Lighting:FindFirstChild("Result_Blurr")
	if(Old_Blur ~= nil)then
		Old_Blur:Destroy()
	end
	
	if(Cam.FieldOfView == 40)then
		TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	end
	
	Toggle_Side_Buttons:Fire(true)
	Toggle_UI(true)
	Toggle_Reset:Fire(true)
	Main_F.Visible=false
	Debounce_C = false
	Debounce_E = false
	Debounce_UI = false
end

local function Display_UI(Fight_Data)
	local function Reset_Display()
		Disconnect_Cons()
		Cam.FieldOfView = 70
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 1.5, 0)
		
		local Old_Blur = game.Lighting:FindFirstChild("Result_Blurr")
		if(Old_Blur ~= nil)then
			Old_Blur:Destroy()
		end
		
		Toggle_UI(false)
	end
	Reset_Display()
	
	local function Update_Display_Data()
		local function Update_Top_Bar_Info()
			if string.len(Fight_Data['Winner']['DisplayName']) > 30 then
				Fight_Data['Winner']['DisplayName']  = "Bot"
			end
			if string.len(Fight_Data['Winner']['Name']) > 30 then
				Fight_Data['Winner']['Name']  = "Bot"
			end
			Top_Data_F.Winner_Data_F.Player_Name_Txt.Text = Fight_Data['Winner']['DisplayName'] 
			Top_Data_F.Winner_Data_F.Player_Display_Name_Txt.Text = Fight_Data['Winner']['Name'] 
			Top_Data_F.Winner_Data_F.Plr_Img_F.Plr_Img.Image = Get_Player_Thumbnail(Fight_Data['Winner']['ID'])
			
			if string.len(Fight_Data['Loser']['DisplayName']) > 30 then
				Fight_Data['Loser']['DisplayName']  = "Bot"
			end
			if string.len(Fight_Data['Loser']['Name']) > 30 then
				Fight_Data['Loser']['Name']  = "Bot"
			end
			Top_Data_F.Loser_Data_F.Player_Name_Txt.Text = Fight_Data['Loser']['DisplayName'] 
			Top_Data_F.Loser_Data_F.Player_Display_Name_Txt.Text = Fight_Data['Loser']['Name']
			Top_Data_F.Loser_Data_F.Plr_Img_F.Plr_Img.Image = Get_Player_Thumbnail(Fight_Data['Loser']['ID'])
			
			Top_Data_F.Score_Txt.Text = Fight_Data['Winner']['Wins'] .. " - " .. Fight_Data['Loser']['Wins']	
		end
		Update_Top_Bar_Info()
		
		local function Update_Main_Data()
			local function Update_Tab(Tab)
				local Key = string.gsub(Tab.Name, "_F", "")
				Key = string.gsub(Key, "_", " ")
				
				Tab.Winner_Data_Txt.Text = Fight_Data['Winner'][Key] .. "" or "0 / 0"
				Tab.Loser_Data_Txt.Text = Fight_Data['Loser'][Key] .. "" or "0 / 0"
			end 
			
			local Tabs = Main_Data_F:GetChildren()
			for i = 1, #Tabs do
				if(Tabs[i] ~= nil and Tabs[i]:IsA("Frame"))then
					Update_Tab(Tabs[i])
				end
			end
		end
		Update_Main_Data()
	end
	Update_Display_Data()
	
	local function Display_Elo_Data()
		Elo_Progress_F.Visible = true 

		local Current_Elo_Data = Elo_Mod.Get_Player_Rank_Data(Plr)
		local Next_Elo_Data = Elo_Mod.Get_Next_Rank_Data(Current_Elo_Data['Index'])
		local Tween_Prog_Bar = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 1)

		Elo_Progress_F.Current_Elo_F.Elo_Txt.Text = Utils.NumToString(Elo_V.Value) .. ""
		Elo_Progress_F.Current_Elo_F.Elo_Img.Image = Current_Elo_Data['Icon']
		Elo_Progress_F.Current_Elo_F.Elo_Img.ImageColor3 = Current_Elo_Data['Color']

		Elo_Progress_F.Next_Elo_F.Elo_Txt.Text = Utils.NumToString(Next_Elo_Data['Elo Range'].Min) .. ""
		Elo_Progress_F.Next_Elo_F.Elo_Img.Image = Next_Elo_Data['Icon']
		Elo_Progress_F.Next_Elo_F.Elo_Img.ImageColor3 = Next_Elo_Data['Color']

		Elo_Progress_F.Prog_Bar_F.Bar_F.UIGradient.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Next_Elo_Data['Color']),
			ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))
		}
		Elo_Progress_F.Prog_Bar_F.Bar_F.Size = UDim2.new(0, 0, 1, 0)

		local Dif = math.clamp(Elo_V.Value / Next_Elo_Data['Elo Range'].Min, 0, 1)
		TS:Create(Elo_Progress_F.Prog_Bar_F.Bar_F, Tween_Prog_Bar, {Size = UDim2.new(Dif, 0, 1, 0)}):Play()
	end

	Display_Elo_Data()
	
	local function Exit_Handle()
		local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
		Exit_B.Size = UDim2.new(0.075, 0, 0.1, 0)
		
		table.insert(Cons, Exit_B.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				SE_Mod.PlaySFX(Plr, "Hover_SE")
				Debounce_E = false
			end
		end))
		
		table.insert(Cons, Exit_B.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				SE_Mod.PlaySFX(Plr, "Click_SE")
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.05625, 0, 0.075, 0)}):Play()
				
				Remove_UI()
				
				wait(0.25)
				Debounce_C = false
			end
		end))	
		
		table.insert(Cons, UIS.InputBegan:Connect(function(input, GPE)
			if(Debounce_C == false and input.KeyCode == Enum.KeyCode.Space and 
				Is_Chatbox_Typing:Invoke() == false)then
				
				Debounce_C = true
				SE_Mod.PlaySFX(Plr, "Click_SE")
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.05625, 0, 0.075, 0)}):Play()

				Remove_UI()

				wait(0.25)
				Debounce_C = false
			end
		end))	
	end
	Exit_Handle()
	
	local function Display_Main_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.4875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
		
		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Result_Blurr"
		
		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
		SE_Mod.Play_Voice_Over("End_Of_Fight")
		
		Debounce_C = false
		Debounce_E = false
		Debounce_UI = true
	end
	Display_Main_UI()
	
	--Auto Remove after 10 Seconds
	for i = 1, 40 do
		task.wait(0.25)
		if(Debounce_UI == false)then
			return
		end
	end
	
	if(Debounce_UI == true)then
		Remove_UI()
	end
end

local function Play_Winning_Outro(Winner_Char)
	if (Winner_Char == Char) then
		local Intro_Animation_Key = Plr:FindFirstChild("Player_Data"):FindFirstChild("Fight Outro Key").Value
		Animation_Mod.Play_Emote_Track_From_Key(Plr, Hum, Intro_Animation_Key, true)
	end
	
	--/ WIP TODO: Move Camera to Winner
	wait(5)
	--local Target_HRP = Winner_Char:WaitForChild("HumanoidRootPart")
	--local RS_Con = nil
	--local Follow_P = nil
	
	--RS_Con = RunService.Stepped:Connect(function()
	--	if(Follow_P ~= nil and Cam ~= nil)then
	--		Cam.CFrame = CFrame.new(Cam.CFrame.Position, Follow_P.Position)
	--	end
	--end)
	--table.insert(Cons, RS_Con)

	--Cam.CameraType = Enum.CameraType.Scriptable

	--if(Target_HRP ~= nil)then
		
	--	local Init_Pos = Target_HRP.Position + Target_HRP.CFrame.LookVector * 5
	--	local Look_CF = CFrame.new(Init_Pos, Target_HRP.Position)
	--	local Tween_Init = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
	--	TS:Create(Cam, Tween_Init, {CFrame = CFrame.new(Init_Pos) * Look_CF.Rotation}):Play()
	--	wait(0.75)
	--	if(Target_HRP ~= nil)then
	--		Follow_P = Target_HRP
	--	end

	--	wait(5)
	--	Follow_P = nil
	--end

	--if(RS_Con ~= nil)then
	--	RS_Con:Disconnect()
	--	RS_Con = nil
	--end
	
end


Fight_Data_Result.OnClientEvent:Connect(function(Fight_Data, Winner_Char)
	
	---- if tutorial mode we skip the winning outro and fight result
	--if Plr:GetAttribute("IsTutorialRunning") == true then
	--	return
	--end
	
	Play_Winning_Outro(Winner_Char)
	
	if(Debounce_UI == false)then
		if not Plr:GetAttribute("IsTutorialRunning") then
			Display_UI(Fight_Data)
		end
	end
end)

Close_Fight_Result.Event:Connect(function()
	if(Debounce_UI)then
		Remove_UI()
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{A9516791-7972-4702-9D32-DE9CA2100288}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Fight_Result_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXF4E54B1A797C4F0F8B60EE242C658C6E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Damage_Effect_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX18975F9CDA8E4E59A3500860A7BB0FCE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local Cam = game.Workspace.CurrentCamera

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Cam_Shake_Mod = require(Data_Mods_F:WaitForChild("CameraShaker"))
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Round_Result_Win 		= Channels.SC_Remote_Events.Round_Result_Win
	
local FD = Plr:WaitForChild("Fight_Data")
local Health_V = FD:WaitForChild("Health")

-- UI References
local Main_F = script.Parent.Damage_F
local Knockout_Tab = script.Parent.Result_F

local Tween_Trans = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0.25)
local Tween_Cons = {}
local function Stop_Tweens()
	for i = 1, #Tween_Cons do
		local T = Tween_Cons[i]
		if(T ~= nil)then
			T:Cancel()
		end
	end
	
	table.clear(Tween_Cons)
end

local function Show_Effect()
	local Tabs = Main_F:GetChildren()
	if(#Tween_Cons > 0)then
		Stop_Tweens()
	end
	
	for i = 1, #Tabs do
		local T = Tabs[i]
		if(T ~= nil)then
			T.BackgroundTransparency = 0.575
			local Tab_T = TS:Create(T, Tween_Trans, {BackgroundTransparency = 1})
			table.insert(Tween_Cons, Tab_T)
			Tab_T:Play()
		end
	end
	
end

local Prev_V = Health_V.Value
Health_V.Changed:Connect(function()
	local Current_V = Health_V.Value
	if(Current_V < Prev_V)then
		Show_Effect()
	end
	
	Prev_V = Current_V
end)

local function Cam_Shake()
	local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
		Cam.CFrame = Cam.CFrame * shakeCf
	end)
	return CS
end
Cam_Shake()


local function Display_Knockout_Effects(Was_Knockout)
	while game.Workspace:GetAttribute("FIGHT_INTRO") ~= nil do
		task.wait()
	end
	
	local function Configure_Display()
		local Img = Knockout_Tab:FindFirstChild("Img")
		local Txt = Knockout_Tab:FindFirstChild("Txt")
		
		Knockout_Tab.Visible = false
		Knockout_Tab.Position = UDim2.new(0.5, 0, -0.5, 0)
		
		if(Was_Knockout)then
			Img.ImageColor3 = Color3.new(1, 0, 0)
			Txt.Text = "Knockout!"
			Txt.TextStrokeColor3 = Color3.new(1, 0, 0)
			
			Sound_Mod.Play_Voice_Over("Knockout")
		else
			Img.ImageColor3 = Color3.fromRGB(0, 170, 255)
			Txt.Text = "Submission KO!"
			Txt.TextStrokeColor3 = Color3.fromRGB(0, 170, 255)
		end
		
		Knockout_Tab.Visible = true
		Knockout_Tab:TweenPosition(UDim2.new(0.5, 0, 0.3, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.375, true, nil)
	end
	Configure_Display()
	
	local function Play_Cash_VFX()
		local Char = Plr.Character
		if(Char ~= nil and Char:FindFirstChild("HumanoidRootPart") ~= nil)then
			local HRP = Char:FindFirstChild("HumanoidRootPart")
			local Cash_VFX = HRP:FindFirstChild("Cash_VFX")
			
			if(Cash_VFX ~= nil)then
				local All_PE = Cash_VFX:GetChildren()
				for i = 1, #All_PE do
					local PE = All_PE[i]
					if(PE ~= nil and PE:IsA("ParticleEmitter"))then
						PE:Emit(10)
					end
				end
			end
		end
	end
	Play_Cash_VFX()
	
	task.wait(3)
	Knockout_Tab:TweenPosition(UDim2.new(0.5, 0, -0.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.25, true, nil)
end

Round_Result_Win.OnClientEvent:Connect(Display_Knockout_Effects)]]></ProtectedString>
							<string name="ScriptGuid">{C02FFF23-18F1-490A-8B59-163EC04AE801}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Client_Damage_Effect_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX3C73ADA9BCFF458889425A66FB181EAB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Tutorial</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXD11A43367B0B4D5DA3BD23B1065AA226">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tour_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX942D50D16E1348D1BA824A38ABFBBCEB">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[
--======================================================================
--  File: StarterGui/Tutorial_UI/Tutorial_UI_Handle.client.lua
--
--  Description:
--      Controls the tutorial user interface (UI). Displays tutorial
--      messages with title and text, handles "OK" button interactions
--      to progress through steps, and toggles the tutorial/commands
--      panels based on events received.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-09-30 by Oriane
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/End_Tutorial
--          * Channels_F/Bindable_F/Events/Display_Tuto_Message
--          * Channels_F/Bindable_F/Events/Next_Tutorial_Step
--          * Channels_F/Bindable_F/Events/Toggle_Tutorial_OK_Button
--          * Channels_F/Bindable_F/Events/Toggle_Commands_Panel
--      - StarterGui:
--          * Tuto_Frame
--          * Tuto_Message
--          * Commands_Frame
--          * Tuto_OK (Button inside Tuto_Message)
--      - Roblox Services:
--          * None beyond defaults (UI handling)
--
--  Notes:
--      - Displays dynamic tutorial messages sent from Tutorial_Handle
--      - "OK" button progresses to next step via Next_Tutorial_Step
--      - Commands panel visibility toggles tutorial message display
--      - Cleanly hides UI when tutorial ends
--
--======================================================================

-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer

-- Modules
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes

local Close_Tutorial 			= Channels.Bindable_Events.Close_Tutorial
local Display_Tuto_Message 		= Channels.Bindable_Events.Display_Tuto_Message
local Display_Tuto_Indicator	= Channels.Bindable_Events.Display_Tuto_Indicator
local Next_Tutorial_Step 		= Channels.Bindable_Events.Next_Tutorial_Step
local Toggle_Tutorial_OK_Button = Channels.Bindable_Events.Toggle_Tutorial_OK_Button
local Toggle_Commands_Panel 	= Channels.Bindable_Events.Toggle_Commands_Panel

-- UI References
local Message = script.Parent.Tuto_Message
local OK_Button = Message:FindFirstChild("Tuto_OK",true)
local Hand_Indicator = script.Parent.Main_F.Hand_Indicator
local Commands_Panel = script.Parent.Commands_Frame

local HandIndicatorTween = nil

local function Stop_Hand_Indicator_Tween()
	Hand_Indicator.Visible = false
	if HandIndicatorTween then
		HandIndicatorTween:Cancel()
		HandIndicatorTween = nil
	end	
end

local function Start_Hand_Indicator_Tween(min_Pos,Max_Pos)

	local minPos  = min_Pos-- UDim2.new(1.048, 0, yScale, yOffset)
	local maxPos = Max_Pos-- UDim2.new(1.082, 0, yScale, yOffset)

	-- start from left
	Hand_Indicator.Position = minPos

	local tweenInfo = TweenInfo.new(
		0.4,                         -- time
		Enum.EasingStyle.Sine,
		Enum.EasingDirection.InOut,
		-1,                          -- repeat forever
		true,                        -- reverse: goes left <-> right
		0
	)

	HandIndicatorTween = TS:Create(Hand_Indicator, tweenInfo, { Position = maxPos })
	HandIndicatorTween:Play()
end

Close_Tutorial.Event:Connect(function()
	Message.Visible = false
end)

Display_Tuto_Message.Event:Connect(function(title, message)
	Message:FindFirstChild("Tuto_Title",true).Text = title
	Message:FindFirstChild("Tuto_Message",true).Text = message
	Message.Visible = true
end)

Display_Tuto_Indicator.Event:Connect(function(Should_Show, Data)
	if(Data ~= nil) then
		Hand_Indicator.Rotation = Data.Rotation
		Hand_Indicator.Size = Data.Size
		Start_Hand_Indicator_Tween(Data.InitialPos,Data.FinalPos)
	else
		Stop_Hand_Indicator_Tween()
	end
	
	Hand_Indicator.Visible = Should_Show
end)

OK_Button.MouseButton1Click:Connect(function()
	Message.Visible = false
	Next_Tutorial_Step:Fire()
end)

local Next_KeyCode = Enum.KeyCode.Return
UIS.InputEnded:Connect(function(input)
	if(Plr:GetAttribute("IsTutorialRunning")) then
		if (OK_Button.Visible and Message.Visible) then 
			if input.KeyCode == Next_KeyCode then
				Message.Visible = false
				Next_Tutorial_Step:Fire()
			end
		end
	end
end)

Toggle_Tutorial_OK_Button.Event:Connect(function(Should_Show)	
	OK_Button.Visible = Should_Show
	if Should_Show then
		Hand_Indicator.Visible = false
	end
end)

Toggle_Commands_Panel.Event:Connect(function(Should_Show)
	if Should_Show == nil then
		Should_Show = not Commands_Panel.Visible
	end
	
	Commands_Panel.Visible = Should_Show
	Message.Visible = not Should_Show
end)

]]></ProtectedString>
							<string name="ScriptGuid">{50A0DF5A-B7D1-46D6-ACE1-53035B6B90B1}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Tour_UI_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX19A841CDE57B40C8A7E5914A4491B54C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Cage_Tutorial_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX2FE3DAB82E15408F997310030B3FF02F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Client/Tutorial/Mini_Tutorial_Controller.client.lua
--
--  Description:
--      Full client-side controller for the Mini Tutorial system.
--      Handles UI prompts, guided steps, typewriter effects, hand
--      indicators, highlight strokes, image-based tutorial messages,
--      navigation buttons, and cleanup/reset logic.
--
--      Features:
--          • Typewriter text animation for tutorial messages
--          • Dynamic hand indicator with tweened movement
--          • UI highlight strokes (UIStroke & ImageStroke effects)
--          • Step progression (Next / OK buttons)
--          • Support for two display modes:
--                - Classic message box (title + text)
--                - Image-based “NewMessageBox” with tip area
--          • Position presets (TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT)
--          • Full cleanup: stroke blinking, indicators, tweens
--          • Mini-tutorial prompt (“Want to take a short tutorial?”)
--          • Integration with server tutorial state
--
--  Last Modified: 2025-11-29 by Darkzeb
--  Version: V2025-11
--
--  Dependencies:
--      Services:
--          - TweenService
--          - UserInputService (indirect via buttons)
--
--      ReplicatedStorage Modules:
--          - Channels (BindableEvents + RemoteEvents)
--
--      UI:
--          - Tuto_Frame, Tuto_Message, MessageBox, Tuto_Prompt
--          - Hand_Indicator template (Temps.Hand_Indicator)
--          - Stroke templates (Temps/*)
--
--  Notes:
--      • This script does all animation logic locally for smooth UX.
--      • Hand indicator & strokes auto-reset when switching steps.
--      • New tutorial steps must fire BindableEvents defined in Channels.
--======================================================================
-- Services
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer

-- Modules
local Channels 						= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Close_Tutorial 				= Channels.Bindable_Events.Close_Tutorial

local Display_InCage_Message	 	= Channels.Bindable_Events.Display_InCage_Message
local Next_Tutorial_Step 			= Channels.Bindable_Events.Next_Tutorial_Step

local Display_InCage_UIStroke  		= Channels.Bindable_Events.Display_InCage_UIStroke
local Display_InCage_ImageStroke  	= Channels.Bindable_Events.Display_InCage_ImageStroke
local Display_InCage_Indicator     	= Channels.Bindable_Events.Display_InCage_Indicator

-- UI References
local Message_F = script.Parent.MessageBox
local Next_Button_F = Message_F.ButtonBox
local Next_B = Next_Button_F.Next_B
local Keybind_F = Next_Button_F.Keybind
local Title = Message_F.Box.Text_F.Tuto_Title
local Text = Message_F.Box.Text_F.Tuto_Message
local TipBox = Message_F.Box_Tip
local Tips = TipBox.Tuto_Message
local Image = Message_F.Box.ImageLabel

local ButtonBox_current_Pos = Next_Button_F.Position
local NextButton_initial_Size = Next_B.Size

local oldStroke={}
local oldImageStroke={}
local UIStroke_Image_Blink_Con=nil
local UIStroke_Blink_Con=nil

local Next_Button_OnTween=nil
local TypeWriter_Con=nil
local Stop_Hand_Indicator_Tween=nil

local Next_KeyCode = nil
local Current_Device= nil

local function ApplyDeviceInputNextKey()

	local Next_KeyHint = ""
	if UIS.TouchEnabled then
		Current_Device = "Mobile"
	else 
		if UIS.KeyboardEnabled and not UIS.GamepadEnabled then
			Current_Device = "PC"
			Next_KeyCode =  Enum.KeyCode.Return
			Next_KeyHint = Next_KeyCode.Name
		elseif UIS.GamepadEnabled then
			Current_Device = "Console"
			Next_KeyCode = Enum.KeyCode.ButtonX
			local Mapped_Key = UIS:GetStringForKeyCode(Enum.KeyCode.ButtonX)
			Next_KeyHint = Mapped_Key~= nil and Mapped_Key or Next_KeyCode.Name 
		else
			Current_Device = "Mobile"
		end
	end

	if Next_KeyHint ~= "" then
		Keybind_F.Holder.Txt.Text = "["..Next_KeyHint.."]"
		Keybind_F.Visible=true
	end
end
ApplyDeviceInputNextKey()

local Tip_Prefix = "<b><font color='rgb(0, 215, 0)'>TIP:</font></b> "

local function Typewrite(label, fullText, showNextButton, duration)
	if Next_Button_OnTween then
		task.cancel(Next_Button_OnTween)
		Next_Button_OnTween=nil
	end
	label.Text = fullText
	label.MaxVisibleGraphemes = 0
	Next_Button_F.Visible=false
	local count = utf8.len(fullText) or #fullText
	if count == 0 then
		label.MaxVisibleGraphemes = -1
		return
	end

	local step = duration / count
	for i = 1, count do
		label.MaxVisibleGraphemes = i
		task.wait(step)
	end
	label.MaxVisibleGraphemes = -1 -- show all
	
	if showNextButton then
		Next_Button_F.Visible=true
		local currentPos = ButtonBox_current_Pos
		local Tween_Show = TweenInfo.new(.5, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
		task.wait(1)
		Next_Button_OnTween=task.spawn(function()
			while true do
				--TS:Create(Next_Button_F,Tween_Show,{ Position = UDim2.new(currentPos.X.Scale+.02,0,currentPos.Y.Scale,0)}):Play()
				TS:Create(Next_B,Tween_Show,{ Size = UDim2.new(NextButton_initial_Size.X.Scale+0.1,0,NextButton_initial_Size.Y.Scale+0.1,0)}):Play()
				task.wait(.5)
				--TS:Create(Next_Button_F,Tween_Show,{ Position = UDim2.new(currentPos.X.Scale,0,currentPos.Y.Scale,0)}):Play()
				TS:Create(Next_B,Tween_Show,{ Size = UDim2.new(NextButton_initial_Size.X.Scale,0,NextButton_initial_Size.Y.Scale,0)}):Play()
				task.wait(.5)	
			end
		end)
	end
	
	if Tips.Text~="" then
		TipBox.Visible=true
	end
	
	if Next_B.Visible and Next_Button_F.Visible then
		Keybind_F.Visible= Current_Device~="Mobile"
		
		--Mini_Tutorial_Hand_Toggle:Fire(Message_F)
		--Stop_Hand_Indicator_Tween()
	end
end

Stop_Hand_Indicator_Tween= function ()
	if HandIndicatorTween then
		HandIndicatorTween:Cancel()
		HandIndicatorTween = nil
	end

	if Hand_Indicator_OnTween then
		Hand_Indicator_OnTween:Destroy()
	end
end

local function Start_Hand_Indicator_Tween(hand,min_Pos,Max_Pos)

	Stop_Hand_Indicator_Tween()

	local leftPos  =min_Pos-- UDim2.new(1.048, 0, yScale, yOffset)
	local rightPos =Max_Pos-- UDim2.new(1.082, 0, yScale, yOffset)

	-- start from left
	hand.Position = leftPos

	local tweenInfo = TweenInfo.new(
		0.4,                         -- time
		Enum.EasingStyle.Sine,
		Enum.EasingDirection.InOut,
		-1,                          -- repeat forever
		true,                        -- reverse: goes left <-> right
		0
	)

	HandIndicatorTween = TS:Create(hand, tweenInfo, { Position = rightPos })
	HandIndicatorTween:Play()
	Hand_Indicator_OnTween=hand
end

Display_InCage_Indicator.Event:Connect(function(Parent, Hand_Indicator_Data)
	
	if Parent ~= nil and Hand_Indicator_Data~= nil then
		local Hand_Indicator = script.Parent:FindFirstChild("Highlight_Templates"):FindFirstChild("Hand_Indicator"):Clone()
		Hand_Indicator.Rotation = Hand_Indicator_Data.Rotation
		Hand_Indicator.Size = Hand_Indicator_Data.Size
		Hand_Indicator.Position = Hand_Indicator_Data.InitialPos
		Hand_Indicator.Parent = Parent
		Hand_Indicator.Visible = true
		task.wait(.1)
		--print(Hand_Indicator)
		Start_Hand_Indicator_Tween(Hand_Indicator,Hand_Indicator_Data.InitialPos,Hand_Indicator_Data.FinalPos)
	else 
		Stop_Hand_Indicator_Tween()
	end
end)

local function PlayEffectOnImage(Stroke)

	local Tween_Show = TweenInfo.new(1, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)

	local currentSize = Stroke.Size
	local XOffset=0.2
	local YOffset=0.2

	while(true) do

		TS:Create(Stroke,Tween_Show,{ Size = UDim2.new(currentSize.X.Scale+XOffset,0,currentSize.Y.Scale+YOffset,0)
			,ImageTransparency=0
		}):Play()

		task.wait(1)
		TS:Create(Stroke,Tween_Show,{ Size = UDim2.new(currentSize.X.Scale+(XOffset+XOffset/4),0,currentSize.Y.Scale+(YOffset+YOffset/4),0),
			ImageTransparency=1
		}):Play()
		task.wait(.25)

		Stroke.Size = currentSize
	end

end


Close_Tutorial.Event:Connect(function()
	Message_F.Visible=false
	TipBox.Visible=false
end)

Display_InCage_Message.Event:Connect(function(messageData)
	
	ApplyDeviceInputNextKey()
	
	local _Title = messageData.title
	local _Message = messageData.txt
	local _TipText = messageData.tips
	local _Next_button = messageData.next_button

	Text.Text = ""
	Tips.Text= ""
	
	Image=Image~=nil and Image or ""
	Title.Visible = _Title ~= nil
	if _Title then
		Title.Text = _Title
	end
	
	if TypeWriter_Con then
		task.cancel(TypeWriter_Con)
		TypeWriter_Con=nil
	end
	if _TipText then
		Tips.Text =Tip_Prefix.._TipText
	end
	TipBox.Visible=false
	Next_Button_F.Visible = _Next_button
	Message_F.Visible=true

	TypeWriter_Con = task.spawn(function()
		Typewrite(Text, _Message, _Next_button, 0.75)
	end)
end)

local function Next_Handle()
	Message_F.Visible=false
	Keybind_F.Visible= false
	Next_Tutorial_Step:Fire()
end

Next_B.MouseButton1Click:Connect(function()
	Next_Handle()
end)

UIS.InputEnded:Connect(function(input)
	if(Plr:GetAttribute("IsTutorialRunning")) then
		if (Next_Button_F.Visible and Message_F.Visible) then 
			if input.KeyCode == Next_KeyCode then
				Next_Handle()
			end
		end
	end
end)

local function DestroyBlink()
	for _,UIS in ipairs(oldImageStroke) do
		UIS:Destroy()
	end
	oldImageStroke={}
	for _,UIS in ipairs(oldStroke) do
		UIS:Destroy()
	end
	oldStroke={}
	if UIStroke_Blink_Con then

		UIStroke_Blink_Con:Disconnect()
		UIStroke_Blink_Con=nil
	end
	if UIStroke_Image_Blink_Con then

		UIStroke_Image_Blink_Con:Disconnect()
		UIStroke_Image_Blink_Con=nil
	end
	Stop_Hand_Indicator_Tween()
end

local function BlinkEffect(StrokeTable)
	while #StrokeTable>0 do
		for _,item in ipairs(StrokeTable) do
			if item:IsA("UIStroke") then
				item.Enabled=not item.Enabled
			elseif item:IsA("ImageLabel") then
				item.Visible=not item.Visible
			end
		end
		task.wait(.5)
	end
end

local function Add_Image_Stroke(Parent,Stroke_Image,Y_Offset, color)

	if not color then
		color=Color3.new(0, 1, 0)
	end

	local stroke = script.Parent:FindFirstChild("Highlight_Templates"):FindFirstChild(Stroke_Image):Clone()
	stroke.ImageColor3=color
	stroke.Parent=Parent
	stroke.Visible=true
	stroke.Position=UDim2.new(0.5,0, not Y_Offset and .5 or Y_Offset,0)
	table.insert(oldImageStroke,stroke)

	if #oldImageStroke>0 and UIStroke_Image_Blink_Con==nil then

		UIStroke_Image_Blink_Con=task.spawn(PlayEffectOnImage(stroke))
		--UIStroke_Image_Blink_Con=task.spawn(BlinkEffect(oldImageStroke))
	end
end



local function Add_Blinking_Stroke(Frames_List, Thickness, Color)
	
	if not Thickness then
		Thickness=2
	end
	if not Color then
		Color=Color3.new(0, 1, 0)
	end
	for _,parent in ipairs(Frames_List) do
		local stroke = Instance.new("UIStroke",parent)
		stroke.Color=Color
		stroke.Thickness=Thickness 
		table.insert(oldStroke,stroke)
	end
	if #oldStroke>0 and UIStroke_Blink_Con ==nil then
		UIStroke_Blink_Con =task.spawn(BlinkEffect(oldStroke))
	end
end

Display_InCage_ImageStroke.Event:Connect(function(Parent, Image, Y_Offset)
	DestroyBlink()
	if Parent ~= nil then
		Add_Image_Stroke(Parent,Image, Y_Offset)
	end
end)

Display_InCage_UIStroke.Event:Connect(function(Targets)
	DestroyBlink()
	if Targets~=nil then
		Add_Blinking_Stroke(Targets)
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{44D00335-4B8D-4FF8-B718-33EC9F97E301}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Cage_Tutorial_UI_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX39325AD0E8A34DB09888C89BB7DF4FEC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tutorial_Launcher</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXB5A7F8ADBFB44C7DB5EAA0C4CB5C43AD">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Services
local RS = game:GetService("ReplicatedStorage")
local CS = game:GetService("CollectionService")
local UIS = game:GetService("UserInputService")
local Players		= game:GetService("Players")
local player 		= Players.LocalPlayer
local character 	= player.Character 

-- Modules
local MenuButtons_Mod 	= require(RS:WaitForChild("Design"):WaitForChild("MenuButtons"))
local Channels 		= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes

local Show_Tutorial_Launcher 			= Channels.Bindable_Events.Show_Tutorial_Launcher

local Toggle_Side_Buttons 			= Channels.Bindable_Events.Toggle_Side_Buttons
local Toggle_TopBar 				= Channels.Bindable_Events.Toggle_TopBar
local Toggle_Tools_Buttons 			= Channels.Bindable_Events.Toggle_Tools_Buttons
local Close_Tutorial 				= Channels.Bindable_Events.Close_Tutorial

local Start_Tour 					= Channels.Bindable_Events.Start_Tour
local Start_Cage_Tutorial			= Channels.Bindable_Events.Start_Cage_Tutorial
local Blinking_ImageStroke  		= Channels.Bindable_Events.Display_InCage_ImageStroke
local Display_InCage_Indicator  	= Channels.Bindable_Events.Display_InCage_Indicator


local Prompt_F = script.Parent.Tuto_Prompt
local Frame_F = script.Parent.Tuto_Frame
local Hint_F = script.Parent.Tuto_Hint

local No_Btn = Prompt_F:FindFirstChild("No_B",true)
local Tour_Btn = Prompt_F:FindFirstChild("Tour_B",true)
local Yes_Btn = Prompt_F:FindFirstChild("Yes_B",true)
local Exit_B = Frame_F:FindFirstChild("Exit_B",true)
local Exit_Keybind_Hint = Exit_B:FindFirstChild("Keybind")
local Hint_OK_B = Hint_F:FindFirstChild("OK_B",true)

local Exit_Keycode = nil
local Cons={}

local function DisconnectAll()
	for _,v in Cons do
		v:Disconnect()
	end
	Cons = {}
end
-- Buttons Setup 

MenuButtons_Mod.Setup_Base_Button(Cons, Yes_Btn, function() 
	Prompt_F.Visible=false
	player:SetAttribute("IsTutorialRunning", true)
	Start_Cage_Tutorial:Fire()
end)

MenuButtons_Mod.Setup_Base_Button(Cons, Tour_Btn, function() 
	Prompt_F.Visible=false
	player:SetAttribute("IsTutorialRunning", true)
	Start_Tour:Fire()
end)

MenuButtons_Mod.Setup_Colored_Button(Cons, No_Btn, Color3.new(0.392157, 0, 0.00784314), function() 
	Close_Tutorial:Fire()
end)

MenuButtons_Mod.Setup_Exit_X_Button(Cons, Exit_B, function()
	Close_Tutorial:Fire()
end)

MenuButtons_Mod.Setup_Base_Button(Cons, Hint_OK_B, function()
	Hint_F.Visible = false
	Blinking_ImageStroke:Fire(nil,nil)
	player:SetAttribute("IsTutorialRunning", false)
	Toggle_TopBar:Fire(true)
	Toggle_Side_Buttons:Fire(true)
	Toggle_Tools_Buttons:Fire(true)
end)

-- Prompt And Frae Visibility
local function Display_Tutorial_Launcher(Should_Show)
	Prompt_F.Visible=Should_Show
	Frame_F.Visible=Should_Show
	Hint_F.Visible=not Should_Show
	Toggle_TopBar:Fire(not Should_Show)
	Toggle_Side_Buttons:Fire(not Should_Show)
	Toggle_Tools_Buttons:Fire(not Should_Show)
	
	if not Should_Show then
		local Tuto_Widget = CS:GetTagged("TutorialButton")[1]
		wait(0.1)
		Blinking_ImageStroke:Fire(Tuto_Widget,"Round_Stroke")
		Display_InCage_Indicator:Fire(Tuto_Widget, {
			InitialPos =UDim2.new(0.5, 0, 0.9, 0) ,
			FinalPos = 	UDim2.new(0.5, 0, 1.2, 0) ,
			Size = 		UDim2.new(0.9, 0, 0.9, 0) ,
			Rotation = 0,
		})
	end
end

Show_Tutorial_Launcher.Event:Connect(function()
	Display_Tutorial_Launcher(true)
end)

Close_Tutorial.Event:Connect(function()
	Display_Tutorial_Launcher(false)
end)


-- Frame Visibility
Start_Tour.Event:Connect(function()
	Frame_F.Visible = true
end)

Start_Cage_Tutorial.Event:Connect(function()
	Frame_F.Visible = true
end)

workspace.AttributeChanged:Connect(function(attr)
	if player:GetAttribute("IsTutorialRunning") and attr == "FIGHT_INTRO" then
		Frame_F.Visible=not workspace:GetAttribute("FIGHT_INTRO")
	end
end)

-- Other than mobile keybinds
local function Apply_Exit_KeyBind(Should_Show)
	local device = nil
	local Exit_KeyHint = ""
	if UIS.TouchEnabled then
		device = "Mobile"
	else 
		if UIS.KeyboardEnabled and not UIS.GamepadEnabled then
			device = "PC"
			Exit_Keycode =  Enum.KeyCode.X
			Exit_KeyHint = Exit_Keycode.Name
		elseif UIS.GamepadEnabled then
			device = "Console"
			Exit_Keycode = Enum.KeyCode.ButtonSelect
			Exit_KeyHint = Exit_Keycode.Name 
		else
			device = "Mobile"
		end
	end

	if Exit_KeyHint ~= "" then
		Exit_Keybind_Hint.Holder.Txt.Text = "["..Exit_KeyHint.."]"
		Exit_Keybind_Hint.Visible=Should_Show
	end
end

character.AttributeChanged:Connect(function(attr)
	if attr == "Is_Fighting" then
		Apply_Exit_KeyBind(character:GetAttribute(attr))
	end
end)

UIS.InputEnded:Connect(function(input)
	if(player:GetAttribute("IsTutorialRunning")) then
		if (Exit_Keybind_Hint.Visible) then 
			if input.KeyCode == Exit_Keycode then
				Close_Tutorial:Fire()
			end
		end
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{1C189087-F93E-4C4C-A7B4-8CD1B250DD72}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Tutorial_Launcher_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX1C5365B12A9F49AF8ABC25792F737CA3">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ReplicatedStorage</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX71272AF8A06648A48BB8A18572B73F37">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Data_Mods_F</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXACD6F4FB063C46E0A24CA8810EBD8361">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Monetization_Mod.lua
--
--  Description:
--      Defines monetization data for Gamepasses and Developer Products.
--      Provides mappings for product IDs, names, icons, types, and
--      optional amounts. Exposed functions allow retrieval of product
--      metadata and integration with MarketplaceService.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * MarketplaceService
--
--  Notes:
--      - GP_Data: Gamepasses with Name, ID, Icon, Price
--          * Examples: VIP, x2 ELO, x2 Cash, Exclusive Emotes, x3 Luck
--      - Dev_Data: Developer Products
--          * Cash Packs (Tiny → Mega Huge)
--          * Gems Packs (Tiny → Mega Huge)
--          * Starter Pack
--      - Used by Monetization_Handle, Codes_Handle, Shop_Handle
--      - Designed to centralize monetization configuration
--
--======================================================================

local MPS = game:GetService("MarketplaceService")

local Monetization_Mod = {}

local GP_Data = {
	['A'] = {
		['Name'] = "VIP!",
		['ID'] = 1258867472,
		['Icon'] = "rbxassetid://116997996978018",
		['Price'] = 49,
	},

	['B'] = {
		['Name'] = "x2 ELO!",
		['ID'] = 1259176869,
		['Icon'] = "rbxassetid://140028327825184",
		['Price'] = 349,
	},

	['C'] = {
		['Name'] = "x2 Cash!",
		['ID'] = 1258959116,
		['Icon'] = "rbxassetid://111390267501817",
		['Price'] = 199,
	},

	['D'] = {
		['Name'] = "Exclusive Emotes!",
		['ID'] = 1259220957,
		['Icon'] = "rbxassetid://140138999956473",
		['Price'] = 249,
	},

	['E'] = {
		['Name'] = "x3 Luck!",
		['ID'] = 1259133027,
		['Icon'] = "rbxassetid://111648715389151",
		['Price'] = 149,
	},

	['F'] = {
		['Name'] = "x2 Luck!",
		['ID'] = 1259086900,
		['Icon'] = "rbxassetid://113302080319391",
		['Price'] = 99,
	},

}

local Dev_Data = {
	['A'] = {
		['Name'] = "Tiny Cash Pack!",
		['ID'] = 3306903850,
		['Type'] = "Cash", 
		['Amount'] = 480,
		['Price'] = 29
	},

	['B'] = {
		['Name'] = "Small Cash Pack!",
		['ID'] = 3306904087,
		['Type'] = "Cash", 
		['Amount'] = 1680,
		['Price'] = 79
	},

	['C'] = {
		['Name'] = "Large Cash Pack!",
		['ID'] = 3306907044,
		['Type'] = "Cash",
		['Amount'] = 4800,
		['Price'] = 199
	},

	['D'] = {
		['Name'] = "Huge Cash Pack!",
		['ID'] = 3306907389,
		['Type'] = "Cash",
		['Amount'] = 21600, 
		['Price'] = 799
	},

	['E'] = {
		['Name'] = "Mega Huge Cash Pack!",
		['ID'] = 3306908329,
		['Type'] = "Cash",
		['Amount'] = 43200,
		['Price'] = 1499
	},

	['F'] = {
		['Name'] = "Tiny Gems Pack!",
		['ID'] = 3306909205,
		['Type'] = "Gems",
		['Amount'] = 20,
		['Price'] = 29
	},

	['G'] = {
		['Name'] = "Small Gems Pack!",
		['ID'] = 3306909447,
		['Type'] = "Gems",
		['Amount'] = 70,
		['Price'] = 79
	},

	['H'] = {
		['Name'] = "Large Gems Pack!",
		['ID'] = 3306909752,
		['Type'] = "Gems",
		['Amount'] = 200,
		['Price'] = 199
	},

	['I'] = {
		['Name'] = "Huge Gems Pack!",
		['ID'] = 3306910019,
		['Type'] = "Gems",
		['Amount'] = 900,
		['Price'] = 799
	},

	['J'] = {
		['Name'] = "Mega Huge Gems Pack!",
		['ID'] = 3306910278,
		['Type'] = "Gems",
		['Amount'] = 1800,
		['Price'] = 1499
	},

	['K'] = {
		['Name'] = "Starter Pack!",
		['ID'] = 3324331165,
		['Type'] = "StarterPack",
	},
	
	['L'] = {
		['Name'] = "Special Gloves",
		['ID'] = 3393273546,
		['Type'] = "Special Gloves",
	},
}

local UGC_Data = {
	["C1"] = { Name = "Nerd Glasses - Green", ID = 77949725271695, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=77949725271695&w=150&h=150" },
	["B1"] = { Name = "Nerd Glasses - Red", ID = 74735903599213, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=74735903599213&w=150&h=150" },
	["A1"] = { Name = "Nerd Glasses", ID = 114623808048803, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=114623808048803&w=150&h=150" },
	["T1"] = { Name = "Big Metal Chain", ID = 114922634621014, Price = 50, Thumbnail = "rbxthumb://type=Asset&Id=114922634621014&w=150&h=150" },
	["G1"] = { Name = "Training Helmet", ID = 81877496476783, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=81877496476783&w=150&h=150" },
	["F1"] = { Name = "Training Helmet", ID = 99713943487010, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=99713943487010&w=150&h=150" },
	["E1"] = { Name = "Training Helmet", ID = 100104438861007, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=100104438861007&w=150&h=150" },
	["D1"] = { Name = "Nerd Glasses - Black", ID = 85169596622861, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=85169596622861&w=150&h=150" },
	["O1"] = { Name = "Snake Glasses Y2K - Orange", ID = 79643861023078, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=79643861023078&w=150&h=150" },
	["N1"] = { Name = "Snake Glasses Y2K - Gray", ID = 81653947431590, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=81653947431590&w=150&h=150" },
	["H1"] = { Name = "Training Helmet", ID = 107974793938990, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=107974793938990&w=150&h=150" },
	["L1"] = { Name = "Snake Glasses Y2K - Red", ID = 138002585775905, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=138002585775905&w=150&h=150" },
	["K1"] = { Name = "Snake Glasses Y2K - Yellow", ID = 85537731341001, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=85537731341001&w=150&h=150" },
	["J1"] = { Name = "Snake Glasses Y2K - Pink", ID = 130898687489564, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=130898687489564&w=150&h=150" },
	["A"] = { Name = "Colorful Dreads Breads", ID = 83795788626582, Price = 60, Thumbnail = "rbxthumb://type=Asset&Id=83795788626582&w=150&h=150" },
	["I1"] = { Name = "Snake Glasses Y2K - Purple", ID = 130235233159644, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=130235233159644&w=150&h=150" },
	["C"] = { Name = "Colorful Dreads Breads", ID = 98302594802885, Price = 60, Thumbnail = "rbxthumb://type=Asset&Id=98302594802885&w=150&h=150" },
	["B"] = { Name = "Dreads Breads", ID = 113738030334375, Price = 60, Thumbnail = "rbxthumb://type=Asset&Id=113738030334375&w=150&h=150" },
	["E"] = { Name = "Cowboy Hat", ID = 101474119058173, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=101474119058173&w=150&h=150" },
	["D"] = { Name = "Dreads Breads", ID = 101251472607139, Price = 60, Thumbnail = "rbxthumb://type=Asset&Id=101251472607139&w=150&h=150" },
	["G"] = { Name = "Cowboy Hat", ID = 75114177921975, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=75114177921975&w=150&h=150" },
	["F"] = { Name = "Cowboy Hat", ID = 75995119815868, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=75995119815868&w=150&h=150" },
	["I"] = { Name = "Fighter Crown - Black Green", ID = 113747837981544, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=113747837981544&w=150&h=150" },
	["H"] = { Name = "Cowboy Hat", ID = 101562313582313, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=101562313582313&w=150&h=150" },
	["K"] = { Name = "Fighter Crown - Red White", ID = 114656167427986, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=114656167427986&w=150&h=150" },
	["J"] = { Name = "Fighter Crown - White Green", ID = 76373498147951, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=76373498147951&w=150&h=150" },
	["M"] = { Name = "Motorcycle Helmet - White Red", ID = 100504804713142, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=100504804713142&w=150&h=150" },
	["L"] = { Name = "Fighter Crown - Black White", ID = 82139183698439, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=82139183698439&w=150&h=150" },
	["O"] = { Name = "Motorcycle Helmet - Black", ID = 96818536482215, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=96818536482215&w=150&h=150" },
	["N"] = { Name = "Motorcycle Helmet - Black Red", ID = 97647774814364, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=97647774814364&w=150&h=150" },
	["Q"] = { Name = "Protein Shaker - White", ID = 122071796353410, Price = 50, Thumbnail = "rbxthumb://type=Asset&Id=122071796353410&w=150&h=150" },
	["P"] = { Name = "Motorcycle Helmet", ID = 82603511834308, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=82603511834308&w=150&h=150" },
	["S"] = { Name = "Protein Shaker - Black", ID = 87085165668528, Price = 50, Thumbnail = "rbxthumb://type=Asset&Id=87085165668528&w=150&h=150" },
	["R"] = { Name = "Protein Shaker - Red", ID = 98181442625165, Price = 50, Thumbnail = "rbxthumb://type=Asset&Id=98181442625165&w=150&h=150" },
	["U"] = { Name = "Face Bandages", ID = 120067224049421, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=120067224049421&w=150&h=150" },
	["T"] = { Name = "Protein Shaker - Yellow", ID = 102642333841802, Price = 50, Thumbnail = "rbxthumb://type=Asset&Id=102642333841802&w=150&h=150" },
	["W"] = { Name = "Face Bandages", ID = 112600507634369, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=112600507634369&w=150&h=150" },
	["V"] = { Name = "Face Bandages", ID = 119243634001553, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=119243634001553&w=150&h=150" },
	["Y"] = { Name = "Eye Bandage", ID = 84887382195802, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=84887382195802&w=150&h=150" },
	["X"] = { Name = "Face Bandages", ID = 91774845227721, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=91774845227721&w=150&h=150" },
	["M1"] = { Name = "Snake Glasses Y2K - Black", ID = 70454931418771, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=70454931418771&w=150&h=150" },
	["Z"] = { Name = "Eye Bandage", ID = 138705825312307, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=138705825312307&w=150&h=150" },
	["S1"] = { Name = "Black Gold VVS Chain Diamonds", ID = 138617591743408, Price = 50, Thumbnail = "rbxthumb://type=Asset&Id=138617591743408&w=150&h=150" },
	["R1"] = { Name = "Snake Glasses Y2K - Green", ID = 95997013721520, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=95997013721520&w=150&h=150" },
	["Q1"] = { Name = "Snake Glasses Y2K - Blue", ID = 108225068022205, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=108225068022205&w=150&h=150" },
	["P1"] = { Name = "Snake Glasses Y2K - Light Blue", ID = 91544116053373, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=91544116053373&w=150&h=150" },
}


-- Conversion parameters for cash → gems
local Conversion_Settings = {
	RATE = 1 / 20,    -- 1 gem = 20 cash
	FEE = 0.15,       -- 15% commission
}

function Monetization_Mod.Get_Conversion_Settings()
	return Conversion_Settings
end

local function Get_Player_Data(Plr, Key)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		return PD:FindFirstChild(Key).Value
	end
	return nil
end

local function Get_Data(Is_GP)
	if(Is_GP)then
		return GP_Data
	end
	return Dev_Data
end

local function Get_ID_From_Name(Is_GP, Name)
	local Data = Get_Data(Is_GP)

	for Key, Item_Data in next, Data do
		if(Item_Data ~= nil and Item_Data['Name'] ~= nil and Item_Data['Name'] == Name 
			and Item_Data['ID'] ~= nil)then

			return Item_Data['ID']
		end
	end

	return nil
end

local function Get_Key_From_Name(Is_GP, Name)
	local Data = Get_Data(Is_GP)

	for Key, Item_Data in next, Data do
		if(Item_Data ~= nil and Item_Data['Name'] ~= nil and Item_Data['Name'] == Name)then
			return Key
		end
	end

	return nil
end

local function Get_Player_Owned_Gamepasses_Keys(Plr)
	local Owned_GP_Keys = Get_Player_Data(Plr, "Owned Gamepasses") or ""
	return string.split(Owned_GP_Keys, ",")
end

local function Player_Owns_Gamepass(Plr, Key)
	local Owned_Keys = Get_Player_Owned_Gamepasses_Keys(Plr)
	if(Owned_Keys ~= nil and #Owned_Keys > 0 and table.find(Owned_Keys, Key) ~= nil)then
		return true
	end

	return false
end


function Monetization_Mod.Get_Player_Owned_Gamepasses_Keys(Plr)
	return Get_Player_Owned_Gamepasses_Keys(Plr)
end

function Monetization_Mod.Get_All_Gamepass_Data()
	return GP_Data
end

function Monetization_Mod.Get_All_Dev_Product_Data()
	return Dev_Data
end

function Monetization_Mod.Get_All_UGC_Data()
	return UGC_Data
end

function Monetization_Mod.Get_ID_From_Name(Is_GP, Name)
	return Get_ID_From_Name(Is_GP, Name)
end

function Monetization_Mod.Get_ID_From_Key(Is_GP, Key)
	if(Is_GP)then
		local Data_V = GP_Data[Key]
		if(Data_V ~= nil and Data_V['ID'] ~= nil)then
			return Data_V['ID']
		end
	else
		local Data_V = Dev_Data[Key]
		if(Data_V ~= nil and Data_V['ID'] ~= nil)then
			return Data_V['ID']
		end
	end

	return -1
end


function Monetization_Mod.Get_Key_From_Name(Is_GP, Name)
	return Get_Key_From_Name(Is_GP, Name)
end

function Monetization_Mod.Get_Key_From_ID(Is_GP, ID)
	local Data = Get_Data(Is_GP)

	for Key, Item_Data in next, Data do
		if(Item_Data ~= nil and Item_Data['ID'] ~= nil and Item_Data['ID'] == ID)then
			return Key
		end
	end

	return nil
end

function Monetization_Mod.Get_Data_From_Key(Is_GP, Key)
	if(Is_GP)then
		return GP_Data[Key]
	end
	return Dev_Data[Key]
end

function Monetization_Mod.Does_Player_Own_Gamepass(Plr, Name)
	local GP_Key = Get_Key_From_Name(true, Name)
	return Player_Owns_Gamepass(Plr, GP_Key)
end

function Monetization_Mod.Does_Player_Own_Gamepass_Key(Plr, Key)
	return Player_Owns_Gamepass(Plr, Key)
end

function Monetization_Mod.Hard_Gamepass_Check(Plr, GP_ID)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = MPS:UserOwnsGamePassAsync(Plr.UserId, GP_ID)
		end)

		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end

	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end

	return false
end

local function Compile_Cash_Boost_Amounts(Plr)
	local Vals = {
		['A'] = Dev_Data['A']['Amount'],
		['B'] = Dev_Data['B']['Amount'],
		['C'] = Dev_Data['C']['Amount'],
		['D'] = Dev_Data['D']['Amount'],
		['E'] = Dev_Data['E']['Amount']
	}
	return Vals
end

function Monetization_Mod.Get_Cash_Boost_Amount(Plr)
	return Compile_Cash_Boost_Amounts(Plr)
end

function Monetization_Mod.Prompt_Suggested_Cash_Boost(Plr, Needed_Amount)
	local Boost_Data = Compile_Cash_Boost_Amounts(Plr)
	local Boost_Key = "A"
	local Current_Dif, Current_Max = math.huge, -1

	for Key, Amount in next, Boost_Data do
		local Dif = math.abs(Amount - Needed_Amount)
		if((Amount >= Needed_Amount or Amount >= Current_Max) and Dif < Current_Dif)then
			Boost_Key = Key
			Current_Dif = Dif
			Current_Max = Amount
		end
	end

	return Dev_Data[Boost_Key]
end

function Monetization_Mod.Get_Cash_Pack_Amount(Key)
	local Cash_Data = Dev_Data[Key]
	if(Cash_Data ~= nil and Cash_Data['Amount'] ~= nil)then
		return Cash_Data['Amount']
	end
	return 0
end

function Monetization_Mod.Get_Gems_Pack_Amount(Key)
	local Gems_Data = Dev_Data[Key]
	if(Gems_Data ~= nil and Gems_Data['Amount'] ~= nil)then
		return Gems_Data['Amount']
	end
	return 0
end

function Monetization_Mod.Get_Cash_Pack_Price(Key)
	local Cash_Data = Dev_Data[Key]
	if(Cash_Data ~= nil and Cash_Data['Amount'] ~= nil)then
		return Cash_Data['Price']
	end
	return 0
end

function Monetization_Mod.Get_Gems_Pack_Price(Key)
	local Gems_Data = Dev_Data[Key]
	if(Gems_Data ~= nil and Gems_Data['Amount'] ~= nil)then
		return Gems_Data['Price']
	end
	return 0
end


function Monetization_Mod.Get_Cash_Multi(Plr)
	local Multi = 1

	local Owned_x2_Cash = Player_Owns_Gamepass(Plr, "C") or (Plr.Player_Data.Cash2x.Value == true)
	if(Owned_x2_Cash)then
		Multi += 1
	end

	local Owned_VIP = Player_Owns_Gamepass(Plr, "A") or (Plr.Player_Data.Vip.Value == true)
	if(Owned_VIP)then
		Multi += 0.1
	end

	return Multi
end

function Monetization_Mod.Get_Elo_Multi(Plr)
	local Multi = 1

	local Owned_x2_Elo = Player_Owns_Gamepass(Plr, "B")
	if(Owned_x2_Elo)then
		Multi += 1
	end

	return Multi
end

function Monetization_Mod.Get_Luck_Multi(Plr)
	local Multi = 1

	local Owned_x2_Luck = Player_Owns_Gamepass(Plr, "F")
	if(Owned_x2_Luck)then
		Multi += 1
	end

	local Owned_x3_Luck = Player_Owns_Gamepass(Plr, "E")
	if(Owned_x3_Luck)then
		Multi += 2
	end

	local Friends_Count = Plr:GetAttribute("Friends_Count") or 0
	Multi += Friends_Count * 0.1

	return Multi
end

function Monetization_Mod.Get_ID_From_Key_UGC( Key)------------By Adnan
	local Data_V = UGC_Data[Key]
	if(Data_V ~= nil and Data_V['ID'] ~= nil)then
		return Data_V['ID']
	end
	return -1
end

function Monetization_Mod.Get_UGC_Key_From_ID_UGC(ID)----------By Adnan
	for key, item in pairs(UGC_Data) do
		if item.ID == ID then
			return key
		end
	end
	return nil
end

return Monetization_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{C280C565-AE73-4587-9967-DBFE942B4914}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Monetization_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX986316544EDB455EA8A3B4164224AD34">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/CameraShaker.lua
--
--  Description:
--      Camera shake utility library (ported from EZ Camera Shake, Unity3D).
--      Provides API to apply one-time or sustained shakes with configurable
--      magnitude, roughness, fade times, and positional/rotational influence.
--
--  Author(s): Stephen Leitnick (port), Road Turtle Games (original Unity asset)
--  Integrated by: Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage/Data_Mods_F:
--          * CameraShakeInstance
--          * CameraShakePresets
--      - Roblox Services:
--          * RunService (BindToRenderStep)
--
--  Notes:
--      - Based on EZ Camera Shake (Unity asset) with permission from author
--      - Provides presets (Explosion, Earthquake, etc.)
--      - Supports ShakeOnce, ShakeSustain, and StopSustained
--      - Callback function must apply the shake CFrame to camera
--
--======================================================================



-- Camera Shaker
-- Stephen Leitnick
-- February 26, 2018

--[[
	
	CameraShaker.CameraShakeInstance
	
	cameraShaker = CameraShaker.new(renderPriority, callbackFunction)
	
	CameraShaker:Start()
	CameraShaker:Stop()
	CameraShaker:StopSustained([fadeOutTime])
	CameraShaker:Shake(shakeInstance)
	CameraShaker:ShakeSustain(shakeInstance)
	CameraShaker:ShakeOnce(magnitude, roughness [, fadeInTime, fadeOutTime, posInfluence, rotInfluence])
	CameraShaker:StartShake(magnitude, roughness [, fadeInTime, posInfluence, rotInfluence])
	
	
	
	EXAMPLE:
	
		local camShake = CameraShaker.new(Enum.RenderPriority.Camera.Value, function(shakeCFrame)
			camera.CFrame = playerCFrame * shakeCFrame
		end)
		
		camShake:Start()
		
		-- Explosion shake:
		camShake:Shake(CameraShaker.Presets.Explosion)
		
		wait(1)
		
		-- Custom shake:
		camShake:ShakeOnce(3, 1, 0.2, 1.5)

		-- Sustained shake:
		camShake:ShakeSustain(CameraShaker.Presets.Earthquake)

		-- Stop all sustained shakes:
		camShake:StopSustained(1) -- Argument is the fadeout time (defaults to the same as fadein time if not supplied)

		-- Stop only one sustained shake:
		shakeInstance = camShake:ShakeSustain(CameraShaker.Presets.Earthquake)
		wait(2)
		shakeInstance:StartFadeOut(1) -- Argument is the fadeout time
	
	
	NOTE:
	
		This was based entirely on the EZ Camera Shake asset for Unity3D. I was given written
		permission by the developer, Road Turtle Games, to port this to Roblox.
		
		Original asset link: https://assetstore.unity.com/packages/tools/camera/ez-camera-shake-33148

		GitHub repository: https://github.com/Sleitnick/RbxCameraShaker
	
	
--]]



local CameraShaker = {}
CameraShaker.__index = CameraShaker

local profileBegin = debug.profilebegin
local profileEnd = debug.profileend
local profileTag = "CameraShakerUpdate"

local V3 = Vector3.new
local CF = CFrame.new
local ANG = CFrame.Angles
local RAD = math.rad
local v3Zero = V3()

local CameraShakeInstance = require(script.CameraShakeInstance)
local CameraShakeState = CameraShakeInstance.CameraShakeState

local defaultPosInfluence = V3(0.15, 0.15, 0.15)
local defaultRotInfluence = V3(1, 1, 1)


CameraShaker.CameraShakeInstance = CameraShakeInstance
CameraShaker.Presets = require(script.CameraShakePresets)


function CameraShaker.new(renderPriority, callback)
	
	assert(type(renderPriority) == "number", "RenderPriority must be a number (e.g.: Enum.RenderPriority.Camera.Value)")
	assert(type(callback) == "function", "Callback must be a function")
	
	local self = setmetatable({
		_running = false;
		_renderName = "CameraShaker";
		_renderPriority = renderPriority;
		_posAddShake = v3Zero;
		_rotAddShake = v3Zero;
		_camShakeInstances = {};
		_removeInstances = {};
		_callback = callback;
	}, CameraShaker)
	
	return self
	
end


function CameraShaker:Start()
	if (self._running) then return end
	self._running = true
	local callback = self._callback
	game:GetService("RunService"):BindToRenderStep(self._renderName, self._renderPriority, function(dt)
		profileBegin(profileTag)
		local cf = self:Update(dt)
		profileEnd()
		callback(cf)
	end)
end


function CameraShaker:Stop()
	if (not self._running) then return end
	game:GetService("RunService"):UnbindFromRenderStep(self._renderName)
	self._running = false
end


function CameraShaker:StopSustained(duration)
	for _,c in pairs(self._camShakeInstances) do
		if (c.fadeOutDuration == 0) then
			c:StartFadeOut(duration or c.fadeInDuration)
		end
	end
end


function CameraShaker:Update(dt)
	
	local posAddShake = v3Zero
	local rotAddShake = v3Zero
	
	local instances = self._camShakeInstances
	
	-- Update all instances:
	for i = 1,#instances do
		
		local c = instances[i]
		local state = c:GetState()
		
		if (state == CameraShakeState.Inactive and c.DeleteOnInactive) then
			self._removeInstances[#self._removeInstances + 1] = i
		elseif (state ~= CameraShakeState.Inactive) then
			local shake = c:UpdateShake(dt)
			posAddShake = posAddShake + (shake * c.PositionInfluence)
			rotAddShake = rotAddShake + (shake * c.RotationInfluence)
		end
		
	end
	
	-- Remove dead instances:
	for i = #self._removeInstances,1,-1 do
		local instIndex = self._removeInstances[i]
		table.remove(instances, instIndex)
		self._removeInstances[i] = nil
	end
	
	return CF(posAddShake) *
			ANG(0, RAD(rotAddShake.Y), 0) *
			ANG(RAD(rotAddShake.X), 0, RAD(rotAddShake.Z))
	
end


function CameraShaker:Shake(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance, "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:ShakeSustain(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance, "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	shakeInstance:StartFadeIn(shakeInstance.fadeInDuration)
	return shakeInstance
end


function CameraShaker:ShakeOnce(magnitude, roughness, fadeInTime, fadeOutTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:StartShake(magnitude, roughness, fadeInTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	shakeInstance:StartFadeIn(fadeInTime)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


return CameraShaker]]></ProtectedString>
						<string name="ScriptGuid">{E22C7767-32CC-4A89-A4CA-416D798B6142}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CameraShaker.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX1A719976F37E4AA1BB2ACCBC5EC75425">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CameraShaker</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX2A3C05CE3D8842069EDDC85C0438F7B8">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/CameraShaker/CameraShakeInstance.lua
--
--  Description:
--      Represents a single camera shake instance. Stores configuration
--      for magnitude, roughness, fade in/out, and positional/rotational
--      influence. Provides methods to update, fade, and scale shake.
--
--  Author(s): Stephen Leitnick
--  Integrated by: Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox:
--          * Vector3
--          * math.noise
--          * Random
--      - Local Modules:
--          * Used by CameraShaker.lua and CameraShakePresets.lua
--
--  Notes:
--      - States: FadingIn, FadingOut, Sustained, Inactive
--      - UpdateShake(dt) returns current offset Vector3
--      - Supports runtime fade in/out adjustments
--      - PositionInfluence and RotationInfluence vectors apply shake
--      - DeleteOnInactive auto-cleans instance after fade
--
--======================================================================



local CameraShakeInstance = {}
CameraShakeInstance.__index = CameraShakeInstance

local V3 = Vector3.new
local NOISE = math.noise


CameraShakeInstance.CameraShakeState = {
	FadingIn = 0;
	FadingOut = 1;
	Sustained = 2;
	Inactive = 3;
}


function CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	
	if (fadeInTime == nil) then fadeInTime = 0 end
	if (fadeOutTime == nil) then fadeOutTime = 0 end
	
	assert(type(magnitude) == "number", "Magnitude must be a number")
	assert(type(roughness) == "number", "Roughness must be a number")
	assert(type(fadeInTime) == "number", "FadeInTime must be a number")
	assert(type(fadeOutTime) == "number", "FadeOutTime must be a number")
	
	local self = setmetatable({
		Magnitude = magnitude;
		Roughness = roughness;
		PositionInfluence = V3();
		RotationInfluence = V3();
		DeleteOnInactive = true;
		roughMod = 1;
		magnMod = 1;
		fadeOutDuration = fadeOutTime;
		fadeInDuration = fadeInTime;
		sustain = (fadeInTime > 0);
		currentFadeTime = (fadeInTime > 0 and 0 or 1);
		tick = Random.new():NextNumber(-100, 100);
		_camShakeInstance = true;
	}, CameraShakeInstance)
	
	return self
	
end


function CameraShakeInstance:UpdateShake(dt)
	
	local _tick = self.tick
	local currentFadeTime = self.currentFadeTime
	
	local offset = V3(
		NOISE(_tick, 0) * 0.5,
		NOISE(0, _tick) * 0.5,
		NOISE(_tick, _tick) * 0.5
	)
	
	if (self.fadeInDuration > 0 and self.sustain) then
		if (currentFadeTime < 1) then
			currentFadeTime = currentFadeTime + (dt / self.fadeInDuration)
		elseif (self.fadeOutDuration > 0) then
			self.sustain = false
		end
	end
	
	if (not self.sustain) then
		currentFadeTime = currentFadeTime - (dt / self.fadeOutDuration)
	end
	
	if (self.sustain) then
		self.tick = _tick + (dt * self.Roughness * self.roughMod)
	else
		self.tick = _tick + (dt * self.Roughness * self.roughMod * currentFadeTime)
	end
	
	self.currentFadeTime = currentFadeTime
	
	return offset * self.Magnitude * self.magnMod * currentFadeTime
	
end


function CameraShakeInstance:StartFadeOut(fadeOutTime)
	if (fadeOutTime == 0) then
		self.currentFadeTime = 0
	end
	self.fadeOutDuration = fadeOutTime
	self.fadeInDuration = 0
	self.sustain = false
end


function CameraShakeInstance:StartFadeIn(fadeInTime)
	if (fadeInTime == 0) then
		self.currentFadeTime = 1
	end
	self.fadeInDuration = fadeInTime or self.fadeInDuration
	self.fadeOutDuration = 0
	self.sustain = true
end


function CameraShakeInstance:GetScaleRoughness()
	return self.roughMod
end


function CameraShakeInstance:SetScaleRoughness(v)
	self.roughMod = v
end


function CameraShakeInstance:GetScaleMagnitude()
	return self.magnMod
end


function CameraShakeInstance:SetScaleMagnitude(v)
	self.magnMod = v
end


function CameraShakeInstance:GetNormalizedFadeTime()
	return self.currentFadeTime
end


function CameraShakeInstance:IsShaking()
	return (self.currentFadeTime > 0 or self.sustain)
end


function CameraShakeInstance:IsFadingOut()
	return ((not self.sustain) and self.currentFadeTime > 0)
end


function CameraShakeInstance:IsFadingIn()
	return (self.currentFadeTime < 1 and self.sustain and self.fadeInDuration > 0)
end


function CameraShakeInstance:GetState()
	if (self:IsFadingIn()) then
		return CameraShakeInstance.CameraShakeState.FadingIn
	elseif (self:IsFadingOut()) then
		return CameraShakeInstance.CameraShakeState.FadingOut
	elseif (self:IsShaking()) then
		return CameraShakeInstance.CameraShakeState.Sustained
	else
		return CameraShakeInstance.CameraShakeState.Inactive
	end
end


return CameraShakeInstance]]></ProtectedString>
							<string name="ScriptGuid">{93000183-FBCE-4BCF-8386-5230A23BE16A}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CameraShakeInstance.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX075C0413F7A34A438A81B6678D7F74E2">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/CameraShaker/CameraShakePresets.lua
--
--  Description:
--      Defines preset camera shake configurations (e.g. Explosion,
--      Earthquake, HandheldCamera). Each preset returns a new
--      CameraShakeInstance with predefined magnitude, roughness,
--      fade times, and positional/rotational influences.
--
--  Author(s): Stephen Leitnick
--  Integrated by: Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Local Modules:
--          * CameraShakeInstance
--      - Roblox:
--          * Vector3
--
--  Notes:
--      - Presets include: Bump, Explosion, Earthquake, BadTrip,
--        HandheldCamera, Vibration, RoughDriving
--      - Each call returns a fresh CameraShakeInstance
--      - Designed for use with CameraShaker.lua
--
--======================================================================


-- Camera Shake Presets
-- Stephen Leitnick
-- February 26, 2018

--[[
	
	CameraShakePresets.Bump
	CameraShakePresets.Explosion
	CameraShakePresets.Earthquake
	CameraShakePresets.BadTrip
	CameraShakePresets.HandheldCamera
	CameraShakePresets.Vibration
	CameraShakePresets.RoughDriving
	
--]]



local CameraShakeInstance = require(script.Parent.CameraShakeInstance)

local CameraShakePresets = {


	-- A high-magnitude, short, yet smooth shake.
	-- Should happen once.
	Bump = function()
		local c = CameraShakeInstance.new(2.5, 4, 0.1, 0.75)
		c.PositionInfluence = Vector3.new(0.15, 0.15, 0.15)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;


	-- An intense and rough shake.
	-- Should happen once.
	Explosion = function()
		local c = CameraShakeInstance.new(5, 10, 0, 1.5)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(4, 1, 1)
		return c
	end;


	-- A continuous, rough shake
	-- Sustained.
	Earthquake = function()
		local c = CameraShakeInstance.new(0.6, 3.5, 2, 10)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(1, 1, 4)
		return c
	end;


	-- A bizarre shake with a very high magnitude and low roughness.
	-- Sustained.
	BadTrip = function()
		local c = CameraShakeInstance.new(10, 0.15, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0.15)
		c.RotationInfluence = Vector3.new(2, 1, 4)
		return c
	end;

	-- A subtle, slow shake.
	-- Sustained.
	HandheldCamera = function()
		local c = CameraShakeInstance.new(1, 0.25, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 0.5, 0.5)
		return c
	end;

	-- A very rough, yet low magnitude shake.
	-- Sustained.
	Vibration = function()
		local c = CameraShakeInstance.new(0.4, 20, 2, 2)
		c.PositionInfluence = Vector3.new(0, 0.15, 0)
		c.RotationInfluence = Vector3.new(1.25, 0, 4)
		return c
	end;

	-- A slightly rough, medium magnitude shake.
	-- Sustained.
	RoughDriving = function()
		local c = CameraShakeInstance.new(1, 2, 1, 1)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;
}

return setmetatable({}, {
	__index = function(t, i)
		local f = CameraShakePresets[i]
		if (type(f) == "function") then
			return f()
		end
		error("No preset found with index \"" .. i .. "\"")
	end;
})]]></ProtectedString>
							<string name="ScriptGuid">{99BE9C80-E925-413D-89DB-8C3B1B04AFC3}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CameraShakePresets.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXD3DFC714A19A408CAF57708D36D30878">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/UI_LeagueTournament_Handler.lua
--
--  Description:
--      Centralized client-side module handling UI updates and event
--      synchronization for both League and Tournament systems.
--      Listens to RemoteEvents for live updates (division changes,
--      tournament progress, and results) and dynamically updates the
--      relevant UI frames bound via BindUI().
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-11-01 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/League_Mod (for league visuals and emojis)
--          * Channels_F/Server_Client_F/Events (RemoteEvents)
--      - Services:
--          * Players
--
--  Notes:
--      - Supports both standalone and merged “LeagueTournament” UIs
--      - UI_Handler:BindUI(uiType, frame) links specific UI frames
--      - Handles live leaderboard rendering and visual rank styling
--      - Automatically updates division, score, and tournament state
--      - Used by the client to reflect server-driven league progression
--
--======================================================================
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local League_Mod = require(game.ReplicatedStorage:WaitForChild("Data_Mods_F"):WaitForChild("League_Mod"))

-- Centralized channel structure
local Channels = require(game.ReplicatedStorage.Modules.Channels)

-- RemoteEvents
local LeagueUpdate = Channels.SC_Remote_Events.League_DivisionUpdate
local TournamentUpdate = Channels.SC_Remote_Events.Tournament_Update
local TournamentResults = Channels.SC_Remote_Events.Tournament_Results

local UI_Handler = {}

-- ==========================================================
-- INTERNAL STATE
-- ==========================================================
UI_Handler.boundUIs = {}
UI_Handler.CurrentLeague = {}
UI_Handler.CurrentTournament = {}

-- ==========================================================
-- BINDING
-- ==========================================================
function UI_Handler:BindUI(uiType, frame)
	self.boundUIs = self.boundUIs or {}

	if uiType == "League" then
		self.boundUIs["League"] = frame
	elseif uiType == "Tournament" then
		self.boundUIs["Tournament"] = frame
	elseif uiType == "LeagueTournament" then
		self.boundUIs["LeagueTournament"] = frame
	end
end

-- ==========================================================
-- UPDATE FUNCTIONS
-- ==========================================================
function UI_Handler:SetTournamentStats(data)
	-- Accept both fusionned and separated UI
	local ui = self.boundUIs["LeagueTournament"]
		or self.boundUIs["Tournament"]

	if not ui then
		warn("[UI_Handler] Tournament UI not bound yet")
		return
	end

	local mainFrame = ui:FindFirstChild("Main_F")
	if not mainFrame then return end
	local body = mainFrame:FindFirstChild("Body")
	if not body then return end
	local tournamentSection = body:FindFirstChild("Tournament_Section") or ui

	local statusLabel = tournamentSection:FindFirstChild("StatusLabel")
	local scoreLabel = tournamentSection:FindFirstChild("ScoreLabel")

	-- update registration status
	if data.Status and statusLabel then
		statusLabel.Text = (data.Status == "Registered")
			and "✓ Registered for Tournament"
			or "✗ Not Registered"
	end

	-- update score
	if data.Score and scoreLabel then
		scoreLabel.Text = string.format("Score: %d", data.Score)
	end

	-- update last result if present
	if data.LastResult then
		local resultFrame = tournamentSection:FindFirstChild("ResultFrame")
		if resultFrame and resultFrame:FindFirstChild("TextLabel") then
			resultFrame.TextLabel.Text =
				string.format("Last result: %s", data.LastResult)
		end
	end

	-- 🔥 Live ranking update
	-- ?? Live ranking update
	-- 🏆 Update live leaderboard
	if data.Ranking then
		local tournamentSection = body:FindFirstChild("Tournament_Section") or ui
		local leaderboard = tournamentSection:WaitForChild("LeaderboardFrame", 5)
		if not leaderboard then
			warn("[UI] LeaderboardFrame not found.")
			return
		end

		local template = leaderboard:FindFirstChild("PlayerTemplate")

		-- clear old entries (keep template)
		for _, child in ipairs(leaderboard:GetChildren()) do
			if child:IsA("Frame") and child.Name ~= "PlayerTemplate" then
				child:Destroy()
			end
		end

		-- sort ranking by score
		table.sort(data.Ranking, function(a, b)
			return a.Score > b.Score
		end)

		for i = 1, math.min(10, #data.Ranking) do
			local entry = data.Ranking[i]
			local row = template and template:Clone() or Instance.new("Frame")
			row.Name = "Row_" .. i
			row.Visible = true
			row.Size = UDim2.new(1, 0, 0, 28)
			row.BackgroundTransparency = 0.05
			row.Parent = leaderboard

			-- UI labels
			local rankLabel = row:FindFirstChild("RankLabel") or Instance.new("TextLabel")
			rankLabel.Text = "#" .. i
			rankLabel.Size = UDim2.new(0.1, 0, 1, 0)
			rankLabel.BackgroundTransparency = 1
			rankLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			rankLabel.TextXAlignment = Enum.TextXAlignment.Center
			rankLabel.Font = Enum.Font.Nunito
			rankLabel.Parent = row

			local nameLabel = row:FindFirstChild("NameLabel") or Instance.new("TextLabel")
			local emoji = League_Mod.GetEmoji(data.Division)
			nameLabel.Text = string.format("%s %s", emoji, entry.Name or "Unknown")
			nameLabel.Size = UDim2.new(0.6, 0, 1, 0)
			nameLabel.Position = UDim2.new(0.1, 0, 0, 0)
			nameLabel.BackgroundTransparency = 1
			nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			nameLabel.TextXAlignment = Enum.TextXAlignment.Left
			nameLabel.Font = Enum.Font.Nunito
			nameLabel.Parent = row

			local scoreLabel = row:FindFirstChild("ScoreLabel") or Instance.new("TextLabel")
			scoreLabel.Text = tostring(entry.Score or 0)
			scoreLabel.Size = UDim2.new(0.3, 0, 1, 0)
			scoreLabel.Position = UDim2.new(0.7, 0, 0, 0)
			scoreLabel.BackgroundTransparency = 1
			scoreLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			scoreLabel.TextXAlignment = Enum.TextXAlignment.Right
			scoreLabel.Font = Enum.Font.Nunito
			scoreLabel.Parent = row

			-- 🎨 background color by rank
			if i == 1 then
				row.BackgroundColor3 = Color3.fromRGB(255, 215, 0) -- gold
			elseif i == 2 then
				row.BackgroundColor3 = Color3.fromRGB(192, 192, 192) -- silver
			elseif i == 3 then
				row.BackgroundColor3 = Color3.fromRGB(205, 127, 50) -- bronze
			else
				row.BackgroundColor3 = League_Mod.GetColor(data.Division)
			end

			-- ✨ UICorner + UIStroke styling
			local corner = row:FindFirstChildOfClass("UICorner") or Instance.new("UICorner")
			corner.CornerRadius = UDim.new(0, 6)
			corner.Parent = row

			local stroke = row:FindFirstChildOfClass("UIStroke") or Instance.new("UIStroke")
			stroke.Thickness = 1
			stroke.Transparency = 0.25
			stroke.Color = Color3.fromRGB(90, 90, 90)
			stroke.Parent = row
		end

		print(string.format("[CLIENT] Live leaderboard updated (%s)", data.Division or "?"))
	end


end


function UI_Handler:SetLeagueStats(stats)
	local ui = self.boundUIs["LeagueTournament"]
		or self.boundUIs["League"]

	if not ui then
		warn("[UI_Handler] League UI not bound yet")
		return
	end

	local mainFrame = ui:FindFirstChild("Main_F")
	if not mainFrame then return end
	local body = mainFrame:FindFirstChild("Body")
	if not body then return end
	local leagueSection = body:FindFirstChild("League_Section") or ui

	local leagueLabel = leagueSection:FindFirstChild("LeagueLabel")
	local rankLabel = leagueSection:FindFirstChild("RankLabel")
	local winsLabel = leagueSection:FindFirstChild("WinsLabel")

	if leagueLabel then leagueLabel.Text = "Division: " .. (stats.Division or "?") end
	if rankLabel then rankLabel.Text = "Rank: " .. (stats.Rank or "?") end
	if winsLabel then winsLabel.Text = string.format("Wins: %d", stats.Wins or 0) end
end

-- ==========================================================
-- EVENT CONNECTIONS
-- ==========================================================
LeagueUpdate.OnClientEvent:Connect(function(stats)
	UI_Handler.CurrentLeague = stats
	UI_Handler:SetLeagueStats(stats)
end)

TournamentUpdate.OnClientEvent:Connect(function(data)
	UI_Handler.CurrentTournament = data
	UI_Handler:SetTournamentStats(data)
end)

TournamentResults.OnClientEvent:Connect(function(result)
	local ui = UI_Handler.boundUIs["LeagueTournament"]
		or UI_Handler.boundUIs["Tournament"]
	if not ui then return end

	local section = ui:FindFirstChild("Main_F")
		and ui.Main_F:FindFirstChild("Body")
		and ui.Main_F.Body:FindFirstChild("Tournament_Section")
	local resultFrame = section and section:FindFirstChild("ResultFrame")
	if not resultFrame then return end

	resultFrame.Visible = true
	local textLabel = resultFrame:FindFirstChild("TextLabel")
	if not textLabel then return end

	local rankings = result.Rankings or {}
	table.sort(rankings, function(a, b) return a.Score > b.Score end)
	local output = string.format("Final Results - %s\n", result.Division or "?")
	for i, entry in ipairs(rankings) do
		output ..= string.format("%d. %s - %d pts\n", i, entry.Name, entry.Score)
	end
	textLabel.Text = output
end)


-- ==========================================================
-- PUBLIC API
-- ==========================================================
function UI_Handler:GetCurrentLeague()
	return self.CurrentLeague
end

function UI_Handler:GetCurrentTournament()
	return self.CurrentTournament
end

return UI_Handler]]></ProtectedString>
						<string name="ScriptGuid">{EA4ABADD-9E0C-4A3C-A194-5522C44153FC}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UI_LeagueTournament_Handler.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFFAC0727AACC45729653CE5E8F6C2A13">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Elo_Mod.lua
--
--  Description:
--      Elo ranking module. Defines rank tiers (Bronze → Platinum) with
--      icon, color, and Elo ranges. Handles Elo computation, soft caps,
--      and helper utilities to retrieve rank-related data.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-12-14 by Darkzeb
--
--  Version: V2025-12
--
--  Dependencies:
--      - Roblox:
--          * NumberRange
--          * Color3
--          * Player.Player_Data.Elo
--
--  Notes:
--      - Players start at 400 Elo by default
--      - Elo can go below 400 but is capped at 3000
--      - Strong soft cap applied after 2500 Elo
--      - Rank_Data:
--          * Bronze   (0–550 Elo)
--          * Silver   (550–800 Elo)
--          * Gold     (800–1150 Elo)
--          * Emerald  (1150–1600 Elo)
--          * Diamond  (1600–2150 Elo)
--          * Platinum (2150+ Elo)
--
--======================================================================

local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

local Elo_Mod = {}

-- Elo bounds
Elo_Mod.ELO_DIFF_UNIT = 400
Elo_Mod.ELO_MIN = 400  -- Default starting Elo
Elo_Mod.ELO_MAX = 3000 -- Absolute maximum Elo (hard cap)
Elo_Mod.SOFT_CAP_ELO = 2500 

-- Elo modes with different K-factors
Elo_Mod.EloMode = {
	Standard   = { Name = "Standard",   K = 8 },
	League     = { Name = "League",     K = 24 },
	Tournament = { Name = "Tournament", K = 24 },
	Ranked     = { Name = "Ranked",     K = 40 },
}

-- Rank definitions and Elo ranges
local Rank_Data = {
	['Bronze'] = {
		['Index'] = 1,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(0, 550),
		['Color'] = Color3.fromRGB(170, 170, 127)
	},
	
	['Silver'] = {
		['Index'] = 2,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(550, 800),
		['Color'] = Color3.new(1, 1, 1)
	},
	
	['Gold'] = {
		['Index'] = 3,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(800, 1150),
		['Color'] = Color3.fromRGB(255, 170, 0)
	},
	
	['Emerald'] = {
		['Index'] = 4,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(1150, 1600),
		['Color'] = Color3.fromRGB(170, 255, 0)
	},
	
	['Diamond'] = {
		['Index'] = 5, 
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(1600, 2150),
		['Color'] = Color3.new(0, 1, 1)
	},
	
	['Platinum'] = {
		['Index'] = 6,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(2150, math.huge),
		['Color'] = Color3.fromRGB(170, 85, 255)
	},
}

--======================================================================
-- Soft cap logic
-- Strongly reduces Elo gains after 2500, reaching near-zero at 3000
--======================================================================
local function getSoftCappedK(elo, baseK)
	
	-- No reduction below or equal to 2500
	if elo <= Elo_Mod.SOFT_CAP_ELO then
		return baseK
	end

	-- Minimal gain at max Elo
	if elo >= Elo_Mod.ELO_MAX then
		return 1
	end

	-- Linear reduction between 2500 and 3000
	local factor = 1 - ((elo - Elo_Mod.SOFT_CAP_ELO) / (Elo_Mod.ELO_MAX - Elo_Mod.SOFT_CAP_ELO))
	return math.max(1, math.floor(baseK * factor))
end

-- Expected score formula (classic Elo)
local function expectedScore(eloA, eloB)
	return 1 / (1 + 10 ^ ((eloB - eloA) / Elo_Mod.ELO_DIFF_UNIT))
end

-- Computes updated Elo with soft cap and hard max cap
local function getUpdatedElo(oldElo, opponentElo, result, kFactor)
	local effectiveK = getSoftCappedK(oldElo, kFactor)

	local e = expectedScore(oldElo, opponentElo)
	local rawDelta = effectiveK * (result - e)

	-- Ensure minimum absolute Elo change of 1
	local delta
	if rawDelta > 0 then
		delta = math.max(1, math.floor(rawDelta))
	elseif rawDelta < 0 then
		delta = math.min(-1, math.ceil(rawDelta))
	else
		delta = 0
	end

	local newElo = oldElo + delta

	-- Hard cap at max only
	if newElo > Elo_Mod.ELO_MAX then
		newElo = Elo_Mod.ELO_MAX
	end

	return newElo
end

--======================================================================
-- Public API
--======================================================================

-- Returns rank data and Elo value for a player
function Elo_Mod.Get_Player_Rank_Data(Plr)
	if(Plr ~= nil)then
		local Elo_Val = PlayerUtils.GetPlayerVal(Plr, "Elo")
		local Ret_Data = Rank_Data['Bronze']
		Ret_Data['Key'] = "Bronze"

		if(Elo_Val ~= nil)then
			local Elo_Amount = Elo_Val.Value
			for Key, Data in next, Rank_Data do
				local Range = Data['Elo Range']
				if(Range.Min <= Elo_Amount and Range.Max > Elo_Amount)then
					Data['Key'] = Key
					return Data, Elo_Amount
				end
			end
		end
	end
	
	local Ret_Data = Rank_Data['Bronze']
	Ret_Data['Key'] = "Bronze"
	return Ret_Data, Elo_Mod.ELO_MIN
end

-- Returns the next rank based on index
function Elo_Mod.Get_Next_Rank_Data(Current_Index)
	for Key, Data in next, Rank_Data do
		if(Current_Index + 1 == Data['Index'])then
			return Data
		end
	end
	
	return Rank_Data['Platinum']
end

-- Returns rank key and data from an Elo value
function Elo_Mod.Get_Elo_Data_From_Val(Val)
	for Key, Data in next, Rank_Data do
		local Range = Data['Elo Range']
		local Min, Max = Range.Min, Range.Max
		
		if(Val >= Min and Val <= Max)then
			return Key, Data
		end
	end
	
	return "Bronze", Rank_Data['Bronze']
end

-- Computes new Elo values for winner and loser
function Elo_Mod.Compute_Elo(winnerElo, loserElo, mode)
	if not mode then
		mode = Elo_Mod.EloMode.Standard
	end

	local K_Factor = mode.K or Elo_Mod.EloMode.Standard.K

	local newWinnerElo = getUpdatedElo(winnerElo, loserElo, 1, K_Factor)
	local newLoserElo  = getUpdatedElo(loserElo, winnerElo, 0, K_Factor)

	return newWinnerElo, newLoserElo
end

-- Scaling factor for rewards based on Elo difference
function Elo_Mod.Get_Elo_Reward_Scaling(player, opponent)
	local pData = player:FindFirstChild("Player_Data")
	local oData = opponent:FindFirstChild("Player_Data")
	if not pData or not oData then return 1 end

	local pElo = pData:FindFirstChild("Elo") and pData.Elo.Value or 0
	local oElo = oData:FindFirstChild("Elo") and oData.Elo.Value or 0

	local diff = oElo - pElo
	local scaling = 1 + (diff / Elo_Mod.ELO_DIFF_UNIT)
	if scaling < 0.5 then scaling = 0.5 end

	return scaling
end

-- Returns raw Elo difference between two players
function Elo_Mod.Get_Elo_Diff(player, opponent)
	local pData = player:FindFirstChild("Player_Data")
	local oData = opponent:FindFirstChild("Player_Data")
	if not pData or not oData then return 0 end

	local pElo = pData:FindFirstChild("Elo") and pData.Elo.Value or 0
	local oElo = oData:FindFirstChild("Elo") and oData.Elo.Value or 0

	return oElo - pElo
end

-- Returns true if two players are in same or adjacent ranges
function Elo_Mod.Adjacent_Elo_Ranks(player, opponent)
	local p_rank, p_elo = Elo_Mod.Get_Player_Rank_Data(player)
	local o_rank, o_elo = Elo_Mod.Get_Player_Rank_Data(opponent)
	
	local p_rank_idx = p_rank['Index']
	local o_rank_idx = o_rank['Index']
	
	return (p_rank_idx == o_rank_idx) or (p_rank_idx == o_rank_idx + 1) or (p_rank_idx + 1 == o_rank_idx)
end


return Elo_Mod]]></ProtectedString>
						<string name="ScriptGuid">{D1565207-A13F-43D4-8C66-D60BA82B3F40}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Elo_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX233C9F35A9C9484DB6F14B39D7F0A2AC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Sound_Mod.lua
--
--  Description:
--      Utility module for handling sound effects and voice overs.
--      Provides functions to fetch sounds from PlayerGui, play global
--      server sounds, and manage randomized voice overs with chance
--      and enable/disable settings.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * Debris (cleanup cloned sounds)
--          * Players
--          * ServerStorage.Global_Sounds_F
--      - Player Instances:
--          * PlayerGui.Sound_Effects_F
--          * PlayerGui.Sound_Effects_F.Voice_Over_F
--          * Player.Player_Data["Voice Over"]
--
--  Notes:
--      - funcs API:
--          * PlaySFX(Obj, SE_Name): plays server global sound
--          * Play_Voice_Over(Action_Key): plays random voice clip
--      - Voice Over system:
--          * Controlled by Player_Data["Voice Over"].Value
--          * Chance attribute (%) on Audio_F determines probability
--          * Did_Play attribute avoids replaying same clip
--      - Supports folders of variant sounds (random selection)
--      - Sounds auto-cleaned with Debris after TimeLength + 1s
--
--======================================================================

local Sound_Mod = {}
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")

local AUDIO = ReplicatedStorage:WaitForChild("Audio")

local SFX_FOLDER = AUDIO:WaitForChild("SFX")
local MUSIC_FOLDER = AUDIO:WaitForChild("Music")
local VOICE_FOLDER = AUDIO:WaitForChild("Voice_Over")

---------------------------------------------------------------------
-- SETTINGS
---------------------------------------------------------------------
function Sound_Mod.SFX_Enabled()
	return SoundService:GetAttribute("SFX_Enabled") ~= false
end

function Sound_Mod.Music_Enabled()
	return SoundService:GetAttribute("Music_Enabled") ~= false
end

---------------------------------------------------------------------
-- HELPERS
---------------------------------------------------------------------
local function chooseVariant(obj)
	if obj:IsA("Folder") then
		local list = obj:GetChildren()
		if #list == 0 then
			warn("[SoundEffectMod] Empty folder:", obj.Name)
			return nil
		end
		return list[math.random(1, #list)]
	end
	return obj
end

local function findIn(folder, name)
	local obj = folder:FindFirstChild(name)
	if not obj then
		warn("[SoundEffectMod] Missing sound:", name)
		return nil
	end
	return chooseVariant(obj)
end

function Sound_Mod.PlaySFX(parent, soundName)
	if not Sound_Mod.SFX_Enabled() then return end

	local template = findIn(SFX_FOLDER, soundName)
	if not template then return end

	local c = template:Clone()
	c.Parent = parent or SoundService
	c:Play()

	Debris:AddItem(c, c.TimeLength + 1)
end

local CurrentMusic = nil

function Sound_Mod.PlayMusic(parent, soundName)
	if not Sound_Mod.Music_Enabled() then return end
	
	if CurrentMusic then
		CurrentMusic:Stop()
		CurrentMusic:Destroy()
		CurrentMusic = nil
	end

	local template = findIn(MUSIC_FOLDER, soundName)
	if not template then return end

	local m = template:Clone()
	m.Looped = true
	m.Parent = parent or SoundService
	m:Play()

	CurrentMusic = m
end

function Sound_Mod.StopMusic()
	if CurrentMusic then
		CurrentMusic:Stop()
		CurrentMusic:Destroy()
		CurrentMusic = nil
	end
end

function Sound_Mod.Play_Voice_Over(actionName)
	local plr = Players.LocalPlayer
	if not plr then return end

	local PD = plr:FindFirstChild("Player_Data")
	if not (PD and PD:FindFirstChild("Voice Over") and PD["Voice Over"].Value) then
		return
	end

	local actionFolder = VOICE_FOLDER:FindFirstChild(actionName)
	if not actionFolder then
		warn("[SoundEffectMod] Missing Voice Over action:", actionName)
		return
	end

	local clips = actionFolder:GetChildren()
	if #clips == 0 then return end

	local selected = clips[math.random(1, #clips)]
	local chance = selected:GetAttribute("Chance") or 100

	if selected:GetAttribute("Did_Play") then return end

	if math.random(1, 100) <= chance then
		selected:SetAttribute("Did_Play", true)
		selected:Play()
	end
end

return Sound_Mod]]></ProtectedString>
						<string name="ScriptGuid">{1D25F64A-814E-4F0C-9961-417AF0E23939}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Sound_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX304BDA8643754D27B70DC191A4560594">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Animation_Mod.lua
--
--  Description:
--      Centralized module for all animation data. Defines movement,
--      striking, and combination moves with associated metadata such as
--      asset IDs, power multipliers, reversibility, and purchase cost.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Animation_Objs_F (container for Animation instances)
--
--  Notes:
--      - Movement_Animations: Idle and shuffle moves
--      - Striking_Data: defensive animations (blocks, slips, dodge, etc.)
--      - Combination_Move_Data: offensive moves (punches, kicks) with fight/purchase metadata
--      - Each entry stores Asset ID, reversibility, and fight-related multipliers
--      - Designed for use by Combination_Handle, Core_Fight_Handle, etc.
--
--======================================================================


local Animation_Mod = {}
local Animation_Objs_F = game.ReplicatedStorage:WaitForChild("Animation_Objs_F")

local Movement_Animations = {
	['Idle'] = 108077631566601,
	['Shuffle Side'] = 79375297609893,
	['Shuffle Forward'] = 136948432130840,
	
	--['Shuffle Forward'] = 109207253924129,
	
	--['Shuffle Side'] = 89602830994683,
	--['Shuffle Forward'] = 139861313294402,
}

local Striking_Data = {
	['Taking Hit'] = {
		['ID'] = 87073445720365,
		['Reverses'] = false
	},
	
	['Body Block Left'] = {
		['ID'] = 104895699142546,
		['Reverses'] = true
	},
	
	['Body Block Right'] = {
		['ID'] = 99944482960873,
		['Reverses'] = true
	},
	
	['Slip Left'] = {
		['ID'] = 136849218895282,
		['Reverses'] = true
	},

	['Slip Right'] = {
		['ID'] = 122220718204244,
		['Reverses'] = true
	},
	
	['Dodge Back'] = {
		['ID'] = 94177011723049,
		['Reverses'] = false
	},
	
	['Headblock Left'] = {
		['ID'] = 110779732594817,
		['Reverses'] = true
	},

	['Headblock Right'] = {
		['ID'] = 121662213274181,
		['Reverses'] = true
	},
	
	['Main Block'] = {
		['ID'] = 94238142478294,
		['Reverses'] = true
	},
	
}
--//
-- Punch (8): A,B,C,G,L,M,N,O
-- Kick (10) : D,E,F,H,I,J,K,P,Q,R
local Combination_Move_Data = {
	['A'] = {
		['Name'] = "Cross Punch",
		['Punch'] = true,
		['ID'] = 100227999129843,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://118407716580363",
		['Power Multi'] = 0,
		['Damage'] = 6,
		['Time Length'] = 0.333,
		['Duration'] = "SHORT",
		['Price'] = 0
	},

	['B'] = {
		['Name'] = "Hook Punch",
		['ID'] = 81561131125346,
		['Punch'] = true,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://122669512309567",
		['Power Multi'] = 0.2,
		['Damage'] = 7,
		['Time Length'] = 0.500,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['C'] = {
		['Name'] = "Jab",
		['ID'] = 134317457381878,
		['Punch'] = true,
		['Reverses'] = false,
		['Icon'] = "rbxassetid://100517302134415",
		['Power Multi'] = 0.2,
		['Damage'] = 6,
		['Time Length'] = 0.370,
		['Duration'] = "SHORT",
		['Price'] = 0
	},

	['D'] = {
		['Name'] = "Body Kick",
		['ID'] = 125520199895947,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://94521634377382",
		['Power Multi'] = 0.2,
		['Damage'] = 7,
		['Time Length'] = 0.550,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['E'] = {
		['Name'] = "Head Kick",
		['ID'] = 132422928966701,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://77784698400276",
		['Power Multi'] = 0.1,
		['Damage'] = 8,
		['Time Length'] = 0.600,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['F'] = {
		['Name'] = "Leg Kick",
		['ID'] = 110461738059355,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://102937129099083",
		['Power Multi'] = 0.1,
		['Damage'] = 6,
		['Time Length'] = 0.467,
		['Duration'] = "SHORT",
		['Price'] = 0
	},

	['G'] = {
		['Name'] = "Overhand Punch",
		['ID'] = 131610958973209,
		['Punch'] = true,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://137155984605073",
		['Power Multi'] = 0.4,
		['Damage'] = 8,
		['Time Length'] = 0.767,
		['Duration'] = "LONG",
		['Price'] = 0
	},

	['H'] = {
		['Name'] = "Push Kick",
		['ID'] = 77338767921527,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://120516884574158",
		['Power Multi'] = 0.1,
		['Damage'] = 6,
		['Time Length'] = 0.433,
		['Duration'] = "SHORT",
		['Price'] = 0
	},

	['I'] = {
		['Name'] = "Roundhouse Body Kick",
		['ID'] = 81721721853423,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://133772978433824",
		['Power Multi'] = 0.3,
		['Damage'] = 8,
		['Time Length'] = 0.617,
		['Duration'] = "LONG",
		['Price'] = 0
	},

	['J'] = {
		['Name'] = "Roundhouse Head Kick",
		['ID'] = 79766698080686,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://104985491295539",
		['Power Multi'] = 0.3,
		['Damage'] = 8,
		['Time Length'] = 0.650,
		['Duration'] = "LONG",
		['Price'] = 0
	},

	['K'] = {
		['Name'] = "Roundhouse Leg Kick",
		['ID'] = 138214621139428,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://136613070075301",
		['Power Multi'] = 0.2,
		['Damage'] = 7,
		['Time Length'] = 0.567,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['L'] = {
		['Name'] = "Spinning Backfist",
		['ID'] = 96399865414625,
		['Punch'] = true,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://136613070075301",
		['Power Multi'] = 0.4,
		['Damage'] = 8,
		['Time Length'] = 0.717,
		['Duration'] = "LONG",
		['Price'] = 0
	},

	['M'] = {
		['Name'] = "Uppercut Punch",
		['ID'] = 71389736066050,
		['Punch'] = true,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://83706181409186",
		['Power Multi'] = 0.2,
		['Damage'] = 7,
		['Time Length'] = 0.583,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['N'] = {
		['Name'] = "Elbow Strike",
		['ID'] = 132635065254903,
		['Punch'] = true,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://138866086874937",
		['Power Multi'] = 0.2,
		['Damage'] = 7,
		['Time Length'] = 0.550,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['O'] = {
		['Name'] = "Spinning Elbow Strike",
		['ID'] = 111369637414564,
		['Punch'] = true,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://101103585275656",
		['Power Multi'] = 0.2,
		['Damage'] = 8,
		['Time Length'] = 0.550,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},

	['P'] = {
		['Name'] = "Flying Knee Strike",
		['ID'] = 130784737248262,
		['Punch'] = false,
		['Reverses'] = false,
		['Icon'] = "rbxassetid://105034123942809",
		['Power Multi'] = 0.5,
		['Damage'] = 9,
		['Time Length'] = 0.817,
		['Duration'] = "LONG",
		['Price'] = 0
	},

	['Q'] = {
		['Name'] = "Knee Clinch",
		['ID'] = 81137097576975,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://100038500073272",
		['Power Multi'] = 0,
		['Damage'] = 6,
		['Time Length'] = 0.350,
		['Duration'] = "SHORT",
		['Price'] = 0
	},

	['R'] = {
		['Name'] = "Knee Strike",
		['ID'] = 108737295565365,
		['Punch'] = false,
		['Reverses'] = true,
		['Icon'] = "rbxassetid://136052094451802",
		['Power Multi'] = 0.2,
		['Damage'] = 7,
		['Time Length'] = 0.517,
		['Duration'] = "MEDIUM",
		['Price'] = 0
	},
}



local Takedown_Move_Data = {
	['A'] = {
		['Name'] = "Takedown",
		['Takedown ID'] = 90000582035319,
		['Receiving ID'] = 137215852579263,
		['CF Offset'] = CFrame.new(Vector3.new(0.4881000518798828, 0.00011396408081054688, -3.292452335357666)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Time Length'] = 1.02,
		['Price'] = 0
	},
	
	['B'] = {
		['Name'] = "Suplex",
		['Takedown ID'] = 96292674087311,
		['Receiving ID'] = 124116836479443,
		['CF Offset'] = CFrame.new(Vector3.new(0.4881000518798828, 0.00011396408081054688, -3.292452335357666)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Time Length'] = 2.07,
		['Price'] = -1
	},
}

local Submission_Hold_Data = {
	['A'] = {
		['Name'] = "Armbar",
		['Submission ID'] = 77995795549949,
		['Submission Loop ID'] = 131555693143885,
		['Receiving ID'] = 135512944211258,
		['Receiving Loop ID'] = 114826200035426,
		['CF Offset'] = CFrame.new(Vector3.new(-0.2868995666503906, 0.00011396408081054688, -3.292452335357666)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = 0
	},
	
	['B'] = {
		['Name'] = "Bow + Arrow Choke",
		['Submission ID'] = 75355863213565,
		['Submission Loop ID'] = 85715488163612,
		['Receiving ID'] = 82374638588189,
		['Receiving Loop ID'] = 123114250253699,
		['CF Offset'] = CFrame.new(Vector3.new(-0.116668701171875, 0.25331592559814453, 1.6584720611572266)) * CFrame.Angles(-0, 0, -0),
		['Price'] = 0
	},
	
	['C'] = {
		['Name'] = "Rear Choke",
		['Submission ID'] = 132773296535203,
		['Submission Loop ID'] = 125823752907571,
		['Receiving ID'] = 124306025776879,
		['Receiving Loop ID'] = 77790217013197,
		['CF Offset'] = CFrame.new(Vector3.new(-0.0677032470703125, 0.16611409187316895, 0.8032341003417969)) * CFrame.Angles(-0, 0, -0),
		['Price'] = -1
	},
	
	['D'] = {
		['Name'] = "D'Acre Choke",
		['Submission ID'] = 119311130373519,
		['Submission Loop ID'] = 125304925445976,
		['Receiving ID'] = 80700787386082,
		['Receiving Loop ID'] = 120536455540110,
		['CF Offset'] = CFrame.new(Vector3.new(0.3773040771484375, 0.00011396408081054688, -7.310765266418457)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},

	['E'] = {
		['Name'] = "Peruvian Necktie",
		['Submission ID'] = 80067783627585,
		['Submission Loop ID'] = 122521525908433,
		['Receiving ID'] = 92103429555208,
		['Receiving Loop ID'] = 83941364350231,
		['CF Offset'] = CFrame.new(Vector3.new(-1.8148994445800781, 0.00011396408081054688, -5.270452499389648)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
	
	['F'] = {
		['Name'] = "Crucifix Choke",
		['Submission ID'] = 136852003392692,
		['Submission Loop ID'] = 138253407435423,
		['Receiving ID'] = 84266203794329,
		['Receiving Loop ID'] = 133824539813558,
		['CF Offset'] = CFrame.new(Vector3.new(-2.4148998260498047, 0.00011396408081054688, -0.8284523487091064)) * CFrame.Angles(-0, math.rad(-90), 0),
		['Price'] = -1
	},
	
	['G'] = {
		['Name'] = "Ezekiel Choke",
		['Submission ID'] = 138151382939604,
		['Submission Loop ID'] = 87342228644616,
		['Receiving ID'] = 130331156841132,
		['Receiving Loop ID'] = 130320679529339,
		['CF Offset'] = CFrame.new(Vector3.new(-0.009899139404296875, 0.00011396408081054688, 2.3495476245880127)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
	
	['H'] = {
		['Name'] = "North-South Choke",
		['Submission ID'] = 120276704304047,
		['Submission Loop ID'] = 101002039631767,
		['Receiving ID'] = 93330579903894,
		['Receiving Loop ID'] = 139785195887722,
		['CF Offset'] = CFrame.new(Vector3.new(4.597099304199219, 0.00011396408081054688, 4.539547920227051)) * CFrame.Angles(0, math.rad(90), 0),
		['Price'] = -1
	},
	
	['I'] = {
		['Name'] = "Anaconda Choke",
		['Submission ID'] = 139254908975474,
		['Submission Loop ID'] = 123395024978060,
		['Receiving ID'] = 107198374601193,
		['Receiving Loop ID'] = 108362674273214,
		['CF Offset'] = CFrame.new(Vector3.new(0.1930999755859375, 0.00011396408081054688, -4.3244524002075195)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
	
	['J'] = {
		['Name'] = "Guillotine Choke",
		['Submission ID'] = 125216184549242,
		['Submission Loop ID'] = 140031549975052,
		['Receiving ID'] = 122205044713456,
		['Receiving Loop ID'] = 135121330657191,
		['CF Offset'] = CFrame.new(Vector3.new(-0.189697265625, 0.00011396408081054688, 0.0002346038818359375)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
	
	['K'] = {
		['Name'] = "Triangle Choke",
		['Submission ID'] = 89703608283013,
		['Submission Loop ID'] = 124327589301499,
		['Receiving ID'] = 73462023202758,
		['Receiving Loop ID'] = 94751838108470,
		['CF Offset'] = CFrame.new(Vector3.new(-0.5547027587890625, 0.00011396408081054688, -0.09476470947265625)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
}

local Cage_Clinch_Data = {
	['A'] = {
		['Name'] = "Clinch Init",
		['ID'] = 80784815674908,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = true,
		['Link Key'] = "F",
	},
	
	['B'] = {
		['Name'] = "Clinch Loop",
		['ID'] = 87962198986708,
		['Reverses'] = false,
		['Looped'] = true,
		['Attacking'] = true,
		['Link Key'] = "G",
	},
	
	['C'] = {
		['Name'] = "High Knee",
		['ID'] = 132795144177389,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = true,
		['Link Key'] = "H",
	},
	
	['D'] = {
		['Name'] = "Low Knee",
		['ID'] = 93673806124998,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = true,
		['Link Key'] = "I",
	},
	
	['E'] = {
		['Name'] = "Uppercut",
		['ID'] = 99286997711377,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = true,
		['Link Key'] = "J",
	},


	['F'] = {
		['Name'] = "Clinch Init Target",
		['ID'] = 139067262581330,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = false,
		['Link Key'] = "A",
	},

	['G'] = {
		['Name'] = "Clinch Loop Target",
		['ID'] = 99857009954124,
		['Reverses'] = false,
		['Looped'] = true,
		['Attacking'] = false,
		['Link Key'] = "B",
	},

	['H'] = {
		['Name'] = "High Knee Target",
		['ID'] = 136345233529547,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = false,
		['Link Key'] = "C",
	},

	['I'] = {
		['Name'] = "Low Knee Target",
		['ID'] = 126512754019218,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = false,
		['Link Key'] = "D",
	},

	['J'] = {
		['Name'] = "Uppercut Target",
		['ID'] = 71592715011713,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = false,
		['Link Key'] = "E",
	},
}

local Emote_Data = {
	['A'] = {
		['Name'] = "Flexing",
		['ID'] = 10713990381,
		['Icon'] = "rbxassetid://129785468776058",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['B'] = {
		['Name'] = "Dolphin Dance",
		['ID'] = 10714068222,
		['Icon'] = "rbxassetid://110318046103048",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['C'] = {
		['Name'] = "1-2 Combo",
		['ID'] = 10717116749,
		['Icon'] = "rbxassetid://129775502633259",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['D'] = {
		['Name'] = "Flossing",
		['ID'] = 10714340543,
		['Icon'] = "rbxassetid://117551617182244",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['E'] = {
		['Name'] = "Break Dance",
		['ID'] = 18526288497,
		['Icon'] = "rbxassetid://109576668333205",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['F'] = {
		['Name'] = "Backflip",
		['ID'] = 15693621070,
		['Icon'] = "rbxassetid://113129464009404",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['G'] = {
		['Name'] = "Monkey",
		['ID'] = 10714388352,
		['Icon'] = "rbxassetid://140702511165691",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['H'] = {
		['Name'] = "Frosty Flair",
		['ID'] = 10214311282,
		['Icon'] = "rbxassetid://111762236681762",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['I'] = {
		['Name'] = "Wild Stuff",
		['ID'] = 18665811005,
		['Icon'] = "rbxassetid://76044186658278",
		['Price'] = 10,
		['Reverses'] = false
	},
	
	['J'] = {
		['Name'] = "Zab",
		['ID'] = 129470135909814,
		['Icon'] = "rbxassetid://116534530149694",
		['Price'] = 10,
		['Reverses'] = false
	},
	
	['K'] = {
		['Name'] = "Robot",
		['ID'] = 10714392151,
		['Icon'] = "rbxassetid://108233046384117",
		['Price'] = 10,
		['Reverses'] = false
	},
}

local function Get_Player_Val(Plr, Key, Get_Object)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		local V = PD:FindFirstChild(Key)
		if(Get_Object)then
			return V
		else
			return V.Value
		end
		
	end
	
	return nil
end

local function Get_Animation_Track(Hum, Name, ID)
	local function Create_Animation_Object()
		local Ani_Obj = Animation_Objs_F:FindFirstChild(Name .. "_Ani")
		if(Ani_Obj == nil)then
			Ani_Obj = Instance.new("Animation", Animation_Objs_F)
			Ani_Obj.Name = Name .. "_Ani"
			Ani_Obj.AnimationId = "rbxassetid://" .. ID
		end
		return Ani_Obj
	end
	local Ani_Obj = Create_Animation_Object()
	return Hum:LoadAnimation(Ani_Obj)
end

function Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Tack_Data = {
		
	}
	
	for Key, ID in next, Movement_Animations do
		Anim_Tack_Data[Key] = Get_Animation_Track(Hum, Key, ID)
	end
	
	return Anim_Tack_Data
end

function Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Anim_Tack_Data = {

	}

	for Key, Anim_Data in next, Striking_Data do
		local Anim_T = Get_Animation_Track(Hum, Key, Anim_Data['ID'])
		local Is_Reversing = Anim_Data['Reverses'] or false
		Anim_T:SetAttribute("Reverses", Is_Reversing)
		
		Anim_Tack_Data[Key] = Anim_T
	end

	return Anim_Tack_Data
end

function Animation_Mod.Get_Strike_Combo_Data(Strike_Key)
	if(Combination_Move_Data[Strike_Key] ~= nil)then
		return Combination_Move_Data[Strike_Key]
	end
	return Combination_Move_Data['A']
end

function Animation_Mod.Get_Takedown_Action_Data(Key)
	if Takedown_Move_Data[Key] ~=nil then 
		return Takedown_Move_Data[Key]
	end
	return Takedown_Move_Data['A']
end

function Animation_Mod.Get_Submission_Action_Data(Key)
	if Submission_Hold_Data[Key] ~=nil then 
		return Submission_Hold_Data[Key]
	end
	return Submission_Hold_Data['A']
end



local function Player_Owns_Strike_Key_Check(Plr, Strike_Key)
	local Strike_Data = Combination_Move_Data[Strike_Key]
	if(Strike_Data ~= nil and Strike_Data['Price'] ~= nil and Strike_Data['Price'] > 0)then
		local Owned_Strikes_V = Get_Player_Val(Plr, "Owned Special Strikes", false) or ""
		local Owned_Strikes_Keys = string.split(Owned_Strikes_V, ",")

		if(Owned_Strikes_Keys ~= nil and table.find(Owned_Strikes_Keys, Strike_Key) == nil)then
			return false
		end
	end

	return true
end

function Animation_Mod.Player_Owns_Strike_Key(Plr, Strike_Key)
	return Player_Owns_Strike_Key_Check(Plr, Strike_Key)
end


function Animation_Mod.Get_Striking_Combination_Tracks(Plr, Hum, Combo_Name)
	local Owned_Strikes_V = Get_Player_Val(Plr, "Owned Special Strikes", false) or ""
	local Owned_Strikes_Keys = string.split(Owned_Strikes_V, ",")
	
	local function Player_Owns_Combo(C_Data, Key)
		if(C_Data['Price'] ~= nil and C_Data['Price'] > 0 and 
			table.find(Owned_Strikes_Keys, Key) == nil)then

			return false
		end
		return true
	end
	
	local Combo_String = ""
	if Combo_Name == "Bot Combo"  then
		Combo_String = "C,A,E,C,A,H"
	else 
		Combo_String= Get_Player_Val(Plr, Combo_Name, false)
	end
	
	local Ani_Tracks = {}
	if(Combo_String ~= nil)then
		local Clean_Combo_Str = string.gsub(Combo_String, " ", "")
		local Str_Split = string.split(Clean_Combo_Str, ",")

		for i = 1, #Str_Split do
			local Ani_Key = Str_Split[i]
			if(Combination_Move_Data[Ani_Key] ~= nil)then
				local C_Data = Combination_Move_Data[Ani_Key]
				local Ani_Name, Ani_ID = C_Data['Name'], C_Data['ID']

				if(Ani_Name ~= nil and Ani_ID ~= nil and Player_Owns_Combo(C_Data, Ani_Key))then
					local Ani_T = Get_Animation_Track(Hum, Ani_Name, Ani_ID)
					local Is_Reversing = C_Data['Reverses']
					Ani_T:SetAttribute("Reverses", Is_Reversing)
					Ani_T:SetAttribute("Strike_Key", Ani_Key)

					table.insert(Ani_Tracks, Ani_T)
				end
			end
		end
	end
	
	return Ani_Tracks
end

local function Get_Punch_Data(Is_Punch)
	local moves = {}
	for key, data in pairs(Combination_Move_Data) do
		if data.Punch == Is_Punch then
			moves[key] = data
		end
	end
	return moves
end

function Animation_Mod.Get_Combinations(Tble)
	if Tble == "Combination" then
		return Combination_Move_Data
	elseif Tble == "Punch" then
		return Get_Punch_Data(true)
	elseif Tble == "Kick" then
		return Get_Punch_Data(false)
	elseif Tble == "Submission" then
		return Submission_Hold_Data
	elseif Tble == "Takedown" then
		return Takedown_Move_Data
	elseif Tble == "Emotes" then
		return Emote_Data
	end
	return nil
end

function Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_ID, Submission_ID, Submission_Loop_ID)
	local function Create_Track_To_Return(ID)
		local Track = Get_Animation_Track(Hum, ID, ID)
		if(Track ~= nil)then
			Track:SetAttribute("Reverses", false)
			return Track
		end
		return nil
	end
	local Takedown_Track = Create_Track_To_Return(Takedown_ID)
	local Submission_Track = Create_Track_To_Return(Submission_ID)
	
	local Submission_Loop_Track = Create_Track_To_Return(Submission_Loop_ID)
	if(Submission_Loop_Track ~= nil)then
		Submission_Loop_Track.Looped = true
	end
	
	return Takedown_Track, Submission_Track, Submission_Loop_Track
end

function Animation_Mod.Player_Owns_Submission_Key_Check(Plr, Strike_Key)
	local Submission_Data = Submission_Hold_Data[Strike_Key]
	
	if (Submission_Data ~= nil and Submission_Data['Price'] and Submission_Data['Price'] == 0) then 
		return true 
	end
	
	if(Submission_Data ~= nil and Submission_Data['Price'] ~= nil and Submission_Data['Price'] ~= 0)then
		local Owned_Submission_V = Get_Player_Val(Plr, "Owned Special Submissions", false) or ""
		local Owned_Submission_Keys = string.split(Owned_Submission_V, ",")
		
		if (Owned_Submission_Keys == nil) then return false end

		if(Owned_Submission_Keys ~= nil and table.find(Owned_Submission_Keys, Strike_Key) == nil) then
			return false
		end
		
	end

	return true
end

function Animation_Mod.Player_Owns_Takedown_Key_Check(Plr, Strike_Key)
	local Takedown_Data = Takedown_Move_Data[Strike_Key]

	if (Takedown_Data ~= nil and Takedown_Data['Price'] and Takedown_Data['Price'] == 0) then 
		return true 
	end

	if(Takedown_Data ~= nil and Takedown_Data['Price'] ~= nil and Takedown_Data['Price'] ~= 0)then
		local Owned_Submission_V = Get_Player_Val(Plr, "Owned Special Takedowns", false) or ""
		local Owned_Submission_Keys = string.split(Owned_Submission_V, ",")

		if (Owned_Submission_Keys == nil) then return false end

		if(Owned_Submission_Keys ~= nil and table.find(Owned_Submission_Keys, Strike_Key) == nil) then
			return false
		end

	end

	return true
end

function Animation_Mod.Get_Unlockable_Submission_Keys(Plr)
	local Keys = {}
	if(Plr ~= nil)then
		--Takedowns
		for T_Keys, T_Data in next, Takedown_Move_Data do
			if(Animation_Mod.Player_Owns_Submission_Key_Check(Plr, T_Keys) == false)then
				table.insert(Keys, T_Keys)
			end
		end
		
		--Submissions
		for S_Keys, S_Data in next, Submission_Hold_Data do
			if(Animation_Mod.Player_Owns_Submission_Key_Check(Plr, S_Keys) == false)then
				table.insert(Keys, S_Keys)
			end
		end
	end
	
	return Keys
end

function Animation_Mod.Get_Unlockable_Strike_Keys(Plr)
	local Keys = {}
	if(Plr ~= nil)then
		for S_Key, S_Data in next, Combination_Move_Data do
			if(Player_Owns_Strike_Key_Check(Plr, S_Key) == false)then
				table.insert(Keys, S_Key)
			end
		end
	end
	
	return Keys
end

function Animation_Mod.Get_Special_Submission_Data(Key)
	--Either Takedown or Submission
	if(Takedown_Move_Data[Key] ~= nil and Takedown_Move_Data[Key]['Price'] ~= nil 
		and Takedown_Move_Data[Key]['Price'] ~= 0)then
		
		return Takedown_Move_Data[Key]
		
	elseif(Submission_Hold_Data[Key] ~= nil and Submission_Hold_Data[Key]['Price'] ~= nil
		and Submission_Hold_Data[Key]['Price'] ~= 0)then
		
		return Submission_Hold_Data[Key]
	end
	
	return nil
end

local function Player_Owns_Emote(Plr, Key)
	local Owned_Keys = Get_Player_Val(Plr, "Owned Emotes", false)
	if(Owned_Keys ~= nil)then
		local Keys = string.split(Owned_Keys, ",")
		if(Emote_Data[Key]["Price"] <= 0) then
			return true
		elseif(Keys ~= nil and #Keys > 0 and table.find(Keys, Key) ~= nil)then
			return true
		end
	end
	
	return false -- replace to False after Demo Testing
end

function Animation_Mod.Player_Owns_Emote_Key(Plr, Key)
	return Player_Owns_Emote(Plr,Key)
end

function Animation_Mod.Get_Unlockable_Emotes(Plr)
	local Keys = {}
	if(Plr ~= nil)then
		local Ignore_Keys_Due_To_Gamepass = {"I", "J", "K"}
		for E_Key, E_Data in next, Emote_Data do
			if(table.find(Ignore_Keys_Due_To_Gamepass, E_Key) == nil and 
				Player_Owns_Emote(Plr, E_Key) == false)then
				
				table.insert(Keys, E_Key)
			end
		end
	end
	
	return Keys
end

function Animation_Mod.Get_Emote_Data_From_Key(Key)
	return Emote_Data[Key]
end

function Animation_Mod.Play_Emote_Track_From_Key(Plr, Hum, Key, Is_Looped)
	if(Plr ~= nil and Hum ~= nil and Emote_Data[Key] ~= nil and Emote_Data[Key]['ID'] ~= nil and 
		Emote_Data[Key]['Name'] ~= nil and Player_Owns_Emote(Plr, Key))then
		
		local E_Data = Emote_Data[Key]
		local Track = Get_Animation_Track(Hum, E_Data['Name'], E_Data['ID'])
		if(Track ~= nil)then
			Track.Looped = Is_Looped
			Track.Priority = Enum.AnimationPriority.Action
			Track:Play()
		end
		
	end
end

function Animation_Mod.Force_Play_Emote_Track_From_Key(Hum, Key, Is_Looped)
	local E_Data = Emote_Data[Key]
	local Track = Get_Animation_Track(Hum, E_Data['Name'], E_Data['ID'])
	if(Track ~= nil)then
		Track.Looped = Is_Looped
		Track.Priority = Enum.AnimationPriority.Action
		Track:Play()
	end
end

local function Get_Takedown_Submission_Keys(Attacking_Char)
	if(Attacking_Char ~= nil and game.Players:GetPlayerFromCharacter(Attacking_Char) ~= nil)then
		local A_Plr = game.Players:GetPlayerFromCharacter(Attacking_Char)
		local Takedown_Key = Get_Player_Val(A_Plr, "Takedown Key", false)
		local Submission_Key = Get_Player_Val(A_Plr, "Submission Key", false)

		if(Takedown_Key ~= nil and Submission_Key ~= nil)then
			return Takedown_Key, Submission_Key
		end
	end

	return "A", "A"
end

function Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)
	local Takedown_Key, Submission_Key = Get_Takedown_Submission_Keys(Attacking_Char)
	return Takedown_Move_Data[Takedown_Key], Submission_Hold_Data[Submission_Key]
end

function Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
	local function Get_Specific_Clinch_Track(Key)
		local Data = Cage_Clinch_Data[Key]
		if(Data ~= nil and Data['ID'] ~= nil and Data['Name'] ~= nil)then
			if(Is_Attacking == false and Data['Link Key'] ~= nil)then
				local New_Data_Key = Data['Link Key']
				local New_Data = Cage_Clinch_Data[New_Data_Key]
				if(New_Data ~= nil and New_Data['ID'] ~= nil and New_Data['Name'] ~= nil)then
					Data = New_Data
				end
			end
			
			return Get_Animation_Track(Hum, Data['Name'], Data['ID'])
		end
		
		return nil
	end
	
	return {
		['Init_Clinch'] = Get_Specific_Clinch_Track("A"),
		['Loop_Clinch'] = Get_Specific_Clinch_Track("B"),
		
		['C'] = Get_Specific_Clinch_Track("C"),
		['D'] = Get_Specific_Clinch_Track("D"),
		['E'] = Get_Specific_Clinch_Track("E")
	}
end

function Animation_Mod.Generate_Clinch_Attack_Keys()
	local Can_Use_Keys = {"C", "D", "E"}
	local Key_Data = {}
	
	for i = 1, 5 do
		local Picked_Key = Can_Use_Keys[math.random(1, #Can_Use_Keys)]
		table.insert(Key_Data, Picked_Key)
	end
	
	return Key_Data
end

function Animation_Mod.Stop_Animation_Tracks(Anim_Tracks, Ignore_List)
	for i = 1, #Anim_Tracks do
		local Ani_T = Anim_Tracks[i]
		if(Ani_T ~= nil and Ani_T.IsPlaying == true and table.find(Ignore_List, Ani_T) == nil)then
			Ani_T:Stop()
		end
	end
end

function Animation_Mod.Play_Animation_Track(Anim_Track, Should_Pause)
	local Is_Reverse = Anim_Track:GetAttribute("Reverses")
	Anim_Track:Play()
	Anim_Track:AdjustSpeed(1)
	
	if(Is_Reverse ~= nil and Is_Reverse == true)then
		wait(Anim_Track.Length * 0.99)

		Anim_Track:Play(0.100000001, 1, -1)
		Anim_Track:AdjustSpeed(-1)
	end
	
	if(Should_Pause ~= nil and Should_Pause)then
		wait(Anim_Track.Length * 0.95)
		Anim_Track:AdjustSpeed(0)
	else
		wait(Anim_Track.Length)
	end
	
end

function Animation_Mod.Play_Blocking_Track(Anim_Track)
	Anim_Track:Play()
	Anim_Track:AdjustSpeed(1)
	wait(Anim_Track.Length * 0.99)
	Anim_Track:AdjustSpeed(0)
end

local function Reset_Char_Animations(Char)
	local Hum = Char:FindFirstChild("Humanoid")
	if(Hum ~= nil)then
		local Ani_Tracks = Hum:GetPlayingAnimationTracks()
		for i = 1, #Ani_Tracks do
			if(Ani_Tracks[i] ~= nil and string.match(Ani_Tracks[i].Name, "Anim") == nil)then
				Ani_Tracks[i]:Stop()
				Ani_Tracks[i]:Destroy()
			end
		end
	end
end

function Animation_Mod.Reset_Character_Animations(Char)
	Reset_Char_Animations(Char)
end

function Animation_Mod.Player_Owns_Action(Plr, Action_Type, Action_Key)
	if Action_Type == "Submission" then
		return Animation_Mod.Player_Owns_Submission_Key_Check(Plr, Action_Key)
	elseif Action_Type == "Takedown" then
		return Animation_Mod.Player_Owns_Takedown_Key_Check(Plr, Action_Key)
	elseif Action_Type == "Emote" then
		return Animation_Mod.Player_Owns_Emote_Key(Plr, Action_Key)
	else
		return Animation_Mod.Player_Owns_Strike_Key(Plr, Action_Key)
	end
	
end

return Animation_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{6CE62A34-24F0-43ED-88B3-23E0D24211D8}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Animation_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3E185DFEEF824ECD81781BB9C1BDD953">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Stats_Manager_Mod.lua
--
--  Description:
--      Utility module for managing player stats and compiling fight
--      recap data. Provides functions to read/write Player_Data stats,
--      initialize fight data structures, and generate match summaries.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * Players
--      - Player Instances:
--          * Player.Player_Data (contains stat values)
--
--  Notes:
--      - funcs API:
--          * Add_To_Player_Stats_Data(Plr, Key, Inc)
--          * Set_Player_Stats_Data(Plr, Key, Val)
--          * Create_Fight_Data_Structure(Char): returns dict of stats
--          * Compile_Fight_Recap_Data(Init, Final, Win): returns diff recap
--      - Stats tracked include:
--          * Total Strikes, Strikes Landed, Dodged Strikes
--          * Takedowns Landed/Attempted
--          * Submissions Finished/Attempted
--          * Punch Knockout Wins, Leg Knockout Wins
--      - Fight recap computes differences and win count per fighter
--
--======================================================================


local Stats_Manager_Mod = {}

local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

local function Add_To_Player_Data(Plr, Key, Inc)
	local Val = PlayerUtils.GetPlayerVal(Plr, Key)
	if(Val ~= nil)then
		Val.Value += Inc
		
		if(Val.Value < 0)then
			Val.Value = 0
		end
	end
end

local function Set_To_Player_Data(Plr, Key, V)
	local Val = PlayerUtils.GetPlayerVal(Plr, Key)
	if(Val ~= nil)then
		Val.Value = V
	end
end

local function Compile_Fight_Recap_Data(Init_Data, Final_Data, Win_Data)	
	local function Get_Difference(Key)
		local F_Val = Final_Data[Key] or 0
		local I_Val = Init_Data[Key] or 0
		local Dif = F_Val - I_Val

		if(Dif < 0)then
			Dif = 0
		end

		return Dif
	end

	local function Count_Wins()
		local fighterName:string = Init_Data['Name']:gsub("@","")
		if(Win_Data ~= nil and #Win_Data > 0)then
			local Count = 0

			for _,thisName in Win_Data do
				if thisName == fighterName then
					Count += 1
				end
			end

			return Count
		end

		return 0
	end

	return {
		['ID'] = Init_Data['ID'],
		['Name'] = Init_Data['Name'],
		['DisplayName'] = Init_Data['DisplayName'],
		['Wins'] = Count_Wins(),
		['Total Strikes'] = Get_Difference("Strikes Landed") .. " / " .. Get_Difference("Total Strikes"),
		['Total Dodges'] = Get_Difference("Dodged Strikes"),
		['Knockouts'] = Get_Difference("Punch Knockout Wins") + Get_Difference("Leg Knockout Wins"),
		['Takedowns'] = Get_Difference("Takedowns Landed") .. " / " .. Get_Difference("Takedowns Attempted"),
		['Submissions'] = Get_Difference("Submissions Finished") .. " / " .. Get_Difference("Submissions Attempted"),
	}
end

function Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, Key, Inc)
	if(game.Players.LocalPlayer == nil and Plr ~= nil)then
		task.spawn(Add_To_Player_Data, Plr, Key, Inc)
	end
end

function Stats_Manager_Mod.Set_Player_Stats_Data(Plr, Key, Val)
	if(game.Players.LocalPlayer == nil and Plr ~= nil)then
		task.spawn(Set_To_Player_Data, Plr, Key, Val)
	end
end

function Stats_Manager_Mod.Create_Fight_Data_Structure(Char)
	local charName = "Player"
	
	if not Char then
		warn("Char param required")
	else
		if 	Char:GetAttribute("IsBot") then
			charName = Char:GetAttribute("Display_Name")
		else	
			charName = Char.Name
		end
	end
	
	local Data = {
		['ID'] = -1,
		['Name'] = `{charName}`,
		['DisplayName'] =`{charName}`,
		['Total Strikes'] = 0,
		['Strikes Landed'] = 0,
		['Dodged Strikes'] = 0,
		['Takedowns Landed'] = 0,
		['Takedowns Attempted'] = 0,
		['Submissions Finished'] = 0,
		['Submissions Attempted'] = 0,
		['Punch Knockout Wins'] = 0,
		['Leg Knockout Wins'] = 0
	}
	
	-- TODO retrieve bot stats (need to be added into behaviors ...)
	
	if(Char ~= nil and game.Players:GetPlayerFromCharacter(Char) ~= nil)then
		local Plr = game.Players:GetPlayerFromCharacter(Char)
		for Key, Init_V in Data do
			local P_Val = PlayerUtils.GetPlayerVal(Plr, Key)
			if not P_Val then
				continue
			end
			
			if(P_Val ~= nil)then
				Data[Key] = P_Val.Value
			end
		end
		
		Data['Name'] = "@" .. Plr.Name
		Data['DisplayName'] = Plr.DisplayName
		Data['ID'] = Plr.UserId
	end
	
	return Data
end

function Stats_Manager_Mod.Create_Fight_Result_Data(Init_C1, Init_C2, Final_C1, Final_C2, Round_Result_Arr, C1_Won)
	if(C1_Won)then
		return {
			['Winner'] = Compile_Fight_Recap_Data(Init_C1, Final_C1, Round_Result_Arr),
			['Loser'] = Compile_Fight_Recap_Data(Init_C2, Final_C2, Round_Result_Arr)
		}
	else
		return {
			['Loser'] = Compile_Fight_Recap_Data(Init_C1, Final_C1, Round_Result_Arr),
			['Winner'] = Compile_Fight_Recap_Data(Init_C2, Final_C2, Round_Result_Arr)
		}
	end
end

return Stats_Manager_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{F898EF73-B4E9-48DE-B261-70F9858F90E4}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Stats_Manager_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD924B906D9A6499490B022CD1ACEC43B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Clothing_Mod.lua
--
--  Description:
--      Defines cosmetic item data for gloves and shorts. Provides
--      mappings between item keys and display names, grouped by crates
--      (Tape, Country, Urban, Fury, Underground, Chromatic, etc.).
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Models/Clothing_F/Shorts_F
--          * Models/Clothing_F/Gloves_F
--
--  Notes:
--      - Gloves_Data maps keys to glove names
--      - Shorts_Data maps keys to shorts names
--      - Utility function Get_Data_Keys() returns CSV of all keys
--      - Used by Shop_Handle, Combination_Handle, Core_Character_Handle, etc.
--
--======================================================================


local Clothing_Mod = {}

local PlayerUtils	= require(game.ReplicatedStorage.Modules.PlayerUtils)

local Clothing_F 	= game.ReplicatedStorage:WaitForChild("Models"):WaitForChild("Clothing_F")
local Shorts_F 		= Clothing_F:WaitForChild("Shorts_F")
local Gloves_F 		= Clothing_F:WaitForChild("Gloves_F")

local Gloves_Data = {
	--// Default
	['A'] = "MMA Gloves",
	--// Tape Crate
	['B'] = "Black Tape",
	['C'] = "Blue Tape",
	['D'] = "Green Tape",
	['E'] = "Red Tape",
	['F'] = "Tan Tape",
	['G'] = "White Tape",
	['H'] = "Purple Tape",
	
	--// Gloves Crate 
	['I'] = "Blue Gloves",
	['J'] = "Green Gloves",
	['K'] = "Mystic Gloves",
	['L'] = "Purple Gloves",
	
	--// Country Crate #1
	['M'] = "Argentinian Gloves",
	['N'] = "Australian Gloves",
	['O'] = "Brazilian Gloves",
	['P'] = "Canadian Gloves",
	['Q'] = "Chilean Gloves",
	['R'] = "Chinese Gloves",
	['S'] = "English Gloves",
	--// Country Crate #2
	['T'] = "French Gloves",
	['U'] = "Georgian Gloves",
	['V'] = "Italian Gloves",
	['W'] = "Jamacian Gloves",
	['X'] = "Japanese Gloves",
	['Y'] = "Mexican Gloves",
	['Z'] = "Moldovan Gloves",

	--// Country Crate #3
	['A1'] = "Nigerian Gloves",
	['B1'] = "Polish Gloves",
	['C1'] = "New Zealand Gloves",
	['D1'] = "Russian Gloves",
	['E1'] = "Spanish Gloves",
	['F1'] = "USA Gloves",
	
	['G1'] = "Orange Gloves",
	['H1'] = "White Gloves",
	
	-- Urban Gloves
	['I1'] = "Graffiti Gloves",
	['J1'] = "Iron Gloves",
	['K1'] = "Gold Gloves",
	['L1'] = "Corrupted Purple Gloves",
	['M1'] = "Corrupted Green Gloves",
	['N1'] = "Corrupted Black Gloves",
	
	-- Fury Crate 1
	['O1'] = "Plastic Green Tape",
	['P1'] = "Plastic Blue Tape",
	['Q1'] = "Plastic Pink Tape",
	['R1'] = "Frozen Chain Tape",
	['S1'] = "Molten Chain Tape",
	['T1'] = "Carbon Chain Tape",

	-- Underground Crate 1
	['U1'] = "Plastic Green Gloves",
	['V1'] = "Plastic Blue Gloves",
	['W1'] = "Plastic Pink Gloves",
	['X1'] = "Blue Flame Gloves",
	['Y1'] = "Lava Gloves",
	['Z1'] = "Carbon Gloves",
	

	['A2'] = "Chromatic Green Gloves",
	['B2'] = "Chromatic Blue Gloves",
	['C2'] = "Chromatic Pink Gloves",
	
	['D2'] = "Chromatic Green Tape",
	['E2'] = "Chromatic Blue Tape",
	['F2'] = "Chromatic Pink Tape",

	['G2'] = "Fury Gloves",
	
	-- New Gloves
	['H2'] = "Spiderman Red Blue",
	['I2'] = "Spiderman Blue Red",
	['J2'] = "Spiderman Red Black",
	['K2'] = "Spiderman Black Red",
	['L2'] = "Hungary Gloves",
	['M2'] = "Thailand Gloves",
	
	
}

-- Unified rarity color table 
local RARITY_COLORS = {
	Platinum = Color3.fromRGB(255,170,255),
	Special  = Color3.fromRGB(255,170,255),
	Diamond  = Color3.fromRGB(150,255,255),
	Gold     = Color3.fromRGB(255,215,0),
	Silver   = Color3.fromRGB(217,217,217),
	Bronze   = Color3.fromRGB(196,124,57),
	Default  = Color3.fromRGB(255,255,255),
	Common   = Color3.fromRGB(255,255,255)
}

local RARITY_ORDER = {
	Platinum = 1,
	Diamond  = 2,
	Gold     = 3,
	Silver   = 4,
	Bronze   = 5,
	Common   = 6,
	Default  = 7,
	Special  = 1, -- même rang que Platinum
}

function Clothing_Mod.Get_Rarity_Order(rarity)
	return RARITY_ORDER[rarity] or 99
end

function Clothing_Mod.Get_Rarity_Color(rarity)
	return RARITY_COLORS[rarity] or RARITY_COLORS.Default
end

local Shorts_Data = {
	['A'] = "MMA Shorts",
	['B'] = "Karate Shorts",
	['C'] = "Denim",
	['D'] = "Dragon Gold",
	['E'] = "Black Champs",
	--// Country Crate #1
	['F'] = "Argentinian Shorts",
	['G'] = "Australian Shorts",
	['H'] = "Brazilian Shorts",
	['I'] = "Canadian Shorts",
	['J'] = "Chilean Shorts",
	['K'] = "Chinese Shorts",
	['L'] = "England Shorts",
	--// Country Crate #2
	['M'] = "French Shorts",
	['N'] = "Georgian Shorts",
	['O'] = "Italian Shorts",
	['P'] = "Jamaican Shorts",
	['Q'] = "Japanese Shorts",
	['R'] = "Mexican Shorts",
	['S'] = "Moldovan Shorts",
	--// Country Crate #3
	['T'] = "Mystic Shorts",
	['U'] = "New Zealand Shorts",
	['V'] = "Nigerian Shorts",
	['W'] = "Polish Shorts",
	['X'] = "Russian Shorts",
	['Y'] = "Spanish Shorts",
	['Z'] = "USA Shorts",
	
	-- New Shorts
	['A1'] = "Spiderman Black Shorts",
	['B1'] = "Spiderman Blue Shorts",
	['C1'] = "Thailand Shorts",
	['D1'] = "Hungary Shorts",
}

function Clothing_Mod.Get_All_Gloves_Data()
	return Gloves_Data
end

function Clothing_Mod.Get_All_Shorts_Data()
	return Shorts_Data
end

function Clothing_Mod.Get_Gloves_Data(Key)
	if(Key == nil or Gloves_Data[Key] == nil)then
		return Gloves_Data
	else
		return Gloves_Data[Key]
	end
end

function Clothing_Mod.Get_Shorts_Data(Key)
	if(Key == nil or Shorts_Data[Key] == nil)then
		return Shorts_Data
	else
		return Shorts_Data[Key]
	end
end

function Clothing_Mod.Player_Owns_Gloves_Key(Plr, Key)
	local Owned_Gloves_V = PlayerUtils.GetPlayerVal(Plr, "Owned Gloves")
	if(Owned_Gloves_V ~= nil)then
		local Owned_Gloves_Keys = string.split(Owned_Gloves_V.Value, ",")
		if(Owned_Gloves_Keys ~= nil and table.find(Owned_Gloves_Keys, Key) ~= nil)then
			return true
		end
	end

	return false
end

function Clothing_Mod.Player_Owns_Shorts_Key(Plr, Key)
	local Owned_Shorts_V = PlayerUtils.GetPlayerVal(Plr, "Owned Shorts")
	if(Owned_Shorts_V ~= nil)then
		local Owned_Shorts_Keys = string.split(Owned_Shorts_V.Value, ",")
		if(Owned_Shorts_Keys ~= nil and table.find(Owned_Shorts_Keys, Key) ~= nil)then
			return true
		end
	end

	return false
end

function Clothing_Mod.Give_Player_Gloves(Plr, Key)
	if Gloves_Data[Key] == nil then
		return false
	end
	if Clothing_Mod.Player_Owns_Gloves_Key(Plr, Key) == true then
		return false
	end
	
	local Owned_Gloves_V = PlayerUtils.GetPlayerVal(Plr, "Owned Gloves")
	if(Owned_Gloves_V ~= nil)then
		local Keys = string.split(Owned_Gloves_V.Value, ",")
		Keys[#Keys + 1] = Key
		Owned_Gloves_V.Value = table.concat(Keys, ",")
	end
end

function Clothing_Mod.Give_Player_Shorts(Plr, Key)
	if Shorts_Data[Key] == nil then
		return false
	end
	if Clothing_Mod.Player_Owns_Shorts_Key(Plr, Key) == true then
		return false
	end

	local Owned_Shorts_V = PlayerUtils.GetPlayerVal(Plr, "Owned Shorts")
	if(Owned_Shorts_V ~= nil)then
		local Keys = string.split(Owned_Shorts_V.Value, ",")
		Keys[#Keys + 1] = Key
		Owned_Shorts_V.Value = table.concat(Keys, ",")
	end
end

function Clothing_Mod.Get_Player_Current_Shorts(Plr)
	local Current_Shorts_V = PlayerUtils.GetPlayerVal(Plr, "Current Shorts")
	if(Current_Shorts_V ~= nil)then
		local Key = Current_Shorts_V.Value
		if(Key ~= nil and Shorts_Data[Key] ~= nil and Shorts_F:FindFirstChild(Shorts_Data[Key]) ~= nil)then
			return Key, Shorts_F:FindFirstChild(Shorts_Data[Key])
		end
	end
	
	return "A", Shorts_F:FindFirstChild(Shorts_Data['A'])
end

function Clothing_Mod.Get_Player_Current_Gloves(Plr)
	local Current_Gloves_V = PlayerUtils.GetPlayerVal(Plr, "Current Gloves")
	if(Current_Gloves_V ~= nil)then
		local Key = Current_Gloves_V.Value
		if(Key ~= nil and Gloves_Data[Key] ~= nil and Gloves_F:FindFirstChild(Gloves_Data[Key]) ~= nil)then
			return Key, Gloves_F:FindFirstChild(Gloves_Data[Key])
		end
	end

	return "A", Gloves_F:FindFirstChild(Gloves_Data['A'])
end

return Clothing_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{7BD4FF5B-E0CB-423E-A752-FEE575B36D06}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Clothing_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX666986149B2B4A4B90CBBF8606DC2606">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Country_Mod.lua
--
--  Description:
--      Provides country and flag data for players. Maps country names
--      to flag asset IDs and numerical indices, with helper functions
--      for retrieving player flag data and performing conversions.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Script children:
--          * Flags (contains Decals with Texture & Map_Index attribute)
--      - Player Instances:
--          * Player.Player_Data.Country
--
--  Notes:
--      - Hardcoded asset IDs for several countries (USA, France, Japan, etc.)
--      - Additional countries loaded dynamically from Flags folder
--      - Provides conversion functions between country names and indices
--      - Defaults to "United States" if invalid country key
--
--======================================================================


local Country_Mod = {}

local Country_Data = {
	--['USA'] = "rbxassetid://14010864446",
	--['Canada'] = "rbxassetid://12503880000",
	--['Mexico'] = "rbxassetid://116338470092166",
	--['France'] = "rbxassetid://12690378646",
	--['Brazil'] = "rbxassetid://17220320205",
	--['Japan'] = "rbxassetid://17041741932",
	--['Poland'] = "rbxassetid://7412759429",
	--['New Zealand'] = "rbxassetid://17357309517",
	--['Moldova'] = "rbxassetid://12895193469",
	--['Georgia'] = "rbxassetid://128636032248868",
	--['Russia'] = "rbxassetid://6514161028",
	--['China'] = "rbxassetid://9110900644",
	--['UK'] = "rbxassetid://119841021475023",
	--['Australia'] = "rbxassetid://18386599365",
	--['Nigeria'] = "rbxassetid://11858119964",
	--['Jamaica'] = "rbxassetid://128621555589394",
	--['Italy'] = "rbxassetid://10333104535",
	--['Spain'] = "rbxassetid://6600099878",
	--['Argentina'] = "rbxassetid://119836429792081",
	--['Chile'] = "rbxassetid://17366784440",
	--['Portugal'] = "rbxassetid://13721042005",
	--['Ireland'] = "rbxassetid://12511955654"
}
local Country_Number_Map = {}

local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

for i, v in pairs(script.Flags:GetChildren()) do
	Country_Data[v.Name] = v.Texture
	Country_Number_Map[v.Name] = tonumber(v:GetAttribute("Map_Index"))
	if v:GetAttribute("Map_Index") == nil then
		error("No Map_Index property assigned")
	end
end

local function Get_Flag_ID(Country_Key)
	local Img = Country_Data[Country_Key]
	if(Img ~= nil)then
		return Img
	end
	
	return Country_Data['United States']
end

function Country_Mod.Get_Player_Country_Data(Plr)
	local Flag_Key = PlayerUtils.GetPlayerVal(Plr, "Country")
	if(Flag_Key ~= nil and Country_Data[Flag_Key.Value] ~= nil)then
		local Key = Flag_Key.Value
		return Key, Country_Data[Key]
	end
	
	return "United States", Country_Data['United States']
end

function Country_Mod.Get_Flag_ID(Country_Key)
	if(Country_Data[Country_Key] ~= nil) then
		return Country_Data[Country_Key]
	end
	return Country_Data['United States']
end

function Country_Mod.Get_Country_Data()
	return Country_Data
end

function Country_Mod.Get_Country_Number_From_Index(index)
	return Country_Number_Map[index]
end

function Country_Mod.Get_Country_Index_From_Number(number)
	for i, v in pairs(Country_Number_Map) do
		if v == number then
			return i
		end
	end
end

return Country_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{CD600C78-F952-420E-A0AF-CAD01C53AAED}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Country_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDBF237F3CD444009BC9B0B5AD0B4CB2D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Crate_Mod.lua
--
--  Description:
--      Defines crate data for the in-game shop. Each crate specifies
--      its name, reward type, price, UI color, and contained items
--      with rarity and links to Clothing_Mod keys.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Clothing_Mod (for ItemKey references)
--
--  Notes:
--      - Crate_Data maps crate IDs ("Crate 1", "Crate 2", etc.)
--      - Each crate has:
--          * Name (display name)
--          * RewardType ("Gloves" or "Shorts")
--          * PriceCoins / PriceGems
--          * Color_BG (UI background color)
--          * Items (Name, Rarity, ItemKey from Clothing_Mod)
--      - Rarities follow scheme: Bronze (7/10), Silver (3/20),
--        Gold (1/10), Diamond (1/100), Platinum (1/1000)
--      - Used by Shop_Handle to validate and roll crate rewards
--
--======================================================================


local Crate_Mod = {}

-- Unified rarity color table 
local RARITY_COLORS = {
	Platinum = Color3.fromRGB(255,170,255),
	Special  = Color3.fromRGB(255,170,255),
	Diamond  = Color3.fromRGB(150,255,255),
	Gold     = Color3.fromRGB(255,215,0),
	Silver   = Color3.fromRGB(217,217,217),
	Bronze   = Color3.fromRGB(196,124,57),
	Default  = Color3.fromRGB(255,255,255),
	Common   = Color3.fromRGB(255,255,255)
}

local Crate_Data = {
	--// rarity: Bronze = 7/10, Silver = 3/20, Gold = 1/10, Diamond = 1/100, Platinum = 1,1000
	
	['Crate 1'] = {
		['Name'] = "Basic Gloves Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 800, 
		['PriceGems'] = 40,
		["Color_BG"] = RARITY_COLORS.Gold, 
		['Items'] = {
			["A"] = {
				["Name"] = "Blue Gloves", 
				["Rarity"] = 7/10,

				["ItemKey"] = "I"
			},
			["B"] = {
				["Name"] = "Green Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "J"
			},
			["C"] = {
				["Name"] = "White Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "H1"
			},
			["D"] = {
				["Name"] = "Purple Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "L"
			},
			["E"] = {
				["Name"] = "Orange Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "G1"
			},
			["F"] = {
				["Name"] = "Chromatic Green Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "A2"
			},
			["G"] = {
				["Name"] = "Chromatic Blue Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "B2"
			},
			["H"] = {
				["Name"] = "Chromatic Pink Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "C2"
			},
		}
	},
	
	['Crate 2'] = {
		['Name'] = "Basic Shorts Crate",
		['RewardType'] = "Shorts",

		['PriceCoins'] = 1000, 
		['PriceGems'] = 50,
		["Color_BG"] = RARITY_COLORS.Diamond, 
		['Items'] = {
			["A"] = {
				["Name"] = "Karate Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "B"
			},
			["B"] = {
				["Name"] = "Denim",
				["Rarity"] = 0.15,

				["ItemKey"] = "C"
			},
			["C"] = {
				["Name"] = "Dragon Gold",
				["Rarity"] = 1/100,

				["ItemKey"] = "D"
			},
			["D"] = {
				["Name"] = "Black Champs",
				["Rarity"] = 7/10,

				["ItemKey"] = "E"
			},
			["E"] = {
				["Name"] = "Mystic Shorts",
				["Rarity"] = 1/10,

				["ItemKey"] = "T"
			},
		}
	},
	
	['Crate 3'] = {
		['Name'] = "Underground Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 2000, 
		['PriceGems'] = 100,
		["Color_BG"] = RARITY_COLORS.Platinum, 
		['Items'] = {
			["A"] = {
				["Name"] = "Plastic Green Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "U1"
			},
			["B"] = {
				["Name"] = "Plastic Blue Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "V1"
			},
			["C"] = {
				["Name"] = "Plastic Pink Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "W1"
			},
			["D"] = {
				["Name"] = "Blue Flame Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "X1"
			},
			["E"] = {
				["Name"] = "Lava Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "Y1"
			},
			["F"] = {
				["Name"] = "Carbon Gloves",
				["Rarity"] = 1/10000,

				["ItemKey"] = "Z1"
			},
			["G"] = {
				["Name"] = "Chromatic Green Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "A2"
			},
			["H"] = {
				["Name"] = "Chromatic Blue Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "B2"
			},
		}
	},
	
	['Crate 4'] = {
		['Name'] = "Tape Crate", --// Crates Name
		['RewardType'] = "Gloves",

		['PriceCoins'] = 600, -- Price in cash
		['PriceGems'] = 30, -- Price in gems
		["Color_BG"] = RARITY_COLORS.Common, -- background color for the crate display UI 
		['Items'] = { --// Only 8 items Per Crate Max
			["A"] = {
				["Name"] = "Black Tape", --// Item name same as listed in Clothing_Mod
				["Rarity"] = 7/10, --// Item Rarity

				["ItemKey"] = "B"
			},
			["B"] = {
				["Name"] = "Blue Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "C"
			},
			["C"] = {
				["Name"] = "Green Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "D"
			},
			["D"] = {
				["Name"] = "Red Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "E"
			},
			["E"] = {
				["Name"] = "Tan Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "F"
			},
			["F"] = {
				["Name"] = "White Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "G"
			},
			["G"] = {
				["Name"] = "Purple Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "H"
			},
			["H"] = {
				["Name"] = "Plastic Green Tape",
				["Rarity"] = 7/10,
				["ItemKey"] = "O1"
			}
		}
	},
	
	['Crate 5'] = {
		['Name'] = "Urban Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 1000, 
		['PriceGems'] = 50,
		["Color_BG"] = RARITY_COLORS.Diamond, 
		['Items'] = {
			["A"] = {
				["Name"] = "Graffiti Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "I1"
			},
			["B"] = {
				["Name"] = "Iron Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "J1"
			},
			["C"] = {
				["Name"] = "Gold Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "K1"
			},
			["D"] = {
				["Name"] = "Corrupted Purple Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "L1"
			},
			["E"] = {
				["Name"] = "Corrupted Green Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "M1"
			},
			["F"] = {
				["Name"] = "Corrupted Black Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "N1"
			},
		}
	},

	['Crate 6'] = {
		['Name'] = "Fury Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 2000, 
		['PriceGems'] = 100,
		["Color_BG"] = RARITY_COLORS.Platinum, 
		['Items'] = {
			["A"] = {
				["Name"] = "Fury Gloves",
				["Rarity"] = 1/10000,
				["ItemKey"] = "G2"
			},
			["B"] = {
				["Name"] = "Plastic Blue Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "P1"
			},
			["C"] = {
				["Name"] = "Plastic Pink Tape",
				["Rarity"] = 1/10,

				["ItemKey"] = "Q1"
			},
			["D"] = {
				["Name"] = "Frozen Chain Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "R1"
			},
			["E"] = {
				["Name"] = "Molten Chain Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "S1"
			},
			["F"] = {
				["Name"] = "Carbon Chain Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "T1"
			},
			["H"] = {
				["Name"] = "Chromatic Pink Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "F2"
			},
		}
	},
	
	['Crate 7'] = {
		['Name'] = "Prime Gloves Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 800,
		['PriceGems'] = 40,
		["Color_BG"] = RARITY_COLORS.Gold,

		['Items'] = {
			["A"] = { ["Name"] = "Blue Gloves",              ["Rarity"] = 7/10,  ["ItemKey"] = "I" },
			["B"] = { ["Name"] = "Green Gloves",             ["Rarity"] = 7/10,  ["ItemKey"] = "J" },
			["C"] = { ["Name"] = "White Gloves",             ["Rarity"] = 7/10,  ["ItemKey"] = "H1" },
			["D"] = { ["Name"] = "Purple Gloves",            ["Rarity"] = 7/10,  ["ItemKey"] = "L" },
			["E"] = { ["Name"] = "Orange Gloves",            ["Rarity"] = 7/10,  ["ItemKey"] = "G1" },
			["F"] = { ["Name"] = "Gold Gloves",              ["Rarity"] = 1/10,  ["ItemKey"] = "K1" },
			["G"] = { ["Name"] = "Chromatic Green Gloves",   ["Rarity"] = 1/10,  ["ItemKey"] = "A2" },
			["H"] = { ["Name"] = "Chromatic Blue Gloves",    ["Rarity"] = 1/10,  ["ItemKey"] = "B2" },
		}
	},
	
	
	['Crate 8'] = {
		['Name'] = "Vanguard Crate",
		['RewardType'] = "Shorts",

		['PriceCoins'] = 1000,
		['PriceGems'] = 50,
		["Color_BG"] = RARITY_COLORS.Diamond,

		['Items'] = {
			["A"] = { ["Name"] = "Dragon Gold",      ["Rarity"] = 1/100,   ["ItemKey"] = "D" },
			["B"] = { ["Name"] = "Corrupted Purple Gloves", ["Rarity"] = 1/100, ["ItemKey"] = "L1"},
			["C"] = { ["Name"] = "Corrupted Green Gloves", ["Rarity"] = 1/100,["ItemKey"] = "M1"},
			["D"] = { ["Name"] = "Corrupted Black Gloves", ["Rarity"] = 1/100,["ItemKey"] = "N1"},
			["E"] = { ["Name"] = "Plastic Pink Tape", ["Rarity"] = 1/10, ["ItemKey"] = "Q1"},
			["F"] = { ["Name"] = "Mystic Shorts",    ["Rarity"] = 1/10,    ["ItemKey"] = "T" },
			["G"] = { ["Name"] = "Plastic Blue Tape", ["Rarity"] = 7/10, ["ItemKey"] = "P1"	},
			["H"] = { ["Name"] = "Graffiti Gloves", ["Rarity"] = 7/10, ["ItemKey"] = "I1"},
		}
	},

	['Crate 9'] = {
		['Name'] = "Blaze Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 2000,
		['PriceGems'] = 100,
		["Color_BG"] = RARITY_COLORS.Platinum,

		['Items'] = {
			["A"] = { ["Name"] = "Iron Gloves",               ["Rarity"] = 7/10,     ["ItemKey"] = "J1" },
			["B"] = { ["Name"] = "Graffiti Gloves",           ["Rarity"] = 7/10,     ["ItemKey"] = "I1" },
			["C"] = { ["Name"] = "Purple Gloves",             ["Rarity"] = 7/10,     ["ItemKey"] = "L" },
			["D"] = { ["Name"] = "Corrupted Green Gloves",    ["Rarity"] = 1/10,     ["ItemKey"] = "M1" },
			["E"] = { ["Name"] = "Corrupted Black Gloves",    ["Rarity"] = 1/10,     ["ItemKey"] = "N1" },
			["F"] = { ["Name"] = "Carbon Gloves",             ["Rarity"] = 1/10000,  ["ItemKey"] = "Z1" },
			["G"] = { ["Name"] = "Blue Flame Gloves",         ["Rarity"] = 1/100,    ["ItemKey"] = "X1" },
			["H"] = { ["Name"] = "Lava Gloves",               ["Rarity"] = 1/100,    ["ItemKey"] = "Y1" },
		}
	},


	--['Crate 7'] = {
	--	['Name'] = "Gold Gloves Crate",
	--	['RewardType'] = "Gloves",

	--	['PriceCoins'] = 800,
	--	['PriceGems'] = 40,
	--	["Color_BG"] = RARITY_COLORS.Gold,

	--	['Items'] = {
	--		["A"] = { ["Name"] = "Blue Gloves",  ["Rarity"] = 0.12, ["ItemKey"] = "I" },
	--		["B"] = { ["Name"] = "Green Gloves", ["Rarity"] = 0.12, ["ItemKey"] = "J" },
	--		["C"] = { ["Name"] = "White Gloves", ["Rarity"] = 0.12, ["ItemKey"] = "H1" },
	--		["D"] = { ["Name"] = "Purple Gloves", ["Rarity"] = 0.12, ["ItemKey"] = "L" },
	--		["E"] = { ["Name"] = "Orange Gloves", ["Rarity"] = 0.12, ["ItemKey"] = "G1" },

	--		-- Gold rarity (min 2)
	--		["F"] = { ["Name"] = "Gold Gloves",             ["Rarity"] = 0.13, ["ItemKey"] = "K1" },
	--		["G"] = { ["Name"] = "Chromatic Green Gloves",  ["Rarity"] = 0.13, ["ItemKey"] = "A2" },
	--		["H"] = { ["Name"] = "Chromatic Blue Gloves",   ["Rarity"] = 0.13, ["ItemKey"] = "B2" },
	--	}
	--},


	--['Crate 8'] = {
	--	['Name'] = "Diamond Shorts Crate",
	--	['RewardType'] = "Shorts",

	--	['PriceCoins'] = 1000,
	--	['PriceGems'] = 50,
	--	["Color_BG"] = RARITY_COLORS.Diamond,

	--	['Items'] = {
	--		["A"] = { ["Name"] = "Karate Shorts",  ["Rarity"] = 0.1525, ["ItemKey"] = "B" },
	--		["B"] = { ["Name"] = "Denim",          ["Rarity"] = 0.1525, ["ItemKey"] = "C" },
	--		["C"] = { ["Name"] = "Black Champs",   ["Rarity"] = 0.1525, ["ItemKey"] = "E" },
	--		["D"] = { ["Name"] = "French Shorts",  ["Rarity"] = 0.1525, ["ItemKey"] = "M" },

	--		["E"] = { ["Name"] = "Mystic Shorts",  ["Rarity"] = 0.1125, ["ItemKey"] = "T" },

	--		["F"] = { ["Name"] = "Dragon Gold",     ["Rarity"] = 0.0925, ["ItemKey"] = "D" },
	--		["G"] = { ["Name"] = "Spanish Shorts",  ["Rarity"] = 0.0925, ["ItemKey"] = "Y" },
	--		["H"] = { ["Name"] = "Polish Shorts",   ["Rarity"] = 0.0925, ["ItemKey"] = "W" },
	--	}
	--},

	--['Crate 9'] = {
	--	['Name'] = "Platinum Gloves Crate",
	--	['RewardType'] = "Gloves",

	--	['PriceCoins'] = 2000,
	--	['PriceGems'] = 100,
	--	["Color_BG"] = RARITY_COLORS.Platinum,

	--	['Items'] = {
	--		["A"] = { ["Name"] = "Iron Gloves",       ["Rarity"] = 0.1626, ["ItemKey"] = "J1" },
	--		["B"] = { ["Name"] = "Graffiti Gloves",   ["Rarity"] = 0.1626, ["ItemKey"] = "I1" },
	--		["C"] = { ["Name"] = "Purple Gloves",     ["Rarity"] = 0.1626, ["ItemKey"] = "L" },

	--		["D"] = { ["Name"] = "Corrupted Green Gloves", ["Rarity"] = 0.1126, ["ItemKey"] = "M1" },
	--		["E"] = { ["Name"] = "Corrupted Black Gloves", ["Rarity"] = 0.1126, ["ItemKey"] = "N1" },

	--		["F"] = { ["Name"] = "Carbon Gloves",    ["Rarity"] = 0.0959, ["ItemKey"] = "Z1" },
	--		["G"] = { ["Name"] = "Blue Flame Gloves",["Rarity"] = 0.0959, ["ItemKey"] = "X1" },
	--		["H"] = { ["Name"] = "Lava Gloves",      ["Rarity"] = 0.0959, ["ItemKey"] = "Y1" },
	--	}
	--},
	--['Crate 7'] = { -- // COUNTRY GLOVES #1
	--	['Name'] = "Country Gloves 1",
	--	['RewardType'] = "Gloves",

	--	['PriceCoins'] = 600, 
	--	['PriceGems'] = 30,
	--	["Color_BG"] = RARITY_COLORS.Common, 
	--	['Items'] = {
	--		["A"] = {
	--			["Name"] = "Argentinian Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "M"
	--		},
	--		["B"] = {
	--			["Name"] = "Australian Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "N"
	--		},
	--		["C"] = {
	--			["Name"] = "Brazilian Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "O"
	--		},
	--		["D"] = {
	--			["Name"] = "Canadian Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "P"
	--		},
	--		["E"] = {
	--			["Name"] = "Chilean Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "Q"
	--		},
	--		["F"] = {
	--			["Name"] = "Chinese Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "R"
	--		},
	--		["G"] = {
	--			["Name"] = "English Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "S"
	--		}			
	--	}
	--},
	
	--['Crate 8'] = { -- // COUNTRY GLOVES #2
	--	['Name'] = "Country Gloves 2",
	--	['RewardType'] = "Gloves",

	--	['PriceCoins'] = 600, 
	--	['PriceGems'] = 30,
	--	["Color_BG"] = RARITY_COLORS.Common, 
	--	['Items'] = {
	--		["A"] = {
	--			["Name"] = "French Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "T"
	--		},
	--		["B"] = {
	--			["Name"] = "Georgian Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "U"
	--		},
	--		["C"] = {
	--			["Name"] = "Italian Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "V"
	--		},
	--		["D"] = {
	--			["Name"] = "Jamacian Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "W"
	--		},
	--		["E"] = {
	--			["Name"] = "Japanese Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "X"
	--		},
	--		["F"] = {
	--			["Name"] = "Mexican Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "Y"
	--		},
	--		["G"] = {
	--			["Name"] = "Moldovan Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "Z"
	--		},
	--	}
	--},
	
	--['Crate 9'] = { -- // COUNTRY GLOVES #3
	--	['Name'] = "Country Gloves 3",
	--	['RewardType'] = "Gloves",

	--	['PriceCoins'] = 600, 
	--	['PriceGems'] = 30,
	--	["Color_BG"] = RARITY_COLORS.Common, 
	--	['Items'] = {
	--		["A"] = {
	--			["Name"] = "Nigerian Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "A1"
	--		},
	--		["B"] = {
	--			["Name"] = "Polish Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "B1"
	--		},
	--		["C"] = {
	--			["Name"] = "New Zealand Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "C1"
	--		},
	--		["D"] = {
	--			["Name"] = "Russian Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "D1"
	--		},
	--		["E"] = {
	--			["Name"] = "Spanish Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "E1"
	--		},
	--		["F"] = {
	--			["Name"] = "USA Gloves",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "F1"
	--		},
	--	}
	--},
	
	--['Crate 10'] = { -- // COUNTRY SHORTS #1
	--	['Name'] = "Country Shorts 1",
	--	['RewardType'] = "Shorts",

	--	['PriceCoins'] = 600, 
	--	['PriceGems'] = 30,
	--	["Color_BG"] = RARITY_COLORS.Common, 
	--	['Items'] = {
	--		["A"] = {
	--			["Name"] = "Argentinian Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "F"
	--		},
	--		["B"] = {
	--			["Name"] = "Australian Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "G"
	--		},
	--		["C"] = {
	--			["Name"] = "Brazilian Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "H"
	--		},
	--		["D"] = {
	--			["Name"] = "Canadian Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "I"
	--		},
	--		["E"] = {
	--			["Name"] = "Chilean Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "J"
	--		},
	--		["F"] = {
	--			["Name"] = "Chinese Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "K"
	--		},
	--		["G"] = {
	--			["Name"] = "England Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "L"
	--		},
	--	}
	--},
	
	--['Crate 11'] = { -- // COUNTRY SHORTS #2
	--	['Name'] = "Country Shorts 2",
	--	['RewardType'] = "Shorts",

	--	['PriceCoins'] = 600, 
	--	['PriceGems'] = 30,
	--	["Color_BG"] = RARITY_COLORS.Common, 
	--	['Items'] = {
	--		["A"] = {
	--			["Name"] = "French Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "M"
	--		},
	--		["B"] = {
	--			["Name"] = "Georgian Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "N"
	--		},
	--		["C"] = {
	--			["Name"] = "Italian Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "O"
	--		},
	--		["D"] = {
	--			["Name"] = "Jamaican Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "P"
	--		},
	--		["E"] = {
	--			["Name"] = "Japanese Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "Q"
	--		},
	--		["F"] = {
	--			["Name"] = "Mexican Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "R"
	--		},
	--		["G"] = {
	--			["Name"] = "Moldovan Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "S"
	--		},
	--	}
	--},
	
	--['Crate 12'] = { -- // COUNTRY SHORTS #3
	--	['Name'] = "Country Shorts 3",
	--	['RewardType'] = "Shorts",

	--	['PriceCoins'] = 600, 
	--	['PriceGems'] = 30,
	--	["Color_BG"] = RARITY_COLORS.Common, 
	--	['Items'] = {
	--		["A"] = {
	--			["Name"] = "New Zealand Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "U"
	--		},
	--		["B"] = {
	--			["Name"] = "Nigerian Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "V"
	--		},
	--		["C"] = {
	--			["Name"] = "Polish Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "W"
	--		},
	--		["D"] = {
	--			["Name"] = "Russian Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "X"
	--		},
	--		["E"] = {
	--			["Name"] = "Spanish Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "Y"
	--		},
	--		["F"] = {
	--			["Name"] = "USA Shorts",
	--			["Rarity"] = 7/10,

	--			["ItemKey"] = "Z"
	--		},
	--	}
	--},

}

function Crate_Mod.GetCrates()
	return Crate_Data
end

function Crate_Mod.Get_Crate_Data_Arr()
	local Arr = {}
	
	for Crate_Key, Data in next, Crate_Data do
		local D = Data
		local Index_Str = string.gsub(Crate_Key, "Crate ", "")
		D['Index'] = tonumber(Index_Str)
		
		table.insert(Arr, D)
	end
	
	table.sort(Arr, function(A, B)
		return A['Index'] < B['Index']
	end)
	
	return Arr
end

return Crate_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{2A9A3F11-D201-441E-B1EF-017944961BB1}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Crate_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX24FAAB18872147C4977DDA22DFB9F92A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Rewards_Mod.lua
--
--  Description:
--      Centralized reward system. Handles both:
--        * Daily retention rewards (7-day cycle)
--        * Session playtime rewards (time thresholds)
--      Provides helper functions to query reward data, player streaks,
--      and claimed rewards. Designed for use in reward UIs and server
--      handles (Codes_Handle, Session_Reward_Handle, etc.).
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Player Instances:
--          * Player.Player_Data.Retention Streak
--          * Player.Player_Data.Redeemed Rewards
--          * Player.Player_Data.SR_Day
--          * Player.Player_Data.SR_Count
--          * Player.Player_Data.SR_ClaimedTimes
--
--  Notes:
--      - Daily_Rewards_Data (7-day cycle):
--          * Day 1: +100 Cash
--          * Day 2: +10 Gems
--          * Day 3: Free Crate 1
--          * Day 4: +300 Cash
--          * Day 5: +25 Gems
--          * Day 6: +450 Cash
--          * Day 7: VIP Gamepass (Key "A")
--        funcs:
--          * Get_Specific_Daily_Reward(Key)
--          * Get_Player_Retention_Streak(Plr)
--          * Get_Claimed_Daily_Player_Rewards(Plr)
--          * Get_Total_Reward_Amount()
--
--      - Session_Rewards_Data (time thresholds):
--          * 10 min: +200 Coins
--          * 15 min: +350 Coins
--          * 21 min: +20 Gems
--          * 30 min: +40 Gems
--        funcs:
--          * Get_Max_Session_Claims()
--          * Get_Session_Reward(Index)
--
--      - Used by:
--          * Codes_Handle (daily codes integration)
--          * Session_Reward_Handle (session playtime tracking)
--          * Reward UIs (Daily / Session)
--
--======================================================================

local Rewards_Mod = {}

local Daily_Rewards_Data = {
	[1] = {
		['Name'] = "+100 Cash!",
		['Type'] = "Cash",
		['Amount'] = 100
	},
	
	[2] = {
		['Name'] = "+10 Gems!",
		['Type'] = "Gems",
		['Amount'] = 10
	},
	
	[3] = {
		['Name'] = "FREE Crate!",
		['Type'] = "Crate",
		['Amount'] = "Crate 1"
	},
	
	[4] = {
		['Name'] = "+300 Cash!",
		['Type'] = "Cash",
		['Amount'] = 300
	},
	
	[5] = {
		['Name'] = "+25 Gems!",
		['Type'] = "Gems",
		['Amount'] = 25
	},
	
	[6] = {
		['Name'] = "+450 Cash!",
		['Type'] = "Cash",
		['Amount'] = 450
	},
	
	[7] = {
		['Name'] = "VIP!",
		['Type'] = "Gamepass",
		['Amount'] = "A"
	},
	
	
	
}

local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

function Rewards_Mod.Get_Specific_Daily_Reward(Key)
	return Daily_Rewards_Data[Key]
end

function Rewards_Mod.Get_Player_Retention_Streak(Plr)
	local Streak = PlayerUtils.GetPlayerVal(Plr, "Retention Streak")
	if(Streak ~= nil) then
		return Streak.Value
	end
	return 0
end

function Rewards_Mod.Get_Claimed_Daily_Player_Rewards(Plr)
	local Keys_Str = PlayerUtils.GetPlayerVal(Plr, "Redeemed Rewards")
	if(Keys_Str ~= nil)then
		return string.split(Keys_Str.Value, ",")
	end
	return {}
end

function Rewards_Mod.Get_Total_Reward_Amount()
	local Data_Arr = {}
	for Key, Reward_Data in next, Daily_Rewards_Data do
		table.insert(Data_Arr, Reward_Data)
	end
	return #Data_Arr
end

----------------------------------------------------------------------
-- Session Rewards
----------------------------------------------------------------------

local UNIT = 60 -- seconds in one minute

Rewards_Mod.Session_SeasonId = 1
Rewards_Mod.Session_Rewards_Data = {
	--{ t = 15, reward = { type="Coins", amount=666, label="Test" } },
	{ t = 10*UNIT, reward = { type="Coins", amount=200, label="Stay 10 minutes: +200 💵" } },
	{ t = 15*UNIT, reward = { type="Coins", amount=350, label="Stay 15 minutes: +350 💵" } },
	{ t = 21*UNIT, reward = { type="Coins", amount=450, label="Stay 21 minutes: +450 💵" } },
	{ t = 30*UNIT, reward = { type="Gems", amount=1000, label="Stay 30 minutes: +1000 💵" } },
}

function Rewards_Mod.Get_Max_Session_Claims()
	return #Rewards_Mod.Session_Rewards_Data
end

function Rewards_Mod.Get_Session_Reward(Index)
	if Index >= 1 and Index <= #Rewards_Mod.Session_Rewards_Data then
		return Rewards_Mod.Session_Rewards_Data[Index].reward
	end
	return nil
end

----------------------------------------------------------------------
-- Gym Reward Event Config
----------------------------------------------------------------------

Rewards_Mod.Gym_Rewards_Messages_Color = Color3.fromRGB(255, 208, 21)
Rewards_Mod.Gym_Rewards_TimeFrame = 5 -- 5 minutes
Rewards_Mod.Gym_Rewards_Duration = 15 -- 15 secondes
Rewards_Mod.Gym_Rewards_Data = {
	{Event_Start_Hour =  18  , reward = { type="Coins", amount=500, label="+500 💵" }},
	{Event_Start_Hour =  19  , reward = { type="Coins", amount=500, label="+500 💵" }},
	{Event_Start_Hour =  20  , reward = { type="Coins", amount=500, label="+500 💵" }},
	{Event_Start_Hour =  21  , reward = { type="Coins", amount=500, label="+500 💵" }},
	{Event_Start_Hour =  22  , reward = { type="Coins", amount=500, label="+500 💵" }}
}

return Rewards_Mod]]></ProtectedString>
						<string name="ScriptGuid">{251F710B-7F81-4B9A-9E85-3502EBBCB114}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Rewards_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB577211B40EE426AAFA7DE93D24131D5">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[
--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Skin_Tone_Mod.lua
--
--  Description:
--      Defines available skin tone colors and provides helper functions
--      to convert between Color3 and string representations ("R,G,B").
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox:
--          * Color3
--          * math.clamp
--          * string.split
--
--  Notes:
--      - Skin_Tone_Data includes:
--          * Dark taupe, Brown, Linen, Nougat, Light orange,
--            Medium brown, Reddish brown, Cork, Burlap, Brick yellow
--      - funcs API:
--          * Get_Skin_Tone_Data(): returns full tone table
--          * Configure_Skin_Tone(Color3): to "R,G,B" string
--          * Configure_To_Color("R,G,B"): back to Color3
--      - Invalid strings fallback to Color3.fromRGB(255,255,255)
--
--======================================================================


local Skin_Tone_Mod = {}

local Skin_Tone_Data = {
	['Dark taupe'] = Color3.fromRGB(90, 76, 66),
	['Brown'] = Color3.fromRGB(124, 92, 70),
	['Linen'] = Color3.fromRGB(175, 148, 131),
	['Nougat'] = Color3.fromRGB(204, 142, 105),
	['Light orange'] = Color3.fromRGB(234, 184, 146),
	['Medium brown'] = Color3.fromRGB(86, 66, 54),
	['Reddish brown'] = Color3.fromRGB(105, 64, 40),
	['Cork'] = Color3.fromRGB(188, 155, 93),
	['Burlap'] = Color3.fromRGB(199, 172, 120),
	['Brick yellow'] = Color3.fromRGB(215, 197, 154),
}

function Skin_Tone_Mod.Get_Skin_Tone_Data()
	return Skin_Tone_Data
end

function Skin_Tone_Mod.Configure_Skin_Tone(Col)
	local R, G, B = Col.R, Col.G, Col.B
	R = math.clamp(R, 0, 255)
	G = math.clamp(G, 0, 255)
	B = math.clamp(B, 0, 255)
	
	return R .. "," .. G .. "," .. B
end

function Skin_Tone_Mod.Configure_To_Color(Col_Str)
	local Str_Data = string.split(Col_Str, ",")
	if(Str_Data ~= nil and #Str_Data >= 3)then
		local R = tonumber(Str_Data[1])
		local G = tonumber(Str_Data[2])
		local B = tonumber(Str_Data[3])
		
		R = math.clamp(R, 0, 255)
		G = math.clamp(G, 0, 255)
		B = math.clamp(B, 0, 255)
		
		return Color3.fromRGB(R, G, B)
	end
	
	return Color3.fromRGB(255, 255, 255)
end

return Skin_Tone_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{F749A5E9-866F-4479-817F-7C4A0036E86B}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Skin_Tone_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF2982C680A774153BB8B31CCDA8E4035">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Skill_Tree_Mod.lua
--
--  Description:
--      Defines milestone-based rewards linked to player progression
--      stats such as wins, knockouts, submissions, and total playtime.
--      Provides structured reward tables consumed by progression and
--      achievement systems.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage/Data_Mods_F:
--          * Crate_Mod (for crate rewards)
--          * Monetization_Mod (for Cash Pack rewards)
--      - Core_Fight_Handle (for Ranked Move unlocks)
--
--  Notes:
--      - Key_Index: {"Total Wins", "Ranked Wins", "Punch Knockout Wins",
--                   "Leg Knockout Wins", "Submissions Wins", "Total Playtime"}
--      - Rewards_Data categories:
--          * Wins: Cash, Gems, Crates, Cash Packs, Ranked Moves
--          * Knockouts: Gems, Cash, Crates, Cash Packs, Ranked Moves
--          * Submissions: Gems, Crates, Ranked Moves, Packs
--          * Playtime: Cash, Gems, Crates
--      - Each reward entry includes:
--          * Reward (type)
--          * Amount (number or key string)
--          * Text (UI message string)
--      - Used by progression/achievement systems to grant milestone rewards
--
--======================================================================

local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

local Skill_Tree_Mod = {}

--[[
	- Cash, Gems, Cash, Gems, Cash Pack, Gems Pack, Crate, Cash Pack, Crate, Gems Pack
	- Gems, Cash, Crate, Cash Pack, Ranked Move, Gems Pack, Ranked Move, Crate 
	
	* General Wins
	- 1 Win | 5 Wins | 10 Wins | 25 Wins | 50 Wins | 100 Wins | 250 Wins | 500 Wins | 1,000 Wins | 2,500 Wins
	
	* Ranked Wins
	- 1 Win | 3 Wins | 5 Wins | 10 Wins | 15 Wins | 25 Wins | 35 Wins | 50 Wins | 75 Wins | 100 Wins
	
	* Punch Knockouts
	- 5 KO's | 10 KO's | 15 KO's | 25 KO's | 50 KO's | 75 KO's | 125 KO's | 250 KO's 
	
	* Leg Knockouts
	- 5 KO's | 10 KO's | 15 KO's | 25 KO's | 50 KO's | 75 KO's | 125 KO's | 250 KO's 
	
	* Submission KOs
	- 1 KO's | 3 KO's | 5 KO's | 10 KO's | 15 KO's | 25 KO's | 50 KO's | 100 KO's
]]--

local Key_Index = {"Total Wins", "Ranked Wins", "Punch Knockout Wins", "Leg Knockout Wins", "Submissions Wins", "Total Playtime"}

local Rewards_Data = {
	['Wins'] = {
		{
			['Reward'] = "Cash",
			['Amount'] = 25,
			['Text'] = "💸 Successfully Earned +25 Cash!"
		},

		{
			['Reward'] = "Gems",
			['Amount'] = 10,
			['Text'] = "💎 Successfully Earned +10 Gems!"
		},

		{
			['Reward'] = "Cash",
			['Amount'] = 100,
			['Text'] = "💸 Successfully Earned +100 Cash!"
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "I",
			['Text'] = "💪 Successfully Earned an Exclusive Takedown & Submission Combo!" -- Replace with Strike
		},

		{
			['Reward'] = "Cash Pack",
			['Amount'] = "A",
			['Text'] = "💸 Successfully Earned a Tiny Cash Pack!"
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "",
			['Text'] = "💪 Successfully Earned an Exclusive Takedown & Submission Combo!" -- Replace with Submission
		},

		{
			['Reward'] = "Crate",
			['Amount'] = "Crate 1",
			['Text'] = "🎁 Successfully Earned a FREE Crate!"
		},

		{
			['Reward'] = "Cash Pack",
			['Amount'] = "C",
			['Text'] = "💸 Successfully Earned a Large Cash Pack!"
		},

		{
			['Reward'] = "Crate",
			['Amount'] = "Crate 2",
			['Text'] = "🎁 Successfully Earned a FREE Crate!" 
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "J",
			['Text'] = "💪 Successfully Earned an Exclusive Takedown & Submission Combo!" -- Replace with Strike
		},
	},

	['Knockouts'] = {
		{
			['Reward'] = "Gems",
			['Amount'] = 5,
			['Text'] = "💎 Successfully Earned +5 Gems!"
		},

		{
			['Reward'] = "Cash",
			['Amount'] = 25,
			['Text'] = "💸 Successfully Earned +25 Cash!"
		},

		{
			['Reward'] = "Crate",
			['Amount'] = "Crate 1",
			['Text'] = "🎁 Successfully Earned a FREE Crate!"
		},

		{
			['Reward'] = "Cash Pack",
			['Amount'] = "B",
			['Text'] = "💸 Successfully Earned a Small Cash Pack!"
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "E",
			['Text'] = "💪 Successfully Earned an Exclusive Takedown & Submission Combo!"
		},

		{
			['Reward'] = "Gems",
			['Amount'] = 50,
			['Text'] = "💎 Successfully Earned +50 Gems!"
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "D",
			['Text'] = "💪 Successfully Earned an Exclusive Takedown & Submission Combo!"
		},

		{
			['Reward'] = "Crate",
			['Amount'] = "Crate 2",
			['Text'] = "🎁 Successfully Earned a FREE Crate!"
		},
	}
}

local Skill_Tree_Data = {
	['Total Wins'] = {1, 5, 10, 25, 50, 100, 250, 500, 1000, 2500},
	['Ranked Wins'] = {1, 3, 5, 10, 15, 25, 35, 50, 75, 100},
	['Punch Knockout Wins'] = {5, 10, 15, 25, 50, 75, 125, 250},
	['Leg Knockout Wins'] = {5, 10, 15, 25, 50, 75, 125, 250},
	['Submissions Wins'] = {1, 3, 5, 10, 15, 25, 50, 100},
	['Total Playtime'] = {3600, 7200, 18000, 36000, 180000, 360000, 1800000, 3600000}
}

local function Compile_Skill_Tree_Plr_Data(Plr)
	local Skill_Tree_V = PlayerUtils.GetPlayerVal(Plr, "Redeemed Skill Tree")
	local Owned_Keys = {
		['Total Wins'] = {},
		['Ranked Wins'] = {},
		['Punch Knockout Wins'] = {},
		['Leg Knockout Wins'] = {},
		['Submissions Wins'] = {},
		['Total Playtime'] = {}
	}

	if(Skill_Tree_V ~= nil)then
		local Data_Str = string.split(Skill_Tree_V.Value, ",")

		local function Process_String_Data(Str)
			local Core_Data = string.split(Str, "|")
			if(Core_Data ~= nil and #Core_Data >= 2)then
				local K_Index = tonumber(Core_Data[1])
				local Key = Key_Index[K_Index]
				local Index = tonumber(Core_Data[2])

				table.insert(Owned_Keys[Key], Index)
			end
		end

		for i = 1, #Data_Str do
			local Data = Data_Str[i]
			if(Data ~= nil)then
				Process_String_Data(Data)
			end
		end
	end

	return Owned_Keys
end

function Skill_Tree_Mod.Get_All_Skill_Tree_Data()
	return Skill_Tree_Data, Rewards_Data
end

function Skill_Tree_Mod.Compile_Skill_Tree_Data(Plr)
	return Compile_Skill_Tree_Plr_Data(Plr)
end

function Skill_Tree_Mod.Get_Reward_Data_Arr(Tree_Key)
	if(Skill_Tree_Data[Tree_Key] ~= nil and #Skill_Tree_Data[Tree_Key] == 8) then
		return Rewards_Data['Knockouts']
	else
		return Rewards_Data['Wins']
	end
end

function Skill_Tree_Mod.Verify_Tree_Index(Key, Tree_Index)
	if(Skill_Tree_Data[Key] ~= nil and Skill_Tree_Data[Key][Tree_Index] ~= nil) then
		return true
	end
	return false
end

function Skill_Tree_Mod.Has_Player_Can_Redeemed_Reward(Plr, Key, Tree_Index)
	local Owned_Rewards_Data = Compile_Skill_Tree_Plr_Data(Plr)
	if(Plr ~= nil and Owned_Rewards_Data ~= nil and 
		(#Owned_Rewards_Data <= 0 or table.find(Owned_Rewards_Data, Tree_Index) == nil)) then

		return true
	end
	return false
end

function Skill_Tree_Mod.Player_Has_Met_Requirement(Plr, Key, Tree_Index)
	local Data_Val = PlayerUtils.GetPlayerVal(Plr, Key)
	if(Plr ~= nil and Data_Val ~= nil and Skill_Tree_Data[Key] ~= nil and Skill_Tree_Data[Key][Tree_Index] ~= nil) then
		local Max_Val = tonumber(Skill_Tree_Data[Key][Tree_Index])
		if(Data_Val.Value >= Max_Val)then
			return true
		end
	end

	return false
end

function Skill_Tree_Mod.Get_Redeem_Data_Entry(Key, Tree_Index)
	local Key_Index_Val = table.find(Key_Index, Key) or 1
	return Key_Index_Val .. "|" .. Tree_Index
end

function Skill_Tree_Mod.Get_Reward_Data(Key, Tree_Index)
	if(Key == "Total Wins" or Key == "Ranked Wins") then
		return Rewards_Data["Wins"][Tree_Index]
	else
		return Rewards_Data["Knockouts"][Tree_Index]
	end
end

return Skill_Tree_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{6C6644A7-AC41-47E8-883C-ACA671146E64}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Skill_Tree_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8F2A16E884344A9A90DA810BDB719A0A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Changelog_Mod.lua
--
--  Description:
--      Static changelog module containing version history and feature
--      updates. Provides a list of changes for display in UI elements.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-10-17 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - None
--
--  Notes:
--      - Returns an array of changelog entries
--      - Each entry contains:
--          * version: string identifier (e.g. "CHANGELOG V2025-09-26.X")
--          	* X correspond to the current patch of this version 
--          * changes: array of string bullet points (maximum 8)
--      - Designed for Changelog UI display in-game
--
--======================================================================


return {
	{
		version = "CHANGELOG V2025-12-15",
		changes = {
			"❓ Crazy new Fight Tutorial – jump in and learn faster than ever",
			"🥊 New ELO System – earn few ELO points in standard cages too",
			"⚙️ Fight Outro Customization – personalize your victory animations",
			"🩳 New Gloves & Shorts – Thailand 🇹🇭 / Hungary 🇭🇺 / Spiderman 🕷️",
			"🐞 Bug Fixes – smoother and more secure gameplay"
		}
	},
	{
		version = "CHANGELOG V2025-11-21",
		changes = {
			"🌟 Huge Fight Gameplay enhancement & upgrades",
			"🥊 Now combos strikes have real damage differences",
			"🥊 You can now strike with punch or kick !",
			"⚙️ Customize your fight entrance animations",
			"🩳 Shop UI new look : now you can buy all shorts & gloves"
		}
	},
	{
		version = "CHANGELOG V2025-HALLOWEEN",
		changes = {
			"🎃 Halloween theme 👻",
			"👻 Halloween UGCs : 21 crazy items 🎃",
			"🥊 Fight against 3 Halloween bots 👹",
			"👗 Halloween UGCs Packs ",
			"🏅 Special podium for Top 3 players!",
			"✅ Halloween Champion 2025 badge"
		}
	},
	{
		version = "CHANGELOG V2025-10-17.1",
		changes = {
			"🧑 Bundle UGCs Title Display",
			"🧑 Podium UGCs are now purchasable through Gems",
			"💎 Exchange in Shop menu to convert Cash to Gems",
			"🎲 Updated animations & Colors for all Podiums",
			"🚀 New Bulk Purchase system with 4 mannequins",
			"🐞 Bug fixes(Autoclicker)" 
		}
	},
	{
		version = "CHANGELOG V2025-10-12",
		changes = {
			"💎 10MILLIONS code to celebrate 10M visits",
			"🙏 THANK YOU ALL, KEEP FIGHTING!!!",
			"🐞 Bug fixes" 
		}
	},
	{
		version = "CHANGELOG V2025-10-04.5",
		changes = {
			"🎲 New Gym Reward x5 per day",
			"🚀 New teleported to Ranked Arena",
			"📖 New Changelog UI with version history",
			"🐞 Bug fixes (takedown bug)",
			"🧑 Podium UGCs are now renewed",
			"🏅 Special chat tag for Top 3 players",
			"🎨 Brand new UI and menus completed"
		}
	},
	{
		version = "CHANGELOG V2025-09-22",
		changes = {
			"📖 New tutorial use ? top menu button",
			"🎁 New daily rewards system ",
			"💸 Limited time offers at startup",
			"🧑 New UGCs to customize your avatar",
			"🎨 Brand new UI and menus",
			"⚡ Enhanced loading time",
			"🏟 Fight mode only in Gym now",
			"🎙 Voice chat is now available"
			
		}
	}
}]]></ProtectedString>
						<string name="ScriptGuid">{D0E63404-3319-4DEC-BCED-8CF05FFC4E7E}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Changelog_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDD2B108DF17948AEA6C2041070A78F58">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/DiscoLights_Mod.lua
--
--  Description:
--      Module handling dynamic disco lighting effects with two modes:
--      - "classic": cycling through vibrant disco colors
--      - "gradient": smooth oscillation between theme-based start/end colors
--      The module supports both MeshPart, SpotLight, and Beam instances,
--      using TweenService for smooth transitions.
--
--  Author(s): Adnan, Darkzeb
--
--  Last Modified: 2025-11-01 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Design/ThemeManager (for color theming)
--      - Services:
--          * TweenService
--
--  Notes:
--      - Automatically falls back to default purple/orange colors if ThemeManager is unavailable
--      - Gradient mode uses sine-based oscillation for continuous color blending
--      - Classic mode cycles through preset hues with optional cyan filtering
--      - Used for visual ambiance in themed environments or event maps
--
--======================================================================


local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DiscoLights_Mod = {}
local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
DiscoLights_Mod.__index = DiscoLights_Mod

-- Default fallback colors
local DEFAULT_START = Color3.fromHex("#6B0FCF")
local DEFAULT_END   = Color3.fromHex("#FE7919")

local COLOR_START, COLOR_END

-- Try loading ThemeManager colors
local success, themeManager = pcall(function()
	return require(ReplicatedStorage:WaitForChild("Design"):WaitForChild("ThemeManager"))
end)

if success and themeManager then
	local startHex = themeManager.getAttribute("shop.Shop_Color_Start")
	local endHex = themeManager.getAttribute("shop.Shop_Color_End")

	if type(startHex) == "string" then
		COLOR_START = Color3.fromHex(startHex)
	else
		warn("[DiscoLights_Mod] Invalid or missing Shop_Color_Start, using default.")
		COLOR_START = DEFAULT_START
	end

	if type(endHex) == "string" then
		COLOR_END = Color3.fromHex(endHex)
	else
		warn("[DiscoLights_Mod] Invalid or missing Shop_Color_End, using default.")
		COLOR_END = DEFAULT_END
	end
else
	warn("[DiscoLights_Mod] Could not load ThemeManager, using defaults.")
	COLOR_START = DEFAULT_START
	COLOR_END = DEFAULT_END
end

function DiscoLights_Mod.new(Objects, mode)
	local self = setmetatable({}, DiscoLights_Mod)
	self.LightableObjects = Objects
	self.IsLightsRunning = false
	self.Mode = mode or "gradient"
	return self
end

----------------------------------------------------------------------
-- Classic mode (unchanged)
----------------------------------------------------------------------
local isSingleLight = false
local selectiveColors = true
local listOfColors1 = {
	Color3.fromHSV(0.33,1,1),Color3.fromHSV(0.36,1,1),Color3.fromHSV(0.39,1,1),
	Color3.fromHSV(0.42,1,1),Color3.fromHSV(0.45,1,1),Color3.fromHSV(0.48,1,1),
	Color3.fromHSV(0.51,1,1),Color3.fromHSV(0.54,1,1),Color3.fromHSV(0.57,1,1)
}
local rng = Random.new()
local colorIndex = 0
local CYAN_HUE, EXCLUDE_CYAN_HALF_WIDTH = 0.5, 0.04
local function hueInBand(h, center, half)
	local d = math.abs(((h - center + 0.5) % 1) - 0.5)
	return d <= half
end
local function randomDiscoColor()
	if isSingleLight then return Color3.fromHSV(0, 1, 1) end
	if selectiveColors then
		colorIndex = (colorIndex % #listOfColors1) + 1
		return listOfColors1[colorIndex]
	end
	local h
	repeat h = rng:NextNumber(0, 1)
	until not hueInBand(h, CYAN_HUE, EXCLUDE_CYAN_HALF_WIDTH)
	return Color3.fromHSV(h, 1, 1)
end

----------------------------------------------------------------------
-- Smooth gradient mode (continuous wave)
----------------------------------------------------------------------
-- Compute interpolated color between start and end
local function lerpColor(a: Color3, b: Color3, t: number): Color3
	return Color3.new(
		a.R + (b.R - a.R) * t,
		a.G + (b.G - a.G) * t,
		a.B + (b.B - a.B) * t
	)
end

-- Continuous smooth interpolation using sine
local function getSmoothGradientColor(time)
	local t = (math.sin(time) + 1) / 2 -- oscillates 0 → 1 → 0
	return lerpColor(COLOR_START, COLOR_END, t)
end

----------------------------------------------------------------------
-- Beam tween helper
----------------------------------------------------------------------
local function tweenBeamColor(beam, tweenInfo, toColor)
	local fromColor = beam.Color.Keypoints[1] and beam.Color.Keypoints[1].Value or Color3.new(1,1,1)
	local proxy = Instance.new("Color3Value")
	proxy.Value = fromColor

	local conn
	conn = proxy.Changed:Connect(function(c: Color3)
		beam.Color = ColorSequence.new(c)
	end)

	local tween = TweenService:Create(proxy, tweenInfo, {Value = toColor})
	tween.Completed:Connect(function()
		conn:Disconnect()
		proxy:Destroy()
	end)
	tween:Play()
end

----------------------------------------------------------------------
-- Main loop
----------------------------------------------------------------------
function DiscoLights_Mod:StartLights()
	if self.IsLightsRunning then return end
	self.IsLightsRunning = true

	local t0 = os.clock()

	while self.IsLightsRunning do
		local color
		if self.Mode == "gradient" then
			local elapsed = os.clock() - t0
			color = getSmoothGradientColor(elapsed * 0.5) -- speed factor
		else
			color = randomDiscoColor()
			task.wait(3)
		end

		local goal = {Color = color}
		for _, obj in ipairs(self.LightableObjects) do
			if obj:IsA("MeshPart") or obj:IsA("SpotLight") then
				TweenService:Create(obj, tweenInfo, goal):Play()
			elseif obj:IsA("Beam") then
				tweenBeamColor(obj, tweenInfo, color)
			end
		end

		if self.Mode == "gradient" then
			task.wait(0.1) -- update ~10 FPS for smooth fade
		end
	end
end

function DiscoLights_Mod:StopLights()
	self.IsLightsRunning = false
end

return DiscoLights_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{188AB1A1-FC95-479F-815F-4B3ABEC21151}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">DiscoLights_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5B2CC88A84E843D5AA7EC4E67314A265">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Offers_Config.lua
--
--  Description:
--      Defines configuration for special in-game offers (discounted
--      Gamepasses, DevProducts, and UGC items). Integrates with
--      Monetization_Mod and DataStoreService to manage limited-time
--      promotions and player offer states.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-3 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage/Data_Mods_F:
--          * Monetization_Mod
--          * Clothing_Mod
--      - Local Modules:
--          * GetPrice_Icon
--          * UGCItemHelper (provides UGCItemsConfig)
--      - Roblox Services:
--          * MarketplaceService
--          * DataStoreService ("PlayerOfferState")
--
--  Notes:
--      - Offers table entries:
--          * Key: link to Monetization_Mod (Gamepass/DevProduct)
--          * Kind: "Gamepass" or "DevProduct"
--          * Title, Icon, OldPrice, NewPrice
--          * IsOfferActive: whether offer is currently valid
--          * EndsAt: expiration timestamp (os.time format)
--          * Priority: display priority
--          * HideIfOwned: hides if player already owns gamepass
--      - Includes UGCItemsConfig from UGCItemHelper
--      - Functions:
--          * loadOfferState(plr, Prekey): loads/saves offer state per player
--
--======================================================================

-- Services
local RunService = game:GetService("RunService")

local IS_SERVER = RunService:IsServer()

local MPS = game:GetService("MarketplaceService")
local RS = game:GetService("ReplicatedStorage")


-- Modules
local Data_Mods_F      = RS:WaitForChild("Data_Mods_F")
local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Monetization_Mod = require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Item_Price_Icon = require(script:WaitForChild("GetPrice_Icon"))

local UGCOffers_Config = require(script.UGCItemHelper)

local Offers_SavedData=nil
local DSS=nil
local OfferStore=nil
if IS_SERVER then
	Offers_SavedData = require(script:WaitForChild("OfferStorageData_Mod"))
	DSS = game:GetService("DataStoreService")
	OfferStore = DSS:GetDataStore("PlayerOfferState")
end


local Offers_Config = {}
local coinsLimit = 5000 -- Not valide now

-- Legit offer kinds (server-authoritative)
Offers_Config.OFFER_KIND = {
	Gamepass   = true,
	DevProduct = true,
	UGC        = true,
	Gloves     = true,
	Shorts     = true,
}

-- one schema for all offers
Offers_Config.UGCItemsConfig = UGCOffers_Config.UGCItemsConfig

Offers_Config.Podiums = {
	LeftPodium = {
		prompt = "Open Discount Offer"

	},
	CenterPodium = {
		prompt = "Open Avatar Item Offer"

	},
	RightPodium = {
		prompt = "Get new equipment"
	}
}

Offers_Config.Offers = {
	-- DevProduct: 6k Cash (consumable → always eligible)
	{
		Key        = "D",                      -- Monetization_Mod.Dev_Data key
		Kind       = "DevProduct",
		Title      = "Special Cash Bundle",
		Icon       = "rbxassetid://15365698744",
		Amount     = "6000",
		OldPrice   = 799,
		NewPrice   = 399,
		IsOfferActive=false,
		EndsAt     = os.time({year=2025, month=9, day=17, hour=23, min=59, sec=59}),
		Priority   = 100,                      -- higher = more likely to be chosen
		-- Consumable = true,                  -- optional override; inferred if omitted
	},

	-- Gamepass: VIP (non-consumable; hide if owned)
	{
		Key        = "A",                      -- Monetization_Mod.GP_Data key
		Kind       = "Gamepass",
		Title      = "VIP Access",
		Icon       = "rbxassetid://116997996978018",
		OldPrice   = 99,
		NewPrice   = 49,
		IsOfferActive=false,
		EndsAt     = os.time({year=2025, month=12, day=28, hour=23, min=59, sec=59}),
		Priority   = 100,
		HideIfOwned = true,                    -- shorthand for Ownership.Kind="Gamepass"
	},
	-- x2 ELO!
	{
		Key         = "B",   -- Monetization_Mod.Gamepass_Data key
		Kind        = "Gamepass",
		Title       = "x2 ELO!",
		Icon        = "rbxassetid://140028327825184",
		OldPrice    = 500,
		NewPrice    = 249, -- discounted
		IsOfferActive = false,
		EndsAt      = os.time({year=2025, month=12, day=30, hour=23, min=59, sec=59}),
		Priority    = 98,
		HideIfOwned = true,
	},

	-- x2 Cash!
	{
		Key         = "C",
		Kind        = "Gamepass",
		Title       = "x2 Cash!",
		Icon        = "rbxassetid://111390267501817",
		OldPrice    = 250,
		NewPrice    = 149,
		IsOfferActive = false,
		EndsAt      = os.time({year=2025, month=12, day=30, hour=23, min=59, sec=59}),
		Priority    = 97,
		HideIfOwned = true,
	},

	-- Exclusive Emotes!
	{
		Key         = "D",
		Kind        = "Gamepass",
		Title       = "Exclusive Emotes!",
		Icon        = "rbxassetid://140138999956473",
		OldPrice    = 300,
		NewPrice    = 199,
		IsOfferActive = false,
		EndsAt      = os.time({year=2025, month=12, day=30, hour=23, min=59, sec=59}),
		Priority    = 96,
		HideIfOwned = true,
	},

	-- x3 Luck!
	{
		Key         = "E",
		Kind        = "Gamepass",
		Title       = "x3 Luck!",
		Icon        = "rbxassetid://111648715389151",
		OldPrice    = 200,
		NewPrice    = 119,
		IsOfferActive = false,
		EndsAt      = os.time({year=2025, month=12, day=30, hour=23, min=59, sec=59}),
		Priority    = 99,
		HideIfOwned = true,
	},

	-- x2 Luck!
	{
		Key         = "F",
		Kind        = "Gamepass",
		Title       = "x2 Luck!",
		Icon        = "rbxassetid://113302080319391",
		OldPrice    = 99,
		NewPrice    = 75,
		IsOfferActive = false,
		EndsAt      = os.time({year=2025, month=12, day=30, hour=23, min=59, sec=59}),
		Priority    = 94,
		HideIfOwned = true,
	},
}

-- Price configuration by rarity
local RARITY_GEM_PRICE = {
	Default = {
		price = 0,
		discount = 0,  -- 50% off 
	},
	Bronze = {
		price = 30,
		discount = 0.50,  -- 50% off 
	},
	Silver = {
		price = 50,
		discount = 0.30,
	},
	Gold = {
		price = 100,
		discount = 0.10,
	},
	Diamond = {
		price = 500,
		discount = 0.05,
	},
	Platinum = {
		price = 1000,
		discount = 0.01,
	},
	Special = {
		price = 0,
		discount = 0, 
	}
}

local Gloves_Prices_Data = {
	-- Default
	['A']  = {Name="MMA Gloves",                Rarity="Default"},

	-- Tape Crate (Bronze)
	['B']  = {Name="Black Tape",                Rarity="Bronze"},
	['C']  = {Name="Blue Tape",                 Rarity="Bronze"},
	['D']  = {Name="Green Tape",                Rarity="Bronze"},
	['E']  = {Name="Red Tape",                  Rarity="Bronze"},
	['F']  = {Name="Tan Tape",                  Rarity="Bronze"},
	['G']  = {Name="White Tape",                Rarity="Bronze"},
	['H']  = {Name="Purple Tape",               Rarity="Bronze"},

	-- Gloves Crate (Bronze except Mystic → Special)
	['I']  = {Name="Blue Gloves",               Rarity="Bronze"},
	['J']  = {Name="Green Gloves",              Rarity="Bronze"},
	['K']  = {Name="Mystic Gloves",             Rarity="Special"},
	['L']  = {Name="Purple Gloves",             Rarity="Bronze"},

	-- Country Crate #1 (Bronze)
	['M']  = {Name="Argentinian Gloves",        Rarity="Bronze"},
	['N']  = {Name="Australian Gloves",         Rarity="Bronze"},
	['O']  = {Name="Brazilian Gloves",          Rarity="Bronze"},
	['P']  = {Name="Canadian Gloves",           Rarity="Bronze"},
	['Q']  = {Name="Chilean Gloves",            Rarity="Bronze"},
	['R']  = {Name="Chinese Gloves",            Rarity="Bronze"},
	['S']  = {Name="English Gloves",            Rarity="Bronze"},

	-- Country Crate #2 (Bronze)
	['T']  = {Name="French Gloves",             Rarity="Bronze"},
	['U']  = {Name="Georgian Gloves",           Rarity="Bronze"},
	['V']  = {Name="Italian Gloves",            Rarity="Bronze"},
	['W']  = {Name="Jamacian Gloves",           Rarity="Bronze"},
	['X']  = {Name="Japanese Gloves",           Rarity="Bronze"},
	['Y']  = {Name="Mexican Gloves",            Rarity="Bronze"},
	['Z']  = {Name="Moldovan Gloves",           Rarity="Bronze"},

	-- Country Crate #3 (Bronze)
	['A1'] = {Name="Nigerian Gloves",           Rarity="Bronze"},
	['B1'] = {Name="Polish Gloves",             Rarity="Bronze"},
	['C1'] = {Name="New Zealand Gloves",        Rarity="Bronze"},
	['D1'] = {Name="Russian Gloves",            Rarity="Bronze"},
	['E1'] = {Name="Spanish Gloves",            Rarity="Bronze"},
	['F1'] = {Name="USA Gloves",                Rarity="Bronze"},
	['G1'] = {Name="Orange Gloves",             Rarity="Bronze"},
	['H1'] = {Name="White Gloves",              Rarity="Bronze"},

	-- Urban Gloves
	['I1'] = {Name="Graffiti Gloves",           Rarity="Bronze"},
	['J1'] = {Name="Iron Gloves",               Rarity="Bronze"},
	['K1'] = {Name="Gold Gloves",               Rarity="Gold"},
	['L1'] = {Name="Corrupted Purple Gloves",   Rarity="Diamond"},
	['M1'] = {Name="Corrupted Green Gloves",    Rarity="Diamond"},
	['N1'] = {Name="Corrupted Black Gloves",    Rarity="Diamond"},

	-- Fury Crate 1
	['O1'] = {Name="Plastic Green Tape",        Rarity="Bronze"},
	['P1'] = {Name="Plastic Blue Tape",         Rarity="Bronze"},
	['Q1'] = {Name="Plastic Pink Tape",         Rarity="Gold"},
	['R1'] = {Name="Frozen Chain Tape",         Rarity="Diamond"},
	['S1'] = {Name="Molten Chain Tape",         Rarity="Diamond"},
	['T1'] = {Name="Carbon Chain Tape",         Rarity="Diamond"},

	-- Underground Crate 1
	['U1'] = {Name="Plastic Green Gloves",      Rarity="Bronze"},
	['V1'] = {Name="Plastic Blue Gloves",       Rarity="Bronze"},
	['W1'] = {Name="Plastic Pink Gloves",       Rarity="Gold"},
	['X1'] = {Name="Blue Flame Gloves",         Rarity="Diamond"},
	['Y1'] = {Name="Lava Gloves",               Rarity="Diamond"},
	['Z1'] = {Name="Carbon Gloves",             Rarity="Platinum",},

	-- Chromatic
	['A2'] = {Name="Chromatic Green Gloves",    Rarity="Gold"},
	['B2'] = {Name="Chromatic Blue Gloves",     Rarity="Gold"},
	['C2'] = {Name="Chromatic Pink Gloves",     Rarity="Gold"},
	['D2'] = {Name="Chromatic Green Tape",      Rarity="Diamond"},
	['E2'] = {Name="Chromatic Blue Tape",       Rarity="Diamond"},
	['F2'] = {Name="Chromatic Pink Tape",       Rarity="Diamond"},
	['G2'] = {Name="Fury Gloves",               Rarity="Platinum"},

	-- New Gloves
	['H2']  = {Name="Spiderman Red Blue",    	Rarity="Platinum"},
	['I2']  = {Name="Spiderman Blue Red",     Rarity="Platinum"},
	['J2']  = {Name="Spiderman Red Black",    Rarity="Platinum"},
	['K2']  = {Name="Spiderman Black Red",    Rarity="Platinum"},
	['L2']  = {Name="Hungary Gloves",    			Rarity="Bronze"},
	['M2']  = {Name="Thailand Gloves",   			Rarity="Bronze"},
}

local Shorts_Prices_Data = {
	['A']  = {Name="MMA Shorts",         Rarity="Default"},
	['B']  = {Name="Karate Shorts",      Rarity="Bronze"},
	['C']  = {Name="Denim",              Rarity="Silver"},
	['D']  = {Name="Dragon Gold",        Rarity="Diamond"},
	['E']  = {Name="Black Champs",       Rarity="Bronze"},

	-- Country Crate #1 
	['F']  = {Name="Argentinian Shorts", Rarity="Bronze"},
	['G']  = {Name="Australian Shorts",  Rarity="Bronze"},
	['H']  = {Name="Brazilian Shorts",   Rarity="Bronze"},
	['I']  = {Name="Canadian Shorts",    Rarity="Bronze"},
	['J']  = {Name="Chilean Shorts",     Rarity="Bronze"},
	['K']  = {Name="Chinese Shorts",     Rarity="Bronze"},
	['L']  = {Name="England Shorts",     Rarity="Bronze"},

	-- Country Crate #2 
	['M']  = {Name="French Shorts",      Rarity="Bronze"},
	['N']  = {Name="Georgian Shorts",    Rarity="Bronze"},
	['O']  = {Name="Italian Shorts",     Rarity="Bronze"},
	['P']  = {Name="Jamaican Shorts",    Rarity="Bronze"},
	['Q']  = {Name="Japanese Shorts",    Rarity="Bronze"},
	['R']  = {Name="Mexican Shorts",     Rarity="Bronze"},
	['S']  = {Name="Moldovan Shorts",    Rarity="Bronze"},

	-- Country Crate #3
	['T']  = {Name="Mystic Shorts",      Rarity="Gold" },
	['U']  = {Name="New Zealand Shorts", Rarity="Bronze"},
	['V']  = {Name="Nigerian Shorts",    Rarity="Bronze"},
	['W']  = {Name="Polish Shorts",      Rarity="Bronze"},
	['X']  = {Name="Russian Shorts",     Rarity="Bronze"},
	['Y']  = {Name="Spanish Shorts",     Rarity="Bronze"},
	['Z']  = {Name="USA Shorts",         Rarity="Bronze"},

	-- New Shorts
	['A1']  = {Name="Spiderman Black Shorts",   Rarity="Platinum"},
	['B1']  = {Name="Spiderman Blue Shorts",    Rarity="Platinum"},
	['C1']  = {Name="Thailand Shorts",       	Rarity="Bronze"},
	['D1']  = {Name="Hungary Shorts",       	Rarity="Bronze"},

}

local function IsItemExcludedFromOffer(Rarity)
	if not Rarity then
		return true
	end
	if Rarity=="Special" or Rarity=="Default" then
		return true
	end
	if RARITY_GEM_PRICE[Rarity].price<=0 then
		return true
	end
	return false
end

local function playerDataBool(plr, name)
	local PD = plr:FindFirstChild("Player_Data")
	local v = PD and PD:FindFirstChild(name)
	return v and (v.Value == true) or false
end

local function Get_Player_Val(Plr, Val)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Val) ~= nil) then
		return PD:FindFirstChild(Val)
	end

	return nil
end

local function IsGamepass_Owned(Plr, Key)
	local Owned_Gamepass_Val = Get_Player_Val(Plr, "Owned Gamepasses")
	if(Owned_Gamepass_Val ~= nil) then
		local Owned_Keys = string.split(Owned_Gamepass_Val.Value, ",")
		if(table.find(Owned_Keys, Key) == nil)then
			return false
		end
		return true
	end
end

local function ownsByDescriptor(plr, def)
	local kind = def.Ownership and def.Ownership.Kind
	if not kind then
		-- fallback shorthand for gamepasses
		if def.Kind == "Gamepass" and def.HideIfOwned then
			--	local gp = Monetization_Mod.Get_All_Gamepass_Data()[def.Key]
			return IsGamepass_Owned(plr, def.Key) or false
		end
		return false
	end

	if kind == "Gamepass" then
		--local gp = Monetization_Mod.Get_All_Gamepass_Data()[def.Key]
		return IsGamepass_Owned(plr, def.Key) or false

	elseif kind == "GlovesKey" then
		local k = def.Ownership.Key
		if type(Clothing_Mod.Player_Owns_Gloves_Key) == "function" then
			return Clothing_Mod.Player_Owns_Gloves_Key(plr, k) == true
		end
		return false

	elseif kind == "ShortsKey" then
		local k = def.Ownership.Key
		if type(Clothing_Mod.Player_Owns_Shorts_Key) == "function" then
			return Clothing_Mod.Player_Owns_Shorts_Key(plr, k) == true
		end
		return false

	elseif kind == "AccessoryKey" then
		local k = def.Ownership.Key
		if type(Clothing_Mod.Player_Owns_Accessory) == "function" then
			return Clothing_Mod.Player_Owns_Accessory(plr, k) == true
		end
		-- fallback string list
		local PD = plr:FindFirstChild("Player_Data")
		local ownedV = PD and PD:FindFirstChild("Owned Accessories")
		if ownedV then
			local arr = string.split(ownedV.Value, ",")
			return table.find(arr, k) ~= nil
		end
		return false

	elseif kind == "UGCKey" then
		local k = def.Ownership.Key -- FIX: use Ownership.Key, not def.Key
		return Player_Owns_Item_UGC(plr, k)

	elseif kind == "PlayerDataFlag" then
		return playerDataBool(plr, def.Ownership.Flag) == (def.Ownership.Value ~= false)
	end

	return false
end

local function applyPriceRules(dataTable)
	for key, item in pairs(dataTable) do
		local rarity = item.Rarity
		local cfg = RARITY_GEM_PRICE[rarity]

		if cfg then
			item.Gems = cfg.price
			item.DiscountedGems = math.floor(cfg.price * (1 - cfg.discount))
		end
	end
end

local function computeItemPrices()
	applyPriceRules(Gloves_Prices_Data)
	applyPriceRules(Shorts_Prices_Data)
end

-- Apply dynamic gem pricing at module load
computeItemPrices()


function Offers_Config.GetClothDataByKey(key, isGloves)
	if isGloves then
		return Gloves_Prices_Data[key]

	else
		return Shorts_Prices_Data[key]
	end
end

function Offers_Config.InsertOffer(Offer)
	table.insert(Offers_Config.Offers,Offer)
end


function Offers_Config.GetAndCreateClothOfferOnKey(plr,OKey,OKind,EndsAt)

	local offer=Offers_Config.getOfferDataByKey(OKind,OKey)


	if offer then
		return offer
	end
	local FOUR_DAYS = 4 * 24 * 60 * 60
	local data
	local newTime =  os.time()+FOUR_DAYS
	if EndsAt then
		newTime =EndsAt 
	end

	if OKind == "Gloves" then

		data = Gloves_Prices_Data[OKey]

	else
		data = Shorts_Prices_Data[OKey]

	end
	if IsItemExcludedFromOffer(Gloves_Prices_Data[OKey].Rarity) then
		newTime = 300
	end

	 offer={
		Key         = OKey,
		Kind        = OKind,
		Title       = data.Name,
		Icon        = "", 
		OldPrice    = data.Gems,
		NewPrice    = data.DiscountedGems,
		EndsAt      = newTime,
		Priority    = 1,
		Consumable  = false,
		HideIfOwned = true,
		IsOfferActive = true,
		Ownership   = { Kind = OKind.."Key", Key = OKey }
	}
	local isOwn = ownsByDescriptor(plr,offer)
	if not isOwn then
		Offers_Config.InsertOffer(offer)
		return offer
	end
	return nil
end

function Offers_Config.GetAndCreateClothOffer(plr)
	local FOUR_DAYS = 4 * 24 * 60 * 60
	local number = math.random(1, 50)
	local itemKind="Gloves"
	local itemIndex=1
	local ItemData
	local ItemKey
	local keys = {}
	local price
	local OldPrice
	local PP = Offers_SavedData.LoadOfferState("ClothOffer_",plr)
	task.wait()
	local expiredSet = {}
	if PP and PP.expiredItems then
		for _, v in ipairs(PP.expiredItems) do
			if type(v) == "string" then
				expiredSet[v] = true
			elseif type(v) == "table" then
				local k = v.Key or v.RefName
				if type(k) == "string" then
					expiredSet[k] = true
				end
			end
		end
	end
	if number % 2 == 0 then
		itemKind="Shorts"

		local List=Clothing_Mod.Get_All_Shorts_Data()
		for k in pairs(List) do
			table.insert(keys, k)
		end
		table.sort(keys) 
		local isOwned=true
		local attempts=0
		local maxAttempts = #keys
		while isOwned and attempts < maxAttempts do
			attempts += 1
			--itemIndex = math.random(1, 15)
			ItemKey=keys[itemIndex]
			isOwned=Clothing_Mod.Player_Owns_Shorts_Key(plr,ItemKey)
			--	print("Shorts_",ItemKey,isOwned)
			if expiredSet[ItemKey.."_"..itemKind] or  IsItemExcludedFromOffer(Shorts_Prices_Data[ItemKey].Rarity) then
				isOwned=true
			end
			itemIndex+=1
		end
		OldPrice = Shorts_Prices_Data[ItemKey].Gems
		price = Shorts_Prices_Data[ItemKey].DiscountedGems
		ItemData=List[ItemKey]
	else

		local List=Clothing_Mod.Get_All_Gloves_Data()
		for k in pairs(List) do
			table.insert(keys, k)
		end
		table.sort(keys) 
		local isOwned=true

		local attempts=0
		local maxAttempts = #keys
		while isOwned and attempts < maxAttempts do
			attempts += 1
			--	itemIndex = math.random(1, 30)
			ItemKey=keys[itemIndex]
			isOwned=Clothing_Mod.Player_Owns_Gloves_Key(plr,ItemKey)
			--	print("Gloves_",ItemKey,isOwned)

			if expiredSet[ItemKey.."_"..itemKind] or  IsItemExcludedFromOffer(Gloves_Prices_Data[ItemKey].Rarity) then
				isOwned=true
			end
			itemIndex+=1
		end
		OldPrice = Gloves_Prices_Data[ItemKey].Gems
		price = Gloves_Prices_Data[ItemKey].DiscountedGems
		ItemData=List[ItemKey]
	end
	local offer={

		Key         = ItemKey,
		Kind        = itemKind,
		Title       = ItemData,
		Icon        = "", 
		OldPrice    = OldPrice,
		NewPrice    = price,
		EndsAt      = os.time()+FOUR_DAYS,
		Priority    = 1,
		Consumable  = false,
		HideIfOwned = true,
		IsOfferActive = true,
		Ownership   = { Kind = itemKind.."Key", Key = ItemKey }
	}
	

	Offers_Config.InsertOffer(offer)
	return offer
end


-- --- helpers ---
function Offers_Config.parseName(name)
	local prio, key, title = string.match(name, "^(%d+)%s*/%s*(%d+)%s*/%s*(.+)$")
	if not prio then return end
	return tonumber(prio), tostring(key), title
end
local function FindUGCFromListByKey(key)
	local list = UGCOffers_Config.UGCItemsConfig or {}
	for _,item in pairs(list) do
		if tostring(item.Key)==tostring(key) then
			return item
		end
	end
	return nil
end
function Offers_Config.GenerateUGCSavedOffer (name)
	local prio, key, title = Offers_Config.parseName(name)
	local _item = FindUGCFromListByKey(key)
	if _item then
		return _item
	end
	local item={
		Key = key,
		Kind = "UGC",
		Title = title,
		RefName=name,
		Priority = prio,
		EndsAt = 0,     
	}
	return item
end

function Offers_Config.GetUGCItemNew(plr)
	local profile = Offers_SavedData.LoadOfferState("offer_1_",plr)
	local expiredSet = {}
	if profile and profile.expiredItems then
		for _, v in ipairs(profile.expiredItems) do
			if type(v) == "string" then
				expiredSet[v] = true
			elseif type(v) == "table" then
				local k = v.Key or v.RefName
				if type(k) == "string" then
					expiredSet[k] = true
				end
			end
		end
	end

	local function isActive(item)
		-- Treat missing flags as active by default
		if item.IsOfferActive == false then
			return false
		end

		-- Resolve the canonical key we’ll use everywhere
		local key= item.RefName
		if type(key) ~= "string" or key == "" then
			return false
		end

		if expiredSet[key] then
			return false
		end
		return true
	end

	local list = UGCOffers_Config.UGCItemsConfig or {}
	local best = nil
	local allActiveOffers={}
	for _, item in ipairs(list) do
		local key = item.Key or item.RefName
		if type(key) == "string" and key ~= "" then
			if isActive(item) and not Player_Owns_Item_UGC_ServerCheck(plr, key) then

				local pri    = tonumber(item.Priority) or 0
				local title  = tostring(item.Title or "")

				if not best
					or pri > (tonumber(best.Priority) or 0)
					or (pri == (tonumber(best.Priority) or 0) and title < tostring(best.Title or "")) then
					best = item
				end
				table.insert(allActiveOffers,item)
				if #allActiveOffers>20 then
					break
				end
			end
		end
	end

	return best ,allActiveOffers -- may be nil if everything is owned/inactive/expired
end






local function getPlayerCoins(plr)
	local PD = plr:FindFirstChild("Player_Data")
	local v = PD and PD:FindFirstChild("Coins")
	return (v and tonumber(v.Value)) or 0
end


local function getDevType(key)
	local t = Monetization_Mod.Get_All_Dev_Product_Data()[key]
	return t and t.Type or nil
end

-- default consumable inference from Dev Type
local TypeConsumableDefault = {
	Cash = true,
	Gems = true,
	["StarterPack"] = false,
	["Special Gloves"] = false,
	Bundle = false,
}

local function isConsumable(def)
	if def.Consumable ~= nil then return def.Consumable end
	if def.Kind == "Gamepass" then return false end
	-- DevProduct: infer from type
	local t = getDevType(def.Key)
	if not t then return false end
	local v = TypeConsumableDefault[t]
	if v == nil then
		-- unknown types treated as non-consumable by default (safer)
		return false
	end
	return v
end

function Player_Owns_Item_UGC(Plr, Key)
	local ID = Monetization_Mod.Get_All_UGC_Data()[Key].ID
	return Player_Owns_Item_UGC_ServerCheck(Plr,ID)
end

function Player_Owns_Item_UGC_ServerCheck(Plr, ID)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = MPS:PlayerOwnsAsset(Plr, ID)
		end)

		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end

	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end

	return false
end



local function discountText(oldP, newP)
	oldP, newP = tonumber(oldP), tonumber(newP)
	if not oldP or not newP or oldP <= 0 or newP <= 0 then return "" end
	local pct = math.floor(((oldP - newP) / oldP) * 100)
	if pct < 0 then pct = 0 end
	return pct > 0 and ("-" .. pct .. "%") or ""
end




-- one row → UI payload (preformatted)
function Offers_Config.rowForClient(plr, def)
	-- Guard: offer inactive
	if not def.IsOfferActive then
		return nil
	end

	-- Expiry check
	local endsAt = tonumber(def.EndsAt) or 0
	if endsAt > 0 and os.time() > endsAt then
		return nil
	end

	-- Resolve catalog entry
	local entry, data
	if def.Kind == "DevProduct" then
		entry = Monetization_Mod.Get_All_Dev_Product_Data()[def.Key]
		if not entry then return nil end
		data = Item_Price_Icon.getPriceInfo(def.Kind, entry.ID)

	elseif def.Kind == "UGC" then
		entry = Monetization_Mod.Get_All_UGC_Data()[def.Key]
		if not entry then return nil end
		data = Item_Price_Icon.getPriceInfo(def.Kind, entry.ID)

	elseif def.Kind == "Gamepass" then
		entry = Monetization_Mod.Get_All_Gamepass_Data()[def.Key]
		if not entry then return nil end
		data = Item_Price_Icon.getPriceInfo(def.Kind, entry.ID)

	elseif def.Kind == "Gloves" or def.Kind == "Shorts" then
		-- These aren’t Roblox catalog items, only internal Clothing_Mod keys
		entry = {
			Name = def.Title,
			Icon = def.Icon,
			ID   = def.Key,
		}
		data = { price = def.NewPrice } -- manual, no Marketplace lookup

	else
		return nil -- unsupported type
	end

	-- Ownership check (skip if already owned and non-consumable)
	local consumable = isConsumable(def)
	if not consumable then
		if ownsByDescriptor(plr, def) then
			return nil
		end
	end

	-- Final payload for client UI
	return {
		ProductKey   = def.Key,
		Kind         = def.Kind,                               -- "DevProduct" | "Gamepass" | "UGC" | "Gloves" | "Shorts"
		Title        = def.Title or (entry and entry.Name) or "Offer",
		ItemIcon     = def.Icon or (entry and entry.Icon) or "",
		Amount       = def.Amount or "",
		OldPrice     = def.OldPrice,
		NewPrice     = data and data.price or def.NewPrice,
		DiscountText = discountText(def.OldPrice, def.NewPrice),
		EndsAt       = endsAt,
		ShowAfter    = tonumber(def.ShowAfter) or 0,
		_Priority    = tonumber(def.Priority) or 0,            -- internal sort key
		Ownership    = def.Ownership or nil
	}
end

function Offers_Config.getOfferDataByKey(Kind,key)
	for _, def in ipairs(Offers_Config.Offers) do
		if def.Key == key and def.Kind==Kind then
			return def
		end
	end
	return nil
end

function Offers_Config.IsItemOwned(plr,Kind, Key)
	local def = Offers_Config.getOfferDataByKey(Kind,Key)
	if not def then return true end
	return ownsByDescriptor(plr, def)
end

function Offers_Config.getOfferByKey(plr,Kind, key)
	local def = Offers_Config.getOfferDataByKey(Kind,key)
	if not def then return nil end
	return Offers_Config.rowForClient(plr, def)
end

-- Build ALL eligible rows
function Offers_Config.buildPayload(plr)
	local out = {}
	for _, def in ipairs(Offers_Config.Offers) do
		local row = Offers_Config.rowForClient(plr, def)
		if row then
			table.insert(out, row)
		end
	end
	return out
end
-- Dynamic eligibility rules at pick time (after rows are built)
function Offers_Config.isRowEligibleNow(plr, row)

	if row.Kind == "Gloves" then
		local data = Gloves_Prices_Data[row.ProductKey]

		if data and  IsItemExcludedFromOffer(data.Rarity) then
			return false
		end
	elseif row.Kind == "Shorts" then
		local data = Shorts_Prices_Data[row.ProductKey]
		if data and IsItemExcludedFromOffer(data.Rarity) then
			return false
		end
	end

	-- Guard: expired rows shouldn’t be picked
	if row.EndsAt and row.EndsAt > 0 and os.time() > row.EndsAt and row.IsOfferActive then
		return false
	end

	-- Rule A: If player has >coinsLimit Coins, skip Cash DevProduct offers
	if row.Kind == "DevProduct" then
		local dev = Monetization_Mod.Get_All_Dev_Product_Data()[row.ProductKey]
		if dev and dev.Type == "Cash" then
			if getPlayerCoins(plr) > coinsLimit then 
				return false
			end
		end
	end

	-- Rule B: If it’s a gamepass and the player already owns it, skip
	if row.Kind == "Gamepass" then
		return (not IsGamepass_Owned(plr, row.ProductKey)) or true
	end

	return true
end

function Offers_Config.pickTopOffer(plr)
	local rows = Offers_Config.buildPayload(plr)

	-- Filter by dynamic eligibility
	local eligible = {}
	for _, r in ipairs(rows) do
		if Offers_Config.isRowEligibleNow(plr, r) then
			table.insert(eligible, r)
		end
	end

	-- Nothing left? return nil so server sends no offer
	if #eligible == 0 then
		return nil
	end

	-- Sort by Priority (desc), then EndsAt (earliest first)
	table.sort(eligible, function(a, b)
		local ap = tonumber(a._Priority) or 0
		local bp = tonumber(b._Priority) or 0
		if ap ~= bp then
			return ap > bp
		end
		local ae = tonumber(a.EndsAt) or math.huge
		local be = tonumber(b.EndsAt) or math.huge
		return ae < be
	end)

	return eligible[1]
end
return Offers_Config
]]></ProtectedString>
						<string name="ScriptGuid">{7A6409B8-4B10-4059-AB0A-886673A95BF4}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Offers_Config.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX818DDD8C73B742149A406EC2BE388E24">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Offers_Config</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX7E6E1522C4C1401B9E574668116BA1D9">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Offers_Config/GetPrice_Icon.lua
--
--  Description:
--      Utility to fetch price and icon metadata for Gamepasses, UGC
--      items, and Developer Products. Uses MarketplaceService and
--      AvatarEditorService with caching to reduce request overhead.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * MarketplaceService
--          * AvatarEditorService
--
--  Notes:
--      - Functions:
--          * thumbUrl(kind, id, w, h): builds thumbnail URL
--          * getPriceInfo(kind, id): returns {price, isForSale, name, iconImage}
--      - Supports:
--          * Gamepasses (via MPS.GetProductInfo, InfoType.GamePass)
--          * UGC/Assets (via AES.GetItemDetails, fallback to MPS)
--          * DevProducts (via MPS.GetProductInfo, InfoType.Product)
--      - Internal cache (TTL = 5s) avoids spamming API calls
--
--======================================================================



local MPS = game:GetService("MarketplaceService")
local AES = game:GetService("AvatarEditorService")

local GetPrice_Icon = {}

GetPrice_Icon.CACHE = {}    -- [cacheKey] = { t = os.clock(), data = ... }
GetPrice_Icon.TTL   = 5

function GetPrice_Icon.thumbUrl(kind: string, id: number, w: number, h: number): string?
	if kind == "Gamepass" then
		return string.format("rbxassetid://"..id)
	elseif kind == "UGC" then
		return string.format("rbxassetid://"..id)
	end
	return nil -- DevProduct: supply custom icon
end

function GetPrice_Icon.getPriceInfo(kind: string, idIn: number | string)
	kind = string.lower(kind)
	local id = tonumber(idIn)
	if not id then return nil end

	local cacheKey = kind .. ":" .. id
	local now = os.clock()
	local c = GetPrice_Icon.CACHE[cacheKey]
	if c and (now - c.t) < GetPrice_Icon.TTL then
		return c.data
	end

	local data = { price = nil, isForSale = nil, name = nil, iconImage = nil }

	if kind == "gamepass" then
		local ok, info = pcall(MPS.GetProductInfo, MPS, id, Enum.InfoType.GamePass)
		if ok and info then
			data.price = info.PriceInRobux
			data.isForSale = info.IsForSale
			data.name = info.Name
			data.iconImage = GetPrice_Icon.thumbUrl("Gamepass", id, 150, 150)
		end

	elseif kind == "ugc" or kind == "asset" then
		-- Primary: AES for accurate current pricing (incl. limiteds/resales)
		local ok1, details = pcall(AES.GetItemDetails, AES, id, Enum.AvatarItemType.Asset)
		if ok1 and details then
			data.price = details.Price or details.LowestResalePrice
			data.isForSale = details.IsForSale
			data.name = details.Name or details.ItemName
			data.iconImage = GetPrice_Icon.thumbUrl("UGC", id, 150, 150)
		else
			-- Fallback: MPS
			local ok2, info = pcall(MPS.GetProductInfo, MPS, id, Enum.InfoType.Asset)
			if ok2 and info then
				data.price = info.PriceInRobux
				data.isForSale = info.IsForSale
				data.name = info.Name
				data.iconImage = GetPrice_Icon.thumbUrl("UGC", id, 150, 150)
			end
		end

	elseif kind == "devproduct" or kind == "product" then
		local ok, info = pcall(MPS.GetProductInfo, MPS, id, Enum.InfoType.Product)
		if ok and info then
			data.price = info.PriceInRobux
			data.isForSale = true -- purchasable via prompt
			data.name = info.Name
			-- DevProduct: no official icon
		end
	end

	-- Only cache if we actually got something meaningful
	if data.name or data.price or data.isForSale ~= nil then
		GetPrice_Icon.CACHE[cacheKey] = { t = now, data = data }
	end
	return data
end

return GetPrice_Icon
]]></ProtectedString>
							<string name="ScriptGuid">{F8E8CEDD-E422-48D2-A63C-1CED1E89EB91}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">GetPrice_Icon.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4D33ABEE00784E42A109BB65A1D2EFC4">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Offers_Config/UGCItemHelper.lua
--
--  Description:
--      Builds dynamic configuration of UGC items from
--      ReplicatedStorage/OfferItems/UGCItems. Parses instance names
--      into Priority/Key/Title and maintains a sorted list with live
--      updates on folder changes.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Models/UGC/OfferItems/UGCItems (instances representing UGC items)
--
--  Notes:
--      - Expected instance name format: "Priority/Key/Title"
--      - Each item entry includes:
--          * Key, Kind="UGC", Title, RefName
--          * Priority (higher = shown first)
--          * EndsAt (0 = no expiration)
--          * IsOfferActive (default true)
--          * _ref (reference to original instance)
--      - Items are sorted by Priority (desc) then Title (asc)
--      - Hooks folder changes (add/remove/rename/attribute change)
--        to auto-refresh UGCItemsConfig
--
--======================================================================




local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UGC_FOLDER = ReplicatedStorage:WaitForChild("Models"):WaitForChild("UGC"):WaitForChild("OfferItems"):WaitForChild("UGCItems")
local Monetization_Mod = require(ReplicatedStorage:WaitForChild("Data_Mods_F"):WaitForChild("Monetization_Mod"))
local M = {}
M.UGCItemsConfig = {}
--["C1"] = { Name = "Nerd Glasses - Green", ID = 77949725271695, Price = 90, Thumbnail = "rbxthumb://type=Asset&Id=77949725271695&w=150&h=150" },
local AllUGCs = Monetization_Mod.Get_All_UGC_Data()

local function FindItemByIDKeyMatch(key)
	for	indexkey,item in pairs(AllUGCs) do
	--	print(indexkey,item)
		if tostring(item.ID)==tostring(key) then
			--print(item.Name ," Matched ")
			return indexkey,item
		end
	end
	return nil,nil
end

-- parse "Priority/Key/Title"

local function parseName(name) 
	local prio, key, title = string.match(name, "^(%d+)%s*/%s*(%d+)%s*/%s*(.+)$")
	if not prio then return end
	return tonumber(prio), tostring(key), title
end

local function rebuild()
	local items = {}
	for _, inst in ipairs(UGC_FOLDER:GetChildren()) do
		local prio, key, title = parseName(inst.Name)
		local _MontizationUGCKey,Item= FindItemByIDKeyMatch(key)
		local title2 = title:gsub("-", " ")
		local newTitle =Item and Item.Name or title2
	--	print(newTitle,title,Item,_MontizationUGCKey)
		
		
		if prio then
			table.insert(items, {
				Key = key,
				Kind = "UGC",
				Title = newTitle,
				RefName=inst.Name,
				Priority = prio,
				EndsAt =  0,           -- 0 = no end
				IsOfferActive = true, -- default true
				_ref = inst,
				MontizationUGCKey = _MontizationUGCKey
			})
		else
			warn("[UGCItemHelper] Bad item name (expected 'Priority/Key/Title'):", inst:GetFullName())
		end
	end
	table.sort(items, function(a,b)
		if a.Priority ~= b.Priority then return a.Priority > b.Priority end
		return a.Title < b.Title
	end)
	M.UGCItemsConfig = items
	--print(("[UGCItemHelper] Refreshed. Items: %d"):format(#items))
end

-- hook signals on a single child to catch rename/attribute edits
local function hookChild(inst)
	inst:GetPropertyChangedSignal("Name"):Connect(rebuild)
	inst.AttributeChanged:Connect(rebuild)
end

-- initial build + hooks
rebuild()
for _, c in ipairs(UGC_FOLDER:GetChildren()) do
	hookChild(c)
end

-- folder-level add/remove hooks
UGC_FOLDER.ChildAdded:Connect(function(c)
	hookChild(c)
	rebuild()
end)

UGC_FOLDER.ChildRemoved:Connect(function()
	rebuild()
end)

return M
]]></ProtectedString>
							<string name="ScriptGuid">{D2FFB2C9-8D68-422A-908F-E7DAACABD9CB}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UGCItemHelper.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX88D5CAFA809C4892B43D3C27C19ECED8">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Offers_Config/OfferStorageData_Mod.lua
--
--  Description:
--      Provides utility functions to manage player offer states in
--      DataStoreService. Supports loading and saving both cloth and
--      UGC offer data, handling active and expired offers.
--
--      Key features:
--        - Load a player’s offer state from DataStore
--        - Save cloth-based offers with tracking of expired items
--        - Save UGC-based offers with podium-specific tracking
--        - Automatically limits the number of stored expired offers
--        - Ensures unique keys per player and per offer/podium
--
--  Author(s): Adnan
--
--  Last Modified: 2025-09-30 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * DataStoreService (PlayerOfferState DataStore)
--      - ReplicatedStorage:
--          * Models/UGC/OfferItems.UGCItems (for counting UGC items)
--      - Player Instances:
--          * UserId used for unique DataStore keys
--
--  Notes:
--      - Uses pcall to safely access DataStore
--      - Maintains a maximum of 30 expired items for cloth offers
--      - UGC expired items limit is determined dynamically based on
--        the number of UGCItems in ReplicatedStorage
--      - Functions are stateless and can be called from server scripts
--======================================================================

local DSS 			= game:GetService("DataStoreService")
local OfferStore	= DSS:GetDataStore("PlayerOfferState")

local OSData = {}

function OSData.LoadOfferState(DataKey,plr)
	local key = DataKey .. plr.UserId
	local ok, Data = pcall(function()
		return OfferStore:GetAsync(key)
	end)
	if ok and Data then
		return Data
	else
		--print("Failed to load offer state for", plr.UserId, err)
	end
	return nil
end

function OSData.SaveClothOfferState(DataKey,plr, offerAC)
	local key = DataKey.. plr.UserId
	local now=os.time() 
	local ok, err = pcall(function()
		OfferStore:UpdateAsync(key, function(old)
			old = old or {}
			old.expiredItems = old.expiredItems or {}
			local prev = old.ActiveOffer

			if prev then
				local expCount = #old.expiredItems
				if expCount == 30 then
					old.expiredItems={}
				else
					table.insert(old.expiredItems, {
						Key = prev.CurrentKey,
						EndedAt = now,
						EndReason ="expired",
					})
				end
			end

			old.ActiveOffer = {
				CurrentKey =offerAC.Key.."_"..offerAC.Kind,
				offer = offerAC
			}
			return old
		end)
	end)

	if not ok then
		warn("Failed to save offer state:", err)
	end
end


local function IsSameDay(t1, t2)
	-- Compare by year + day-of-year to avoid timezone/date string issues
	local d1 = os.date("!*t", t1)
	local d2 = os.date("!*t", t2)
	return d1.year == d2.year and d1.yday == d2.yday
end

function OSData.SaveOfferPurchaseCount(DataKey, plr)
	local key = DataKey .. plr.UserId
	local now = os.time()

	local ok, err = pcall(function()
		OfferStore:UpdateAsync(key, function(old)
			old = old or {}

			old.PurchasedCount = old.PurchasedCount or 0
			local prev = old["LastPurchasedDate"]

			if prev then
				if not IsSameDay(prev, now) then
					old.PurchasedCount = 0
				end
			end

			old.PurchasedCount += 1
			old.LastPurchasedDate = now

			return old
		end)
	end)

	if not ok then
		warn("Failed to save offer state:", err)
	end
end


function OSData.SaveUGCOfferState(DataKey,PodiumID,plr, itemName, endTime)
	--	local key = "offer_1_" .. plr.UserId
	local key = DataKey .. plr.UserId
	local now = os.time()

	local ok, err = pcall(function()
		OfferStore:UpdateAsync(key, function(old)
			old = old or {}
			old.expiredItems = old.expiredItems or {}
			local prev 

			if old.ActiveOffer then

				prev= old.ActiveOffer[PodiumID] or {}
			else
				old.ActiveOffer={}
			end
			if prev then
				local expCount = #old.expiredItems
				local folderCount=#game.ReplicatedStorage.Models.UGC.OfferItems.UGCItems:GetChildren()
				if expCount >= (folderCount-1) then
					old.expiredItems={}
				end
				table.insert(old.expiredItems, {
					Key = prev.CurrentKey,
					EndedAt = now,
					EndReason ="expired",
				})
			end
			old.ActiveOffer[PodiumID] = {
				CurrentKey = itemName,
				EndsAt     = endTime,
				StartedAt  = now,
			}
			return old
		end)
	end)

	if not ok then
		warn("Failed to save offer state:", err)
	end
end

return OSData
]]></ProtectedString>
							<string name="ScriptGuid">{0B7883C7-5768-468B-B9AE-5649144ABB4D}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">OfferStorageData_Mod.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX5C710B00386747E2B33D48EED5EF5D43">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/UGC_Pack_Config.lua
--
--  Description:
--      Configuration module defining all available UGC (User Generated Content)
--      packs and their associated avatar assets. Each pack contains a list of
--      accessories with Roblox asset IDs and human-readable titles.
--      Used by UGC_Pack_Handle.lua for accessory application, ownership checks,
--      and purchase setup.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-11-14 by Adnan
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * None (data-only module)
--
--  Exports:
--      - UGCPC.UGCPacks : table
--          Structure:
--              {
--                  ["PackName"] = {
--                      items = {
--                          { id = "AssetId", Title = "Display Name" },
--                          ...
--                      }
--                  }
--              }
--
--  Features:
--      - Centralized configuration for all UGC item packs
--      - Supports dynamic loading via require()
--      - Easily extendable with new packs or assets
--      - Read-only data table to be consumed by server scripts
--
--  Notes:
--      - Intended for use under ReplicatedStorage/Data_Mods_F/
--      - Ensure all listed AssetIds are valid published Roblox assets
--      - Avoid direct modification at runtime; treat as static data
--
--======================================================================

local UGCPC = {}--UGC_Pack_Config

local packs = {




	["Pack1"]={
		items={
			{
				id = "115157954314498",
				Title="MMA Gloves around Neck"
			},
			{
				id = "112667835660803",
				Title="VVS-Double-Chain-MMA-Fighter"
			},
			{
				id = "84934153889096",
				Title="MMA-FIGHTERS-CHAMPIONS-BELT"
			},
			{
				id = "87085165668528",
				Title="Protein-Shaker-Black"
			},
			{
				id = "101251472607139",
				Title="Dreads-Breads"
			},
		},
	},
	["Pack2"]={

		items={
			{
				id = "114922634621014",
				Title="Big Metal Chain"
			},
			{
				id = "99505840765729",
				Title="MMA FIGHTERS CHAMPION'S BELT"
			},
			{
				id = "135859105132166",
				Title="Realistic Gym Towel on Shoulders"
			},
			{
				id = "98181442625165",
				Title="Protein-Shaker-Red"
			},
			{
				id = "95343467130849",
				Title="Trendy Motorcycle Helmet"
			},
		},
	},
	["Pack3"]={

		items={
			{
				id = "75078885992255",
				Title="Boxing Gloves Around Neck"
			},
			{
				id = "81219496918209",
				Title="Black Gold VVS Chain Diamonds"
			},
			{
				id = "102642333841802",
				Title="Protein Shaker - Yellow"
			},
			{
				id = "79643861023078",
				Title="Snake Glasses Y2K - Orange"
			},
			{
				id = "75995119815868",
				Title="Cowboy Hat"
			},
		},
	},
	["Pack4"]={

		items={
			{
				id = "85169596622861",
				Title="Nerd Glasses"
			},
			{
				id = "81877496476783",
				Title="MMA Fighter Training Helmet - Blue"
			},
			{
				id = "140183743497109",
				Title="Big Black Chain"
			},
			{
				id = "139123166526936",
				Title="MMA Gloves around Neck"
			},
			{
				id = "84934153889096",
				Title="MMA FIGHTERS CHAMPION'S BELT"
			},
		},
	},
}

UGCPC.UGCPacks = packs

return UGCPC]]></ProtectedString>
						<string name="ScriptGuid">{C628451A-7553-48BA-89BB-6C5CEC0222CF}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UGC_Pack_Config.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE5044A4482B843E6A21A812D06BB97B9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/PodiumColors_Mod.lua
--
--  Description:
--      Provides a flexible system for defining and applying color schemes
--      across various UI elements, 3D objects, and particle effects.
--      Supports TextLabels, Buttons, Images, BaseParts, Beams, Trails,
--      ParticleEmitters, and UIGradient objects with gradient and 
--      transparency control.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-16 by Adnan
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * None explicitly required; uses standard classes (GuiObject, 
--            BasePart, ParticleEmitter, Beam, Trail)
--
--  Notes:
--      - ColorSchemes table:
--          * Key: scheme name ("S1", "S2", etc.)
--          * NeonEffectColor: Color3
--          * TextColors: Color3
--          * RibbonGradient: table with _1.._5 keys (Color3), 
--            optional gradient_rotation (number) and gradient_transparency (table)
--      - Functions:
--          * ApplyColors(Parent, SchemeName, Specs, TextInfo): applies 
--            a scheme to specified targets under a parent instance
--          * GetScheme(name): returns the color scheme table
--          * SetScheme(name, t): sets or updates a color scheme
--      - Helpers:
--          * toColorSequence(val): converts Color3 or table to ColorSequence
--          * toNumberSequence(tbl): converts table to NumberSequence
--          * ensureUIGradient(gui): ensures a UIGradient exists on GUI
--          * applyValue(obj, schemeVal, TextInfo): internal application logic
--          * findOne(root, pathOrName): resolves single target by path or name
--          * resolveTargets(root, nameField): resolves one or more targets
--
--======================================================================

local Color_Mod = {}

Color_Mod.__index = Color_Mod

function Color_Mod.new(Parent, SchemeName, Specs,TextInfo)
	local self = setmetatable({}, Color_Mod)
	self.Parent=Parent
	self.SchemeName=SchemeName
	self.Specs=Specs
	self.TextInfo=TextInfo
	self:ApplyColors(Parent, SchemeName, Specs,TextInfo)
	return self
end
-- =========================
-- Define schemes (simple)
-- =========================
local ColorSchemes = {
	["S1"] = {
		NeonEffectColor = Color3.fromRGB(218, 164, 40),
		RibbonGradient  = {
			_1 = Color3.fromRGB(255, 255, 0),
			_2 = Color3.fromRGB(170, 0, 0),
	
			gradient_rotation = 90, -- UI only
			gradient_transparency = { {t=0, v=0}, {t=1, v=0} },
			gradient_offset       = { x = 0, y = 0}, -- UI only (Vector2-ish)
		},
	},
	["S2"] = {
		NeonEffectColor = Color3.fromRGB(255, 0, 0),
		RibbonGradient  = {
			_1 = Color3.fromRGB(170, 0, 127),
			_2 = Color3.fromRGB(255, 159, 90),
			gradient_rotation = 90, -- UI only
			gradient_transparency = { {t=0, v=0}, {t=1, v=0} },
			gradient_offset       = { x =0, y = 0.05}, -- UI only (Vector2-ish)
		},
	},
	["S3"] = {
		NeonEffectColor = Color3.fromRGB(0, 176, 199),
		RibbonGradient  = {
			_1 = Color3.fromRGB(0, 255, 255),
			_2 = Color3.fromRGB(248, 255, 105),
			gradient_rotation = 90, -- UI only
			
			gradient_transparency = { {t=0, v=0}, {t=1, v=0} },
			gradient_offset       = { x = 0, y = .15}, -- UI only (Vector2-ish)
		},
		
	}
}

-- =========================
-- Small helpers
-- =========================
local function toColorSequence(val)
	if typeof(val) == "ColorSequence" then return val end
	if typeof(val) == "Color3" then
		return ColorSequence.new{
			ColorSequenceKeypoint.new(0, val),
			ColorSequenceKeypoint.new(1, val),
		}
	end
	if typeof(val) == "table" then
		local stops = {}
		for k,v in pairs(val) do
			local n = tonumber(k:match("^_(%d+)$") or "")
			if n then table.insert(stops, {n=n, c=v}) end
		end
		table.sort(stops, function(a,b) return a.n < b.n end)
		if #stops > 0 then
			local keys = {}
			for i, s in ipairs(stops) do
				local t = (#stops == 1) and 0 or (i-1)/(#stops-1)
				table.insert(keys, ColorSequenceKeypoint.new(t, s.c))
			end
			return ColorSequence.new(keys)
		end
	end
	return nil
end

local function toNumberSequence(tbl)
	if typeof(tbl) == "NumberSequence" then return tbl end
	if typeof(tbl) == "table" then
		local pts = {}
		for _,p in ipairs(tbl) do
			if typeof(p) == "table" and p.t and p.v then
				table.insert(pts, NumberSequenceKeypoint.new(p.t, p.v))
			end
		end
		if #pts > 0 then
			table.sort(pts, function(a,b) return a.Time < b.Time end)
			return NumberSequence.new(pts)
		end
	end
	return nil
end

local function ensureUIGradient(gui)
	local g = gui:FindFirstChildOfClass("UIGradient")
	if g then return g end
	g = Instance.new("UIGradient")
	g.Name = "AutoGradient"
	g.Parent = gui
	return g
end

local function isGui(obj) return obj:IsA("GuiObject") end

local function applyValue(obj, schemeVal,textInfo)

	if obj:IsA("TextLabel") and textInfo.CanSetText and obj.Name == textInfo.TextObjName then
		obj.Text = textInfo.Text or ""
	end

	-- UI: use / create UIGradient, support rotation + transparency
	if isGui(obj) then
		local seq = toColorSequence(schemeVal)
		if seq then
			local grad = ensureUIGradient(obj)
			grad.Color = seq
			local off = schemeVal.gradient_offset
			if off then
				if typeof(off) == "Vector2" then
					grad.Offset = off
				elseif type(off) == "table" then
					local x = off.x or off[1] or 0
					local y = off.y or off[2] or 0
					grad.Offset = Vector2.new(x, y)
				end
			else
				grad.Offset = Vector2.new(0, 0)
			end
			
			if typeof(schemeVal) == "table" and schemeVal.gradient_rotation then
				grad.Rotation = math.clamp(tonumber(schemeVal.gradient_rotation) or 0, 0, 360)
			end
			if typeof(schemeVal) == "table" and schemeVal.gradient_transparency then
				local ns = toNumberSequence(schemeVal.gradient_transparency)
				if ns then grad.Transparency = ns end
			end
			return true
		end
	end

	-- Direct UIGradient target
	if obj:IsA("UIGradient") then
		local seq = toColorSequence(schemeVal)
		if seq then
			obj.Color = seq
			if typeof(schemeVal) == "table" and schemeVal.gradient_rotation then
				obj.Rotation = math.clamp(tonumber(schemeVal.gradient_rotation) or 0, 0, 360)
			end
			if typeof(schemeVal) == "table" and schemeVal.gradient_transparency then
				local ns = toNumberSequence(schemeVal.gradient_transparency)
				if ns then obj.Transparency = ns end
			end
			return true
		end
	end

	-- Beam / Trail / ParticleEmitter: gradient sequence (no rotation prop)
	if obj:IsA("Beam") or obj:IsA("Trail") or obj:IsA("ParticleEmitter") then
		local seq = toColorSequence(schemeVal)
		if seq then
			obj.Color = seq
			if obj:IsA("ParticleEmitter") and typeof(schemeVal) == "table" and schemeVal.gradient_transparency then
				local ns = toNumberSequence(schemeVal.gradient_transparency)
				if ns then obj.Transparency = ns end
			end
			return true
		end
	end

	-- Single-color fallbacks (Color3 only)
	if typeof(schemeVal) == "Color3" then
		if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then

			obj.TextColor3 = schemeVal; return true
		end
		if obj:IsA("ImageLabel") or obj:IsA("ImageButton") then
			obj.ImageColor3 = schemeVal; return true
		end
		if obj:IsA("Decal") or obj:IsA("Texture") then
			obj.Color3 = schemeVal; return true
		end
		if obj:IsA("BasePart") then
			obj.Color = schemeVal; return true
		end
		if obj:IsA("Beam") or obj:IsA("Trail") or obj:IsA("ParticleEmitter") then
			obj.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0, schemeVal),
				ColorSequenceKeypoint.new(1, schemeVal),
			}
			return true
		end
		-- generic attempts
		if pcall(function() obj.Color = schemeVal end) then return true end
		if pcall(function() obj.Color3 = schemeVal end) then return true end
		if pcall(function() obj.TextColor3 = schemeVal end) then return true end
		if pcall(function() obj.ImageColor3 = schemeVal end) then return true end
	end

	return false
end

local function findOne(root, pathOrName)
	-- supports "A/B/C" path (relative to root), or deep find by Name
	local current = root
	if string.find(pathOrName, "/") then
		for seg in string.gmatch(pathOrName, "([^/]+)") do
			current = current and current:FindFirstChild(seg) or nil
		end
		return current
	else
		local direct = root:FindFirstChild(pathOrName)
		if direct then return direct end
		for _,d in ipairs(root:GetDescendants()) do
			if d.Name == pathOrName then return d end
		end
	end
	return nil
end

local function resolveTargets(root, nameField)
	-- nameField can be "string" or { "A/B", "C/D", "PlainName" }
	local out = {}
	if type(nameField) == "string" then
		local t = findOne(root, nameField)
		if t then table.insert(out, t) end
	elseif type(nameField) == "table" then
		for _, s in ipairs(nameField) do
			local t = findOne(root, s)
			if t then table.insert(out, t) end
		end
	end
	return out
end


function Color_Mod:ApplyColors(Parent, SchemeName, Specs,TextInfo)
	assert(typeof(Parent) == "Instance", "Parent must be an Instance")
	local scheme = ColorSchemes[SchemeName]
	if not scheme then
		warn(("Color_Mod: scheme '%s' not found"):format(tostring(SchemeName)))
		return
	end
	TextInfo = TextInfo or {CanSetText=false,TextObjName="",Text=""}

	for _, spec in ipairs(Specs or {}) do
		local targets = resolveTargets(Parent, spec.Name)
		if #targets == 0 then
			warn(("Color_Mod: target(s) not found for %s"):format(typeof(spec.Name)=="table" and table.concat(spec.Name,", ") or tostring(spec.Name)))
		else

			local val = scheme[spec.Use]
			if val == nil then
				warn(("Color_Mod: scheme key '%s' missing in '%s'"):format(tostring(spec.Use), SchemeName))
			else
				for _, obj in ipairs(targets) do
					local ok = applyValue(obj, val,TextInfo)
					if not ok then
						warn(("Color_Mod: could not apply '%s' to %s (%s)"):format(tostring(spec.Use), obj.Name, obj.ClassName))
					end
				end
			end
		end
	end
end

-- optional getters if you want to tweak at runtime
function Color_Mod.GetScheme(name) return ColorSchemes[name] end
function Color_Mod.SetScheme(name, t) ColorSchemes[name] = t end

return Color_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{A43D9C81-CEC9-4823-8BBF-F85D7D7E6570}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">PodiumColors_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4D5C474A727F446588D9E282CD832416">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Models/UGC/Hallowen_UGCs_Config.lua
--
--  Description:
--      Configuration module for all Halloween UGC (User Generated Content) items.
--      It automatically parses and indexes UGC models located in
--      ReplicatedStorage.Models.UGC.Halloween_Models, extracting key metadata
--      from their names (index, title, detail, and asset key).
--      Also includes a helper function to verify UGC ownership on the server.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-11-01 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Models/UGC/Halloween_Models (container for UGC item models)
--      - Services:
--          * MarketplaceService
--
--  Notes:
--      - Item names must follow the pattern: "<index> / <title> / <detail> / <assetId>"
--      - Player_Owns_Item_UGC_ServerCheck retries up to 3 times for reliability
--      - Items are stored in HUC.HUGCItems, sorted by index and title
--      - Used for in-game validation and presentation of Halloween UGCs
--
--======================================================================

local MPS = game:GetService("MarketplaceService")
local RS = game:GetService("ReplicatedStorage")
local UGC_FOLDER = RS:WaitForChild("Models"):WaitForChild("UGC"):WaitForChild("Halloween_Models")


local HUC= {}
HUC.HUGCItems = {}

function HUC.Player_Owns_Item_UGC_ServerCheck(Plr, ID)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = MPS:PlayerOwnsAsset(Plr, ID)
		end)

		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end

	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end

	return false
end

local function parseName(name: string)
	-- title / detail / key
	local index,title, detail, key =  name:match("^(%d+)%s*/%s*([^/]+)%s*/%s*([^/]+)%s*/%s*(%d+)%s*$")
	return index,title, detail, key
end

local function rebuild()

	for _, inst in ipairs(UGC_FOLDER:GetChildren()) do
		local index, title, detail, key = parseName(inst.Name)

		table.insert(HUC.HUGCItems,{
			Index = tonumber(index),
			Key = key,
			Kind = "HallowenUGC",
			Title = title,
			RefName=inst.Name,
		})
	end
		table.sort(HUC.HUGCItems, function(a, b)
			local ia = a.Index or math.huge
			local ib = b.Index or math.huge
			if ia ~= ib then return ia < ib end
			return (a.Title or "") < (b.Title or "")
		end)
	--	print(("[UGCItemHelper] Refreshed. Items: %d"):format(#HUC.HUGCItems))
end

rebuild()

return HUC]]></ProtectedString>
						<string name="ScriptGuid">{595EEAFD-8FD8-47E0-B644-4D3ABEE98B54}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Hallowen_UGCs_Config.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX26C24F96E5CF41A4952180346EBEE527">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/League_Mod.lua
--
--  Description:
--      Central configuration module for all league-related data,
--      including progression order, point thresholds, colors, and
--      visual identifiers. Also defines promotion/demotion logic and
--      utility functions for retrieving league attributes.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-11-01 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - None (pure configuration module)
--
--  Notes:
--      - League_Mod.Order defines the progression from Unranked to Legend
--      - League_Mod.Config stores per-league metadata (color, emoji, LP)
--      - PromotionConfig controls tournament and promotion mechanics:
--          * TopPromotionCount, BottomDemotionCount
--          * LP rewards and duration of each cycle
--      - Utility functions provide safe access to league data and helpers
--        for determining next/previous ranks
--
--======================================================================

local League_Mod = {}

-- Ordered progression of leagues
League_Mod.Order = {
	"Unranked",
	"Bronze",
	"Silver",
	"Gold",
	"Emerald",
	"Diamond",
	"Platinum",
	"Legend",
}

-- Core configuration per league
League_Mod.Config = {
	Unranked = {
		color = Color3.fromRGB(80, 80, 80),
		emoji = "⚪",
		displayName = "Unranked",
		minPoints = 0,
	},
	Bronze = {
		color = Color3.fromRGB(205, 127, 50),
		emoji = "🥉",
		displayName = "Bronze",
		minPoints = 100,
	},
	Silver = {
		color = Color3.fromRGB(180, 180, 180),
		emoji = "🥈",
		displayName = "Silver",
		minPoints = 250,
	},
	Gold = {
		color = Color3.fromRGB(255, 215, 0),
		emoji = "🥇",
		displayName = "Gold",
		minPoints = 500,
	},
	Emerald = {
		color = Color3.fromRGB(0, 220, 100),
		emoji = "🌿",
		displayName = "Emerald",
		minPoints = 800,
	},
	Diamond = {
		color = Color3.fromRGB(0, 180, 255),
		emoji = "💎",
		displayName = "Diamond",
		minPoints = 1200,
	},
	Platinum = {
		color = Color3.fromRGB(120, 150, 255),
		emoji = "🧬",
		displayName = "Platinum",
		minPoints = 1600,
	},
	Legend = {
		color = Color3.fromRGB(255, 80, 180),
		emoji = "🏆",
		displayName = "Legend",
		minPoints = 2000,
	},
}

League_Mod.PromotionConfig = {
	-- Combien de joueurs montent ou descendent par division
	TopPromotionCount = 3,     -- les 3 premiers montent
	BottomDemotionCount = 3,   -- les 3 derniers descendent

	-- Seuils de points personnalisables
	BasePromotionPoints = 100,
	BaseDemotionPoints = 20,

	-- Récompenses de tournoi
	RewardPromo = 10,   -- LP gagnés par les promus
	RewardDemote = -5,  -- LP perdus par les relégués
	RewardBase = 0.5,   -- multiplicateur LP pour les autres
	TournamentDuration = 2 * 60 * 60, -- durée (2 heures)
}


--========================================================
-- Utility Functions
--========================================================

-- Get color safely
function League_Mod.GetColor(leagueName)
	local cfg = League_Mod.Config[leagueName]
	if cfg and cfg.color then
		return cfg.color
	end
	return Color3.fromRGB(80, 80, 80)
end

-- Get emoji safely
function League_Mod.GetEmoji(leagueName)
	local cfg = League_Mod.Config[leagueName]
	if cfg and cfg.emoji then
		return cfg.emoji
	end
	return ""
end

-- Get display name safely
function League_Mod.GetDisplayName(leagueName)
	local cfg = League_Mod.Config[leagueName]
	if cfg and cfg.displayName then
		return cfg.displayName
	end
	return "Unknown"
end

-- Get index of a league in the progression
function League_Mod.GetRankIndex(leagueName)
	for i, name in ipairs(League_Mod.Order) do
		if name == leagueName then
			return i
		end
	end
	return 1 -- default to Unranked
end

-- Get next league name
function League_Mod.GetNextLeague(current)
	local idx = League_Mod.GetRankIndex(current)
	return League_Mod.Order[idx + 1]
end

-- Get previous league name
function League_Mod.GetPreviousLeague(current)
	local idx = League_Mod.GetRankIndex(current)
	return League_Mod.Order[idx - 1]
end

-- Get base config table (deepcopy if needed)
function League_Mod.GetAll()
	return League_Mod.Config
end

return League_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{8B30EEEF-3324-4DA9-B9FF-AFBA9B210735}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">League_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE3C5D1B5891A4F3F8DAA9980ADF8BA2E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Bots_Mod.lua
--
--  Description:
--      Centralized module for all bot configuration data used in fight cages.
--      Each entry maps a cage identifier to a bot template and difficulty level.
--      The module also provides helper functions to retrieve the correct
--      bot folders in ServerStorage and Workspace, adapting to current themes.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-11-01 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Design/ThemeManager (for theme-based folder selection)
--      - ServerStorage:
--          * Training_Bots (contains bot template folders)
--      - Workspace:
--          * Main_World_F/Gameplay/Objects/Bots (workspace container)
--
--  Notes:
--      - Each Fight_Cage_X can define a unique bot setup (template, difficulty)
--      - ThemeManager determines which template folder ("Standard", "Halloween", etc.) to use
--      - Bots_Mod is used primarily by Bots_Manager for spawning and management
--
--======================================================================

local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)

local Bots_Mod = {

	cages = {
		["Fight_Cage_0"] = { Profile = "NORMAL" },
		["Fight_Cage_1"] = { Profile = "NORMAL" },
		["Fight_Cage_2"] = { Profile = "NORMAL" },
		["Fight_Cage_3"] = { Profile = "NORMAL" },
		["Fight_Cage_4"] = { Profile = "NORMAL" },
		["Fight_Cage_5"] = { Profile = "NORMAL" },
		["Fight_Cage_6"] = { Profile = "NORMAL" },
		["Fight_Cage_7"] = { Profile = "NORMAL" },
		["Fight_Cage_8"] = { Profile = "NORMAL" }
	},

	-- Define reusable profiles
	profiles = {
		NORMAL = {
			Template = "Training_Bot",
			DisplayName = "Greg Jackson",
			Behavior = "NORMAL"
		},
		COACH = {
			Template = "Coach_Bot",
			DisplayName = "George Saint-Pierre",
			Behavior = "COACH"
		},
		FEMALE = {
			Template = "Female_Bot",
			DisplayName = "Amanda Nunes",
			Behavior = "NORMAL"
		}
	}
}

function Bots_Mod.getProfileForCage(cageName)
	local cage = Bots_Mod.cages[cageName]
	if not cage then
		return Bots_Mod.getProfile("NORMAL")
	end
	return Bots_Mod.getProfile(cage.Profile)
end

function Bots_Mod.getProfile(profileName) 
	return Bots_Mod.profiles[profileName] or Bots_Mod.profiles["NORMAL"] 
end

-- Get the bots template folder according to the current theme
function Bots_Mod.getBotsTemplateFolder()
	if ThemeManager.getCurrentTheme() == "Halloween" then
		return game.ServerStorage:WaitForChild("Training_Bots"):WaitForChild("Halloween")
	else
		return game.ServerStorage:WaitForChild("Training_Bots"):WaitForChild("Standard")
	end

end

-- Get the bots workspace folder (where cloned bots are instantiated)
function Bots_Mod.getBotsWorkspaceFolder()
	local Main_World_F = game.Workspace:WaitForChild("Main_World_F")
	local Gameplay = Main_World_F:WaitForChild("Gameplay")
	local Objects = Gameplay:WaitForChild("Objects")
	return Objects:WaitForChild("Bots")
end

return Bots_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{988ACD31-DEE7-4599-B0E0-0468CFCFF055}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Bots_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1561CB76175C4BD3943529318E4D178A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[
--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Fight_Params_Mod.lua
--
--  Description:
--      Central configuration module defining all fight-related
--      gameplay parameters: health, stamina, punch power, block mechanics,
--      takedown rules, submission minigame settings, rewards, and cage types.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-05-12 by Darkzeb
--
--  Version: V2025-12
--
--  Used By:
--      - Fight_Service
--      - Cage_Factory
--      - Tournament_Manager
--      - Any system needing combat parameters
--
--  Notes:
--      - Pure configuration module (no functions).
--      - All values grouped by gameplay domain for clarity.
--      - CageType acts as an enum to prevent string errors.
--
--======================================================================

local Fight_Params_Mod = {
	
	------ PARAMETERS (WIP) -------
	Health = {
		Max_Value = 100,
		Reloading_Active = true,
		Reload_Time_Factor = 1.8 
	},
	
	Stamina = {
		Max_Value = 100,
		Reload_Time_Factor = 0.1,
		Min_To_Dodge = 7, 
		Min_To_Hit = 3,
		Min_To_Takedown = 15,
		Attempted_Takedown = 25
	},
	
	Block_Power = {
		Max_Value = 30, 
		Reload_Time_Factor = 0.2667,
		Reload_Delay = 6
	},
	
	Punch_Power={
		Max_Value = 1.5, 
		Min_Value = 0,
		Reload_Time = 2, 
		--Reload_Delay = 0.75
	},
	
	Takedown ={
		Min_Difference=5
	},
	
	Submission_Minigame = {
		Initial_Score = 25,
		Winning_Score = 50,
		Loosing_Score = 0,
		Bot_ClickDelay = 0.2,
		Coach_Bot_ClickDelay = 0.4,
	},
	
	CageClinch = {
		Active= false
	},
	
	-- every win fight rewards the player with cash
	Reward = {
		Standard_Win_Cash = 20,
		Ranked_Win_Cash = 25
	},
	
	CageType = {
		STANDARD = "STANDARD",
		RANKED   = "RANKED",
		TUTORIAL = "TUTORIAL",
		LEAGUE   = "LEAGUE"
	},
	
	Ranked_Arena_Required_Wins = 5
}

return Fight_Params_Mod
]]></ProtectedString>
						<string name="ScriptGuid">{54EF275C-F8AC-483A-A112-CCADA8FE22D2}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_Params_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX84248A6D6B254962BB7A6432A66C8FB4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local Workspace = game:GetService("Workspace")

local Tutorial_Mod = {
	Tour_Steps = {
		{
			title = "⭐ QUICK TOUR",
			txt = "Let's discover the <b>MMA Fighters</b> room 🥊! "
		},
		{
			title = "🏋️‍♂️ GYM",
			txt = "Go to the <b>Gym</b> 💪 to earn <b>Cash 💵</b>.",
			camera_key = "Gym_Cam_P"
		},
		{
			title = "👊 FIGHT",
			txt = "Enter a <b>Cage</b> 🦁 and fight a <b>bot 🤖</b> or a <b>player 🥊</b>.",
			camera_key = "Cages_Cam_P"
		},
		{
			title = "🏆 RANKED ARENA",
			txt = "Enter the <b>Ranked Arena</b> 🥇 and battle through <b>5 intense rounds</b> to climb your <b>Elo 📈</b>.",
			camera_key = "Arena_Cam_P"
		},
		{
			title = "⭐ LEADERBOARD",
			txt = "Check the <b>Global Leaderboard</b> 🌍 and climb to the top 🏅!",
			camera_key = "LB_Cam_P"
		},
		{
			title = "🛒 SHOP",
			txt = "Use <b>Cash 💵</b> and <b>Gems 💎</b> to buy items.",
			camera_key = "Shop_Cam_P"
		}
	},
	Menus_Tour_Steps = {
		{
			title = "🥊 COMBOS",
			txt = "Choose and equip your <b>combos</b> 🔥. Unlock more as you grow ⚡.",
			open_panel_event = "Open_Combos",
			hint = {
				InitialPos = UDim2.new(0.81,0,.03,0) ,
				FinalPos = UDim2.new(0.85,0,.03,0) ,
				Size = UDim2.new(.07,0,0.07,0) ,
				Rotation = -90,
			}
		},
		{
			title = "👤 AVATAR",
			txt = "Customize your fighter with <b>skins & outfits</b> ✨.",
			open_panel_event = "Open_Equipment",
			hint = {
				InitialPos = UDim2.new(0.81,0,.03,0) ,
				FinalPos = UDim2.new(0.85,0,.03,0) ,
				Size = UDim2.new(.07,0,0.07,0) ,
				Rotation = -90,
			}
		},
		{
			title = "🎁 SHOP ITEMS",
			txt = "Browse items and open <b>crates</b> 🎉 for rare rewards ⚡.",
			open_panel_event = "Open_Shop_UI",
			hint = {
				InitialPos = UDim2.new(.91,0,.03,0) ,
				FinalPos = UDim2.new(.95,0,.03,0) ,
				Size = UDim2.new(.07,0,0.07,0) ,
				Rotation = -90,
			}
		}
	},
	
	Basic_Fight_Steps = {
		{
			title = "WELCOME TO THE OCTOGON!";
			txt = "You’re about to fight your opponent: coach George Saint-Pierre.",
			image = "rbxassetid://105736152900143",
			next_button = true,
			visible_keys = {
				Punch =  false,
				Kick =  false, 
				Damage_Bar  = false,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		}, 
		{
			txt = "Move inside the cage with the joystick or the arrow keys.",
			next_button = false,
			next_condition = {
				Delay = 2,
				CharAttribute = "IsMoving",
				ExpectedValue = true
			},
			highlight = {
				Direction = {
					Mobile = {
						Stroke_Template = "Square_Stroke"
					}
				}
			},
			visible_keys = {
				Punch =  false,
				Kick =  false, 
				Damage_Bar  = false,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		},
		{
			title = "STRIKES",
			txt = "Punch your opponent to lower their health points.",
			image= "rbxassetid://139942312851229",
			next_button = false,
			next_condition = {
				Delay = 3,
				CharAttribute = "LastFightAction",
				ExpectedValue = "Punch"
			},
			highlight = { 
				Punch = {
					Mobile = {
						Stroke_Template = "Punching_B_Stroke",
						Hand_Indicator = {
							InitialPos =UDim2.new(.5,0,-0.147,0) ,
							FinalPos = UDim2.new(.5,0,-0.247,0) ,
							Size = UDim2.new(.347,0,0.5,0) ,
							Rotation = 180,
						}
					},
					Other = {
						Stroke_Template = "Square_Stroke"
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  false, 
				Damage_Bar  = false,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		},
		{
			txt = "You can also use kicks and knee strikes for more damages!",
			image= "rbxassetid://70645081883201",
			next_button = false,
			next_condition = {
				Delay = 2,
				CharAttribute = "LastFightAction",
				ExpectedValue = "Kick"
			},
			highlight = {
				Kick = {
					Mobile = {
						Stroke_Template = "Kicking_B_Stroke", 
						Hand_Indicator = {
							InitialPos =UDim2.new(0.5, 0,-0.094, 0) ,
							FinalPos = UDim2.new(.5,0,-0.194,0) ,
							Size = UDim2.new(.347,0,0.5,0) ,
							Rotation = 180,
						}
					},
					Other = {
						Stroke_Template = "Square_Stroke"

					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = false,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		},
		{
			txt = "The amount of health lost depends on the Damage bar. Try to hit at the perfect timing!",
			image= "rbxassetid://75029345195737",
			next_button = true,
			highlight = {
				Damage_Bar_Gauge = { 
					Stroke_Template = "Damage_Bar_Stroke",
					Y_Offset = .45,
					Hand_Indicator = {
						InitialPos =UDim2.new(0.595, 0,0.118, 0) ,
						FinalPos = UDim2.new(0.595, 0,0.018, 0) ,
						Size = UDim2.new(0.254, 0,0.5,0) ,
						Rotation = 180,
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		},
		{
			title = "HEALTH",
			txt = "Your health points are shown at the top in green. \nThe first one to reach zero loses the round.",
			next_button = true,
			highlight = {
				Health_Bar = {
					Stroke_Template = "Square_Stroke", 
					Hand_Indicator = {
						InitialPos =UDim2.new(0.734, 0,1.511, 0) ,
						FinalPos = UDim2.new(0.734, 0,1.711, 0) ,
						Size = UDim2.new(1.5, 0,1.5, 0) ,
						Rotation = 0,
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		},
		{
			title = "STAMINA",
			txt = "You lose stamina every time you strike, be careful not to exhaust yourself!",
			image= "rbxassetid://75029345195737",
			next_button = true,
			highlight = {
				Stamina_Bar = {
					Stroke_Template = "Square_Stroke",
					Y_Offset = 0.53,
					Hand_Indicator = {
						InitialPos =UDim2.new(0.734, 0,1.511, 0) ,
						FinalPos = UDim2.new(0.734, 0,1.711, 0) ,
						Size = UDim2.new(1.5, 0,1.5, 0) ,
						Rotation = 0,
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = false,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = false
			}
		},
		{
			txt = "To recharge your stamina and block the incoming attacks, hold the blocking shield.",
			tips = "the shield recharges after a few seconds.",
			image= "rbxassetid://80173980511775",
			next_button = false,
			next_condition = {
				Delay = 3,
				CharAttribute = "LastFightAction",
				ExpectedValue = "Block"
			},
			highlight = {
				Block = {
					Mobile = {
						Stroke_Template = "Round_Stroke",
						Y_Offset = 0.46,
						Hand_Indicator= {
							InitialPos =UDim2.new(-0.271, 0,0.491, 0) ,
							FinalPos = UDim2.new(-0.371, 0,0.491, 0) ,
							Size = UDim2.new(0.533, 0,0.803, 0) ,
							Rotation = 90,
						}
					},
					Other = {
						Stroke_Template = "Square_Stroke"
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = true,
				Dodge = false,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = true
			}
		},
		{
			title= "DODGE",
			txt = "You can also avoid your opponent’s attacks by dodging.",
			tips = "you dodge in the direction you’re moving (or randomly if you're standing still).",
			image= "rbxassetid://88026216056179",
			next_button = false,
			next_condition = {
				Delay = 2,
				CharAttribute = "LastFightAction",
				ExpectedValue = "Dodge"
			},
			highlight = {
				Dodge = {
					Mobile = {
						Stroke_Template = "Round_Stroke",
						Y_Offset = 0.46,
						Hand_Indicator= {
							InitialPos =UDim2.new(-0.271, 0,0.491,0 ) ,
							FinalPos = UDim2.new(-0.371, 0,0.491, 0) ,
							Size = UDim2.new(0.533, 0,0.803, 0) ,
							Rotation = 90,
						}
					},
					Other = {
						Stroke_Template = "Square_Stroke"
					}
				},
				Direction = {
					Mobile = {
						Stroke_Template = "Square_Stroke"
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = true,
				Dodge = true,
				Takedown_Progress = false,
				Takedown  = false,
				Shield = true
			}
		},
		{
			title = "TAKEDOWN",
			txt = "Try to take the advantage over your opponent. ",
			tips="you can try for a Takedown when you have more than 5 hits ahead of him.",
			image= "rbxassetid://123246640429196",
			next_button = false,
			next_condition = "TakedownAvailable",
			highlight = {
				Takedown_Progress = {
					Stroke_Template = "Round_Stroke",
					Y_Offset = 0.46,
					Hand_Indicator= { 
						InitialPos =UDim2.new(0.498, 0, 0, 0) ,
						FinalPos = UDim2.new(0.498, 0,0.1, 0) ,
						Size = UDim2.new(0.533, 0,0.803, 0) ,
						Rotation = 0,
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = true,
				Dodge = true,
				Takedown_Progress = true,
				Takedown  = false,
				Shield = true
			}
		},
		{
			txt = "Go ahead, you can attempt a submission!",
			image= "rbxassetid://93493048884345",
			next_button = false,
			next_condition = {
				Delay = 0,
				CharAttribute = "LastFightAction",
				ExpectedValue = "Takedown"
			},
			highlight = {
				Takedown = {
					Mobile = {
						Stroke_Template = "Round_Stroke",
						Y_Offset = 0.46,
						Hand_Indicator= {
							InitialPos =UDim2.new(0.498, 0,-0.4, 0) ,
							FinalPos = UDim2.new(0.498, 0,-0.5, 0) ,
							Size = UDim2.new(0.533, 0,0.803, 0) ,
							Rotation = 180,
						}
					},
					Other = {
						Stroke_Template = "Square_Stroke"
					}
				}
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = true,
				Dodge = true,
				Takedown_Progress = true,
				Takedown  = true,
				Shield = true
			}
		},
		{
			title = "SUBMISSION",
			txt = "Tap as fast as you can to win the submission! You will instantly win the round!",
			image= "rbxassetid://93493048884345",
			next_button = false,
			next_condition = {
				Delay = 0,
				CharAttribute = "LastFightAction",
				ExpectedValue = "Submission"
			},
			visible_keys = {
				Punch =  true,
				Kick =  true, 
				Damage_Bar  = true,
				Block = true,
				Dodge = true,
				Takedown_Progress = true,
				Takedown  = true,
				Shield = true
			}
		},
		{
			title = "CONGRATS",
			txt = "You've learned all the secrets of combat. Now, you're ready to fight!",
			next_button = true
		}
	}
}

function Tutorial_Mod:GetTutorialPartsFolder()
	return game.Workspace.Main_World_F.Gameplay.Objects.Tutorial_Parts_F
end


return Tutorial_Mod]]></ProtectedString>
						<string name="ScriptGuid">{35D221C5-16C1-4706-8CF5-4A747AD2E056}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tutorial_Mod.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX979F41A019C948C984F607DFEDCB5BF8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Data_Mods_F/Cage_Factory.lua
--
--  Description:
--      Factory module responsible for creating, allocating, stacking,
--      and cleaning up temporary fight cages (tutorial, league, standard).
--      Handles vertical slot management to avoid collisions, timed
--      automatic cleanup, and cage-type routing.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-05-12 by Darkzeb
--
--  Version: V2025-12
--
--  Dependencies:
--      - Roblox Services:
--          * ReplicatedStorage
--          * Players
--          * Workspace
--          * Debris
--      - Modules:
--          * Fight_Params_Mod (cageType enum)
--
--  Used By:
--      - Tournament_Manager
--      - Fight_Service
--
--  Notes:
--      - Vertical slot allocator prevents cage overlap.
--      - Cages auto-despawn after MaxDuration (Debris).
--      - Slot is automatically released when a cage is removed.
--      - Supports: Tutorial, League, Standard cages.
--
--======================================================================


local RS = game:GetService("ReplicatedStorage")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")

local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))

local Cage_Factory = {
	Standard_Cage_Folder = game.Workspace.Main_World_F.Gameplay.Objects.Fight_Cages_F,
		
	Tournament_TemplateFolder = RS:WaitForChild("Models"):WaitForChild("Tournaments"),
	Tournament_Cage_Folder = game.Workspace.Main_World_F.Gameplay.Objects.Tournament,
	Tournament_Template = "TournamentCage", 
	
	Tutorial_TemplateFolder = RS:WaitForChild("Models"):WaitForChild("Tutorial"),
	Tutorial_Cages_Folder = game.Workspace.Main_World_F.Gameplay.Objects.Tutorial_Parts_F.Tutorial_Cages,
	Tutorial_Template = "TutorialCage", 
	
	SLOTS_FREE = {},             -- free slot stack
	SLOTS_NEXT = 0,              -- next new slot index
	MaxDuration = 10 * 60 -- 10 minutes max per fight (safety cleanup)
}

-- ==========================================================
-- UTILS
-- ==========================================================
--------------------------------------------------------------------
-- Slot allocator: ensures no collision and reused vertical slots ---
--------------------------------------------------------------------
function Cage_Factory:GetFreeSlot()
	if #self.SLOTS_FREE > 0 then
		-- reuse a previously freed slot
		local slot = table.remove(self.SLOTS_FREE) -- pop last
		return slot
	end

	-- allocate new slot if no free slot available
	self.SLOTS_NEXT += 1
	return self.SLOTS_NEXT
end

function Cage_Factory:ReleaseSlot(slot)
	table.insert(self.SLOTS_FREE, slot)
end

-- Creates a new arena instance for a fight
function Cage_Factory:CreateCage(cageType)
	local template = nil
	local parent = nil
	if cageType == Fight_Params_Mod.CageType.TUTORIAL then
		local folder = Cage_Factory.Tutorial_TemplateFolder
		template = folder:FindFirstChild(Cage_Factory.Tutorial_Template)
		parent = Cage_Factory.Tutorial_Cages_Folder

	elseif cageType == Fight_Params_Mod.CageType.LEAGUE then		
		local folder = Cage_Factory.Tutorial_TemplateFolder
		template = folder:FindFirstChild(Cage_Factory.Tournament_Template)
		parent = Cage_Factory.Tournament_Cage_Folder
	else
		-- TODO
	end
	
	local cage = template:Clone()
	cage.Parent = parent
	cage.Name = ("%s_%d"):format(cageType, math.random(1000, 9999))
	cage:SetAttribute("Is_Tournament", cageType == Fight_Params_Mod.CageType.LEAGUE)

	-- allocate vertical slot
	local slot = self:GetFreeSlot()
	cage:SetAttribute("Slot", slot)

	local baseHeight = 0
	local stackOffset = 100
	local y = baseHeight + (slot * stackOffset)

	cage:SetPrimaryPartCFrame(CFrame.new(0, y, 0))

	-- cleanup after timeout
	Debris:AddItem(cage, Cage_Factory.MaxDuration)

	-- when cage is removed, free its slot
	cage.AncestryChanged:Connect(function(_, parent)
		if not parent then
			local usedSlot = cage:GetAttribute("Slot")
			if usedSlot then
				self:ReleaseSlot(usedSlot)
			end
		end
	end)

	return cage
end

-- Destroys the arena when the fight is over
function Cage_Factory:DestroyArena(arenaName)

	local arena = Cage_Factory.Tournament_Cage_Folder:FindFirstChild(arenaName)
	if not arena or not arena.Parent then
		warn("[ARENA] No valid arena found for cleanup.")
		return
	end

	-- Log plus explicite
	if arena:GetAttribute("Is_Tournament") then
		print(string.format("[ARENA] Cleaning up tournament arena: %s", arena.Name))
	else
		print(string.format("[ARENA] Cleaning up regular arena: %s", arena.Name))
	end

	-- Nettoyage défensif
	pcall(function()
		arena:Destroy()
	end)
end

function Cage_Factory:getCageFolder(cageType)
	if cageType == Fight_Params_Mod.CageType.TUTORIAL then
		return Cage_Factory.Tutorial_Cages_Folder
	elseif cageType == Fight_Params_Mod.CageType.LEAGUE then
		return Cage_Factory.Tournament_Cage_Folder
	elseif cageType == Fight_Params_Mod.CageType.STANDARD then
		return Cage_Factory.Standard_Cage_Folder
	else
		warn("Unsupported cageType: "..cageType)
	end
end



return Cage_Factory]]></ProtectedString>
						<string name="ScriptGuid">{DE23A127-6A7D-4A1E-81C4-45FFEE961568}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Cage_Factory.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX8A454990BA7B44659B0D496B65F19B7C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Bot_Behaviors</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXC8AADE42EF4B45EDBBF94D6935BCB0BC">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Modules/Behaviors/NORMAL.lua
--
--  Description:
--      Behavior module defining the "NORMAL" AI used for training fights.
--      Provides full combat behavior logic including:
--          • Movement & player tracking
--          • Striking, blocking, dodging
--          • Hit reactions, stamina/health handling
--          • Submission logic & cage clinch interactions
--          • Animation orchestration and damage application
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-12-05 by Darkzeb
--
--  Version: V2025-12
--
--  Dependencies:
--      - Roblox Services:
--          * RunService
--          * TweenService
--          * ReplicatedStorage
--          * Debris
--
--      - Modules:
--          * Utils
--          * Channels (RemoteEvents & Bindables)
--          * Animation_Mod
--          * Sound_Mod
--          * Stats_Manager_Mod
--          * Fight_Params_Mod
--
--  Used By:
--      - Bots_Manager (injects this behavior when spawning training bots)
--      - Fight_Service
--
--  Notes:
--      - AI maintains its own registry (_registry) for instance tracking.
--      - Fully autonomous decision-making:
--          ✔ dodges based on raycast distance
--          ✔ reacts to player attacks
--          ✔ manages strike combos, block logic, stamina regen
--      - Submission & clinch sequences use specialized animation tracks.
--      - Large module: logic is intentionally server-side for determinism.
--
--======================================================================
local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")

local Channels = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Overhead_Display = Channels.SC_Remote_Events.Overhead_Display
local Got_Hit_Effect = Channels.SC_Remote_Events.Got_Hit_Effect
local AI_Training_Cage_Clinch = Channels.Bindable_Events.AI_Training_Cage_Clinch
local AI_Training_Submission = Channels.Bindable_Events.AI_Training_Submission
local Ragdoll_Player = Channels.Bindable_Events.Ragdoll_Player

local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))

local NORMAL_Behavior = {}
NORMAL_Behavior.__index = NORMAL_Behavior
NORMAL_Behavior._registry = {}


function NORMAL_Behavior.new()
	local self = setmetatable({}, NORMAL_Behavior)
	self.Cons = {}
	return self
end

function NORMAL_Behavior:Init(_plr, _botModel)
	self.player = _plr
	self.Bot = _botModel
	NORMAL_Behavior._registry[_botModel] = self
end

function NORMAL_Behavior:StartFight()
	local HRP = nil
	local Hum = nil
	local Head =nil
	local Fight_Data_F = nil
	local Stamina_V = nil
	local Fight_UI = nil
	local Health_V =nil
	local Stam_V = nil
	local Block_Power_V = nil
	local Strike_Power_V = nil
	local Fight_Walkspeed = 12
	local Is_Active = false

	if self.Bot and self.Bot:IsA("Model") then
		-- set body parts
		HRP = self.Bot:FindFirstChild("HumanoidRootPart")
		Hum = self.Bot:FindFirstChildWhichIsA("Humanoid")
		Head = self.Bot:FindFirstChild("Head")
		-- fight data folder
		Fight_Data_F = self.Bot:FindFirstChild("Fight_Data")
		if Fight_Data_F ~= nil then
			Health_V = Fight_Data_F:FindFirstChild("Health")
			Stam_V = Fight_Data_F:FindFirstChild("Staminia")
			Block_Power_V = Fight_Data_F:FindFirstChild("Block Power")
			Strike_Power_V = Fight_Data_F:FindFirstChild("Strike Power")
			-- use Stam_V for stamina regen logic
			Stamina_V = Stam_V
		end
		-- store current fight UI if present
		Fight_UI = self.Bot:FindFirstChild("Fighting_UI")
	end
	
	-- Direct stamina regeneration for bot (server-side)
	local function Reload_Stamina()
		while Stamina_V.Value < 40 do
			Stamina_V.Value = math.min(Stamina_V.Value + 1, 100) -- regen step, adjust as needed
			task.wait(0.1)
		end
	end

	local function Disconnect_Cons()
		for i = 1, #self.Cons do
			if(self.Cons[i] ~= nil)then
				self.Cons[i]:Disconnect()
			end
		end
		table.clear(self.Cons)
	end

	local function Get_Fighting_UI()
		local Fight_UI = self.Bot:FindFirstChild("Fighting_UI")
		if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
			local Main_F = Fight_UI:FindFirstChild("Main_F") 
			local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
			if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
				return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
			end
		end
		return nil, nil
	end

	local function Reset_AI()
		Disconnect_Cons()

		Health_V.Value = Fight_Params_Mod.Health.Max_Value
		Stam_V.Value = Fight_Params_Mod.Stamina.Max_Value
		Block_Power_V.Value = Fight_Params_Mod.Block_Power.Max_Value
		Strike_Power_V.Value = Fight_Params_Mod.Punch_Power.Max_Value

		if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
			HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
		end

		if(Hum ~= nil)then
			Hum.AutoRotate = false
			Hum.WalkSpeed = 12
			Hum.JumpPower = 0

			Animation_Mod.Reset_Character_Animations(self.Bot)

			Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
			Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
			Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
		end

		self.Bot:SetAttribute("Is_Fighting", false)
		Is_Active = false
	end
	
	-- determine which player and character to fight
	-- prefer explicit arguments, fall back to stored values
	local T_Plr = self.player 
	if not T_Plr then return end
	local T_Char =  self.player.Character
	if not T_Char then return end
	-- cache parts from the opponent
	local T_HRP = T_Char:WaitForChild("HumanoidRootPart")
	local T_Fight_Data = T_Plr:FindFirstChild("Fight_Data")
	if not T_Fight_Data then return end
	local T_Health_V = T_Fight_Data:WaitForChild("Health")
	--local T_Stam_V = T_Fight_Data:WaitForChild("Staminia")
	--local T_Block_Power_V = T_Fight_Data:WaitForChild("Block Power")
	local T_Strike_Power_V = T_Fight_Data:WaitForChild("Strike Power")
	local Is_Submission = false

	self.Bot:SetAttribute("Is_Fighting", true)
	Reset_AI()
	Is_Active = true

	--Fight Data Changes
	table.insert(self.Cons, Health_V.Changed:Connect(function()
		if(self.Bot ~= nil and Health_V.Value <= 0)then
			Ragdoll_Player:Fire(self.Bot)
		end
	end))

	local function Create_BG()
		local OldG = HRP:FindFirstChildWhichIsA("BodyGyro")
		if(OldG ~= nil)then
			OldG:Destroy()
		end

		local bodyG = Instance.new("BodyGyro", HRP)
		bodyG.P = 1000
		bodyG.MaxTorque = Vector3.new(0, 1000, 0)
		bodyG.D = 10

		return bodyG
	end
	local BG = Create_BG()

	local function Movement_Handle()
		local function Update_Player_Movement()
			local function Get_Target_Position()
				if(T_HRP ~= nil)then
					local Move_Speed = T_HRP.Velocity
					local Def_Pos = T_HRP.Position + T_HRP.CFrame.LookVector * 3.5

					if(math.floor(Move_Speed.Magnitude) <= 0)then
						return Def_Pos, T_HRP.Position
					else
						local Ping = T_Plr:GetNetworkPing()
						local Dir = Move_Speed.Unit
						local Speed = Move_Speed.Magnitude
						local Extrapolated_Pos = Def_Pos + Dir * (Speed * Ping)
						local Travel_Time = ((Extrapolated_Pos - HRP.Position).Magnitude) / Hum.WalkSpeed
						return Extrapolated_Pos + Dir * (Hum.WalkSpeed * Travel_Time), Extrapolated_Pos
					end
				end

				return HRP.Position, HRP.Position + HRP.CFrame.LookVector * 3
			end
			local Move_Pos, Look_Pos = Get_Target_Position()

			BG.CFrame = CFrame.new(HRP.Position, Look_Pos)
			Hum:MoveTo(Move_Pos)
		end

		table.insert(self.Cons, RunService.Stepped:Connect(function()
			if(BG ~= nil and HRP ~= nil and Hum ~= nil and Hum.PlatformStand == false and T_Plr ~= nil and T_HRP ~= nil)then
				if(T_Health_V ~= nil and T_Health_V.Value > 0 and Is_Submission == false)then
					Update_Player_Movement()
				else
					Hum:MoveTo(HRP.Position)
				end
			end
		end))

		table.insert(self.Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
			if(Hum.PlatformStand == true)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			else
				BG.P = 1000
				BG.MaxTorque = Vector3.new(0, 1000, 0)
				BG.D = 10
			end
		end))
	end
	Movement_Handle()

	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
		Damage_UIG.Offset = Vector2.new(0, -0.5)
		Damage_Bar_Img.Visible = false
	end

	local function Create_Anim_Arr_Data(Anim_Track_Data)
		local D = {}
		for Key, Anim_Track in next, Anim_Track_Data do
			table.insert(D, Anim_Track)
		end
		return D
	end

	local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	local Combo_Strike_Index = 1
	local Combo_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(T_Plr, Hum, "Bot Combo")
	local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)

	local Debounce_Striking = false
	local Debounce_Dodge = false
	local Debounce_Blocking = false
	--local Debounce_Takedown = false
	local Is_Hit = false

	local function Striking_Movement_Handle()
		--> Update Movement, Moving Forward or Backwards | Moving Left to Right | Standing Idle
		--> Track Humanoid MoveDirection
		table.insert(self.Cons, Hum:GetPropertyChangedSignal("WalkToPoint"):Connect(function()
			local Move_Speed = math.floor(HRP.Velocity.Magnitude)
			if(Move_Speed > 3 and Anim_Track_Data['Shuffle Forward'].IsPlaying == false)then
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				Anim_Track_Data['Shuffle Forward']:Play()
				Anim_Track_Data['Shuffle Forward']:AdjustSpeed(-1)

			elseif(Move_Speed <= 3 and 
				(Anim_Track_Data['Shuffle Forward'].IsPlaying == true or 
					Anim_Track_Data['Shuffle Side'].IsPlaying == true))then

				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
			end
		end))

		Anim_Track_Data['Idle']:Play()
		Anim_Track_Data['Idle']:AdjustSpeed(0.5)
	end
	Striking_Movement_Handle()

	local function On_Hit_Effects()
		--[[
			* When Health goes Down!
				> Camera Shake Effects
					-> Quick Shake
				> Apply Hit Effects
					-> Reset all Animations, Play the Hit One
				> Set Debounce till Hit Effect goes Away
		]]--

		local Prev_Health = Health_V.Value
		local Hit_Anim_Track = Striking_Anim_Tracks['Taking Hit']

		local function Show_Sweat_Effects()
			if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
				local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
				local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
				if(PE ~= nil)then
					PE:Emit(25)
				end
			end
		end

		table.insert(self.Cons, Health_V.Changed:Connect(function()
			local Current_V = Health_V.Value
			if(Current_V < Prev_Health and Is_Hit == false)then
				Is_Hit = true

				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Show_Sweat_Effects()

				task.spawn(function()
					Animation_Mod.Play_Animation_Track(Hit_Anim_Track)
					Is_Hit = false
				end)
			end

			Prev_Health = Current_V
		end))
	end
	On_Hit_Effects()

	local function Blocking_Effects()
		--[[
			* On Sheild Blocking Power goes down (Greater than 0) and Debounce_Blocking == true
			* Get the Opponent Handed Type
				> Play the Coresponding Animation
		]]--

		local Prev_Blocking = Block_Power_V.Value
		local Tween_Health_Con = nil
		local Tween_Stam_Con = nil
		local Tween_Block_Con = nil
		Block_Power_V:SetAttribute("Is_Blocking", false)

		local function Reset_Healing_Cons()
			if(Tween_Health_Con ~= nil)then
				Tween_Health_Con:Cancel()
				Tween_Health_Con = nil
			end

			if(Tween_Stam_Con ~= nil)then
				Tween_Stam_Con:Cancel()
				Tween_Stam_Con = nil
			end
		end

		local function Create_Reload_Tween (Value, Max, Speed)
			local Delta = Max - Value.Value
			local Reload_Time = math.clamp(Delta, 1, Fight_Params_Mod.Health.Max_Value) * Speed
			local Tween = TweenInfo.new(Reload_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
			return TS:Create(Value, Tween, {Value = Max})
		end

		local function Set_Healing_Cons()
			local Health_Params = Fight_Params_Mod.Health
			if Health_Params.Reloading_Active then
				Tween_Health_Con = Create_Reload_Tween(Health_V, Health_Params.Max_Value, Health_Params.Reload_Time_Factor)
				Tween_Health_Con:Play()
			end

			local Stam_Params = Fight_Params_Mod.Stamina
			Tween_Stam_Con = Create_Reload_Tween(Stam_V, Stam_Params.Max_Value, Stam_Params.Reload_Time_Factor)
			Tween_Stam_Con:Play()
		end

		table.insert(self.Cons, Block_Power_V.AttributeChanged:Connect(function(Attrib_Key)
			if(Attrib_Key == "Is_Blocking" and Block_Power_V:GetAttribute("Is_Blocking") ~= nil)then
				Reset_Healing_Cons()
				if(Block_Power_V:GetAttribute("Is_Blocking") == true)then
					Set_Healing_Cons()
				end
			end
		end))


		local function Update_Fight_Block_UI()
			if(Fight_UI ~= nil and Block_Power_V ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil and 
				Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then

				local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
				local Img = Sheild_F:FindFirstChild("Shield_Img")
				local Txt = Sheild_F:FindFirstChild("Shield_Txt")

				if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
					local UIG = Img:FindFirstChildWhichIsA("UIGradient")
					local Block_Power = Block_Power_V.Value
					local Dif =  math.clamp(Block_Power / 30, 0, 1)
					local Offset_Pos_Y = (1 - Dif) - 0.5

					UIG.Offset = Vector2.new(0, Offset_Pos_Y)
					Txt.Text = Block_Power .. ""
					if(Dif <= 0.25)then
						Txt.TextColor3 = Color3.new(1, 0, 0)
					else
						Txt.TextColor3 = Color3.new(1, 1, 1)
					end

				end
			end

		end

		table.insert(self.Cons, Block_Power_V.Changed:Connect(function()
			local Current_V = Block_Power_V.Value
			if(Current_V > 0 and Current_V < Prev_Blocking and Debounce_Blocking == true)then
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Striking_Anim_Tracks['Body Block Left'])

				if(Block_Power_V.Value < 30)then
					if(Tween_Block_Con ~= nil)then
						Tween_Block_Con:Cancel()
						Tween_Block_Con = nil
					end

					local Block_Time = math.clamp((30 - Block_Power_V.Value) * 0.2667, 0.2667, 8)
					local Tween_Block_Power = TweenInfo.new(Block_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 6)
					Tween_Block_Con = TS:Create(Block_Power_V, Tween_Block_Power, {Value = 30})
					Tween_Block_Con:Play()
					Tween_Block_Con.Completed:Wait()
					Tween_Block_Con = nil
				end
			end

			Update_Fight_Block_UI()
			Prev_Blocking = Current_V

		end))

	end
	Blocking_Effects()

	local function Get_Core_Strike_Handles()
		local Funcs = {}
		SE_Mod.PlaySFX(T_Plr, "Punch_Woosh_SE")

		local function Has_Enough_Stam(Min_V)
			if(Stam_V ~= nil and Stam_V.Value >= Min_V)then
				Stam_V.Value -= Min_V
				return true
			end
			return false
		end

		local function Get_Player_To_Hit()
			local Whitelist_Chars = {T_Char}
			local Overlap_P = OverlapParams.new()
			Overlap_P.MaxParts = 1
			Overlap_P.FilterType = Enum.RaycastFilterType.Include
			Overlap_P.FilterDescendantsInstances = {Whitelist_Chars}

			local function Create_Region_CF()
				local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
				local Distance = (Speed + 3)
				--local Head_Dir = Head.CFrame.LookVector
				--local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

				local cframe = HRP.CFrame * CFrame.new(0, 0, -3)
				return cframe
			end
			local Spawn_CF = Create_Region_CF()
			local Hitbox_Size = Vector3.new(4, 8, 4)

			--local function Create_Hitbox_Part()
			--	local P = Instance.new("Part", game.Workspace)
			--	P.Name = "Hitbox_Part"
			--	P.Anchored = true
			--	P.CanCollide = false
			--	P.Transparency = 0.5
			--	P.Color = Color3.new(1, 0, 0)
			--	P.Material = Enum.Material.SmoothPlastic
			--	P.Size = Hitbox_Size
			--	P.CFrame = Spawn_CF

			--	Debris:AddItem(P, 5)
			--end
			--Create_Hitbox_Part()

			local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
			if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
				local function Get_Char_From_BP()
					for i = 1, #Whitelist_Chars do
						local C = Whitelist_Chars[i]
						if(C ~= nil and Region_Data[1]:IsDescendantOf(C))then
							return C
						end
					end

					return Whitelist_Chars[1]
				end

				return Get_Char_From_BP()
			end

			return nil
		end

		local function Get_Punch_Power(delay)
			local Params = Fight_Params_Mod.Punch_Power

			local Tween_Punch_Power_Back = TweenInfo.new(Params.Reload_Time, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, delay)
			local Strike_Power = Strike_Power_V.Value
			Strike_Power_V.Value = Params.Min_Value
			TS:Create(Strike_Power_V, Tween_Punch_Power_Back, {Value = Params.Max_Value}):Play()
			return Strike_Power
		end

		local function Get_Target_Fight_Data(Hit_Char)
			local Hit_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
			if(Hit_Plr ~= nil)then
				return Hit_Plr:FindFirstChild("Fight_Data")
			else
				return Hit_Char:FindFirstChild("Fight_Data")
			end
		end

		function Funcs.Strike_Handle()
			if Stamina_V.Value < 20 then Reload_Stamina() end
			--[[
				* Play Woosh Sound Effect locally
				* Play Animation
				* Tell the Server that you are Striking
			]]--

			Debounce_Striking = true
			-- AI is Striking!
			SE_Mod.PlaySFX(T_Plr, "Punch_Woosh_SE")

			local function Play_Strike_Animation()
				local Track = Combo_Anim_Arr[Combo_Strike_Index]
				local Key = Track:GetAttribute("Strike_Key") or "A"

				task.spawn(function()
					if(HRP ~= nil and Has_Enough_Stam(10))then

						local Hit_Char = Get_Player_To_Hit()
						local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Key)

						local Damage_Multi = Get_Punch_Power(Strike_Data['Time Length'])
						local Strike_Damage = Strike_Data['Damage']
						local Punch_Power = math.round(Strike_Damage * Damage_Multi)

						if(Hit_Char ~= nil)then
							local Hit_Fight_Data = Get_Target_Fight_Data(Hit_Char)
							if(Hit_Fight_Data ~= nil and Hit_Fight_Data:FindFirstChild("Health") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Block Power") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Staminia") ~= nil)then

								local T_Health = Hit_Fight_Data:FindFirstChild("Health")
								local T_Block_Power = Hit_Fight_Data:FindFirstChild("Block Power")
								local T_Staminia = Hit_Fight_Data:FindFirstChild("Staminia")

								local function Is_Dodging_Check()
									local Is_Dodging = T_Staminia:GetAttribute("Is_Dodging")
									if(Is_Dodging ~= nil and Is_Dodging == true)then
										local Target_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if(Target_Plr ~= nil)then
											Stats_Manager_Mod.Add_To_Player_Stats_Data(Target_Plr, "Dodged Strikes", 1)
										end

										return true
									end
									return false
								end

								local function Is_Blocking_Check()
									local Is_Block = T_Block_Power:GetAttribute("Is_Blocking")
									if(Is_Block ~= nil and Is_Block == true)then
										T_Block_Power.Value -= Punch_Power
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.fromRGB(170, 85, 255))

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										if(T_Block_Power.Value < 0)then
											local Dif = math.abs(T_Block_Power.Value)
											T_Health.Value = math.clamp(T_Health.Value - Dif, 0, 100)
											T_Block_Power.Value = 0

											SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
											--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)

											Overhead_Display:FireAllClients(Hit_Char, "-" .. Dif, Color3.new(1, 0, 0))

										else
											SE_Mod.PlaySFX(HRP, "Blocked_Hit_SE")	
										end

										return true
									end

									return false
								end

								if(Is_Dodging_Check())then
									--Play Dodging Text
									Overhead_Display:FireAllClients(Hit_Char, "Dodged", Color3.fromRGB(35, 244, 68))
								elseif(Is_Blocking_Check())then
									--Play Blocking 
								else
									--Apply the Hit
									local function Apply_Strike()
										T_Health.Value = math.clamp(T_Health.Value - Punch_Power, 0, 100)
										SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
										--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.new(1, 0, 0))
										--Punch_Hit_VFX:FireClient(Plr, Hit_Char)
										--Play Damage Val Show

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										local T_HRP = Hit_Char:FindFirstChild("HumanoidRootPart")
										if(T_HRP ~= nil)then
											local Hit_Force = 625 -- Was 350 then 500
											local Dir = HRP.CFrame.LookVector 
											T_HRP:ApplyImpulse(Dir * Hit_Force * T_HRP:GetMass())
										end
									end
									Apply_Strike()
								end
							end

						end
					end
				end)

				Combo_Strike_Index += 1
				if(Combo_Strike_Index > #Combo_Anim_Arr)then
					Combo_Strike_Index = 1
				end

				Animation_Mod.Stop_Animation_Tracks(Combo_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Track)
			end
			task.spawn(Play_Strike_Animation)
			task.wait(0.5)

			Debounce_Striking = false
		end

		local Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left']
		local Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		local Back_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		function Funcs.Dodge_Handle(Dodge_Type)
			--[[
				* Get the Type First
					-> First Index? Just play the Slip Animation
					-> 2nd Index? Play the Dodge Animation AND apply Force to the Player in the direction
				
					-> Tell the Server that you are Dodging and should reduce Staminia Value
			]]--

			Debounce_Dodge = true
			-- AI is Dodging

			local function Apply_Force(Dir)
				HRP:ApplyImpulse(Dir * (Fight_Walkspeed * 65) * HRP:GetMass())
			end

			task.spawn(function()
				if(Has_Enough_Stam(5))then
					--Play the Sound Effect
					--Toggle Value
					SE_Mod.PlaySFX(HRP, "Missed_SE")
					Stam_V:SetAttribute("Is_Dodging", true)
					task.wait(0.5)
					Stam_V:SetAttribute("Is_Dodging", false)
				end
			end)
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})

			local function Increment_Anim()
				if(Dodge_Type == "Dodge Left")then
					if(Left_Dodge_Ani == Striking_Anim_Tracks['Slip Left'])then
						Left_Dodge_Ani = Striking_Anim_Tracks['Headblock Left']
					else
						Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left'] 
					end
				else
					--Right
					if(Right_Dodge_Ani == Striking_Anim_Tracks['Slip Right'])then
						Right_Dodge_Ani = Striking_Anim_Tracks['Headblock Right']
					else
						Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right'] 
					end
				end
			end

			if(Dodge_Type == "Dodge Left")then
				--Left
				if(Left_Dodge_Ani == Striking_Anim_Tracks['Headblock Left'])then
					--Apply_Force(HRP.CFrame.RightVector * -1)
				end
				Apply_Force(HRP.CFrame.RightVector * -1)
				Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Right")then
				--Right
				if(Right_Dodge_Ani == Striking_Anim_Tracks['Headblock Right'])then
					--Apply_Force(HRP.CFrame.RightVector)
				end
				Apply_Force(HRP.CFrame.RightVector)
				Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Back")then
				Apply_Force(HRP.CFrame.LookVector * -1)
				Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
			end

			Debounce_Dodge = false
		end

		local function Toggle_Sheild_Icon(Is_Enabled)
			local Main_F =  Fight_UI:FindFirstChild("Main_F")
			if(Main_F ~= nil and Main_F:FindFirstChild("Shield_F") ~= nil)then
				local SF = Main_F:FindFirstChild("Shield_F")
				SF.Visible = true

				local Img = SF:FindFirstChild("Shield_Img")
				if(Img ~= nil)then
					if(Is_Enabled)then
						Img.Image = "rbxassetid://130871917395731"
					else
						Img.Image = "rbxassetid://125284121534949"
					end
				end
			end
		end

		local function Toggle_Heal_PE(Is_Enabled)
			local PE = HRP:GetChildren()
			for i = 1, #PE do
				if(PE[i] ~= nil and PE[i].Name == "Heal_PE" and PE[i]:IsA("ParticleEmitter"))then
					PE[i].Enabled = Is_Enabled
				end
			end

			Toggle_Sheild_Icon(Is_Enabled)
		end

		local Low_Block_Con = nil
		local function Disable_Blocking_Handle()
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed
			end

			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Block_Power_V:SetAttribute("Is_Blocking", false)
			Toggle_Heal_PE(false)

			Debounce_Blocking = false
		end

		local function Play_Blocking_Animation()
			local Anim_Track = Striking_Anim_Tracks['Main Block']
			if(Anim_Track ~= nil)then
				Anim_Track:Play()
				Anim_Track:AdjustSpeed(1)
				task.wait(Anim_Track.Length * 0.9)

				if(Anim_Track ~= nil and Debounce_Blocking == true)then
					Anim_Track:AdjustSpeed(0)
				end
			end
		end

		function Funcs.Disable_Blocking_Handle()
			-- AI is turning off Blocking
			Disable_Blocking_Handle()
		end

		function Funcs.Blocking_Handle()
			Debounce_Blocking = true
			-- AI Is Blocking

			if(Hum ~= nil)then
				Hum.WalkSpeed = 8
			end

			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			Low_Block_Con = Block_Power_V.Changed:Connect(function()
				if(Block_Power_V.Value <= 0 and Debounce_Blocking == true)then
					if(Low_Block_Con ~= nil)then
						Low_Block_Con:Disconnect()
						Low_Block_Con = nil
					end

					Disable_Blocking_Handle()
				end
			end)
			table.insert(self.Cons, Low_Block_Con)
			task.spawn(Play_Blocking_Animation)

			if(Block_Power_V ~= nil and Block_Power_V.Value > 0)then
				Block_Power_V:SetAttribute("Is_Blocking", true)
				Toggle_Heal_PE(true)
			end
		end

		function Funcs.Get_Hitbox_Res()
			return (Get_Player_To_Hit() ~= nil)
		end		

		function Funcs.Get_Dodge_Type()
			local function Get_Ray_Distance_Data()
				local Origin = HRP.Position
				local Ray_Parm = RaycastParams.new()
				Ray_Parm.FilterType = Enum.RaycastFilterType.Exclude
				Ray_Parm.FilterDescendantsInstances = {self.Bot, T_Char}

				local function Get_Ray_Dist(Dir)
					local Ray_Res = game.Workspace:Raycast(Origin, Dir * 10, Ray_Parm)
					if(Ray_Res ~= nil and Ray_Res.Distance ~= nil)then
						return Ray_Res.Distance
					end
					return 15
				end

				return {
					{
						['Type'] = "Dodge Back",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.LookVector * -1)
					},

					{
						['Type'] = "Dodge Left",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector * -1)
					},

					{
						['Type'] = "Dodge Right",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector)
					},

				}
			end
			local Ray_Dist_Arr = Get_Ray_Distance_Data()

			table.sort(Ray_Dist_Arr, function(A, B)
				return A['Distance'] > B['Distance']
			end)

			return Ray_Dist_Arr[1]['Type']
		end

		function Funcs.Is_Player_Striking_You()
			if(T_Strike_Power_V ~= nil and T_Strike_Power_V.Value < Fight_Params_Mod.Punch_Power.Max_Value * 0.5)then
				return true
			end
			return false
		end

		return Funcs
	end
	local Core_Strike_Funcs = Get_Core_Strike_Handles()

	--[[
		Core AI Decision Making goes here
		
		* If within Striking Distance ~ 5 Studs
			* If Player is Striking too, Dodge Left Right or Back (Max 2 Dodges)
			* Has to Strike (Max 3 Strikes)
				* Dodge Back if Strike (or left or Right)
		* Default to Blocking Handle
	]]--

	local function Submission_Handle(Is_Submitting, Attacking_Char)
		Animation_Mod.Reset_Character_Animations(self.Bot)
		if(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end

		if(Is_Submitting)then
			Is_Submission = true
			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end

			if(HRP ~= nil)then
				--HRP.Anchored = true
				--HRP.CFrame *= CFrame.new(Vector3.new(0, 0.15, 0))
				HRP.CFrame = HRP.CFrame * CFrame.new(0, 0.15, 0)
			end

			--> Play Animation
			--> Get Submission Character & Player
			--> Get their Takedown and Submission Data

			--> If Attacking Player, Set HRP CFrame Position
			--> Play Take Down Animation

			--> Play Submission Animation
			--> Play Submission Loop Animation

			local function Get_Takedown_Submission_Tracks()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)
				return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Receiving ID'], Submission_Data['Receiving ID'], Submission_Data['Receiving Loop ID'])
			end
			local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()

			Takedown_Track.Priority = Enum.AnimationPriority.Action2
			Animation_Mod.Play_Animation_Track(Takedown_Track, true)

			task.wait(0.25)

			Submission_Track.Priority = Enum.AnimationPriority.Action3
			Animation_Mod.Play_Animation_Track(Submission_Track)

			Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
		else
			Is_Hit = false

			if(HRP ~= nil)then
				HRP.Anchored = false
			end

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
			Is_Submission = false
		end
	end

	table.insert(self.Cons, AI_Training_Submission.Event:Connect(function(AI_Char, Attacking_Char, Is_Submitting)
		if(AI_Char == self.Bot)then
			Submission_Handle(Is_Submitting, Attacking_Char)
		end
	end))


	local function Clinch_Handle(Animation_Sequence_Data, Is_Attacking)
		local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(self.Bot)

			if(Debounce_Blocking == true)then
				task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
			end

			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
		end
		Freeze_Character()

		local function Play_Strike_Sequences()
			local Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
			Animation_Mod.Play_Animation_Track(Clinch_Tracks_Data['Init_Clinch'], true)
			task.spawn(Animation_Mod.Play_Animation_Track, Clinch_Tracks_Data['Loop_Clinch'])
			task.wait(1)

			for i = 1, #Animation_Sequence_Data do
				local Strike_Key = Animation_Sequence_Data[i]
				local Strike_Track = Clinch_Tracks_Data[Strike_Key]

				if(Strike_Track ~= nil)then
					--Play Flash, Play Hit Sound Effect, Quick Camera Shake
					Animation_Mod.Play_Animation_Track(Strike_Track)
					--wait(0.5)
				end
			end

		end
		Play_Strike_Sequences()

		local function Clinch_Reset_Handle()
			Animation_Mod.Reset_Character_Animations(self.Bot)
			Is_Hit = false

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
		end	
		Clinch_Reset_Handle()
	end

	table.insert(self.Cons, AI_Training_Cage_Clinch.Event:Connect(function(AI_Char, Sequence_Keys, Is_Attacking)
		if(AI_Char == self.Bot)then
			Clinch_Handle(Sequence_Keys, Is_Attacking)
		end
	end))


	local Strike_Count, Dodge_Count = 0, 0
	local function Main_AI_Logic_Gate()
		if(Health_V.Value > 0 and Is_Hit == false and T_Health_V ~= nil and T_Health_V.Value > 0)then
			if(Core_Strike_Funcs.Get_Hitbox_Res())then -- Within Strike Zone
				local Is_Player_Hitting_You = Core_Strike_Funcs.Is_Player_Striking_You()
				if(Is_Player_Hitting_You)then
					--Take the HIts until you're below 20 Block Power
					-- Dodge? or Strike
					if(Block_Power_V.Value > 10)then
						if(Dodge_Count < 2 or Strike_Count >= 3)then
							--Dodge
							if(Debounce_Dodge == false and Stam_V.Value >= 5)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								local Dodge_Type = Core_Strike_Funcs.Get_Dodge_Type()
								Core_Strike_Funcs.Dodge_Handle(Dodge_Type)

								Dodge_Count += 1
								if(Strike_Count >= 3)then
									Strike_Count = 0
								end
							end

						else
							--Strike
							if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								Core_Strike_Funcs.Strike_Handle()
								Strike_Count += 1
								if(Dodge_Count >= 2)then
									Dodge_Count = 0
								end
							else
								Core_Strike_Funcs.Blocking_Handle()
							end
						end
					elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
						--Not within Strike Zone, resort to Blocking
						Core_Strike_Funcs.Blocking_Handle()
					end
				else
					--Strike
					if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
						if(Debounce_Blocking == true)then
							task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
						end

						Core_Strike_Funcs.Strike_Handle()
						Strike_Count += 1
						if(Dodge_Count >= 2)then
							Dodge_Count = 0
						end
					else 
						Core_Strike_Funcs.Blocking_Handle()
					end
				end
			elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
				--Not within Strike Zone, resort to Blocking
				Core_Strike_Funcs.Blocking_Handle()
			end

		elseif(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end
	end

	while Is_Active do
		if(Is_Submission == false)then
			Main_AI_Logic_Gate()
		end
		task.wait(0.5)
	end
end

return NORMAL_Behavior]]></ProtectedString>
							<string name="ScriptGuid">{3F2D8824-21A1-49BD-B0FF-CD21B5FCF329}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">NORMAL.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX05214615E43245D49D6175ECCB51EC2F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Modules/Behaviors/COACH.lua
--
--  Description:
--      Behavior module defining the "NORMAL" AI used for training fights.
--      Provides full combat behavior logic including:
--          • Movement & player tracking
--          • Striking, blocking, dodging
--          • Hit reactions, stamina/health handling
--          • Submission logic & cage clinch interactions
--          • Animation orchestration and damage application
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-12-05 by Darkzeb
--
--  Version: V2025-12
--
--  Dependencies:
--      - Roblox Services:
--          * RunService
--          * TweenService
--          * ReplicatedStorage
--          * Debris
--
--      - Modules:
--          * Utils
--          * Channels (RemoteEvents & Bindables)
--          * Animation_Mod
--          * Sound_Mod
--          * Stats_Manager_Mod
--          * Fight_Params_Mod
--
--  Used By:
--      - Bots_Manager (injects this behavior when spawning training bots)
--      - Fight_Service
--
--  Notes:
--      - AI maintains its own registry (_registry) for instance tracking.
--      - Fully autonomous decision-making:
--          ✔ dodges based on raycast distance
--          ✔ reacts to player attacks
--          ✔ manages strike combos, block logic, stamina regen
--      - Submission & clinch sequences use specialized animation tracks.
--      - Large module: logic is intentionally server-side for determinism.
--
--======================================================================
local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")

local Channels = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Overhead_Display = Channels.SC_Remote_Events.Overhead_Display
local Got_Hit_Effect = Channels.SC_Remote_Events.Got_Hit_Effect
local AI_Training_Cage_Clinch = Channels.Bindable_Events.AI_Training_Cage_Clinch
local AI_Training_Submission = Channels.Bindable_Events.AI_Training_Submission
local Ragdoll_Player = Channels.Bindable_Events.Ragdoll_Player

local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))

local COACH_Behavior = {}
COACH_Behavior.__index = COACH_Behavior
COACH_Behavior._registry = {}


function COACH_Behavior.new()
	local self = setmetatable({}, COACH_Behavior)
	self.Cons = {}
	return self
end

function COACH_Behavior:Init(_plr, _botModel)
	self.player = _plr
	self.Bot = _botModel
	COACH_Behavior._registry[_botModel] = self
end

function COACH_Behavior:StartFight()
	local HRP = nil
	local Hum = nil
	local Head =nil
	local Fight_Data_F = nil
	local Stamina_V = nil
	local Fight_UI = nil
	local Health_V =nil
	local Stam_V = nil
	local Block_Power_V = nil
	local Strike_Power_V = nil
	local Fight_Walkspeed = 12
	local Is_Active = false

	if self.Bot and self.Bot:IsA("Model") then
		-- set body parts
		HRP = self.Bot:FindFirstChild("HumanoidRootPart")
		Hum = self.Bot:FindFirstChildWhichIsA("Humanoid")
		Head = self.Bot:FindFirstChild("Head")
		-- fight data folder
		Fight_Data_F = self.Bot:FindFirstChild("Fight_Data")
		if Fight_Data_F ~= nil then
			Health_V = Fight_Data_F:FindFirstChild("Health")
			Stam_V = Fight_Data_F:FindFirstChild("Staminia")
			Block_Power_V = Fight_Data_F:FindFirstChild("Block Power")
			Strike_Power_V = Fight_Data_F:FindFirstChild("Strike Power")
			-- use Stam_V for stamina regen logic
			Stamina_V = Stam_V
		end
		-- store current fight UI if present
		Fight_UI = self.Bot:FindFirstChild("Fighting_UI")
	end
	
	-- Direct stamina regeneration for bot (server-side)
	local function Reload_Stamina()
		while Stamina_V.Value < 40 do
			Stamina_V.Value = math.min(Stamina_V.Value + 1, 100) -- regen step, adjust as needed
			task.wait(0.1)
		end
	end

	local function Disconnect_Cons()
		for i = 1, #self.Cons do
			if(self.Cons[i] ~= nil)then
				self.Cons[i]:Disconnect()
			end
		end
		table.clear(self.Cons)
	end

	local function Get_Fighting_UI()
		local Fight_UI = self.Bot:FindFirstChild("Fighting_UI")
		if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
			local Main_F = Fight_UI:FindFirstChild("Main_F") 
			local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
			if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
				return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
			end
		end
		return nil, nil
	end

	local function Reset_AI()
		Disconnect_Cons()

		Health_V.Value = Fight_Params_Mod.Health.Max_Value
		Stam_V.Value = Fight_Params_Mod.Stamina.Max_Value
		Block_Power_V.Value = Fight_Params_Mod.Block_Power.Max_Value
		Strike_Power_V.Value = Fight_Params_Mod.Punch_Power.Max_Value

		if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
			HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
		end

		if(Hum ~= nil)then
			Hum.AutoRotate = false
			Hum.WalkSpeed = 12
			Hum.JumpPower = 0

			Animation_Mod.Reset_Character_Animations(self.Bot)

			Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
			Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
			Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
		end

		self.Bot:SetAttribute("Is_Fighting", false)
		Is_Active = false
	end
	
	-- determine which player and character to fight
	-- prefer explicit arguments, fall back to stored values
	local T_Plr = self.player 
	if not T_Plr then return end
	local T_Char =  self.player.Character
	if not T_Char then return end
	-- cache parts from the opponent
	local T_HRP = T_Char:WaitForChild("HumanoidRootPart")
	local T_Fight_Data = T_Plr:FindFirstChild("Fight_Data")
	if not T_Fight_Data then return end
	local T_Health_V = T_Fight_Data:WaitForChild("Health")
	--local T_Stam_V = T_Fight_Data:WaitForChild("Staminia")
	--local T_Block_Power_V = T_Fight_Data:WaitForChild("Block Power")
	local T_Strike_Power_V = T_Fight_Data:WaitForChild("Strike Power")
	local Is_Submission = false

	self.Bot:SetAttribute("Is_Fighting", true)
	Reset_AI()
	Is_Active = true

	--Fight Data Changes
	table.insert(self.Cons, Health_V.Changed:Connect(function()
		if(self.Bot ~= nil and Health_V.Value <= 0)then
			Ragdoll_Player:Fire(self.Bot)
		end
	end))

	local function Create_BG()
		local OldG = HRP:FindFirstChildWhichIsA("BodyGyro")
		if(OldG ~= nil)then
			OldG:Destroy()
		end

		local bodyG = Instance.new("BodyGyro", HRP)
		bodyG.P = 1000
		bodyG.MaxTorque = Vector3.new(0, 1000, 0)
		bodyG.D = 10

		return bodyG
	end
	local BG = Create_BG()

	local function Movement_Handle()
		local function Update_Player_Movement()
			local function Get_Target_Position()
				if(T_HRP ~= nil)then
					local Move_Speed = T_HRP.Velocity
					local Def_Pos = T_HRP.Position + T_HRP.CFrame.LookVector * 3.5

					if(math.floor(Move_Speed.Magnitude) <= 0)then
						return Def_Pos, T_HRP.Position
					else
						local Ping = T_Plr:GetNetworkPing()
						local Dir = Move_Speed.Unit
						local Speed = Move_Speed.Magnitude
						local Extrapolated_Pos = Def_Pos + Dir * (Speed * Ping)
						local Travel_Time = ((Extrapolated_Pos - HRP.Position).Magnitude) / Hum.WalkSpeed
						return Extrapolated_Pos + Dir * (Hum.WalkSpeed * Travel_Time), Extrapolated_Pos
					end
				end

				return HRP.Position, HRP.Position + HRP.CFrame.LookVector * 3
			end
			local Move_Pos, Look_Pos = Get_Target_Position()

			BG.CFrame = CFrame.new(HRP.Position, Look_Pos)
			Hum:MoveTo(Move_Pos)
		end

		table.insert(self.Cons, RunService.Stepped:Connect(function()
			if(BG ~= nil and HRP ~= nil and Hum ~= nil and Hum.PlatformStand == false and T_Plr ~= nil and T_HRP ~= nil)then
				if(T_Health_V ~= nil and T_Health_V.Value > 0 and Is_Submission == false)then
					Update_Player_Movement()
				else
					Hum:MoveTo(HRP.Position)
				end
			end
		end))

		table.insert(self.Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
			if(Hum.PlatformStand == true)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			else
				BG.P = 1000
				BG.MaxTorque = Vector3.new(0, 1000, 0)
				BG.D = 10
			end
		end))
	end
	Movement_Handle()

	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
		Damage_UIG.Offset = Vector2.new(0, -0.5)
		Damage_Bar_Img.Visible = false
	end

	local function Create_Anim_Arr_Data(Anim_Track_Data)
		local D = {}
		for Key, Anim_Track in next, Anim_Track_Data do
			table.insert(D, Anim_Track)
		end
		return D
	end

	local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	local Combo_Strike_Index = 1
	local Combo_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(T_Plr, Hum, "Bot Combo")
	local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)

	local Debounce_Striking = false
	local Debounce_Dodge = false
	local Debounce_Blocking = false
	--local Debounce_Takedown = false
	local Is_Hit = false

	local function Striking_Movement_Handle()
		--> Update Movement, Moving Forward or Backwards | Moving Left to Right | Standing Idle
		--> Track Humanoid MoveDirection
		table.insert(self.Cons, Hum:GetPropertyChangedSignal("WalkToPoint"):Connect(function()
			local Move_Speed = math.floor(HRP.Velocity.Magnitude)
			if(Move_Speed > 3 and Anim_Track_Data['Shuffle Forward'].IsPlaying == false)then
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				Anim_Track_Data['Shuffle Forward']:Play()
				Anim_Track_Data['Shuffle Forward']:AdjustSpeed(-1)

			elseif(Move_Speed <= 3 and 
				(Anim_Track_Data['Shuffle Forward'].IsPlaying == true or 
					Anim_Track_Data['Shuffle Side'].IsPlaying == true))then

				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
			end
		end))

		Anim_Track_Data['Idle']:Play()
		Anim_Track_Data['Idle']:AdjustSpeed(0.5)
	end
	Striking_Movement_Handle()

	local function On_Hit_Effects()
		--[[
			* When Health goes Down!
				> Camera Shake Effects
					-> Quick Shake
				> Apply Hit Effects
					-> Reset all Animations, Play the Hit One
				> Set Debounce till Hit Effect goes Away
		]]--

		local Prev_Health = Health_V.Value
		local Hit_Anim_Track = Striking_Anim_Tracks['Taking Hit']

		local function Show_Sweat_Effects()
			if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
				local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
				local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
				if(PE ~= nil)then
					PE:Emit(25)
				end
			end
		end

		table.insert(self.Cons, Health_V.Changed:Connect(function()
			local Current_V = Health_V.Value
			if(Current_V < Prev_Health and Is_Hit == false)then
				Is_Hit = true

				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Show_Sweat_Effects()

				task.spawn(function()
					Animation_Mod.Play_Animation_Track(Hit_Anim_Track)
					Is_Hit = false
				end)
			end

			Prev_Health = Current_V
		end))
	end
	On_Hit_Effects()

	local function Blocking_Effects()
		--[[
			* On Sheild Blocking Power goes down (Greater than 0) and Debounce_Blocking == true
			* Get the Opponent Handed Type
				> Play the Coresponding Animation
		]]--

		local Prev_Blocking = Block_Power_V.Value
		local Tween_Health_Con = nil
		local Tween_Stam_Con = nil
		local Tween_Block_Con = nil
		Block_Power_V:SetAttribute("Is_Blocking", false)

		local function Reset_Healing_Cons()
			if(Tween_Health_Con ~= nil)then
				Tween_Health_Con:Cancel()
				Tween_Health_Con = nil
			end

			if(Tween_Stam_Con ~= nil)then
				Tween_Stam_Con:Cancel()
				Tween_Stam_Con = nil
			end
		end

		local function Create_Reload_Tween (Value, Max, Speed)
			local Delta = Max - Value.Value
			local Reload_Time = math.clamp(Delta, 1, Fight_Params_Mod.Health.Max_Value) * Speed
			local Tween = TweenInfo.new(Reload_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
			return TS:Create(Value, Tween, {Value = Max})
		end

		local function Set_Healing_Cons()
			local Health_Params = Fight_Params_Mod.Health
			if Health_Params.Reloading_Active then
				Tween_Health_Con = Create_Reload_Tween(Health_V, Health_Params.Max_Value, Health_Params.Reload_Time_Factor)
				Tween_Health_Con:Play()
			end

			local Stam_Params = Fight_Params_Mod.Stamina
			Tween_Stam_Con = Create_Reload_Tween(Stam_V, Stam_Params.Max_Value, Stam_Params.Reload_Time_Factor)
			Tween_Stam_Con:Play()
		end

		table.insert(self.Cons, Block_Power_V.AttributeChanged:Connect(function(Attrib_Key)
			if(Attrib_Key == "Is_Blocking" and Block_Power_V:GetAttribute("Is_Blocking") ~= nil)then
				Reset_Healing_Cons()
				if(Block_Power_V:GetAttribute("Is_Blocking") == true)then
					Set_Healing_Cons()
				end
			end
		end))


		local function Update_Fight_Block_UI()
			if(Fight_UI ~= nil and Block_Power_V ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil and 
				Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then

				local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
				local Img = Sheild_F:FindFirstChild("Shield_Img")
				local Txt = Sheild_F:FindFirstChild("Shield_Txt")

				if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
					local UIG = Img:FindFirstChildWhichIsA("UIGradient")
					local Block_Power = Block_Power_V.Value
					local Dif =  math.clamp(Block_Power / 30, 0, 1)
					local Offset_Pos_Y = (1 - Dif) - 0.5

					UIG.Offset = Vector2.new(0, Offset_Pos_Y)
					Txt.Text = Block_Power .. ""
					if(Dif <= 0.25)then
						Txt.TextColor3 = Color3.new(1, 0, 0)
					else
						Txt.TextColor3 = Color3.new(1, 1, 1)
					end

				end
			end

		end

		table.insert(self.Cons, Block_Power_V.Changed:Connect(function()
			local Current_V = Block_Power_V.Value
			if(Current_V > 0 and Current_V < Prev_Blocking and Debounce_Blocking == true)then
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Striking_Anim_Tracks['Body Block Left'])

				if(Block_Power_V.Value < 30)then
					if(Tween_Block_Con ~= nil)then
						Tween_Block_Con:Cancel()
						Tween_Block_Con = nil
					end

					local Block_Time = math.clamp((30 - Block_Power_V.Value) * 0.2667, 0.2667, 8)
					local Tween_Block_Power = TweenInfo.new(Block_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 6)
					Tween_Block_Con = TS:Create(Block_Power_V, Tween_Block_Power, {Value = 30})
					Tween_Block_Con:Play()
					Tween_Block_Con.Completed:Wait()
					Tween_Block_Con = nil
				end
			end

			Update_Fight_Block_UI()
			Prev_Blocking = Current_V

		end))

	end
	Blocking_Effects()

	local function Get_Core_Strike_Handles()
		local Funcs = {}
		SE_Mod.PlaySFX(T_Plr, "Punch_Woosh_SE")

		local function Has_Enough_Stam(Min_V)
			if(Stam_V ~= nil and Stam_V.Value >= Min_V)then
				Stam_V.Value -= Min_V
				return true
			end
			return false
		end

		local function Get_Player_To_Hit()
			local Whitelist_Chars = {T_Char}
			local Overlap_P = OverlapParams.new()
			Overlap_P.MaxParts = 1
			Overlap_P.FilterType = Enum.RaycastFilterType.Include
			Overlap_P.FilterDescendantsInstances = {Whitelist_Chars}

			local function Create_Region_CF()
				local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
				local Distance = (Speed + 3)
				--local Head_Dir = Head.CFrame.LookVector
				--local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

				local cframe = HRP.CFrame * CFrame.new(0, 0, -3)
				return cframe
			end
			local Spawn_CF = Create_Region_CF()
			local Hitbox_Size = Vector3.new(4, 8, 4)

			--local function Create_Hitbox_Part()
			--	local P = Instance.new("Part", game.Workspace)
			--	P.Name = "Hitbox_Part"
			--	P.Anchored = true
			--	P.CanCollide = false
			--	P.Transparency = 0.5
			--	P.Color = Color3.new(1, 0, 0)
			--	P.Material = Enum.Material.SmoothPlastic
			--	P.Size = Hitbox_Size
			--	P.CFrame = Spawn_CF

			--	Debris:AddItem(P, 5)
			--end
			--Create_Hitbox_Part()

			local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
			if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
				local function Get_Char_From_BP()
					for i = 1, #Whitelist_Chars do
						local C = Whitelist_Chars[i]
						if(C ~= nil and Region_Data[1]:IsDescendantOf(C))then
							return C
						end
					end

					return Whitelist_Chars[1]
				end

				return Get_Char_From_BP()
			end

			return nil
		end

		local function Get_Punch_Power(delay)
			local Params = Fight_Params_Mod.Punch_Power

			local Tween_Punch_Power_Back = TweenInfo.new(Params.Reload_Time, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, delay)
			local Strike_Power = Strike_Power_V.Value
			Strike_Power_V.Value = Params.Min_Value
			TS:Create(Strike_Power_V, Tween_Punch_Power_Back, {Value = Params.Max_Value}):Play()
			return Strike_Power
		end

		local function Get_Target_Fight_Data(Hit_Char)
			local Hit_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
			if(Hit_Plr ~= nil)then
				return Hit_Plr:FindFirstChild("Fight_Data")
			else
				return Hit_Char:FindFirstChild("Fight_Data")
			end
		end

		function Funcs.Strike_Handle()
			if Stamina_V.Value < 20 then Reload_Stamina() end
			--[[
				* Play Woosh Sound Effect locally
				* Play Animation
				* Tell the Server that you are Striking
			]]--

			Debounce_Striking = true
			-- AI is Striking!
			SE_Mod.PlaySFX(T_Plr, "Punch_Woosh_SE")

			local function Play_Strike_Animation()
				local Track = Combo_Anim_Arr[Combo_Strike_Index]
				local Key = Track:GetAttribute("Strike_Key") or "A"

				task.spawn(function()
					if(HRP ~= nil and Has_Enough_Stam(10))then

						local Hit_Char = Get_Player_To_Hit()
						local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Key)

						local Damage_Multi = Get_Punch_Power(Strike_Data['Time Length'])
						local Strike_Damage = Strike_Data['Damage']
						local Punch_Power = math.round(Strike_Damage * Damage_Multi)

						if(Hit_Char ~= nil)then
							local Hit_Fight_Data = Get_Target_Fight_Data(Hit_Char)
							if(Hit_Fight_Data ~= nil and Hit_Fight_Data:FindFirstChild("Health") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Block Power") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Staminia") ~= nil)then

								local T_Health = Hit_Fight_Data:FindFirstChild("Health")
								local T_Block_Power = Hit_Fight_Data:FindFirstChild("Block Power")
								local T_Staminia = Hit_Fight_Data:FindFirstChild("Staminia")

								local function Is_Dodging_Check()
									local Is_Dodging = T_Staminia:GetAttribute("Is_Dodging")
									if(Is_Dodging ~= nil and Is_Dodging == true)then
										local Target_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if(Target_Plr ~= nil)then
											Stats_Manager_Mod.Add_To_Player_Stats_Data(Target_Plr, "Dodged Strikes", 1)
										end

										return true
									end
									return false
								end

								local function Is_Blocking_Check()
									local Is_Block = T_Block_Power:GetAttribute("Is_Blocking")
									if(Is_Block ~= nil and Is_Block == true)then
										T_Block_Power.Value -= Punch_Power
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.fromRGB(170, 85, 255))

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										if(T_Block_Power.Value < 0)then
											local Dif = math.abs(T_Block_Power.Value)
											T_Health.Value = math.clamp(T_Health.Value - Dif, 0, 100)
											T_Block_Power.Value = 0

											SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
											--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)

											Overhead_Display:FireAllClients(Hit_Char, "-" .. Dif, Color3.new(1, 0, 0))

										else
											SE_Mod.PlaySFX(HRP, "Blocked_Hit_SE")	
										end

										return true
									end

									return false
								end

								if(Is_Dodging_Check())then
									--Play Dodging Text
									Overhead_Display:FireAllClients(Hit_Char, "Dodged", Color3.fromRGB(35, 244, 68))
								elseif(Is_Blocking_Check())then
									--Play Blocking 
								else
									--Apply the Hit
									local function Apply_Strike()
										T_Health.Value = math.clamp(T_Health.Value - Punch_Power, 0, 100)
										SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
										--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.new(1, 0, 0))
										--Punch_Hit_VFX:FireClient(Plr, Hit_Char)
										--Play Damage Val Show

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										local T_HRP = Hit_Char:FindFirstChild("HumanoidRootPart")
										if(T_HRP ~= nil)then
											local Hit_Force = 625 -- Was 350 then 500
											local Dir = HRP.CFrame.LookVector 
											T_HRP:ApplyImpulse(Dir * Hit_Force * T_HRP:GetMass())
										end
									end
									Apply_Strike()
								end
							end

						end
					end
				end)

				Combo_Strike_Index += 1
				if(Combo_Strike_Index > #Combo_Anim_Arr)then
					Combo_Strike_Index = 1
				end

				Animation_Mod.Stop_Animation_Tracks(Combo_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Track)
			end
			task.spawn(Play_Strike_Animation)
			
			-- waiting time for the next strike (2 instead of 0.5)
			task.wait(2)

			Debounce_Striking = false
		end

		local Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left']
		local Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		local Back_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		function Funcs.Dodge_Handle(Dodge_Type)
			--[[
				* Get the Type First
					-> First Index? Just play the Slip Animation
					-> 2nd Index? Play the Dodge Animation AND apply Force to the Player in the direction
				
					-> Tell the Server that you are Dodging and should reduce Staminia Value
			]]--

			Debounce_Dodge = true
			-- AI is Dodging

			local function Apply_Force(Dir)
				HRP:ApplyImpulse(Dir * (Fight_Walkspeed * 65) * HRP:GetMass())
			end

			task.spawn(function()
				if(Has_Enough_Stam(5))then
					--Play the Sound Effect
					--Toggle Value
					SE_Mod.PlaySFX(HRP, "Missed_SE")
					Stam_V:SetAttribute("Is_Dodging", true)
					task.wait(0.5)
					Stam_V:SetAttribute("Is_Dodging", false)
				end
			end)
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})

			local function Increment_Anim()
				if(Dodge_Type == "Dodge Left")then
					if(Left_Dodge_Ani == Striking_Anim_Tracks['Slip Left'])then
						Left_Dodge_Ani = Striking_Anim_Tracks['Headblock Left']
					else
						Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left'] 
					end
				else
					--Right
					if(Right_Dodge_Ani == Striking_Anim_Tracks['Slip Right'])then
						Right_Dodge_Ani = Striking_Anim_Tracks['Headblock Right']
					else
						Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right'] 
					end
				end
			end

			if(Dodge_Type == "Dodge Left")then
				--Left
				if(Left_Dodge_Ani == Striking_Anim_Tracks['Headblock Left'])then
					--Apply_Force(HRP.CFrame.RightVector * -1)
				end
				Apply_Force(HRP.CFrame.RightVector * -1)
				Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Right")then
				--Right
				if(Right_Dodge_Ani == Striking_Anim_Tracks['Headblock Right'])then
					--Apply_Force(HRP.CFrame.RightVector)
				end
				Apply_Force(HRP.CFrame.RightVector)
				Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Back")then
				Apply_Force(HRP.CFrame.LookVector * -1)
				Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
			end

			Debounce_Dodge = false
		end

		local function Toggle_Sheild_Icon(Is_Enabled)
			local Main_F =  Fight_UI:FindFirstChild("Main_F")
			if(Main_F ~= nil and Main_F:FindFirstChild("Shield_F") ~= nil)then
				local SF = Main_F:FindFirstChild("Shield_F")
				SF.Visible = true

				local Img = SF:FindFirstChild("Shield_Img")
				if(Img ~= nil)then
					if(Is_Enabled)then
						Img.Image = "rbxassetid://130871917395731"
					else
						Img.Image = "rbxassetid://125284121534949"
					end
				end
			end
		end

		local function Toggle_Heal_PE(Is_Enabled)
			local PE = HRP:GetChildren()
			for i = 1, #PE do
				if(PE[i] ~= nil and PE[i].Name == "Heal_PE" and PE[i]:IsA("ParticleEmitter"))then
					PE[i].Enabled = Is_Enabled
				end
			end

			Toggle_Sheild_Icon(Is_Enabled)
		end

		local Low_Block_Con = nil
		local function Disable_Blocking_Handle()
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed
			end

			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Block_Power_V:SetAttribute("Is_Blocking", false)
			Toggle_Heal_PE(false)

			Debounce_Blocking = false
		end

		local function Play_Blocking_Animation()
			local Anim_Track = Striking_Anim_Tracks['Main Block']
			if(Anim_Track ~= nil)then
				Anim_Track:Play()
				Anim_Track:AdjustSpeed(1)
				task.wait(Anim_Track.Length * 0.9)

				if(Anim_Track ~= nil and Debounce_Blocking == true)then
					Anim_Track:AdjustSpeed(0)
				end
			end
		end

		function Funcs.Disable_Blocking_Handle()
			-- AI is turning off Blocking
			Disable_Blocking_Handle()
		end

		function Funcs.Blocking_Handle()
			Debounce_Blocking = true
			-- AI Is Blocking

			if(Hum ~= nil)then
				Hum.WalkSpeed = 8
			end

			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			Low_Block_Con = Block_Power_V.Changed:Connect(function()
				if(Block_Power_V.Value <= 0 and Debounce_Blocking == true)then
					if(Low_Block_Con ~= nil)then
						Low_Block_Con:Disconnect()
						Low_Block_Con = nil
					end

					Disable_Blocking_Handle()
				end
			end)
			table.insert(self.Cons, Low_Block_Con)
			task.spawn(Play_Blocking_Animation)

			if(Block_Power_V ~= nil and Block_Power_V.Value > 0)then
				Block_Power_V:SetAttribute("Is_Blocking", true)
				Toggle_Heal_PE(true)
			end
		end

		function Funcs.Get_Hitbox_Res()
			return (Get_Player_To_Hit() ~= nil)
		end		

		function Funcs.Get_Dodge_Type()
			local function Get_Ray_Distance_Data()
				local Origin = HRP.Position
				local Ray_Parm = RaycastParams.new()
				Ray_Parm.FilterType = Enum.RaycastFilterType.Exclude
				Ray_Parm.FilterDescendantsInstances = {self.Bot, T_Char}

				local function Get_Ray_Dist(Dir)
					local Ray_Res = game.Workspace:Raycast(Origin, Dir * 10, Ray_Parm)
					if(Ray_Res ~= nil and Ray_Res.Distance ~= nil)then
						return Ray_Res.Distance
					end
					return 15
				end

				return {
					{
						['Type'] = "Dodge Back",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.LookVector * -1)
					},

					{
						['Type'] = "Dodge Left",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector * -1)
					},

					{
						['Type'] = "Dodge Right",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector)
					},

				}
			end
			local Ray_Dist_Arr = Get_Ray_Distance_Data()

			table.sort(Ray_Dist_Arr, function(A, B)
				return A['Distance'] > B['Distance']
			end)

			return Ray_Dist_Arr[1]['Type']
		end

		function Funcs.Is_Player_Striking_You()
			if(T_Strike_Power_V ~= nil and T_Strike_Power_V.Value < Fight_Params_Mod.Punch_Power.Max_Value * 0.5)then
				return true
			end
			return false
		end

		return Funcs
	end
	local Core_Strike_Funcs = Get_Core_Strike_Handles()

	--[[
		Core AI Decision Making goes here
		
		* If within Striking Distance ~ 5 Studs
			* If Player is Striking too, Dodge Left Right or Back (Max 2 Dodges)
			* Has to Strike (Max 3 Strikes)
				* Dodge Back if Strike (or left or Right)
		* Default to Blocking Handle
	]]--

	local function Submission_Handle(Is_Submitting, Attacking_Char)
		Animation_Mod.Reset_Character_Animations(self.Bot)
		if(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end

		if(Is_Submitting)then
			Is_Submission = true
			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end

			if(HRP ~= nil)then
				--HRP.Anchored = true
				--HRP.CFrame *= CFrame.new(Vector3.new(0, 0.15, 0))
				HRP.CFrame = HRP.CFrame * CFrame.new(0, 0.15, 0)
			end

			--> Play Animation
			--> Get Submission Character & Player
			--> Get their Takedown and Submission Data

			--> If Attacking Player, Set HRP CFrame Position
			--> Play Take Down Animation

			--> Play Submission Animation
			--> Play Submission Loop Animation

			local function Get_Takedown_Submission_Tracks()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)
				return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Receiving ID'], Submission_Data['Receiving ID'], Submission_Data['Receiving Loop ID'])
			end
			local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()

			Takedown_Track.Priority = Enum.AnimationPriority.Action2
			Animation_Mod.Play_Animation_Track(Takedown_Track, true)

			task.wait(0.25)

			Submission_Track.Priority = Enum.AnimationPriority.Action3
			Animation_Mod.Play_Animation_Track(Submission_Track)

			Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
		else
			Is_Hit = false

			if(HRP ~= nil)then
				HRP.Anchored = false
			end

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
			Is_Submission = false
		end
	end

	table.insert(self.Cons, AI_Training_Submission.Event:Connect(function(AI_Char, Attacking_Char, Is_Submitting)
		if(AI_Char == self.Bot)then
			Submission_Handle(Is_Submitting, Attacking_Char)
		end
	end))


	local function Clinch_Handle(Animation_Sequence_Data, Is_Attacking)
		local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(self.Bot)

			if(Debounce_Blocking == true)then
				task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
			end

			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
		end
		Freeze_Character()

		local function Play_Strike_Sequences()
			local Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
			Animation_Mod.Play_Animation_Track(Clinch_Tracks_Data['Init_Clinch'], true)
			task.spawn(Animation_Mod.Play_Animation_Track, Clinch_Tracks_Data['Loop_Clinch'])
			task.wait(1)

			for i = 1, #Animation_Sequence_Data do
				local Strike_Key = Animation_Sequence_Data[i]
				local Strike_Track = Clinch_Tracks_Data[Strike_Key]

				if(Strike_Track ~= nil)then
					--Play Flash, Play Hit Sound Effect, Quick Camera Shake
					Animation_Mod.Play_Animation_Track(Strike_Track)
					--wait(0.5)
				end
			end

		end
		Play_Strike_Sequences()

		local function Clinch_Reset_Handle()
			Animation_Mod.Reset_Character_Animations(self.Bot)
			Is_Hit = false

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
		end	
		Clinch_Reset_Handle()
	end

	table.insert(self.Cons, AI_Training_Cage_Clinch.Event:Connect(function(AI_Char, Sequence_Keys, Is_Attacking)
		if(AI_Char == self.Bot)then
			Clinch_Handle(Sequence_Keys, Is_Attacking)
		end
	end))

	local MIN_T_HEALTH = 80
	local Strike_Count, Dodge_Count = 0, 0
	local function Main_AI_Logic_Gate()
		if(Health_V.Value > 0 and Is_Hit == false and T_Health_V ~= nil and T_Health_V.Value > 0)then
			if(Core_Strike_Funcs.Get_Hitbox_Res())then -- Within Strike Zone
				local Is_Player_Hitting_You = Core_Strike_Funcs.Is_Player_Striking_You()
				if(Is_Player_Hitting_You)then
					--Take the HIts until you're below 20 Block Power
					-- Dodge? or Strike
					if(Block_Power_V.Value > 10)then
						if(Dodge_Count < 2 or Strike_Count >= 3)then
							--Dodge
							if(Debounce_Dodge == false and Stam_V.Value >= 5)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								local Dodge_Type = Core_Strike_Funcs.Get_Dodge_Type()
								Core_Strike_Funcs.Dodge_Handle(Dodge_Type)

								Dodge_Count += 1
								if(Strike_Count >= 3)then
									Strike_Count = 0
								end
							end

						else
							--Strike (MODIFIED to only strike 15%)
							if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0 and math.random() < 0.15)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end
								
								if (T_Health_V.Value > MIN_T_HEALTH) then
									Core_Strike_Funcs.Strike_Handle()
									Strike_Count += 1
									if(Dodge_Count >= 2)then
										Dodge_Count = 0
									end
								end
							else
								Core_Strike_Funcs.Blocking_Handle()
							end
						end
					elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
						--Not within Strike Zone, resort to Blocking
						Core_Strike_Funcs.Blocking_Handle()
					end
				else
					--Strike (MODIFIED to reduce strike to 30%)
					if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0 and math.random() < 0.3)then
						if(Debounce_Blocking == true)then
							task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
						end

						if (T_Health_V.Value > MIN_T_HEALTH) then
							Core_Strike_Funcs.Strike_Handle()
							Strike_Count += 1
							if(Dodge_Count >= 2)then
								Dodge_Count = 0
							end
						end
					else 
						Core_Strike_Funcs.Blocking_Handle()
					end
				end
			elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
				--Not within Strike Zone, resort to Blocking
				Core_Strike_Funcs.Blocking_Handle()
			end

		elseif(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end
	end

	while Is_Active do
		if(Is_Submission == false)then
			Main_AI_Logic_Gate()
		end
		task.wait(0.5)
	end
end

return COACH_Behavior]]></ProtectedString>
							<string name="ScriptGuid">{E40AE112-634D-4578-8DB9-CAF13D622F8A}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">COACH.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXA67F0D8FC4CB49A2858BEE4E3F771B26">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Vendor</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXA418E51D5A0F42658DAD397D4C15498C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Vendor/Spr.lua
--
--  Description:
--      Spring-driven motion library for Roblox. Provides physics-based
--      animations by interpolating instance properties towards target
--      values with configurable damping and frequency. Includes sleep
--      detection to optimize performance.
--
--  Author(s): Fractality (https://github.com/Fraktality/spr)
--  License: MIT (2024)
--
--  Last Modified: 2024 by Fractality (vendored by Darkzeb)
--
--  Version: Upstream 2024
--
--  Dependencies:
--      - Roblox Services:
--          * RunService
--      - Lua math functions
--
--  Notes:
--      - Public API:
--          * spr.target(obj, dampingRatio, undampedFrequency, targetProps)
--              Animates properties towards target values
--          * spr.stop(obj [, property])
--              Stops one or all properties from animating
--      - Supports various property types via type metadata
--      - Automatic sleep when offset & velocity below thresholds
--      - Visualizer available: https://www.desmos.com/calculator/rzvw27ljh9
--
--======================================================================

--!strict
--!native
---------------------------------------------------------------------
-- spr - Spring-driven motion library
--
-- Copyright (c) 2024 Fractality. All rights reserved.
-- Released under the MIT license.
--
-- Docs & license can be found at https://github.com/Fraktality/spr
--
-- API Summary:
--
-- spr.target(
--    Instance obj,
--    number dampingRatio,
--    number undampedFrequency,
--    dict<string, Variant> targetProperties)
--
--    Animates the given properties towardes the target values,
--    given damping ratio and undamped frequency.
--
--
-- spr.stop(
--    Instance obj[,
--    string property])
--
--    Stops the specified property on an Instance from animating.
--    If no property is specified, all properties of the Instance
--    will stop animating.
--
-- Visualizer: https://www.desmos.com/calculator/rzvw27ljh9
---------------------------------------------------------------------

local STRICT_RUNTIME_TYPES = true -- assert on parameter and property type mismatch
local SLEEP_OFFSET_SQ_LIMIT = (1/3840)^2 -- square of the offset sleep limit
local SLEEP_VELOCITY_SQ_LIMIT = 1e-2^2 -- square of the velocity sleep limit
local SLEEP_ROTATION_DIFF = math.rad(0.01) -- rad
local SLEEP_ROTATION_VELOCITY = math.rad(0.1) -- rad/s
local EPS = 1e-5 -- epsilon for stability checks around pathological frequency/damping values

local RunService: RunService = game:GetService("RunService")

local pi = math.pi
local exp = math.exp
local sin = math.sin
local cos = math.cos
local min = math.min
local max = math.max
local sqrt = math.sqrt
local atan2 = math.atan2
local round = math.round

local function magnitudeSq(vec: {number})
	local out = 0
	for _, v in vec do
		out += v^2
	end
	return out
end

local function distanceSq(vec0: {number}, vec1: {number})
	local out = 0
	for i0, v0 in vec0 do
		out += (vec1[i0] - v0)^2
	end
	return out
end

type TypeMetadata<T> = {
	springType: (dampingRatio: number, frequency: number, pos: number, typedat: TypeMetadata<T>, rawTarget: T) -> LinearSpring<T>,
	toIntermediate: (T) -> {number},
	fromIntermediate: ({number}) -> T,
}

-- Spring for an array of linear values
local LinearSpring = {}

type LinearSpring<T> = typeof(setmetatable({} :: {
	d: number,
	f: number,
	g: {number},
	p: {number},
	v: {number},
	typedat: TypeMetadata<T>,
	rawTarget: T,
}, LinearSpring))

do
	LinearSpring.__index = LinearSpring

	function LinearSpring.new<T>(dampingRatio: number, frequency: number, pos: T, rawGoal: T, typedat)
		local linearPos = typedat.toIntermediate(pos)
		return setmetatable(
			{
				d = dampingRatio,
				f = frequency,
				g = linearPos,
				p = linearPos,
				v = table.create(#linearPos, 0),
				typedat = typedat,
				rawGoal = rawGoal
			},
			LinearSpring
		)
	end

	function LinearSpring.setGoal<T>(self, goal: T)
		self.rawGoal = goal
		self.g = self.typedat.toIntermediate(goal)
	end

	function LinearSpring.setDampingRatio<T>(self: LinearSpring<T>, dampingRatio: number)
		self.d = dampingRatio
	end

	function LinearSpring.setFrequency<T>(self: LinearSpring<T>, frequency: number)
		self.f = frequency
	end

	function LinearSpring.canSleep<T>(self)
		if magnitudeSq(self.v) > SLEEP_VELOCITY_SQ_LIMIT then
			return false
		end

		if distanceSq(self.p, self.g) > SLEEP_OFFSET_SQ_LIMIT then
			return false
		end

		return true
	end

	function LinearSpring.step<T>(self: LinearSpring<T>, dt: number)
		-- Advance the spring simulation by dt seconds.
		-- Take the damped harmonic oscillator ODE:
		--    f^2*(X[t] - g) + 2*d*f*X'[t] + X''[t] = 0
		-- Where X[t] is position at time t, g is target position,
		-- f is undamped angular frequency, and d is damping ratio.
		-- Apply constant initial conditions:
		--    X[0] = p0
		--    X'[0] = v0
		-- Solve the IVP to get analytic expressions for X[t] and X'[t].
		-- The solution takes one of three forms for 0<=d<1, d=1, and d>1

		local d = self.d
		local f = self.f*(2*pi) -- Hz -> Rad/s
		local g = self.g
		local p = self.p
		local v = self.v

		if d == 1 then -- critically damped
			local q = exp(-f*dt)
			local w = dt*q

			local c0 = q + w*f
			local c2 = q - w*f
			local c3 = w*f*f

			for idx = 1, #p do
				local o = p[idx] - g[idx]
				p[idx] = o*c0 + v[idx]*w + g[idx]
				v[idx] = v[idx]*c2 - o*c3
			end

		elseif d < 1 then -- underdamped
			local q = exp(-d*f*dt)
			local c = sqrt(1 - d*d)

			local i = cos(dt*f*c)
			local j = sin(dt*f*c)

			-- Damping ratios approaching 1 can cause division by very small numbers.
			-- To mitigate that, group terms around z=j/c and find an approximation for z.
			-- Start with the definition of z:
			--    z = sin(dt*f*c)/c
			-- Substitute a=dt*f:
			--    z = sin(a*c)/c
			-- Take the Maclaurin expansion of z with respect to c:
			--    z = a - (a^3*c^2)/6 + (a^5*c^4)/120 + O(c^6)
			--    z ≈ a - (a^3*c^2)/6 + (a^5*c^4)/120
			-- Rewrite in Horner form:
			--    z ≈ a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6

			local z
			if c > EPS then
				z = j/c
			else
				local a = dt*f
				z = a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6
			end

			-- Frequencies approaching 0 present a similar problem.
			-- We want an approximation for y as f approaches 0, where:
			--    y = sin(dt*f*c)/(f*c)
			-- Substitute b=dt*c:
			--    y = sin(b*c)/b
			-- Now reapply the process from z.

			local y
			if f*c > EPS then
				y = j/(f*c)
			else
				local b = f*c
				y = dt + ((dt*dt)*(b*b)*(b*b)/20 - b*b)*(dt*dt*dt)/6
			end

			for idx = 1, #p do
				local o = p[idx] - g[idx]
				p[idx] = (o*(i + z*d) + v[idx]*y)*q + g[idx]
				v[idx] = (v[idx]*(i - z*d) - o*(z*f))*q
			end

		else -- overdamped
			local c = sqrt(d*d - 1)

			local r1 = -f*(d + c)
			local r2 = -f*(d - c)

			local ec1 = exp(r1*dt)
			local ec2 = exp(r2*dt)

			for idx = 1, #p do
				local o = p[idx] - g[idx]
				local co2 = (v[idx] - o*r1)/(2*f*c)
				local co1 = ec1*(o - co2)

				p[idx] = co1 + co2*ec2 + g[idx]
				v[idx] = co1*r1 + co2*ec2*r2
			end
		end

		return self.typedat.fromIntermediate(self.p)
	end
end

local RotationSpring = {} 

type RotationSpring = typeof(setmetatable({} :: {
	d: number,
	f: number,
	g: CFrame,
	p: CFrame,
	v: Vector3,
}, RotationSpring))

do
	RotationSpring.__index = RotationSpring

	function RotationSpring.new(d: number, f: number, p: CFrame, g: CFrame)
		return setmetatable(
			{
				d = d,
				f = f,
				g = g:Orthonormalize(),
				p = p:Orthonormalize(),
				v = Vector3.zero
			},
			RotationSpring
		)
	end

	function RotationSpring.setGoal(self: RotationSpring, value: CFrame)
		self.g = value:Orthonormalize()
	end

	function RotationSpring.setDampingRatio(self: RotationSpring, dampingRatio: number)
		self.d = dampingRatio
	end

	function RotationSpring.setFrequency(self: RotationSpring, frequency: number)
		self.f = frequency
	end

	-- evaluate dot products in high precision
	local function dot(v0: Vector3, v1: Vector3)
		return v0.X*v1.X + v0.Y*v1.Y + v0.Z*v1.Z
	end

	local function areRotationsClose(c0: CFrame, c1: CFrame)
		local rx = dot(c0.XVector, c1.XVector)
		local ry = dot(c0.YVector, c1.YVector)
		local rz = dot(c0.ZVector, c1.ZVector)
		local trace = rx + ry + rz
		return trace > 1 + 2*cos(SLEEP_ROTATION_DIFF)
	end

	local function angleDiff(c0: CFrame, c1: CFrame)
		local x = dot(c0.XVector, c1.XVector)
		local y = dot(c0.YVector, c1.YVector)
		local z = dot(c0.ZVector, c1.ZVector)
		local w = x + y + z - 1
		return atan2(sqrt(max(0, 1 - w*w*0.25)), w*0.5)
	end

	-- gives approx. 21% accuracy improvement over CFrame.fromAxisAngle near poles
	local function fromAxisAngle(axis: Vector3, angle: number)
		local c = cos(angle)
		local s = sin(angle)
		local x, y, z = axis.X, axis.Y, axis.Z

		local mxy = x*y*(1 - c)
		local myz = y*z*(1 - c)
		local mzx = z*x*(1 - c)

		local rx = Vector3.new(x*x*(1 - c) + c, mxy + z*s, mzx - y*s)
		local ry = Vector3.new(mxy - z*s, y*y*(1 - c) + c, myz + x*s)
		local rz = Vector3.new(mzx + y*s, myz - x*s, z*z*(1 - c) + c)

		return CFrame.fromMatrix(Vector3.zero, rx, ry, rz):Orthonormalize()
	end

	local function rotateAxis(r0: Vector3, c1: CFrame)
		local c0 = CFrame.identity
		local mag = r0.Magnitude
		if mag > 1e-6 then
			c0 = fromAxisAngle(r0.Unit, mag)
		end
		return c0 * c1
	end

	-- axis*angle difference between two cframes
	local function axisAngleDiff(c0: CFrame, c1: CFrame)
		-- use native axis (stable enough)
		local axis = (c0*c1:Inverse()):ToAxisAngle()

		-- use full-precision angle calculation to minimize truncation
		local angle = angleDiff(c0, c1)
		return axis.Unit*angle
	end

	function RotationSpring.canSleep(self: RotationSpring)
		local sleepP = areRotationsClose(self.p, self.g)
		local sleepV = self.v.Magnitude < SLEEP_ROTATION_VELOCITY
		return sleepP and sleepV
	end

	function RotationSpring.step(self: RotationSpring, dt: number): CFrame
		local d = self.d
		local f = self.f*(2*pi)
		local g = self.g
		local p0 = self.p
		local v0 = self.v

		local offset = axisAngleDiff(p0, g)
		local decay = exp(-d*f*dt)

		local pt: CFrame
		local vt: Vector3

		if d == 1 then -- critically damped
			pt = rotateAxis((offset*(1 + f*dt) + v0*dt)*decay, g)
			vt = (v0*(1 - dt*f) - offset*(dt*f*f))*decay

		elseif d < 1 then -- underdamped
			local c = sqrt(1 - d*d)

			local i = cos(dt*f*c)
			local j = sin(dt*f*c)

			local y = j/(f*c)
			local z = j/c

			pt = rotateAxis((offset*(i + z*d) + v0*y)*decay, g)
			vt = (v0*(i - z*d) - offset*(z*f))*decay

		else -- overdamped
			local c = sqrt(d*d - 1)

			local r1 = -f*(d + c)
			local r2 = -f*(d - c)

			local co2 = (v0 - offset*r1)/(2*f*c)
			local co1 = offset - co2

			local e1 = co1*exp(r1*dt)
			local e2 = co2*exp(r2*dt)

			pt = rotateAxis(e1 + e2, g)
			vt = e1*r1 + e2*r2
		end

		self.p = pt
		self.v = vt

		return pt
	end
end

-- Defined early to be used by CFrameSpring
local typeMetadata_Vector3 = {
	springType = LinearSpring.new,

	toIntermediate = function(value)
		return {value.X, value.Y, value.Z}
	end,

	fromIntermediate = function(value: {number})
		return Vector3.new(value[1], value[2], value[3])
	end,
}

-- Encapsulates a CFrame - Separates translation from rotation
local CFrameSpring = {}
do
	CFrameSpring.__index = CFrameSpring

	function CFrameSpring.new(
		dampingRatio: number,
		frequency: number,
		valueCurrent: CFrame,
		valueGoal: CFrame,
		_: any
	)
		return setmetatable(
			{
				rawGoal = valueGoal,
				_position = LinearSpring.new(dampingRatio, frequency, valueCurrent.Position, valueGoal.Position, typeMetadata_Vector3),
				_rotation = RotationSpring.new(dampingRatio, frequency, valueCurrent.Rotation, valueGoal.Rotation)
			},
			CFrameSpring
		)
	end

	function CFrameSpring:setGoal(value: CFrame)
		self.rawGoal = value
		self._position:setGoal(value.Position)
		self._rotation:setGoal(value.Rotation)
	end

	function CFrameSpring:setDampingRatio(value: number)
		self._position.d = value
		self._rotation.d = value
	end

	function CFrameSpring:setFrequency(value: number)
		self._position.f = value
		self._rotation.f = value
	end

	function CFrameSpring:canSleep()
		return self._position:canSleep() and self._rotation:canSleep()
	end

	function CFrameSpring:step(dt): CFrame
		local p: Vector3 = self._position:step(dt)
		local r: CFrame = self._rotation:step(dt)
		return r + p
	end
end

-- Color conversions
local rgbToLuv
local luvToRgb
do
	local function inverseGammaCorrectD65(c)
		return c < 0.0404482362771076 and c/12.92 or 0.87941546140213*(c + 0.055)^2.4
	end

	local function gammaCorrectD65(c)
		return c < 3.1306684425e-3 and 12.92*c or 1.055*c^(1/2.4) - 0.055
	end

	function rgbToLuv(value: Color3): {number}
		-- convert RGB to a variant of cieluv space
		local r, g, b = value.R, value.G, value.B

		-- D65 sRGB inverse gamma correction
		r = inverseGammaCorrectD65(r)
		g = inverseGammaCorrectD65(g)
		b = inverseGammaCorrectD65(b)

		-- sRGB -> xyz
		local x = 0.9257063972951867*r - 0.8333736323779866*g - 0.09209820666085898*b
		local y = 0.2125862307855956*r + 0.71517030370341085*g + 0.0722004986433362*b
		local z = 3.6590806972265883*r + 11.4426895800574232*g + 4.1149915024264843*b

		-- xyz -> scaled cieluv
		local l = y > 0.008856451679035631 and 116*y^(1/3) - 16 or 903.296296296296*y

		local u, v
		if z > 1e-14 then
			u = l*x/z
			v = l*(9*y/z - 0.46832)
		else
			u = -0.19783*l
			v = -0.46832*l
		end

		return {l, u, v}
	end

	function luvToRgb(value: {number}): Color3
		-- convert back from modified cieluv to rgb space
		local l = value[1]
		if l < 0.0197955 then
			return Color3.new(0, 0, 0)
		end
		local u = value[2]/l + 0.19783
		local v = value[3]/l + 0.46832

		-- cieluv -> xyz
		local y = (l + 16)/116
		y = y > 0.206896551724137931 and y*y*y or 0.12841854934601665*y - 0.01771290335807126
		local x = y*u/v
		local z = y*((3 - 0.75*u)/v - 5)

		-- xyz -> D65 sRGB
		local r =  7.2914074*x - 1.5372080*y - 0.4986286*z
		local g = -2.1800940*x + 1.8757561*y + 0.0415175*z
		local b =  0.1253477*x - 0.2040211*y + 1.0569959*z

		-- clamp minimum sRGB component
		if r < 0 and r < g and r < b then
			r, g, b = 0, g - r, b - r
		elseif g < 0 and g < b then
			r, g, b = r - g, 0, b - g
		elseif b < 0 then
			r, g, b = r - b, g - b, 0
		end

		-- gamma correction from D65
		-- clamp to avoid undesirable overflow wrapping behavior on certain properties (e.g. BasePart.Color)
		return Color3.new(
			min(gammaCorrectD65(r), 1),
			min(gammaCorrectD65(g), 1),
			min(gammaCorrectD65(b), 1)
		)
	end
end

-- Type definitions
-- Transforms Roblox types into intermediate types, converting
-- between spaces as necessary to preserve perceptual linearity
local typeMetadata = {
	boolean = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value and 1 or 0}
		end,

		fromIntermediate = function(value)
			return value[1] >= 0.5
		end,
	},

	number = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value}
		end,

		fromIntermediate = function(value)
			return value[1]
		end,
	},

	NumberRange = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value.Min, value.Max}
		end,

		fromIntermediate = function(value)
			return NumberRange.new(value[1], value[2])
		end,
	},

	UDim = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value.Scale, value.Offset}
		end,

		fromIntermediate = function(value: {number})
			return UDim.new(value[1], round(value[2]))
		end,
	},

	UDim2 = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			local x = value.X
			local y = value.Y
			return {x.Scale, x.Offset, y.Scale, y.Offset}
		end,

		fromIntermediate = function(value: {number})
			return UDim2.new(value[1], round(value[2]), value[3], round(value[4]))
		end,
	},

	Vector2 = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value.X, value.Y}
		end,

		fromIntermediate = function(value: {number})
			return Vector2.new(value[1], value[2])
		end,
	},

	Vector3 = typeMetadata_Vector3,

	Color3 = {
		springType = LinearSpring.new,
		toIntermediate = rgbToLuv,
		fromIntermediate = luvToRgb,
	},

	-- Only interpolates start and end keypoints
	ColorSequence = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			local keypoints = value.Keypoints

			local luv0 = rgbToLuv(keypoints[1].Value)
			local luv1 = rgbToLuv(keypoints[#keypoints].Value)

			return {
				luv0[1], luv0[2], luv0[3],
				luv1[1], luv1[2], luv1[3],
			}
		end,

		fromIntermediate = function(value: {})
			return ColorSequence.new(
				luvToRgb{value[1], value[2], value[3]},
				luvToRgb{value[4], value[5], value[6]}
			)
		end,
	},

	CFrame = {
		springType = CFrameSpring.new,
		toIntermediate = error, -- custom (CFrameSpring)
		fromIntermediate = error, -- custom (CFrameSpring)
	}
}

type PropertyOverride = {
	[string]: {
		class: string,
		get: (any)->(),
		set: (any, any)->(),
	}
}

local PSEUDO_PROPERTIES: PropertyOverride = {
	Pivot = {
		class = "PVInstance",
		get = function(inst: PVInstance)
			return inst:GetPivot()
		end,
		set = function(inst: PVInstance, value: CFrame)
			inst:PivotTo(value)
		end
	},
	Scale = {
		class = "Model",
		get = function(inst: Model)
			return inst:GetScale()
		end,
		set = function(inst: Model, value: number)
			local FLOAT_MANTISSA_MIN = 1.402e-45
			local FLOAT_MANTISSA_MAX = 2^24
			value = math.clamp(value, FLOAT_MANTISSA_MIN, FLOAT_MANTISSA_MAX)
			inst:ScaleTo(value)
		end
	}
}

local function getProperty(instance: Instance, property: string): any
	local override = PSEUDO_PROPERTIES[property]
	if override and instance:IsA(override.class) then
		return override.get(instance)
	else
		return (instance :: any)[property]
	end
end

local function setProperty(instance: Instance, property: string, value: unknown)
	local override = PSEUDO_PROPERTIES[property]
	if override and instance:IsA(override.class) then
		override.set(instance, value)
	else
		(instance :: any)[property] = value
	end
end

-- Frame loop
local springStates_other: {[Instance]: {[string]: any}} = {} -- {[instance] = {[property] = spring}
local springStates_render: {[Instance]: {[string]: any}} = {} -- {[instance] = {[property] = spring}
local completedCallbacks: {[Instance]: {()->()}} = {}

local function processSprings(springStates: typeof(springStates_other), dt: number)
	for instance, state in springStates do
		for propName, spring in state do
			if spring:canSleep() then
				state[propName] = nil
				setProperty(instance, propName, spring.rawGoal)
			else
				setProperty(instance, propName, spring:step(dt))
			end
		end

		if not next(state) then
			springStates[instance] = nil

			-- trigger completed callbacks when all properties finish animating
			local callbackList = completedCallbacks[instance]
			if callbackList then
				-- flush callback list before we run any callbacks in case
				-- one of the callbacks recursively adds another callback
				completedCallbacks[instance] = nil

				for _, callback in callbackList do
					task.spawn(callback)
				end
			end
		end
	end
end

RunService.PreSimulation:Connect(function(dt)
	processSprings(springStates_other, dt)
end)

RunService.PostSimulation:Connect(function(dt)
	processSprings(springStates_render, dt)
end)

local function assertType(argNum: number, fnName: string, expectedType: string, value: unknown)
	if not expectedType:find(typeof(value)) then
		error(`bad argument #{argNum} to {fnName} ({expectedType} expected, got {typeof(value)})`, 3)
	end
end

-- API
local spr = {}

function spr.target(instance: Instance, dampingRatio: number, frequency: number, properties: {[string]: any})
	if STRICT_RUNTIME_TYPES then
		assertType(1, "spr.target", "Instance", instance)
		assertType(2, "spr.target", "number", dampingRatio)
		assertType(3, "spr.target", "number", frequency)
		assertType(4, "spr.target", "table", properties)
	end

	if dampingRatio ~= dampingRatio or dampingRatio < 0 then
		error(("expected damping ratio >= 0; got %.2f"):format(dampingRatio), 2)
	end

	if frequency ~= frequency or frequency < 0 then
		error(("expected undamped frequency >= 0; got %.2f"):format(frequency), 2)
	end

	local targetRecord = (if instance:IsA("Camera") then springStates_render else springStates_other) :: {[Instance]: {[string]: any}}

	local state = targetRecord[instance]
	if not state then
		state = {}
		targetRecord[instance] = state
	end

	for propName, propTarget in properties do
		local propValue = getProperty(instance, propName)

		if STRICT_RUNTIME_TYPES and typeof(propTarget) ~= typeof(propValue) then
			error(`bad property {propName} to spr.target ({typeof(propValue)} expected, got {typeof(propTarget)})`, 2)
		end

		-- Special case infinite frequency for an instantaneous change
		if frequency == math.huge then
			setProperty(instance, propName, propTarget)
			state[propName] = nil
			continue
		end

		local spring = state[propName]
		if not spring then
			local md = typeMetadata[typeof(propTarget)]
			if not md then
				error("unsupported type: " .. typeof(propTarget), 2)
			end

			spring = md.springType(dampingRatio, frequency, propValue, propTarget, md)
			state[propName] = spring
		end

		spring:setGoal(propTarget)
		spring:setDampingRatio(dampingRatio)
		spring:setFrequency(frequency)
	end

	if not next(state) then
		targetRecord[instance] = nil
	end
end

function spr.stop(instance: Instance, property: string?)
	if STRICT_RUNTIME_TYPES then
		assertType(1, "spr.stop", "Instance", instance)
		assertType(2, "spr.stop", "string|nil", property)
	end

	if property then
		local state = springStates_other[instance] or springStates_render[instance]
		if state then
			state[property] = nil
		end
	else
		springStates_other[instance] = nil
		springStates_render[instance] = nil
	end
end

function spr.completed(instance: Instance, callback: ()->())
	if STRICT_RUNTIME_TYPES then
		assertType(1, "spr.completed", "Instance", instance)
		assertType(2, "spr.completed", "function", callback)
	end

	local callbackList = completedCallbacks[instance]
	if callbackList then
		table.insert(callbackList, callback)
	else
		completedCallbacks[instance] = {callback}
	end
end

return table.freeze(spr)]]></ProtectedString>
						<string name="ScriptGuid">{11974A4C-E3B3-40C4-9708-55C548ED8D1A}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Spr.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD4F1428361C24DE395FD8D72F569D17A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Vendor/Find.lua
--
--  Description:
--      Utility function to locate a descendant instance by name.
--      Calls a callback immediately if found, otherwise waits for
--      DescendantAdded and disconnects once the instance appears.
--
--  Author(s): Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox API:
--          * Instance:FindFirstChild
--          * Instance.DescendantAdded
--
--  Notes:
--      - Usage:
--          local Find = require(ReplicatedStorage.Vendor.Find)
--          Find(workspace, "TargetPart", function(obj)
--              print("Found:", obj:GetFullName())
--          end)
--      - Disconnects listener once object is found
--
--======================================================================


return function(root:Instance,ref:string,callback)
	local result = root:FindFirstChild(ref,true)
	if result then
		callback(result)
	end

	local conn:RBXScriptConnection
	conn = root.DescendantAdded:Connect(function(newObj:Instance)
		if newObj.Name == ref then
			conn:Disconnect()
			callback(newObj)
		end
	end)

end]]></ProtectedString>
						<string name="ScriptGuid">{166DE562-EAF9-41DE-AF57-A71683EC910F}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Find.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7892BDB1B27644E49C1322D4700A2D26">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Vendor/Trove.lua
--
--  Description:
--      Utility for managing collections of cleanup tasks (connections,
--      Instances, functions) grouped into a “Trove”. When the trove is
--      destroyed, all registered items are cleaned up automatically.
--
--  Author(s): (original author upstream) — vendored by Darkzeb
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: vendored version
--
--  Dependencies:
--      - Roblox API:
--          * Instance connection/disconnect
--          * :Destroy for Instances
--          * Property `.Parent`, AncestryChanged (if auto-binding to parent)
--
--  Notes:
--      - Use `Trove.new([parent])` to create a new trove optionally bound to a parent Instance
--      - Methods:
--          * `Add(item)` – registers cleanup for connection, Instance, or function
--          * `Remove(item)` / `Unlink(item)` – removes item from trove without cleanup
--          * `Destroy()` – triggers cleanup for all registered items
--      - If parent is provided, trove auto-destroys when parent is removed from the game
--      - Commonly used to manage lifetime of connections and instances in components/controllers
--
--======================================================================

--!strict

local RunService = game:GetService("RunService")

export type Trove = {
	Extend: (self: Trove) -> Trove,
	Clone: <T>(self: Trove, instance: T & Instance) -> T,
	Construct: <T, A...>(self: Trove, class: Constructable<T, A...>, A...) -> T,
	Connect: (self: Trove, signal: SignalLike | RBXScriptSignal, fn: (...any) -> ...any) -> ConnectionLike,
	BindToRenderStep: (self: Trove, name: string, priority: number, fn: (dt: number) -> ()) -> (),
	AddPromise: <T>(self: Trove, promise: T & PromiseLike) -> T,
	Add: <T>(self: Trove, object: T & Trackable, cleanupMethod: string?) -> T,
	Remove: <T>(self: Trove, object: T & Trackable) -> boolean,
	Clean: (self: Trove) -> (),
	AttachToInstance: (self: Trove, instance: Instance) -> RBXScriptConnection,
	Destroy: (self: Trove) -> (),
}

type TroveInternal = Trove & {
	_objects: { any },
	_cleaning: boolean,
	_findAndRemoveFromObjects: (self: TroveInternal, object: any, cleanup: boolean) -> boolean,
	_cleanupObject: (self: TroveInternal, object: any, cleanupMethod: string?) -> (),
}

--[=[
	@within Trove
	@type Trackable Instance | RBXScriptConnection | ConnectionLike | PromiseLike | thread | ((...any) -> ...any) | Destroyable | DestroyableLowercase | Disconnectable | DisconnectableLowercase
	Represents all trackable objects by Trove.
]=]
export type Trackable =
	Instance
| RBXScriptConnection
| ConnectionLike
| PromiseLike
| thread
| ((...any) -> ...any)
| Destroyable
| DestroyableLowercase
| Disconnectable
| DisconnectableLowercase

--[=[
	@within Trove
	@interface ConnectionLike
	.Connected boolean
	.Disconnect (self) -> ()
]=]
type ConnectionLike = {
	Connected: boolean,
	Disconnect: (self: ConnectionLike) -> (),
}

--[=[
	@within Trove
	@interface SignalLike
	.Connect (self, callback: (...any) -> ...any) -> ConnectionLike
	.Once (self, callback: (...any) -> ...any) -> ConnectionLike
]=]
type SignalLike = {
	Connect: (self: SignalLike, callback: (...any) -> ...any) -> ConnectionLike,
	Once: (self: SignalLike, callback: (...any) -> ...any) -> ConnectionLike,
}

--[=[
	@within Trove
	@interface PromiseLike
	.getStatus (self) -> string
	.finally (self, callback: (...any) -> ...any) -> PromiseLike
	.cancel (self) -> ()
]=]
type PromiseLike = {
	getStatus: (self: PromiseLike) -> string,
	finally: (self: PromiseLike, callback: (...any) -> ...any) -> PromiseLike,
	cancel: (self: PromiseLike) -> (),
}

--[=[
	@within Trove
	@type Constructable { new: (A...) -> T } | (A...) -> T
]=]
type Constructable<T, A...> = { new: (A...) -> T } | (A...) -> T

--[=[
	@within Trove
	@interface Destroyable
	.disconnect (self) -> ()
]=]
type Destroyable = {
	Destroy: (self: Destroyable) -> (),
}

--[=[
	@within Trove
	@interface DestroyableLowercase
	.disconnect (self) -> ()
]=]
type DestroyableLowercase = {
	destroy: (self: DestroyableLowercase) -> (),
}

--[=[
	@within Trove
	@interface Disconnectable
	.disconnect (self) -> ()
]=]
type Disconnectable = {
	Disconnect: (self: Disconnectable) -> (),
}

--[=[
	@within Trove
	@interface DisconnectableLowercase
	.disconnect (self) -> ()
]=]
type DisconnectableLowercase = {
	disconnect: (self: DisconnectableLowercase) -> (),
}

local FN_MARKER = newproxy()
local THREAD_MARKER = newproxy()
local GENERIC_OBJECT_CLEANUP_METHODS = table.freeze({ "Destroy", "Disconnect", "destroy", "disconnect" })

local function GetObjectCleanupFunction(object: any, cleanupMethod: string?)
	local t = typeof(object)

	if t == "function" then
		return FN_MARKER
	elseif t == "thread" then
		return THREAD_MARKER
	end

	if cleanupMethod then
		return cleanupMethod
	end

	if t == "Instance" then
		return "Destroy"
	elseif t == "RBXScriptConnection" then
		return "Disconnect"
	elseif t == "table" then
		for _, genericCleanupMethod in GENERIC_OBJECT_CLEANUP_METHODS do
			if typeof(object[genericCleanupMethod]) == "function" then
				return genericCleanupMethod
			end
		end
	end

	error(`failed to get cleanup function for object {t}: {object}`, 3)
end

local function AssertPromiseLike(object: any)
	if
		typeof(object) ~= "table"
		or typeof(object.getStatus) ~= "function"
		or typeof(object.finally) ~= "function"
		or typeof(object.cancel) ~= "function"
	then
		error("did not receive a promise as an argument", 3)
	end
end

--[=[
	@class Trove
	A Trove is helpful for tracking any sort of object during
	runtime that needs to get cleaned up at some point.
]=]
local Trove = {}
Trove.__index = Trove

--[=[
	@return Trove
	Constructs a Trove object.

	```lua
	local trove = Trove.new()
	```
]=]
function Trove.new(): Trove
	local self = setmetatable({}, Trove)

	self._objects = {}
	self._cleaning = false

	return (self :: any) :: Trove
end

--[=[
	@method Add
	@within Trove
	@param object any -- Object to track
	@param cleanupMethod string? -- Optional cleanup name override
	@return object: any
	Adds an object to the trove. Once the trove is cleaned or
	destroyed, the object will also be cleaned up.

	The following types are accepted (e.g. `typeof(object)`):

	| Type | Cleanup |
	| ---- | ------- |
	| `Instance` | `object:Destroy()` |
	| `RBXScriptConnection` | `object:Disconnect()` |
	| `function` | `object()` |
	| `thread` | `task.cancel(object)` |
	| `table` | `object:Destroy()` _or_ `object:Disconnect()` _or_ `object:destroy()` _or_ `object:disconnect()` |
	| `table` with `cleanupMethod` | `object:<cleanupMethod>()` |

	Returns the object added.

	```lua
	-- Add a part to the trove, then destroy the trove,
	-- which will also destroy the part:
	local part = Instance.new("Part")
	trove:Add(part)
	trove:Destroy()

	-- Add a function to the trove:
	trove:Add(function()
		print("Cleanup!")
	end)
	trove:Destroy()

	-- Standard cleanup from table:
	local tbl = {}
	function tbl:Destroy()
		print("Cleanup")
	end
	trove:Add(tbl)

	-- Custom cleanup from table:
	local tbl = {}
	function tbl:DoSomething()
		print("Do something on cleanup")
	end
	trove:Add(tbl, "DoSomething")
	```
]=]
function Trove.Add(self: TroveInternal, object: Trackable, cleanupMethod: string?): any
	if self._cleaning then
		error("cannot call trove:Add() while cleaning", 2)
	end

	local cleanup = GetObjectCleanupFunction(object, cleanupMethod)
	table.insert(self._objects, { object, cleanup })

	return object
end

--[=[
	@method Clone
	@within Trove
	@return Instance
	Clones the given instance and adds it to the trove. Shorthand for
	`trove:Add(instance:Clone())`.

	```lua
	local clonedPart = trove:Clone(somePart)
	```
]=]
function Trove.Clone(self: TroveInternal, instance: Instance): Instance
	if self._cleaning then
		error("cannot call trove:Clone() while cleaning", 2)
	end

	return self:Add(instance:Clone())
end

--[=[
	@method Construct
	@within Trove
	@param class { new(Args...) -> T } | (Args...) -> T
	@param ... Args...
	@return T
	Constructs a new object from either the
	table or function given.

	If a table is given, the table's `new`
	function will be called with the given
	arguments.

	If a function is given, the function will
	be called with the given arguments.
	
	The result from either of the two options
	will be added to the trove.

	This is shorthand for `trove:Add(SomeClass.new(...))`
	and `trove:Add(SomeFunction(...))`.

	```lua
	local Signal = require(somewhere.Signal)

	-- All of these are identical:
	local s = trove:Construct(Signal)
	local s = trove:Construct(Signal.new)
	local s = trove:Construct(function() return Signal.new() end)
	local s = trove:Add(Signal.new())

	-- Even Roblox instances can be created:
	local part = trove:Construct(Instance, "Part")
	```
]=]
function Trove.Construct<T, A...>(self: TroveInternal, class: Constructable<T, A...>, ...: A...)
	if self._cleaning then
		error("Cannot call trove:Construct() while cleaning", 2)
	end

	local object = nil
	local t = type(class)
	if t == "table" then
		object = (class :: any).new(...)
	elseif t == "function" then
		object = (class :: any)(...)
	end

	return self:Add(object)
end

--[=[
	@method Connect
	@within Trove
	@param signal RBXScriptSignal
	@param fn (...: any) -> ()
	@return RBXScriptConnection
	Connects the function to the signal, adds the connection
	to the trove, and then returns the connection.

	This is shorthand for `trove:Add(signal:Connect(fn))`.

	```lua
	trove:Connect(workspace.ChildAdded, function(instance)
		print(instance.Name .. " added to workspace")
	end)
	```
]=]
function Trove.Connect(self: TroveInternal, signal: SignalLike, fn: (...any) -> ...any)
	if self._cleaning then
		error("Cannot call trove:Connect() while cleaning", 2)
	end

	return self:Add(signal:Connect(fn))
end

--[=[
	@method BindToRenderStep
	@within Trove
	@param name string
	@param priority number
	@param fn (dt: number) -> ()
	Calls `RunService:BindToRenderStep` and registers a function in the
	trove that will call `RunService:UnbindFromRenderStep` on cleanup.

	```lua
	trove:BindToRenderStep("Test", Enum.RenderPriority.Last.Value, function(dt)
		-- Do something
	end)
	```
]=]
function Trove.BindToRenderStep(self: TroveInternal, name: string, priority: number, fn: (dt: number) -> ())
	if self._cleaning then
		error("cannot call trove:BindToRenderStep() while cleaning", 2)
	end

	RunService:BindToRenderStep(name, priority, fn)

	self:Add(function()
		RunService:UnbindFromRenderStep(name)
	end)
end

--[=[
	@method AddPromise
	@within Trove
	@param promise Promise
	@return Promise
	Gives the promise to the trove, which will cancel the promise if the trove is cleaned up or if the promise
	is removed. The exact promise is returned, thus allowing chaining.

	```lua
	trove:AddPromise(doSomethingThatReturnsAPromise())
		:andThen(function()
			print("Done")
		end)
	-- Will cancel the above promise (assuming it didn't resolve immediately)
	trove:Clean()

	local p = trove:AddPromise(doSomethingThatReturnsAPromise())
	-- Will also cancel the promise
	trove:Remove(p)
	```

	:::caution Promise v4 Only
	This is only compatible with the [roblox-lua-promise](https://eryn.io/roblox-lua-promise/) library, version 4.
	:::
]=]
function Trove.AddPromise(self: TroveInternal, promise: PromiseLike)
	if self._cleaning then
		error("cannot call trove:AddPromise() while cleaning", 2)
	end
	AssertPromiseLike(promise)

	if promise:getStatus() == "Started" then
		promise:finally(function()
			if self._cleaning then
				return
			end
			self:_findAndRemoveFromObjects(promise, false)
		end)

		self:Add(promise, "cancel")
	end

	return promise
end

--[=[
	@method Remove
	@within Trove
	@param object any
	Removes the object from the Trove and cleans it up.

	```lua
	local part = Instance.new("Part")
	trove:Add(part)
	trove:Remove(part)
	```
]=]
function Trove.Remove(self: TroveInternal, object: Trackable): boolean
	if self._cleaning then
		error("cannot call trove:Remove() while cleaning", 2)
	end

	return self:_findAndRemoveFromObjects(object, true)
end

--[=[
	@method Extend
	@within Trove
	@return Trove
	Creates and adds another trove to itself. This is just shorthand
	for `trove:Construct(Trove)`. This is useful for contexts where
	the trove object is present, but the class itself isn't.

	:::note
	This does _not_ clone the trove. In other words, the objects in the
	trove are not given to the new constructed trove. This is simply to
	construct a new Trove and add it as an object to track.
	:::

	```lua
	local trove = Trove.new()
	local subTrove = trove:Extend()

	trove:Clean() -- Cleans up the subTrove too
	```
]=]
function Trove.Extend(self: TroveInternal)
	if self._cleaning then
		error("cannot call trove:Extend() while cleaning", 2)
	end

	return self:Construct(Trove)
end

--[=[
	@method Clean
	@within Trove
	Cleans up all objects in the trove. This is
	similar to calling `Remove` on each object
	within the trove. The ordering of the objects
	removed is _not_ guaranteed.

	```lua
	trove:Clean()
	```
]=]
function Trove.Clean(self: TroveInternal)
	if self._cleaning then
		return
	end

	self._cleaning = true

	for _, obj in self._objects do
		self:_cleanupObject(obj[1], obj[2])
	end

	table.clear(self._objects)
	self._cleaning = false
end

--[=[
	@method WrapClean
	@within Trove
	Returns a function that wraps the trove's `Clean()`
	method. Calling the returned function will clean up
	the trove.

	This is often useful in contexts where functions
	are the primary mode for cleaning up an environment,
	such as in many "observer" patterns.

	```lua
	local cleanup = trove:WrapClean()

	-- Sometime later...
	cleanup()
	```

	```lua
	-- Common observer pattern example:
	someObserver(function()
		local trove = Trove.new()
		-- Foo
		return trove:WrapClean()
	end)
	```
]=]
function Trove.WrapClean(self: TroveInternal)
	return function()
		self:Clean()
	end
end

function Trove._findAndRemoveFromObjects(self: TroveInternal, object: any, cleanup: boolean): boolean
	local objects = self._objects

	for i, obj in objects do
		if obj[1] == object then
			local n = #objects
			objects[i] = objects[n]
			objects[n] = nil

			if cleanup then
				self:_cleanupObject(obj[1], obj[2])
			end

			return true
		end
	end

	return false
end

function Trove._cleanupObject(_self: TroveInternal, object: any, cleanupMethod: string?)
	if cleanupMethod == FN_MARKER then
		task.spawn(object)
	elseif cleanupMethod == THREAD_MARKER then
		pcall(task.cancel, object)
	else
		object[cleanupMethod](object)
	end
end

--[=[
	@method AttachToInstance
	@within Trove
	@param instance Instance
	@return RBXScriptConnection
	Attaches the trove to a Roblox instance. Once this
	instance is removed from the game (parent or ancestor's
	parent set to `nil`), the trove will automatically
	clean up.

	This inverses the ownership of the Trove object, and should
	only be used when necessary. In other words, the attached
	instance dictates when the trove is cleaned up, rather than
	the trove dictating the cleanup of the instance.

	:::caution
	Will throw an error if `instance` is not a descendant
	of the game hierarchy.
	:::

	```lua
	trove:AttachToInstance(somePart)
	trove:Add(function()
		print("Cleaned")
	end)

	-- Destroying the part will cause the trove to clean up, thus "Cleaned" printed:
	somePart:Destroy()
	```
]=]
function Trove.AttachToInstance(self: TroveInternal, instance: Instance)
	if self._cleaning then
		error("cannot call trove:AttachToInstance() while cleaning", 2)
	elseif not instance:IsDescendantOf(game) then
		error("instance is not a descendant of the game hierarchy", 2)
	end

	return self:Connect(instance.Destroying, function()
		self:Destroy()
	end)
end

--[=[
	@method Destroy
	@within Trove
	Alias for `trove:Clean()`.

	```lua
	trove:Destroy()
	```
]=]
function Trove.Destroy(self: TroveInternal)
	self:Clean()
end

return {
	new = Trove.new,
}
]]></ProtectedString>
						<string name="ScriptGuid">{9B713D75-700A-48F5-A8FC-6770B22DC0C8}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Trove.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX54FDFDB6775C40EBBCF020872357A07E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	
	The majority of this code is an interface designed to make it easy for you to
	work with TopbarPlus (most methods for instance reference :modifyTheme()).
	The processing overhead mainly consists of applying themes and calculating 
	appearance (such as size and width of labels) which is handled in about
	200 lines of code here and the Widget UI module. This has been achieved
	in v3 by outsourcing a majority of previous calculations to inbuilt Roblox
	features like UIListLayouts.


	v3 provides inbuilt support for controllers (simply press DPadUp),
	touch devices (phones, tablets , etc), localization (automatic resizing
	of widgets, autolocalize for relevant labels), backwards compatability
	with the old topbar, and more.


	My primary goals for the v3 re-write have been to:
		
	1. Improve code readability and organisation (reduced lines of code within
	   Icon+IconController from 3200 to ~950, separated UI elements, etc)
		
	2. Improve ease-of-use (themes now actually make sense and can account
	   for any modifications you want, converted to a package for
	   quick installation and easy-comparisons of new updates, etc)
	
	3. Provide support for all key features of the new Roblox topbar
	   while improving performance of the module (deferring and collecting
	   changes then calling as a singular, utilizing inbuilt Roblox features
	   such as UILIstLayouts, etc)

--]]



-- SERVICES
local UserInputService = game:GetService("UserInputService")
local ContentProvider = game:GetService("ContentProvider")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local Types = require(script.Types)



-- TYPES
export type Icon = Types.Icon



-- REFERENCE HANDLER
-- Multiple Icons packages may exist at runtime (for instance if the developer additionally uses HD Admin)
-- therefore this ensures that the first required package becomes the dominant and only functioning module
local iconModule = script
local Reference = require(iconModule.Reference)
local referenceObject = Reference.getObject()
local leadPackage = referenceObject and referenceObject.Value
if leadPackage and leadPackage ~= iconModule then
	return require(leadPackage) :: Types.StaticIcon
end
if not referenceObject then
	Reference.addToReplicatedStorage()
end



-- MODULES
local Signal = require(iconModule.Packages.GoodSignal)
local Janitor = require(iconModule.Packages.Janitor)
local Utility = require(iconModule.Utility)
local Themes = require(iconModule.Features.Themes)
local Gamepad = require(iconModule.Features.Gamepad)
local Overflow = require(iconModule.Features.Overflow)
local Icon = {}
Icon.__index = Icon



--- LOCAL
local localPlayer = Players.LocalPlayer
local themes = iconModule.Features.Themes
local iconsDict = {}
local anyIconSelected = Signal.new()
local elements = iconModule.Elements
local totalCreatedIcons = 0
local preferredInput = {
	mobile = Enum.PreferredInput.Touch,
	desktop = Enum.PreferredInput.KeyboardAndMouse,
	console = Enum.PreferredInput.Gamepad
}



-- PUBLIC VARIABLES
Icon.baseDisplayOrderChanged = Signal.new()
Icon.baseDisplayOrder = 10
Icon.baseTheme = require(themes.Default)
Icon.isOldTopbar = false -- Logic has been moved to Container
Icon.iconsDictionary = iconsDict
Icon.insetHeightChanged = Signal.new()
Icon.container = require(elements.Container)(Icon)
Icon.topbarEnabled = true
Icon.iconAdded = Signal.new()
Icon.iconRemoved = Signal.new()
Icon.iconChanged = Signal.new()



-- PUBLIC FUNCTIONS
function Icon.getIcons()
	return Icon.iconsDictionary
end

function Icon.getIconByUID(UID)
	local match = Icon.iconsDictionary[UID]
	if match then
		return match
	end
	return nil
end

function Icon.getIcon(nameOrUID)
	local match = Icon.getIconByUID(nameOrUID)
	if match then
		return match
	end
	for _, icon in pairs(iconsDict) do
		if icon.name == nameOrUID then
			return icon
		end
	end
	return nil
end

function Icon.setTopbarEnabled(bool, isInternal)
	if typeof(bool) ~= "boolean" then
		bool = Icon.topbarEnabled
	end
	if not isInternal then
		Icon.topbarEnabled = bool
	end
	for _, screenGui in pairs(Icon.container) do
		screenGui.Enabled = bool
	end
end

function Icon.modifyBaseTheme(modifications)
	modifications = Themes.getModifications(modifications)
	for _, modification in pairs(modifications) do
		for _, detail in pairs(Icon.baseTheme) do
			Themes.merge(detail, modification)
		end
	end
	for _, icon in pairs(iconsDict) do
		icon:setTheme(Icon.baseTheme)
	end
end

function Icon.setDisplayOrder(int)
	Icon.baseDisplayOrder = int
	Icon.baseDisplayOrderChanged:Fire(int)
end



-- SETUP
task.defer(Gamepad.start, Icon)
task.defer(Overflow.start, Icon)
task.defer(function()
	local playerGui = localPlayer:WaitForChild("PlayerGui")
	for _, screenGui in pairs(Icon.container) do
		screenGui.Parent = playerGui
	end
	require(iconModule.Attribute)
end)



-- CONSTRUCTOR
function Icon.new()
	local self = {}
	setmetatable(self, Icon)

	--- Janitors (for cleanup)
	local janitor = Janitor.new()
	self.janitor = janitor
	self.themesJanitor = janitor:add(Janitor.new())
	self.singleClickJanitor = janitor:add(Janitor.new())
	self.captionJanitor = janitor:add(Janitor.new())
	self.joinJanitor = janitor:add(Janitor.new())
	self.menuJanitor = janitor:add(Janitor.new())
	self.dropdownJanitor = janitor:add(Janitor.new())

	-- Register
	local iconUID = Utility.generateUID()
	iconsDict[iconUID] = self
	janitor:add(function()
		iconsDict[iconUID] = nil
	end)

	-- Signals (events)
	self.selected = janitor:add(Signal.new())
	self.deselected = janitor:add(Signal.new())
	self.toggled = janitor:add(Signal.new())
	self.viewingStarted = janitor:add(Signal.new())
	self.viewingEnded = janitor:add(Signal.new())
	self.stateChanged = janitor:add(Signal.new())
	self.notified = janitor:add(Signal.new())
	self.noticeStarted = janitor:add(Signal.new())
	self.noticeChanged = janitor:add(Signal.new())
	self.endNotices = janitor:add(Signal.new())
	self.toggleKeyAdded = janitor:add(Signal.new())
	self.fakeToggleKeyChanged = janitor:add(Signal.new())
	self.alignmentChanged = janitor:add(Signal.new())
	self.updateSize = janitor:add(Signal.new())
	self.resizingComplete = janitor:add(Signal.new())
	self.joinedParent = janitor:add(Signal.new())
	self.menuSet = janitor:add(Signal.new())
	self.dropdownSet = janitor:add(Signal.new())
	self.updateMenu = janitor:add(Signal.new())
	self.startMenuUpdate = janitor:add(Signal.new())
	self.childThemeModified = janitor:add(Signal.new())
	self.indicatorSet = janitor:add(Signal.new())
	self.dropdownChildAdded = janitor:add(Signal.new())
	self.menuChildAdded = janitor:add(Signal.new())

	-- Properties
	self.iconModule = iconModule
	self.UID = iconUID
	self.isEnabled = true
	self.enabled = self.isEnabled -- Backwards compatability
	self.isSelected = false
	self.isViewing = false
	self.joinedFrame = false
	self.parentIconUID = false
	self.deselectWhenOtherIconSelected = true
	self.totalNotices = 0
	self.activeState = "Deselected"
	self.alignment = ""
	self.originalAlignment = ""
	self.appliedTheme = {}
	self.appearance = {}
	self.cachedInstances = {}
	self.cachedNamesToInstances = {}
	self.cachedCollectives = {}
	self.bindedToggleKeys = {}
	self.customBehaviours = {}
	self.toggleItems = {}
	self.bindedEvents = {}
	self.notices = {}
	self.menuIcons = {}
	self.dropdownIcons = {}
	self.childIconsDict = {}
	self.creationTime = os.clock()

	-- Widget is the new name for an icon
	local widget = janitor:add(require(elements.Widget)(self, Icon))
	self.widget = widget
	self:setAlignment()
	
	-- It's important we set an order otherwise icons will not align
	-- correctly within menus
	totalCreatedIcons += 1
	local ourOrder = 1+(totalCreatedIcons*0.01)
	self:setOrder(ourOrder, "deselected")
	self:setOrder(ourOrder, "selected")

	-- This applies the default them
	self:setTheme(Icon.baseTheme)

	-- Button Clicked (for states "Selected" and "Deselected")
	local clickRegion = self:getInstance("ClickRegion")
	local hasUsedMouseButton1Click = false
	local lastToggleTime = 0
	local DEBOUNCE_TIME = 0.1 -- 100ms debounce to prevent rapid toggles

	local function handleToggle()
		if self.locked then
			return
		end

		-- Debounce logic to prevent rapid toggling
		local currentTime = tick()
		if currentTime - lastToggleTime < DEBOUNCE_TIME then
			return
		end
		lastToggleTime = currentTime

		if self.isSelected then
			self:deselect("User", self)
		else
			self:select("User", self)
		end
	end

	clickRegion.MouseButton1Click:Connect(function()
		hasUsedMouseButton1Click = true
		handleToggle()
	end)

	clickRegion.TouchTap:Connect(function()
		-- This resolves the bug report by @28Pixels:
		-- https://devforum.roblox.com/t/topbarplus/1017485/1104
		-- Only use TouchTap if MouseButton1Click has never fired
		-- This handles edge cases where ONLY TouchTap works
		-- Also prevents double-toggle bug with multi-touch on mobile
		-- Credit to @sayer80 for this fix
		if not hasUsedMouseButton1Click then
			handleToggle()
		end
	end)

	-- Keys can be bound to toggle between Selected and Deselected
	janitor:add(UserInputService.InputBegan:Connect(function(input, touchingAnObject)
		if self.locked then
			return
		end
		if self.bindedToggleKeys[input.KeyCode] and not touchingAnObject then
			handleToggle()
		end
	end))

	-- Button Hovering (for state "Viewing")
	-- Hovering is a state only for devices with keyboards
	-- and controllers (not touchpads)
	local function viewingStarted(dontSetState)
		if self.locked then
			return
		end
		self.isViewing = true
		self.viewingStarted:Fire(true)
		if not dontSetState then
			self:setState("Viewing", "User", self)
		end
	end
	local function viewingEnded()
		if self.locked then
			return
		end
		self.isViewing = false
		self.viewingEnded:Fire(true)
		self:setState(nil, "User", self)
	end
	self.joinedParent:Connect(function()
		if self.isViewing then
			viewingEnded()
		end
	end)
	clickRegion.MouseEnter:Connect(function()
		local dontSetState = UserInputService.PreferredInput ~= preferredInput.desktop
		viewingStarted(dontSetState)
	end)
	local touchCount = 0
	janitor:add(UserInputService.TouchEnded:Connect(viewingEnded))
	clickRegion.MouseLeave:Connect(viewingEnded)
	clickRegion.SelectionGained:Connect(viewingStarted)
	clickRegion.SelectionLost:Connect(viewingEnded)
	clickRegion.MouseButton1Down:Connect(function()
		if not self.locked and UserInputService.PreferredInput == preferredInput.mobile then
			touchCount += 1
			local myTouchCount = touchCount
			task.delay(0.2, function()
				if myTouchCount == touchCount then
					viewingStarted()
				end
			end)
		end
	end)
	clickRegion.MouseButton1Up:Connect(function()
		touchCount += 1
	end)

	-- Handle overlay on viewing
	local iconOverlay = self:getInstance("IconOverlay")
	self.viewingStarted:Connect(function()
		iconOverlay.Visible = not self.overlayDisabled
	end)
	self.viewingEnded:Connect(function()
		iconOverlay.Visible = false
	end)

	-- Deselect when another icon is selected
	janitor:add(anyIconSelected:Connect(function(incomingIcon)
		if incomingIcon ~= self and self.deselectWhenOtherIconSelected and incomingIcon.deselectWhenOtherIconSelected then
			self:deselect("AutoDeselect", incomingIcon)
		end
	end))

	-- This checks if the script calling this module is a descendant of a ScreenGui
	-- with 'ResetOnSpawn' set to true. If it is, then we destroy the icon the
	-- client respawns. This solves one of the most asked about questions on the post
	-- The only caveat this may not work if the player doesn't uniquely name their ScreenGui and the frames
	-- the LocalScript rests within
	local source =  debug.info(2, "s")
	local sourcePath = string.split(source, ".")
	local origin = game
	local originsScreenGui
	for i, sourceName in pairs(sourcePath) do
		origin = origin:FindFirstChild(sourceName)
		if not origin then
			break
		end
		if origin:IsA("ScreenGui") then
			originsScreenGui = origin
		end
	end
	if origin and originsScreenGui and originsScreenGui.ResetOnSpawn == true then
		self.originsScreenGui = originsScreenGui
		Utility.localPlayerRespawned(function()
			self:destroy()
		end)
	end

	-- Additional children behaviour when toggled (mostly notices)
	self.toggled:Connect(function(isSelected)
		self.noticeChanged:Fire(self.totalNotices)
		for childIconUID, _ in pairs(self.childIconsDict) do
			local childIcon = Icon.getIconByUID(childIconUID)
			childIcon.noticeChanged:Fire(childIcon.totalNotices)
			if not isSelected and childIcon.isSelected then
				-- If an icon within a menu or dropdown is also
				-- a dropdown or menu, then close it
				for _, _ in pairs(childIcon.childIconsDict) do
					childIcon:deselect("HideParentFeature", self)
				end
			end
		end
	end)
	
	-- This closes/reopens the chat or playerlist if the icon is a dropdown
	-- In the future I'd prefer to use the position+size of the chat
	-- to determine whether to close dropdown (instead of non-right-set)
	-- but for reasons mentioned here it's unreliable at the time of
	-- writing this: https://devforum.roblox.com/t/here/2794915
	-- I could also make this better by accounting for multiple
	-- dropdowns being open (not just this one) but this will work
	-- fine for almost every use case for now.
	self.selected:Connect(function()
		local isDropdown = #self.dropdownIcons > 0
		if isDropdown then
			if StarterGui:GetCore("ChatActive") and self.alignment ~= "Right" then
				self.chatWasPreviouslyActive = true
				StarterGui:SetCore("ChatActive", false)
			end
			if StarterGui:GetCoreGuiEnabled("PlayerList") and self.alignment ~= "Left" then
				self.playerlistWasPreviouslyActive = true
				StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
			end
		end
	end)
	self.deselected:Connect(function()
		if self.chatWasPreviouslyActive then
			self.chatWasPreviouslyActive = nil
			StarterGui:SetCore("ChatActive", true)
		end
		if self.playerlistWasPreviouslyActive then
			self.playerlistWasPreviouslyActive = nil
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
		end
	end)
	
	-- There's a rare occassion where the appearance is not
	-- fully set to deselected so this ensures the icons
	-- appearance is fully as it should be
	task.delay(0.1, function()
		if self.activeState == "Deselected" then
			self.stateChanged:Fire("Deselected")
			self:refresh()
		end
	end)
	
	-- Call icon added
	Icon.iconAdded:Fire(self)

	return self
end



-- METHODS
function Icon:setName(name)
	self.widget.Name = name
	self.name = name
	return self
end

function Icon:setState(incomingStateName, fromSource, sourceIcon)
	-- This is responsible for acknowleding a change in stage (such as from "Deselected" to "Viewing" when
	-- a users mouse enters the widget), then informing other systems of this state change to then act upon
	-- (such as the theme handler applying the theme which corresponds to that state).
	if not incomingStateName then
		incomingStateName = (self.isSelected and "Selected") or "Deselected"
	end
	local stateName = Utility.formatStateName(incomingStateName)
	local previousStateName = self.activeState
	if previousStateName == stateName then
		return
	end
	local currentIsSelected = self.isSelected
	self.activeState = stateName
	if stateName == "Deselected" then
		self.isSelected = false
		if currentIsSelected then
			self.toggled:Fire(false, fromSource, sourceIcon)
			self.deselected:Fire(fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(false, fromSource, sourceIcon)
	elseif stateName == "Selected" then
		self.isSelected = true
		if not currentIsSelected then
			self.toggled:Fire(true, fromSource, sourceIcon)
			self.selected:Fire(fromSource, sourceIcon)
			anyIconSelected:Fire(self, fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(true, fromSource, sourceIcon)
	end
	self.stateChanged:Fire(stateName, fromSource, sourceIcon)
end

function Icon:getInstance(name)
	-- This enables us to easily retrieve instances located within the icon simply by passing its name.
	-- Every important/significant instance is named uniquely therefore this is no worry of overlap.
	-- We cache the result for more performant retrieval in the future.
	local instance = self.cachedNamesToInstances[name]
	if instance then
		return instance
	end
	local function cacheInstance(childName, child)
		local currentCache = self.cachedInstances[child]
		if not currentCache then
			local collectiveName = child:GetAttribute("Collective")
			local cachedCollective = collectiveName and self.cachedCollectives[collectiveName]
			if cachedCollective then
				table.insert(cachedCollective, child)
			end
			self.cachedNamesToInstances[childName] = child
			self.cachedInstances[child] = true
			child.Destroying:Once(function()
				self.cachedNamesToInstances[childName] = nil
				self.cachedInstances[child] = nil
			end)
		end
	end
	local widget = self.widget
	cacheInstance("Widget", widget)
	if name == "Widget" then
		return widget
	end

	local returnChild
	local function scanChildren(parentInstance)
		for _, child in pairs(parentInstance:GetChildren()) do
			local widgetUID = child:GetAttribute("WidgetUID")
			if widgetUID and widgetUID ~= self.UID then
				-- This prevents instances within other icons from being recorded
				-- (for instance when other icons are added to this icons menu)
				continue
			end
			-- If the child is a fake placeholder instance (such as dropdowns, notices, etc)
			-- then its important we scan the real original instance instead of this clone
			local realChild = Themes.getRealInstance(child)
			if realChild then
				child = realChild
			end
			-- Finally scan its children
			scanChildren(child)
			if child:IsA("GuiBase") or child:IsA("UIBase") or child:IsA("ValueBase") then
				local childName = child.Name
				cacheInstance(childName, child)
				if childName == name then
					returnChild = child
				end
			end
		end
	end
	scanChildren(widget)
	return returnChild
end

function Icon:getCollective(name)
	-- A collective is an array of instances within the Widget that have been
	-- grouped together based on a given name. This just makes it easy
	-- to act on multiple instances at once which share similar behaviours.
	-- For instance, if we want to change the icons corner size, all corner instances
	-- with the attribute "Collective" and value "WidgetCorner" could be updated
	-- instantly by doing Themes.apply(icon, "WidgetCorner", newSize)
	local collective = self.cachedCollectives[name]
	if collective then
		return collective
	end
	collective = {}
	for instance, _ in pairs(self.cachedInstances) do
		if instance:GetAttribute("Collective") == name then
			table.insert(collective, instance)
		end
	end
	self.cachedCollectives[name] = collective
	return collective
end

function Icon:getInstanceOrCollective(collectiveOrInstanceName)
	-- Similar to :getInstance but also accounts for 'Collectives', such as UICorners and returns
	-- an array of instances instead of a single instance
	local instances = {}
	local instance = self:getInstance(collectiveOrInstanceName)
	if instance then
		table.insert(instances, instance)
	end
	if #instances == 0 then
		instances = self:getCollective(collectiveOrInstanceName)
	end
	return instances
end

function Icon:getStateGroup(iconState)
	local chosenState = iconState or self.activeState
	local stateGroup = self.appearance[chosenState]
	if not stateGroup then
		stateGroup = {}
		self.appearance[chosenState] = stateGroup
	end
	return stateGroup
end

function Icon:refreshAppearance(instance, specificProperty)
	Themes.refresh(self, instance, specificProperty)
	return self
end

function Icon:refresh()
	self:refreshAppearance(self.widget)
	self.updateSize:Fire()
	return self
end

function Icon:updateParent()
	local parentIcon = Icon.getIconByUID(self.parentIconUID)
	if parentIcon then
		parentIcon.updateSize:Fire()
	end
end

function Icon:setBehaviour(collectiveOrInstanceName, property, callback, refreshAppearance)
	-- You can specify your own custom callback to handle custom logic just before
	-- an instances property is changed by using :setBehaviour()
	local key = collectiveOrInstanceName.."-"..property
	self.customBehaviours[key] = callback
	if refreshAppearance then
		local instances = self:getInstanceOrCollective(collectiveOrInstanceName)
		for _, instance in pairs(instances) do
			self:refreshAppearance(instance, property)
		end
	end
end

function Icon:modifyTheme(modifications, customModificationUID)
	local modificationUID = Themes.modify(self, modifications, customModificationUID)
	return self, modificationUID
end

function Icon:modifyChildTheme(modifications, modificationUID)
	-- Same as modifyTheme except for its children (i.e. icons
	-- within its dropdown or menu)
	self.childModifications = modifications
	self.childModificationsUID = modificationUID
	for childIconUID, _ in pairs(self.childIconsDict) do
		local childIcon = Icon.getIconByUID(childIconUID)
		childIcon:modifyTheme(modifications, modificationUID)
	end
	self.childThemeModified:Fire()
	return self
end

function Icon:removeModification(modificationUID)
	Themes.remove(self, modificationUID)
	return self
end

function Icon:removeModificationWith(instanceName, property, state)
	Themes.removeWith(self, instanceName, property, state)
	return self
end

function Icon:setTheme(theme)
	Themes.set(self, theme)
	return self
end

function Icon:setEnabled(bool)
	self.isEnabled = bool
	self.enabled = self.isEnabled
	self.widget.Visible = bool
	self:updateParent()
	return self
end

function Icon:select(fromSource, sourceIcon)
	self:setState("Selected", fromSource, sourceIcon)
	return self
end

function Icon:deselect(fromSource, sourceIcon)
	self:setState("Deselected", fromSource, sourceIcon)
	return self
end

function Icon:notify(customClearSignal, noticeId)
	-- Generates a notification which appears in the top right of the icon. Useful for example for prompting
	-- users of changes/updates within your UI such as a Catalog
	-- 'customClearSignal' is a signal object (e.g. icon.deselected) or
	-- Roblox event (e.g. Instance.new("BindableEvent").Event)
	local notice = self.notice
	if not notice then
		notice = require(elements.Notice)(self, Icon)
		self.notice = notice
	end
	self.noticeStarted:Fire(customClearSignal, noticeId)
	return self
end

function Icon:clearNotices()
	self.endNotices:Fire()
	return self
end

function Icon:disableOverlay(bool)
	self.overlayDisabled = bool
	return self
end
Icon.disableStateOverlay = Icon.disableOverlay

function Icon:setImage(imageId, iconState)
	self:modifyTheme({"IconImage", "Image", imageId, iconState})
	
	-- This code ensures icon images are preloaded if they haven't been fetched yet
	task.spawn(function()
		local newIdContent = if tonumber(imageId) then `rbxassetid://{imageId}` else imageId
		local initialAssetFetchStatus = ContentProvider:GetAssetFetchStatus(newIdContent)
	
		if initialAssetFetchStatus ~= Enum.AssetFetchStatus.Success then
			pcall(ContentProvider.PreloadAsync, ContentProvider, { newIdContent })
		end
	end)
		
	return self
end

function Icon:setLabel(text, iconState)
	self:modifyTheme({"IconLabel", "Text", text, iconState})
	return self
end

function Icon:setOrder(int, iconState)
	-- We multiply by 100 to allow for custom increments inbetween
	-- (.01, .02, etc) as LayoutOrders only support integers
	local newInt = int*100
	self:modifyTheme({"IconSpot", "LayoutOrder", newInt, iconState})
	self:modifyTheme({"Widget", "LayoutOrder", newInt, iconState})
	return self
end

function Icon:setCornerRadius(udim, iconState)
	self:modifyTheme({"IconCorners", "CornerRadius", udim, iconState})
	return self
end

function Icon:align(leftCenterOrRight, isFromParentIcon)
	-- Determines the side of the screen the icon will be ordered
	local direction = tostring(leftCenterOrRight):lower()
	if direction == "mid" or direction == "centre" then
		direction = "center"
	end
	if direction ~= "left" and direction ~= "center" and direction ~= "right" then
		direction = "left"
	end
	local screenGui = (direction == "center" and Icon.container.TopbarCentered) or Icon.container.TopbarStandard
	local holders = screenGui.Holders
	local finalDirection = string.upper(string.sub(direction, 1, 1))..string.sub(direction, 2)
	if not isFromParentIcon then
		self.originalAlignment = finalDirection
	end
	local joinedFrame = self.joinedFrame
	local alignmentHolder = holders[finalDirection]
	self.screenGui = screenGui
	self.alignmentHolder = alignmentHolder
	if not self.isDestroyed then
		self.widget.Parent = joinedFrame or alignmentHolder
	end
	self.alignment = finalDirection
	self.alignmentChanged:Fire(finalDirection)
	Icon.iconChanged:Fire(self)
	return self
end
Icon.setAlignment = Icon.align

function Icon:setLeft()
	self:setAlignment("Left")
	return self
end

function Icon:setMid()
	self:setAlignment("Center")
	return self
end

function Icon:setRight()
	self:setAlignment("Right")
	return self
end

function Icon:setWidth(offsetMinimum, iconState)
	-- This sets a minimum X offset size for the widget, useful
	-- for example if you're constantly changing the label
	-- but don't want the icon to resize every time
	self:modifyTheme({"Widget", "DesiredWidth", offsetMinimum, iconState})
	return self
end

function Icon:setImageScale(number, iconState)
	self:modifyTheme({"IconImageScale", "Value", number, iconState})
	return self
end

function Icon:setImageRatio(number, iconState)
	self:modifyTheme({"IconImageRatio", "AspectRatio", number, iconState})
	return self
end

function Icon:setTextSize(number, iconState)
	self:modifyTheme({"IconLabel", "TextSize", number, iconState})
	return self
end

function Icon:setTextFont(font, fontWeight, fontStyle, iconState)
	fontWeight = fontWeight or Enum.FontWeight.Regular
	fontStyle = fontStyle or Enum.FontStyle.Normal
	local fontFace
	local fontType = typeof(font)
	if fontType == "number" then
		fontFace = Font.fromId(font, fontWeight, fontStyle)
	elseif fontType == "EnumItem" then
		fontFace = Font.fromEnum(font)
	elseif fontType == "string" then
		if not font:match("rbxasset") then
			fontFace = Font.fromName(font, fontWeight, fontStyle)
		end
	end
	if not fontFace then
		fontFace = Font.new(font, fontWeight, fontStyle)
	end
	self:modifyTheme({"IconLabel", "FontFace", fontFace, iconState})
	return self
end

function Icon:setTextColor(Color, iconState)
	if Color == nil or Color == "" or (type(Color) ~= "userdata" or typeof(Color) ~= "Color3") then
		if Color ~= nil and Color ~= "" then
			warn("setTextColor item must be a Color3 value! Changed the color to white.")
		end
		Color = Color3.fromRGB(255, 255, 255)
	end

	self:modifyTheme({"IconLabel", "TextColor3", Color, iconState})
	return self
end

function Icon:bindToggleItem(guiObjectOrLayerCollector)
	if not guiObjectOrLayerCollector:IsA("GuiObject") and not guiObjectOrLayerCollector:IsA("LayerCollector") then
		error("Toggle item must be a GuiObject or LayerCollector!")
	end
	self.toggleItems[guiObjectOrLayerCollector] = true
	self:_updateSelectionInstances()
	return self
end

function Icon:unbindToggleItem(guiObjectOrLayerCollector)
	self.toggleItems[guiObjectOrLayerCollector] = nil
	self:_updateSelectionInstances()
	return self
end

function Icon:_updateSelectionInstances()
	-- This is to assist with controller navigation and selection
	-- It converts the value true to an array
	for guiObjectOrLayerCollector, _ in pairs(self.toggleItems) do
		local buttonInstancesArray = {}
		for _, instance in pairs(guiObjectOrLayerCollector:GetDescendants()) do
			if (instance:IsA("TextButton") or instance:IsA("ImageButton")) and instance.Active then
				table.insert(buttonInstancesArray, instance)
			end
		end
		self.toggleItems[guiObjectOrLayerCollector] = buttonInstancesArray
	end
end

function Icon:_setToggleItemsVisible(bool, fromSource, sourceIcon)
	for toggleItem, _ in pairs(self.toggleItems) do
		if not sourceIcon or sourceIcon == self or sourceIcon.toggleItems[toggleItem] == nil then
			local property = "Visible"
			if toggleItem:IsA("LayerCollector") then
				property = "Enabled"
			end
			toggleItem[property] = bool
		end
	end
end

function Icon:bindEvent(iconEventName, eventFunction)
	local event = self[iconEventName]
	assert(event and typeof(event) == "table" and event.Connect, "argument[1] must be a valid topbarplus icon event name!")
	assert(typeof(eventFunction) == "function", "argument[2] must be a function!")
	self.bindedEvents[iconEventName] = event:Connect(function(...)
		eventFunction(self, ...)
	end)
	return self
end

function Icon:unbindEvent(iconEventName)
	local eventConnection = self.bindedEvents[iconEventName]
	if eventConnection then
		eventConnection:Disconnect()
		self.bindedEvents[iconEventName] = nil
	end
	return self
end

function Icon:bindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = true
	self.toggleKeyAdded:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:unbindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = nil
	return self
end

function Icon:call(callback, ...)
	local packedArgs = table.pack(...)
	task.spawn(function()
		callback(self, table.unpack(packedArgs))
	end)
	return self
end

function Icon:addToJanitor(callback, methodName, index)
	self.janitor:add(callback, methodName, index)
	return self
end

function Icon:lock()
	-- This disables all user inputs related to the icon (such as clicking buttons, pressing keys, etc)
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = false
	self.locked = true
	return self
end

function Icon:unlock()
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = true
	self.locked = false
	return self
end

function Icon:debounce(seconds)
	self:lock()
	task.wait(seconds)
	self:unlock()
	return self
end

function Icon:autoDeselect(bool)
	-- When set to true the icon will deselect itself automatically whenever
	-- another icon is selected
	if bool == nil then
		bool = true
	end
	self.deselectWhenOtherIconSelected = bool
	return self
end

function Icon:oneClick(bool)
	-- When set to true the icon will automatically deselect when selected, this creates
	-- the effect of a single click button
	local singleClickJanitor = self.singleClickJanitor
	singleClickJanitor:clean()
	if bool or bool == nil then
		singleClickJanitor:add(self.selected:Connect(function()
			self:deselect("OneClick", self)
		end))
	end
	self.oneClickEnabled = true
	return self
end

function Icon:setCaption(text)
	if text == "_hotkey_" and (self.captionText) then
		return self
	end
	local captionJanitor = self.captionJanitor
	self.captionJanitor:clean()
	if not text or text == "" then
		self.caption = nil
		self.captionText = nil
		return self
	end
	local caption = captionJanitor:add(require(elements.Caption)(self))
	caption:SetAttribute("CaptionText", text)
	self.caption = caption
	self.captionText = text
	return self
end

function Icon:setCaptionHint(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.fakeToggleKey = keyCodeEnum
	self.fakeToggleKeyChanged:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:leave()
	local joinJanitor = self.joinJanitor
	joinJanitor:clean()
	return self
end

function Icon:joinMenu(parentIcon)
	Utility.joinFeature(self, parentIcon, parentIcon.menuIcons, parentIcon:getInstance("Menu"))
	parentIcon.menuChildAdded:Fire(self)
	return self
end

function Icon:setMenu(arrayOfIcons)
	self.menuSet:Fire(arrayOfIcons)
	return self
end

function Icon:setFixedMenu(arrayOfIcons)
	self:freezeMenu(arrayOfIcons)
	self:setMenu(arrayOfIcons)
end
Icon.setFrozenMenu = Icon.setFixedMenu

function Icon:freezeMenu()
	-- A frozen menu is a menu which is permanently locked in the
	-- the selected state (with its toggle hidden)
	self:select("FrozenMenu", self)
	self:bindEvent("deselected", function(icon)
		icon:select("FrozenMenu", self)
	end)
	self:modifyTheme({"IconSpot", "Visible", false})
end

function Icon:joinDropdown(parentIcon)
	parentIcon:getDropdown()
	Utility.joinFeature(self, parentIcon, parentIcon.dropdownIcons, parentIcon:getInstance("DropdownScroller"))
	parentIcon.dropdownChildAdded:Fire(self)
	return self
end

function Icon:getDropdown()
	local dropdown = self.dropdown
	if not dropdown then
		dropdown = require(elements.Dropdown)(self)
		self.dropdown = dropdown
		self:clipOutside(dropdown)
	end
	return dropdown
end

function Icon:setDropdown(arrayOfIcons)
	self:getDropdown()
	self.dropdownSet:Fire(arrayOfIcons)
	return self
end

function Icon:clipOutside(instance)
	-- This is essential for items such as notices and dropdowns which will exceed the bounds of the widget. This is an issue
	-- because the widget must have ClipsDescendents enabled to hide items for instance when the menu is closing or opening.
	-- This creates an invisible frame which matches the size and position of the instance, then the instance is parented outside of
	-- the widget and tracks the clone to match its size and position. In order for themes, etc to work the applying system checks
	-- to see if an instance is a clone, then if it is, it applies it to the original instance instead of the clone.
	local instanceClone = Utility.clipOutside(self, instance)
	self:refreshAppearance(instance)
	return self, instanceClone
end

function Icon:setIndicator(keyCode)
	-- An indicator is a direction button prompt with an image of the given keycode. This is useful for instance
	-- with controllers to show the user what button to press to highlight the topbar. You don't need
	-- to set an indicator for controllers as this is handled internally within the Gamepad module
	local indicator = self.indicator
	if not indicator then
		indicator = self.janitor:add(require(elements.Indicator)(self, Icon))
		self.indicator = indicator
	end
	self.indicatorSet:Fire(keyCode)
end

function Icon:convertLabelToNumberSpinner(numberSpinner, callback)
	task.defer(function()
		
		local label = self:getInstance("IconLabel")
		label.Transparency = 1
		numberSpinner.Parent = label.Parent
		numberSpinner.Size = UDim2.fromScale(1, 1)
		numberSpinner.AnchorPoint = Vector2.new(0.5, 0.5)
		numberSpinner.Position = UDim2.new(0.5, 0, 0.5, 0)
		numberSpinner.TextXAlignment = Enum.TextXAlignment.Center
		numberSpinner.ClipsDescendants = false

		local propertiesToChangeLabel = {
			"FontFace",
			"BorderSizePixel",
			"BorderColor3",
			"Rotation",
			"TextStrokeTransparency",
			"TextStrokeColor3",
			"TextStrokeTransparency",
			"TextColor3",
		}
		for _, property in ipairs(propertiesToChangeLabel) do
			numberSpinner[property] = label[property]
			self:addToJanitor(label:GetPropertyChangedSignal(property):Connect(function()
				numberSpinner[property] = label[property]
			end))
		end

		local minDigits = 0
		local maxDigits = 8
		local function getSpinnerSizeAndDigitCount()
			local TotalSize = 0
			local numOfDigits = 0
			for i, child in numberSpinner.Frame:GetChildren() do
				local name = string.lower(child.Name)
				if name == "digit" then
					TotalSize += child.AbsoluteSize.X
					numOfDigits += 1
				elseif name == "prefix" or name == "suffix" or name == "comma" then
					if child.Text ~= "" then
						TotalSize += child.AbsoluteSize.X
						numOfDigits += 1
					end
				end
			end
			return TotalSize, numOfDigits
		end
		
		local function getLabelParentContainerXSize()
			local firstParent = label.Parent
			local nextParent = firstParent and firstParent.Parent
			if nextParent == nil then
				return 0
			end
			if nextParent.IconImage.Visible == true then
				return numberSpinner.Frame.AbsoluteSize.X + label.Parent.Parent.IconImage.AbsoluteSize.X
			else
				return nextParent.AbsoluteSize.X
			end
		end
		local function getNumberSpinnerXSize()
			return numberSpinner.Frame.AbsoluteSize.X
		end

		local function adjustSize()
			local totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			if numOfDigits < 18 then
				self:setLabel(numberSpinner.Value)
			end

			local NumberSpinnerXSize = getNumberSpinnerXSize()

			while totalDigitXSize < NumberSpinnerXSize and self.isDestroyed ~= true do
				task.wait(0.05)
				if numOfDigits > minDigits and numOfDigits < maxDigits then
					numberSpinner.TextSize = label.TextSize
					break
				else
					numberSpinner.TextSize += 1
				end

				NumberSpinnerXSize = getNumberSpinnerXSize()
				totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			end

			local labelParentContainerXSize = getLabelParentContainerXSize()
			while totalDigitXSize > labelParentContainerXSize and self.isDestroyed ~= true do
				task.wait(0.05)
				if numOfDigits < maxDigits and numOfDigits > minDigits then
					numberSpinner.TextSize = label.TextSize
					break
				else
					numberSpinner.TextSize -= 1
				end

				labelParentContainerXSize = getLabelParentContainerXSize()
				totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			end
		end

		self:addToJanitor(numberSpinner.Frame.ChildAdded:Connect(adjustSize))
		self:addToJanitor(numberSpinner.Frame.ChildRemoved:Connect(adjustSize))
		self:addToJanitor(self.iconAdded:Connect(function()
			task.wait(1)
			adjustSize()
		end))

		self:updateParent()

		-- This corrects text to the size of a normal label
		numberSpinner.Name = "LabelSpinner"
		numberSpinner.Prefix = "$"
		numberSpinner.Commas = true
		numberSpinner.Decimals = 0
		numberSpinner.Duration = 0.25
		numberSpinner.Value = 10
		task.wait(0.2)
		
		if typeof(callback) == "function" then
			callback()
		end
		
	end)
	return self
end



-- DESTROY/CLEANUP
function Icon:destroy()
	if self.isDestroyed then
		return
	end
	self:clearNotices()
	if self.parentIconUID then
		self:leave()
	end
	self.isDestroyed = true
	self.janitor:clean()
	Icon.iconRemoved:Fire(self)
end
Icon.Destroy = Icon.destroy

return Icon :: Types.StaticIcon]]></ProtectedString>
						<string name="ScriptGuid">{EB73902A-5FCE-4DBC-A299-D8539FB6D4A2}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TopbarPlus.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX963FB7AF5B8D4F359EED689FF6931ACD">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TopbarPlus</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX8E1811ECAEDF467DA93DE0CE90E4E516">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict

-- GoodSignal Types (...but simpler!)

--- Connection

type Connection<Variant... = ...any> = {
	Disconnect: (self: Connection<Variant...>) -> (),
}

--- Signal

type Signal<Variant... = ...any> = {
	Connect: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
    Once: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
	Wait: (self: Signal<Variant...>) -> Variant...,
}

----------------------

export type IconState = "Deselected" | "Selected" | "Viewing"
export type Events = "selected" | "deselected" | "toggled" | "viewingStarted" | "viewingEnded" | "notified"
export type Alignment = "Left" | "Center" | "Right"
export type EventSource = "User" | "OneClick" | "AutoDeselect" | "HideParentFeature" | "Overflow"
export type Modification = { any }


type StaticFunctions = {
	getIcons: typeof(
		--[[
			Returns a dictionary of icons where the key is the icon's UID and value the icon.
		]]
		function(): { Icon }
			return (nil :: any) :: { Icon }
		end
	),
	getIcon: typeof(
		--[[
			Returns an icon of the given name or UID.
		]]
		function(nameOrUID: string): Icon?
			return nil :: any
		end
	),
	setTopbarEnabled: typeof(
		--[[
			When set to <code>false</code> all TopbarPlus ScreenGuis are hidden.
			This does not impact Roblox's Topbar.
		]]
		function(enabled: boolean)

		end
	),
	modifyBaseTheme: typeof(
		--[[
			Updates the appearance of all icons.
		]]
		function(modifications: { Modification })

		end
	),
	setDisplayOrder: typeof(
		--[[
			Sets the base DisplayOrder of all TopbarPlus ScreenGuis.
		]]
		function(order: number)

		end
	),
}

type Methods = {
	
	-- CLASS FUNCTIONS
	setName: typeof(
		--[[
			Sets the name of the Widget instance. This can be used in conjunction with <code>Icon.getIcon(name)</code>
		]]
		function(self: Icon, name: string): Icon
			return nil :: any
		end
	),
	getInstance: typeof(
		--[[
			Returns the first descendant found within the widget of name <code>instanceName</code>.
		]]
		function(self: Icon, instanceName: string): Instance?
			return (nil :: any) :: Instance?
		end
	),
	modifyTheme: typeof(
		--[[
			Updates the appearance of the icon.
		]]
		function(self: Icon, modifications: {Modification} | Modification): Icon
			return nil :: any
		end
	),
	modifyChildTheme: typeof(
		--[[
			Updates the appearance of all icons that are parented to this icon (for example when a menu or dropdown).
		]]
		function(self: Icon, modifications: { Modification }): Icon
			return nil :: any
		end
	),
	setEnabled: typeof(
		--[[
			When set to <code>false</code> the icon will be disabled and hidden.
		]]
		function(self: Icon, enabled: boolean): Icon
			return nil :: any
		end
	),
	select: typeof(
		--[[
			Selects the icon (as if it were clicked once).
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	deselect: typeof(
		--[[
			Deselects the icon (as if it were clicked, then clicked again).
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	notify: typeof(
		--[[
			Prompts a notice bubble which accumulates the further it is prompted.
			If the icon belongs to a dropdown or menu, then the notice will appear on the parent icon when the parent icon is deselected.
		]]
		function(self: Icon, clearNoticeEvent: Signal?): Icon
			return nil :: any
		end
	),
	clearNotices: typeof(
		--[[
			
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	disableOverlay: typeof(
		--[[
			When set to <code>true</code>, disables the shade effect which appears when the icon is pressed and released.
		]]
		function(self: Icon, disabled: boolean): Icon
			return nil :: any
		end
	),
	setImage: typeof(
		--[[
			Applies an image to the icon based on the given <code>imageId</code>. <code>imageId</code> can be an assetId or a complete asset string.
		]]
		function(self: Icon, imageId: string | number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setLabel: typeof(
		--[[
			
		]]
		function(self: Icon, text: string, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setOrder: typeof(
		--[[
			
		]]
		function(self: Icon, order: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setCornerRadius: typeof(
		--[[
			
		]]
		function(self: Icon, udim: UDim2, iconState: IconState?): Icon
			return nil :: any
		end
	),
	align: typeof(
		--[[
			This enables you to set the icon to the <code>"Left"</code> (default), <code>"Center"</code> or <code>"Right"</code> side of the screen.
		]]
		function(self: Icon, alignment: Alignment?): Icon
			return nil :: any
		end
	),
	setWidth: typeof(
		--[[
			This sets the minimum width the icon can be (it can be larger for instance when setting a long label). The default width is <code>44</code>.
		]]
		function(self: Icon, minimumSize: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setImageScale: typeof(
		--[[
			How large the image is relative to the icon. The default value is <code>0.5</code>.
		]]
		function(self: Icon, scale: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setImageRatio: typeof(
		--[[
			How stretched the image will appear. The default value is <code>1</code> (a perfect square).
		]]
		function(self: Icon, ratio: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextSize: typeof(
		--[[
			The size of the icon labels' text. The default value is <code>16</code>.
		]]
		function(self: Icon, textSize: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextColor: typeof(
		--[[
			The color of the icon labels' text
		]]
		function(self: Icon, color: Color3, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextFont: typeof(
		--[[
			Sets the labels FontFace.
			<code>font</code> can be a font family name (such as <code>"Creepster"</code>),
			a font enum (such as <code>Enum.Font.Bangers</code>),
			a font ID (such as <code>12187370928</code>),
			or font family link (such as <code>"rbxasset://fonts/families/Sarpanch.json"</code>).
		]]
		function(self: Icon, font: string | Enum.Font, fontWeight: Enum.FontWeight?, fontStyle: Enum.FontSize?, iconState: IconState?): Icon
			return nil :: any
		end
	),
	bindToggleItem: typeof(
		--[[
			Binds a GuiObject or LayerCollector to appear and disappeared when the icon is toggled.
		]]
		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
			return nil :: any
		end
	),
	unbindToggleItem: typeof(
		--[[
			Unbinds the given GuiObject or LayerCollector from the toggle.
		]]
		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
			return nil :: any
		end
	),
	bindEvent: typeof(
		--[[
			Connects to an icon event with <code>iconEventName</code>.
			It's important to remember all event names are in <code>camelCase</code>.
			<code>callback</code> is called with arguments <code>(self, ...)</code> when the event is triggered.
		]]
		function(self: Icon, event: Events, callback: (...any) -> ()): Icon
			return nil :: any
		end
	),
	unbindEvent: typeof(
		--[[
			Unbinds the connection of the associated <code>iconEventName</code>.
		]]
		function(self: Icon, event: Events): Icon
			return nil :: any
		end
	),
	bindToggleKey: typeof(
		--[[
			Binds a keycode which toggles the icon when pressed.
		]]
		function(self: Icon, keycode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	unbindToggleKey: typeof(
		--[[
			Unbinds the given keycode.
		]]
		function(self: Icon, keycode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	call: typeof(
		--[[
			Calls the function immediately via <code>task.spawn</code>.
			The first argument passed is the icon itself.
			This is useful when needing to extend the behaviour of an icon while remaining in the chain.
		]]
		function(self: Icon, func: (self: Icon) -> (...any), ...: any): Icon
			return nil :: any
		end
	),
	addToJanitor: typeof(
		--[[
			Passes the given userdata to the icons janitor to be destroyed/disconnected on the icons destruction.
			If a function is passed, it will be called when the icon is destroyed.
		]]
		function(self: Icon, userdata: unknown): Icon
			return nil :: any
		end
	),
	lock: typeof(
		--[[
			Prevents the icon being toggled by user-input (such as clicking), however, the icon can still be toggled via localscript using methods such as <code>icon:select()</code>.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	unlock: typeof(
		--[[
			Re-enables user-input to toggle the icon again.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	debounce: typeof(
		--[[
			Locks the icon, yields for the given time, then unlocks the icon, effectively shorthand for <code>icon:lock() task.wait(seconds) icon:unlock()</code>.
			This is useful for applying cooldowns (to prevent an icon from being pressed again) after an icon has been selected or deselected.
		]]
		function(self: Icon, seconds: number): Icon
			return nil :: any
		end
	),
	autoDeselect: typeof(
		--[[
			When set to <code>true</code> (the default) the icon is deselected when another icon (with autoDeselect enabled) is pressed.
			Set to <code>false</code> to prevent the icon being deselected when another icon is selected (a useful behaviour in dropdowns).
		]]
		function(self: Icon, enabled: boolean?): Icon
			return nil :: any
		end
	),
	oneClick: typeof(
		--[[
			When set to true the icon will automatically deselect when selected.
			This creates the effect of a single click button.
		]]
		function(self: Icon, enabled: boolean?): Icon
			return nil :: any
		end
	),
	setCaption: typeof(
		--[[
			Sets a caption. To remove, pass <code>nil</code> as <code>text</code>.
		]]
		function(self: Icon, text: string?): Icon
			return nil :: any
		end
	),
	setCaptionHint: typeof(
		--[[
			This customizes the appearance of the caption's hint without having to use <code>icon:bindToggleKey</code>.
		]]
		function(self: Icon, keyCode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	setDropdown: typeof(
		--[[
			Creates a vertical dropdown based upon the given table array of icons.
			Pass an empty table <code>{}</code> to remove the dropdown.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	joinDropdown: typeof(
		--[[
			Joins the dropdown of <code>parentIcon</code>.
			This is what <code>icon:setDropdown</code> calls internally on the icons within its array.
		]]
		function(self: Icon, parent: Icon): Icon
			return nil :: any
		end
	),
	setMenu: typeof(
		--[[
			Creates a horizontal menu based upon the given array of icons.
			Pass an empty table <code>{}</code> to remove the menu.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	setFixedMenu: typeof(
		--[[
			Creates a menu that is always selected and has it's close button hidden.
			Pass an empty table <code>{}</code> to remove the menu.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	joinMenu: typeof(
		--[[
			Joins the menu of <code>parentIcon</code>.
			This is what <code>icon:setMenu</code> calls internally on the icons within its array.
		]]
		function(self: Icon, parentIcon: Icon): Icon
			return nil :: any
		end
	),
	leave: typeof(
		--[[
			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	convertLabelToNumberSpinner: typeof(
		--[[
			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
		]]
		function(self: Icon, numberSpinner: any, func: (...any) -> (...any), ...: any): Icon
			return nil :: any
		end
	),
	destroy: typeof(
		--[[
			Clears all connections and destroys all instances associated with the icon.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
} & StaticFunctions

type Fields = {
	-- CLASS PROPERTIES
	name: string,
	isSelected: boolean,
	isEnabled: boolean,
	totalNotices: number,
	locked: boolean,

	-- CLASS EVENTS
	selected: Signal<EventSource>,
	deselected: Signal<EventSource>,
	toggled: Signal<boolean, EventSource>,
	viewingStarted: Signal,
	viewingEnded: Signal,
	notified: Signal,
}

export type Icon = Methods & StaticFunctions --typeof(setmetatable({} :: Fields, MT))

export type StaticIcon = {
	new: typeof(
		--[[
			Constructs an empty <code>32x32</code> icon on the topbar.
		]]
		function(): Icon
			return (nil :: any) :: Icon
		end
	),
} & StaticFunctions

return {}]]></ProtectedString>
							<string name="ScriptGuid">{A285FE17-855F-4B9E-BFDA-EF910628F313}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Types.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX498C636F046E46D9BEAB9A63465B2BB4">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--!strict
-- LOCAL
local VERSION = {}



-- SHARED
VERSION.appVersion = "v3.4.0"
VERSION.latestVersion = nil :: string?



-- FUNCTIONS
function VERSION.getLatestVersion(): string?
	local DEVELOPMENT_PLACE_ID = 117501901079852
	local latestVersion = VERSION.latestVersion
	if latestVersion then
		return latestVersion
	end
	local placeName = ""
	while true do
		local success, hdDevelopmentDetails = pcall(function()
			return game:GetService("MarketplaceService"):GetProductInfo(DEVELOPMENT_PLACE_ID)
		end)
		if success and hdDevelopmentDetails then
			placeName = hdDevelopmentDetails.Name
			break
		end
		task.wait(1)
	end
	latestVersion = string.match(placeName, "^TopbarPlus (.*)$")
	if latestVersion then
		latestVersion = latestVersion:gsub("%s+", "") -- Remove all whitespace (spaces, tabs, newlines)
	end
	VERSION.latestVersion = latestVersion
	return latestVersion
end

function VERSION.getAppVersion()
	return VERSION.appVersion
end

function VERSION.isUpToDate()
	local latestVersion = VERSION.getLatestVersion()
	local appVersion = VERSION.getAppVersion()
	return latestVersion ~= nil and latestVersion == appVersion
end



return VERSION]]></ProtectedString>
							<string name="ScriptGuid">{0EB677EB-363E-4DC0-AEE5-B33B440155A3}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">VERSION.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD0D386573AD8400499CFEC7A9F031B46">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- This module enables you to place Icon wherever you like within the data model while
-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
-- This is necessary to prevent two TopbarPlus applications initiating at runtime which would
-- cause icons to overlap with each other

local replicatedStorage = game:GetService("ReplicatedStorage")
local Reference = {}
Reference.objectName = "TopbarPlusReference"

function Reference.addToReplicatedStorage()
	local existingItem = replicatedStorage:FindFirstChild(Reference.objectName)
    if existingItem then
        return false
    end
    local objectValue = Instance.new("ObjectValue")
	objectValue.Name = Reference.objectName
    objectValue.Value = script.Parent
    objectValue.Parent = replicatedStorage
    return objectValue
end

function Reference.getObject()
	local objectValue = replicatedStorage:FindFirstChild(Reference.objectName)
    if objectValue then
        return objectValue
    end
    return false
end

return Reference]]></ProtectedString>
							<string name="ScriptGuid">{458CED67-15EC-4D87-93DA-8B4C913731C9}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Reference.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXADC311DCAEEF456093923ADEA3746459">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--[[

	TopbarPlus was developed by ForeverHD and is possible thanks to HD Admin.

	By using TopbarPlus in your experience or application, you agree to either:
		1. Keep Attribute unchanged, or
		2. If an experience, to credit TopbarPlus in your description, or in a
		   devforum post linked from your experience's description.

	v3 has involved over 350 hours of work to develop, so please consider supporting
	its development by reporting any issues or feedback you have at its repository:
	https://github.com/1ForeverHD/TopbarPlus

	You can get in touch with me on Discord via the social link here:
	https://create.roblox.com/store/asset/92368439343389/TopbarPlus

	Many thanks! ~Ben, June 10th 2025
	
]]

task.defer(function()
	local RunService = game:GetService("RunService")
	local VERSION = require(script.Parent.VERSION)
	local appVersion = VERSION.getAppVersion()
	local latestVersion = VERSION.getLatestVersion()
	local isOutdated = not VERSION.isUpToDate()
	if not RunService:IsStudio() then
		print(`🍍 Running TopbarPlus {appVersion} by @ForeverHD & HD Admin`)
	end
	if isOutdated then
		warn(`A new version of TopbarPlus ({latestVersion}) is available: https://devforum.roblox.com/t/topbarplus/1017485`)
	end
end)

return {}]]></ProtectedString>
							<string name="ScriptGuid">{74138A72-23E8-488A-8368-BA1988540F71}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Attribute.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX88D56A9725424870B0B7B663F3CBF857">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Just generic utility functions which I use and repeat across all my projects



-- LOCAL
local Utility = {}
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer



-- FUNCTIONS
function Utility.createStagger(delayTime, callback, delayInitially)
	-- This creates and returns a function which when called
	-- acts identically to callback, however will only be called
	-- for a maximum of once per delayTime. If the returned function
	-- is called more than once during the delayTime, then it will
	-- wait until the expiryTime then perform another recall.
	-- This is useful for visual interfaces and effects which may be
	-- triggered multiple times within a frame or short period, but which
	-- we don't necessary need to (for performance reasons).
	local staggerActive = false
	local multipleCalls = false
	if not delayTime or delayTime == 0 then
		-- We make 0.01 instead of 0 because devices can now run at
		-- different frame rates
		delayTime = 0.01
	end
	local function staggeredCallback(...)
		if staggerActive then
			multipleCalls = true
			return
		end
		local packedArgs = table.pack(...)
		staggerActive = true
		multipleCalls = false
		task.spawn(function()
			if delayInitially then
				task.wait(delayTime)
			end
			callback(table.unpack(packedArgs))
		end)
		task.delay(delayTime, function()
			staggerActive = false
			if multipleCalls then
				-- This means it has been called at least once during
				-- the stagger period, so call again
				staggeredCallback(table.unpack(packedArgs))
			end
		end)
	end
	return staggeredCallback
end

function Utility.round(n)
	-- Credit to Darkmist101 for this
	return math.floor(n + 0.5)
end

function Utility.reverseTable(t)
	for i = 1, math.floor(#t/2) do
		local j = #t - i + 1
		t[i], t[j] = t[j], t[i]
	end
end

function Utility.copyTable(t)
	-- Credit to Stephen Leitnick (September 13, 2017) for this function from TableUtil
	assert(type(t) == "table", "First argument must be a table")
	local tCopy = table.create(#t)
	for k,v in pairs(t) do
		if (type(v) == "table") then
			tCopy[k] = Utility.copyTable(v)
		else
			tCopy[k] = v
		end
	end
	return tCopy
end

local validCharacters = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9","0","<",">","?","@","{","}","[","]","!","(",")","=","+","~","#"}
function Utility.generateUID(length)
	length = length or 8
	local UID = ""
	local list = validCharacters
	local total = #list
	for i = 1, length do
		local randomCharacter = list[math.random(1, total)]
		UID = UID..randomCharacter
	end
	return UID
end

local instanceTrackers = {}
function Utility.setVisible(instance, bool, sourceUID)
	-- This effectively works like a buff object but
	-- incredibly simplified. It stacks false values
	-- so that if there is more than more than, the 
	-- instance remains hidden even if set visible true
	local tracker = instanceTrackers[instance]
	if not tracker then
		tracker = {}
		instanceTrackers[instance] = tracker
		instance.Destroying:Once(function()
			instanceTrackers[instance] = nil
		end)
	end
	if not bool then
		tracker[sourceUID] = true
	else
		tracker[sourceUID] = nil
	end
	local isVisible = bool
	if bool then
		for sourceUID, _ in pairs(tracker) do
			isVisible = false
			break
		end
	end
	instance.Visible = isVisible
end

function Utility.formatStateName(incomingStateName)
	return string.upper(string.sub(incomingStateName, 1, 1))..string.lower(string.sub(incomingStateName, 2))
end

function Utility.localPlayerRespawned(callback)
	-- The client localscript may be located under a ScreenGui with ResetOnSpawn set to true
	-- In these scenarios, traditional methods like CharacterAdded won't be called by the
	-- time the localscript has been destroyed, therefore we listen for removing instead
	-- If humanoid and health == 0, then reset/died normally, else was
	-- forcefully reset via a method such as LoadCharacter
	-- We wrap this behaviour in case any additional quirks need to be accounted for
	localPlayer.CharacterRemoving:Connect(callback)
end

function Utility.getClippedContainer(screenGui)
	-- We always want clipped items to display in front hence
	-- why we have this
	local clippedContainer = screenGui:FindFirstChild("ClippedContainer")
	if not clippedContainer then
		clippedContainer = Instance.new("Folder")
		clippedContainer.Name = "ClippedContainer"
		clippedContainer.Parent = screenGui
	end
	return clippedContainer
end

local Janitor = require(script.Parent.Packages.Janitor)
local GuiService = game:GetService("GuiService")
function Utility.clipOutside(icon, instance)
	local cloneJanitor = icon.janitor:add(Janitor.new())
	instance.Destroying:Once(function()
		cloneJanitor:Destroy()
	end)
	icon.janitor:add(instance)

	local originalParent = instance.Parent
	local clone = cloneJanitor:add(Instance.new("Frame"))
	clone:SetAttribute("IsAClippedClone", true)
	clone.Name = instance.Name
	clone.AnchorPoint = instance.AnchorPoint
	clone.Size = instance.Size
	clone.Position = instance.Position
	clone.BackgroundTransparency = 1
	clone.LayoutOrder = instance.LayoutOrder
	clone.Parent = originalParent

	local valueInstance = Instance.new("ObjectValue")
	valueInstance.Name = "OriginalInstance"
	valueInstance.Value = instance
	valueInstance.Parent = clone

	local valueInstanceCopy = valueInstance:Clone()
	instance:SetAttribute("HasAClippedClone", true)
	valueInstanceCopy.Name = "ClippedClone"
	valueInstanceCopy.Value = clone
	valueInstanceCopy.Parent = instance

	local screenGui
	local Icon = require(icon.iconModule)
	local container = Icon.container
	local function updateScreenGui()
		local originalScreenGui = originalParent:FindFirstAncestorWhichIsA("ScreenGui")
		screenGui = if string.match(originalScreenGui.Name, "Clipped") then originalScreenGui else container[originalScreenGui.Name.."Clipped"]
		instance.AnchorPoint = Vector2.new(0, 0)
		instance.Parent = Utility.getClippedContainer(screenGui)
	end
	cloneJanitor:add(icon.alignmentChanged:Connect(updateScreenGui))
	updateScreenGui()

	-- Lets copy over children that modify size
	for _, child in pairs(instance:GetChildren()) do
		if child:IsA("UIAspectRatioConstraint") then
			child:Clone().Parent = clone
		end
	end

	-- If the icon is hidden, its important we are too (as
	-- setting a parent to visible = false no longer makes
	-- this hidden)
	local widget = icon.widget
	local isOutsideParent = false
	local ignoreVisibilityUpdater = instance:GetAttribute("IgnoreVisibilityUpdater")
	local function updateVisibility()
		if ignoreVisibilityUpdater then
			return
		end
		local isVisible = widget.Visible
		if isOutsideParent then
			isVisible = false
		end
		Utility.setVisible(instance, isVisible, "ClipHandler")
	end
	cloneJanitor:add(widget:GetPropertyChangedSignal("Visible"):Connect(updateVisibility))

	local previousScroller
	local function checkIfOutsideParentXBounds()
		-- Defer so that roblox's properties reflect their true values
		task.defer(function()
			-- If the instance is within a parent item (such as a dropdown or menu)
			-- then we hide it if it exceeds the bounds of that parent
			local parentInstance
			local ourUID = icon.UID
			local nextIconUID = ourUID
			local shouldClipToParent = instance:GetAttribute("ClipToJoinedParent")
			if shouldClipToParent then
				for i = 1, 10 do -- This is safer than while true do and should never be > 4 parents
					local nextIcon = Icon.getIconByUID(nextIconUID)
					if not nextIcon then
						break
					end
					local nextParentInstance = nextIcon.joinedFrame
					nextIconUID = nextIcon.parentIconUID
					if not nextParentInstance then
						break
					end
					parentInstance = nextParentInstance
					if parentInstance and parentInstance.Name == "DropdownScroller" then
						break
					end
				end
			end
			if not parentInstance then
				isOutsideParent = false
				updateVisibility()
				return
			end
			local pos = instance.AbsolutePosition
			local halfSize = instance.AbsoluteSize/2
			local parentPos = parentInstance.AbsolutePosition
			local parentSize = parentInstance.AbsoluteSize
			local posHalf = (pos + halfSize)
			local exceededLeft = posHalf.X < parentPos.X
			local exceededRight = posHalf.X > (parentPos.X + parentSize.X)
			local exceededTop = posHalf.Y < parentPos.Y
			local exceededBottom = posHalf.Y > (parentPos.Y + parentSize.Y)
			local hasExceeded = exceededLeft or exceededRight or exceededTop or exceededBottom
			if hasExceeded ~= isOutsideParent then
				isOutsideParent = hasExceeded
				updateVisibility()
			end
			if parentInstance:IsA("ScrollingFrame") and previousScroller ~= parentInstance then
				previousScroller = parentInstance
				local connection = parentInstance:GetPropertyChangedSignal("AbsoluteWindowSize"):Connect(function()
					checkIfOutsideParentXBounds()
				end)
				cloneJanitor:add(connection, "Disconnect", "TrackUtilityScroller-"..ourUID)
			end
		end)
	end

	local camera = workspace.CurrentCamera
	local additionalOffsetX = instance:GetAttribute("AdditionalOffsetX") or 0
	local function trackProperty(property)
		local absoluteProperty = "Absolute"..property
		local function updateProperty()
			local cloneValue = clone[absoluteProperty]
			local absoluteValue = UDim2.fromOffset(cloneValue.X, cloneValue.Y)
			if property == "Position" then

				-- This binds the instances within the bounds of the screen
				local SIDE_PADDING = 4
				local limitX = camera.ViewportSize.X - instance.AbsoluteSize.X - SIDE_PADDING
				local inputX = absoluteValue.X.Offset
				if inputX < SIDE_PADDING then
					inputX = SIDE_PADDING
				elseif inputX > limitX then
					inputX = limitX
				end
				absoluteValue = UDim2.fromOffset(inputX, absoluteValue.Y.Offset)

				-- AbsolutePosition does not perfectly match with TopbarInsets enabled
				-- This corrects this
				local topbarInset = GuiService.TopbarInset
				local viewportWidth = workspace.CurrentCamera.ViewportSize.X
				local guiWidth = screenGui.AbsoluteSize.X
				local guiOffset = screenGui.AbsolutePosition.X
				--local widthDifference = guiOffset - topbarInset.Min.X
				local oldTopbarCenterOffset = 0--widthDifference/30
				local offsetX = if Icon.isOldTopbar then guiOffset else viewportWidth - guiWidth - oldTopbarCenterOffset
				
				-- Also add additionalOffset
				offsetX -= additionalOffsetX
				absoluteValue += UDim2.fromOffset(-offsetX, topbarInset.Height)

				-- Finally check if within its direct parents bounds
				checkIfOutsideParentXBounds()

			end
			instance[property] = absoluteValue
		end
		
		-- This defer is essential as the listener may be in a different screenGui to the actor
		local updatePropertyStaggered = Utility.createStagger(0.01, updateProperty)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyStaggered))
		cloneJanitor:add(clone:GetAttributeChangedSignal("ForceUpdate"):Connect(function()
			updatePropertyStaggered()
		end))

		-- This is to patch a weirddddd bug with ScreenGuis with SreenInsets set to
		-- 'TopbarSafeInsets'. For some reason the absolute position of gui instances
		-- within this type of screenGui DO NOT accurately update to match their new
		-- real world position; instead they jump around almost randomly for a few frames.
		-- I have spent way too many hours trying to solve this bug, I think the only way
		-- for the time being is to not use ScreenGuis with TopbarSafeInsets, but I don't
		-- have time to redesign the entire system around that at the moment.
		-- Here's a GIF of this bug: https://i.imgur.com/VitHdC1.gif
		local updatePropertyPatch = Utility.createStagger(0.5, updateProperty, true)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyPatch))
		
		-- When the screenGui is resized (such as when chat is hidden/shown), we need
		-- to update the position of the clone. Ths especially fixes the following:
		-- https://devforum.roblox.com/t/bug/1017485/1732
		if property == "Position" then
			cloneJanitor:add(screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				updatePropertyStaggered()
			end))
		end

	end
	task.delay(0.1, checkIfOutsideParentXBounds)
	checkIfOutsideParentXBounds()
	updateVisibility()
	trackProperty("Position")
	
	-- Track visiblity changes
	cloneJanitor:add(instance:GetPropertyChangedSignal("Visible"):Connect(function()
		--print("Visiblity changed:", instance, clone, instance.Visible)
		--clone.Visible = instance.Visible
	end))

	-- To ensure accurate positioning, it's important the clone also remains the same size as the instance
	local shouldTrackCloneSize = instance:GetAttribute("TrackCloneSize")
	if shouldTrackCloneSize then
		trackProperty("Size")
	else
		cloneJanitor:add(instance:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			local absolute = instance.AbsoluteSize
			clone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end))
	end

	return clone
end

function Utility.joinFeature(originalIcon, parentIcon, iconsArray, scrollingFrameOrFrame)

	-- This is resonsible for moving the icon under a feature like a dropdown
	local joinJanitor = originalIcon.joinJanitor
	joinJanitor:clean()
	if not scrollingFrameOrFrame then
		originalIcon:leave()
		return
	end
	originalIcon.parentIconUID = parentIcon.UID
	originalIcon.joinedFrame = scrollingFrameOrFrame
	local function updateAlignent()
		local parentAlignment = parentIcon.alignment
		if parentAlignment == "Center" then
			parentAlignment = "Left"
		end
		originalIcon:setAlignment(parentAlignment, true)
	end
	joinJanitor:add(parentIcon.alignmentChanged:Connect(updateAlignent))
	updateAlignent()
	originalIcon:modifyTheme({"IconButton", "BackgroundTransparency", 1}, "JoinModification")
	originalIcon:modifyTheme({"ClickRegion", "Active", false}, "JoinModification")
	if parentIcon.childModifications then
		-- We defer so that the default values (such as dropdown
		-- minimum width can be applied before any custom
		-- child modifications from the user)
		task.defer(function()
			originalIcon:modifyTheme(parentIcon.childModifications, parentIcon.childModificationsUID)
		end)
	end
	--
	local clickRegion = originalIcon:getInstance("ClickRegion")
	local function makeSelectable()
		clickRegion.Selectable = parentIcon.isSelected
	end
	joinJanitor:add(parentIcon.toggled:Connect(makeSelectable))
	task.defer(makeSelectable)
	joinJanitor:add(function()
		clickRegion.Selectable = true
	end)
	--

	-- We track icons in arrays and dictionaries using their UID instead of the icon
	-- itself to prevent heavy cyclical tables when printing the icons
	local originalIconUID = originalIcon.UID
	table.insert(iconsArray, originalIconUID)
	parentIcon:autoDeselect(false)
	parentIcon.childIconsDict[originalIconUID] = true
	if not parentIcon.isEnabled then
		parentIcon:setEnabled(true)
	end
	originalIcon.joinedParent:Fire(parentIcon)

	-- This is responsible for removing it from that feature and updating
	-- their parent icon so its informed of the icon leaving it
	joinJanitor:add(function()
		local joinedFrame = originalIcon.joinedFrame
		if not joinedFrame then
			return
		end
		for i, iconUID in pairs(iconsArray) do
			if iconUID == originalIconUID then
				table.remove(iconsArray, i)
				break
			end
		end
		local Icon = require(originalIcon.iconModule)
		local parentIcon = Icon.getIconByUID(originalIcon.parentIconUID)
		if not parentIcon then
			return
		end
		originalIcon:setAlignment(originalIcon.originalAlignment)
		originalIcon.parentIconUID = false
		originalIcon.joinedFrame = false
		--originalIcon:setBehaviour("IconButton", "BackgroundTransparency", nil, true)
		originalIcon:removeModification("JoinModification")
		
		local parentHasNoChildren = true
		local parentChildIcons = parentIcon.childIconsDict
		parentChildIcons[originalIconUID] = nil
		for childIconUID, _ in pairs(parentChildIcons) do
			parentHasNoChildren = false
			break
		end
		if parentHasNoChildren and not parentIcon.isAnOverflow then
			parentIcon:setEnabled(false)
		end
		updateAlignent()

	end)

end



return Utility]]></ProtectedString>
							<string name="ScriptGuid">{DBCBD47F-268D-4C0C-8778-4B3FCD9E048B}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Utility.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX8683BC6A937C4B68A909707DAD695BDB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Elements</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXA327CF545F2942D9AB9DBAAD6D57BDFD">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local CAPTION_COLOR = Color3.fromRGB(39, 41, 48)
local TEXT_SIZE = 15
return function(icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local clickRegion = icon:getInstance("ClickRegion")
	local caption = Instance.new("CanvasGroup")
	caption.Name = "Caption"
	caption.AnchorPoint = Vector2.new(0.5, 0)
	caption.BackgroundTransparency = 1
	caption.BorderSizePixel = 0
	caption.GroupTransparency = 1
	caption.Position = UDim2.fromOffset(0, 0)
	caption.Visible = true
	caption.ZIndex = 30
	caption.Parent = clickRegion

	local box = Instance.new("Frame")
	box.Name = "Box"
	box.AutomaticSize = Enum.AutomaticSize.XY
	box.BackgroundColor3 = CAPTION_COLOR
	box.Position = UDim2.fromOffset(4, 7)
	box.ZIndex = 12
	box.Parent = caption

	local header = Instance.new("TextLabel")
	header.Name = "Header"
	header.FontFace = Font.new(
		"rbxasset://fonts/families/BuilderSans.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	header.Text = "Caption"
	header.TextColor3 = Color3.fromRGB(255, 255, 255)
	header.TextSize = TEXT_SIZE
	header.TextTruncate = Enum.TextTruncate.None
	header.TextWrapped = false
	header.TextXAlignment = Enum.TextXAlignment.Left
	header.AutomaticSize = Enum.AutomaticSize.X
	header.BackgroundTransparency = 1
	header.LayoutOrder = 1
	header.Size = UDim2.fromOffset(0, 16)
	header.ZIndex = 18
	header.Parent = box

	local layout = Instance.new("UIListLayout")
	layout.Name = "Layout"
	layout.Padding = UDim.new(0, 8)
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Parent = box

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "CaptionCorner"
	UICorner.Parent = box

	local padding = Instance.new("UIPadding")
	padding.Name = "Padding"
	padding.PaddingBottom = UDim.new(0, 12)
	padding.PaddingLeft = UDim.new(0, 12)
	padding.PaddingRight = UDim.new(0, 12)
	padding.PaddingTop = UDim.new(0, 12)
	padding.Parent = box

	local hotkeys = Instance.new("Frame")
	hotkeys.Name = "Hotkeys"
	hotkeys.AutomaticSize = Enum.AutomaticSize.Y
	hotkeys.BackgroundTransparency = 1
	hotkeys.LayoutOrder = 3
	hotkeys.Size = UDim2.fromScale(1, 0)
	hotkeys.Visible = false
	hotkeys.Parent = box

	local layout1 = Instance.new("UIListLayout")
	layout1.Name = "Layout1"
	layout1.Padding = UDim.new(0, 6)
	layout1.FillDirection = Enum.FillDirection.Vertical
	layout1.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout1.HorizontalFlex = Enum.UIFlexAlignment.None
	layout1.ItemLineAlignment = Enum.ItemLineAlignment.Automatic
	layout1.VerticalFlex = Enum.UIFlexAlignment.None
	layout1.SortOrder = Enum.SortOrder.LayoutOrder
	layout1.Parent = hotkeys

	local keyTag1 = Instance.new("ImageLabel")
	keyTag1.Name = "Key1"
	keyTag1.Image = "rbxasset://textures/ui/Controls/key_single.png"
	keyTag1.ImageTransparency = 0.7
	keyTag1.ScaleType = Enum.ScaleType.Slice
	keyTag1.SliceCenter = Rect.new(5, 5, 23, 24)
	keyTag1.AutomaticSize = Enum.AutomaticSize.X
	keyTag1.BackgroundTransparency = 1
	keyTag1.LayoutOrder = 1
	keyTag1.Size = UDim2.fromOffset(0, 30)
	keyTag1.ZIndex = 15
	keyTag1.Parent = hotkeys

	local inset = Instance.new("UIPadding")
	inset.Name = "Inset"
	inset.PaddingLeft = UDim.new(0, 8)
	inset.PaddingRight = UDim.new(0, 8)
	inset.Parent = keyTag1

	local labelContent = Instance.new("TextLabel")
	labelContent.AutoLocalize = false
	labelContent.Name = "LabelContent"
	labelContent.FontFace = Font.new(
		"rbxasset://fonts/families/GothamSSm.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	labelContent.Text = ""
	labelContent.TextColor3 = Color3.fromRGB(189, 190, 190)
	labelContent.TextSize = TEXT_SIZE
	labelContent.AutomaticSize = Enum.AutomaticSize.X
	labelContent.BackgroundTransparency = 1
	labelContent.Position = UDim2.fromOffset(0, -1)
	labelContent.Size = UDim2.fromScale(1, 1)
	labelContent.ZIndex = 16
	labelContent.Parent = keyTag1
	
	local caret = Instance.new("ImageLabel")
	caret.Name = "Caret"
	caret.Image = "rbxassetid://101906294438076"
	caret.ImageColor3 = CAPTION_COLOR
	caret.AnchorPoint = Vector2.new(0, 0.5)
	caret.BackgroundTransparency = 1
	caret.Position = UDim2.new(0, 0, 0, 4)
	caret.Size = UDim2.fromOffset(16, 8)
	caret.ZIndex = 12
	caret.Parent = caption

	local dropShadow = Instance.new("ImageLabel")
	dropShadow.Visible = true
	dropShadow.Name = "DropShadow"
	dropShadow.Image = "rbxassetid://124920646932671"
	dropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
	dropShadow.ImageTransparency = 0.45
	dropShadow.ScaleType = Enum.ScaleType.Slice
	dropShadow.SliceCenter = Rect.new(12, 12, 13, 13)
	dropShadow.BackgroundTransparency = 1
	dropShadow.Position = UDim2.fromOffset(0, 5)
	dropShadow.Size = UDim2.new(1, 0, 0, 48)
	dropShadow.Parent = caption
	box:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		dropShadow.Size = UDim2.new(1, 0, 0, box.AbsoluteSize.Y + 8)
	end)
	
	-- It's important we match the sizes as this is not
	-- handles within clipOutside (as it assumes the sizes
	-- are already the same)
	local captionJanitor = icon.captionJanitor
	local _, captionClone = icon:clipOutside(caption)
	captionClone.AutomaticSize = Enum.AutomaticSize.None
	local function matchSize()
		local absolute = caption.AbsoluteSize
		captionClone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
	end
	captionJanitor:add(caption:GetPropertyChangedSignal("AbsoluteSize"):Connect(matchSize))
	matchSize()
	
	
	
	-- This handles the appearing/disappearing/positioning of the caption
	local isCompletelyEnabled = false
	local captionHeader = caption.Box.Header
	local UserInputService = game:GetService("UserInputService")
	local function updateHotkey(keyCodeEnum)
		local hasKeyboard = UserInputService.KeyboardEnabled
		local text = caption:GetAttribute("CaptionText") or ""
		local hideHeader = text == "_hotkey_"
		if not hasKeyboard and hideHeader then
			icon:setCaption()
			return
		end
		captionHeader.Text = text
		captionHeader.Visible = not hideHeader
		if keyCodeEnum then
			labelContent.Text = keyCodeEnum.Name
			hotkeys.Visible = true
		end
		if not hasKeyboard then
			hotkeys.Visible = false
		end
	end
	caption:GetAttributeChangedSignal("CaptionText"):Connect(updateHotkey)

	local EASING_STYLE = Enum.EasingStyle.Quad
	local TWEEN_SPEED = 0.2
	local TWEEN_INFO_IN = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.In)
	local TWEEN_INFO_OUT = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.Out)
	local TweenService = game:GetService("TweenService")
	local RunService = game:GetService("RunService")
	local function getCaptionPosition(customEnabled)
		local enabled = if customEnabled ~= nil then customEnabled else isCompletelyEnabled
		local yOut = 2
		local yIn = yOut + 8
		local yOffset = if enabled then yIn else yOut
		return UDim2.new(0.5, 0, 1, yOffset)
	end
	local function updatePosition(forcedEnabled)
		
		-- Ignore changes if not enabled to reduce redundant calls
		if not isCompletelyEnabled then
			return
		end
		
		-- Currently the one thing which isn't accounted for are the bounds of the screen
		-- This would be an issue if someone sets a long caption text for the left or
		-- right most icon
		local enabled = if forcedEnabled ~= nil then forcedEnabled else isCompletelyEnabled
		local startPosition = getCaptionPosition(not enabled)
		local endPosition = getCaptionPosition(enabled)
		
		-- It's essential we reset the carets position to prevent the x sizing bounds
		-- of the caption from infinitely scaling up
		if enabled then
			local caretY = caret.Position.Y.Offset
			caret.Position = UDim2.fromOffset(0, caretY)
			caption.AutomaticSize = Enum.AutomaticSize.XY
			caption.Size = UDim2.fromOffset(32, 53)
		else
			local absolute = caption.AbsoluteSize
			caption.AutomaticSize = Enum.AutomaticSize.Y
			caption.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end
		
		-- We initially default to the opposite state
		local previousCaretX
		local function updateCaret()
			local caretX = clickRegion.AbsolutePosition.X - caption.AbsolutePosition.X + clickRegion.AbsoluteSize.X/2 - caret.AbsoluteSize.X/2
			local caretY = caret.Position.Y.Offset
			local newCaretPosition = UDim2.fromOffset(caretX, caretY)
			if previousCaretX ~= caretX then
				-- Again, it's essential we reset the caret if
				-- a difference in X position is detected otherwise
				-- a slight quirk with AutomaticCanvas can cause
				-- the caption to infinitely scale
				previousCaretX = caretX
				caret.Position = UDim2.fromOffset(0, caretY)
				task.wait()
			end
			caret.Position = newCaretPosition
		end
		captionClone.Position = startPosition
		updateCaret()
		
		-- Now we tween into the new state
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tween = TweenService:Create(captionClone, tweenInfo, {Position = endPosition})
		local updateCaretConnection = RunService.Heartbeat:Connect(updateCaret)
		tween:Play()
		tween.Completed:Once(function()
			updateCaretConnection:Disconnect()
		end)
		
	end
	captionJanitor:add(clickRegion:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updatePosition()
	end))
	updatePosition(false)
	
	captionJanitor:add(icon.toggleKeyAdded:Connect(updateHotkey))
	for keyCodeEnum, _ in pairs(icon.bindedToggleKeys) do
		updateHotkey(keyCodeEnum)
		break
	end
	captionJanitor:add(icon.fakeToggleKeyChanged:Connect(updateHotkey))
	local fakeToggleKey = icon.fakeToggleKey
	if fakeToggleKey then
		updateHotkey(fakeToggleKey)
	end

	local function setCaptionEnabled(enabled)
		if isCompletelyEnabled == enabled then
			return
		end
		local joinedFrame = icon.joinedFrame
		if joinedFrame and string.match(joinedFrame.Name, "Dropdown") then
			enabled = false
		end
		isCompletelyEnabled = enabled
		local newTransparency = (enabled and 0) or 1
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tweenTransparency = TweenService:Create(caption, tweenInfo, {
			GroupTransparency = newTransparency
		})
		tweenTransparency:Play()
		if enabled then
			captionClone:SetAttribute("ForceUpdate", true)
		end
		updatePosition()
		updateHotkey()
	end
	
	local WAIT_DURATION = 0.5
	local RECOVER_PERIOD = 0.3
	local Icon = require(icon.iconModule)
	captionJanitor:add(icon.stateChanged:Connect(function(stateName)
		if stateName == "Viewing" then
			local lastClock = Icon.captionLastClosedClock
			local clockDifference = (lastClock and os.clock() - lastClock) or 999
			local waitDuration = (clockDifference < RECOVER_PERIOD and 0) or WAIT_DURATION
			task.delay(waitDuration, function()
				if icon.activeState == "Viewing" then
					setCaptionEnabled(true)
				end
			end)
		else
			Icon.captionLastClosedClock = os.clock()
			setCaptionEnabled(false)
		end
	end))
	
	return caption
end]]></ProtectedString>
								<string name="ScriptGuid">{A460C1B2-2E73-42D4-9A4C-62204F961EA6}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Caption.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0D70C1F99D4D4C24893AFFABF4555307">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local hasBecomeOldTheme = false
local previousInsetHeight = 0
return function(Icon)
	
	-- Has to be included for the time being due to this bug mentioned here:
	-- https://devforum.roblox.com/t/bug/2973508/7
	local GuiService = game:GetService("GuiService")
	local Players =  game:GetService("Players")
	local UserInputService = game:GetService("UserInputService")
	local container = {}
	local Signal = require(script.Parent.Parent.Packages.GoodSignal)
	local insetChanged = Signal.new()
	local guiInset = GuiService:GetGuiInset()
	local startInset = 0
	local yDownOffset = 0
	local ySizeOffset = 0
	local checkCount = 0
	local isConsoleScreen = false
	local isUsingVR = false
	local function checkInset(status)
		local currentHeight = GuiService.TopbarInset.Height
		local isOldTopbar = currentHeight <= 36
		

		-- These additional checks are needed to ensure *it is actually* the old topbar
		-- and not a client which takes a really long time to load
		-- There's unfortunately no APIs to do this a prettier way
		isConsoleScreen = GuiService:IsTenFootInterface()
		isUsingVR = UserInputService.VREnabled
		Icon.isOldTopbar = isOldTopbar
		checkCount += 1
		if currentHeight == 0 and status == nil then
			task.defer(function()
				task.wait(8)
				checkInset("ForceConvertToOld")
			end)
		elseif checkCount == 1 then
			task.delay(5, function()
				local localPlayer = Players.LocalPlayer
				localPlayer:WaitForChild("PlayerGui")
				if checkCount == 1 then
					checkInset()
				end
			end)
		end

		-- Conver to old theme if verified
		if Icon.isOldTopbar and not isConsoleScreen and not isUsingVR and hasBecomeOldTheme == false and (currentHeight ~= 0 or status == "ForceConvertToOld") then
			hasBecomeOldTheme = true
			task.defer(function()
				-- If oldtopbar, apply the Classic theme
				local themes = script.Parent.Parent.Features.Themes
				local Classic = require(themes.Classic)
				Icon.modifyBaseTheme(Classic)

				-- Also configure the oldtopbar correctly
				local function decideToHideTopbar()
					if GuiService.MenuIsOpen then
						Icon.setTopbarEnabled(false, true)
					else
						Icon.setTopbarEnabled()
					end
				end
				GuiService:GetPropertyChangedSignal("MenuIsOpen"):Connect(decideToHideTopbar)
				decideToHideTopbar()
			end)
		end

		-- Modify the offsets slightly depending on device type
		guiInset = GuiService:GetGuiInset()
		startInset = if isOldTopbar then 12 else guiInset.Y - 50
		yDownOffset = if isOldTopbar then 2 else 0 --if isOldTopbar then 2 else 0 
		ySizeOffset = -2
		if isConsoleScreen then
			startInset = 10
			yDownOffset = 0 ---9
		end
		if GuiService.TopbarInset.Height == 0 and not hasBecomeOldTheme then
			yDownOffset += 13
			ySizeOffset = 50
		end

		-- Now inform other areas of the change
		insetChanged:Fire(guiInset)
		local insetHeight = guiInset.Y
		if insetHeight ~= previousInsetHeight then
			previousInsetHeight = insetHeight
			task.defer(function()
				Icon.insetHeightChanged:Fire(insetHeight)
			end)
		end
		
	end
	GuiService:GetPropertyChangedSignal("TopbarInset"):Connect(checkInset)
	checkInset("FirstTime")

	local screenGui = Instance.new("ScreenGui")
	insetChanged:Connect(function()
		screenGui:SetAttribute("StartInset", startInset)
	end)
	screenGui.Name = "TopbarStandard"
	screenGui.Enabled = true
	screenGui.DisplayOrder = Icon.baseDisplayOrder
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.IgnoreGuiInset = true
	screenGui.ResetOnSpawn = false
	screenGui.ScreenInsets = Enum.ScreenInsets.TopbarSafeInsets
	container[screenGui.Name] = screenGui
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGui.DisplayOrder = Icon.baseDisplayOrder
	end)

	local holders = Instance.new("Frame")
	holders.Name = "Holders"
	holders.BackgroundTransparency = 1
	insetChanged:Connect(function()
		local holderY = if isUsingVR then 36 else 56
		local holderSize = if isConsoleScreen then UDim2.new(1, 0, 0, holderY) else UDim2.new(1, 0, 1, ySizeOffset)
		holders.Position = UDim2.new(0, 0, 0, yDownOffset)
		holders.Size = holderSize
	end)
	holders.Visible = true
	holders.ZIndex = 1
	holders.Parent = screenGui
	
	local screenGuiCenter = screenGui:Clone()
	local holdersCenter = screenGuiCenter.Holders
	local function updateCenteredHoldersHeight()
		holdersCenter.Size = UDim2.new(1, 0, 0, GuiService.TopbarInset.Height+ySizeOffset)
	end
	screenGuiCenter.Name = "TopbarCentered"
	screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
	screenGuiCenter.ScreenInsets = Enum.ScreenInsets.None
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
	end)
	container[screenGuiCenter.Name] = screenGuiCenter
	
	insetChanged:Connect(updateCenteredHoldersHeight)
	updateCenteredHoldersHeight()
	
	local screenGuiClipped = screenGui:Clone()
	screenGuiClipped.Name = screenGuiClipped.Name.."Clipped"
	screenGuiClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	end)
	container[screenGuiClipped.Name] = screenGuiClipped
	
	local screenGuiCenterClipped = screenGuiCenter:Clone()
	screenGuiCenterClipped.Name = screenGuiCenterClipped.Name.."Clipped"
	screenGuiCenterClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenterClipped.DisplayOrder = (Icon.baseDisplayOrder + 1)
	end)
	container[screenGuiCenterClipped.Name] = screenGuiCenterClipped
	
	local holderReduction = -24
	local left = Instance.new("ScrollingFrame")
	left:SetAttribute("IsAHolder", true)
	left.Name = "Left"
	insetChanged:Connect(function()
		left.Position = UDim2.fromOffset(startInset, 0)
	end)
	left.Size = UDim2.new(1, holderReduction, 1, 0)
	left.BackgroundTransparency = 1
	left.Visible = true
	left.ZIndex = 1
	left.Active = false
	left.ClipsDescendants = true
	left.HorizontalScrollBarInset = Enum.ScrollBarInset.None
	left.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	left.AutomaticCanvasSize = Enum.AutomaticSize.X
	left.ScrollingDirection = Enum.ScrollingDirection.X
	left.ScrollBarThickness = 0
	left.BorderSizePixel = 0
	left.Selectable = false
	left.ScrollingEnabled = false--true
	left.ElasticBehavior = Enum.ElasticBehavior.Never
	left.Parent = holders
	
	local UIListLayout = Instance.new("UIListLayout")
	insetChanged:Connect(function()
		UIListLayout.Padding = UDim.new(0, startInset)
	end)
	UIListLayout.FillDirection = Enum.FillDirection.Horizontal
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
	UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	UIListLayout.Parent = left
	
	local center = left:Clone()
	insetChanged:Connect(function()
		center.UIListLayout.Padding = UDim.new(0, startInset)
	end)
	center.ScrollingEnabled = false
	center.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	center.Name = "Center"
	center.Parent = holdersCenter
	
	local right = left:Clone()
	insetChanged:Connect(function()
		right.UIListLayout.Padding = UDim.new(0, startInset)
	end)
	right.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
	right.Name = "Right"
	right.AnchorPoint = Vector2.new(1, 0)
	right.Position = UDim2.new(1, -12, 0, 0)
	right.Parent = holders

	-- This is important so that all elements update instantly
	insetChanged:Fire(guiInset)

	return container
end]]></ProtectedString>
								<string name="ScriptGuid">{1B2038C0-2986-48AA-88D9-23E496B1BC15}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Container.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX54CD1DB097754DF8BA709FE493BDA612">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local widget = icon.widget
	local contents = icon:getInstance("Contents")
	local indicator = Instance.new("Frame")
	indicator.Name = "Indicator"
	indicator.LayoutOrder = 9999999
	indicator.ZIndex = 6
	indicator.Size = UDim2.new(0, 42, 0, 42)
	indicator.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicator.BackgroundTransparency = 1
	indicator.Position = UDim2.new(1, 0, 0.5, 0)
	indicator.BorderSizePixel = 0
	indicator.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicator.Parent = contents

	local indicatorButton = Instance.new("Frame")
	indicatorButton.Name = "IndicatorButton"
	indicatorButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.AnchorPoint = Vector2.new(0.5, 0.5)
	indicatorButton.BorderSizePixel = 0
	indicatorButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.Parent = indicator
	
	local GuiService = game:GetService("GuiService")
	local GamepadService = game:GetService("GamepadService")
	local ourClickRegion = icon:getInstance("ClickRegion")
	local function selectionChanged()
		local selectedClickRegion = GuiService.SelectedObject
		if selectedClickRegion == ourClickRegion then
			indicatorButton.BackgroundTransparency = 1
			indicatorButton.Position = UDim2.new(0.5, -2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1.2, 1.2)
		else
			indicatorButton.BackgroundTransparency = 0.75
			indicatorButton.Position = UDim2.new(0.5, 2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1, 1)
		end
	end
	icon.janitor:add(GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(selectionChanged))
	selectionChanged()

	local imageLabel = Instance.new("ImageLabel")
	imageLabel.LayoutOrder = 2
	imageLabel.ZIndex = 15
	imageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	imageLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.BackgroundTransparency = 1
	imageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.Image = "rbxasset://textures/ui/Controls/XboxController/DPadUp@2x.png"
	imageLabel.Parent = indicatorButton

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = indicatorButton

	local UserInputService = game:GetService("UserInputService")
	local function setIndicatorVisible(visibility)
		if visibility == nil then
			visibility = indicator.Visible
		end
		if GamepadService.GamepadCursorEnabled then
			visibility = false
		end
		if visibility then
			icon:modifyTheme({"PaddingRight", "Size", UDim2.new(0, 0, 1, 0)}, "IndicatorPadding")
		elseif indicator.Visible then
			icon:removeModification("IndicatorPadding")
		end
		icon:modifyTheme({"Indicator", "Visible", visibility})
		icon.updateSize:Fire()
	end
	icon.janitor:add(GamepadService:GetPropertyChangedSignal("GamepadCursorEnabled"):Connect(setIndicatorVisible))
	icon.indicatorSet:Connect(function(keyCode)
		local visibility = false
		if keyCode then
			imageLabel.Image = UserInputService:GetImageForKeyCode(keyCode)
			visibility = true
		end
		setIndicatorVisible(visibility)
	end)

	local function updateSize()
		local ySize = widget.AbsoluteSize.Y*0.96
		indicator.Size = UDim2.new(0, ySize, 0, ySize)
	end
	widget:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateSize)
	updateSize()

	return indicator
end]]></ProtectedString>
								<string name="ScriptGuid">{E74516B7-3B4F-4E4E-822D-94C6F96EABBB}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Indicator.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2A38E33F126545B78C7C000F1AE04A70">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[return function(icon)

	local menu = Instance.new("ScrollingFrame")
	menu.Name = "Menu"
	menu.BackgroundTransparency = 1
	menu.Visible = true
	menu.ZIndex = 1
	menu.Size = UDim2.fromScale(1, 1)
	menu.ClipsDescendants = true
	menu.TopImage = ""
	menu.BottomImage = ""
	menu.HorizontalScrollBarInset = Enum.ScrollBarInset.Always
	menu.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	menu.ScrollingEnabled = true
	menu.ScrollingDirection = Enum.ScrollingDirection.X
	menu.ZIndex = 20
	menu.ScrollBarThickness = 3
	menu.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	menu.ScrollBarImageTransparency = 0.8
	menu.BorderSizePixel = 0
	menu.Selectable = false
	
	local Icon = require(icon.iconModule)
	local menuUIListLayout = Icon.container.TopbarStandard:FindFirstChild("UIListLayout", true):Clone()
	menuUIListLayout.Name = "MenuUIListLayout"
	menuUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	menuUIListLayout.Parent = menu

	local menuGap = Instance.new("Frame")
	menuGap.Name = "MenuGap"
	menuGap.BackgroundTransparency = 1
	menuGap.Visible = false
	menuGap.AnchorPoint = Vector2.new(0, 0.5)
	menuGap.ZIndex = 5
	menuGap.Parent = menu
	
	local hasStartedMenu = false
	local Themes = require(script.Parent.Parent.Features.Themes)
	local function totalChildrenChanged()
		
		local menuJanitor = icon.menuJanitor
		local totalIcons = #icon.menuIcons
		if hasStartedMenu then
			if totalIcons <= 0 then
				menuJanitor:clean()
				hasStartedMenu = false
			end
			return
		end
		hasStartedMenu = true
		
		-- Listen for changes
		menuJanitor:add(icon.toggled:Connect(function()
			if #icon.menuIcons > 0 then
				icon.updateSize:Fire()
			end
		end))
		
		-- Modify appearance of menu icon when joined
		local _, modificationUID = icon:modifyTheme({
			{"Menu", "Active", true},
		})
		task.defer(function()
			menuJanitor:add(function()
				icon:removeModification(modificationUID)
			end)
		end)
		
		-- For right-aligned icons, this ensures their menus
		-- close button appear instantly when selected (instead
		-- of partially hidden from view)
		local previousCanvasX = menu.AbsoluteCanvasSize.X
		local function rightAlignCanvas()
			if icon.alignment == "Right" then
				local newCanvasX = menu.AbsoluteCanvasSize.X
				local difference = previousCanvasX - newCanvasX
				previousCanvasX = newCanvasX
				menu.CanvasPosition = Vector2.new(menu.CanvasPosition.X - difference, 0)
			end
		end
		menuJanitor:add(icon.selected:Connect(rightAlignCanvas))
		menuJanitor:add(menu:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(rightAlignCanvas))
		
		-- Apply a close selected image if the user hasn't applied thier own
		local stateGroup = icon:getStateGroup()
		local imageDeselected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Deselected")
		local imageSelected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Selected")
		if imageDeselected == imageSelected then
			local fontLink = "rbxasset://fonts/families/FredokaOne.json"
			local fontFace = Font.new(fontLink, Enum.FontWeight.Light, Enum.FontStyle.Normal)
			icon:removeModificationWith("IconLabel", "Text", "Viewing")
			icon:removeModificationWith("IconLabel", "Image", "Viewing")
			icon:modifyTheme({
				{"IconLabel", "FontFace", fontFace, "Selected"},
				{"IconLabel", "Text", "X", "Selected"},
				{"IconLabel", "TextSize", 20, "Selected"},
				{"IconLabel", "TextStrokeTransparency", 0.8, "Selected"},
				{"IconImage", "Image", "", "Selected"},
			})
		end

		-- Change order of spot when alignment changes
		local menuGap = icon:getInstance("MenuGap")
		local function updateAlignent()
			local alignment = icon.alignment
			local spotIndex = -99999
			local gapIndex = -99998
			if alignment == "Right" then
				spotIndex = 99999
				gapIndex = 99998
			end
			icon:modifyTheme({"IconSpot", "LayoutOrder", spotIndex})
			menuGap.LayoutOrder = gapIndex
		end
		menuJanitor:add(icon.alignmentChanged:Connect(updateAlignent))
		updateAlignent()
		
		-- This updates the scrolling frame to only display a scroll
		-- length equal to the distance produced by its MaxIcons
		menu:GetAttributeChangedSignal("MenuCanvasWidth"):Connect(function()
			local canvasWidth = menu:GetAttribute("MenuCanvasWidth")
			local canvasY = menu.CanvasSize.Y
			menu.CanvasSize = UDim2.new(0, canvasWidth, canvasY.Scale, canvasY.Offset)
		end)
		menuJanitor:add(icon.updateMenu:Connect(function()
			local maxIcons = menu:GetAttribute("MaxIcons")
			if not maxIcons then
				return
			end
			local orderedInstances = {}
			for _, child in pairs(menu:GetChildren()) do
				local widgetUID = child:GetAttribute("WidgetUID")
				if widgetUID and child.Visible then
					table.insert(orderedInstances, {child, child.AbsolutePosition.X})
				end
			end
			table.sort(orderedInstances, function(groupA, groupB)
				return groupA[2] < groupB[2]
			end)
			local totalWidth = 0
			for i = 1, maxIcons do
				local group = orderedInstances[i]
				if not group then
					break
				end
				local child = group[1]
				local width = child.AbsoluteSize.X + menuUIListLayout.Padding.Offset
				totalWidth += width
			end
			menu:SetAttribute("MenuWidth", totalWidth)
		end))
		local function startMenuUpdate()
			task.delay(0.1, function()
				icon.startMenuUpdate:Fire()
			end)
		end
		menuJanitor:add(menu.ChildAdded:Connect(startMenuUpdate))
		menuJanitor:add(menu.ChildRemoved:Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxIcons"):Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxWidth"):Connect(startMenuUpdate))
		startMenuUpdate()
	end
	
	icon.menuChildAdded:Connect(totalChildrenChanged)
	icon.menuSet:Connect(function(arrayOfIcons)
		-- Reset any previous icons
		for i, otherIconUID in pairs(icon.menuIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		-- Apply new icons
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinMenu(icon)
			end
		end
	end)
	
	return menu
end]]></ProtectedString>
								<string name="ScriptGuid">{0B304BC3-4A7A-45D5-AC26-D6047AD5D843}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Menu.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF28E78F30223449FBB42488180ABA4BE">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local notice = Instance.new("Frame")
	notice.Name = "Notice"
	notice.ZIndex = 25
	notice.AutomaticSize = Enum.AutomaticSize.X
	notice.BorderColor3 = Color3.fromRGB(0, 0, 0)
	notice.BorderSizePixel = 0
	notice.BackgroundTransparency = 0.1
	notice.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	notice.Visible = false
	notice.Parent = icon.widget

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = notice

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Parent = notice

	local noticeLabel = Instance.new("TextLabel")
	noticeLabel.Name = "NoticeLabel"
	noticeLabel.ZIndex = 26
	noticeLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	noticeLabel.AutomaticSize = Enum.AutomaticSize.X
	noticeLabel.Size = UDim2.new(1, 0, 1, 0)
	noticeLabel.BackgroundTransparency = 1
	noticeLabel.Position = UDim2.new(0.5, 0, 0.515, 0)
	noticeLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.FontSize = Enum.FontSize.Size14
	noticeLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.Text = "1"
	noticeLabel.TextWrapped = true
	noticeLabel.TextWrap = true
	noticeLabel.Font = Enum.Font.Arial
	noticeLabel.Parent = notice
	
	local iconModule = script.Parent.Parent
	local packages = iconModule.Packages
	local Janitor = require(packages.Janitor)
	local Signal = require(packages.GoodSignal)
	local Utility = require(iconModule.Utility)
	icon.noticeChanged:Connect(function(totalNotices)

		-- Notice amount
		if not totalNotices then
			return
		end
		local exceeded99 = totalNotices > 99
		local noticeDisplay = (exceeded99 and "99+") or totalNotices
		noticeLabel.Text = noticeDisplay
		if exceeded99 then
			noticeLabel.TextSize = 11
		end

		-- Should enable
		local enabled = true
		if totalNotices < 1 then
			enabled = false
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		local dropdownOrMenuActive = #icon.dropdownIcons > 0 or #icon.menuIcons > 0
		if icon.isSelected and dropdownOrMenuActive then
			enabled = false
		elseif parentIcon and not parentIcon.isSelected then
			enabled = false
		end
		Utility.setVisible(notice, enabled, "NoticeHandler")

	end)
	icon.noticeStarted:Connect(function(customClearSignal, noticeId)
	
		if not customClearSignal then
			customClearSignal = icon.deselected
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		if parentIcon then
			parentIcon:notify(customClearSignal)
		end
		
		local noticeJanitor = icon.janitor:add(Janitor.new())
		local noticeComplete = noticeJanitor:add(Signal.new())
		noticeJanitor:add(icon.endNotices:Connect(function()
			noticeComplete:Fire()
		end))
		noticeJanitor:add(customClearSignal:Connect(function()
			noticeComplete:Fire()
		end))
		noticeId = noticeId or Utility.generateUID()
		icon.notices[noticeId] = {
			completeSignal = noticeComplete,
			clearNoticeEvent = customClearSignal,
		}
		local function updateNotice()
			icon.noticeChanged:Fire(icon.totalNotices)
		end
		icon.notified:Fire(noticeId)
		icon.totalNotices += 1
		updateNotice()
		noticeComplete:Once(function()
			noticeJanitor:destroy()
			icon.totalNotices -= 1
			icon.notices[noticeId] = nil
			updateNotice()
		end)
	end)
	
	-- Establish the notice
	notice:SetAttribute("ClipToJoinedParent", true)
	icon:clipOutside(notice)
	
	return notice
end]]></ProtectedString>
								<string name="ScriptGuid">{D1DC8017-4586-4647-B5CC-B1C6C79CAC95}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Notice.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX1C0C3B1FFD4E484DBE5C2AEB98D8C2B7">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[return function(Icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local selectionContainer = Instance.new("Frame")
	selectionContainer.Name = "SelectionContainer"
	selectionContainer.Visible = false
	
	local selection = Instance.new("Frame")
	selection.Name = "Selection"
	selection.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	selection.BackgroundTransparency = 1
	selection.BorderColor3 = Color3.fromRGB(0, 0, 0)
	selection.BorderSizePixel = 0
	selection.Parent = selectionContainer

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Name = "UIStroke"
	UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	UIStroke.Color = Color3.fromRGB(255, 255, 255)
	UIStroke.Thickness = 3
	UIStroke.Parent = selection

	local selectionGradient = Instance.new("UIGradient")
	selectionGradient.Name = "SelectionGradient"
	selectionGradient.Parent = UIStroke

	local UICorner = Instance.new("UICorner")
	UICorner:SetAttribute("Collective", "IconCorners")
	UICorner.Name = "UICorner"
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = selection
	
	local RunService = game:GetService("RunService")
	local GuiService = game:GetService("GuiService")
	local rotationSpeed = 1
	selection:GetAttributeChangedSignal("RotationSpeed"):Connect(function()
		rotationSpeed = selection:GetAttribute("RotationSpeed")
	end)
	RunService.Heartbeat:Connect(function()
		if not GuiService.SelectedObject then
			return
		end
		selectionGradient.Rotation = (os.clock() * rotationSpeed * 100) % 360
	end)

	return selectionContainer
	
end]]></ProtectedString>
								<string name="ScriptGuid">{CAAAB745-D981-4CB0-8123-600706B882B2}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Selection.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX43EDD7699E2943668EF8444846410E3A">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- I named this 'Widget' instead of 'Icon' to make a clear difference between the icon *object* and
-- the icon (aka Widget) instance.
-- This contains the core components of the icon such as the button, image, label and notice. It's
-- also responsible for handling the automatic resizing of the widget (based upon image visibility and text length)

return function(icon, Icon)

	local widget = Instance.new("Frame")
	widget:SetAttribute("WidgetUID", icon.UID)
	widget.Name = "Widget"
	widget.BackgroundTransparency = 1
	widget.Visible = true
	widget.ZIndex = 20
	widget.Active = false
	widget.ClipsDescendants = true

	local button = Instance.new("Frame")
	button.Name = "IconButton"
	button.Visible = true
	button.ZIndex = 2
	button.BorderSizePixel = 0
	button.Parent = widget
	button.ClipsDescendants = true
	button.Active = false -- This is essential for mobile scrollers to work when dragging
	icon.deselected:Connect(function()
		button.ClipsDescendants = true
		task.delay(0.2, function()
			if icon.isSelected then
				button.ClipsDescendants = false
			end
		end)
	end)

	-- Account for PreferredTransparency which can be set by every player
	local GuiService = game:GetService("GuiService")
	icon:setBehaviour("IconButton", "BackgroundTransparency", function(value)
		local preference = GuiService.PreferredTransparency
		local newValue = value * preference
		if value == 1 then
			return value
		end
		return newValue
	end)
	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
		icon:refreshAppearance(button, "BackgroundTransparency")
	end))

	local iconCorner = Instance.new("UICorner")
	iconCorner:SetAttribute("Collective", "IconCorners")
	iconCorner.Name = "UICorner"
	iconCorner.Parent = button

	local menu = require(script.Parent.Menu)(icon)
	local menuUIListLayout = menu.MenuUIListLayout
	local menuGap = menu.MenuGap
	menu.Parent = button

	local iconSpot = Instance.new("Frame")
	iconSpot.Name = "IconSpot"
	iconSpot.BackgroundColor3 = Color3.fromRGB(225, 225, 225)
	iconSpot.BackgroundTransparency = 0.9
	iconSpot.Visible = true
	iconSpot.AnchorPoint = Vector2.new(0, 0.5)
	iconSpot.ZIndex = 5
	iconSpot.Parent = menu

	local iconSpotCorner = iconCorner:Clone()
	iconSpotCorner.Parent = iconSpot

	local overlay = iconSpot:Clone()
	overlay.UICorner.Name = "OverlayUICorner"
	overlay.Name = "IconOverlay"
	overlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	overlay.ZIndex = iconSpot.ZIndex + 1
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.Position = UDim2.new(0, 0, 0, 0)
	overlay.AnchorPoint = Vector2.new(0, 0)
	overlay.Visible = false
	overlay.Parent = iconSpot

	local clickRegion = Instance.new("TextButton")
	clickRegion:SetAttribute("CorrespondingIconUID", icon.UID)
	clickRegion.Name = "ClickRegion"
	clickRegion.BackgroundTransparency = 1
	clickRegion.Visible = true
	clickRegion.Text = ""
	clickRegion.ZIndex = 20
	clickRegion.Selectable = true
	clickRegion.SelectionGroup = true
	clickRegion.Parent = iconSpot
	
	local Gamepad = require(script.Parent.Parent.Features.Gamepad)
	Gamepad.registerButton(clickRegion)

	local clickRegionCorner = iconCorner:Clone()
	clickRegionCorner.Parent = clickRegion

	local contents = Instance.new("Frame")
	contents.Name = "Contents"
	contents.BackgroundTransparency = 1
	contents.Size = UDim2.fromScale(1, 1)
	contents.Parent = iconSpot

	local contentsList = Instance.new("UIListLayout")
	contentsList.Name = "ContentsList"
	contentsList.FillDirection = Enum.FillDirection.Horizontal
	contentsList.VerticalAlignment = Enum.VerticalAlignment.Center
	contentsList.SortOrder = Enum.SortOrder.LayoutOrder
	contentsList.VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly
	contentsList.Padding = UDim.new(0, 3)
	contentsList.Parent = contents

	local paddingLeft = Instance.new("Frame")
	paddingLeft.Name = "PaddingLeft"
	paddingLeft.LayoutOrder = 1
	paddingLeft.ZIndex = 5
	paddingLeft.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingLeft.BackgroundTransparency = 1
	paddingLeft.BorderSizePixel = 0
	paddingLeft.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingLeft.Parent = contents

	local paddingCenter = Instance.new("Frame")
	paddingCenter.Name = "PaddingCenter"
	paddingCenter.LayoutOrder = 3
	paddingCenter.ZIndex = 5
	paddingCenter.Size = UDim2.new(0, 0, 1, 0)
	paddingCenter.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingCenter.BackgroundTransparency = 1
	paddingCenter.BorderSizePixel = 0
	paddingCenter.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingCenter.Parent = contents

	local paddingRight = Instance.new("Frame")
	paddingRight.Name = "PaddingRight"
	paddingRight.LayoutOrder = 5
	paddingRight.ZIndex = 5
	paddingRight.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingRight.BackgroundTransparency = 1
	paddingRight.BorderSizePixel = 0
	paddingRight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingRight.Parent = contents

	local iconLabelContainer = Instance.new("Frame")
	iconLabelContainer.Name = "IconLabelContainer"
	iconLabelContainer.LayoutOrder = 4
	iconLabelContainer.ZIndex = 3
	iconLabelContainer.AnchorPoint = Vector2.new(0, 0.5)
	iconLabelContainer.Size = UDim2.new(0, 0, 0.5, 0)
	iconLabelContainer.BackgroundTransparency = 1
	iconLabelContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
	iconLabelContainer.Parent = contents

	local iconLabel = Instance.new("TextLabel")
	local viewportX = workspace.CurrentCamera.ViewportSize.X+200
	iconLabel.Name = "IconLabel"
	iconLabel.LayoutOrder = 4
	iconLabel.ZIndex = 15
	iconLabel.AnchorPoint = Vector2.new(0, 0)
	iconLabel.Size = UDim2.new(0, viewportX, 1, 0)
	iconLabel.ClipsDescendants = false
	iconLabel.BackgroundTransparency = 1
	iconLabel.Position = UDim2.fromScale(0, 0)
	iconLabel.RichText = true
	iconLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
	iconLabel.Text = ""
	iconLabel.TextWrapped = true
	iconLabel.TextWrap = true
	iconLabel.TextScaled = false
	iconLabel.Active = false
	iconLabel.AutoLocalize = true
	iconLabel.Parent = iconLabelContainer

	local iconImage = Instance.new("ImageLabel")
	iconImage.Name = "IconImage"
	iconImage.LayoutOrder = 2
	iconImage.ZIndex = 15
	iconImage.AnchorPoint = Vector2.new(0, 0.5)
	iconImage.Size = UDim2.new(0, 0, 0.5, 0)
	iconImage.BackgroundTransparency = 1
	iconImage.Position = UDim2.new(0, 11, 0.5, 0)
	iconImage.ScaleType = Enum.ScaleType.Stretch
	iconImage.Active = false
	iconImage.Parent = contents

	local iconImageCorner = iconCorner:Clone()
	iconImageCorner:SetAttribute("Collective", nil)
	iconImageCorner.CornerRadius = UDim.new(0, 0)
	iconImageCorner.Name = "IconImageCorner"
	iconImageCorner.Parent = iconImage

	local TweenService = game:GetService("TweenService")
	local resizingCount = 0
	local function handleLabelAndImageChangesUnstaggered(forceUpdateString)

		-- We defer changes by a frame to eliminate all but 1 requests which
		-- could otherwise stack up to 20+ requests in a single frame
		-- We then repeat again once to account for any final changes
		-- Deferring is also essential because properties are set immediately
		-- afterwards (therefore calculations will use the correct values)
		task.defer(function()
			local indicator = icon.indicator
			local usingIndicator = indicator and indicator.Visible
			local usingText = usingIndicator or iconLabel.Text ~= ""
			local usingImage = iconImage.Image ~= "" and iconImage.Image ~= nil
			local _alignment = Enum.HorizontalAlignment.Center
			local NORMAL_BUTTON_SIZE = UDim2.fromScale(1, 1)
			local buttonSize = NORMAL_BUTTON_SIZE
			if usingImage and not usingText then
				iconLabelContainer.Visible = false
				iconImage.Visible = true
				paddingLeft.Visible = false
				paddingCenter.Visible = false
				paddingRight.Visible = false
			elseif not usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = false
				paddingLeft.Visible = true
				paddingCenter.Visible = false
				paddingRight.Visible = true
			elseif usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = true
				paddingLeft.Visible = true
				paddingCenter.Visible = not usingIndicator
				paddingRight.Visible = not usingIndicator
				_alignment = Enum.HorizontalAlignment.Left
			end
			button.Size = buttonSize

			local function getItemWidth(item)
				local targetWidth = item:GetAttribute("TargetWidth") or item.AbsoluteSize.X
				return targetWidth
			end
			local contentsPadding = contentsList.Padding.Offset
			local initialWidgetWidth = contentsPadding --0
			local textWidth = iconLabel.TextBounds.X
			iconLabelContainer.Size = UDim2.new(0, textWidth, iconLabel.Size.Y.Scale, 0)
			for _, child in pairs(contents:GetChildren()) do
				if child:IsA("GuiObject") and child.Visible == true then
					local itemWidth = getItemWidth(child)
					initialWidgetWidth += itemWidth + contentsPadding
				end
			end
			local widgetMinimumWidth = widget:GetAttribute("MinimumWidth")
			local widgetMinimumHeight = widget:GetAttribute("MinimumHeight")
			local widgetBorderSize = widget:GetAttribute("BorderSize")
			local widgetWidth = math.clamp(initialWidgetWidth, widgetMinimumWidth, viewportX)
			local menuIcons = icon.menuIcons
			local additionalWidth = 0
			local hasMenu = #menuIcons > 0
			local showMenu = hasMenu and icon.isSelected
			if showMenu then
				for _, frame in pairs(menu:GetChildren()) do
					if frame ~= iconSpot and frame:IsA("GuiObject") and frame.Visible then
						additionalWidth += getItemWidth(frame) + menuUIListLayout.Padding.Offset
					end
				end
				if not iconSpot.Visible then
					widgetWidth -= (getItemWidth(iconSpot) + menuUIListLayout.Padding.Offset*2 + widgetBorderSize)
				end
				additionalWidth -= (widgetBorderSize*0.5)
				widgetWidth += additionalWidth - (widgetBorderSize*0.75)
			end
			menuGap.Visible = showMenu and iconSpot.Visible
			local desiredWidth = widget:GetAttribute("DesiredWidth")
			if desiredWidth and widgetWidth < desiredWidth then
				widgetWidth = desiredWidth
			end

			icon.updateMenu:Fire()
			local preWidth = math.max(widgetWidth-additionalWidth, widgetMinimumWidth)
			local spotWidth = preWidth-(widgetBorderSize*2)
			local menuWidth = menu:GetAttribute("MenuWidth")
			local totalMenuWidth = menuWidth and menuWidth + spotWidth + menuUIListLayout.Padding.Offset + 10
			if totalMenuWidth then
				local maxWidth = menu:GetAttribute("MaxWidth")
				if maxWidth then
					totalMenuWidth = math.max(maxWidth, widgetMinimumWidth)
				end
				menu:SetAttribute("MenuCanvasWidth", widgetWidth)
				if totalMenuWidth < widgetWidth then
					widgetWidth = totalMenuWidth
				end
			end

			local style = Enum.EasingStyle.Quint
			local direction = Enum.EasingDirection.Out
			local spotWidthMax = math.max(spotWidth, getItemWidth(iconSpot), iconSpot.AbsoluteSize.X)
			local widgetWidthMax = math.max(widgetWidth, getItemWidth(widget), widget.AbsoluteSize.X)
			local SPEED = 750
			local spotTweenInfo = TweenInfo.new(spotWidthMax/SPEED, style, direction)
			local widgetTweenInfo = TweenInfo.new(widgetWidthMax/SPEED, style, direction)
			TweenService:Create(iconSpot, spotTweenInfo, {
				Position = UDim2.new(0, widgetBorderSize, 0.5, 0),
				Size = UDim2.new(0, spotWidth, 1, -widgetBorderSize*2),
			}):Play()
			TweenService:Create(clickRegion, spotTweenInfo, {
				Size = UDim2.new(0, spotWidth, 1, 0),
			}):Play()
			local newWidgetSize = UDim2.fromOffset(widgetWidth, widgetMinimumHeight)
			local updateInstantly = widget.Size.Y.Offset ~= widgetMinimumHeight
			if updateInstantly then
				widget.Size = newWidgetSize
			end
			widget:SetAttribute("TargetWidth", newWidgetSize.X.Offset)
			local movingTween = TweenService:Create(widget, widgetTweenInfo, {
				Size = newWidgetSize,
			})
			movingTween:Play()
			resizingCount += 1
			for i = 1, widgetTweenInfo.Time * 100 do
				task.delay(i/100, function()
					Icon.iconChanged:Fire(icon)
				end)
			end
			task.delay(widgetTweenInfo.Time-0.2, function()
				resizingCount -= 1
				task.defer(function()
					if resizingCount == 0 then
						icon.resizingComplete:Fire()
					end
				end)
			end)
			icon:updateParent()
		end)
	end
	local Utility = require(script.Parent.Parent.Utility)
	local handleLabelAndImageChanges = Utility.createStagger(0.01, handleLabelAndImageChangesUnstaggered)
	local firstTimeSettingFontFace = true
	icon:setBehaviour("IconLabel", "Text", handleLabelAndImageChanges)
	icon:setBehaviour("IconLabel", "FontFace", function(value)
		local previousFontFace = iconLabel.FontFace
		if previousFontFace == value then
			return
		end
		task.spawn(function()
			--[[
			local fontLink = value.Family
			if string.match(fontLink, "rbxassetid://") then
				local ContentProvider = game:GetService("ContentProvider")
				local assets = {fontLink}
				ContentProvider:PreloadAsync(assets)
			end--]]

			-- Afaik there's no way to determine when a Font Family has
			-- loaded (even with ContentProvider), so we just have to try
			-- a few times and hope it loads within the refresh period
			handleLabelAndImageChanges()
			if firstTimeSettingFontFace then
				firstTimeSettingFontFace = false
				for i = 1, 10 do
					task.wait(1)
					handleLabelAndImageChanges()
				end
			end
		end)
	end)
	local function updateBorderSize()
		task.defer(function()
			local borderOffset = widget:GetAttribute("BorderSize")
			local alignment = icon.alignment
			local alignmentOffset = (iconSpot.Visible == false and 0) or (alignment == "Right" and -borderOffset) or borderOffset
			menu.Position = UDim2.new(0, alignmentOffset, 0, 0)
			menuGap.Size = UDim2.fromOffset(borderOffset, 0)
			menuUIListLayout.Padding = UDim.new(0, 0)
			handleLabelAndImageChanges()
		end)
	end
	icon:setBehaviour("Widget", "BorderSize", updateBorderSize)
	icon:setBehaviour("IconSpot", "Visible", updateBorderSize)
	icon.startMenuUpdate:Connect(handleLabelAndImageChanges)
	icon.updateSize:Connect(handleLabelAndImageChanges)
	icon:setBehaviour("ContentsList", "HorizontalAlignment", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "DesiredWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumHeight", handleLabelAndImageChanges)
	icon:setBehaviour("Indicator", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("IconImageRatio", "AspectRatio", handleLabelAndImageChanges)
	icon:setBehaviour("IconImage", "Image", function(value)
		local textureId = (tonumber(value) and "http://www.roblox.com/asset/?id="..value) or value or ""
		if iconImage.Image ~= textureId then
			handleLabelAndImageChanges()
		end
		return textureId
	end)
	icon.alignmentChanged:Connect(function(newAlignment)
		if newAlignment == "Center" then
			newAlignment = "Left"
		end
		menuUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment[newAlignment]
		updateBorderSize()
	end)

	-- Localization support (refresh icon size whenever player changes language changes in-game)
	local Players = game:GetService("Players")
	local localPlayer = Players.LocalPlayer
	local lastLocaleId = localPlayer.LocaleId
	icon.janitor:add(localPlayer:GetPropertyChangedSignal("LocaleId"):Connect(function()
		task.delay(0.2, function()
			local newLocaleId = localPlayer.LocaleId
			if newLocaleId ~= lastLocaleId then
				lastLocaleId = newLocaleId
				icon:refresh()
				task.wait(0.5)
				icon:refresh()
			end
		end)
	end))
	
	local iconImageScale = Instance.new("NumberValue")
	iconImageScale.Name = "IconImageScale"
	iconImageScale.Parent = iconImage
	iconImageScale:GetPropertyChangedSignal("Value"):Connect(function()
		iconImage.Size = UDim2.new(iconImageScale.Value, 0, iconImageScale.Value, 0)
	end)

	local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
	UIAspectRatioConstraint.Name = "IconImageRatio"
	UIAspectRatioConstraint.AspectType = Enum.AspectType.FitWithinMaxSize
	UIAspectRatioConstraint.DominantAxis = Enum.DominantAxis.Height
	UIAspectRatioConstraint.Parent = iconImage

	local iconGradient = Instance.new("UIGradient")
	iconGradient.Name = "IconGradient"
	iconGradient.Enabled = true
	iconGradient.Parent = button

	local iconSpotGradient = Instance.new("UIGradient")
	iconSpotGradient.Name = "IconSpotGradient"
	iconSpotGradient.Enabled = true
	iconSpotGradient.Parent = iconSpot

	return widget
end]]></ProtectedString>
								<string name="ScriptGuid">{BC39889F-6520-4D1C-8BF6-0F453E4C0210}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Widget.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX40EFEE28035D455FB13761F7EE0CB88D">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Themes = require(script.Parent.Parent.Features.Themes)
local PADDING = 0 -- used to be 8
return function(icon)
	
	local dropdown = Instance.new("Frame") -- Instance.new("CanvasGroup")
	dropdown.Name = "Dropdown"
	dropdown.AutomaticSize = Enum.AutomaticSize.X
	dropdown.BackgroundTransparency = 1
	dropdown.BorderSizePixel = 0
	dropdown.AnchorPoint = Vector2.new(0.5, 0)
	dropdown.Position = UDim2.new(0.5, 0, 1, 10)
	dropdown.ZIndex = -2
	dropdown.ClipsDescendants = true
	dropdown.Parent = icon.widget

	-- Account for PreferredTransparency which can be set by every player
	local GuiService = game:GetService("GuiService")
	icon:setBehaviour("Dropdown", "BackgroundTransparency", function(value)
		local preference = GuiService.PreferredTransparency
		local newValue = value * preference
		if value == 1 then
			return value
		end
		return newValue
	end)
	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
		icon:refreshAppearance(dropdown, "BackgroundTransparency")
	end))

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "DropdownCorner"
	UICorner.CornerRadius = UDim.new(0, 10)
	UICorner.Parent = dropdown

	local dropdownScroller = Instance.new("ScrollingFrame")
	dropdownScroller.Name = "DropdownScroller"
	dropdownScroller.AutomaticSize = Enum.AutomaticSize.X
	dropdownScroller.BackgroundTransparency = 1
	dropdownScroller.BorderSizePixel = 0
	dropdownScroller.AnchorPoint = Vector2.new(0, 0)
	dropdownScroller.Position = UDim2.new(0, 0, 0, 0)
	dropdownScroller.ZIndex = -1
	dropdownScroller.ClipsDescendants = true
	dropdownScroller.Visible = true
	dropdownScroller.VerticalScrollBarInset = Enum.ScrollBarInset.None --ScrollBar
	dropdownScroller.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
	dropdownScroller.Active = false
	dropdownScroller.ScrollingEnabled = true
	dropdownScroller.AutomaticCanvasSize = Enum.AutomaticSize.Y
	dropdownScroller.ScrollBarThickness = 5
	dropdownScroller.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	dropdownScroller.ScrollBarImageTransparency = 0.8
	dropdownScroller.CanvasSize = UDim2.new(0, 0, 0, 0)
	dropdownScroller.Selectable = false
	dropdownScroller.Active = true
	dropdownScroller.Parent = dropdown

	local TweenDuration = Instance.new("NumberValue") -- this helps to change the speed to open / close in modifyTheme()
	TweenDuration.Name = "DropdownSpeed"
	TweenDuration.Value = 0.07
	TweenDuration.Parent = dropdown

	local dropdownPadding = Instance.new("UIPadding")
	dropdownPadding.Name = "DropdownPadding"
	dropdownPadding.PaddingTop = UDim.new(0, PADDING)
	dropdownPadding.PaddingBottom = UDim.new(0, PADDING)
	dropdownPadding.Parent = dropdownScroller

	local dropdownList = Instance.new("UIListLayout")
	dropdownList.Name = "DropdownList"
	dropdownList.FillDirection = Enum.FillDirection.Vertical
	dropdownList.SortOrder = Enum.SortOrder.LayoutOrder
	dropdownList.HorizontalAlignment = Enum.HorizontalAlignment.Center
	dropdownList.HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly
	dropdownList.Parent = dropdownScroller

	local dropdownJanitor = icon.dropdownJanitor
	local Icon = require(icon.iconModule)
	icon.dropdownChildAdded:Connect(function(childIcon)
		local _, modificationUID = childIcon:modifyTheme({
			{"Widget", "BorderSize", 0},
			{"IconCorners", "CornerRadius", UDim.new(0, 10)},
			{"Widget", "MinimumWidth", 190},
			{"Widget", "MinimumHeight", 58},
			{"IconLabel", "TextSize", 20},
			{"IconOverlay", "Size", UDim2.new(1, 0, 1, 0)},
			{"PaddingLeft", "Size", UDim2.fromOffset(25, 0)},
			{"Notice", "Position", UDim2.new(1, -24, 0, 5)},
			{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Left},
			{"Selection", "Size", UDim2.new(1, -PADDING, 1, -PADDING)},
			{"Selection", "Position", UDim2.new(0, PADDING/2, 0, PADDING/2)},
		})
		task.defer(function()
			childIcon.joinJanitor:add(function()
				childIcon:removeModification(modificationUID)
			end)
		end)
	end)
	icon.dropdownSet:Connect(function(arrayOfIcons)
		for i, otherIconUID in pairs(icon.dropdownIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinDropdown(icon)
			end
		end
	end)

	local function updateMaxIcons()
		--icon:modifyTheme({"Dropdown", "Visible", icon.isSelected})
		local maxIcons = dropdown:GetAttribute("MaxIcons")
		if not maxIcons then return 0 end
		local children = {}
		for _, child in pairs(dropdownScroller:GetChildren()) do
			if child:IsA("GuiObject") and child.Visible then
				table.insert(children, child)
			end
		end

		table.sort(children, function(a, b) return a.AbsolutePosition.Y < b.AbsolutePosition.Y end)
		local totalHeight = 0
		local maxIconsRoundedUp = math.ceil(maxIcons)
		for i = 1, maxIconsRoundedUp do
			local child = children[i]
			if not child then break end
			local height = child.AbsoluteSize.Y
			local isReduced = i == maxIconsRoundedUp and maxIconsRoundedUp ~= maxIcons
			if isReduced then
				height *= (maxIcons - maxIconsRoundedUp + 1)
			end
			totalHeight += height
		end
		totalHeight += dropdownPadding.PaddingTop.Offset + dropdownPadding.PaddingBottom.Offset
		return totalHeight
	end
	
	local openTween = nil
	local closeTween = nil
	local currentSpeedMultiplier = nil
	local currentTweenInfo = nil
	local function getTweenInfo()
		local speedMultiplier = Themes.getInstanceValue(dropdown, "MaxIcons") or 1
		if currentSpeedMultiplier and currentSpeedMultiplier == speedMultiplier and currentTweenInfo then
			return currentTweenInfo
		end
		local newTweenInfo = TweenInfo.new(
			TweenDuration.Value * speedMultiplier,
			Enum.EasingStyle.Exponential,
			Enum.EasingDirection.Out
		)
		currentTweenInfo = newTweenInfo
		currentSpeedMultiplier = speedMultiplier
		return newTweenInfo
	end
	local function updateVisibility()
		-- Update visibiliy of dropdown using tween transition
		local tweenInfo = getTweenInfo()
		
		if openTween then
			openTween:Cancel()
			openTween = nil
		end
		if closeTween then
			closeTween:Cancel()
			closeTween = nil
		end

		if icon.isSelected then
			local height = updateMaxIcons()
			dropdown.Visible = true
			dropdown.BackgroundTransparency = 0 -- no transparency so it looks solid
			dropdown.Size = UDim2.new(0, dropdown.Size.X.Offset, 0, 0) -- reset height to 0 before tween

			openTween = TweenService:Create(dropdown, tweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, height)})
			openTween:Play()
			openTween.Completed:Connect(function()
				openTween = nil
			end)
		else
			local closeTweenInfo = TweenInfo.new(0)
			closeTween = TweenService:Create(dropdown, closeTweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, 0)})
			closeTween:Play()
			closeTween.Completed:Connect(function()
				closeTween = nil
			end)
		end
	end

	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))
	updateVisibility()
	--task.delay(0.2, updateVisibility)

	local function updateChildSize()
		local tweenInfo = getTweenInfo()
		if not icon.isSelected then return end
		if openTween then
			openTween:Cancel()
			openTween = nil
		end
		if closeTween then
			closeTween:Cancel()
			closeTween = nil
		end
		
		RunService.Heartbeat:Wait()
		
		local height = updateMaxIcons()

		openTween = TweenService:Create(dropdown, tweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, height)})
		openTween:Play()
		openTween.Completed:Connect(function()	
			openTween = nil
		end)
	end

	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))

	-- Ensures canvas and size stay synced (original updateMaxIcons logic)
	local updateCount = 0
	local isUpdating = false

	-- This updates the scrolling frame to only display a scroll
	-- length equal to the distance produced by its MaxIcons
	local function updateMaxIconsListener()
		updateCount += 1
		if isUpdating then return end
		local myUpdateCount = updateCount
		isUpdating = true
		task.defer(function()
			isUpdating = false
			if updateCount ~= myUpdateCount then
				updateMaxIconsListener()
			end
		end)
		local maxIcons = dropdown:GetAttribute("MaxIcons")
		if not maxIcons then return end

		local orderedInstances = {}
		for _, child in pairs(dropdownScroller:GetChildren()) do
			if child:IsA("GuiObject") and child.Visible then
				table.insert(orderedInstances, {child, child.AbsolutePosition.Y})
			end
		end
		table.sort(orderedInstances, function(a, b) return a[2] < b[2] end)

		local totalHeight = 0
		local hasSetNextSelection = false
		local maxIconsRoundedUp = math.ceil(maxIcons)
		for i = 1, maxIconsRoundedUp do
			local group = orderedInstances[i]
			if not group then break end
			local child = group[1]
			local height = child.AbsoluteSize.Y
			local isReduced = i == maxIconsRoundedUp and maxIconsRoundedUp ~= maxIcons
			if isReduced then
				height = height * (maxIcons - maxIconsRoundedUp + 1)
			end
			totalHeight += height
			if isReduced then
				continue
			end
			local iconUID = child:GetAttribute("WidgetUID")
			local childIcon = iconUID and Icon.getIconByUID(iconUID)
			if childIcon then
				local nextSelection = nil
				if not hasSetNextSelection then
					hasSetNextSelection = true
					nextSelection = icon:getInstance("ClickRegion")
				end
				childIcon:getInstance("ClickRegion").NextSelectionUp = nextSelection
			end
		end
		totalHeight += dropdownPadding.PaddingTop.Offset + dropdownPadding.PaddingBottom.Offset

		dropdownScroller.Size = UDim2.fromOffset(0, totalHeight)

	end

	dropdownJanitor:add(dropdownScroller:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdownScroller.ChildAdded:Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateChildSize)) -- rezise the dropdown when icon delects or adds
	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateChildSize))
	dropdownJanitor:add(icon.childThemeModified:Connect(updateMaxIconsListener))
	updateMaxIconsListener()

	-- Ensures each child listens to visibility changes
	local function connectVisibilityListeners(child)
		if child:IsA("GuiObject") then
			child:GetPropertyChangedSignal("Visible"):Connect(updateChildSize)
			child:GetPropertyChangedSignal("Size"):Connect(updateChildSize) -- -- update max icons when child size changes
		end
	end
	
	-- For existing children
	for _, child in pairs(dropdownScroller:GetChildren()) do
		connectVisibilityListeners(child)
	end
	-- For new children
	dropdownScroller.ChildAdded:Connect(function(child)
		RunService.Heartbeat:Wait()
		connectVisibilityListeners(child)
		updateChildSize()
	end)

	-- On start, hide dropdown (prevent it showing as opened)
	dropdown.Visible = false

	return dropdown
end]]></ProtectedString>
								<string name="ScriptGuid">{9F0AB4C0-3E4B-4FEE-ACD0-EAB062B762A7}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Dropdown.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX2D356A6C7FDE4A7DBC6210B8E3684273">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Features</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX92993A22893D42A5B3CA6F2E451CAD44">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- As the name suggests, this handles everything related to gamepads
-- (i.e. Xbox or Playstation controllers) and their navigation
-- I created a separate module for gamepads (and not touchpads or
-- keyboards) because gamepads are greatly more unqiue and require
-- additional tailored programming



-- SERVICES
local GamepadService = game:GetService("GamepadService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")



-- LOCAL
local DEFAULT_HIGHLIGHT_KEY = Enum.KeyCode.DPadUp -- The default key to highlight the topbar icon
local GAMEPAD_INPUT = Enum.PreferredInput.Gamepad
local Gamepad = {}
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Gamepad.start(incomingIcon)
	
	-- Public variables
	Icon = incomingIcon
	Icon.highlightKey = if Icon.highlightKey ~= nil then Icon.highlightKey else DEFAULT_HIGHLIGHT_KEY -- What controller key to highlight the topbar (or set to false to disable)
	Icon.highlightIcon = false -- Change to a specific icon if you'd like to highlight a specific icon instead of the left-most
	
	-- We defer so the developer can make changes before the
	-- gamepad controls are initialized
	task.delay(1, function()
		-- Some local utility
		local iconsDict = Icon.iconsDictionary
		local function getIconFromSelectedObject()
			local clickRegion = GuiService.SelectedObject
			local iconUID = clickRegion and clickRegion:GetAttribute("CorrespondingIconUID")
			local icon = iconUID and iconsDict[iconUID]
			return icon
		end
		
		-- This enables users to instantly open up their last selected icon
		local previousHighlightedIcon
		local usedIndicatorOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
		local usedBOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
		local Selection = require(script.Parent.Parent.Elements.Selection)
		local function updateSelectedObject()
			local icon = getIconFromSelectedObject()
			local isUsingGamepad = UserInputService.PreferredInput == GAMEPAD_INPUT
			if icon then
				if isUsingGamepad then
					local clickRegion = icon:getInstance("ClickRegion")
					local selection = icon.selection
					if not selection then
						selection = icon.janitor:add(Selection(Icon))
						selection:SetAttribute("IgnoreVisibilityUpdater", true)
						selection.Parent = icon.widget
						icon.selection = selection
						icon:refreshAppearance(selection) --icon:clipOutside(selection)
					end
					clickRegion.SelectionImageObject = selection.Selection
				end
				if previousHighlightedIcon and previousHighlightedIcon ~= icon then
					previousHighlightedIcon:setIndicator()
				end
				local newIndicator = if isUsingGamepad and not usedBOnce and not icon.parentIconUID then Enum.KeyCode.ButtonB else nil
				previousHighlightedIcon = icon
				Icon.lastHighlightedIcon = icon
				icon:setIndicator(newIndicator)
			else
				local newIndicator = if isUsingGamepad and not usedIndicatorOnce then Icon.highlightKey else nil
				if not previousHighlightedIcon then
					previousHighlightedIcon = Gamepad.getIconToHighlight()
				end
				if newIndicator == Icon.highlightKey then
					-- We only display the highlightKey once to show
					-- the user how to highlight the topbar icon
					usedIndicatorOnce = true
				else
					--usedBOnce = true
				end
				if previousHighlightedIcon then
					previousHighlightedIcon:setIndicator(newIndicator)
				end
			end
		end
		GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(updateSelectedObject)

		-- This listens for a gamepad being present/added/removed
		local function preferredInputChanged()
			local preferredInput = UserInputService.PreferredInput
			local isUsingGamepad = preferredInput == GAMEPAD_INPUT

			if not isUsingGamepad then
				usedIndicatorOnce = false
				usedBOnce = false
			end
			updateSelectedObject()
		end
		UserInputService:GetPropertyChangedSignal("PreferredInput"):Connect(preferredInputChanged)
		preferredInputChanged()

		-- This allows for easy highlighting of the topbar when the
		-- when ``Icon.highlightKey`` (i.e. DPadUp) is pressed.
		-- If you'd like to disable, do ``Icon.highlightKey = false``
		UserInputService.InputBegan:Connect(function(input, touchingAnObject)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				-- Sometimes the Roblox gamepad glitches when combined with a cursor
				-- This fixes that by unhighlighting if the cursor is pressed down
				-- (i.e. a mouse click)
				local icon = getIconFromSelectedObject()
				if icon then
					GuiService.SelectedObject = nil
				end
				return
			end
			if input.KeyCode ~= Icon.highlightKey then
				return
			end
			local iconToHighlight = Gamepad.getIconToHighlight()
			if iconToHighlight then
				if GamepadService.GamepadCursorEnabled then
					task.wait(0.2)
					GamepadService:DisableGamepadCursor()
				end
				local clickRegion = iconToHighlight:getInstance("ClickRegion")
				GuiService.SelectedObject = clickRegion
			end
		end)
	end)
end

function Gamepad.getIconToHighlight()
	-- If an icon has already been selected, returns the last selected icon
	-- Else if more than 0 icons, it selects the left-most icon
	local iconsDict = Icon.iconsDictionary
	local iconToHighlight = Icon.highlightIcon or Icon.lastHighlightedIcon
	if not iconToHighlight then
		local currentX
		for _, icon in pairs(iconsDict) do
			if icon.parentIconUID then
				continue
			end
			local thisX = icon.widget.AbsolutePosition.X
			if not currentX or thisX < currentX then
				iconToHighlight = icon
				currentX = iconToHighlight.widget.AbsolutePosition.X
			end
		end
	end
	return iconToHighlight
end

-- This called when the icon's ClickRegion is created
function Gamepad.registerButton(buttonInstance)
	-- This provides a basic level of support for controllers by making
	-- the icons easy to highlight via the virtual cursor, then
	-- when selected, focuses in on the selected icon and hops
	-- between other nearby icons simply by toggling the joystick
	local inputBegan = false
	buttonInstance.InputBegan:Connect(function(input)
		-- Two wait frames required to ensure inputBegan is detected within
		-- UserInputService.InputBegan. We do this because object.InputBegan
		-- does not return the correct input objects (unlike the service)
		inputBegan = true
		task.wait()
		task.wait()
		inputBegan = false
	end)
	local connection = UserInputService.InputBegan:Connect(function(input)
		task.wait()
		if input.KeyCode == Enum.KeyCode.ButtonA and inputBegan then
			-- We focus on an icon when selected via the virtual cursor
			task.wait(0.2)
			GamepadService:DisableGamepadCursor()
			GuiService.SelectedObject = buttonInstance
			return
		end
		local isSelected = GuiService.SelectedObject == buttonInstance
		local unselectKeyCodes = {"ButtonB", "ButtonSelect"}
		local keyName = input.KeyCode.Name
		if table.find(unselectKeyCodes, keyName) and isSelected then
			-- We unfocus when back button is pressed, but ignore
			-- if the virtual cursor is disabled otherwise it will be
			-- impossible to select the topbar
			if not(keyName == "ButtonSelect" and not GamepadService.GamepadCursorEnabled) then
				GuiService.SelectedObject = nil
			end
		end
	end)
	buttonInstance.Destroying:Once(function()
		connection:Disconnect()
	end)
end



return Gamepad]]></ProtectedString>
								<string name="ScriptGuid">{9529EF9E-2024-4908-B067-F9421BFF2118}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Gamepad.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXCE3D912614F340FDB6E8169A85CE2CCD">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- When designing your game for many devices and screen sizes, icons may occasionally
-- particularly for smaller devices like phones, overlap with other icons or the bounds
-- of the screen. The overflow handler solves this challenge by moving the out-of-bounds
-- icon into an overflow menu (with a limited scrolling canvas) preventing overlaps occuring



-- LOCAL
local Overflow = {}
local holders = {}
local orderedAvailableIcons = {}
local iconsDict
local currentCamera = workspace.CurrentCamera
local overflowIcons = {}
local overflowIconUIDs = {}
local Utility = require(script.Parent.Parent.Utility)
local beginCheckingCenterIcons = false
local beganSecondaryCenterCheck = false
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Overflow.start(incomingIcon)
	Icon = incomingIcon
	iconsDict = Icon.iconsDictionary
	local primaryScreenGui
	for _, screenGui in pairs(Icon.container) do
		if primaryScreenGui == nil and screenGui.ScreenInsets == Enum.ScreenInsets.TopbarSafeInsets then
			primaryScreenGui = screenGui
		end
		for _, holder in pairs(screenGui.Holders:GetChildren()) do
			if holder:GetAttribute("IsAHolder") then
				holders[holder.Name] = holder
			end
		end
	end

	-- We listen for changes in icons (such as them being added, removed,
	-- the setting of a different alignment, the widget size changing, etc)
	local beginOverflow = false
	local updateBoundaries = Utility.createStagger(0.1, function(ignoreAvailable)
		if not beginOverflow then
			return
		end
		if not ignoreAvailable then
			Overflow.updateAvailableIcons("Center")
		end
		Overflow.updateBoundary("Left")
		Overflow.updateBoundary("Right")
	end)
	task.delay(0.5, function()
		beginOverflow = true
		updateBoundaries()
	end)
	task.delay(2, function()
		-- This is essential to prevent central icons begin added
		-- left or right due to incomplete UIListLayout calculations
		-- within the first few frames
		beginCheckingCenterIcons = true
		updateBoundaries()
	end)
	Icon.iconAdded:Connect(updateBoundaries)
	Icon.iconRemoved:Connect(updateBoundaries)
	Icon.iconChanged:Connect(updateBoundaries)
	currentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
		updateBoundaries(true)
	end)
	primaryScreenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updateBoundaries(true)
	end)
end

function Overflow.getWidth(icon, getMaxWidth)
	local widget = icon.widget
	return widget:GetAttribute("TargetWidth") or widget.AbsoluteSize.X
end

function Overflow.getAvailableIcons(alignment)
	local ourOrderedIcons = orderedAvailableIcons[alignment]
	if not ourOrderedIcons then
		ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	end
	return ourOrderedIcons
end

function Overflow.updateAvailableIcons(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon)
	local ourTotal = 0
	local ourOrderedIcons = {}
	for _, icon in pairs(iconsDict) do
		local parentUID = icon.parentIconUID
		local isDirectlyOnTopbar = not parentUID or overflowIconUIDs[parentUID]
		local isOverflow = overflowIconUIDs[icon.UID]
		if isDirectlyOnTopbar and icon.alignment == alignment and not isOverflow and icon.isEnabled then
			table.insert(ourOrderedIcons, icon)
			ourTotal += 1
		end
	end

	-- Ignore if no icons are available
	if ourTotal <= 0 then
		return {}
	end

	-- This sorts these icons by smallest order, or if equal, left-most position
	-- (even for the right alignment because all icons are sorted left-to-right)
	table.sort(ourOrderedIcons, function(iconA, iconB)
		local orderA = iconA.widget.LayoutOrder
		local orderB = iconB.widget.LayoutOrder
		local hasParentA = iconA.parentIconUID
		local hasParentB = iconB.parentIconUID
		if hasParentA == hasParentB then
			if orderA < orderB then
				return true
			end
			if orderA > orderB then
				return false
			end
			return iconA.widget.AbsolutePosition.X < iconB.widget.AbsolutePosition.X
		elseif hasParentB then
			return false
		elseif hasParentA then
			return true
		end
		return nil
	end)

	-- Finish up
	orderedAvailableIcons[alignment] = ourOrderedIcons
	return ourOrderedIcons

end

function Overflow.getRealXPositions(alignment, orderedIcons)
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local isLeft = alignment == "Left"
	local holder = holders[alignment]
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local holderUIList = holder.UIListLayout
	local topbarInset = holderUIList.Padding.Offset
	local absoluteX = (isLeft and holderXPos) or holderXPos + holderXSize
	local realXPositions = {}
	if isLeft then
		Utility.reverseTable(orderedIcons)
	end
	for i = #orderedIcons, 1, -1 do
		local icon = orderedIcons[i]
		local sizeX = Overflow.getWidth(icon)
		if not isLeft then
			absoluteX -= sizeX
		end
		realXPositions[icon.UID] = absoluteX
		if isLeft then
			absoluteX += sizeX
		end
		absoluteX += (isLeft and topbarInset) or -topbarInset
	end
	return realXPositions
end

function Overflow.updateBoundary(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon) or within an overflow
	local holder = holders[alignment]
	local holderUIList = holder.UIListLayout
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local topbarInset = holderUIList.Padding.Offset
	local topbarPadding = holderUIList.Padding.Offset
	local BOUNDARY_GAP = topbarInset
	local ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	local boundWidth = 0
	local ourTotal = 0
	for _, icon in pairs(ourOrderedIcons) do
		boundWidth += Overflow.getWidth(icon) + topbarPadding
		ourTotal += 1
	end
	if ourTotal <= 0 then
		return
	end
	
	-- These are the icons with menus which icons will be moved into
	-- when overflowing
	local isCentral = alignment == "Center"
	local isLeft = alignment == "Left"
	local isRight = not isLeft
	local overflowIcon = overflowIcons[alignment]
	if not overflowIcon and not isCentral and #ourOrderedIcons > 0 then
		local order = (isLeft and -9999999) or 9999999
		overflowIcon = Icon.new()--:setLabel(`{alignment}`)
		overflowIcon:setImage(6069276526, "Deselected")
		overflowIcon:setName("Overflow"..alignment)
		overflowIcon:setOrder(order)
		overflowIcon:setAlignment(alignment)
		overflowIcon:autoDeselect(false)
		overflowIcon.isAnOverflow = true
		--overflowIcon:freezeMenu()
		overflowIcon:select("OverflowStart", overflowIcon)
		overflowIcon:setEnabled(false)
		overflowIcons[alignment] = overflowIcon
		overflowIconUIDs[overflowIcon.UID] = true
		if not Icon.closeableOverflowMenus then
			local iconSpot = overflowIcon:getInstance("IconSpot")
			iconSpot.Visible = false
		end
	end

	-- The default boundary is the point where both the left-most-right-icon
	-- and left-most-right-icon meet OR the opposite side of the screen
	local oppositeAlignment = (alignment == "Left" and "Right") or "Left"
	local oppositeOrderedIcons = Overflow.updateAvailableIcons(oppositeAlignment)
	local nearestOppositeIcon = (isLeft and oppositeOrderedIcons[1]) or (isRight and oppositeOrderedIcons[#oppositeOrderedIcons])
	local oppositeOverflowIcon = overflowIcons[oppositeAlignment]
	local boundary = (isLeft and holderXPos + holderXSize) or holderXPos
	if nearestOppositeIcon then
		local oppositeRealXPositions = Overflow.getRealXPositions(oppositeAlignment, oppositeOrderedIcons)
		local oppositeX = oppositeRealXPositions[nearestOppositeIcon.UID]
		local oppositeXSize = Overflow.getWidth(nearestOppositeIcon)
		boundary = (isLeft and oppositeX - BOUNDARY_GAP) or oppositeX + oppositeXSize + BOUNDARY_GAP
	end
	
	-- We get the left-most icon (if left alignment) or right-most-icon (if
	-- right alignment) of the central icons group to see if we need to change
	-- the boundary (if the central icon boundary is smaller than the alignment
	-- boundary then we use the central)
	local totalChecks = 0
	local usingNearestCenter = false
	local function checkToShiftCentralIcon()
		local centerOrderedIcons = Overflow.getAvailableIcons("Center")
		local centerPos = (isLeft and 1) or #centerOrderedIcons
		local nearestCenterIcon = centerOrderedIcons[centerPos]
		local function secondaryCheck()
			if not beganSecondaryCenterCheck then
				beganSecondaryCenterCheck = true
				task.delay(3, Overflow.updateBoundary, alignment)
			end
		end
		if nearestCenterIcon and not nearestCenterIcon.hasRelocatedInOverflow then
			local ourNearestIcon = (isLeft and ourOrderedIcons[#ourOrderedIcons]) or (isRight and ourOrderedIcons[1])
			local centralNearestXPos = nearestCenterIcon.widget.AbsolutePosition.X
			local ourNearestXPos = ourNearestIcon.widget.AbsolutePosition.X
			local ourNearestXSize = Overflow.getWidth(ourNearestIcon)
			local centerBoundary = (isLeft and centralNearestXPos-BOUNDARY_GAP) or centralNearestXPos + Overflow.getWidth(nearestCenterIcon) + BOUNDARY_GAP
			local removeBoundary = (isLeft and ourNearestXPos + ourNearestXSize) or ourNearestXPos
			local hasShifted = false
			if isLeft then
				if centerBoundary < removeBoundary then
					if not beginCheckingCenterIcons then
						secondaryCheck()
						return
					end
					nearestCenterIcon:align("Left")
					nearestCenterIcon.hasRelocatedInOverflow = true
					hasShifted = true
				end
			elseif isRight then
				if centerBoundary > removeBoundary then
					if not beginCheckingCenterIcons or removeBoundary < 0 then
						secondaryCheck()
						return
					end
					nearestCenterIcon:align("Right")
					nearestCenterIcon.hasRelocatedInOverflow = true
					hasShifted = true
				end
			end
			if hasShifted then
				totalChecks += 1
				if totalChecks <= 4 then
					Overflow.updateAvailableIcons("Center")
					checkToShiftCentralIcon()
				end
			end
		end
	end
	checkToShiftCentralIcon()
	
	--[[
	This updates the maximum size of the overflow menus
	The menu determines its bounds from the smallest of either:
	 	1. The closest center-aligned icon (i.e. the boundary)
	 	2. The edge of the opposite overflow menu UNLESS...
	 	3. ... the edge exceeds more than half the screenGui
	--]]
	if overflowIcon then
		local menuBoundary = boundary
		local menu = overflowIcon:getInstance("Menu")
		local holderXEndPos = holderXPos + holderXSize
		local menuWidth = holderXSize
		if menu and oppositeOverflowIcon then
			local oppositeWidget = oppositeOverflowIcon.widget
			local oppositeXPos = oppositeWidget.AbsolutePosition.X
			local oppositeXSize = Overflow.getWidth(oppositeOverflowIcon)
			local oppositeBoundary = (isLeft and oppositeXPos - BOUNDARY_GAP) or oppositeXPos + oppositeXSize + BOUNDARY_GAP
			local oppositeMenu = oppositeOverflowIcon:getInstance("Menu")
			local isDominant = menu.AbsoluteCanvasSize.X >= oppositeMenu.AbsoluteCanvasSize.X
			if not usingNearestCenter then
				local halfwayXPos = holderXPos + holderXSize/2
				local halfwayBoundary = (isLeft and halfwayXPos - BOUNDARY_GAP/2) or halfwayXPos + BOUNDARY_GAP/2
				menuBoundary = halfwayBoundary
				if isDominant then
					menuBoundary = oppositeBoundary
				end
			end
			menuWidth = (isLeft and menuBoundary - holderXPos) or (holderXEndPos - menuBoundary)
		end
		local currentMaxWidth = menu and menu:GetAttribute("MaxWidth")
		menuWidth = Utility.round(menuWidth)
		if menu and currentMaxWidth ~= menuWidth then
			menu:SetAttribute("MaxWidth", menuWidth)
		end
	end

	-- Parent ALL icons of that alignment into the overflow if at least on
	-- sibling exceeds the bounds.
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local joinOverflow = false
	local realXPositions = Overflow.getRealXPositions(alignment, ourOrderedIcons)
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local widgetX = Overflow.getWidth(icon)
		local xPos = realXPositions[icon.UID]
		if (isLeft and xPos + widgetX >= boundary) or (isRight and xPos <= boundary) then
			joinOverflow = true
		end
	end
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local isOverflow = overflowIconUIDs[icon.UID]
		if not isOverflow then
			if joinOverflow and not icon.parentIconUID then
				icon:joinMenu(overflowIcon)
			elseif not joinOverflow and icon.parentIconUID then
				icon:leave()
			end
		end
	end
	
	-- Hide the overflows when not in use
	if overflowIcon.isEnabled ~= joinOverflow then
		overflowIcon:setEnabled(joinOverflow)
	end
	
	-- Have the menus auto selected
	if overflowIcon.isEnabled and not overflowIcon.overflowAlreadyOpened then
		overflowIcon.overflowAlreadyOpened = true
		overflowIcon:select()
	end

end



return Overflow]]></ProtectedString>
								<string name="ScriptGuid">{3288A332-DE1E-4A2E-BA8D-609C7D031735}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Overflow.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX7B1D2BFE4AF348DC934D811B3498C80D">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- The functions here are dedicated solely to managing theme state
-- and updating the appearance of instances to match that state.
-- You don't need to use any of these functions, the useful ones
-- have been abstracted as icon methods



-- LOCAL
local Themes = {}
local Utility = require(script.Parent.Parent.Utility)
local baseTheme = require(script.Default)



-- FUNCTIONS
function Themes.getThemeValue(stateGroup, instanceName, property, iconState)
	if stateGroup then
		for _, detail in pairs(stateGroup) do
			local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
			if instanceName == checkingInstanceName and property == checkingPropertyName then
				return checkingValue
			end
		end
	end
	return nil
end

function Themes.getInstanceValue(instance, property)
	local success, value = pcall(function()
		return instance[property]
	end)
	if not success then
		value = instance:GetAttribute(property)
	end
	return value
end

function Themes.getRealInstance(instance)
	if not instance:GetAttribute("IsAClippedClone") then
		return
	end
	local originalInstance = instance:FindFirstChild("OriginalInstance")
	if not originalInstance then
		return
	end
	return originalInstance.Value
end

function Themes.getClippedClone(instance)
	if not instance:GetAttribute("HasAClippedClone") then
		return
	end
	local clippedClone = instance:FindFirstChild("ClippedClone")
	if not clippedClone then
		return
	end
	return clippedClone.Value
end

function Themes.refresh(icon, instance, specificProperty)
	-- Some instances such as notices need immediate refreshing upon creation as
	-- they're added in after the initial refresh period
	if specificProperty then
		local stateGroup = icon:getStateGroup()
		local value = Themes.getThemeValue(stateGroup, instance.Name, specificProperty) or Themes.getInstanceValue(instance, specificProperty)
		Themes.apply(icon, instance, specificProperty, value, true)
		return
	end
	-- If no property is specified we update all properties that exist within
	-- the applied theme appearance
	local stateGroup = icon:getStateGroup()
	if not stateGroup then
		return
	end
	local validInstances = {[instance.Name] = instance}
	for _, child in pairs(instance:GetDescendants()) do
		local collective = child:GetAttribute("Collective")
		if collective then
			validInstances[collective] = child
		end
		validInstances[child.Name] = child
	end
	for _, detail in pairs(stateGroup) do
		local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
		local instanceToUpdate = validInstances[checkingInstanceName]
		if instanceToUpdate then
			Themes.apply(icon, instanceToUpdate.Name, checkingPropertyName, checkingValue, true)
		end
	end
	return
end

function Themes.apply(icon, collectiveOrInstanceNameOrInstance, property, value, forceApply)
	-- This is responsible for **applying** appearance changes to instances within the icon
	-- however it IS NOT responsible for updating themes. Use :modifyTheme for that.
	-- This also calls callbacks given by :setBehaviour before applying these property changes
	-- to the given instances
	if icon.isDestroyed then
		return
	end
	local instances
	local collectiveOrInstanceName = collectiveOrInstanceNameOrInstance
	if typeof(collectiveOrInstanceNameOrInstance) == "Instance" then
		instances = {collectiveOrInstanceNameOrInstance}
		collectiveOrInstanceName = collectiveOrInstanceNameOrInstance.Name
	else
		instances = icon:getInstanceOrCollective(collectiveOrInstanceNameOrInstance)
	end
	local key = collectiveOrInstanceName.."-"..property
	local customBehaviour = icon.customBehaviours[key]
	for _, instance in pairs(instances) do
		local clippedClone = Themes.getClippedClone(instance)
		if clippedClone then
			-- This means theme effects are applied to both the original
			-- instance and its clone (instead of just the instance).
			-- This is important for some properties such as position
			-- and size which might be dictated by the clone
			table.insert(instances, clippedClone)
		end
	end
	for _, instance in pairs(instances) do
		if property == "Position" and Themes.getClippedClone(instance) then
			-- The clone manages the position of the real instance so ignore
			continue
		elseif property == "Size" and Themes.getRealInstance(instance) then
			-- The real instance manages the size of the clone so ignore
			continue
		end
		local currentValue = Themes.getInstanceValue(instance, property)
		if not forceApply and value == currentValue then
			continue
		end
		if customBehaviour then
			local newValue = customBehaviour(value, instance, property)
			if newValue ~= nil then
				value = newValue
			end
		end
		local success = pcall(function()
			instance[property] = value
		end)
		if not success then
			-- If property is not a real property, we set
			-- the value as an attribute instead. This is useful
			-- for instance in :setWidth where we also want to
			-- specify a desired width for every state which can
			-- then be easily read by the widget element
			instance:SetAttribute(property, value)
		end
	end
end

function Themes.getModifications(modifications)
	if typeof(modifications[1]) ~= "table" then
		-- This enables users to do :modifyTheme({a,b,c,d})
		-- in addition of :modifyTheme({{a,b,c,d}})
		modifications = {modifications}
	end
	return modifications
end

function Themes.merge(detail, modification, callback)
	local instanceName, property, value, stateName = table.unpack(modification)
	local checkingInstanceName, checkingPropertyName, _, checkingStateName = table.unpack(detail)
	if instanceName == checkingInstanceName and property == checkingPropertyName and Themes.statesMatch(stateName, checkingStateName) then
		detail[3] = value
		if callback then
			callback(detail)
		end
		return true
	end
	return false
end

function Themes.modify(icon, modifications, modificationsUID)
	-- This is what the 'old set' used to do (although for clarity that behaviour has now been
	-- split into two methods, .modifyTheme and .apply).
	-- modifyTheme is responsible for UPDATING the internal values within a theme for a particular
	-- state, then checking to see if the appearance of the icon needs to be updated.
	-- If no iconState is specified, the change is applied to both Deselected and Selected
	-- A modification can also be 'undone' using :removeModification and passing in
	-- the UID returned from this method
	task.spawn(function()
		modificationsUID = modificationsUID or Utility.generateUID()
		modifications = Themes.getModifications(modifications)
		for _, modification in pairs(modifications) do
			local instanceName, property, value, iconState = table.unpack(modification)
			if iconState == nil then
				-- If no state specified, apply to all states
				Themes.modify(icon, {instanceName, property, value, "Selected"}, modificationsUID)
				Themes.modify(icon, {instanceName, property, value, "Viewing"}, modificationsUID)
			end
			local chosenState = Utility.formatStateName(iconState or "Deselected")
			local stateGroup = icon:getStateGroup(chosenState)
			local function nowSetIt()
				if chosenState == icon.activeState then
					Themes.apply(icon, instanceName, property, value)
				end
			end
			local function updateRecord()
				for stateName, detail in pairs(stateGroup) do
					local didMerge = Themes.merge(detail, modification, function(detail)
						detail[5] = modificationsUID
						nowSetIt()
					end)
					if didMerge then
						return
					end
				end
				local detail = {instanceName, property, value, chosenState, modificationsUID}
				table.insert(stateGroup, detail)
				nowSetIt()
			end
			updateRecord()
		end
	end)
	return modificationsUID
end

function Themes.remove(icon, modificationsUID)
	for iconState, stateGroup in pairs(icon.appearance) do
		for i = #stateGroup, 1, -1 do
			local detail = stateGroup[i]
			local checkingUID = detail[5]
			if checkingUID == modificationsUID then
				table.remove(stateGroup, i)
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.removeWith(icon, instanceName, property, state)
	for iconState, stateGroup in pairs(icon.appearance) do
		if state == iconState or not state then
			for i = #stateGroup, 1, -1 do
				local detail = stateGroup[i]
				local detailName = detail[1]
				local detailProperty = detail[2]
				if detailName == instanceName and detailProperty == property then
					table.remove(stateGroup, i)
				end
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.change(icon)
	-- This changes the theme to the appearance of whatever
	-- state is currently active
	local stateGroup = icon:getStateGroup()
	for _, detail in pairs(stateGroup) do
		local instanceName, property, value = unpack(detail)
		Themes.apply(icon, instanceName, property, value)
	end
end

function Themes.set(icon, theme)
	-- This is responsible for processing the final appearance of a given theme (such as
	-- ensuring Deselected merge into missing Selected, saving that internal state,
	-- then checking to see if the appearance of the icon needs to be updated
	local themesJanitor = icon.themesJanitor
	themesJanitor:clean()
	themesJanitor:add(icon.stateChanged:Connect(function()
		Themes.change(icon)
	end))
	if typeof(theme) == "Instance" and theme:IsA("ModuleScript") then
		theme = require(theme)
	end
	icon.appliedTheme = theme
	Themes.rebuild(icon)
end

function Themes.statesMatch(state1, state2)
	-- States match if they have the same name OR if nil (because unspecified represents all states)
	local state1lower = (state1 and string.lower(state1))
	local state2lower = (state2 and string.lower(state2))
	return state1lower == state2lower or not state1 or not state2
end

function Themes.rebuild(icon)
	-- A note for my future self: this code can be optimised further by
	-- converting appearance into a instanceName-property dictionary
	-- as apposed to an array of every potential change. When converting
	-- in the future, .modify and .apply would also have to be updated.
	local appliedTheme = icon.appliedTheme
	local statesArray = {"Deselected", "Selected", "Viewing"}
	local function generateTheme()
		for _, stateName in pairs(statesArray) do
			-- This applies themes in layers
			-- The last layers take higher priority as they overwrite
			-- any duplicate earlier applied effects
			local stateAppearance = {}
			local function updateDetails(theme, incomingStateName)
				-- This ensures there's always a base 'default' layer
				if not theme then
					return
				end
				for _, detail in pairs(theme) do
					local modificationsUID = detail[5]
					local detailStateName = detail[4]
					if Themes.statesMatch(incomingStateName, detailStateName) then
						local key = detail[1].."-"..detail[2]
						local newDetail = Utility.copyTable(detail)
						newDetail[5] = modificationsUID
						stateAppearance[key] = newDetail
					end
				end
			end
			-- First we apply the base theme (i.e. the Default module)
			if stateName == "Selected" then
				updateDetails(baseTheme, "Deselected")
			end
			updateDetails(baseTheme, "Empty")
			updateDetails(baseTheme, stateName)
			-- Next we apply any custom themes by the games developer
			if appliedTheme ~= baseTheme then
				if stateName == "Selected" then
					updateDetails(appliedTheme, "Deselected")
				end
				updateDetails(baseTheme, "Empty")
				updateDetails(appliedTheme, stateName)
			end
			-- Finally we apply any modifications that have already been made
			-- Modifiers are all the changes made using icon:modifyTheme(...)
			local alreadyAppliedTheme = {}
			local alreadyAppliedGroup = icon.appearance[stateName]
			if alreadyAppliedGroup then
				for _, modifier in pairs(alreadyAppliedGroup) do
					local modificationsUID = modifier[5]
					if modificationsUID ~= nil then
						local modification = {modifier[1], modifier[2], modifier[3], stateName, modificationsUID}
						table.insert(alreadyAppliedTheme, modification)
					end
				end
			end
			updateDetails(alreadyAppliedTheme, stateName)
			-- This now converts it into our final appearance
			local finalStateAppearance = {}
			for _, detail in pairs(stateAppearance) do
				table.insert(finalStateAppearance, detail)
			end
			icon.appearance[stateName] = finalStateAppearance
		end
		Themes.change(icon)
	end
	generateTheme()
end



return Themes]]></ProtectedString>
								<string name="ScriptGuid">{632F5BD5-C465-4406-B5A2-80785CF4F8E9}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Themes.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXA3DBABF82C7346A08382439A6395A879">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Themes</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX43B5B9FAA32A40D382FC6033BE7A39A7">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[-- This is to provide backwards compatability with the old Roblox
-- topbar while experiences transition over to the new topbar
-- You don't need to apply this yourself, topbarplus automatically
-- applies it if the old roblox topbar is detected


return {
	{"Selection", "Size", UDim2.new(1, -6, 1, -5)},
	{"Selection", "Position", UDim2.new(0, 3, 0, 3)},
	
	{"Widget", "MinimumWidth", 32, "Deselected"},
	{"Widget", "MinimumHeight", 32, "Deselected"},
	{"Widget", "BorderSize", 0, "Deselected"},
	{"IconCorners", "CornerRadius", UDim.new(0, 9), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.5, "Deselected"},
	{"IconLabel", "TextSize", 14, "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.5, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -3), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 15, 0, 15), "Deselected"},
	{"NoticeLabel", "TextSize", 11, "Deselected"},
	
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Selected"},
	{"IconSpot", "BackgroundTransparency", 0.702, "Selected"},
	{"IconSpotGradient", "Enabled", false, "Selected"},
	{"IconOverlay", "BackgroundTransparency", 0.97, "Selected"},
	
}]]></ProtectedString>
									<string name="ScriptGuid">{1E4AE9F0-D3C7-4338-B546-AF2C7165F6B3}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Classic.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX93DBA113EFC44C6388E89A6B76C4C3CB">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[-- Themes in v3 work simply by applying the value (agument[3])
-- to the property (agument[2]) of an instance within the icon which
-- matches the name of argument[1]. Argument[1] can also be used to
-- specify a collection of instances with a corresponding 'collective'
-- value. A colletive is simply an attribute applied to some instances
-- within the icon to group them together (such as "IconCorners").
-- If the property (argument[2]) does not exist within the instance,
-- it will instead be applied as an attribute on the instance:
-- (i.e. ``instance:SetAttribute(argument[2], [argument[3])``)
-- Use argument[4] to specify a state: "Deselected", "Selected"
-- or "Viewing". If argument[4] is empty the state will default
-- to "Deselected".
-- I've designed themes this way so you have full control over
-- the appearance of the widget and its descendants


return {
	
	-- When no state is specified the modification is applied to *all* states (Deselected, Selected and Viewing)
	{"IconCorners", "CornerRadius", UDim.new(1, 0)},
	{"Selection", "RotationSpeed", 1},
	{"Selection", "Size", UDim2.new(1, 0, 1, 1)},
	{"Selection", "Position", UDim2.new(0, 0, 0, 0)},
	{"SelectionGradient", "Color", ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(86, 86, 86)),
	})},
	
	-- When the icon is deselected
	{"IconImage", "Image", "", "Deselected"},
	{"IconLabel", "Text", "", "Deselected"},
	{"IconLabel", "Position", UDim2.fromOffset(0, 0), "Deselected"}, -- 0, -1
	{"Widget", "DesiredWidth", 44, "Deselected"},
	{"Widget", "MinimumWidth", 44, "Deselected"},
	{"Widget", "MinimumHeight", 44, "Deselected"},
	{"Widget", "BorderSize", 4, "Deselected"},
  	{"IconButton", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.08, "Deselected"},
	{"IconImageScale", "Value", 0.5, "Deselected"},
	{"IconImageCorner", "CornerRadius", UDim.new(0, 0), "Deselected"},
	{"IconImage", "ImageColor3", Color3.fromRGB(255, 255, 255), "Deselected"},
	{"IconImage", "ImageTransparency", 0, "Deselected"},
	{"IconImageRatio", "AspectRatio", 1, "Deselected"},
	{"IconLabel", "FontFace", Font.new("rbxasset://fonts/families/BuilderSans.json", Enum.FontWeight.Bold, Enum.FontStyle.Normal), "Deselected"},
	{"IconLabel", "TextSize", 16, "Deselected"},
	{"IconSpot", "BackgroundTransparency", 1, "Deselected"},
	{"IconOverlay", "BackgroundTransparency", 0.85, "Deselected"},
	{"IconSpotGradient", "Enabled", false, "Deselected"},
	{"IconGradient", "Enabled", false, "Deselected"},
	{"ClickRegion", "Active", true, "Deselected"},  -- This is set to false within scrollers to ensure scroller can be dragged on mobile
	{"Menu", "Active", false, "Deselected"},
	{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Center, "Deselected"},
  	{"Dropdown", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.08, "Deselected"},
	{"Dropdown", "MaxIcons", 4.5, "Deselected"},
	{"Menu", "MaxIcons", 4, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -1), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 20, 0, 20), "Deselected"},
	{"NoticeLabel", "TextSize", 13, "Deselected"},
	{"PaddingLeft", "Size", UDim2.new(0, 9, 1, 0), "Deselected"},
	{"PaddingRight", "Size", UDim2.new(0, 11, 1, 0), "Deselected"},
	
	-- When the icon is selected
	-- Selected also inherits everything from Deselected if nothing is set
	{"IconSpot", "BackgroundTransparency", 0.7, "Selected"},
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(255, 255, 255), "Selected"},
	{"IconSpotGradient", "Enabled", true, "Selected"},
	{"IconSpotGradient", "Rotation", 45, "Selected"},
	{"IconSpotGradient", "Color", ColorSequence.new(Color3.fromRGB(96, 98, 100), Color3.fromRGB(77, 78, 80)), "Selected"},
	
	
	-- When a cursor is hovering above, a controller highlighting, or touchpad (mobile) pressing (but not released)
	--{"IconSpot", "BackgroundTransparency", 0.75, "Viewing"},
	
}]]></ProtectedString>
									<string name="ScriptGuid">{8B19A5EF-8683-4227-AEB3-647FE1E858B1}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Default.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX7F85AA51A591486F9E78365495E3AEFB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Packages</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX129438F629FC437BB863DB71FE12FF81">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread()
	-- Note: We cannot use the initial set of arguments passed to
	-- runEventHandlerInFreeThread for a call to the handler, because those
	-- arguments would stay on the stack for the duration of the thread's
	-- existence, temporarily leaking references. Without access to raw bytecode
	-- there's no way for us to clear the "..." references from the stack.
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end
Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		_handlerListHead = false,
	}, Signal)
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false
end
Signal.Destroy = Signal.DisconnectAll

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
				-- Get the freeRunnerThread to the first yield
				coroutine.resume(freeRunnerThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

-- Implement Signal:Once() in terms of a connection which disconnects
-- itself before running the handler.
function Signal:Once(fn)
	local cn;
	cn = self:Connect(function(...)
		if cn._connected then
			cn:Disconnect()
		end
		fn(...)
	end)
	return cn
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

return Signal]]></ProtectedString>
								<string name="ScriptGuid">{EA20E9D7-E4E4-44C4-8403-66E2C7F2EBAA}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">GoodSignal.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA4254D3C26484470B01D10919DCEAF91">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[[
-------------------------------------
This package was modified by ForeverHD.

PACKAGE MODIFICATIONS:
	1. Added pascalCase aliases for all methods
	2. Modified behaviour of :add so that it takes both objects and promises (previously only objects)
	3. Slight change to how promises are tracked
	4. Added isAnInstanceBeingDestroyed check to line 228
	5. Added 'OriginalTraceback' to help determine where an error was added to the janitor
	6. Likely some additional changes which weren't record here
	7. Removed comments as these were detected by Moonwave
-------------------------------------
--]]



-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local function getPromiseReference()
	return false
end

local IndicesReference = newproxy(true)
getmetatable(IndicesReference).__tostring = function()
	return "IndicesReference"
end

local LinkToInstanceIndex = newproxy(true)
getmetatable(LinkToInstanceIndex).__tostring = function()
	return "LinkToInstanceIndex"
end

local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

local Janitor = {
	IGNORE_MEMORY_DEBUG = true,
	ClassName = "Janitor";
	__index = {
		CurrentlyCleaning = true;
		[IndicesReference] = nil;
	};
}

local TypeDefaults = {
	["function"] = true;
	["Promise"] = "cancel";
	RBXScriptConnection = "Disconnect";
}

function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

Janitor.is = Janitor.Is

function Janitor.__index:Add(Object, MethodName, Index)
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	local objectType = typeof(Object)
	if objectType == "table" and string.match(tostring(Object), "Promise") then
		objectType = "Promise"
		--local status = Object:getStatus()
		--print("status =", status, status == "Rejected")
	end
	MethodName = MethodName or TypeDefaults[objectType] or "Destroy"
	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil :: any, 2)))
	end

	local OriginalTraceback = debug.traceback("")
	self[Object] = {MethodName, OriginalTraceback}
	return Object
end
Janitor.__index.Give = Janitor.__index.Add

-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

function Janitor.__index:AddPromise(PromiseObject)
	local Promise = getPromiseReference()
	if Promise then
		if not Promise.is(PromiseObject) then
			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
		end
		if PromiseObject:getStatus() == Promise.Status.Started then
			local Id = newproxy(false)
			local NewPromise = self:Add(Promise.new(function(Resolve, _, OnCancel)
				if OnCancel(function()
						PromiseObject:cancel()
					end) then
					return
				end

				Resolve(PromiseObject)
			end), "cancel", Id)

			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise
		else
			return PromiseObject
		end
	else
		return PromiseObject
	end
end
Janitor.__index.GivePromise = Janitor.__index.AddPromise

-- This will assume whether or not the object is a Promise or a regular object.
function Janitor.__index:AddObject(Object)
	local Id = newproxy(false)
	local Promise = getPromiseReference()
	if Promise and Promise.is(Object) then
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	else
		return self:Add(Object, false, Id), Id
	end
end

Janitor.__index.GiveObject = Janitor.__index.AddObject

function Janitor.__index:Remove(Index)
	local This = self[IndicesReference]
	if This then
		local Object = This[Index]

		if Object then
			local ObjectDetail = self[Object]
			local MethodName = ObjectDetail and ObjectDetail[1]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

function Janitor.__index:Get(Index)
	local This = self[IndicesReference]
	if This then
		return This[Index]
	end
	return nil
end

function Janitor.__index:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil
		for Object, ObjectDetail in next, self do
			if Object == IndicesReference then
				continue
			end

			-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
			local TypeOf = type(Object)
			if TypeOf == "string" or TypeOf == "number" then
				self[Object] = nil
				continue
			end

			local MethodName = ObjectDetail[1]
			local OriginalTraceback = ObjectDetail[2]
			local function warnUser(warning)
				local cleanupLine = debug.traceback("", 3)--string.gsub(debug.traceback("", 3), "%c", "")
				local addedLine = OriginalTraceback
				warn("-------- Janitor Error --------".."\n"..tostring(warning).."\n"..cleanupLine..""..addedLine)
			end
			if MethodName == true then
				local success, warning = pcall(Object)
				if not success then
					warnUser(warning)
				end
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					local success, warning = pcall(ObjectMethod, Object)
					local isAnInstanceBeingDestroyed = typeof(Object) == "Instance" and ObjectMethod == "Destroy"
					if not success and not isAnInstanceBeingDestroyed then
						warnUser(warning)
					end
				end
			end

			self[Object] = nil
		end

		local This = self[IndicesReference]
		if This then
			for Index in next, This do
				This[Index] = nil
			end

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

Janitor.__index.Clean = Janitor.__index.Cleanup

function Janitor.__index:Destroy()
	self:Cleanup()
	--table.clear(self)
	--setmetatable(self, nil)
end

Janitor.__call = Janitor.__index.Cleanup

local Disconnect = {Connected = true}
Disconnect.__index = Disconnect
function Disconnect:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function Disconnect:__tostring()
	return "Disconnect<" .. tostring(self.Connected) .. ">"
end

function Janitor.__index:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, Disconnect)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				coroutine.wrap(function()
					Heartbeat:Wait()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							Heartbeat:Wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)()
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

function Janitor.__index:LinkToInstances(...)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

for FunctionName, Function in next, Janitor.__index do
	local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
	Janitor.__index[NewFunctionName] = Function
end

return Janitor]]></ProtectedString>
								<string name="ScriptGuid">{4107FA92-EFF5-43D4-95BF-BB863AAD63FF}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Janitor.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX66F95CE1254D4768BA50EC44AFA07462">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Design</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX627B32F93AD44726BE547AD0C2F99700">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--[[ 🎨 THEME MANAGER COMMANDS (Studio Console)
======================================================
📦 MODULE PATH
local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)
ThemeManager.applyTheme("Standard")

------------------------------------------------------
Apply existing theme (Studio)
------------------------------------------------------
-- Standard
local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)
ThemeManager.applyTheme("Standard")

-- Halloween
local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)
ThemeManager.applyTheme("Halloween")

------------------------------------------------------
Capture current configuration  (Studio only)
------------------------------------------------------
local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)
local current = ThemeManager.captureInStudio()
print(current)

]]


local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local ThemeManager = {}

local currentTheme = "Standard"

---------------------------------------------------------
-- THEMES
---------------------------------------------------------
ThemeManager.Themes = {
	Halloween = {
		cages = {
			PaddingCorner = { Color = "#E85D04" },
			FenceDoor = { Color = "#14213D" },
			UIGradient = {
				Colors = {
					{ Time = 0, Color = "#8B0000" },
					{ Time = 1, Color = "#FF7518" }
				}
			},
			LogoDecalId = "rbxassetid://137441062081064",
			PaddingFence = { Color = "#370617" },
			PaddingFenceDoor = { Color = "#9D0208" },
			FenceFrame = { Color = "#000000" },
			CornerTrim = { Color = "#FCA311" },
			PlayerSpawnGlowColor = { Color = "#e85d04"}
		},
		lights = {
			Neon_LED_Roof_Beam_Color = "#9933FF",
			Neon_LED_Roof_Color = "#FF6600",
			BaseFloor_LED_Color = "#FF6600"
		},
		atmosphere = {
			Density = 0.5,
			Color = "#FF0000",
			Decay = "#0000FF",
			Glare = 0.1,
			Haze = 0.5
		},
		menus = {
			Header_Color = "#340859",
			Header_Font_Color = "#FE7919",
			Highlight_Font_Color = "#FE7919",
			UIStroke_Color = "#FE7919",
			CallToAction_Color  = "#FE7919",
			CallToAction_Over_Color  = "#FE7919",
			CallToAction_Disabled_Color = "#382109",
			Text_Main_Color ="#FE7919",
			Selection_Color = "#FFFFFF"
		},
		room = {
			Floor_Material = {
				Color = "#cacbd1",
				MaterialVariant = "FloorHalloween",
				BaseMaterial = "Plastic"
			},
			Leaderboard_Floor_Material ={
				Color = "#cacbd1",
				MaterialVariant = "FloorHalloween",
				BaseMaterial = "Plastic"
			},
			Stairs_Material = {
				Color = "#cacbd1",
				MaterialVariant = "FloorHalloween",
				BaseMaterial = "Plastic"
			}, 
			PunchingBag_Texture = "rbxassetid://73607057486777"
		},
		shop = {
			Shop_Color_Start = "#6B0FCF",
			Shop_Color_End = "#FE7919"
		},
		splashscreens = {
			"rbxassetid://110276208829998",
			"rbxassetid://128056827804876",
			"rbxassetid://123256769506474",
			"rbxassetid://90729050354125",
			"rbxassetid://126480358779298"
		}
	},

	Standard = {
		cages = {
			PaddingCorner = { Color = "#4CE573" },
			FenceDoor = { Color = "#4C4B4D" },
			UIGradient = {
				Colors = {
					{ Time = 0, Color = "#23F444" },
					{ Time = 1, Color = "#FFFFFF" }
				}
			},
			LogoDecalId = "rbxassetid://98568379999069",
			PaddingFence = { Color = "#3B3D46" },
			PaddingFenceDoor = { Color = "#3B3D46" },
			FenceFrame = { Color = "#4C4B4D" },
			CornerTrim = { Color = "#3B3D46" },
			PlayerSpawnGlowColor = { Color = "#00ff00"}
		},
		lights = {
			Neon_LED_Roof_Beam_Color = "#65b554",
			Neon_LED_Roof_Color = "#87f474",
			BaseFloor_LED_Color = "#87f474"
		},
		atmosphere = {
			Density = 0.3,
			Color = "#60fa6d",
			Decay = "#a0c9e2",
			Glare = 0.8,
			Haze = 2.11
		},
		menus = {
			Header_Color = "#23F444",
			Header_Font_Color = "#000000",
			Highlight_Font_Color = "#23F444",
			UIStroke_Color = "#23f444",
			CallToAction_Color = "#23f444",
			CallToAction_Over_Color  = "#006200",
			CallToAction_Disabled_Color = "#09380E",
			Text_Main_Color ="#23F444",
			Selection_Color = "#FFFFFF"
		},
		room = {
			Floor_Material = {
				BaseMaterial = "Concrete",
				Color = "#474544",
				MaterialVariant = "Concrete_Tiles"
			},
			Leaderboard_Floor_Material ={
				BaseMaterial = "Metal",
				Color = "#2F2F2F",
				MaterialVariant = "MetalPanels"
			},
			Stairs_Material = {
				BaseMaterial = "WoodPlanks",
				Color = "#3F3C39",
				MaterialVariant = "WoodPlanks"
			}, 
			PunchingBag_Texture = "rbxassetid://70954748798604"
		},
		shop = {
			Shop_Color_Start = "#6B0FCF",
			Shop_Color_End = "#00ffff"
		},
		splashscreens = {
			"rbxassetid://133655844729939", -- Jon Jones
			"rbxassetid://77228773105758",  -- Khabib vs McGregor
			"rbxassetid://82383919298361",  -- Roblox fights
			"rbxassetid://127946909806988" -- Roblox kick
		}
	}
}

---------------------------------------------------------
-- INTERNAL HELPERS
---------------------------------------------------------
local function rgbToHex(color3)
	local r = math.floor(color3.R * 255)
	local g = math.floor(color3.G * 255)
	local b = math.floor(color3.B * 255)
	return string.format("#%02X%02X%02X", r, g, b)
end

local function hexToColor3(hex)
	hex = hex:gsub("#", "")
	local r = tonumber(hex:sub(1, 2), 16)
	local g = tonumber(hex:sub(3, 4), 16)
	local b = tonumber(hex:sub(5, 6), 16)
	return Color3.fromRGB(r, g, b)
end

local function colorSequenceToTable(sequence)
	local t = {}
	for _, keypoint in ipairs(sequence.Keypoints) do
		table.insert(t, {
			Time = keypoint.Time,
			Color = rgbToHex(keypoint.Value)
		})
	end
	return t
end

local function tableToColorSequence(tbl)
	local keypoints = {}
	for _, v in ipairs(tbl) do
		table.insert(keypoints, ColorSequenceKeypoint.new(v.Time, hexToColor3(v.Color)))
	end
	return ColorSequence.new(keypoints)
end

local function findUIGradient(fighter)
	local mainP = fighter:FindFirstChild("Main_P")
	if not mainP then return nil end
	local playerDisplay = mainP:FindFirstChild("Player_Display_UI")
	if not playerDisplay then return nil end
	local emptyTxt = playerDisplay:FindFirstChild("Empty_Txt", true)
	if not emptyTxt then return nil end
	return emptyTxt:FindFirstChildOfClass("UIGradient")
end

local function getFightCagesFolder()
	return workspace.Main_World_F.Gameplay.Objects.Fight_Cages_F
end

local function getFighterGradient()
	local FightCagesFolder = getFightCagesFolder()
	local fighter =FightCagesFolder.Fight_Handle_M:FindFirstChild("Fighter_1")
	if not fighter then return nil end
	local gradient = fighter
		.Main_P
		.Player_Display_UI
		.Empty_Txt
		.UIGradient
	return gradient
end

local function Get_First_Child_Material(folder)
	local first_child = folder:GetChildren()[1]
	if(first_child)then
		return {
			BaseMaterial = first_child.Material.Name,
			MaterialVariant = first_child.MaterialVariant, 
			Color = rgbToHex(first_child.Color)
		}
	end
end

local function Apply_Material_To_Children(folder, mat)
	for _, obj in ipairs(folder:GetChildren()) do
		obj.Material = Enum.Material[mat.BaseMaterial]
		obj.MaterialVariant = mat.MaterialVariant
		obj.Color = hexToColor3(mat.Color)
	end
end

---------------------------------------------------------
-- GET ATTRIBUTE VALUE FROM THEME
---------------------------------------------------------
function ThemeManager.getAttributeFromTheme(themeName, path)
	local theme = ThemeManager.Themes[themeName]
	if not theme then
		warn("[ThemeManager] Unknown theme: " .. tostring(themeName))
		return nil
	end
	if not path or path == "" then
		return theme
	end

	local current = theme
	for key in string.gmatch(path, "[^%.]+") do
		if type(current) == "table" then
			current = current[key]
		else
			warn("[ThemeManager] Invalid path segment: " .. key)
			return nil
		end
	end
	return current
end

function ThemeManager.getAttribute(path)
	return ThemeManager.getAttributeFromTheme(ThemeManager.getCurrentTheme(), path)
end

function ThemeManager.getColorAttribute(path)
	local colorHex = ThemeManager.getAttribute(path)
	if not colorHex then return Color3.new(1,1,1)
	else
		return hexToColor3(colorHex)
	end
end

---------------------------------------------------------
-- APPLY THEME HELPERS
---------------------------------------------------------
local function handleThemeAssets(themeName)
	local replicatedThemes = game.ReplicatedStorage.Design.Themes
	local artThemes = workspace.Main_World_F.Environment.Art:FindFirstChild("Themes")

	if not artThemes then
		artThemes = Instance.new("Folder")
		artThemes.Name = "Themes"
		artThemes.Parent = workspace.Main_World_F.Environment.Art
	end

	if themeName == "Standard" then
		for _, folder in ipairs(artThemes:GetChildren()) do
			if folder:IsA("Folder") then
				folder.Parent = replicatedThemes
				print("[ThemeManager] Restored theme folder to ReplicatedStorage:", folder.Name)
			end
		end
	else
		local themeFolder = replicatedThemes:FindFirstChild(themeName)
		if themeFolder then
			themeFolder.Parent = artThemes
			print("[ThemeManager] Moved theme folder to Workspace:", themeName)
		else
			warn("[ThemeManager] No folder found in ReplicatedStorage for theme:", themeName)
		end
	end
end


local function applyCages(cageConfig)
	local FightCagesFolder = workspace.Main_World_F.Gameplay.Objects.Fight_Cages_F
	if not FightCagesFolder then return end

	for _, cage in ipairs(FightCagesFolder:GetChildren()) do
		if cage:GetAttribute("Cage_Type") ~= "RANKED" then
			local mmaCage = cage:FindFirstChild("MMA_Cage")
			if not mmaCage then continue end

			for partName, settings in pairs(cageConfig) do
				local part = mmaCage:FindFirstChild(partName, true)
				if part and part:IsA("BasePart") then
					if settings.Color then
						part.Color = hexToColor3(settings.Color)
					end
					if settings.TextureId then
						local surface = part:FindFirstChildOfClass("Texture") or Instance.new("Texture")
						surface.Texture = settings.TextureId
						surface.Parent = part
					end
				end
			end

			if cageConfig.LogoDecalId then
				local logo = mmaCage:FindFirstChild("Logo")
				if logo then
					local decal = logo:FindFirstChildOfClass("Decal")
					if decal then
						decal.Texture = cageConfig.LogoDecalId
					end
				end
			end
		end
	end

	-- UIGradient
	if cageConfig.UIGradient and cageConfig.UIGradient.Colors then
		local colorSeq = tableToColorSequence(cageConfig.UIGradient.Colors)
		for _, handle in ipairs(FightCagesFolder:GetChildren()) do
			if handle:IsA("Model") and string.match(handle.Name, "^Fight_Cage_%d+$")  then
				for _, fighterName in ipairs({ "Fighter_1", "Fighter_2" }) do
					local fighter = handle:FindFirstChild(fighterName)
					if fighter then
						local gradient = findUIGradient(fighter)
						if gradient then
							gradient.Color = colorSeq
						end
					end
				end
			end
		end
	end
end


local function applyLights(lightsConfig)
	if not lightsConfig then return end

	if lightsConfig.Neon_LED_Roof_Color or lightsConfig.Neon_LED_Roof_Beam_Color then
		for _, obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("BasePart") and obj.Name:match("^Neon") then
				if lightsConfig.Neon_LED_Roof_Color then
					obj.Color = hexToColor3(lightsConfig.Neon_LED_Roof_Color)
				end
				local beam = obj:FindFirstChildOfClass("Beam")
				if beam and lightsConfig.Neon_LED_Roof_Beam_Color then
					local col = hexToColor3(lightsConfig.Neon_LED_Roof_Beam_Color)
					beam.Color = ColorSequence.new(col)
				end
			end
		end
	end

	if lightsConfig.BaseFloor_LED_Color then
		local baseColor = hexToColor3(lightsConfig.BaseFloor_LED_Color)
		local trimsFolder = workspace.Main_World_F.Environment.Art.Lights:FindFirstChild("CageFloorTrims")
		if trimsFolder then
			for _, cageTrim in ipairs(trimsFolder:GetChildren()) do
				local baseLED = cageTrim:FindFirstChild("BaseFloor_LED")
				if baseLED and baseLED:IsA("BasePart") then
					baseLED.Color = baseColor
				end
			end
		end
	end
end


local function applyAtmosphere(atmo)
	if not atmo then return end
	local a = game.Lighting.Atmosphere_Day
	if not a then return end
	if atmo.Density then a.Density = atmo.Density end
	if atmo.Color then a.Color = hexToColor3(atmo.Color) end
	if atmo.Decay then a.Decay = hexToColor3(atmo.Decay) end
	if atmo.Glare then a.Glare = atmo.Glare end
	if atmo.Haze then a.Haze = atmo.Haze end
end


local function applyRoom(roomConfig)
	local art = workspace.Main_World_F.Environment.Art.Structure
	if roomConfig.Floor_Material then Apply_Material_To_Children(art.Floor_Main, roomConfig.Floor_Material) end
	if roomConfig.Leaderboard_Floor_Material then Apply_Material_To_Children(art.Floor_Leaderboard, roomConfig.Leaderboard_Floor_Material) end
	if roomConfig.Stairs_Material then Apply_Material_To_Children(art.Stairs_Spawn, roomConfig.Stairs_Material) end

	local Gym_Objects = workspace.Main_World_F.Gameplay.Objects.GymObjects.PunchingBags:GetChildren()
	for _, obj in ipairs(Gym_Objects) do
		if obj.Name == "PunchingBag" then
			local bag = obj:FindFirstChild("PunchingBag")
			if bag and roomConfig.PunchingBag_Texture then
				bag.TextureID = roomConfig.PunchingBag_Texture
			end
		end
	end
end


local function applyShopAttributes(shopConfig)
	if shopConfig.Shop_Color_Start then
		script:SetAttribute("Shop_Color_Start", hexToColor3(shopConfig.Shop_Color_Start))
	end
	if shopConfig.Shop_Color_End then
		script:SetAttribute("Shop_Color_End", hexToColor3(shopConfig.Shop_Color_End))
	end
end


local function applyUI_AllRoots(menusConfig)
	
	local CollectionService = game:GetService("CollectionService")
	local root = game.StarterGui

	if menusConfig.Text_Main_Color then
		local Text_Main_Color = hexToColor3(menusConfig.Text_Main_Color)
		game.Workspace.Main_World_F.Environment.Spawns.TeleportSign_ToHome.SurfaceGui.TextLabel.TextColor3 = Text_Main_Color
		game.Workspace.Main_World_F.Environment.Spawns.TeleportSign_ToRank.SurfaceGui.TextLabel.TextColor3 = Text_Main_Color
	end


	if menusConfig.Header_Color then
		local Header_Color = hexToColor3(menusConfig.Header_Color)
		for _, header in ipairs(CollectionService:GetTagged("Header_Background")) do
			if header:IsDescendantOf(root) and (header:IsA("ImageLabel") or header:IsA("ImageButton")) then
				header.ImageColor3 = Header_Color
			end
		end
	end
	
	if menusConfig.Header_Font_Color then
		for _, header in ipairs(CollectionService:GetTagged("Header_Title")) do
			if header:IsDescendantOf(root) then
				if header:IsA("TextLabel") then
					header.TextColor3 = hexToColor3(menusConfig.Header_Font_Color)
				end
			end
		end
	end
	
	if menusConfig.Highlight_Font_Color then
		for _, txt in ipairs(CollectionService:GetTagged("Highlight_Text")) do
			if txt:IsDescendantOf(root) then
				if txt:IsA("TextLabel") then
					txt.TextColor3 = hexToColor3(menusConfig.Highlight_Font_Color)
				end
			end
		end
	end

	if menusConfig.UIStroke_Color then
		for _, header in ipairs(CollectionService:GetTagged("UIStroke_Theme")) do
			if header:IsDescendantOf(root) then
				if header:IsA("UIStroke") then
					header.Color = hexToColor3(menusConfig.UIStroke_Color)
				end
			end
		end
	end


	-- local outline_white = "rbxassetid://83762309767724"
	if menusConfig.UIStroke_Color then
		for _, outline in ipairs(CollectionService:GetTagged("Outline_Image")) do
			if outline:IsDescendantOf(root) then
				if outline:IsA("ImageLabel") then
					outline.ImageColor3 = hexToColor3(menusConfig.UIStroke_Color)
				end
			end
		end
	end

	if menusConfig.CallToAction_Color then
		for _, cta in ipairs(CollectionService:GetTagged("CTA_Button")) do
			if cta:IsDescendantOf(root) then
				cta.BackgroundColor3 = hexToColor3(menusConfig.CallToAction_Color)
			end
		end 
	end
end

local function handleSpecialAssets(themeName)
	if (themeName == 'Halloween') then
		game.StarterGui.Menus.HUD.CurrencyIndicators.HalloweenShop.Visible = true
	else
		game.StarterGui.Menus.HUD.CurrencyIndicators.HalloweenShop.Visible = false
	end
end
---------------------------------------------------------
-- MAIN APPLY FUNCTION
---------------------------------------------------------
function ThemeManager.applyTheme(themeName)
	local theme = ThemeManager.Themes[themeName]
	assert(theme, "Unknown theme: " .. tostring(themeName))

	-- 1. Handle asset folders
	handleThemeAssets(themeName)

	-- 2. Apply configuration groups
	if theme.cages then applyCages(theme.cages) end
	if theme.lights then applyLights(theme.lights) end
	if theme.atmosphere then applyAtmosphere(theme.atmosphere) end
	if theme.room then applyRoom(theme.room) end
	if theme.shop then applyShopAttributes(theme.shop) end
	if theme.menus then applyUI_AllRoots(theme.menus) end

	handleSpecialAssets(themeName)
	print("[ThemeManager] Applied theme:", themeName)
end

---------------------------------------------------------
-- API
---------------------------------------------------------
function ThemeManager.getCurrentTheme()
	return currentTheme
end

return ThemeManager
]]></ProtectedString>
						<string name="ScriptGuid">{AD338602-1C7A-45C9-815E-1DD4DB9F48A8}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ThemeManager.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX51D7F2E666614480B319E99D47B7C727">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- 🔒 LockManager.lua
-- Gestion centralisée du verrouillage / déverrouillage des objets d'un Workspace
-- Auteur : toi 😎
-- Compatible avec dossiers tagués ("Locked") ou avec attribut Locked = true

--[[
local LockManager = require(game.ReplicatedStorage.Design.LockManager)
LockManager.lock(workspace.Main_World_F)

LockManager.unlock(workspace.Main_World_F)
]]

local CollectionService = game:GetService("CollectionService")

local LockManager = {}

---------------------------------------------------------------------
-- 🔍 UTILITAIRES
---------------------------------------------------------------------

-- Renvoie le chemin complet d'un objet
local function getFullNameSafe(obj)
	local success, result = pcall(function() return obj:GetFullName() end)
	return success and result or "(unknown)"
end

-- Verrouille / déverrouille tous les BasePart descendants d’un dossier donné
local function setLockState(folder, state)
	for _, descendant in ipairs(folder:GetDescendants()) do
		if descendant:IsA("BasePart") then
			descendant.Locked = state
		end
	end
end

-- Vérifie si un dossier est marqué Locked (via tag ou attribut)
local function isLockedFolder(folder)
	if CollectionService:HasTag(folder, "Locked") then
		return true
	end
	if folder:GetAttribute("Locked") == true then
		return true
	end
	return false
end

---------------------------------------------------------------------
-- 🔒 LOCK
---------------------------------------------------------------------

function LockManager.lock(root)
	if not root then
		warn("⚠️ No root element provided to LockManager.lock()")
		return
	end

	local lockedFolders = {}
	for _, descendant in ipairs(root:GetDescendants()) do
		if descendant:IsA("Folder") and isLockedFolder(descendant) then
			table.insert(lockedFolders, descendant)
		end
	end

	for _, folder in ipairs(lockedFolders) do
		setLockState(folder, true)
		print("🔒 Locked :", getFullNameSafe(folder))
	end

	print("✅ LockManager : " .. tostring(#lockedFolders) .. " folder(s) locked.")
end

---------------------------------------------------------------------
-- 🔓 UNLOCK
---------------------------------------------------------------------

function LockManager.unlock(root)
	if not root then
		warn("⚠️ No root element provided to LockManager.unlock()")
		return
	end

	local unlockedFolders = {}
	for _, descendant in ipairs(root:GetDescendants()) do
		if descendant:IsA("Folder") and isLockedFolder(descendant) then
			table.insert(unlockedFolders, descendant)
		end
	end

	for _, folder in ipairs(unlockedFolders) do
		setLockState(folder, false)
		print("🔓 Unlocked :", getFullNameSafe(folder))
	end

	print("✅ LockManager : " .. tostring(#unlockedFolders) .. "  folder(s) unlocked.")
end

---------------------------------------------------------------------
-- ✅ EXPORT
---------------------------------------------------------------------
return LockManager
]]></ProtectedString>
						<string name="ScriptGuid">{62B962A5-1D9B-45D5-8B34-3793C58BF9DC}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">LockManager.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9E8FBB4AC97F469180E1FEB8A829DBDC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Design/MenuButtons.lua
--
--  Description:
--      Utility module providing standardized interactive button behaviors
--      for UI elements:
--          • Hover animations
--          • Click animations
--          • Color transitions
--          • Tab activation logic
--          • Custom callbacks
--
--      Designed to give consistent UX across all menus and panels.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-02-10 by Darkzeb
--
--  Version: V2025-02
--
--  Dependencies:
--      - Roblox Services:
--          * TweenService
--
--      - Modules:
--          * Sound_Mod (UI sound effects)
--          * ThemeManager (UI theme colors)
--
--  Used By:
--      - All UI screens using interactive buttons
--      - Menus with tabs, exit buttons, and stylized hover/click effects
--
--  Notes:
--      - Setup_Button is the core helper used by all exposed functions.
--      - Tween scaling uses configurable ratios for click & hover.
--      - Supports arbitrary button shapes and independently scaled axes.
--      - Debounce system prevents spam interactions.
--
--======================================================================


local MenuButtons = {}

----- DEPENDENCIES -----
--// Services
local TS = game:GetService("TweenService")
--// Required Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local ThemeManager = require(game.ReplicatedStorage:WaitForChild("Design"):WaitForChild("ThemeManager"))

----- REFERENCES -----
--// Player and Character
local Plr = game.Players.LocalPlayer

----- VARIABLES -----
local Tween_Length = 0.125
local Debounce_length = 0.25
local Click_Size_Ratio = 0.9
local Over_Size_Ratio = 1.1
local Over_Bg_Color = ThemeManager.getColorAttribute("menus.CallToAction_Over_Color")
local Reverse_Tween = TweenInfo.new(Tween_Length, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

local function Get_Scale_Size(Normal, Ratio, X_Scale, Y_Scale)
	local X_Scaled_Size = X_Scale and Normal.X.Scale * Ratio or Normal.X.Scale
	local Y_Scaled_Size = Y_Scale and Normal.Y.Scale * Ratio or Normal.Y.Scale
	return UDim2.new(X_Scaled_Size, 0, Y_Scaled_Size, 0)	
end


local function Setup_Button(Cons, B, Selected, X_Scale, Y_Scale, Over_Color, Exit_Callback)	
	local Normal_Size = B.Size
	local Normal_Bg_Color = B.BackgroundColor3
	
	local Over_Size = Get_Scale_Size(Normal_Size, Over_Size_Ratio, X_Scale, Y_Scale) 
	local Click_Size = Get_Scale_Size(Normal_Size, Click_Size_Ratio, X_Scale, Y_Scale) 
	local Debounce_E = false
	local Debounce = false

	table.insert(Cons, Selected.MouseEnter:Connect(function()
		if(Debounce_E == false)then
			Debounce_E = true
			SE_Mod.PlaySFX(Plr, "Hover_SE")
			B:TweenSize(Over_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, Tween_Length, true, nil)
			B.BackgroundColor3 = Over_Color ~=nil and Over_Color or Over_Bg_Color
			Debounce_E = false
		end
	end))
	
	
	table.insert(Cons, Selected.MouseLeave:Connect(function()
		B:TweenSize(Normal_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, Tween_Length, true, nil)
		B.BackgroundColor3 = Normal_Bg_Color
	end))
	
	
	table.insert(Cons, Selected.MouseButton1Click:Connect(function()
		if(Debounce == false)then
			Debounce = true
			SE_Mod.PlaySFX(Plr, "Click_SE")
			TS:Create(B, Reverse_Tween, {Size = Click_Size}):Play()
			
			Exit_Callback()
			
			task.wait(Debounce_length)
			Debounce = false
			B.Size = Normal_Size
		end
	end))
end

local function Activate_Tab(Tab_B_Name, Tabs_Container_F, Tabs_Data, Before_Show_Function)
	
	if Before_Show_Function ~= nil then Before_Show_Function() end
	
	for Tab_Name, Tab_Data in pairs(Tabs_Data) do 
		local Tab_Panel_F = Tab_Data["Frame"]
		local Tab_Show_Function = Tab_Data["Show_Function"]
		local Tab_B = Tabs_Container_F:FindFirstChild(Tab_Name)
		
		if Tab_Name == Tab_B_Name then
			Tab_B.BackgroundTransparency = 0
			Tab_Panel_F.Visible = true
			if Tab_Show_Function ~= nil then Tab_Show_Function() end
		else
			Tab_B.BackgroundTransparency = 1
			Tab_Panel_F.Visible = false
		end	
	end
end

function MenuButtons.Setup_Exit_X_Button(Cons, B, Exit_Callback)
	Setup_Button(Cons, B, B, false, true, nil, Exit_Callback)
end

function MenuButtons.Activate_Tab(Tab_B_Name, Tabs_Container_F, Tabs_Data, Before_Show_Function)
	Activate_Tab(Tab_B_Name, Tabs_Container_F, Tabs_Data, Before_Show_Function)
end

function MenuButtons.Setup_Tab_Button(Cons, Tab_B, Tabs_Container_F, Tabs_Data, Before_Show_Function)
	Setup_Button(Cons, Tab_B, Tab_B, true, true, nil, function()
		MenuButtons.Activate_Tab(Tab_B.Name, Tabs_Container_F, Tabs_Data, Before_Show_Function)
	end)
end

function MenuButtons.Setup_Colored_Button(Cons, B, Over_Color, Callback, Selected)
	if Selected == nil then Selected = B end
	Setup_Button(Cons, B, Selected, true, true, Over_Color, Callback)
end

-- Selected is optional if Button container and Buttton sleection frame are different
function MenuButtons.Setup_Base_Button(Cons, B, Callback, Selected)
	if Selected == nil then Selected = B end
	Setup_Button(Cons, B, Selected, true, true, nil, Callback)
end

return MenuButtons
]]></ProtectedString>
						<string name="ScriptGuid">{B4F03557-0ECC-417F-84C0-03B85800D940}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">MenuButtons.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX38830830B89142668E3756AB39402E76">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Models</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXB05CE6F148284EA18E7FB5AE3D2F3143">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GymEventAssets</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXCA8C377392184912B5E70065FE038B25">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Highlight</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX2669957E8EF14B3F80BB22A12F25FA12">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local RS 					= game:GetService("ReplicatedStorage")
local Channels 				= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local Gym_Reward_Update 	= Channels.Bindable_Events.Gym_Reward_Update

local Count_Down_L = script.Parent:FindFirstChild("Countdown_L", true)

Gym_Reward_Update.Event:Connect(function(i)
	if i>0 then
		Count_Down_L.Visible = true
		Count_Down_L.Text = i .. "s"
	else
		Count_Down_L.Visible = false
	end
end)
]]></ProtectedString>
								<string name="ScriptGuid">{F987E6C4-F68C-41B9-A5C3-B64D7353601D}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Highlight_Handle.server.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX1419E8E104254448BAE15A9FE3C7C500">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Base</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX442DE08C6F4A476C9EC3CECF1A3FA339">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
									<string name="ScriptGuid">{138D3C7D-487E-4FC5-9FB0-015409AEF174}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Rotate.server.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXE96A593DA32D4B3E979CB42644200C7C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">RingAlpha</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX536530828DB944D7B3271966854B288A">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
									<string name="ScriptGuid">{C43418F8-DF18-4AF8-932B-F9F3D56EE547}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Rotate.server.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXFA79DA3D6548475882A5E22B44AE5D1E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">UGC</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX51F43A6C0BB645F1B9C6221E9BA0BC4F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">OfferItems</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXD7A94DD576314366942BB7C8C2B54EF8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">UGCPacks</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX3BDB7D7047334D04A08F12AF23AD2234">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Guy_Pack1</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXA9D28EB3EDED4900948391EFFDAE0B76">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
										<string name="ScriptGuid">{BFCCF6CD-2ECC-4DD7-9461-468A90685843}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Animate.client.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXFA031955093B44B7BEBBDBA2DF3EA7F8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Guy_Pack2</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX8E0A7E427D494D10B17B99F131EA903F">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
										<string name="ScriptGuid">{EF70D274-6C43-485D-AA34-A62801A43E47}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Animate.client.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX45E4EA3D127E4C5B87556DBC010AFE76">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Guy_Pack3</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX1DE6F3519AD642FC9F27164B24A3A102">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
										<string name="ScriptGuid">{56AFFCC3-D29F-4742-8C33-E4140AFC0485}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Animate.client.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXDDCA51102D9141FA84DC914DC1D9A1BA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">Guy_Pack4</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX6706CA41FC97461BBBB7B52F1A71AC68">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
										<string name="ScriptGuid">{A04CD2C2-F010-436C-88F6-F803BE746F37}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Animate.client.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX085CCE84BA754D2AB8AF3F18747FBA84">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Modules</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXB801D4598F8A48EFB4B5DFA450225695">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Modules/Utils.lua
--
--  Description:
--      Comprehensive utility module providing helper functions for
--      formatting, math/string processing, player lookup, UI/model
--      utilities, glove alignment, server metadata, and secure remote
--      validation. Designed to be required broadly across the project.
--
--      Main Features:
--          • CSV encode/decode utilities
--          • Number formatting & large number abbreviation system
--          • Time conversion (HH:MM:SS)
--          • Safe character resolution anywhere in workspace
--          • Hover rotation + continuous rotation for 3D previews
--          • Glove alignment helpers (front & top view)
--          • Server info (server type, JobId, group/badge ids)
--
--          • SecureRemote (RemoteEvent wrapper):
--                - Type validation
--                - Missing-arg protection
--                - Per-player anti-spam & burst/lifetime rate limits
--                - Exploit detection & kick threshold
--
--          • SecureFunction (RemoteFunction wrapper):
--                - Type validation
--                - Rate limiting
--                - Safe pcall execution
--
--  Last Modified: 2025-11-29 by Darkzeb
--  Version: V2025-11
--
--  Dependencies:
--      Services:
--          - Players
--
--  Notes:
--      • SecureRemote / SecureFunction are core security primitives
--        used across the fight system and UI interactions.
--      • Rotation helpers use global-axis orientation for consistency.
--      • Number abbreviation supports extended notation (K → Qd → Ot…).
--======================================================================


local Utils = {}

local Players = game:GetService("Players")

function Utils.CsvToList(csv)
	if not csv or csv == "" then return {} end
	local t = {}
	for _, v in ipairs(string.split(csv, ",")) do
		local s = v:gsub("%s+", "")
		if s ~= "" then table.insert(t, s) end
	end
	return t
end

function Utils.ListToCsv(list)
	if not list or #list == 0 then return "" end
	return table.concat(list, ",")
end

function Utils.AddToCsv(csv, value)
	local list = Utils.CsvToList(csv)
	if not table.find(list, value) then
		table.insert(list, value)
	end
	return Utils.ListToCsv(list)
end

function Utils.Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

function Utils.Time_Conversion(Raw_S)
	local Hrs, Min_Secs = math.floor(Raw_S / 3600), Raw_S % 3600
	local Min, Sec = math.floor(Min_Secs / 60), Min_Secs % 60
	if Min < 10 then Min = "0" .. Min end
	if Sec < 10 then Sec = "0" .. Sec end
	if Hrs > 0 then return Utils.Format_Number(Hrs) .. ":" .. Min .. ":" .. Sec end
	return Min .. ":" .. Sec
end

function Utils.StartsWith(str, prefix)
	return typeof(str) == "string"
		and typeof(prefix) == "string"
		and string.sub(str, 1, #prefix) == prefix
end

function Utils.todayUTC()
	local d = os.date("!*t")
	return string.format("%04d-%02d-%02d", d.year, d.month, d.day)
end

function Utils.NumToString(Num)

	local function ToRomanNums(Num)
		local RomanNums1 = {
			"I", "II", "III", "IV", "V", "VI", "VII", "IIX", "IX", "X"
		}
		local RomanNums2 = {
			"I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"
		}
		local RomanNums3 = {
			"X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "C",
			"CX", "CXX", "CXXX", "CXL", "CL", "CLX", "CLXX", "CLXXX", "CXC", "CC"
		}
		local RomanNum = ""
		local Tens = math.floor(Num/10)
		local Ones = Num - (Tens * 10)
		if Tens > 0 then
			RomanNum = RomanNum .. RomanNums3[Tens]
			if Ones > 0 then
				RomanNum = RomanNum .. RomanNums2[Ones]
			end
		else
			if Ones > 0 then
				RomanNum = RomanNums1[Ones]
			end
		end
		return RomanNum
	end

	local UNITS = {"K","M","B","T","Qa","Qi","Sx","Sp","Oc","N","Dc","U","Dd","Td","Qt","Qd","Sd","St","Ot","Nv","V","C"}
	Num = tonumber(Num)
	
	----------------------------------------------------------------------
	-- NEW RULE: For numbers >= 10K → NO DECIMALS (e.g. "143K", "2M")
	----------------------------------------------------------------------
	if Num >= 10000 then
		local str = tostring(math.floor(Num))
		local len = math.floor((#str - 1) / 3)
		local suffix = UNITS[len]

		if suffix then
			local base = math.floor(Num / (1000 ^ len))
			return tostring(base) .. suffix
		end
	end
	
	if Num >= 1000 then
		local Div
		local Char
		if tostring(Num):split('e+')[2] then
			Div = math.floor(tonumber(tostring(Num):split('e+')[2])/3)
			local Rest = tonumber(tostring(Num):split('e+')[2])%3
			Char = UNITS[Div]
			if not Char then
				if math.floor(Div/#UNITS) <= 209 then
					Char = UNITS[Div%#UNITS + 1] .. ToRomanNums(math.floor(Div/#UNITS))
					local NewNum = tostring(tonumber(tostring(Num):split('e')[1]) * 10^Rest)
					local AfterFasila = ''
					if NewNum:split('.')[2] then
						for i = 1, string.len(NewNum:split('.')[2]) do
							if i > 2 then
								break
							elseif tonumber(NewNum:split('.')[2]:split('')[i]) == 0 then
								break
							else
								AfterFasila = AfterFasila .. tonumber(NewNum:split('.')[2]:split('')[i])
							end
						end
						NewNum = NewNum:split('.')[1] .. "." .. AfterFasila
					end
					Num = NewNum .. Char
				else
					Num = "Inf"
				end 
			else
				local NewNum = tostring(tonumber(tostring(Num):split('e')[1]) * 10^Rest)
				local AfterFasila = ''
				if NewNum:split('.')[2] then
					for i = 1, string.len(NewNum:split('.')[2]) do
						if i > 2 then
							break
						elseif tonumber(NewNum:split('.')[2]:split('')[i]) == 0 then
							break
						else
							AfterFasila = AfterFasila .. tonumber(NewNum:split('.')[2]:split('')[i])
						end
					end
					NewNum = NewNum:split('.')[1] .. "." .. AfterFasila
				end
				Num = NewNum .. Char
			end
		elseif tostring(Num) == "inf" then
			Num = "Inf"
		else
			Num = tostring(math.floor(Num))
			local Div = math.floor((string.len(Num)-1)/3)
			local Char = UNITS[Div]
			local Rest = string.len(Num) - 3*Div
			local NewNum = ""
			for i = 1, Rest do
				NewNum = NewNum .. Num:split('')[i]
			end
			if Num:split('')[Rest + 1] ~= "0" then
				NewNum = NewNum .. "." 
			end
			
			for i = 1, 2 do
				if Num:split('')[Rest + i] == "0" then
					break
				else
					NewNum = NewNum .. Num:split('')[Rest + i]
				end
			end
			NewNum = NewNum .. Char
			Num = NewNum
		end
	elseif Num <= 1000 then
		Num = tostring(Num)
		if Num:split('.')[2] then
			Num = Num:split('.')[1] .. "." .. Num:split('.')[2]:split('')[1]
		end
	end
	return Num
end

function Utils.getGroupId()
	return 35784641
end

function Utils.getServerId()
	return game.JobId
end

function Utils.getWelcomeBadgeId()
	return 1326039894106761
end

function Utils.GetServerType()
	if game.PrivateServerId ~= "" then
		if game.PrivateServerOwnerId ~= 0 then
			return "Private" -- VIP / Reserved server
		else
			return "PrivateReserved" -- Serveur privé non-VIP
		end
	else
		return "Public"
	end
end

-- Utility: find any model safely by name anywhere in workspace
function Utils.ResolveCharacter(name)
	if not name then return nil end
	local c = workspace:FindFirstChild(name)
	if c and c:FindFirstChild("HumanoidRootPart") then
		return c
	end

	for _, descendant in ipairs(workspace:GetDescendants()) do
		if descendant:IsA("Model") and descendant.Name == name and descendant:FindFirstChild("HumanoidRootPart") then
			return descendant
		end
	end
	return nil
end

function Utils.SetupHoverRotation(button, model, speed)
	local primary = model:FindFirstChildWhichIsA("BasePart")
	if not primary then return end

	primary.Anchored = true
	model.PrimaryPart = primary

	local rotating = false

	button.MouseEnter:Connect(function()
		if rotating then return end
		rotating = true
		task.spawn(function()
			while rotating do
				-- GLOBAL AXIS rotation (not relative to current orientation)
				primary.CFrame = CFrame.fromMatrix(
					primary.Position,
					primary.CFrame.RightVector,
					primary.CFrame.UpVector
				) * CFrame.Angles(0, math.rad(speed), 0)

				task.wait(1/60)
			end
		end)
	end)

	button.MouseLeave:Connect(function()
		rotating = false
	end)
end

function Utils.SetupRotation(model, speed)
	local primary = model:FindFirstChildWhichIsA("BasePart")
	if not primary then return end
	primary.Anchored = true
	model.PrimaryPart = primary
	
	task.spawn(function()
		while true do
			-- GLOBAL AXIS rotation (not relative to current orientation)
			primary.CFrame = CFrame.fromMatrix(
				primary.Position,
				primary.CFrame.RightVector,
				primary.CFrame.UpVector
			) * CFrame.Angles(0, math.rad(speed), 0)

			task.wait(1/60)
		end
	end)
end

function Utils.AlignGloves(leftModel, rightModel, offset)
	offset = offset or 0.5

	if leftModel then
		leftModel:PivotTo(CFrame.new(-offset, 0, 0))
	end

	if rightModel then
		rightModel:PivotTo(CFrame.new(offset, 0, 0))
	end
end

function Utils.AlignGlovesTopView(leftModel, rightModel)
	local LEFT_ORIENTATION = CFrame.Angles(math.rad(-90), math.rad(20), 0)
	local RIGHT_ORIENTATION = CFrame.Angles(math.rad(-90), math.rad(-20), 0)

	if leftModel then
		leftModel:PivotTo(CFrame.new(-0.5, 0, 0) * LEFT_ORIENTATION)
	end
	if rightModel then
		rightModel:PivotTo(CFrame.new(0.5, 0, 0) * RIGHT_ORIENTATION)
	end
end

-- Internal: tracks spam per player per remote
local callHistory = {}

-- Cleanup when player leaves
Players.PlayerRemoving:Connect(function(player)
	callHistory[player] = nil
end)

-- Disconnect all remotes for a player (optional use)
function Utils.ClearPlayer(player)
	callHistory[player] = nil
end

function Utils.SecureRemote(remote, callback, expectedArgs, options)
	assert(remote and remote:IsA("RemoteEvent"), "Expected a RemoteEvent")
	assert(type(callback) == "function", "Callback must be a function")

	expectedArgs = expectedArgs or {}
	options = options or {}

	-- Defaults
	options.MaxBurst = options.MaxBurst or 8       -- Max calls within 1 sec before suspicious
	options.RateLimit = options.RateLimit or 10    -- Hard limit (ignored for legit spam)
	options.PunishThreshold = options.PunishThreshold or 20 -- Only kick if absolutely malicious

	-- Per-player stats
	local history = {}

	remote.OnServerEvent:Connect(function(player, ...)
		if not player or not player:IsA("Player") then return end

		local args = {...}
		local argCount = #args

		---------------------------------------
		-- 1. Secure argument validation
		---------------------------------------
		if type(expectedArgs) == "table" then
			local expectedCount = #expectedArgs

			if not options.AllowMissingArgs and argCount ~= expectedCount then
				return -- soft fail
			end

			if argCount > expectedCount then
				return -- too many args → safe ignore
			end

			for i = 1, math.min(argCount, expectedCount) do
				local expected = expectedArgs[i]
				local value = args[i]
				local actualType = typeof(value)

				if actualType ~= expected then
					-- Special case: Instance class check
					if actualType == "Instance" and value:IsA(expected) then
						continue
					end
					return -- bad type → ignore only
				end
			end
		end

		---------------------------------------
		-- 2. Anti-spam & exploit detector
		---------------------------------------
		local now = os.clock()

		history[player] = history[player] or {
			last = 0,
			burst = 0,
			total = 0,
		}

		local h = history[player]

		-- Burst counter (per second)
		if now - h.last < 1 then
			h.burst += 1
		else
			h.burst = 1
		end
		h.last = now

		h.total += 1

		-- Legit players may spam 10–20/s → OK
		if h.burst > options.MaxBurst then
			-- Suspicious player → ignore but do NOT kick
			if h.burst > options.PunishThreshold then
				-- Only kick obvious exploiters
				
				-- TODO remove that trace in production
				-- ⭐ Trace the RemoteEvent that triggered the kick
				warn(string.format(
					"[SecureRemote] Kicking player '%s' for malicious spam on RemoteEvent '%s' | burst=%d | total=%d",
					player.Name,
					remote.Name,
					h.burst,
					h.total
					))
				
				player:Kick("Malicious RemoteEvent spam detected.")
				return
			end
			return -- ignore spam
		end

		---------------------------------------
		-- 3. Execute callback safely
		---------------------------------------
		local ok, err = pcall(callback, player, table.unpack(args))
		if not ok then
			warn("[SecureRemote] Callback error:", err)
		end
	end)
end


function Utils.SecureFunction(remote, callback, expectedArgs, options)
	assert(remote and remote:IsA("RemoteFunction"), "Expected a RemoteFunction")
	assert(type(callback) == "function", "Callback must be a function")

	expectedArgs = expectedArgs or {}
	options = options or {}

	options.RateLimit = options.RateLimit or 10
	options.MaxBurst = options.MaxBurst or 5
	options.PunishThreshold = options.PunishThreshold or 20

	local history = {}

	remote.OnServerInvoke = function(player, ...)
		if not player or not player:IsA("Player") then
			return nil
		end

		local args = {...}
		local argCount = #args

		---------------------------
		-- Arg validation
		---------------------------
		if type(expectedArgs) == "table" then
			if argCount ~= #expectedArgs then
				return nil
			end

			for i, expected in ipairs(expectedArgs) do
				local value = args[i]
				local actualType = typeof(value)

				if actualType ~= expected then
					if actualType == "Instance" and value:IsA(expected) then
						continue
					end
					return nil
				end
			end
		elseif type(expectedArgs) == "number" then
			if argCount ~= expectedArgs then
				return nil
			end
		end

		---------------------------
		-- Anti spam
		---------------------------
		local now = os.clock()

		history[player] = history[player] or {
			last = 0,
			burst = 0,
			total = 0,
		}

		local h = history[player]

		if now - h.last < 1 then
			h.burst += 1
		else
			h.burst = 1
		end
		h.last = now
		h.total += 1

		if h.burst > options.MaxBurst then
			if h.burst > options.PunishThreshold then
				-- TODO remove that trace in production
				-- ⭐ Trace the RemoteEvent that triggered the kick
				warn(string.format(
					"[SecureRemote] Kicking player '%s' for malicious spam on RemoteFunction '%s' | burst=%d | total=%d",
					player.Name,
					remote.Name,
					h.burst,
					h.total
					))
				player:Kick("RemoteFunction exploit detected.")
			end
			return nil -- soft ignore
		end

		---------------------------
		-- Execute function safely
		---------------------------
		local results = {pcall(callback, player, table.unpack(args))}
		local ok = table.remove(results, 1)
		if not ok then
			warn("[SecureFunction] Error:", results[1])
			return nil
		end

		return table.unpack(results)
	end
end

-- Utils.WaitForAttribute(instance, attrName, timeout, cancelFn)
-- instance   : Instance Roblox
-- attrName   : string (nom de l'attribut)
-- timeout    : number ou nil (en secondes)
-- cancelFn   : function() -> bool (optionnel) si tu veux stopper l'attente
--
-- Retourne :
--   true  → attribut trouvé avant timeout/annulation
--   false → timeout ou cancel demandé
function Utils.WaitForAttribute(instance, attrName, timeout, cancelFn)
	local elapsed = 0
	local dt = 0.1

	while not instance:GetAttribute(attrName) do
		task.wait(dt)
		elapsed += dt

		-- Si une fonction d'annulation est fournie :
		if cancelFn and cancelFn() then
			return false
		end

		-- Timeout atteint ?
		if timeout and elapsed >= timeout then
			warn(("Utils.WaitForAttribute timeout waiting for '%s' on %s")
				:format(attrName, instance:GetFullName()))
			return false
		end
	end

	return true
end

return Utils]]></ProtectedString>
						<string name="ScriptGuid">{FDC7F2EF-E053-43D8-BC05-AADD88AEDB69}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Utils.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7EB86519530348F994657BE2871EA855">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Channels.lua
--
--  Description:
--      Centralized communication registry providing structured access
--      to all RemoteEvents, RemoteFunctions, and Bindables used for
--      client-server and server-client communication. Ensures consistent
--      access paths and initialization order across the experience.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-11-29 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/
--              - Server_Client_F
--              - Client_Server_F
--              - Bindable_F (Events / RF)
--
--  Notes:
--      - Channels.Bindable_Events: internal signals (UI, gameplay sync)
--      - Channels.Bindable_Functions: internal function remotes (group/badge checks)
--      - Channels.CS_Remote_Functions: client→server requests (rewards, crates, data)
--      - Channels.CS_Remote_Events: client→server fire events (UI, settings, actions)
--      - Channels.SC_Remote_Events: server→client communication (fight flow, UI, data)
--      - Serves as the unified import point for any module needing networked communication
--
--======================================================================

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Channels = {}

Channels_F 						= ReplicatedStorage:WaitForChild("Channels_F")
Channels.Server_Client 			= Channels_F:WaitForChild("Server_Client_F")
Channels.Client_Server 			= Channels_F:WaitForChild("Client_Server_F")
Channels.Bindable 				= Channels_F:WaitForChild("Bindable_F")
Channels.Bindable_RF_F     		= Channels.Bindable:WaitForChild("RF")
Channels.Bindable_Events_F     	= Channels.Bindable:WaitForChild("Events")
Channels.Client_Server_RF    	= Channels.Client_Server:WaitForChild("RF")
Channels.Client_Server_Events 	= Channels.Client_Server:WaitForChild("Events")
Channels.Server_Client_Events 	= Channels.Server_Client:WaitForChild("Events")
Channels.Offers_F 				= Channels_F:WaitForChild("Offers")
Channels.UGC_Pack_F			 	= Channels_F:WaitForChild("UGC_Pack")

-- Centralized remotes events & function registry

Channels.Bindable_Events = {
	AI_Training_Submission		= Channels.Bindable_Events_F:WaitForChild("AI_Training_Submission"),
	Award_Badge					= Channels.Bindable_Events_F:WaitForChild("Award_Badge"),
	AI_Training_Cage_Clinch		= Channels.Bindable_Events_F:WaitForChild("AI_Training_Cage_Clinch"),
	Click_Rate_Inc				= Channels.Bindable_Events_F:WaitForChild("Click_Rate_Inc"),
	Click_Rate_Reset			= Channels.Bindable_Events_F:WaitForChild("Click_Rate_Reset"),
	Click_Rate_Update			= Channels.Bindable_Events_F:WaitForChild("Click_Rate_Update"),
	Close_Changelog				= Channels.Bindable_Events_F:WaitForChild("Close_Changelog"),
	Close_DailyRewards			= Channels.Bindable_Events_F:WaitForChild("Close_DailyRewards"),
	Close_Fight_Result			= Channels.Bindable_Events_F:WaitForChild("Close_Fight_Result"),
	Close_Settings				= Channels.Bindable_Events_F:WaitForChild("Close_Settings"),
	Show_Tutorial_Launcher		= Channels.Bindable_Events_F:FindFirstChild("Show_Tutorial_Launcher"),
	Close_Tutorial				= Channels.Bindable_Events_F:WaitForChild("Close_Tutorial"),
	Disable_Fight_Mode			= Channels.Bindable_Events_F:WaitForChild("Disable_Fight_Mode"),
	Display_Data				= Channels.Bindable_Events_F:WaitForChild("Display_Data"),
	Display_Tuto_Message		= Channels.Bindable_Events_F:WaitForChild("Display_Tuto_Message"),
	Display_Tuto_Indicator		= Channels.Bindable_Events_F:WaitForChild("Display_Tuto_Indicator"),
	Equipment_Strike			= Channels.Bindable_Events_F:WaitForChild("Equipment_Strike"),
	Grant_Gamepass_Perks		= Channels.Bindable_Events_F:WaitForChild("Grant_Gamepass_Perks"),
	Gym_Reward_Update			= Channels.Bindable_Events_F:WaitForChild("Gym_Reward_Update"),
	Hallowen_UGCs				= Channels.Bindable_Events_F:WaitForChild("Hallowen_UGCs"),
	MTX_Finished				= Channels.Bindable_Events_F:WaitForChild("MTX_Finished"),
	MTX_Prompted				= Channels.Bindable_Events_F:WaitForChild("MTX_Prompted"),
	New_Round_Display			= Channels.Bindable_Events_F:WaitForChild("New_Round_Display"),
	Next_Tutorial_Step			= Channels.Bindable_Events_F:WaitForChild("Next_Tutorial_Step"),
	On_Submission_Handle		= Channels.Bindable_Events_F:WaitForChild("On_Submission_Handle"),
	Open_Appearance				= Channels.Bindable_Events_F:WaitForChild("Open_Appearance"),
	Open_Equipment				= Channels.Bindable_Events_F:WaitForChild("Open_Equipment"),
	Open_Changelog				= Channels.Bindable_Events_F:WaitForChild("Open_Changelog"),
	Open_Codes					= Channels.Bindable_Events_F:WaitForChild("Open_Codes"),
	Open_Combos					= Channels.Bindable_Events_F:WaitForChild("Open_Combos"),
	Open_Daily_Rewards			= Channels.Bindable_Events_F:WaitForChild("Open_Daily_Rewards"),
	Open_Emotes_UI				= Channels.Bindable_Events_F:WaitForChild("Open_Emotes_UI"),
	Open_InsufficientFunds_UI	= Channels.Bindable_Events_F:WaitForChild("Open_InsufficientFunds_UI"),
	Open_Leagues				= Channels.Bindable_Events_F:WaitForChild("Open_Leagues"),
	Open_Servers				= Channels.Bindable_Events_F:WaitForChild("Open_Servers"),
	Open_Session_Rewards		= Channels.Bindable_Events_F:WaitForChild("Open_Session_Rewards"),
	Open_Settings				= Channels.Bindable_Events_F:WaitForChild("Open_Settings"),
	Open_Shop_UI				= Channels.Bindable_Events_F:WaitForChild("Open_Shop_UI"),
	Open_Skill_Tree				= Channels.Bindable_Events_F:WaitForChild("Open_Skill_Tree"),
	Open_Starter_Pack			= Channels.Bindable_Events_F:WaitForChild("Open_Starter_Pack"),
	Open_Stats					= Channels.Bindable_Events_F:WaitForChild("Open_Stats"),
	Player_Leaderboard_Data		= Channels.Bindable_Events_F:WaitForChild("Player_Leaderboard_Data"),
	Prompt_Invite				= Channels.Bindable_Events_F:WaitForChild("Prompt_Invite"),
	Ragdoll_Player				= Channels.Bindable_Events_F:WaitForChild("Ragdoll_Player"),
	Remove_Submission_UI		= Channels.Bindable_Events_F:WaitForChild("Remove_Submission_UI"),
	Remove_Trail				= Channels.Bindable_Events_F:WaitForChild("Remove_Trail"),
	Set_Fight_Mode_Lock			= Channels.Bindable_Events_F:WaitForChild("Set_Fight_Mode_Lock"),
	Set_Trail					= Channels.Bindable_Events_F:WaitForChild("Set_Trail"),
	
	Show_White_Fade				= Channels.Bindable_Events_F:WaitForChild("Show_White_Fade"),
	Start_Core_Fight			= Channels.Bindable_Events_F:WaitForChild("Start_Core_Fight"),
	Toggle_BG_Volume			= Channels.Bindable_Events_F:WaitForChild("Toggle_BG_Volume"),
	Toggle_Commands_Panel		= Channels.Bindable_Events_F:WaitForChild("Toggle_Commands_Panel"),
	Toggle_Cutscene				= Channels.Bindable_Events_F:WaitForChild("Toggle_Cutscene"),
	Toggle_Fight_Button			= Channels.Bindable_Events_F:WaitForChild("Toggle_Fight_Button"),
	Toggle_Tools_Buttons		= Channels.Bindable_Events_F:WaitForChild("Toggle_Tools_Buttons"),
	Toggle_Fight_Mode			= Channels.Bindable_Events_F:WaitForChild("Toggle_Fight_Mode"),
	Toggle_Fight_UI				= Channels.Bindable_Events_F:WaitForChild("Toggle_Fight_UI"),
	Toggle_Player_List			= Channels.Bindable_Events_F:WaitForChild("Toggle_Player_List"),
	Toggle_Reset				= Channels.Bindable_Events_F:WaitForChild("Toggle_Reset"),
	Toggle_Side_Buttons			= Channels.Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"),
	Toggle_Takedown_Tracker		= Channels.Bindable_Events_F:WaitForChild("Toggle_Takedown_Tracker"),
	Toggle_TopBar				= Channels.Bindable_Events_F:WaitForChild("Toggle_TopBar"),
	Toggle_Tutorial_OK_Button	= Channels.Bindable_Events_F:WaitForChild("Toggle_Tutorial_OK_Button"),
	Tournament_Score_Updated	= Channels.Bindable_Events_F:WaitForChild("Tournament_Score_Updated"),
	Tournament_Fight_Ended		= Channels.Bindable_Events_F:WaitForChild("Tournament_Fight_Ended"),
	Transition_Fade_UI			= Channels.Bindable_Events_F:WaitForChild("Transition_Fade_UI"),
	Transition_Hole_UI			= Channels.Bindable_Events_F:WaitForChild("Transition_Hole_UI"),
	Update_Server_Data			= Channels.Bindable_Events_F:WaitForChild("Update_Server_Data"),
	Voice_Chat_Prompt			= Channels.Bindable_Events_F:WaitForChild("Voice_Chat_Prompt"),
	Release_Mobile_Blocking    	= Channels.Bindable_Events_F:WaitForChild("Release_Mobile_Blocking"),
	Toggle_Key_Labels          	= Channels.Bindable_Events_F:WaitForChild("Toggle_Key_Labels"),
	
	Start_Tour					= Channels.Bindable_Events_F:WaitForChild("Start_Tour"),
	Start_Cage_Tutorial			= Channels.Bindable_Events_F:WaitForChild("Start_Cage_Tutorial"),
	Display_InCage_Message		= Channels.Bindable_Events_F:WaitForChild("Display_InCage_Message"),
	Display_InCage_ImageStroke  = Channels.Bindable_Events_F:WaitForChild("Display_InCage_ImageStroke"),
	Display_InCage_UIStroke		= Channels.Bindable_Events_F:WaitForChild("Display_InCage_UIStroke"),
	Display_InCage_Indicator    = Channels.Bindable_Events_F:WaitForChild("Display_InCage_Indicator"),
	
	
	Change_Shop_UIFrames		= Channels.Bindable_Events_F:WaitForChild("Change_Shop_UIFrames"),
	Game_Loading_Finished		= Channels.Bindable_Events_F:WaitForChild("Game_Loading_Finished"),

}

Channels.Bindable_Functions = {
	Is_Chatbox_Typing 			= Channels.Bindable_RF_F:WaitForChild("Is_Chatbox_Typing"),
	Player_Can_Access_Arena 	= Channels.Bindable_RF_F:WaitForChild("Player_Can_Access_Arena"),
	Player_In_Group 			= Channels.Bindable_RF_F:WaitForChild("Player_In_Group"),
	Player_Owns_Badge 			= Channels.Bindable_RF_F:WaitForChild("Player_Owns_Badge"),
	Get_Fights_Keys				= Channels.Bindable_RF_F:WaitForChild("Get_Fights_Keys"),
}

Channels.CS_Remote_Functions = {
	Avatar_Clothing_Request		= Channels.Client_Server_RF:WaitForChild("Avatar_Clothing_Request"),
	Claim_Daily_Reward 			= Channels.Client_Server_RF:WaitForChild("Claim_Daily_Reward"),
	Claim_Session_Reward 		= Channels.Client_Server_RF:WaitForChild("Claim_Session_Reward"),
	Combo_Action_Request 		= Channels.Client_Server_RF:WaitForChild("Combo_Action_Request"),
	Crate_Action_Request 		= Channels.Client_Server_RF:WaitForChild("Crate_Action_Request"),
	Create_Training_Bot 		= Channels.Client_Server_RF:WaitForChild("Create_Training_Bot"),
	Destroy_Training_Bot 		= Channels.Client_Server_RF:WaitForChild("Destroy_Training_Bot"),
	Send_Invite_Notification    = Channels.Client_Server_RF:WaitForChild("Send_Invite_Notification"),
	Emote_Slot_Request 			= Channels.Client_Server_RF:WaitForChild("Emote_Slot_Request"),
	Get_All_Server_Data 		= Channels.Client_Server_RF:WaitForChild("Get_All_Server_Data"),
	Get_Session_Progress 		= Channels.Client_Server_RF:WaitForChild("Get_Session_Progress"),
	Player_In_Group 			= Channels.Client_Server_RF:WaitForChild("Player_In_Group"),
	Player_Owns_Badge			= Channels.Client_Server_RF:WaitForChild("Player_Owns_Badge"),
	Redeem_Code 				= Channels.Client_Server_RF:WaitForChild("Redeem_Code"),
	Redeem_Skill_Tree_Reward 	= Channels.Client_Server_RF:WaitForChild("Redeem_Skill_Tree_Reward"),
	Teleport_To_Server 			= Channels.Client_Server_RF:WaitForChild("Teleport_To_Server"),
	Get_Mobile_Buttons          = Channels.Client_Server_RF:WaitForChild("Get_Mobile_Buttons"),
	
	Find_Cage_Mini_Tutorial  	= Channels.Client_Server_RF:WaitForChild("Find_Cage_Mini_Tutorial")
}

Channels.CS_Remote_Events = {
	Convert_Cash_To_Gems 		= Channels.Client_Server_Events:WaitForChild("Convert_Cash_To_Gems"),
	Crate_Display 				= Channels.Client_Server_Events:WaitForChild("Crate_Display"),
	Exit_Machine 				= Channels.Client_Server_Events:WaitForChild("Exit_Machine"),
	Gym_Reward_Testing 			= Channels.Client_Server_Events:WaitForChild("Gym_Reward_Testing"),
	Ready_To_Fight				= Channels.Client_Server_Events:WaitForChild("Ready_To_Fight"),
	Reset_Sequence 				= Channels.Client_Server_Events:WaitForChild("Reset_Sequence"),
	Save_Appearance 			= Channels.Client_Server_Events:WaitForChild("Save_Appearance"),
	Set_Body_Preset 			= Channels.Client_Server_Events:WaitForChild("Set_Body_Preset"),
	Save_Settings 				= Channels.Client_Server_Events:WaitForChild("Save_Settings"),
	Server_Message_Crate 		= Channels.Client_Server_Events:WaitForChild("Server_Message_Crate"),
	Set_Creator_Reward_Code 	= Channels.Client_Server_Events:WaitForChild("Set_Creator_Reward_Code"),
	Set_Player_Device 			= Channels.Client_Server_Events:WaitForChild("Set_Player_Device"),
	Show_Shield_UI 				= Channels.Client_Server_Events:WaitForChild("Show_Shield_UI"),
	Tournament_Leave 			= Channels.Client_Server_Events:WaitForChild("Tournament_Leave"),
	Tournament_Register 		= Channels.Client_Server_Events:WaitForChild("Tournament_Register"),
	Workout_Rep 				= Channels.Client_Server_Events:WaitForChild("Workout_Rep"),

	Blocking_Strike           	= Channels.Client_Server_Events:WaitForChild("Blocking_Strike"),
	Dodging_Strike              = Channels.Client_Server_Events:WaitForChild("Dodging_Strike"),
	Throwing_Strike             = Channels.Client_Server_Events:WaitForChild("Throwing_Strike"),
	Toggle_Healing_Effect       = Channels.Client_Server_Events:WaitForChild("Toggle_Healing_Effect"),
	Unblocking_Strike           = Channels.Client_Server_Events:WaitForChild("Unblocking_Strike"),
	
	Purchase_Cloth_Item		    = Channels.Client_Server_Events:WaitForChild("Purchase_Cloth_Item"),
	
	End_Mini_Tutorial_Match		= Channels.Client_Server_Events:WaitForChild("End_Mini_Tutorial_Match"),
	Set_TakeDown_Mini_Tutorial	= Channels.Client_Server_Events:WaitForChild("Set_TakeDown_Mini_Tutorial"),
	
	Reset_Player_Profile		= Channels.Client_Server_Events:WaitForChild("Reset_Player_Profile"),
	Fight_Intro_Finished		= Channels.Client_Server_Events:WaitForChild("Fight_Intro_Finished")
}

Channels.SC_Remote_Events = {
	Admin_Notification			= Channels.Server_Client_Events:WaitForChild("Admin_Notification"),
	Cage_Clinch_Start 			= Channels.Server_Client_Events:WaitForChild("Cage_Clinch_Start"),
	Convert_Feedback 			= Channels.Server_Client_Events:WaitForChild("Convert_Feedback"),
	Display_Data 				= Channels.Server_Client_Events:WaitForChild("Display_Data"),
	Elo_Rank_Dif 				= Channels.Server_Client_Events:WaitForChild("Elo_Rank_Dif"),
	End_Fight 					= Channels.Server_Client_Events:WaitForChild("End_Fight"),
	Fight_Data_Result 			= Channels.Server_Client_Events:WaitForChild("Fight_Data_Result"),
	Fight_Set_Up 				= Channels.Server_Client_Events:WaitForChild("Fight_Set_Up"),
	Fight_Spawn_Notification 	= Channels.Server_Client_Events:WaitForChild("Fight_Spawn_Notification"),
	Got_Hit_Effect 				= Channels.Server_Client_Events:WaitForChild("Got_Hit_Effect"),
	Grant_Free_Crate 			= Channels.Server_Client_Events:WaitForChild("Grant_Free_Crate"),
	Hide_Special_Gloves_Frame 	= Channels.Server_Client_Events:WaitForChild("Hide_Special_Gloves_Frame"),
	Init_Gym_Training 			= Channels.Server_Client_Events:WaitForChild("Init_Gym_Training"),
	Open_InsufficientFunds 		= Channels.Server_Client_Events:WaitForChild("Open_InsufficientFunds"),
	League_DivisionUpdate 		= Channels.Server_Client_Events:WaitForChild("League_DivisionUpdate"),
	Open_Emotes 				= Channels.Server_Client_Events:WaitForChild("Open_Emotes"),
	Open_Shop 					= Channels.Server_Client_Events:WaitForChild("Open_Shop"),
	Overhead_Display 			= Channels.Server_Client_Events:WaitForChild("Overhead_Display"),
	Round_Result_Win 			= Channels.Server_Client_Events:WaitForChild("Round_Result_Win"),
	Server_Chat 				= Channels.Server_Client_Events:WaitForChild("Server_Chat"),
	Session_Reward_Claim_Result = Channels.Server_Client_Events:WaitForChild("Session_Reward_Claim_Result"),
	Session_Reward_Progress 	= Channels.Server_Client_Events:WaitForChild("Session_Reward_Progress"),
	Show_Crate_Effects 			= Channels.Server_Client_Events:WaitForChild("Show_Crate_Effects"),
	Show_Punch_Effects 			= Channels.Server_Client_Events:WaitForChild("Show_Punch_Effects"),
	Submission_Minigame_Update	= Channels.Server_Client_Events:WaitForChild("Submission_Minigame_Update"),
	Top3_Players_Updated 		= Channels.Server_Client_Events:WaitForChild("Top3_Players_Updated"),
	Tournament_Results 			= Channels.Server_Client_Events:WaitForChild("Tournament_Results"),
	Tournament_Update 			= Channels.Server_Client_Events:WaitForChild("Tournament_Update"),
	Transition_Fade 			= Channels.Server_Client_Events:WaitForChild("Transition_Fade"),
	Transition_Hole 			= Channels.Server_Client_Events:WaitForChild("Transition_Hole"),
	Update_All_Server_Data 		= Channels.Server_Client_Events:WaitForChild("Update_All_Server_Data"),
	Update_Player_Device 		= Channels.Server_Client_Events:WaitForChild("Update_Player_Device"),
	Update_Player_List 			= Channels.Server_Client_Events:WaitForChild("Update_Player_List"),
	Shop_Item_Purchased			= Channels.Server_Client_Events:WaitForChild("Shop_Item_Purchased"),
	Shop_Purchase_Rejected		= Channels.Server_Client_Events:WaitForChild("Shop_Purchase_Rejected"),
	Game_Startup_Ready			= Channels.Server_Client_Events:WaitForChild("Game_Startup_Ready"),
}

Channels.Offers = {
	GetActiveOffers = Channels.Offers_F:WaitForChild("GetActiveOffers"),
	GetCurrentClothOffer = Channels.Offers_F:WaitForChild("GetCurrentClothOffer"),
	GetNewClothOffer = Channels.Offers_F:WaitForChild("GetNewClothOffer"),
	ClothItemIdSignal = Channels.Offers_F:WaitForChild("ClothItemIdSignal"),
	RequestPurchase = Channels.Offers_F:WaitForChild("RequestPurchase"),
	SendOfferToClient = Channels.Offers_F:WaitForChild("SendOfferToClient"),
	ShowMessage = Channels.Offers_F:WaitForChild("ShowMessage"),
	Open_InsufficientFunds =  Channels.Offers_F:WaitForChild("Open_InsufficientFunds"),
	SendUGCOfferToClient = Channels.Offers_F:WaitForChild("SendUGCOfferToClient"),
	ShowOfferSignalBind = Channels.Offers_F:WaitForChild("ShowOfferSignalBind")

}
	
Channels.UGC_Pack = {
	ApplyAccessoriesRE = Channels.UGC_Pack_F:WaitForChild("ApplyAccessoriesRE"),
	ShowAvatarAndGetTriggerRE = Channels.UGC_Pack_F:WaitForChild("ShowAvatarAndGetTriggerRE")
}

return Channels]]></ProtectedString>
						<string name="ScriptGuid">{94E2B922-AA18-4680-9468-2DD2E6722946}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Channels.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC96E9F19BD60407BA40F414B30F14DB9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/Modules/CreatorCodes.lua
--
--  Description:
--      Static table of creator codes used for attribution,
--      partnerships, or in-game rewards. Each entry maps a creator
--      identifier (Creator_1, Creator_2, …) to a Name string.
--
--  Author(s): Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - None (standalone static data)
--
--  Notes:
--      - Current creators:
--          * bye
--          * AEBID
--          * NM
--          * SkiluaOnYTB
--          * Akamuro
--          * JkChimera
--          * Kayzarox
--          * Unchained
--      - Can be expanded with additional Creator_N entries
--      - Likely used in attribution systems or special code redemption
--
--======================================================================

return {
	Creator_1 = {
		Name = "bye",
	},
	Creator_2 = {
		Name = "AEBID",
	},
	Creator_3 = {
		Name = "NM",
	},
	Creator_4 = {
		Name = "SkiluaOnYTB",
	},
	Creator_5 = {
		Name = "Akamuro",
	},
	Creator_6 = {
		Name = "JkChimera",
	},
	Creator_7 = {
		Name = "Kayzarox",
	},
	Creator_8 = {
		Name = "Unchained",
	},
}]]></ProtectedString>
						<string name="ScriptGuid">{63B4B240-4926-4253-9D3F-A97BED3155D6}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CreatorCodes.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2800E0916C4C4D84931FFEB34DFBEE98">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ReplicatedStorage/GameAnalytics.lua
--
--  Description:
--      Proxy module for GameAnalytics. Automatically loads the
--      appropriate implementation depending on context:
--          * GameAnalytics (server)
--          * GameAnalyticsClient (client)
--
--  Author(s): Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * RunService
--      - Local Modules:
--          * script.GameAnalytics (server-side implementation)
--          * script.GameAnalyticsClient (client-side implementation)
--
--  Notes:
--      - Usage: require(ReplicatedStorage.GameAnalytics)
--        Will return server or client version transparently
--      - Ensures consistent API entrypoint across environments
--
--======================================================================

local RunService = game:GetService("RunService")

if RunService:IsServer() then
	return require(script.GameAnalytics)
else
	return require(script.GameAnalyticsClient)
end]]></ProtectedString>
						<string name="ScriptGuid">{3AC0D407-19C8-4F0A-B07B-266E95BAA159}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GameAnalytics.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX03476E8ED97C48A5A529FB988FCE3180">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GameAnalytics</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX491924DEB6324EDBB380CFCC7CD6F4C9">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local GAResourceFlowType = require(script.GAResourceFlowType)
local GAProgressionStatus = require(script.GAProgressionStatus)
local GAErrorSeverity = require(script.GAErrorSeverity)

local ga = {
	EGAResourceFlowType = GAResourceFlowType,
	EGAProgressionStatus = GAProgressionStatus,
	EGAErrorSeverity = GAErrorSeverity,
}

local types = require(script.Types)
local logger = require(script.Logger)
local threading = require(script.Threading)
local state = require(script.State)
local validation = require(script.Validation)
local store = require(script.Store)
local events = require(script.Events)
local utilities = require(script.Utilities)
local Players = game:GetService("Players")
local MKT = game:GetService("MarketplaceService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalizationService = game:GetService("LocalizationService")
local ScriptContext = game:GetService("ScriptContext")
local Postie = require(script.Postie)
local OnPlayerReadyEvent
local ProductCache = {}
local ONE_HOUR_IN_SECONDS = 3600
local MaxErrorsPerHour = 10
local ErrorDS = {}
local errorCountCache = {}
local errorCountCacheKeys = {}

local InitializationQueue = {}
local InitializationQueueByUserId = {}

type BusinessEventOptions = types.BusinessEventOptions
type ResourceEventOptions = types.ResourceEventOptions
type ProgressionEventOptions = types.ProgressionEventOptions
type DesignEventOptions = types.DesignEventOptions
type ErrorEventOptions = types.ErrorEventOptions
type CustomDimension = types.CustomDimension
type ProductInfo = types.ProductInfo
type ProcessReceiptInfo = types.ProcessReceiptInfo
type TeleportData = types.TeleportData
type RemoteConfigs = types.RemoteConfigs
type GameAnalyticsOptions = types.GameAnalyticsOptions

local function addToInitializationQueue(func, ...)
	if InitializationQueue ~= nil then
		table.insert(InitializationQueue, {
			Func = func,
			Args = { ... },
		})

		logger:i("Added event to initialization queue")
	else
		--This should never happen
		logger:w("Initialization queue already cleared.")
	end
end

local function addToInitializationQueueByUserId(userId, func, ...)
	if not ga:isPlayerReady(userId) then
		if InitializationQueueByUserId[userId] == nil then
			InitializationQueueByUserId[userId] = {}
		end

		table.insert(InitializationQueueByUserId[userId], {
			Func = func,
			Args = { ... },
		})

		logger:i("Added event to player initialization queue")
	else
		--This should never happen
		logger:w("Player initialization queue already cleared.")
	end
end

-- local functions
local function isSdkReady(options)
	local playerId = options["playerId"] or nil
	local needsInitialized = options["needsInitialized"] or true
	local shouldWarn = options["shouldWarn"] or false
	local message = options["message"] or ""

	-- Is SDK initialized
	if needsInitialized and not state.Initialized then
		if shouldWarn then
			logger:w(message .. " SDK is not initialized")
		end

		return false
	end

	-- Is SDK enabled
	if needsInitialized and playerId and not state:isEnabled(playerId) then
		if shouldWarn then
			logger:w(message .. " SDK is disabled")
		end

		return false
	end

	-- Is session started
	if needsInitialized and playerId and not state:sessionIsStarted(playerId) then
		if shouldWarn then
			logger:w(message .. " Session has not started yet")
		end

		return false
	end

	return true
end

function ga:configureAvailableCustomDimensions01(customDimensions: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available custom dimensions must be set before SDK is initialized")
		return
	end

	state:setAvailableCustomDimensions01(customDimensions)
end

function ga:configureAvailableCustomDimensions02(customDimensions: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available custom dimensions must be set before SDK is initialized")
		return
	end

	state:setAvailableCustomDimensions02(customDimensions)
end

function ga:configureAvailableCustomDimensions03(customDimensions: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available custom dimensions must be set before SDK is initialized")
		return
	end

	state:setAvailableCustomDimensions03(customDimensions)
end

function ga:configureAvailableResourceCurrencies(resourceCurrencies: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available resource currencies must be set before SDK is initialized")
		return
	end

	events:setAvailableResourceCurrencies(resourceCurrencies)
end

function ga:configureAvailableResourceItemTypes(resourceItemTypes: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available resource item types must be set before SDK is initialized")
		return
	end

	events:setAvailableResourceItemTypes(resourceItemTypes)
end

function ga:configureBuild(build: string)
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Build version must be set before SDK is initialized.")
		return
	end

	events:setBuild(build)
end

function ga:configureAvailableGamepasses(availableGamepasses: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available gamepasses must be set before SDK is initialized.")
		return
	end

	state:setAvailableGamepasses(availableGamepasses)
end

function ga:startNewSession(player: Player, gaData)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end

		if not state.Initialized then
			logger:w("Cannot start new session. SDK is not initialized yet.")
			return
		end

		state:startNewSession(player, gaData)
	end)
end

function ga:endSession(playerId: number)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		state:endSession(playerId)
	end)
end

function ga:filterForBusinessEvent(text: string)
	return string.gsub(text, "[^A-Za-z0-9%s%-_%.%(%)!%?]", "")
end

function ga:addBusinessEvent(playerId: number | BusinessEventOptions, options: BusinessEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add business event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addBusinessEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addBusinessEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local amount = options["amount"] or 0
		local itemType = options["itemType"] or ""
		local itemId = options["itemId"] or ""
		local cartType = options["cartType"] or ""
		local USDSpent = math.floor((amount * 0.7) * 0.35)
		local gamepassId = options["gamepassId"] or nil
		local customFields = options["customFields"]

		events:addBusinessEvent(playerId, "USD", USDSpent, itemType, itemId, cartType, customFields)

		if itemType == "Gamepass" and cartType ~= "Website" then
			local player = Players:GetPlayerByUserId(playerId)
			local playerData = store:GetPlayerDataFromCache(playerId)
			if not playerData.OwnedGamepasses then
				playerData.OwnedGamepasses = {}
			end
			table.insert(playerData.OwnedGamepasses, gamepassId)
			store.PlayerCache[playerId] = playerData
			store:SavePlayerData(player)
		end
	end)
end

function ga:addResourceEvent(playerId: number | ResourceEventOptions, options: ResourceEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add resource event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addResourceEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addResourceEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local flowType = options["flowType"] or 0
		local currency = options["currency"] or ""
		local amount = options["amount"] or 0
		local itemType = options["itemType"] or ""
		local itemId = options["itemId"] or ""
		local customFields = options["customFields"]

		events:addResourceEvent(playerId, flowType, currency, amount, itemType, itemId, customFields)
	end)
end

function ga:addProgressionEvent(playerId: number | ProgressionEventOptions, options: ProgressionEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add progression event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addProgressionEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addProgressionEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local progressionStatus = options["progressionStatus"] or 0
		local progression01 = options["progression01"] or ""
		local progression02 = options["progression02"] or nil
		local progression03 = options["progression03"] or nil
		local score = options["score"] or nil
		local customFields = options["customFields"]

		events:addProgressionEvent(
			playerId,
			progressionStatus,
			progression01,
			progression02,
			progression03,
			score,
			customFields
		)
	end)
end

function ga:addDesignEvent(playerId: number | DesignEventOptions, options: DesignEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add design event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addDesignEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addDesignEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local eventId = options["eventId"] or ""
		local value = options["value"] or nil
		local customFields = options["customFields"]

		events:addDesignEvent(playerId, eventId, value, customFields)
	end)
end

function ga:addErrorEvent(playerId: number | ErrorEventOptions, options: ErrorEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add error event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addErrorEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addErrorEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local severity = options["severity"] or 0
		local message = options["message"] or ""
		local customFields = options["customFields"]

		events:addErrorEvent(playerId, severity, message, customFields)
	end)
end

function ga:setEnabledDebugLog(flag: boolean)
	if RunService:IsStudio() then
		if flag then
			logger:setDebugLog(flag)
			logger:i("Debug logging enabled")
		else
			logger:i("Debug logging disabled")
			logger:setDebugLog(flag)
		end
	else
		logger:i("setEnabledDebugLog can only be used in studio")
	end
end

function ga:setEnabledInfoLog(flag: boolean)
	if flag then
		logger:setInfoLog(flag)
		logger:i("Info logging enabled")
	else
		logger:i("Info logging disabled")
		logger:setInfoLog(flag)
	end
end

function ga:setEnabledVerboseLog(flag: boolean)
	if flag then
		logger:setVerboseLog(flag)
		logger:ii("Verbose logging enabled")
	else
		logger:ii("Verbose logging disabled")
		logger:setVerboseLog(flag)
	end
end

function ga:setEnabledEventSubmission(flag: boolean)
	threading:performTaskOnGAThread(function()
		if flag then
			state:setEventSubmission(flag)
			logger:i("Event submission enabled")
		else
			logger:i("Event submission disabled")
			state:setEventSubmission(flag)
		end
	end)
end

function ga:setCustomDimension01(playerId: number | CustomDimension, dimension: CustomDimension?)
	threading:performTaskOnGAThread(function()
		if not validation:validateDimension(state._availableCustomDimensions01, dimension) then
			logger:w(
				"Could not set custom01 dimension value to '"
					.. (dimension or "")
					.. "'. Value not found in available custom01 dimension values"
			)
			return
		end

		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = true,
				message = "Could not set custom01 dimension",
			})
		then
			return
		end

		state:setCustomDimension01(playerId, dimension)
	end)
end

function ga:setCustomDimension02(playerId: number | CustomDimension, dimension: CustomDimension?)
	threading:performTaskOnGAThread(function()
		if not validation:validateDimension(state._availableCustomDimensions02, dimension) then
			logger:w(
				"Could not set custom02 dimension value to '"
					.. (dimension or "")
					.. "'. Value not found in available custom02 dimension values"
			)
			return
		end

		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = true,
				message = "Could not set custom02 dimension",
			})
		then
			return
		end

		state:setCustomDimension02(playerId, dimension)
	end)
end

function ga:setCustomDimension03(playerId: number | CustomDimension, dimension: CustomDimension?)
	threading:performTaskOnGAThread(function()
		if not validation:validateDimension(state._availableCustomDimensions03, dimension) then
			logger:w(
				"Could not set custom03 dimension value to '"
					.. (dimension or "")
					.. "'. Value not found in available custom03 dimension values"
			)
			return
		end

		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = true,
				message = "Could not set custom03 dimension",
			})
		then
			return
		end

		state:setCustomDimension03(playerId, dimension)
	end)
end

function ga:setEnabledReportErrors(flag: boolean)
	threading:performTaskOnGAThread(function()
		state.ReportErrors = flag
	end)
end

function ga:setEnabledCustomUserId(flag: boolean)
	threading:performTaskOnGAThread(function()
		state.UseCustomUserId = flag
	end)
end

function ga:setEnabledAutomaticSendBusinessEvents(flag: boolean)
	threading:performTaskOnGAThread(function()
		state.AutomaticSendBusinessEvents = flag
	end)
end

function ga:addGameAnalyticsTeleportData(playerIds: { number }, teleportData: TeleportData)
	local gameAnalyticsTeleportData = {}
	for _, playerId in ipairs(playerIds) do
		local PlayerData = store:GetPlayerDataFromCache(playerId)
		PlayerData.PlayerTeleporting = true
		local data = {
			["SessionID"] = PlayerData.SessionID,
			["Sessions"] = PlayerData.Sessions,
			["SessionStart"] = PlayerData.SessionStart,
		}

		gameAnalyticsTeleportData[tostring(playerId)] = data
	end

	teleportData["gameanalyticsData"] = gameAnalyticsTeleportData

	return teleportData
end

function ga:getRemoteConfigsValueAsString(playerId: number | RemoteConfigs, options: RemoteConfigs)
	local key = options["key"] or ""
	local defaultValue = options["defaultValue"] or nil
	return state:getRemoteConfigsStringValue(playerId, key, defaultValue)
end

function ga:isRemoteConfigsReady(playerId: number)
	return state:isRemoteConfigsReady(playerId)
end

function ga:getRemoteConfigsContentAsString(playerId: number)
	return state:getRemoteConfigsContentAsString(playerId)
end

function ga:PlayerJoined(Player: Player)
	local joinData = Player:GetJoinData()
	local teleportData = joinData.TeleportData
	local gaData = nil

	--Variables
	local PlayerData = store:GetPlayerData(Player)

	if teleportData and typeof(teleportData) == "table" then
		gaData = teleportData.gameanalyticsData and teleportData.gameanalyticsData[tostring(Player.UserId)]
	end

	local pd = store:GetPlayerDataFromCache(Player.UserId)
	if pd then
		if gaData then
			pd.SessionID = gaData.SessionID
			pd.SessionStart = gaData.SessionStart
		end
		pd.PlayerTeleporting = false
		return
	end

	local PlayerPlatform = "unknown"
	local isGetPlatformSuccessful, platform = Postie.invokeClient("getPlatform", Player, 5)
	if isGetPlatformSuccessful then
		PlayerPlatform = platform
	end

	--Fill Data
	for key, value in pairs(store.BasePlayerData) do
		if PlayerData[key] then
			continue
		end

		if typeof(value) == "table" then
			PlayerData[key] = utilities:copyTable(value)
		else
			PlayerData[key] = value
		end
	end

	local countryCodeResult, countryCode = pcall(function()
		return LocalizationService:GetCountryRegionForPlayerAsync(Player)
	end)

	if countryCodeResult then
		PlayerData.CountryCode = countryCode
	end

	store.PlayerCache[Player.UserId] = PlayerData

	PlayerData.Platform = (PlayerPlatform == "Console" and "uwp_console")
		or (PlayerPlatform == "Mobile" and "uwp_mobile")
		or (PlayerPlatform == "Desktop" and "uwp_desktop")
		or "uwp_desktop"
	PlayerData.OS = PlayerData.Platform .. " 0.0.0"

	if not countryCodeResult then
		events:addSdkErrorEvent(
			Player.UserId,
			"event_validation",
			"player_joined",
			"string_empty_or_null",
			"country_code",
			""
		)
	end

	local PlayerCustomUserId = ""
	if state.UseCustomUserId then
		local isGetCustomUserIdSuccessful, customUserId = Postie.invokeClient("getCustomUserId", Player, 5)
		if isGetCustomUserIdSuccessful then
			PlayerCustomUserId = customUserId
		end
	end

	if not utilities:isStringNullOrEmpty(PlayerCustomUserId) then
		logger:i("Using custom id: " .. PlayerCustomUserId)
		PlayerData.CustomUserId = PlayerCustomUserId
	end

	ga:startNewSession(Player, gaData)

	OnPlayerReadyEvent = OnPlayerReadyEvent or ReplicatedStorage:WaitForChild("OnPlayerReadyEvent")
	OnPlayerReadyEvent:Fire(Player)

	--Validate
	if state.AutomaticSendBusinessEvents then
		--Website gamepasses
		if PlayerData.OwnedGamepasses == nil then --player is new (or is playing after SDK update)
			PlayerData.OwnedGamepasses = {}
			for _, id in ipairs(state._availableGamepasses) do
				if MKT:UserOwnsGamePassAsync(Player.UserId, id) then
					table.insert(PlayerData.OwnedGamepasses, id)
				end
			end
			--Player's data is now up to date. gamepass purchases on website can now be tracked in future visits
			store.PlayerCache[Player.UserId] = PlayerData
			store:SavePlayerData(Player)
		else
			--build a list of the game passes a user owns
			local currentlyOwned = {}
			for _, id in ipairs(state._availableGamepasses) do
				if MKT:UserOwnsGamePassAsync(Player.UserId, id) then
					table.insert(currentlyOwned, id)
				end
			end

			--make a table so it's easier to compare to stored game passes
			local storedGamepassesTable = {}
			for _, id in ipairs(PlayerData.OwnedGamepasses) do
				storedGamepassesTable[id] = true
			end

			--compare stored game passes to currently owned game passses
			for _, id in ipairs(currentlyOwned) do
				if not storedGamepassesTable[id] then
					table.insert(PlayerData.OwnedGamepasses, id)

					local gamepassInfo = ProductCache[id]

					--Cache
					if not gamepassInfo then
						--Get
						gamepassInfo = MKT:GetProductInfo(id, Enum.InfoType.GamePass)
						ProductCache[id] = gamepassInfo
					end

					ga:addBusinessEvent(Player.UserId, {
						amount = gamepassInfo.PriceInRobux,
						itemType = "Gamepass",
						itemId = ga:filterForBusinessEvent(gamepassInfo.Name),
						cartType = "Website",
					})
				end
			end

			store.PlayerCache[Player.UserId] = PlayerData

			store:SavePlayerData(Player)
		end
	end

	local playerEventQueue = InitializationQueueByUserId[Player.UserId]
	if playerEventQueue then
		InitializationQueueByUserId[Player.UserId] = nil
		for _, queuedFunction in ipairs(playerEventQueue) do
			queuedFunction.Func(unpack(queuedFunction.Args))
		end

		logger:i("Player initialization queue called #" .. #playerEventQueue .. " events")
	end
end

function ga:PlayerRemoved(Player: Player)
	--Save
	store:SavePlayerData(Player)

	local PlayerData = store:GetPlayerDataFromCache(Player.UserId)
	if PlayerData then
		if not PlayerData.PlayerTeleporting then
			ga:endSession(Player.UserId)
		else
			store.PlayerCache[Player.UserId] = nil
			store.DataStoreQueue.RemoveKey(Player.UserId)
		end
	end
end

function ga:isPlayerReady(playerId: number)
	if store:GetPlayerDataFromCache(playerId) then
		return true
	else
		return false
	end
end

function ga:ProcessReceiptCallback(Info: ProcessReceiptInfo)
	--Variables
	local ProductInfo = ProductCache[Info.ProductId] :: ProductInfo?

	--Cache
	if not ProductInfo then
		pcall(function()
			ProductInfo = MKT:GetProductInfo(Info.ProductId, Enum.InfoType.Product)
			ProductCache[Info.ProductId] = ProductInfo
		end)
	end

	if ProductInfo then
		ga:addBusinessEvent(Info.PlayerId, {
			amount = Info.CurrencySpent,
			itemType = "DeveloperProduct",
			itemId = ga:filterForBusinessEvent(ProductInfo.Name),
		})
	end
end

--customGamepassInfo argument to optinaly provide our own name or price
function ga:GamepassPurchased(player: Player, id: number, customGamepassInfo: ProductInfo?)
	local gamepassInfo = ProductCache[id]

	--Cache
	if not gamepassInfo then
		--Get
		gamepassInfo = MKT:GetProductInfo(id, Enum.InfoType.GamePass)
		ProductCache[id] = gamepassInfo
	end

	local amount = 0
	local itemId = "GamePass"
	if customGamepassInfo then
		amount = customGamepassInfo.PriceInRobux
		itemId = customGamepassInfo.Name
	elseif gamepassInfo then
		amount = gamepassInfo.PriceInRobux
		itemId = gamepassInfo.Name
	end

	ga:addBusinessEvent(player.UserId, {
		amount = amount or 0,
		itemType = "Gamepass",
		itemId = ga:filterForBusinessEvent(itemId),
		gamepassId = id,
	})
end

local requiredInitializationOptions = { "gameKey", "secretKey" }

function ga:initServer(gameKey: string, secretKey: string)
	ga:initialize({
		gameKey = gameKey,
		secretKey = secretKey,
	})
end

function ga:initialize(options: GameAnalyticsOptions)
	threading:performTaskOnGAThread(function()
		for _, option in ipairs(requiredInitializationOptions) do
			if options[option] == nil then
				logger:e("Initialize '" .. option .. "' option missing")
				return
			end
		end
		if options.enableInfoLog ~= nil and options.enableInfoLog then
			ga:setEnabledInfoLog(options.enableInfoLog)
		end
		if options.enableVerboseLog ~= nil and options.enableVerboseLog then
			ga:setEnabledVerboseLog(options.enableVerboseLog)
		end
		if options.availableCustomDimensions01 ~= nil and #options.availableCustomDimensions01 > 0 then
			ga:configureAvailableCustomDimensions01(options.availableCustomDimensions01)
		end
		if options.availableCustomDimensions02 ~= nil and #options.availableCustomDimensions02 > 0 then
			ga:configureAvailableCustomDimensions02(options.availableCustomDimensions02)
		end
		if options.availableCustomDimensions03 ~= nil and #options.availableCustomDimensions03 > 0 then
			ga:configureAvailableCustomDimensions03(options.availableCustomDimensions03)
		end
		if options.availableResourceCurrencies ~= nil and #options.availableResourceCurrencies > 0 then
			ga:configureAvailableResourceCurrencies(options.availableResourceCurrencies)
		end
		if options.availableResourceItemTypes ~= nil and #options.availableResourceItemTypes > 0 then
			ga:configureAvailableResourceItemTypes(options.availableResourceItemTypes)
		end
		if options.build ~= nil and #options.build > 0 then
			ga:configureBuild(options.build)
		end
		if options.availableGamepasses ~= nil and #options.availableGamepasses > 0 then
			ga:configureAvailableGamepasses(options.availableGamepasses)
		end
		if options.enableDebugLog ~= nil then
			ga:setEnabledDebugLog(options.enableDebugLog)
		end

		if options.automaticSendBusinessEvents ~= nil then
			ga:setEnabledAutomaticSendBusinessEvents(options.automaticSendBusinessEvents)
		end
		if options.reportErrors ~= nil then
			ga:setEnabledReportErrors(options.reportErrors)
		end

		if options.useCustomUserId ~= nil then
			ga:setEnabledCustomUserId(options.useCustomUserId)
		end

		if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
			logger:w("SDK already initialized. Can only be called once.")
			return
		end

		local gameKey = options["gameKey"]
		local secretKey = options["secretKey"]

		if not validation:validateKeys(gameKey, secretKey) then
			logger:w(
				"SDK failed initialize. Game key or secret key is invalid. Can only contain characters A-z 0-9, gameKey is 32 length, secretKey is 40 length. Failed keys - gameKey: "
					.. gameKey
					.. ", secretKey: "
					.. secretKey
			)
			return
		end

		events.GameKey = gameKey
		events.SecretKey = secretKey

		state.Initialized = true

		-- New Players
		Players.PlayerAdded:Connect(function(Player)
			ga:PlayerJoined(Player)
		end)

		-- Players leaving
		Players.PlayerRemoving:Connect(function(Player)
			ga:PlayerRemoved(Player)
		end)

		-- Fire for players already in game
		for _, Player in ipairs(Players:GetPlayers()) do
			coroutine.wrap(ga.PlayerJoined)(ga, Player)
		end

		for _, queuedFunction in ipairs(InitializationQueue) do
			task.spawn(queuedFunction.Func, unpack(queuedFunction.Args))
		end
		logger:i("Server initialization queue called #" .. #InitializationQueue .. " events")
		InitializationQueue = {}

		events:processEventQueue()
	end)
end

if not ReplicatedStorage:FindFirstChild("GameAnalyticsRemoteConfigs") then
	--Create
	local f = Instance.new("RemoteEvent")
	f.Name = "GameAnalyticsRemoteConfigs"
	f.Parent = ReplicatedStorage
end

if not ReplicatedStorage:FindFirstChild("OnPlayerReadyEvent") then
	--Create
	local f = Instance.new("BindableEvent")
	f.Name = "OnPlayerReadyEvent"
	f.Parent = ReplicatedStorage
end

task.spawn(function()
	local currentHour = math.floor(os.time() / 3600)
	ErrorDS = store:GetErrorDataStore(currentHour)

	while task.wait(ONE_HOUR_IN_SECONDS) do
		currentHour = math.floor(os.time() / 3600)
		ErrorDS = store:GetErrorDataStore(currentHour)
		errorCountCache = {}
		errorCountCacheKeys = {}
	end
end)

task.spawn(function()
	while task.wait(store.AutoSaveData) do
		for _, key in pairs(errorCountCacheKeys) do
			local errorCount = errorCountCache[key]
			local step = errorCount.currentCount - errorCount.countInDS
			errorCountCache[key].countInDS = store:IncrementErrorCount(ErrorDS, key, step)
			errorCountCache[key].currentCount = errorCountCache[key].countInDS
		end
	end
end)

local function ErrorHandler(message, trace, scriptName, player)
	local scriptNameTmp = "(null)"
	if scriptName ~= nil then
		scriptNameTmp = scriptName
	end
	local messageTmp = "(null)"
	if message ~= nil then
		messageTmp = message
	end
	local traceTmp = "(null)"
	if trace ~= nil then
		traceTmp = trace
	end
	local m = scriptNameTmp .. ": message=" .. messageTmp .. ", trace=" .. traceTmp
	if #m > 8192 then
		m = string.sub(m, 1, 8192)
	end

	local userId = nil
	if player then
		userId = player.UserId
		m = m:gsub(player.Name, "[LocalPlayer]") -- so we don't flood the same errors with different player names
	end

	local key = m
	if #key > 50 then
		key = string.sub(key, 1, 50)
	end

	if errorCountCache[key] == nil then
		errorCountCacheKeys[#errorCountCacheKeys + 1] = key
		errorCountCache[key] = {}
		errorCountCache[key].countInDS = 0
		errorCountCache[key].currentCount = 0
	end

	-- don't report error if limit has been exceeded
	if errorCountCache[key].currentCount > MaxErrorsPerHour then
		return
	end

	ga:addErrorEvent(userId, {
		severity = ga.EGAErrorSeverity.error,
		message = m,
	})

	-- increment error count
	errorCountCache[key].currentCount = errorCountCache[key].currentCount + 1
end

local function ErrorHandlerFromServer(message, trace, Script)
	--Validate
	if not state.ReportErrors then
		return
	end

	if not Script then -- don't remember if this check is necessary but must have added it for a reason
		return
	end

	local scriptName = nil
	local ok, _ = pcall(function()
		scriptName = Script:GetFullName() -- CoreGui.RobloxGui.Modules.PlayerList error, can't get name because of security permission
	end)
	if not ok then
		return
	end

	return ErrorHandler(message, trace, scriptName)
end

local function ErrorHandlerFromClient(message, trace, scriptName, player)
	--Validate
	if not state.ReportErrors then
		return
	end

	return ErrorHandler(message, trace, scriptName, player)
end

--Error Logging
ScriptContext.Error:Connect(ErrorHandlerFromServer)
if not ReplicatedStorage:FindFirstChild("GameAnalyticsError") then
	--Create
	local f = Instance.new("RemoteEvent")
	f.Name = "GameAnalyticsError"
	f.Parent = ReplicatedStorage
end

ReplicatedStorage.GameAnalyticsError.OnServerEvent:Connect(function(player, message, trace, scriptName)
	ErrorHandlerFromClient(message, trace, scriptName, player)
end)

--Record Gamepasses.
MKT.PromptGamePassPurchaseFinished:Connect(function(Player, ID, Purchased)
	--Validate
	if not state.AutomaticSendBusinessEvents or not Purchased then
		return
	end

	ga:GamepassPurchased(Player, ID)
end)

return ga]]></ProtectedString>
							<string name="ScriptGuid">{328E11C9-C388-424D-A26F-B116A380A27B}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">GameAnalytics.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX2B7DDB39D282406D92F0113D6E919B75">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">GameAnalytics</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXB240437D601E47B9BB188368B2F6BF41">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local events = {
	ProcessEventsInterval = 8,
	GameKey = "",
	SecretKey = "",
	Build = "",
	_availableResourceCurrencies = {},
	_availableResourceItemTypes = {},
}

local store = require(script.Parent.Store)
local logger = require(script.Parent.Logger)
local version = require(script.Parent.Version)
local validation = require(script.Parent.Validation)
local threading = require(script.Parent.Threading)
local http_api = require(script.Parent.HttpApi)
local utilities = require(script.Parent.Utilities)
local GAResourceFlowType = require(script.Parent.GAResourceFlowType)
local GAProgressionStatus = require(script.Parent.GAProgressionStatus)
local GAErrorSeverity = require(script.Parent.GAErrorSeverity)
local HTTP = game:GetService("HttpService")

local CategorySessionStart = "user"
local CategorySessionEnd = "session_end"
local CategoryBusiness = "business"
local CategoryResource = "resource"
local CategoryProgression = "progression"
local CategoryDesign = "design"
local CategoryError = "error"
local CategorySdkError = "sdk_error"
local MAX_EVENTS_TO_SEND_IN_ONE_BATCH = 500
local MAX_AGGREGATED_EVENTS = 2000

local function addCustomFieldsToEvent(eventData, customFields)
	if not (eventData and customFields) then
		return
	end

	local fields = {}

	for key, value in pairs(customFields) do
		local v = tostring(value)
		if #v > 256 then
			logger:w("Custom field value is too long. Max length is 256 characters. Field: " .. key)
			v = string.sub(v, 1, 256)
		end

		fields[key] = v
	end

	if fields and next(fields) then
		eventData["custom_fields"] = fields
	end
end

local function addDimensionsToEvent(playerId, eventData)
	if not eventData or not playerId then
		return
	end

	local PlayerData = store:GetPlayerDataFromCache(playerId)

	-- add to dict (if not nil)
	if PlayerData and PlayerData.CurrentCustomDimension01 and #PlayerData.CurrentCustomDimension01 > 0 then
		eventData["custom_01"] = PlayerData.CurrentCustomDimension01
	end

	if PlayerData and PlayerData.CurrentCustomDimension02 and #PlayerData.CurrentCustomDimension02 > 0 then
		eventData["custom_02"] = PlayerData.CurrentCustomDimension02
	end

	if PlayerData and PlayerData.CurrentCustomDimension03 and #PlayerData.CurrentCustomDimension03 > 0 then
		eventData["custom_03"] = PlayerData.CurrentCustomDimension03
	end
end

local function getClientTsAdjusted(playerId)
	if not playerId then
		return os.time()
	end

	local PlayerData = store:GetPlayerDataFromCache(playerId)
	local clientTs = os.time()
	local clientTsAdjustedInteger = clientTs + PlayerData.ClientServerTimeOffset
	if validation:validateClientTs(clientTsAdjustedInteger) then
		return clientTsAdjustedInteger
	else
		return clientTs
	end
end

local DUMMY_SESSION_ID = HTTP:GenerateGUID(false):lower()

local function Length(Table)
	local counter = 0
	for _, _ in pairs(Table) do
		counter += 1
	end
	return counter
end

local function getEventAnnotations(playerId)
	local PlayerData
	local id

	if playerId then
		id = playerId
		PlayerData = store:GetPlayerDataFromCache(playerId)
	else
		id = "DummyId"
		PlayerData = {
			OS = "uwp_desktop 0.0.0",
			Platform = "uwp_desktop",
			SessionID = DUMMY_SESSION_ID,
			Sessions = 1,
			CustomUserId = "Server",
		}
	end

	local annotations = {
		-- ---- REQUIRED ----
		-- collector event API version
		["v"] = 2,
		-- User identifier
		["user_id"] = tostring(id) .. PlayerData.CustomUserId,
		-- Client Timestamp (the adjusted timestamp)
		["client_ts"] = getClientTsAdjusted(playerId),
		-- SDK version
		["sdk_version"] = "roblox " .. version.SdkVersion,
		-- Operation system version
		["os_version"] = PlayerData.OS,
		-- Device make (hardcoded to apple)
		["manufacturer"] = "unknown",
		-- Device version
		["device"] = "unknown",
		-- Platform (operating system)
		["platform"] = PlayerData.Platform,
		-- Session identifier
		["session_id"] = PlayerData.SessionID,
		-- Session number
		["session_num"] = PlayerData.Sessions,
	}

	if not utilities:isStringNullOrEmpty(PlayerData.CountryCode) then
		annotations["country_code"] = PlayerData.CountryCode
	else
		annotations["country_code"] = "unknown"
	end

	if validation:validateBuild(events.Build) then
		annotations["build"] = events.Build
	end

	if PlayerData.Configurations and Length(PlayerData.Configurations) > 0 then
		annotations["configurations"] = PlayerData.Configurations
	end

	if not utilities:isStringNullOrEmpty(PlayerData.AbId) then
		annotations["ab_id"] = PlayerData.AbId
	end

	if not utilities:isStringNullOrEmpty(PlayerData.AbVariantId) then
		annotations["ab_variant_id"] = PlayerData.AbVariantId
	end

	return annotations
end

local function addEventToStore(playerId, eventData)
	-- Get default annotations
	local ev = getEventAnnotations(playerId)

	-- Merge with eventData
	for k in pairs(eventData) do
		ev[k] = eventData[k]
	end

	-- Create json string representation
	local json = HTTP:JSONEncode(ev)

	-- output if VERBOSE LOG enabled
	logger:ii("Event added to queue: " .. json)

	-- Add to store
	store.EventsQueue[#store.EventsQueue + 1] = ev
end

local function dequeueMaxEvents()
	if #store.EventsQueue <= MAX_EVENTS_TO_SEND_IN_ONE_BATCH then
		local eventsQueue = store.EventsQueue
		store.EventsQueue = {}
		return eventsQueue
	else
		logger:w(
			("More than %d events queued! Sending %d."):format(
				MAX_EVENTS_TO_SEND_IN_ONE_BATCH,
				MAX_EVENTS_TO_SEND_IN_ONE_BATCH
			)
		)

		if #store.EventsQueue > MAX_AGGREGATED_EVENTS then
			logger:w(("DROPPING EVENTS: More than %d events queued!"):format(MAX_AGGREGATED_EVENTS))
		end

		-- Expensive operation to get ordered events cleared out (O(n))
		local eventsQueue = table.create(MAX_EVENTS_TO_SEND_IN_ONE_BATCH)
		for i = 1, MAX_EVENTS_TO_SEND_IN_ONE_BATCH do
			eventsQueue[i] = store.EventsQueue[i]
		end

		-- Shift everything down and overwrite old events
		local eventCount = #store.EventsQueue
		for i = 1, math.min(MAX_AGGREGATED_EVENTS, eventCount) do
			store.EventsQueue[i] = store.EventsQueue[i + MAX_EVENTS_TO_SEND_IN_ONE_BATCH]
		end

		-- Clear additional events
		for i = MAX_AGGREGATED_EVENTS + 1, eventCount do
			store.EventsQueue[i] = nil
		end

		return eventsQueue
	end
end

local function processEvents()
	local queue = dequeueMaxEvents()

	if #queue == 0 then
		logger:i("Event queue: No events to send")
		return
	end

	-- Log
	logger:i("Event queue: Sending " .. tostring(#queue) .. " events.")

	local eventsResult = http_api:sendEventsInArray(events.GameKey, events.SecretKey, queue)
	local statusCode = eventsResult.statusCode
	local responseBody = eventsResult.body

	if statusCode == http_api.EGAHTTPApiResponse.Ok and responseBody then
		logger:i("Event queue: " .. tostring(#queue) .. " events sent.")
	else
		if statusCode == http_api.EGAHTTPApiResponse.NoResponse then
			logger:w("Event queue: Failed to send events to collector - Retrying next time")
			for _, e in pairs(queue) do
				if #store.EventsQueue < MAX_AGGREGATED_EVENTS then
					store.EventsQueue[#store.EventsQueue + 1] = e
				else
					break
				end
			end
		else
			if statusCode == http_api.EGAHTTPApiResponse.BadRequest and responseBody then
				logger:w(
					"Event queue: "
						.. tostring(#queue)
						.. " events sent. "
						.. tostring(#responseBody)
						.. " events failed GA server validation."
				)
			else
				logger:w("Event queue: Failed to send events.")
			end
		end
	end
end

function events:processEventQueue()
	processEvents()
	threading:scheduleTimer(events.ProcessEventsInterval, function()
		events:processEventQueue()
	end)
end

function events:setBuild(build)
	if not validation:validateBuild(build) then
		logger:w("Validation fail - configure build: Cannot be null, empty or above 32 length. String: " .. build)
		return
	end

	self.Build = build
	logger:i("Set build version: " .. build)
end

function events:setAvailableResourceCurrencies(availableResourceCurrencies)
	if not validation:validateResourceCurrencies(availableResourceCurrencies) then
		return
	end

	self._availableResourceCurrencies = availableResourceCurrencies
	logger:i("Set available resource currencies: (" .. table.concat(availableResourceCurrencies, ", ") .. ")")
end

function events:setAvailableResourceItemTypes(availableResourceItemTypes)
	if not validation:validateResourceCurrencies(availableResourceItemTypes) then
		return
	end

	self._availableResourceItemTypes = availableResourceItemTypes
	logger:i("Set available resource item types: (" .. table.concat(availableResourceItemTypes, ", ") .. ")")
end

function events:addSessionStartEvent(playerId, teleportData, customFields)
	local PlayerData = store:GetPlayerDataFromCache(playerId)

	if teleportData then
		PlayerData.Sessions = teleportData.Sessions
	else
		local eventDict = {}

		-- Event specific data
		eventDict["category"] = CategorySessionStart

		-- Increment session number  and persist
		PlayerData.Sessions = PlayerData.Sessions + 1

		--  Add custom dimensions
		addDimensionsToEvent(playerId, eventDict)

		-- Add to store
		addEventToStore(playerId, eventDict)
		addCustomFieldsToEvent(eventDict, customFields)

		logger:i("Add SESSION START event")

		processEvents()
	end
end

function events:addSessionEndEvent(playerId, customFields)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	local session_start_ts = PlayerData.SessionStart
	local client_ts_adjusted = getClientTsAdjusted(playerId)
	local sessionLength = 0

	if client_ts_adjusted ~= nil and session_start_ts ~= nil then
		sessionLength = client_ts_adjusted - session_start_ts
	end

	if sessionLength < 0 then
		-- Should never happen.
		-- Could be because of edge cases regarding time altering on device.
		logger:w("Session length was calculated to be less then 0. Should not be possible. Resetting to 0.")
		sessionLength = 0
	end

	-- Event specific data
	local eventDict = {}
	eventDict["category"] = CategorySessionEnd
	eventDict["length"] = sessionLength

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventDict)
	addCustomFieldsToEvent(eventDict, customFields)

	-- Add to store
	addEventToStore(playerId, eventDict)
	PlayerData.SessionStart = 0

	logger:i("Add SESSION END event.")

	processEvents()
end

function events:addBusinessEvent(playerId, currency, amount, itemType, itemId, cartType, customFields)
	-- Validate event params
	if not validation:validateBusinessEvent(currency, amount, cartType, itemType, itemId) then
		-- TODO: add sdk error event
		return
	end

	-- Create empty eventData
	local eventDict = {}

	-- Increment transaction number and persist
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	PlayerData.Transactions = PlayerData.Transactions + 1

	-- Required
	eventDict["event_id"] = itemType .. ":" .. itemId
	eventDict["category"] = CategoryBusiness
	eventDict["currency"] = currency
	eventDict["amount"] = amount
	eventDict["transaction_num"] = PlayerData.Transactions

	-- Optional
	if not utilities:isStringNullOrEmpty(cartType) then
		eventDict["cart_type"] = cartType
	end

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventDict)
	addCustomFieldsToEvent(eventDict, customFields)

	logger:i(
		"Add BUSINESS event: {currency:"
			.. currency
			.. ", amount:"
			.. tostring(amount)
			.. ", itemType:"
			.. itemType
			.. ", itemId:"
			.. itemId
			.. ", cartType:"
			.. cartType
			.. "}"
	)

	-- Send to store
	addEventToStore(playerId, eventDict)
end

function events:addResourceEvent(playerId, flowType, currency, amount, itemType, itemId, customFields)
	-- Validate event params
	if
		not validation:validateResourceEvent(
			GAResourceFlowType,
			flowType,
			currency,
			amount,
			itemType,
			itemId,
			self._availableResourceCurrencies,
			self._availableResourceItemTypes
		)
	then
		-- TODO: add sdk error event
		return
	end

	-- If flow type is sink reverse amount
	if flowType == GAResourceFlowType.Sink then
		amount = (-1 * amount)
	end

	-- Create empty eventData
	local eventDict = {}

	-- insert event specific values
	local flowTypeString = GAResourceFlowType[flowType]
	eventDict["event_id"] = flowTypeString .. ":" .. currency .. ":" .. itemType .. ":" .. itemId
	eventDict["category"] = CategoryResource
	eventDict["amount"] = amount

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventDict)
	addCustomFieldsToEvent(eventDict, customFields)

	logger:i(
		"Add RESOURCE event: {currency:"
			.. currency
			.. ", amount:"
			.. tostring(amount)
			.. ", itemType:"
			.. itemType
			.. ", itemId:"
			.. itemId
			.. "}"
	)

	-- Send to store
	addEventToStore(playerId, eventDict)
end

function events:addProgressionEvent(
	playerId,
	progressionStatus,
	progression01,
	progression02,
	progression03,
	score,
	customFields
)
	-- Validate event params
	if
		not validation:validateProgressionEvent(
			GAProgressionStatus,
			progressionStatus,
			progression01,
			progression02,
			progression03
		)
	then
		-- TODO: add sdk error event
		return
	end

	-- Create empty eventData
	local eventDict = {}

	-- Progression identifier
	local progressionIdentifier
	if utilities:isStringNullOrEmpty(progression02) then
		progressionIdentifier = progression01
	elseif utilities:isStringNullOrEmpty(progression03) then
		progressionIdentifier = progression01 .. ":" .. progression02
	else
		progressionIdentifier = progression01 .. ":" .. progression02 .. ":" .. progression03
	end

	local statusString = GAProgressionStatus[progressionStatus]

	-- Append event specifics
	eventDict["category"] = CategoryProgression
	eventDict["event_id"] = statusString .. ":" .. progressionIdentifier

	-- Attempt
	local attempt_num = 0

	-- Add score if specified and status is not start
	if score ~= nil and progressionStatus ~= GAProgressionStatus.Start then
		eventDict["score"] = score
	end

	local PlayerData = store:GetPlayerDataFromCache(playerId)

	-- Count attempts on each progression fail and persist
	if progressionStatus == GAProgressionStatus.Fail then
		-- Increment attempt number
		local progressionTries = PlayerData.ProgressionTries[progressionIdentifier] or 0
		PlayerData.ProgressionTries[progressionIdentifier] = progressionTries + 1
	end

	-- increment and add attempt_num on complete and delete persisted
	if progressionStatus == GAProgressionStatus.Complete then
		-- Increment attempt number
		local progressionTries = PlayerData.ProgressionTries[progressionIdentifier] or 0
		PlayerData.ProgressionTries[progressionIdentifier] = progressionTries + 1

		-- Add to event
		attempt_num = PlayerData.ProgressionTries[progressionIdentifier]
		eventDict["attempt_num"] = attempt_num

		-- Clear
		PlayerData.ProgressionTries[progressionIdentifier] = 0
	end

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventDict)
	addCustomFieldsToEvent(eventDict, customFields)

	local progression02String = ""
	if not utilities:isStringNullOrEmpty(progression02) then
		progression02String = progression02
	end

	local progression03String = ""
	if not utilities:isStringNullOrEmpty(progression03) then
		progression03String = progression03
	end

	logger:i(
		"Add PROGRESSION event: {status:"
			.. statusString
			.. ", progression01:"
			.. progression01
			.. ", progression02:"
			.. progression02String
			.. ", progression03:"
			.. progression03String
			.. ", score:"
			.. tostring(score)
			.. ", attempt:"
			.. tostring(attempt_num)
			.. "}"
	)

	-- Send to store
	addEventToStore(playerId, eventDict)
end

function events:addDesignEvent(playerId, eventId, value, customFields)
	-- Validate
	if not validation:validateDesignEvent(eventId) then
		-- TODO: add sdk error event
		return
	end

	-- Create empty eventData
	local eventData = {}

	-- Append event specifics
	eventData["category"] = CategoryDesign
	eventData["event_id"] = eventId

	if value ~= nil then
		eventData["value"] = value
	end

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventData)
	addCustomFieldsToEvent(eventData, customFields)

	logger:i("Add DESIGN event: {eventId:" .. eventId .. ", value:" .. tostring(value) .. "}")

	-- Send to store
	addEventToStore(playerId, eventData)
end

function events:addErrorEvent(playerId, severity, message, customFields)
	-- Validate
	if not validation:validateErrorEvent(GAErrorSeverity, severity, message) then
		-- TODO: add sdk error event
		return
	end

	-- Create empty eventData
	local eventData = {}

	local severityString = GAErrorSeverity[severity]

	eventData["category"] = CategoryError
	eventData["severity"] = severityString
	eventData["message"] = message

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventData)
	addCustomFieldsToEvent(eventData, customFields)

	local messageString = ""
	if not utilities:isStringNullOrEmpty(message) then
		messageString = message
	end

	logger:i("Add ERROR event: {severity:" .. severityString .. ", message:" .. messageString .. "}")

	-- Send to store
	addEventToStore(playerId, eventData)
end

function events:addSdkErrorEvent(playerId, category, area, action, parameter, reason)
	-- Create empty eventData
	local eventData = {}

	eventData["category"] = CategorySdkError
	eventData["error_category"] = category
	eventData["error_area"] = area
	eventData["error_action"] = action

	if not utilities:isStringNullOrEmpty(parameter) then
		eventData["error_parameter"] = parameter
	end

	if not utilities:isStringNullOrEmpty(reason) then
		eventData["reason"] = reason
	end

	logger:i(
		"Add SDK ERROR event: {error_category:"
			.. category
			.. ", error_area:"
			.. area
			.. ", error_action:"
			.. action
			.. "}"
	)

	-- Send to store
	addEventToStore(playerId, eventData)
end

return events]]></ProtectedString>
								<string name="ScriptGuid">{1F63C198-F977-4BDF-8CBD-EE14D94FC45C}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Events.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXCBD145BF8EA34846B131F59939DBCDBC">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local function readonlytable(table)
	return setmetatable({}, {
		__index = table,
		__metatable = false,
		__newindex = function(t, k, v)
			error("Attempt to modify read-only table: " .. t .. ", key=" .. k .. ", value=" .. v)
		end,
	})
end

return readonlytable({
	debug = "debug",
	info = "info",
	warning = "warning",
	error = "error",
	critical = "critical",
})]]></ProtectedString>
								<string name="ScriptGuid">{3DC165BB-AEB6-447A-A4A5-16672F735411}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">GAErrorSeverity.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE2E6A8C30F7C466789EDD96555607AB6">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local function readonlytable(table)
	return setmetatable({}, {
		__index = table,
		__metatable = false,
		__newindex = function(t, k, v)
			error("Attempt to modify read-only table: " .. t .. ", key=" .. k .. ", value=" .. v)
		end,
	})
end

return readonlytable({
	Start = "Start",
	Complete = "Complete",
	Fail = "Fail",
})]]></ProtectedString>
								<string name="ScriptGuid">{6236F2B7-01A6-433E-A7F9-6B5BEABEEC30}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">GAProgressionStatus.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX34585ED16F944B3891D734F1F3AC3641">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local function readonlytable(table)
	return setmetatable({}, {
		__index = table,
		__metatable = false,
		__newindex = function(t, k, v)
			error("Attempt to modify read-only table: " .. t .. ", key=" .. k .. ", value=" .. v)
		end,
	})
end

return readonlytable({
	Source = "Source",
	Sink = "Sink",
})]]></ProtectedString>
								<string name="ScriptGuid">{05BCFC76-505F-49C3-B48C-5139EE6A489B}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">GAResourceFlowType.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3D38A9B537E64725A66AAF9E42F49C23">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local validation = require(script.Parent.Validation)
local version = require(script.Parent.Version)

local HashLib = require(script.HashLib)

local http_api = {
	protocol = "https",
	hostName = "api.gameanalytics.com",
	version = "v2",
	remoteConfigsVersion = "v1",
	initializeUrlPath = "init",
	eventsUrlPath = "events",
	EGAHTTPApiResponse = {
		NoResponse = 0,
		BadResponse = 1,
		RequestTimeout = 2,
		JsonEncodeFailed = 3,
		JsonDecodeFailed = 4,
		InternalServerError = 5,
		BadRequest = 6,
		Unauthorized = 7,
		UnknownResponseCode = 8,
		Ok = 9,
		Created = 10,
	},
}

local HTTP = game:GetService("HttpService")
local logger = require(script.Parent.Logger)
local baseUrl = (RunService:IsStudio() and "https" or http_api.protocol)
	.. "://"
	.. (RunService:IsStudio() and "sandbox-" or "")
	.. http_api.hostName
	.. "/"
	.. http_api.version
local remoteConfigsBaseUrl = (RunService:IsStudio() and "https" or http_api.protocol)
	.. "://"
	.. (RunService:IsStudio() and "sandbox-" or "")
	.. http_api.hostName
	.. "/remote_configs/"
	.. http_api.remoteConfigsVersion

local function getInitAnnotations(build, playerData, playerId)
	local initAnnotations = {
		["user_id"] = tostring(playerId) .. playerData.CustomUserId,
		["sdk_version"] = "roblox " .. version.SdkVersion,
		["os_version"] = playerData.OS,
		["platform"] = playerData.Platform,
		["build"] = build,
		["session_num"] = playerData.Sessions,
		["random_salt"] = playerData.Sessions,
	}

	return initAnnotations
end

local function encode(payload, secretKey)
	--Validate
	if not secretKey then
		logger:w("Error encoding, invalid SecretKey")
		return
	end

	--Encode
	local payloadHmac = HashLib.hmac(
		HashLib.sha256,
		RunService:IsStudio() and "16813a12f718bc5c620f56944e1abc3ea13ccbac" or secretKey,
		payload,
		true
	)

	return HashLib.base64_encode(payloadHmac)
end

local function processRequestResponse(response, requestId)
	local statusCode = response.StatusCode
	local body = response.Body

	if not body or #body == 0 then
		logger:d(requestId .. " request. failed. Might be no connection. Status code: " .. tostring(statusCode))
		return http_api.EGAHTTPApiResponse.NoResponse
	end

	if statusCode == 200 then
		return http_api.EGAHTTPApiResponse.Ok
	elseif statusCode == 201 then
		return http_api.EGAHTTPApiResponse.Created
	elseif statusCode == 0 or statusCode == 401 then
		logger:d(requestId .. " request. 401 - Unauthorized.")
		return http_api.EGAHTTPApiResponse.Unauthorized
	elseif statusCode == 400 then
		logger:d(requestId .. " request. 400 - Bad Request.")
		return http_api.EGAHTTPApiResponse.BadRequest
	elseif statusCode == 500 then
		logger:d(requestId .. " request. 500 - Internal Server Error.")
		return http_api.EGAHTTPApiResponse.InternalServerError
	else
		return http_api.EGAHTTPApiResponse.UnknownResponseCode
	end
end

function http_api:initRequest(gameKey, secretKey, build, playerData, playerId)
	local url = remoteConfigsBaseUrl
		.. "/"
		.. http_api.initializeUrlPath
		.. "?game_key="
		.. gameKey
		.. "&interval_seconds=0&configs_hash="
		.. (playerData.ConfigsHash or "")
	if RunService:IsStudio() then
		url = baseUrl .. "/5c6bcb5402204249437fb5a7a80a4959/" .. self.initializeUrlPath
	end

	logger:d("Sending 'init' URL: " .. url)

	local payload = HTTP:JSONEncode(getInitAnnotations(build, playerData, playerId))
	payload = payload:gsub('"country_code":"unknown"', '"country_code":null')
	local authorization = encode(payload, secretKey)

	logger:d("init payload: " .. payload)

	local res
	local success, err = pcall(function()
		res = HTTP:RequestAsync({
			Url = url,
			Method = "POST",
			Headers = {
				["Authorization"] = authorization,
				["Content-Type"] = "application/json",
			},
			Body = payload,
		})
	end)

	if not success then
		logger:d("Failed Init Call. error: " .. err)
		return {
			statusCode = http_api.EGAHTTPApiResponse.UnknownResponseCode,
			body = nil,
		}
	end
	logger:d("init request content: " .. res.Body)

	local requestResponseEnum = processRequestResponse(res, "Init")

	-- if not 200 result
	if
		requestResponseEnum ~= http_api.EGAHTTPApiResponse.Ok
		and requestResponseEnum ~= http_api.EGAHTTPApiResponse.Created
		and requestResponseEnum ~= http_api.EGAHTTPApiResponse.BadRequest
	then
		logger:d(
			"Failed Init Call. URL: " .. url .. ", JSONString: " .. payload .. ", Authorization: " .. authorization
		)
		return {
			statusCode = requestResponseEnum,
			body = nil,
		}
	end

	--Response
	local responseBody
	success = pcall(function()
		responseBody = HTTP:JSONDecode(res.Body)
	end)

	if not success then
		logger:d("Failed Init Call. Json decoding failed: " .. err)
		return {
			statusCode = http_api.EGAHTTPApiResponse.JsonDecodeFailed,
			body = nil,
		}
	end

	-- print reason if bad request
	if requestResponseEnum == http_api.EGAHTTPApiResponse.BadRequest then
		logger:d("Failed Init Call. Bad request. Response: " .. res.Body)
		return {
			statusCode = requestResponseEnum,
			body = nil,
		}
	end

	-- validate Init call values
	local validatedInitValues = validation:validateAndCleanInitRequestResponse(
		responseBody,
		requestResponseEnum == http_api.EGAHTTPApiResponse.Created
	)

	if not validatedInitValues then
		return {
			statusCode = http_api.EGAHTTPApiResponse.BadResponse,
			body = nil,
		}
	end

	-- all ok
	return {
		statusCode = requestResponseEnum,
		body = responseBody,
	}
end

function http_api:sendEventsInArray(gameKey, secretKey, eventArray)
	if not eventArray or #eventArray == 0 then
		logger:d("sendEventsInArray called with missing eventArray")
		return
	end

	-- Generate URL
	local url = baseUrl .. "/" .. gameKey .. "/" .. self.eventsUrlPath
	if RunService:IsStudio() then
		url = baseUrl .. "/5c6bcb5402204249437fb5a7a80a4959/" .. self.eventsUrlPath
	end

	logger:d("Sending 'events' URL: " .. url)

	-- make JSON string from data
	local payload = HTTP:JSONEncode(eventArray)
	payload = payload:gsub('"country_code":"unknown"', '"country_code":null')
	local authorization = encode(payload, secretKey)

	local res
	local success, err = pcall(function()
		res = HTTP:RequestAsync({
			Url = url,
			Method = "POST",
			Headers = {
				["Authorization"] = authorization,
				["Content-Type"] = "application/json",
			},
			Body = payload,
		})
	end)

	if not success then
		logger:d("Failed Events Call. error: " .. err)
		return {
			statusCode = http_api.EGAHTTPApiResponse.UnknownResponseCode,
			body = nil,
		}
	end

	logger:d("body: " .. res.Body)
	local requestResponseEnum = processRequestResponse(res, "Events")

	-- if not 200 result
	if
		requestResponseEnum ~= http_api.EGAHTTPApiResponse.Ok
		and requestResponseEnum ~= http_api.EGAHTTPApiResponse.Created
		and requestResponseEnum ~= http_api.EGAHTTPApiResponse.BadRequest
	then
		logger:d(
			"Failed Events Call. URL: " .. url .. ", JSONString: " .. payload .. ", Authorization: " .. authorization
		)
		return {
			statusCode = requestResponseEnum,
			body = nil,
		}
	end

	local responseBody
	pcall(function()
		responseBody = HTTP:JSONDecode(res.Body)
	end)

	if not responseBody then
		logger:d("Failed Events Call. Json decoding failed")
		return {
			statusCode = http_api.EGAHTTPApiResponse.JsonDecodeFailed,
			body = nil,
		}
	end

	-- print reason if bad request
	if requestResponseEnum == http_api.EGAHTTPApiResponse.BadRequest then
		logger:d("Failed Events Call. Bad request. Response: " .. res.Body)
		return {
			statusCode = requestResponseEnum,
			body = nil,
		}
	end

	-- all ok
	return {
		statusCode = http_api.EGAHTTPApiResponse.Ok,
		body = responseBody,
	}
end

return http_api]]></ProtectedString>
								<string name="ScriptGuid">{5A3921BF-4F54-4754-9C7F-4C2AFCEC8796}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">HttpApi.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXB22F4FA134D54A9C920A93548E58DAB9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">HttpApi</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXB637CAB757824A1E8CCCFE372930C6ED">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[--[=[------------------------------------------------------------------------------------------------------------------------
-- HashLib by Egor Skriptunoff, boatbomber, and howmanysmall

Documentation here: https://devforum.roblox.com/t/open-source-hashlib/416732/1

--------------------------------------------------------------------------------------------------------------------------

Module was originally written by Egor Skriptunoff and distributed under an MIT license.
It can be found here: https://github.com/Egor-Skriptunoff/pure_lua_SHA/blob/master/sha2.lua

That version was around 3000 lines long, and supported Lua versions 5.1, 5.2, 5.3, and 5.4, and LuaJIT.
Although that is super cool, Roblox only uses Lua 5.1, so that was extreme overkill.

I, boatbomber, worked (with howmanysmall's guidance) to port it to Roblox in a way that
doesn't overcomplicate it with support of unreachable cases. Then, howmanysmall did some final optimizations
that really squeeze out all the performance possible.

After quite a bit of work and benchmarking, this is what we were left with.
Enjoy!

--------------------------------------------------------------------------------------------------------------------------

DESCRIPTION:
	This module contains functions to calculate SHA digest:
		MD5, SHA-1,
		SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,
		SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,
		HMAC
	Additionally, it has a few extra utility functions:
		hex_to_bin
		base64_to_bin
		bin_to_base64
	Written in pure Lua.
USAGE:
	Input data should be a string
	Result (SHA digest) is returned in hexadecimal representation as a string of lowercase hex digits.
	Simplest usage example:
		local HashLib = require(script.HashLib)
		local your_hash = HashLib.sha256("your string")
API:
		HashLib.md5
		HashLib.sha1
	SHA2 hash functions:
		HashLib.sha224
		HashLib.sha256
		HashLib.sha512_224
		HashLib.sha512_256
		HashLib.sha384
		HashLib.sha512
	SHA3 hash functions:
		HashLib.sha3_224
		HashLib.sha3_256
		HashLib.sha3_384
		HashLib.sha3_512
		HashLib.shake128
		HashLib.shake256
	Misc utilities:
		HashLib.hmac (Applicable to any hash function from this module except SHAKE*)
		HashLib.hex_to_bin
		HashLib.base64_to_bin
		HashLib.bin_to_base64

--]=]
---------------------------------------------------------------------------

local Base64 = require(script.Base64)

--------------------------------------------------------------------------------
-- LOCALIZATION FOR VM OPTIMIZATIONS
--------------------------------------------------------------------------------

local ipairs = ipairs

--------------------------------------------------------------------------------
-- 32-BIT BITWISE FUNCTIONS
--------------------------------------------------------------------------------
-- Only low 32 bits of function arguments matter, high bits are ignored
-- The result of all functions (except HEX) is an integer inside "correct range":
-- for "bit" library:    (-TWO_POW_31)..(TWO_POW_31-1)
-- for "bit32" library:        0..(TWO_POW_32-1)
local bit32_band = bit32.band -- 2 arguments
local bit32_bor = bit32.bor -- 2 arguments
local bit32_bxor = bit32.bxor -- 2..5 arguments
local bit32_lshift = bit32.lshift -- second argument is integer 0..31
local bit32_rshift = bit32.rshift -- second argument is integer 0..31
local bit32_lrotate = bit32.lrotate -- second argument is integer 0..31
local bit32_rrotate = bit32.rrotate -- second argument is integer 0..31

--------------------------------------------------------------------------------
-- CREATING OPTIMIZED INNER LOOP
--------------------------------------------------------------------------------
-- Arrays of SHA2 "magic numbers" (in "INT64" and "FFI" branches "*_lo" arrays contain 64-bit values)
local sha2_K_lo, sha2_K_hi, sha2_H_lo, sha2_H_hi, sha3_RC_lo, sha3_RC_hi = {}, {}, {}, {}, {}, {}
local sha2_H_ext256 = {
	[224] = {},
	[256] = sha2_H_hi,
}

local sha2_H_ext512_lo, sha2_H_ext512_hi = {
	[384] = {},
	[512] = sha2_H_lo,
}, {
	[384] = {},
	[512] = sha2_H_hi,
}

local md5_K, md5_sha1_H = {}, { 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0 }
local md5_next_shift =
	{ 0, 0, 0, 0, 0, 0, 0, 0, 28, 25, 26, 27, 0, 0, 10, 9, 11, 12, 0, 15, 16, 17, 18, 0, 20, 22, 23, 21 }
local HEX64, XOR64A5, lanes_index_base -- defined only for branches that internally use 64-bit integers: "INT64" and "FFI"
local common_W = {} -- temporary table shared between all calculations (to avoid creating new temporary table every time)
local K_lo_modulo, hi_factor, hi_factor_keccak = 4294967296, 0, 0

local TWO_POW_NEG_56 = 2 ^ -56
local TWO_POW_NEG_17 = 2 ^ -17

local TWO_POW_2 = 2 ^ 2
local TWO_POW_3 = 2 ^ 3
local TWO_POW_4 = 2 ^ 4
local TWO_POW_5 = 2 ^ 5
local TWO_POW_6 = 2 ^ 6
local TWO_POW_7 = 2 ^ 7
local TWO_POW_8 = 2 ^ 8
local TWO_POW_9 = 2 ^ 9
local TWO_POW_10 = 2 ^ 10
local TWO_POW_11 = 2 ^ 11
local TWO_POW_12 = 2 ^ 12
local TWO_POW_13 = 2 ^ 13
local TWO_POW_14 = 2 ^ 14
local TWO_POW_15 = 2 ^ 15
local TWO_POW_16 = 2 ^ 16
local TWO_POW_17 = 2 ^ 17
local TWO_POW_18 = 2 ^ 18
local TWO_POW_19 = 2 ^ 19
local TWO_POW_20 = 2 ^ 20
local TWO_POW_21 = 2 ^ 21
local TWO_POW_22 = 2 ^ 22
local TWO_POW_23 = 2 ^ 23
local TWO_POW_24 = 2 ^ 24
local TWO_POW_25 = 2 ^ 25
local TWO_POW_26 = 2 ^ 26
local TWO_POW_27 = 2 ^ 27
local TWO_POW_28 = 2 ^ 28
local TWO_POW_29 = 2 ^ 29
local TWO_POW_30 = 2 ^ 30
local TWO_POW_31 = 2 ^ 31
local TWO_POW_32 = 2 ^ 32
local TWO_POW_40 = 2 ^ 40

local TWO56_POW_7 = 256 ^ 7

-- Implementation for Lua 5.1/5.2 (with or without bitwise library available)
local function sha256_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K = common_W, sha2_K_hi
	local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 64 do
			local a, b = W[j - 15], W[j - 2]
			W[j] = bit32_bxor(bit32_rrotate(a, 7), bit32_lrotate(a, 14), bit32_rshift(a, 3))
				+ bit32_bxor(bit32_lrotate(b, 15), bit32_lrotate(b, 13), bit32_rshift(b, 10))
				+ W[j - 7]
				+ W[j - 16]
		end

		local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8
		for j = 1, 64 do
			local z = bit32_bxor(bit32_rrotate(e, 6), bit32_rrotate(e, 11), bit32_lrotate(e, 7))
				+ bit32_band(e, f)
				+ bit32_band(-1 - e, g)
				+ h
				+ K[j]
				+ W[j]
			h = g
			g = f
			f = e
			e = z + d
			d = c
			c = b
			b = a
			a = z
				+ bit32_band(d, c)
				+ bit32_band(a, bit32_bxor(d, c))
				+ bit32_bxor(bit32_rrotate(a, 2), bit32_rrotate(a, 13), bit32_lrotate(a, 10))
		end

		h1, h2, h3, h4 = (a + h1) % 4294967296, (b + h2) % 4294967296, (c + h3) % 4294967296, (d + h4) % 4294967296
		h5, h6, h7, h8 = (e + h5) % 4294967296, (f + h6) % 4294967296, (g + h7) % 4294967296, (h + h8) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8
end

local function sha512_feed_128(H_lo, H_hi, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 128
	-- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]
	local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi
	local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo =
		H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]
	local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi =
		H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]
	for pos = offs, offs + size - 1, 128 do
		for j = 1, 16 * 2 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for jj = 17 * 2, 80 * 2, 2 do
			local a_lo, a_hi, b_lo, b_hi = W[jj - 30], W[jj - 31], W[jj - 4], W[jj - 5]
			local tmp1 = bit32_bxor(
				bit32_rshift(a_lo, 1) + bit32_lshift(a_hi, 31),
				bit32_rshift(a_lo, 8) + bit32_lshift(a_hi, 24),
				bit32_rshift(a_lo, 7) + bit32_lshift(a_hi, 25)
			) % 4294967296 + bit32_bxor(
				bit32_rshift(b_lo, 19) + bit32_lshift(b_hi, 13),
				bit32_lshift(b_lo, 3) + bit32_rshift(b_hi, 29),
				bit32_rshift(b_lo, 6) + bit32_lshift(b_hi, 26)
			) % 4294967296 + W[jj - 14] + W[jj - 32]

			local tmp2 = tmp1 % 4294967296
			W[jj - 1] = bit32_bxor(
				bit32_rshift(a_hi, 1) + bit32_lshift(a_lo, 31),
				bit32_rshift(a_hi, 8) + bit32_lshift(a_lo, 24),
				bit32_rshift(a_hi, 7)
			) + bit32_bxor(
				bit32_rshift(b_hi, 19) + bit32_lshift(b_lo, 13),
				bit32_lshift(b_hi, 3) + bit32_rshift(b_lo, 29),
				bit32_rshift(b_hi, 6)
			) + W[jj - 15] + W[jj - 33] + (tmp1 - tmp2) / 4294967296

			W[jj] = tmp2
		end

		local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
		local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
		for j = 1, 80 do
			local jj = 2 * j
			local tmp1 = bit32_bxor(
				bit32_rshift(e_lo, 14) + bit32_lshift(e_hi, 18),
				bit32_rshift(e_lo, 18) + bit32_lshift(e_hi, 14),
				bit32_lshift(e_lo, 23) + bit32_rshift(e_hi, 9)
			) % 4294967296 + (bit32_band(e_lo, f_lo) + bit32_band(-1 - e_lo, g_lo)) % 4294967296 + h_lo + K_lo[j] + W[jj]

			local z_lo = tmp1 % 4294967296
			local z_hi = bit32_bxor(
				bit32_rshift(e_hi, 14) + bit32_lshift(e_lo, 18),
				bit32_rshift(e_hi, 18) + bit32_lshift(e_lo, 14),
				bit32_lshift(e_hi, 23) + bit32_rshift(e_lo, 9)
			) + bit32_band(e_hi, f_hi) + bit32_band(-1 - e_hi, g_hi) + h_hi + K_hi[j] + W[jj - 1] + (tmp1 - z_lo) / 4294967296

			h_lo = g_lo
			h_hi = g_hi
			g_lo = f_lo
			g_hi = f_hi
			f_lo = e_lo
			f_hi = e_hi
			tmp1 = z_lo + d_lo
			e_lo = tmp1 % 4294967296
			e_hi = z_hi + d_hi + (tmp1 - e_lo) / 4294967296
			d_lo = c_lo
			d_hi = c_hi
			c_lo = b_lo
			c_hi = b_hi
			b_lo = a_lo
			b_hi = a_hi
			tmp1 = z_lo
				+ (bit32_band(d_lo, c_lo) + bit32_band(b_lo, bit32_bxor(d_lo, c_lo))) % 4294967296
				+ bit32_bxor(
						bit32_rshift(b_lo, 28) + bit32_lshift(b_hi, 4),
						bit32_lshift(b_lo, 30) + bit32_rshift(b_hi, 2),
						bit32_lshift(b_lo, 25) + bit32_rshift(b_hi, 7)
					)
					% 4294967296
			a_lo = tmp1 % 4294967296
			a_hi = z_hi
				+ (bit32_band(d_hi, c_hi) + bit32_band(b_hi, bit32_bxor(d_hi, c_hi)))
				+ bit32_bxor(
					bit32_rshift(b_hi, 28) + bit32_lshift(b_lo, 4),
					bit32_lshift(b_hi, 30) + bit32_rshift(b_lo, 2),
					bit32_lshift(b_hi, 25) + bit32_rshift(b_lo, 7)
				)
				+ (tmp1 - a_lo) / 4294967296
		end

		a_lo = h1_lo + a_lo
		h1_lo = a_lo % 4294967296
		h1_hi = (h1_hi + a_hi + (a_lo - h1_lo) / 4294967296) % 4294967296
		a_lo = h2_lo + b_lo
		h2_lo = a_lo % 4294967296
		h2_hi = (h2_hi + b_hi + (a_lo - h2_lo) / 4294967296) % 4294967296
		a_lo = h3_lo + c_lo
		h3_lo = a_lo % 4294967296
		h3_hi = (h3_hi + c_hi + (a_lo - h3_lo) / 4294967296) % 4294967296
		a_lo = h4_lo + d_lo
		h4_lo = a_lo % 4294967296
		h4_hi = (h4_hi + d_hi + (a_lo - h4_lo) / 4294967296) % 4294967296
		a_lo = h5_lo + e_lo
		h5_lo = a_lo % 4294967296
		h5_hi = (h5_hi + e_hi + (a_lo - h5_lo) / 4294967296) % 4294967296
		a_lo = h6_lo + f_lo
		h6_lo = a_lo % 4294967296
		h6_hi = (h6_hi + f_hi + (a_lo - h6_lo) / 4294967296) % 4294967296
		a_lo = h7_lo + g_lo
		h7_lo = a_lo % 4294967296
		h7_hi = (h7_hi + g_hi + (a_lo - h7_lo) / 4294967296) % 4294967296
		a_lo = h8_lo + h_lo
		h8_lo = a_lo % 4294967296
		h8_hi = (h8_hi + h_hi + (a_lo - h8_lo) / 4294967296) % 4294967296
	end

	H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] =
		h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
	H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] =
		h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
end

local function md5_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K, md5_next_shift = common_W, md5_K, md5_next_shift
	local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((d * 256 + c) * 256 + b) * 256 + a
		end

		local a, b, c, d = h1, h2, h3, h4
		local s = 32 - 7
		for j = 1, 16 do
			local F = bit32_rrotate(bit32_band(b, c) + bit32_band(-1 - b, d) + a + K[j] + W[j], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 32 - 5
		for j = 17, 32 do
			local F = bit32_rrotate(bit32_band(d, b) + bit32_band(-1 - d, c) + a + K[j] + W[(5 * j - 4) % 16 + 1], s)
				+ b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 32 - 4
		for j = 33, 48 do
			local F = bit32_rrotate(bit32_bxor(bit32_bxor(b, c), d) + a + K[j] + W[(3 * j + 2) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 32 - 6
		for j = 49, 64 do
			local F = bit32_rrotate(bit32_bxor(c, bit32_bor(b, -1 - d)) + a + K[j] + W[(j * 7 - 7) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
	end

	H[1], H[2], H[3], H[4] = h1, h2, h3, h4
end

local function sha1_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W = common_W
	local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 80 do
			W[j] = bit32_lrotate(bit32_bxor(W[j - 3], W[j - 8], W[j - 14], W[j - 16]), 1)
		end

		local a, b, c, d, e = h1, h2, h3, h4, h5
		for j = 1, 20 do
			local z = bit32_lrotate(a, 5) + bit32_band(b, c) + bit32_band(-1 - b, d) + 0x5A827999 + W[j] + e -- constant = math.floor(TWO_POW_30 * sqrt(2))
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 21, 40 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0x6ED9EBA1 + W[j] + e -- TWO_POW_30 * sqrt(3)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 41, 60 do
			local z = bit32_lrotate(a, 5) + bit32_band(d, c) + bit32_band(b, bit32_bxor(d, c)) + 0x8F1BBCDC + W[j] + e -- TWO_POW_30 * sqrt(5)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 61, 80 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0xCA62C1D6 + W[j] + e -- TWO_POW_30 * sqrt(10)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
		h5 = (e + h5) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5
end

local function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)
	-- This is an example of a Lua function having 79 local variables :-)
	-- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8
	local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi
	local qwords_qty = block_size_in_bytes / 8
	for pos = offs, offs + size - 1, block_size_in_bytes do
		for j = 1, qwords_qty do
			local a, b, c, d = string.byte(str, pos + 1, pos + 4)
			lanes_lo[j] = bit32_bxor(lanes_lo[j], ((d * 256 + c) * 256 + b) * 256 + a)
			pos = pos + 8
			a, b, c, d = string.byte(str, pos - 3, pos)
			lanes_hi[j] = bit32_bxor(lanes_hi[j], ((d * 256 + c) * 256 + b) * 256 + a)
		end

		local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi, L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi, L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi =
			lanes_lo[1],
			lanes_hi[1],
			lanes_lo[2],
			lanes_hi[2],
			lanes_lo[3],
			lanes_hi[3],
			lanes_lo[4],
			lanes_hi[4],
			lanes_lo[5],
			lanes_hi[5],
			lanes_lo[6],
			lanes_hi[6],
			lanes_lo[7],
			lanes_hi[7],
			lanes_lo[8],
			lanes_hi[8],
			lanes_lo[9],
			lanes_hi[9],
			lanes_lo[10],
			lanes_hi[10],
			lanes_lo[11],
			lanes_hi[11],
			lanes_lo[12],
			lanes_hi[12],
			lanes_lo[13],
			lanes_hi[13],
			lanes_lo[14],
			lanes_hi[14],
			lanes_lo[15],
			lanes_hi[15],
			lanes_lo[16],
			lanes_hi[16],
			lanes_lo[17],
			lanes_hi[17],
			lanes_lo[18],
			lanes_hi[18],
			lanes_lo[19],
			lanes_hi[19],
			lanes_lo[20],
			lanes_hi[20],
			lanes_lo[21],
			lanes_hi[21],
			lanes_lo[22],
			lanes_hi[22],
			lanes_lo[23],
			lanes_hi[23],
			lanes_lo[24],
			lanes_hi[24],
			lanes_lo[25],
			lanes_hi[25]

		for round_idx = 1, 24 do
			local C1_lo = bit32_bxor(L01_lo, L06_lo, L11_lo, L16_lo, L21_lo)
			local C1_hi = bit32_bxor(L01_hi, L06_hi, L11_hi, L16_hi, L21_hi)
			local C2_lo = bit32_bxor(L02_lo, L07_lo, L12_lo, L17_lo, L22_lo)
			local C2_hi = bit32_bxor(L02_hi, L07_hi, L12_hi, L17_hi, L22_hi)
			local C3_lo = bit32_bxor(L03_lo, L08_lo, L13_lo, L18_lo, L23_lo)
			local C3_hi = bit32_bxor(L03_hi, L08_hi, L13_hi, L18_hi, L23_hi)
			local C4_lo = bit32_bxor(L04_lo, L09_lo, L14_lo, L19_lo, L24_lo)
			local C4_hi = bit32_bxor(L04_hi, L09_hi, L14_hi, L19_hi, L24_hi)
			local C5_lo = bit32_bxor(L05_lo, L10_lo, L15_lo, L20_lo, L25_lo)
			local C5_hi = bit32_bxor(L05_hi, L10_hi, L15_hi, L20_hi, L25_hi)

			local D_lo = bit32_bxor(C1_lo, C3_lo * 2 + (C3_hi % TWO_POW_32 - C3_hi % TWO_POW_31) / TWO_POW_31)
			local D_hi = bit32_bxor(C1_hi, C3_hi * 2 + (C3_lo % TWO_POW_32 - C3_lo % TWO_POW_31) / TWO_POW_31)

			local T0_lo = bit32_bxor(D_lo, L02_lo)
			local T0_hi = bit32_bxor(D_hi, L02_hi)
			local T1_lo = bit32_bxor(D_lo, L07_lo)
			local T1_hi = bit32_bxor(D_hi, L07_hi)
			local T2_lo = bit32_bxor(D_lo, L12_lo)
			local T2_hi = bit32_bxor(D_hi, L12_hi)
			local T3_lo = bit32_bxor(D_lo, L17_lo)
			local T3_hi = bit32_bxor(D_hi, L17_hi)
			local T4_lo = bit32_bxor(D_lo, L22_lo)
			local T4_hi = bit32_bxor(D_hi, L22_hi)

			L02_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_20) / TWO_POW_20 + T1_hi * TWO_POW_12
			L02_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_20) / TWO_POW_20 + T1_lo * TWO_POW_12
			L07_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_19) / TWO_POW_19 + T3_hi * TWO_POW_13
			L07_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_19) / TWO_POW_19 + T3_lo * TWO_POW_13
			L12_lo = T0_lo * 2 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_31) / TWO_POW_31
			L12_hi = T0_hi * 2 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_31) / TWO_POW_31
			L17_lo = T2_lo * TWO_POW_10 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_22) / TWO_POW_22
			L17_hi = T2_hi * TWO_POW_10 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_22) / TWO_POW_22
			L22_lo = T4_lo * TWO_POW_2 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_30) / TWO_POW_30
			L22_hi = T4_hi * TWO_POW_2 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_30) / TWO_POW_30

			D_lo = bit32_bxor(C2_lo, C4_lo * 2 + (C4_hi % TWO_POW_32 - C4_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C2_hi, C4_hi * 2 + (C4_lo % TWO_POW_32 - C4_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L03_lo)
			T0_hi = bit32_bxor(D_hi, L03_hi)
			T1_lo = bit32_bxor(D_lo, L08_lo)
			T1_hi = bit32_bxor(D_hi, L08_hi)
			T2_lo = bit32_bxor(D_lo, L13_lo)
			T2_hi = bit32_bxor(D_hi, L13_hi)
			T3_lo = bit32_bxor(D_lo, L18_lo)
			T3_hi = bit32_bxor(D_hi, L18_hi)
			T4_lo = bit32_bxor(D_lo, L23_lo)
			T4_hi = bit32_bxor(D_hi, L23_hi)

			L03_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_21) / TWO_POW_21 + T2_hi * TWO_POW_11
			L03_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_21) / TWO_POW_21 + T2_lo * TWO_POW_11
			L08_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_3) / TWO_POW_3 + T4_hi * TWO_POW_29 % TWO_POW_32
			L08_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_3) / TWO_POW_3 + T4_lo * TWO_POW_29 % TWO_POW_32
			L13_lo = T1_lo * TWO_POW_6 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_26) / TWO_POW_26
			L13_hi = T1_hi * TWO_POW_6 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_26) / TWO_POW_26
			L18_lo = T3_lo * TWO_POW_15 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_17) / TWO_POW_17
			L18_hi = T3_hi * TWO_POW_15 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_17) / TWO_POW_17
			L23_lo = (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_2) / TWO_POW_2 + T0_hi * TWO_POW_30 % TWO_POW_32
			L23_hi = (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_2) / TWO_POW_2 + T0_lo * TWO_POW_30 % TWO_POW_32

			D_lo = bit32_bxor(C3_lo, C5_lo * 2 + (C5_hi % TWO_POW_32 - C5_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C3_hi, C5_hi * 2 + (C5_lo % TWO_POW_32 - C5_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L04_lo)
			T0_hi = bit32_bxor(D_hi, L04_hi)
			T1_lo = bit32_bxor(D_lo, L09_lo)
			T1_hi = bit32_bxor(D_hi, L09_hi)
			T2_lo = bit32_bxor(D_lo, L14_lo)
			T2_hi = bit32_bxor(D_hi, L14_hi)
			T3_lo = bit32_bxor(D_lo, L19_lo)
			T3_hi = bit32_bxor(D_hi, L19_hi)
			T4_lo = bit32_bxor(D_lo, L24_lo)
			T4_hi = bit32_bxor(D_hi, L24_hi)

			L04_lo = T3_lo * TWO_POW_21 % TWO_POW_32 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_11) / TWO_POW_11
			L04_hi = T3_hi * TWO_POW_21 % TWO_POW_32 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_11) / TWO_POW_11
			L09_lo = T0_lo * TWO_POW_28 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_4) / TWO_POW_4
			L09_hi = T0_hi * TWO_POW_28 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_4) / TWO_POW_4
			L14_lo = T2_lo * TWO_POW_25 % TWO_POW_32 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_7) / TWO_POW_7
			L14_hi = T2_hi * TWO_POW_25 % TWO_POW_32 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_7) / TWO_POW_7
			L19_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_8) / TWO_POW_8 + T4_hi * TWO_POW_24 % TWO_POW_32
			L19_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_8) / TWO_POW_8 + T4_lo * TWO_POW_24 % TWO_POW_32
			L24_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_9) / TWO_POW_9 + T1_hi * TWO_POW_23 % TWO_POW_32
			L24_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_9) / TWO_POW_9 + T1_lo * TWO_POW_23 % TWO_POW_32

			D_lo = bit32_bxor(C4_lo, C1_lo * 2 + (C1_hi % TWO_POW_32 - C1_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C4_hi, C1_hi * 2 + (C1_lo % TWO_POW_32 - C1_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L05_lo)
			T0_hi = bit32_bxor(D_hi, L05_hi)
			T1_lo = bit32_bxor(D_lo, L10_lo)
			T1_hi = bit32_bxor(D_hi, L10_hi)
			T2_lo = bit32_bxor(D_lo, L15_lo)
			T2_hi = bit32_bxor(D_hi, L15_hi)
			T3_lo = bit32_bxor(D_lo, L20_lo)
			T3_hi = bit32_bxor(D_hi, L20_hi)
			T4_lo = bit32_bxor(D_lo, L25_lo)
			T4_hi = bit32_bxor(D_hi, L25_hi)

			L05_lo = T4_lo * TWO_POW_14 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_18) / TWO_POW_18
			L05_hi = T4_hi * TWO_POW_14 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_18) / TWO_POW_18
			L10_lo = T1_lo * TWO_POW_20 % TWO_POW_32 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_12) / TWO_POW_12
			L10_hi = T1_hi * TWO_POW_20 % TWO_POW_32 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_12) / TWO_POW_12
			L15_lo = T3_lo * TWO_POW_8 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_24) / TWO_POW_24
			L15_hi = T3_hi * TWO_POW_8 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_24) / TWO_POW_24
			L20_lo = T0_lo * TWO_POW_27 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_5) / TWO_POW_5
			L20_hi = T0_hi * TWO_POW_27 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_5) / TWO_POW_5
			L25_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_25) / TWO_POW_25 + T2_hi * TWO_POW_7
			L25_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_25) / TWO_POW_25 + T2_lo * TWO_POW_7

			D_lo = bit32_bxor(C5_lo, C2_lo * 2 + (C2_hi % TWO_POW_32 - C2_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C5_hi, C2_hi * 2 + (C2_lo % TWO_POW_32 - C2_lo % TWO_POW_31) / TWO_POW_31)

			T1_lo = bit32_bxor(D_lo, L06_lo)
			T1_hi = bit32_bxor(D_hi, L06_hi)
			T2_lo = bit32_bxor(D_lo, L11_lo)
			T2_hi = bit32_bxor(D_hi, L11_hi)
			T3_lo = bit32_bxor(D_lo, L16_lo)
			T3_hi = bit32_bxor(D_hi, L16_hi)
			T4_lo = bit32_bxor(D_lo, L21_lo)
			T4_hi = bit32_bxor(D_hi, L21_hi)

			L06_lo = T2_lo * TWO_POW_3 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_29) / TWO_POW_29
			L06_hi = T2_hi * TWO_POW_3 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_29) / TWO_POW_29
			L11_lo = T4_lo * TWO_POW_18 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_14) / TWO_POW_14
			L11_hi = T4_hi * TWO_POW_18 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_14) / TWO_POW_14
			L16_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_28) / TWO_POW_28 + T1_hi * TWO_POW_4
			L16_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_28) / TWO_POW_28 + T1_lo * TWO_POW_4
			L21_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_23) / TWO_POW_23 + T3_hi * TWO_POW_9
			L21_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_23) / TWO_POW_23 + T3_lo * TWO_POW_9

			L01_lo = bit32_bxor(D_lo, L01_lo)
			L01_hi = bit32_bxor(D_hi, L01_hi)
			L01_lo, L02_lo, L03_lo, L04_lo, L05_lo =
				bit32_bxor(L01_lo, bit32_band(-1 - L02_lo, L03_lo)),
				bit32_bxor(L02_lo, bit32_band(-1 - L03_lo, L04_lo)),
				bit32_bxor(L03_lo, bit32_band(-1 - L04_lo, L05_lo)),
				bit32_bxor(L04_lo, bit32_band(-1 - L05_lo, L01_lo)),
				bit32_bxor(L05_lo, bit32_band(-1 - L01_lo, L02_lo))
			L01_hi, L02_hi, L03_hi, L04_hi, L05_hi =
				bit32_bxor(L01_hi, bit32_band(-1 - L02_hi, L03_hi)),
				bit32_bxor(L02_hi, bit32_band(-1 - L03_hi, L04_hi)),
				bit32_bxor(L03_hi, bit32_band(-1 - L04_hi, L05_hi)),
				bit32_bxor(L04_hi, bit32_band(-1 - L05_hi, L01_hi)),
				bit32_bxor(L05_hi, bit32_band(-1 - L01_hi, L02_hi))
			L06_lo, L07_lo, L08_lo, L09_lo, L10_lo =
				bit32_bxor(L09_lo, bit32_band(-1 - L10_lo, L06_lo)),
				bit32_bxor(L10_lo, bit32_band(-1 - L06_lo, L07_lo)),
				bit32_bxor(L06_lo, bit32_band(-1 - L07_lo, L08_lo)),
				bit32_bxor(L07_lo, bit32_band(-1 - L08_lo, L09_lo)),
				bit32_bxor(L08_lo, bit32_band(-1 - L09_lo, L10_lo))
			L06_hi, L07_hi, L08_hi, L09_hi, L10_hi =
				bit32_bxor(L09_hi, bit32_band(-1 - L10_hi, L06_hi)),
				bit32_bxor(L10_hi, bit32_band(-1 - L06_hi, L07_hi)),
				bit32_bxor(L06_hi, bit32_band(-1 - L07_hi, L08_hi)),
				bit32_bxor(L07_hi, bit32_band(-1 - L08_hi, L09_hi)),
				bit32_bxor(L08_hi, bit32_band(-1 - L09_hi, L10_hi))
			L11_lo, L12_lo, L13_lo, L14_lo, L15_lo =
				bit32_bxor(L12_lo, bit32_band(-1 - L13_lo, L14_lo)),
				bit32_bxor(L13_lo, bit32_band(-1 - L14_lo, L15_lo)),
				bit32_bxor(L14_lo, bit32_band(-1 - L15_lo, L11_lo)),
				bit32_bxor(L15_lo, bit32_band(-1 - L11_lo, L12_lo)),
				bit32_bxor(L11_lo, bit32_band(-1 - L12_lo, L13_lo))
			L11_hi, L12_hi, L13_hi, L14_hi, L15_hi =
				bit32_bxor(L12_hi, bit32_band(-1 - L13_hi, L14_hi)),
				bit32_bxor(L13_hi, bit32_band(-1 - L14_hi, L15_hi)),
				bit32_bxor(L14_hi, bit32_band(-1 - L15_hi, L11_hi)),
				bit32_bxor(L15_hi, bit32_band(-1 - L11_hi, L12_hi)),
				bit32_bxor(L11_hi, bit32_band(-1 - L12_hi, L13_hi))
			L16_lo, L17_lo, L18_lo, L19_lo, L20_lo =
				bit32_bxor(L20_lo, bit32_band(-1 - L16_lo, L17_lo)),
				bit32_bxor(L16_lo, bit32_band(-1 - L17_lo, L18_lo)),
				bit32_bxor(L17_lo, bit32_band(-1 - L18_lo, L19_lo)),
				bit32_bxor(L18_lo, bit32_band(-1 - L19_lo, L20_lo)),
				bit32_bxor(L19_lo, bit32_band(-1 - L20_lo, L16_lo))
			L16_hi, L17_hi, L18_hi, L19_hi, L20_hi =
				bit32_bxor(L20_hi, bit32_band(-1 - L16_hi, L17_hi)),
				bit32_bxor(L16_hi, bit32_band(-1 - L17_hi, L18_hi)),
				bit32_bxor(L17_hi, bit32_band(-1 - L18_hi, L19_hi)),
				bit32_bxor(L18_hi, bit32_band(-1 - L19_hi, L20_hi)),
				bit32_bxor(L19_hi, bit32_band(-1 - L20_hi, L16_hi))
			L21_lo, L22_lo, L23_lo, L24_lo, L25_lo =
				bit32_bxor(L23_lo, bit32_band(-1 - L24_lo, L25_lo)),
				bit32_bxor(L24_lo, bit32_band(-1 - L25_lo, L21_lo)),
				bit32_bxor(L25_lo, bit32_band(-1 - L21_lo, L22_lo)),
				bit32_bxor(L21_lo, bit32_band(-1 - L22_lo, L23_lo)),
				bit32_bxor(L22_lo, bit32_band(-1 - L23_lo, L24_lo))
			L21_hi, L22_hi, L23_hi, L24_hi, L25_hi =
				bit32_bxor(L23_hi, bit32_band(-1 - L24_hi, L25_hi)),
				bit32_bxor(L24_hi, bit32_band(-1 - L25_hi, L21_hi)),
				bit32_bxor(L25_hi, bit32_band(-1 - L21_hi, L22_hi)),
				bit32_bxor(L21_hi, bit32_band(-1 - L22_hi, L23_hi)),
				bit32_bxor(L22_hi, bit32_band(-1 - L23_hi, L24_hi))
			L01_lo = bit32_bxor(L01_lo, RC_lo[round_idx])
			L01_hi = L01_hi + RC_hi[round_idx] -- RC_hi[] is either 0 or 0x80000000, so we could use fast addition instead of slow XOR
		end

		lanes_lo[1] = L01_lo
		lanes_hi[1] = L01_hi
		lanes_lo[2] = L02_lo
		lanes_hi[2] = L02_hi
		lanes_lo[3] = L03_lo
		lanes_hi[3] = L03_hi
		lanes_lo[4] = L04_lo
		lanes_hi[4] = L04_hi
		lanes_lo[5] = L05_lo
		lanes_hi[5] = L05_hi
		lanes_lo[6] = L06_lo
		lanes_hi[6] = L06_hi
		lanes_lo[7] = L07_lo
		lanes_hi[7] = L07_hi
		lanes_lo[8] = L08_lo
		lanes_hi[8] = L08_hi
		lanes_lo[9] = L09_lo
		lanes_hi[9] = L09_hi
		lanes_lo[10] = L10_lo
		lanes_hi[10] = L10_hi
		lanes_lo[11] = L11_lo
		lanes_hi[11] = L11_hi
		lanes_lo[12] = L12_lo
		lanes_hi[12] = L12_hi
		lanes_lo[13] = L13_lo
		lanes_hi[13] = L13_hi
		lanes_lo[14] = L14_lo
		lanes_hi[14] = L14_hi
		lanes_lo[15] = L15_lo
		lanes_hi[15] = L15_hi
		lanes_lo[16] = L16_lo
		lanes_hi[16] = L16_hi
		lanes_lo[17] = L17_lo
		lanes_hi[17] = L17_hi
		lanes_lo[18] = L18_lo
		lanes_hi[18] = L18_hi
		lanes_lo[19] = L19_lo
		lanes_hi[19] = L19_hi
		lanes_lo[20] = L20_lo
		lanes_hi[20] = L20_hi
		lanes_lo[21] = L21_lo
		lanes_hi[21] = L21_hi
		lanes_lo[22] = L22_lo
		lanes_hi[22] = L22_hi
		lanes_lo[23] = L23_lo
		lanes_hi[23] = L23_hi
		lanes_lo[24] = L24_lo
		lanes_hi[24] = L24_hi
		lanes_lo[25] = L25_lo
		lanes_hi[25] = L25_hi
	end
end

--------------------------------------------------------------------------------
-- MAGIC NUMBERS CALCULATOR
--------------------------------------------------------------------------------
-- Q:
--    Is 53-bit "double" math enough to calculate square roots and cube roots of primes with 64 correct bits after decimal point?
-- A:
--    Yes, 53-bit "double" arithmetic is enough.
--    We could obtain first 40 bits by direct calculation of p^(1/3) and next 40 bits by one step of Newton's method.
do
	local function mul(src1, src2, factor, result_length)
		-- src1, src2 - long integers (arrays of digits in base TWO_POW_24)
		-- factor - small integer
		-- returns long integer result (src1 * src2 * factor) and its floating point approximation
		local result, carry, value, weight = table.create(result_length), 0.0, 0.0, 1.0
		for j = 1, result_length do
			for k = math.max(1, j + 1 - #src2), math.min(j, #src1) do
				carry = carry + factor * src1[k] * src2[j + 1 - k] -- "int32" is not enough for multiplication result, that's why "factor" must be of type "double"
			end

			local digit = carry % TWO_POW_24
			result[j] = math.floor(digit)
			carry = (carry - digit) / TWO_POW_24
			value = value + digit * weight
			weight = weight * TWO_POW_24
		end

		return result, value
	end

	local idx, step, p, one, sqrt_hi, sqrt_lo = 0, { 4, 1, 2, -2, 2 }, 4, { 1 }, sha2_H_hi, sha2_H_lo
	repeat
		p = p + step[p % 6]
		local d = 1
		repeat
			d = d + step[d % 6]
			if d * d > p then
				-- next prime number is found
				local root = p ^ (1 / 3)
				local R = root * TWO_POW_40
				R = mul(table.create(1, math.floor(R)), one, 1.0, 2)
				local _, delta = mul(R, mul(R, R, 1.0, 4), -1.0, 4)
				local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
				local lo = R[1] % 256 * 16777216 + math.floor(delta * (TWO_POW_NEG_56 / 3) * root / p)

				if idx < 16 then
					root = math.sqrt(p)
					R = root * TWO_POW_40
					R = mul(table.create(1, math.floor(R)), one, 1.0, 2)
					_, delta = mul(R, R, -1.0, 2)

					local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
					local lo = R[1] % 256 * 16777216 + math.floor(delta * TWO_POW_NEG_17 / root)
					local idx = idx % 8 + 1
					sha2_H_ext256[224][idx] = lo
					sqrt_hi[idx], sqrt_lo[idx] = hi, lo + hi * hi_factor

					if idx > 7 then
						sqrt_hi, sqrt_lo = sha2_H_ext512_hi[384], sha2_H_ext512_lo[384]
					end
				end

				idx = idx + 1
				sha2_K_hi[idx], sha2_K_lo[idx] = hi, lo % K_lo_modulo + hi * hi_factor
				break
			end
		until p % d == 0
	until idx > 79
end

-- Calculating IVs for SHA512/224 and SHA512/256
for width = 224, 256, 32 do
	local H_lo, H_hi = {}, nil
	if XOR64A5 then
		for j = 1, 8 do
			H_lo[j] = XOR64A5(sha2_H_lo[j])
		end
	else
		H_hi = {}
		for j = 1, 8 do
			H_lo[j] = bit32_bxor(sha2_H_lo[j], 0xA5A5A5A5) % 4294967296
			H_hi[j] = bit32_bxor(sha2_H_hi[j], 0xA5A5A5A5) % 4294967296
		end
	end

	sha512_feed_128(H_lo, H_hi, "SHA-512/" .. tostring(width) .. "\128" .. string.rep("\0", 115) .. "\88", 0, 128)
	sha2_H_ext512_lo[width] = H_lo
	sha2_H_ext512_hi[width] = H_hi
end

-- Constants for MD5
do
	for idx = 1, 64 do
		-- we can't use formula math.floor(abs(sin(idx))*TWO_POW_32) because its result may be beyond integer range on Lua built with 32-bit integers
		local hi, lo = math.modf(math.abs(math.sin(idx)) * TWO_POW_16)
		md5_K[idx] = hi * 65536 + math.floor(lo * TWO_POW_16)
	end
end

-- Constants for SHA3
do
	local sh_reg = 29
	local function next_bit()
		local r = sh_reg % 2
		sh_reg = bit32_bxor((sh_reg - r) / 2, 142 * r)
		return r
	end

	for idx = 1, 24 do
		local lo, m = 0, nil
		for _ = 1, 6 do
			m = m and m * m * 2 or 1
			lo = lo + next_bit() * m
		end

		local hi = next_bit() * m
		sha3_RC_hi[idx], sha3_RC_lo[idx] = hi, lo + hi * hi_factor_keccak
	end
end

--------------------------------------------------------------------------------
-- MAIN FUNCTIONS
--------------------------------------------------------------------------------
local function sha256ext(width, message)
	-- Create an instance (private objects for current calculation)
	local Array256 = sha2_H_ext256[width] -- # == 8
	local length, tail = 0.0, ""
	local H = table.create(8)
	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] =
		Array256[1], Array256[2], Array256[3], Array256[4], Array256[5], Array256[6], Array256[7], Array256[8]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					sha256_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha256_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- Anyway, it looks very unrealistic that someone would spend more than a year of calculations to process TWO_POW_53 bytes of data by using this Lua script :-)
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha256_feed_64(H, final_blocks, 0, #final_blocks)
				local max_reg = width / 32
				for j = 1, max_reg do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H, "", 1, max_reg)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA256 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA256 digest by invoking this function without an argument
		return partial
	end
end

local function sha512ext(width, message)
	-- Create an instance (private objects for current calculation)
	local length, tail, H_lo, H_hi =
		0.0,
		"",
		table.pack(table.unpack(sha2_H_ext512_lo[width])),
		not HEX64 and table.pack(table.unpack(sha2_H_ext512_hi[width]))

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 128 then
					offs = 128 - #tail
					sha512_feed_128(H_lo, H_hi, tail .. string.sub(message_part, 1, offs), 0, 128)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 128
				sha512_feed_128(H_lo, H_hi, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-17-length) % 128 + 9)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-17 - length) % 128 + 9)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-17 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move floating point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha512_feed_128(H_lo, H_hi, final_blocks, 0, #final_blocks)
				local max_reg = math.ceil(width / 64)

				if HEX64 then
					for j = 1, max_reg do
						H_lo[j] = HEX64(H_lo[j])
					end
				else
					for j = 1, max_reg do
						H_lo[j] = string.format("%08x", H_hi[j] % 4294967296)
							.. string.format("%08x", H_lo[j] % 4294967296)
					end

					H_hi = nil
				end

				H_lo = string.sub(table.concat(H_lo, "", 1, max_reg), 1, width / 4)
			end

			return H_lo
		end
	end

	if message then
		-- Actually perform calculations and return the SHA512 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA512 digest by invoking this function without an argument
		return partial
	end
end

local function md5(message)
	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.create(4), 0.0, ""
	H[1], H[2], H[3], H[4] = md5_sha1_H[1], md5_sha1_H[2], md5_sha1_H[3], md5_sha1_H[4]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					md5_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				md5_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(11) --{tail, "\128", string.rep("\0", (-9 - length) % 64)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64)

				tail = nil
				length = length * 8 -- convert "byte-counter" to "bit-counter"
				for j = 4, 11 do
					local low_byte = length % 256
					final_blocks[j] = string.char(low_byte)
					length = (length - low_byte) / 256
				end

				final_blocks = table.concat(final_blocks)
				md5_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 4 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = string.gsub(table.concat(H), "(..)(..)(..)(..)", "%4%3%2%1")
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the MD5 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get MD5 digest by invoking this function without an argument
		return partial
	end
end

local function sha1(message)
	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.pack(table.unpack(md5_sha1_H)), 0.0, ""

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					sha1_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha1_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha1_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 5 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA-1 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA-1 digest by invoking this function without an argument
		return partial
	end
end

local function keccak(block_size_in_bytes, digest_size_in_bytes, is_SHAKE, message)
	-- "block_size_in_bytes" is multiple of 8
	if type(digest_size_in_bytes) ~= "number" then
		-- arguments in SHAKE are swapped:
		--    NIST FIPS 202 defines SHAKE(message,num_bits)
		--    this module   defines SHAKE(num_bytes,message)
		-- it's easy to forget about this swap, hence the check
		error("Argument 'digest_size_in_bytes' must be a number", 2)
	end

	-- Create an instance (private objects for current calculation)
	local tail, lanes_lo, lanes_hi = "", table.create(25, 0), hi_factor_keccak == 0 and table.create(25, 0)
	local result

	--~     pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)/r is integer),
	--~     break P into n consecutive r-bit pieces P0, ..., Pn-1 (last is zero-padded)
	--~     initialize the state S to a string of b 0 bits.
	--~     absorb the input into the state: For each block Pi,
	--~         extend Pi at the end by a string of c 0 bits, yielding one of length b,
	--~         XOR that with S and
	--~         apply the block permutation f to the result, yielding a new state S
	--~     initialize Z to be the empty string
	--~     while the length of Z is less than d:
	--~         append the first r bits of S to Z
	--~         if Z is still less than d bits long, apply f to S, yielding a new state S.
	--~     truncate Z to d bits
	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				local offs = 0
				if tail ~= "" and #tail + partLength >= block_size_in_bytes then
					offs = block_size_in_bytes - #tail
					keccak_feed(
						lanes_lo,
						lanes_hi,
						tail .. string.sub(message_part, 1, offs),
						0,
						block_size_in_bytes,
						block_size_in_bytes
					)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % block_size_in_bytes
				keccak_feed(lanes_lo, lanes_hi, message_part, offs, size - size_tail, block_size_in_bytes)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				-- append the following bits to the message: for usual SHA3: 011(0*)1, for SHAKE: 11111(0*)1
				local gap_start = is_SHAKE and 31 or 6
				tail = tail
					.. (
						#tail + 1 == block_size_in_bytes and string.char(gap_start + 128)
						or string.char(gap_start) .. string.rep("\0", (-2 - #tail) % block_size_in_bytes) .. "\128"
					)
				keccak_feed(lanes_lo, lanes_hi, tail, 0, #tail, block_size_in_bytes)
				tail = nil

				local lanes_used = 0
				local total_lanes = math.floor(block_size_in_bytes / 8)
				local qwords = {}

				local function get_next_qwords_of_digest(qwords_qty)
					-- returns not more than 'qwords_qty' qwords ('qwords_qty' might be non-integer)
					-- doesn't go across keccak-buffer boundary
					-- block_size_in_bytes is a multiple of 8, so, keccak-buffer contains integer number of qwords
					if lanes_used >= total_lanes then
						keccak_feed(lanes_lo, lanes_hi, "\0\0\0\0\0\0\0\0", 0, 8, 8)
						lanes_used = 0
					end

					qwords_qty = math.floor(math.min(qwords_qty, total_lanes - lanes_used))
					if hi_factor_keccak ~= 0 then
						for j = 1, qwords_qty do
							qwords[j] = HEX64(lanes_lo[lanes_used + j - 1 + lanes_index_base])
						end
					else
						for j = 1, qwords_qty do
							qwords[j] = string.format("%08x", lanes_hi[lanes_used + j] % 4294967296)
								.. string.format("%08x", lanes_lo[lanes_used + j] % 4294967296)
						end
					end

					lanes_used = lanes_used + qwords_qty
					return string.gsub(
						table.concat(qwords, "", 1, qwords_qty),
						"(..)(..)(..)(..)(..)(..)(..)(..)",
						"%8%7%6%5%4%3%2%1"
					),
						qwords_qty * 8
				end

				local parts = {} -- digest parts
				local last_part, last_part_size = "", 0

				local function get_next_part_of_digest(bytes_needed)
					-- returns 'bytes_needed' bytes, for arbitrary integer 'bytes_needed'
					bytes_needed = bytes_needed or 1
					if bytes_needed <= last_part_size then
						last_part_size = last_part_size - bytes_needed
						local part_size_in_nibbles = bytes_needed * 2
						local result = string.sub(last_part, 1, part_size_in_nibbles)
						last_part = string.sub(last_part, part_size_in_nibbles + 1)
						return result
					end

					local parts_qty = 0
					if last_part_size > 0 then
						parts_qty = 1
						parts[parts_qty] = last_part
						bytes_needed = bytes_needed - last_part_size
					end

					-- repeats until the length is enough
					while bytes_needed >= 8 do
						local next_part, next_part_size = get_next_qwords_of_digest(bytes_needed / 8)
						parts_qty = parts_qty + 1
						parts[parts_qty] = next_part
						bytes_needed = bytes_needed - next_part_size
					end

					if bytes_needed > 0 then
						last_part, last_part_size = get_next_qwords_of_digest(1)
						parts_qty = parts_qty + 1
						parts[parts_qty] = get_next_part_of_digest(bytes_needed)
					else
						last_part, last_part_size = "", 0
					end

					return table.concat(parts, "", 1, parts_qty)
				end

				if digest_size_in_bytes < 0 then
					result = get_next_part_of_digest
				else
					result = get_next_part_of_digest(digest_size_in_bytes)
				end
			end

			return result
		end
	end

	if message then
		-- Actually perform calculations and return the SHA3 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA3 digest by invoking this function without an argument
		return partial
	end
end

local function HexToBinFunction(hh)
	return string.char(tonumber(hh, 16))
end

local function hex2bin(hex_string)
	return (string.gsub(hex_string, "%x%x", HexToBinFunction))
end

local base64_symbols = {
	["+"] = 62,
	["-"] = 62,
	[62] = "+",
	["/"] = 63,
	["_"] = 63,
	[63] = "/",
	["="] = -1,
	["."] = -1,
	[-1] = "=",
}

local symbol_index = 0
for j, pair in ipairs({ "AZ", "az", "09" }) do
	for ascii = string.byte(pair), string.byte(pair, 2) do
		local ch = string.char(ascii)
		base64_symbols[ch] = symbol_index
		base64_symbols[symbol_index] = ch
		symbol_index = symbol_index + 1
	end
end

local function bin2base64(binary_string)
	local result = table.create(math.ceil(#binary_string / 3))
	local length = 0

	for pos = 1, #binary_string, 3 do
		local c1, c2, c3, c4 = string.byte(string.sub(binary_string, pos, pos + 2) .. "\0", 1, -1)
		length = length + 1
		result[length] = base64_symbols[math.floor(c1 / 4)]
			.. base64_symbols[c1 % 4 * 16 + math.floor(c2 / 16)]
			.. base64_symbols[c3 and c2 % 16 * 4 + math.floor(c3 / 64) or -1]
			.. base64_symbols[c4 and c3 % 64 or -1]
	end

	return table.concat(result)
end

local function base642bin(base64_string)
	local result, chars_qty = {}, 3
	for pos, ch in string.gmatch(string.gsub(base64_string, "%s+", ""), "()(.)") do
		local code = base64_symbols[ch]
		if code < 0 then
			chars_qty = chars_qty - 1
			code = 0
		end

		local idx = pos % 4
		if idx > 0 then
			result[-idx] = code
		else
			local c1 = result[-1] * 4 + math.floor(result[-2] / 16)
			local c2 = (result[-2] % 16) * 16 + math.floor(result[-3] / 4)
			local c3 = (result[-3] % 4) * 64 + code
			result[#result + 1] = string.sub(string.char(c1, c2, c3), 1, chars_qty)
		end
	end

	return table.concat(result)
end

local block_size_for_HMAC -- this table will be initialized at the end of the module
local function pad_and_xor(str, result_length, byte_for_xor)
	return string.gsub(str, ".", function(c)
		return string.char(bit32_bxor(string.byte(c), byte_for_xor))
	end) .. string.rep(string.char(byte_for_xor), result_length - #str)
end

-- For the sake of speed of converting hexes to strings, there's a map of the conversions here
local BinaryStringMap = {}
for Index = 0, 255 do
	BinaryStringMap[string.format("%02x", Index)] = string.char(Index)
end

-- Update 02.14.20 - added AsBinary for easy GameAnalytics replacement.
local function hmac(hash_func, key, message, AsBinary)
	-- Create an instance (private objects for current calculation)
	local block_size = block_size_for_HMAC[hash_func]
	if not block_size then
		error("Unknown hash function", 2)
	end

	if #key > block_size then
		key = string.gsub(hash_func(key), "%x%x", HexToBinFunction)
		--key = hex2bin(hash_func(key))
	end

	local append = hash_func()(pad_and_xor(key, block_size, 0x36))
	local result

	local function partial(message_part)
		if not message_part then
			result = result
				or hash_func(pad_and_xor(key, block_size, 0x5C) .. (string.gsub(append(), "%x%x", HexToBinFunction)))
			return result
		elseif result then
			error("Adding more chunks is not allowed after receiving the result", 2)
		else
			append(message_part)
			return partial
		end
	end

	if message then
		-- Actually perform calculations and return the HMAC of a message
		local FinalMessage = partial(message)()
		return AsBinary and (string.gsub(FinalMessage, "%x%x", BinaryStringMap)) or FinalMessage
	else
		-- Return function for chunk-by-chunk loading of a message
		-- User should feed every chunk of the message as single argument to this function and finally get HMAC by invoking this function without an argument
		return partial
	end
end

local sha = {
	md5 = md5,
	sha1 = sha1,
	-- SHA2 hash functions:
	sha224 = function(message)
		return sha256ext(224, message)
	end,

	sha256 = function(message)
		return sha256ext(256, message)
	end,

	sha512_224 = function(message)
		return sha512ext(224, message)
	end,

	sha512_256 = function(message)
		return sha512ext(256, message)
	end,

	sha384 = function(message)
		return sha512ext(384, message)
	end,

	sha512 = function(message)
		return sha512ext(512, message)
	end,

	-- SHA3 hash functions:
	sha3_224 = function(message)
		return keccak((1600 - 2 * 224) / 8, 224 / 8, false, message)
	end,

	sha3_256 = function(message)
		return keccak((1600 - 2 * 256) / 8, 256 / 8, false, message)
	end,

	sha3_384 = function(message)
		return keccak((1600 - 2 * 384) / 8, 384 / 8, false, message)
	end,

	sha3_512 = function(message)
		return keccak((1600 - 2 * 512) / 8, 512 / 8, false, message)
	end,

	shake128 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 128) / 8, digest_size_in_bytes, true, message)
	end,

	shake256 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 256) / 8, digest_size_in_bytes, true, message)
	end,

	-- misc utilities:
	hmac = hmac, -- HMAC(hash_func, key, message) is applicable to any hash function from this module except SHAKE*
	hex_to_bin = hex2bin, -- converts hexadecimal representation to binary string
	base64_to_bin = base642bin, -- converts base64 representation to binary string
	bin_to_base64 = bin2base64,
	base64_encode = Base64.Encode,
	base64_decode = Base64.Decode,
	-- converts binary string to base64 representation
}

block_size_for_HMAC = {
	[sha.md5] = 64,
	[sha.sha1] = 64,
	[sha.sha224] = 64,
	[sha.sha256] = 64,
	[sha.sha512_224] = 128,
	[sha.sha512_256] = 128,
	[sha.sha384] = 128,
	[sha.sha512] = 128,
	[sha.sha3_224] = (1600 - 2 * 224) / 8,
	[sha.sha3_256] = (1600 - 2 * 256) / 8,
	[sha.sha3_384] = (1600 - 2 * 384) / 8,
	[sha.sha3_512] = (1600 - 2 * 512) / 8,
}

return sha]]></ProtectedString>
									<string name="ScriptGuid">{ADDFCF84-20BB-4E47-AF72-497DC9CA6DF5}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">HashLib.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBXFA1916750FA4466CAFFDB68267A9BD3C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">HashLib</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXB70F01BFE10146169BADECCBA2BAD817">
									<Properties>
										<Content name="LinkedSource"><null></null></Content>
										<ProtectedString name="Source"><![CDATA[-- @original: https://gist.github.com/Reselim/40d62b17d138cc74335a1b0709e19ce2
local Alphabet = {}
local Indexes = {}

-- A-Z
for Index = 65, 90 do
	table.insert(Alphabet, Index)
end

-- a-z
for Index = 97, 122 do
	table.insert(Alphabet, Index)
end

-- 0-9
for Index = 48, 57 do
	table.insert(Alphabet, Index)
end

table.insert(Alphabet, 43) -- +
table.insert(Alphabet, 47) -- /

for Index, Character in ipairs(Alphabet) do
	Indexes[Character] = Index
end

local Base64 = {}

local bit32_rshift = bit32.rshift
local bit32_lshift = bit32.lshift
local bit32_band = bit32.band

--[[**
	Encodes a string in Base64.
	@param [t:string] Input The input string to encode.
	@returns [t:string] The string encoded in Base64.
**--]]
function Base64.Encode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 3 do
		local C1, C2, C3 = string.byte(Input, Index, Index + 2)

		local A = bit32_rshift(C1, 2)
		local B = bit32_lshift(bit32_band(C1, 3), 4) + bit32_rshift(C2 or 0, 4)
		local C = bit32_lshift(bit32_band(C2 or 0, 15), 2) + bit32_rshift(C3 or 0, 6)
		local D = bit32_band(C3 or 0, 63)

		Length = Length + 1
		Output[Length] = Alphabet[A + 1]

		Length = Length + 1
		Output[Length] = Alphabet[B + 1]

		Length = Length + 1
		Output[Length] = C2 and Alphabet[C + 1] or 61

		Length = Length + 1
		Output[Length] = C3 and Alphabet[D + 1] or 61
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] =
			string.char(table.unpack(Output, Index, IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1))
	end

	return table.concat(NewOutput)
end

--[[**
	Decodes a string from Base64.
	@param [t:string] Input The input string to decode.
	@returns [t:string] The newly decoded string.
**--]]
function Base64.Decode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 4 do
		local C1, C2, C3, C4 = string.byte(Input, Index, Index + 3)

		local I1 = Indexes[C1] - 1
		local I2 = Indexes[C2] - 1
		local I3 = (Indexes[C3] or 1) - 1
		local I4 = (Indexes[C4] or 1) - 1

		local A = bit32_lshift(I1, 2) + bit32_rshift(I2, 4)
		local B = bit32_lshift(bit32_band(I2, 15), 4) + bit32_rshift(I3, 2)
		local C = bit32_lshift(bit32_band(I3, 3), 6) + I4

		Length = Length + 1
		Output[Length] = A

		if C3 ~= 61 then
			Length = Length + 1
			Output[Length] = B
		end

		if C4 ~= 61 then
			Length = Length + 1
			Output[Length] = C
		end
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] =
			string.char(table.unpack(Output, Index, IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1))
	end

	return table.concat(NewOutput)
end

return Base64]]></ProtectedString>
										<string name="ScriptGuid">{3C9F7996-77C0-4DE4-AC18-C44521E3FBA6}</string>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">Base64.lua</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX5011030FA25E4163843C355A13C6BD15">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
--local GameAnalyticsSendMessage

local logger = {
	_infoLogEnabled = false,
	_infoLogAdvancedEnabled = false,
	_debugEnabled = false --RunService:IsStudio(),
}

function logger:setDebugLog(enabled)
	self._debugEnabled = enabled
end

function logger:setInfoLog(enabled)
	self._infoLogEnabled = enabled
end

function logger:setVerboseLog(enabled)
	self._infoLogAdvancedEnabled = enabled
end

function logger:i(format)
	if not self._infoLogEnabled then
		return
	end

	local m = "Info/GameAnalytics: " .. format
	print(m)
	--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
	--    GameAnalyticsSendMessage:FireAllClients({
	--        Text = m,
	--        Font = Enum.Font.Arial,
	--        Color = Color3.new(255, 255, 255),
	--        FontSize = Enum.FontSize.Size96
	--    })
end

function logger:w(format)
	local m = "Warning/GameAnalytics: " .. format
	warn(m)
	--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
	--    GameAnalyticsSendMessage:FireAllClients({
	--        Text = m,
	--        Font = Enum.Font.Arial,
	--        Color = Color3.new(255, 255, 0),
	--        FontSize = Enum.FontSize.Size96
	--    })
end

function logger:e(format)
	task.spawn(function()
		local m = "Error/GameAnalytics: " .. format
		error(m, 0)
		--        GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
		--        GameAnalyticsSendMessage:FireAllClients({
		--            Text = m,
		--            Font = Enum.Font.Arial,
		--            Color = Color3.new(255, 0, 0),
		--            FontSize = Enum.FontSize.Size96
		--        })
	end)
end

function logger:d(format)
	if not self._debugEnabled then
		return
	end

	local m = "Debug/GameAnalytics: " .. format
	print(m)
	--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
	--    GameAnalyticsSendMessage:FireAllClients({
	--        Text = m,
	--        Font = Enum.Font.Arial,
	--        Color = Color3.new(255, 255, 255),
	--        FontSize = Enum.FontSize.Size96
	--    })
end

function logger:ii(format)
	if not self._infoLogAdvancedEnabled then
		return
	end

	local m = "Verbose/GameAnalytics: " .. format
	print(m)
	--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
	--    GameAnalyticsSendMessage:FireAllClients({
	--        Text = m,
	--        Font = Enum.Font.Arial,
	--        Color = Color3.new(255, 255, 255),
	--        FontSize = Enum.FontSize.Size96
	--    })
end

return logger]]></ProtectedString>
								<string name="ScriptGuid">{CBFEA257-508C-4670-B890-3A2A690202B2}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Logger.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX7431F143081040DC970BBBE9B8F4550E">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--[[
	Postie 1.1.0 by BenSBk
	Depends on:
	- The Roblox API
	- A RemoteEvent named Sent
	- A RemoteEvent named Received

	Postie is a safe alternative to RemoteFunctions with a time-out.

	Postie.invokeClient( // yields, server-side
		player: Player,
		id: string,
		timeOut: number,
		...data: any
	) => didRespond: boolean, ...response: any

		Invoke player with sent data. Invocation identified by id. Yield until
		timeOut (given in seconds) is reached and return false, or a response is
		received back from the client and return true plus the data returned
		from the client. If the invocation reaches the client, but the client
		doesn't have a corresponding callback, return before timeOut regardless
		but return false.

	Postie.invokeServer( // yields, client-side
		id: string,
		timeOut: number,
		...data: any
	) => didRespond: boolean, ...response: any

		Invoke the server with sent data. Invocation identified by id. Yield
		until timeOut (given in seconds) is reached and return false, or a
		response is received back from the server and return true plus the data
		returned from the server. If the invocation reaches the server, but the
		server doesn't have a corresponding callback, return before timeOut
		regardless but return false.

	Postie.setCallback(
		id: string,
		callback?: (...data: any) -> ...response: any
	)

		Set the callback that is invoked when an invocation identified by id is
		sent. Data sent with the invocation are passed to the callback. If on
		the server, the player who invoked is implicitly received as the first
		argument.

	Postie.getCallback(
		id: string
	) => callback?: (...data: any) -> ...response: any

		Return the callback corresponding with id.
]]

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local replicatedStorage = game:GetService("ReplicatedStorage")

if not replicatedStorage:FindFirstChild("PostieSent") then
	--Create
	local f = Instance.new("RemoteEvent")
	f.Name = "PostieSent"
	f.Parent = replicatedStorage
end

if not replicatedStorage:FindFirstChild("PostieReceived") then
	--Create
	local f = Instance.new("RemoteEvent")
	f.Name = "PostieReceived"
	f.Parent = replicatedStorage
end

local sent = replicatedStorage.PostieSent -- RemoteEvent
local received = replicatedStorage.PostieReceived -- RemoteEvent

local isServer = RunService:IsServer()
local callbackById = {}
local listenerByUuid = {}

local Postie = {}

function Postie.invokeClient(id: string, player: Player, timeOut: number, ...: any): (boolean, ...any)
	assert(isServer, "Postie.invokeClient can only be called from the server")

	local thread = coroutine.running()
	local isResumed = false
	local uuid = HttpService:GenerateGUID(false)

	-- We await a signal from the client.
	listenerByUuid[uuid] = function(playerWhoFired, didInvokeCallback, ...)
		if playerWhoFired ~= player then
			-- The client lied about the UUID.
			return
		end
		isResumed = true
		listenerByUuid[uuid] = nil
		if didInvokeCallback then
			task.spawn(thread, true, ...)
		else
			task.spawn(thread, false)
		end
	end

	-- We await the time-out.
	task.delay(timeOut, function()
		if isResumed then
			return
		end
		listenerByUuid[uuid] = nil
		task.spawn(thread, false)
	end)

	-- Finally, we send the signal to the client and await either the client's
	-- response or the time-out.
	sent:FireClient(player, id, uuid, ...)
	return coroutine.yield()
end

function Postie.invokeServer(id: string, timeOut: number, ...: any): (boolean, ...any)
	assert(not isServer, "Postie.invokeServer can only be called from the client")

	local thread = coroutine.running()
	local isResumed = false
	local uuid = HttpService:GenerateGUID(false)

	-- We await a signal from the client.
	listenerByUuid[uuid] = function(didInvokeCallback, ...)
		isResumed = true
		listenerByUuid[uuid] = nil
		if didInvokeCallback then
			task.spawn(thread, true, ...)
		else
			task.spawn(thread, false)
		end
	end

	-- We await the time-out.
	task.delay(timeOut, function()
		if isResumed then
			return
		end
		listenerByUuid[uuid] = nil
		task.spawn(thread, false)
	end)

	-- Finally, we send the signal to the client and await either the client's
	-- response or the time-out.
	sent:FireServer(id, uuid, ...)
	return coroutine.yield()
end

function Postie.setCallback(id: string, callback: ((...any) -> ...any)?)
	callbackById[id] = callback
end

function Postie.getCallback(id: string): ((...any) -> ...any)?
	return callbackById[id]
end

if isServer then
	-- We handle responses received from the client.
	received.OnServerEvent:Connect(function(player, uuid, didInvokeCallback, ...)
		local listener = listenerByUuid[uuid]
		if not listener then
			return
		end
		listener(player, didInvokeCallback, ...)
	end)

	-- We handle requests sent by the client.
	sent.OnServerEvent:Connect(function(player, id, uuid, ...)
		local callback = callbackById[id]
		if callback then
			received:FireClient(player, uuid, true, callback(player, ...))
		else
			received:FireClient(player, uuid, false)
		end
	end)
else
	-- We handle responses received from the server.
	received.OnClientEvent:Connect(function(uuid, didInvokeCallback, ...)
		local listener = listenerByUuid[uuid]
		if not listener then
			return
		end
		listener(didInvokeCallback, ...)
	end)

	-- We handle requests sent by the server.
	sent.OnClientEvent:Connect(function(id, uuid, ...)
		local callback = callbackById[id]
		if callback then
			received:FireServer(uuid, true, callback(...))
		else
			received:FireServer(uuid, false)
		end
	end)
end

return Postie]]></ProtectedString>
								<string name="ScriptGuid">{909D63B6-001F-4401-8056-98905624DB72}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Postie.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3D52A0C442484AD6BD479F4F82192E66">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local validation = require(script.Parent.Validation)
local logger = require(script.Parent.Logger)
local http_api = require(script.Parent.HttpApi)
local store = require(script.Parent.Store)
local events = require(script.Parent.Events)
local HTTP = game:GetService("HttpService")

local state = {
	_availableCustomDimensions01 = {},
	_availableCustomDimensions02 = {},
	_availableCustomDimensions03 = {},
	_availableGamepasses = {},
	_enableEventSubmission = true,
	Initialized = false,
	ReportErrors = true,
	UseCustomUserId = false,
	AutomaticSendBusinessEvents = true,
	ConfigsHash = "",
}

local GameAnalyticsRemoteConfigs

local function getClientTsAdjusted(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	if not PlayerData then
		return os.time()
	end

	local clientTs = os.time()
	local clientTsAdjustedInteger = clientTs + PlayerData.ClientServerTimeOffset
	if validation:validateClientTs(clientTsAdjustedInteger) then
		return clientTsAdjustedInteger
	else
		return clientTs
	end
end

local function populateConfigurations(player)
	local PlayerData = store:GetPlayerDataFromCache(player.UserId)
	local sdkConfig = PlayerData.SdkConfig

	if sdkConfig["configs"] then
		local configurations = sdkConfig["configs"]

		for _, configuration in pairs(configurations) do
			if configuration then
				local key = configuration["key"] or ""
				local start_ts = configuration["start_ts"] or 0
				local end_ts = configuration["end_ts"] or math.huge
				local client_ts_adjusted = getClientTsAdjusted(player.UserId)

				if
					#key > 0
					and configuration["value"]
					and client_ts_adjusted > start_ts
					and client_ts_adjusted < end_ts
				then
					PlayerData.Configurations[key] = configuration["value"]
					logger:d(
						"configuration added: key=" .. configuration["key"] .. ", value=" .. configuration["value"]
					)
				end
			end
		end
	end

	logger:i("Remote configs populated")

	PlayerData.RemoteConfigsIsReady = true
	GameAnalyticsRemoteConfigs = GameAnalyticsRemoteConfigs
		or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsRemoteConfigs")
	GameAnalyticsRemoteConfigs:FireClient(player, PlayerData.Configurations)
end

function state:sessionIsStarted(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	if not PlayerData then
		return false
	end

	return PlayerData.SessionStart ~= 0
end

function state:isEnabled(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	if not PlayerData then
		return false
	elseif not PlayerData.InitAuthorized then
		return false
	else
		return true
	end
end

function state:validateAndFixCurrentDimensions(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)

	-- validate that there are no current dimension01 not in list
	if not validation:validateDimension(self._availableCustomDimensions01, PlayerData.CurrentCustomDimension01) then
		logger:d(
			"Invalid dimension01 found in variable. Setting to nil. Invalid dimension: "
				.. PlayerData.CurrentCustomDimension01
		)
	end

	-- validate that there are no current dimension02 not in list
	if not validation:validateDimension(self._availableCustomDimensions02, PlayerData.CurrentCustomDimension02) then
		logger:d(
			"Invalid dimension02 found in variable. Setting to nil. Invalid dimension: "
				.. PlayerData.CurrentCustomDimension02
		)
	end

	-- validate that there are no current dimension03 not in list
	if not validation:validateDimension(self._availableCustomDimensions03, PlayerData.CurrentCustomDimension03) then
		logger:d(
			"Invalid dimension03 found in variable. Setting to nil. Invalid dimension: "
				.. PlayerData.CurrentCustomDimension03
		)
	end
end

function state:setAvailableCustomDimensions01(availableCustomDimensions)
	if not validation:validateCustomDimensions(availableCustomDimensions) then
		return
	end

	self._availableCustomDimensions01 = availableCustomDimensions
	logger:i("Set available custom01 dimension values: (" .. table.concat(availableCustomDimensions, ", ") .. ")")
end

function state:setAvailableCustomDimensions02(availableCustomDimensions)
	if not validation:validateCustomDimensions(availableCustomDimensions) then
		return
	end

	self._availableCustomDimensions02 = availableCustomDimensions
	logger:i("Set available custom02 dimension values: (" .. table.concat(availableCustomDimensions, ", ") .. ")")
end

function state:setAvailableCustomDimensions03(availableCustomDimensions)
	if not validation:validateCustomDimensions(availableCustomDimensions) then
		return
	end

	self._availableCustomDimensions03 = availableCustomDimensions
	logger:i("Set available custom03 dimension values: (" .. table.concat(availableCustomDimensions, ", ") .. ")")
end

function state:setAvailableGamepasses(availableGamepasses)
	self._availableGamepasses = availableGamepasses
	logger:i("Set available game passes: (" .. table.concat(availableGamepasses, ", ") .. ")")
end

function state:setEventSubmission(flag)
	self._enableEventSubmission = flag
end

function state:isEventSubmissionEnabled()
	return self._enableEventSubmission
end

function state:setCustomDimension01(playerId, dimension)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	PlayerData.CurrentCustomDimension01 = dimension
end

function state:setCustomDimension02(playerId, dimension)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	PlayerData.CurrentCustomDimension02 = dimension
end

function state:setCustomDimension03(playerId, dimension)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	PlayerData.CurrentCustomDimension03 = dimension
end

function state:startNewSession(player, teleportData, customFields)
	if state:isEventSubmissionEnabled() and teleportData == nil then
		logger:i("Starting a new session.")
	end

	local PlayerData = store:GetPlayerDataFromCache(player.UserId)

	-- make sure the current custom dimensions are valid
	state:validateAndFixCurrentDimensions(player.UserId)

	local initResult = http_api:initRequest(events.GameKey, events.SecretKey, events.Build, PlayerData, player.UserId)
	local statusCode = initResult.statusCode
	local responseBody = initResult.body

	if
		(statusCode == http_api.EGAHTTPApiResponse.Ok or statusCode == http_api.EGAHTTPApiResponse.Created)
		and responseBody
	then
		-- set the time offset - how many seconds the local time is different from servertime
		local timeOffsetSeconds = 0
		local serverTs = responseBody["server_ts"] or -1
		if serverTs > 0 then
			local clientTs = os.time()
			timeOffsetSeconds = serverTs - clientTs
		end

		responseBody["time_offset"] = timeOffsetSeconds

		if not (statusCode == http_api.EGAHTTPApiResponse.Created) then
			local sdkConfig = PlayerData.SdkConfig

			if sdkConfig["configs"] then
				responseBody["configs"] = sdkConfig["configs"]
			end

			if sdkConfig["ab_id"] then
				responseBody["ab_id"] = sdkConfig["ab_id"]
			end

			if sdkConfig["ab_variant_id"] then
				responseBody["ab_variant_id"] = sdkConfig["ab_variant_id"]
			end
		end

		PlayerData.SdkConfig = responseBody
		PlayerData.InitAuthorized = true
	elseif statusCode == http_api.EGAHTTPApiResponse.Unauthorized then
		logger:w("Initialize SDK failed - Unauthorized")
		PlayerData.InitAuthorized = false
	else
		-- log the status if no connection
		if
			statusCode == http_api.EGAHTTPApiResponse.NoResponse
			or statusCode == http_api.EGAHTTPApiResponse.RequestTimeout
		then
			logger:i("Init call (session start) failed - no response. Could be offline or timeout.")
		elseif
			statusCode == http_api.EGAHTTPApiResponse.BadResponse
			or statusCode == http_api.EGAHTTPApiResponse.JsonEncodeFailed
			or statusCode == http_api.EGAHTTPApiResponse.JsonDecodeFailed
		then
			logger:i("Init call (session start) failed - bad response. Could be bad response from proxy or GA servers.")
		elseif
			statusCode == http_api.EGAHTTPApiResponse.BadRequest
			or statusCode == http_api.EGAHTTPApiResponse.UnknownResponseCode
		then
			logger:i("Init call (session start) failed - bad request or unknown response.")
		end

		PlayerData.InitAuthorized = true
	end

	-- set offset in state (memory) from current config (config could be from cache etc.)
	PlayerData.ClientServerTimeOffset = PlayerData.SdkConfig["time_offset"] or 0
	PlayerData.ConfigsHash = PlayerData.SdkConfig["configs_hash"] or ""
	PlayerData.AbId = PlayerData.SdkConfig["ab_id"] or ""
	PlayerData.AbVariantId = PlayerData.SdkConfig["ab_variant_id"] or ""

	-- populate configurations
	populateConfigurations(player)

	if not state:isEnabled(player.UserId) then
		logger:w("Could not start session: SDK is disabled.")
		return
	end

	if teleportData then
		PlayerData.SessionID = teleportData.SessionID
		PlayerData.SessionStart = teleportData.SessionStart
	else
		PlayerData.SessionID = string.lower(HTTP:GenerateGUID(false))
		PlayerData.SessionStart = getClientTsAdjusted(player.UserId)
	end

	if state:isEventSubmissionEnabled() then
		events:addSessionStartEvent(player.UserId, teleportData, customFields)
	end
end

function state:endSession(playerId, customFields)
	if state.Initialized and state:isEventSubmissionEnabled() then
		logger:i("Ending session.")
		if state:isEnabled(playerId) and state:sessionIsStarted(playerId) then
			events:addSessionEndEvent(playerId, customFields)
			store.PlayerCache[playerId] = nil
		end
	end
end

function state:getRemoteConfigsStringValue(playerId, key, defaultValue)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	return PlayerData.Configurations[key] or defaultValue
end

function state:isRemoteConfigsReady(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	return PlayerData.RemoteConfigsIsReady
end

function state:getRemoteConfigsContentAsString(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	return HTTP:JSONEncode(PlayerData.Configurations)
end

return state]]></ProtectedString>
								<string name="ScriptGuid">{9027A710-D7FC-40E8-9285-D1C0EECFEE2F}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">State.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3F070CAA91F148B3A198D6F455C33B9D">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local DS = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")
local DSQ = require(script.DataStoreQueue)

local store = {
	PlayerDS = RunService:IsStudio() and {} or DS:GetDataStore("GA_PlayerDS_1.0.0"),
	AutoSaveData = 180, --Set to 0 to disable
	BasePlayerData = {
		Sessions = 0,
		Transactions = 0,
		ProgressionTries = {},
		CurrentCustomDimension01 = "",
		CurrentCustomDimension02 = "",
		CurrentCustomDimension03 = "",
		ConfigsHash = "",
		AbId = "",
		AbVariantId = "",
		InitAuthorized = false,
		SdkConfig = {},
		ClientServerTimeOffset = 0,
		Configurations = {},
		RemoteConfigsIsReady = false,
		PlayerTeleporting = false,
		OwnedGamepasses = nil, --nil means a completely new player. {} means player with no game passes
		CountryCode = "",
		CustomUserId = "",
	},

	DataToSave = {
		"Sessions",
		"Transactions",
		"ProgressionTries",
		"CurrentCustomDimension01",
		"CurrentCustomDimension02",
		"CurrentCustomDimension03",
		"OwnedGamepasses",
	},

	--Cache
	PlayerCache = {},
	EventsQueue = {},
	DataStoreQueue = DSQ,
}

function store:GetPlayerData(Player)
	local key = Player.UserId
	local success, PlayerData = DSQ.AddRequest(key, function()
		return RunService:IsStudio() and {} or (store.PlayerDS:GetAsync(key) or {})
	end, 7) -- Add to a queue with 7s delay between each request

	if not success then
		PlayerData = {}
	end
	return PlayerData
end

function store:GetPlayerDataFromCache(userId)
	local playerData = store.PlayerCache[tonumber(userId)]
	if playerData then
		return playerData
	end
	playerData = store.PlayerCache[tostring(userId)]
	return playerData
end

function store:GetErrorDataStore(scope)
	local ErrorDS
	local success = pcall(function()
		ErrorDS = RunService:IsStudio() and {} or DS:GetDataStore("GA_ErrorDS_1.0.0", scope)
	end)

	if not success then
		ErrorDS = {}
	end

	return ErrorDS
end

function store:SavePlayerData(Player)
	--Variables
	local PlayerData = store:GetPlayerDataFromCache(Player.UserId)
	local SavePlayerData = {}

	if not PlayerData then
		return
	end

	--Fill
	for _, key in pairs(store.DataToSave) do
		SavePlayerData[key] = PlayerData[key]
	end

	--Save
	local key = Player.UserId
	if not RunService:IsStudio() then
		DSQ.AddRequest(key, function()
			return store.PlayerDS:SetAsync(key, SavePlayerData)
		end, 7)
	end
end

function store:IncrementErrorCount(ErrorDS, ErrorKey, step)
	if not ErrorKey then
		return
	end

	local count = 0
	--Increment count
	if not RunService:IsStudio() then
		--Increment count
		_, count = DSQ.AddRequest(ErrorKey, function()
			return ErrorDS:IncrementAsync(ErrorKey, step)
		end, 7)
	end
	return count
end
return store]]></ProtectedString>
								<string name="ScriptGuid">{3507B0B9-9EAE-4D6B-9A02-1D1BE96495AD}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Store.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXE0B394626DE349E7A363D5F4988769F9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Store</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX4356819C3AE7429BBCE05CBE133B8320">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local DataStoreManager = {}
DataStoreManager.QR = true
DataStoreManager.Queue = {}
DataStoreManager.Process = 0
local LastRequest = {}

task.spawn(function()
	while DataStoreManager.QR do
		task.wait()
		if #DataStoreManager.Queue > 0 then
			local Request = DataStoreManager.Queue[1]
			table.remove(DataStoreManager.Queue, 1)
			if not LastRequest[Request.Key] then
				LastRequest[Request.Key] = 0
			end

			DataStoreManager.Process += 1
			local remain = (Request.Delay + LastRequest[Request.Key]) - DateTime.now().UnixTimestamp
			if remain <= 0 then
				remain = 0
			end
			task.delay(remain, function()
				local Success, Error, ds
				repeat
					LastRequest[Request.Key] = DateTime.now().UnixTimestamp
					Success, Error, ds = pcall(Request.Func)

					if not Success then
						warn(Error)
					end
					if Success and Error then
						break
					end
					if not Request.Delay then
						break
					end
					task.wait(Request.Delay)
				until Success and Error
				Request.Event:Fire(Success, Error, ds)
				DataStoreManager.Process -= 1
				LastRequest[Request.Key] = DateTime.now().UnixTimestamp
			end)
		end
	end
end)

function DataStoreManager.AddRequest(Key, Request, Delay)
	local FinishedEvent = Instance.new("BindableEvent")
	table.insert(DataStoreManager.Queue, {
		Key = Key,
		Delay = Delay,
		Func = Request,
		Event = FinishedEvent,
	})
	local Success, ValOrErr, ds = FinishedEvent.Event:Wait()
	return Success, ValOrErr, ds
end

function DataStoreManager.RemoveKey(Key)
	LastRequest[Key] = nil
end
return DataStoreManager]]></ProtectedString>
									<string name="ScriptGuid">{386C8F42-039A-43B4-BCB2-CC575C393EE7}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">DataStoreQueue.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX239197BE5F6F466FB8753AAFB8EFA0D0">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local threading = {
	_canSafelyClose = true,
	_endThread = false,
	_isRunning = false,
	_blocks = {},
	_scheduledBlock = nil,
	_hasScheduledBlockRun = true,
}

local logger = require(script.Parent.Logger)
local RunService = game:GetService("RunService")

local function getScheduledBlock()
	local now = tick()

	if
		not threading._hasScheduledBlockRun
		and threading._scheduledBlock ~= nil
		and threading._scheduledBlock.deadline <= now
	then
		threading._hasScheduledBlockRun = true
		return threading._scheduledBlock
	else
		return nil
	end
end

local function run()
	task.spawn(function()
		logger:d("Starting GA thread")

		while not threading._endThread do
			threading._canSafelyClose = false

			if #threading._blocks ~= 0 then
				for _, b in pairs(threading._blocks) do
					local s, e = pcall(b.block)
					if not s then
						logger:e(e)
					end
				end

				threading._blocks = {}
			end

			local timedBlock = getScheduledBlock()
			if timedBlock ~= nil then
				local s, e = pcall(timedBlock.block)
				if not s then
					logger:e(e)
				end
			end

			threading._canSafelyClose = true
			task.wait(1)
		end

		logger:d("GA thread stopped")
	end)

	--Safely Close
	game:BindToClose(function()
		-- waiting bug fix to work inside studio
		if RunService:IsStudio() then
			return
		end

		--Give game.Players.PlayerRemoving time to to its thang
		task.wait(1)

		--Delay
		if not threading._canSafelyClose then
			repeat
				task.wait()
			until threading._canSafelyClose
		end

		task.wait(3)
	end)
end

function threading:scheduleTimer(interval, callback)
	if self._endThread then
		return
	end

	if not self._isRunning then
		self._isRunning = true
		run()
	end

	local timedBlock = {
		block = callback,
		deadline = tick() + interval,
	}

	if self._hasScheduledBlockRun then
		self._scheduledBlock = timedBlock
		self._hasScheduledBlockRun = false
	end
end

function threading:performTaskOnGAThread(callback)
	if self._endThread then
		return
	end

	if not self._isRunning then
		self._isRunning = true
		run()
	end

	local timedBlock = {
		block = callback,
	}

	self._blocks[#self._blocks + 1] = timedBlock
end

function threading:stopThread()
	self._endThread = true
end

return threading]]></ProtectedString>
								<string name="ScriptGuid">{2FC4F095-881D-4871-9BF5-D4F292DE6F0A}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Threading.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXBA79669375A246D28C8D583D5E8C9EE3">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[type EventOptions = {
	customFields: { [string]: string }?,
}

export type BusinessEventOptions = EventOptions & {
	amount: number,
	itemType: string,
	itemId: string,
	cartType: string?,
}

export type ResourceEventOptions = EventOptions & {
	flowType: number,
	currency: string,
	amount: number,
	itemType: string,
	itemId: string,
}

export type ProgressionEventOptions = EventOptions & {
	progressionStatus: number,
	progression01: string,
	progression02: string?,
	progression03: string?,
	score: number?,
}

export type DesignEventOptions = EventOptions & {
	eventId: string,
	value: number?,
}

export type ErrorEventOptions = EventOptions & {
	message: string,
	severity: number,
}

export type CustomDimension = string

export type ProductInfo = {
	Name: string,
	PriceInRobux: number,
}

export type ProcessReceiptInfo = {
	ProductId: number,
	PlayerId: number,
	CurrencySpent: number,
}

export type TeleportData = { [string]: any }
export type RemoteConfigs = { [string]: any }

export type GameAnalyticsOptions = {
	enableInfoLog: boolean?,
	enableVerboseLog: boolean?,
	availableCustomDimensions01: { CustomDimension }?,
	availableCustomDimensions02: { CustomDimension }?,
	availableCustomDimensions03: { CustomDimension }?,
	availableResourceCurrencies: { string }?,
	availableResourceItemTypes: { string }?,
	build: string?,
	availableGamepasses: { string }?,
	enableDebugLog: boolean?,
	automaticSendBusinessEvents: boolean?,
	reportErrors: boolean?,
	useCustomUserId: boolean?,
	gameKey: string?,
	secretKey: string?,
}

return {}]]></ProtectedString>
								<string name="ScriptGuid">{EA767828-90C5-48B4-85D1-C6CC22EA4C3A}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Types.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0F7063C0995148C6968370975247124C">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local utilities = {}

function utilities:isStringNullOrEmpty(s)
	return (not s) or #s == 0
end

function utilities:stringArrayContainsString(array, search)
	if #array == 0 then
		return false
	end

	for _, s in ipairs(array) do
		if s == search then
			return true
		end
	end

	return false
end

function utilities:copyTable(t)
	local copy = {}
	for k, v in pairs(t) do
		if typeof(v) == "table" then
			copy[k] = self:copyTable(v)
		else
			copy[k] = v
		end
	end
	return copy
end

return utilities]]></ProtectedString>
								<string name="ScriptGuid">{A79D0511-9CE5-4A0E-91A0-16ACB871EBF7}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Utilities.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX63A3DEA96E0A44C0B30C63D5973747E7">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local validation = {}

local logger = require(script.Parent.Logger)
local utilities = require(script.Parent.Utilities)

function validation:validateCustomDimensions(customDimensions)
	return validation:validateArrayOfStrings(20, 32, false, "custom dimensions", customDimensions)
end

function validation:validateDimension(dimensions, dimension)
	-- allow nil
	if utilities:isStringNullOrEmpty(dimension) then
		return true
	end

	if not utilities:stringArrayContainsString(dimensions, dimension) then
		return false
	end

	return true
end

function validation:validateResourceCurrencies(resourceCurrencies)
	if not validation:validateArrayOfStrings(20, 64, false, "resource currencies", resourceCurrencies) then
		return false
	end

	-- validate each string for regex
	for _, resourceCurrency in pairs(resourceCurrencies) do
		if not string.find(resourceCurrency, "^[A-Za-z]+$") then
			logger:w(
				"resource currencies validation failed: a resource currency can only be A-Z, a-z. String was: "
					.. resourceCurrency
			)
			return false
		end
	end

	return true
end

function validation:validateResourceItemTypes(resourceItemTypes)
	if not validation:validateArrayOfStrings(20, 32, false, "resource item types", resourceItemTypes) then
		return false
	end

	-- validate each string for regex
	for _, resourceItemType in pairs(resourceItemTypes) do
		if not validation:validateEventPartCharacters(resourceItemType) then
			logger:w(
				"resource item types validation failed: a resource item type cannot contain other characters than A-z, 0-9, -_., ()!?. String was: "
					.. resourceItemType
			)
			return false
		end
	end

	return true
end

function validation:validateEventPartCharacters(eventPart)
	if not string.find(eventPart, "^[A-Za-z0-9%s%-_%.%(%)!%?]+$") then
		return false
	end

	return true
end

function validation:validateArrayOfStrings(maxCount, maxStringLength, allowNoValues, logTag, arrayOfStrings)
	local arrayTag = logTag

	if not arrayTag then
		arrayTag = "Array"
	end

	-- use arrayTag to annotate warning log
	if not arrayOfStrings then
		logger:w(arrayTag .. " validation failed: array cannot be nil.")
		return false
	end

	-- check if empty
	if not allowNoValues and #arrayOfStrings == 0 then
		logger:w(arrayTag .. " validation failed: array cannot be empty.")
		return false
	end

	-- check if exceeding max count
	if maxCount > 0 and #arrayOfStrings > maxCount then
		logger:w(
			arrayTag
				.. " validation failed: array cannot exceed "
				.. tostring(maxCount)
				.. " values. It has "
				.. #arrayOfStrings
				.. " values."
		)
		return false
	end

	-- validate each string
	for _, arrayString in ipairs(arrayOfStrings) do
		local stringLength = 0
		if arrayString then
			stringLength = #arrayString
		end

		-- check if empty (not allowed)
		if stringLength == 0 then
			logger:w(arrayTag .. " validation failed: contained an empty string.")
			return false
		end

		-- check if exceeding max length
		if maxStringLength > 0 and stringLength > maxStringLength then
			logger:w(
				arrayTag
					.. " validation failed: a string exceeded max allowed length (which is: "
					.. tostring(maxStringLength)
					.. "). String was: "
					.. arrayString
			)
			return false
		end
	end

	return true
end

function validation:validateBuild(build)
	if not validation:validateShortString(build, false) then
		return false
	end

	return true
end

function validation:validateShortString(shortString, canBeEmpty)
	-- String is allowed to be empty or nil
	if canBeEmpty and utilities:isStringNullOrEmpty(shortString) then
		return true
	end

	if utilities:isStringNullOrEmpty(shortString) or #shortString > 32 then
		return false
	end

	return true
end

function validation:validateKeys(gameKey, secretKey)
	if string.find(gameKey, "^[A-Za-z0-9]+$") and #gameKey == 32 then
		if string.find(secretKey, "^[A-Za-z0-9]+$") and #secretKey == 40 then
			return true
		end
	end

	return false
end

function validation:validateAndCleanInitRequestResponse(initResponse, configsCreated)
	-- make sure we have a valid dict
	if not initResponse then
		logger:w("validateInitRequestResponse failed - no response dictionary.")
		return nil
	end

	local validatedDict = {}

	-- validate server_ts
	local serverTsNumber = initResponse["server_ts"] or -1
	if serverTsNumber > 0 then
		validatedDict["server_ts"] = serverTsNumber
	end

	if configsCreated then
		validatedDict["configs"] = initResponse["configs"] or {}
		validatedDict["ab_id"] = initResponse["ab_id"] or ""
		validatedDict["ab_variant_id"] = initResponse["ab_variant_id"] or ""
	end

	return validatedDict
end

function validation:validateClientTs(clientTs)
	if clientTs < 1000000000 or clientTs > 9999999999 then
		return false
	end

	return true
end

function validation:validateCurrency(currency)
	if utilities:isStringNullOrEmpty(currency) then
		return false
	end

	if string.find(currency, "^[A-Z]+$") and #currency == 3 then
		return true
	end

	return false
end

function validation:validateEventPartLength(eventPart, allowNull)
	if allowNull and utilities:isStringNullOrEmpty(eventPart) then
		return true
	end

	if utilities:isStringNullOrEmpty(eventPart) then
		return false
	end

	if #eventPart == 0 or #eventPart > 64 then
		return false
	end
	return true
end

function validation:validateBusinessEvent(currency, amount, cartType, itemType, itemId)
	-- validate currency
	if not validation:validateCurrency(currency) then
		logger:w(
			"Validation fail - business event - currency: Cannot be (null) and need to be A-Z, 3 characters and in the standard at openexchangerates.org. Failed currency: "
				.. currency
		)
		return false
	end

	if amount < 0 then
		logger:w("Validation fail - business event - amount: Cannot be less then 0. Failed amount: " .. amount)
		return false
	end

	-- validate cartType
	if not validation:validateShortString(cartType, true) then
		logger:w("Validation fail - business event - cartType. Cannot be above 32 length. String: " .. cartType)
		return false
	end

	-- validate itemType length
	if not validation:validateEventPartLength(itemType, false) then
		logger:w(
			"Validation fail - business event - itemType: Cannot be (null), empty or above 64 characters. String: "
				.. itemType
		)
		return false
	end

	-- validate itemType chars
	if not validation:validateEventPartCharacters(itemType) then
		logger:w(
			"Validation fail - business event - itemType: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. itemType
		)
		return false
	end

	-- validate itemId
	if not validation:validateEventPartLength(itemId, false) then
		logger:w(
			"Validation fail - business event - itemId. Cannot be (null), empty or above 64 characters. String: "
				.. itemId
		)
		return false
	end

	if not validation:validateEventPartCharacters(itemId) then
		logger:w(
			"Validation fail - business event - itemId: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. itemId
		)
		return false
	end

	return true
end

function validation:validateResourceEvent(
	flowTypeValues,
	flowType,
	currency,
	amount,
	itemType,
	itemId,
	currencies,
	itemTypes
)
	if flowType ~= flowTypeValues.Source and flowType ~= flowTypeValues.Sink then
		logger:w("Validation fail - resource event - flowType: Invalid flow type " .. tostring(flowType))
		return false
	end

	if utilities:isStringNullOrEmpty(currency) then
		logger:w("Validation fail - resource event - currency: Cannot be (null)")
		return false
	end

	if not utilities:stringArrayContainsString(currencies, currency) then
		logger:w(
			"Validation fail - resource event - currency: Not found in list of pre-defined available resource currencies. String: "
				.. currency
		)
		return false
	end

	if not (amount > 0) then
		logger:w(
			"Validation fail - resource event - amount: Float amount cannot be 0 or negative. Value: "
				.. tostring(amount)
		)
		return false
	end

	if utilities:isStringNullOrEmpty(itemType) then
		logger:w("Validation fail - resource event - itemType: Cannot be (null)")
		return false
	end

	if not validation:validateEventPartLength(itemType, false) then
		logger:w(
			"Validation fail - resource event - itemType: Cannot be (null), empty or above 64 characters. String: "
				.. itemType
		)
		return false
	end

	if not validation:validateEventPartCharacters(itemType) then
		logger:w(
			"Validation fail - resource event - itemType: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. itemType
		)
		return false
	end

	if not utilities:stringArrayContainsString(itemTypes, itemType) then
		logger:w(
			"Validation fail - resource event - itemType: Not found in list of pre-defined available resource itemTypes. String: "
				.. itemType
		)
		return false
	end

	if not validation:validateEventPartLength(itemId, false) then
		logger:w(
			"Validation fail - resource event - itemId: Cannot be (null), empty or above 64 characters. String: "
				.. itemId
		)
		return false
	end

	if not validation:validateEventPartCharacters(itemId) then
		logger:w(
			"Validation fail - resource event - itemId: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. itemId
		)
		return false
	end

	return true
end

function validation:validateProgressionEvent(
	progressionStatusValues,
	progressionStatus,
	progression01,
	progression02,
	progression03
)
	if
		progressionStatus ~= progressionStatusValues.Start
		and progressionStatus ~= progressionStatusValues.Complete
		and progressionStatus ~= progressionStatusValues.Fail
	then
		logger:w("Validation fail - progression event: Invalid progression status " .. tostring(progressionStatus))
		return false
	end

	-- Make sure progressions are defined as either 01, 01+02 or 01+02+03
	if
		not utilities:isStringNullOrEmpty(progression03)
		and not (not utilities:isStringNullOrEmpty(progression02) or utilities:isStringNullOrEmpty(progression01))
	then
		logger:w(
			"Validation fail - progression event: 03 found but 01+02 are invalid. Progression must be set as either 01, 01+02 or 01+02+03."
		)
		return false
	elseif not utilities:isStringNullOrEmpty(progression02) and utilities:isStringNullOrEmpty(progression01) then
		logger:w(
			"Validation fail - progression event: 02 found but not 01. Progression must be set as either 01, 01+02 or 01+02+03"
		)
		return false
	elseif utilities:isStringNullOrEmpty(progression01) then
		logger:w(
			"Validation fail - progression event: progression01 not valid. Progressions must be set as either 01, 01+02 or 01+02+03"
		)
		return false
	end

	-- progression01 (required)
	if not validation:validateEventPartLength(progression01, false) then
		logger:w(
			"Validation fail - progression event - progression01: Cannot be (null), empty or above 64 characters. String: "
				.. progression01
		)
		return false
	end

	if not validation:validateEventPartCharacters(progression01) then
		logger:w(
			"Validation fail - progression event - progression01: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. progression01
		)
		return false
	end

	-- progression02
	if not utilities:isStringNullOrEmpty(progression02) then
		if not validation:validateEventPartLength(progression02, false) then
			logger:w(
				"Validation fail - progression event - progression02: Cannot be empty or above 64 characters. String: "
					.. progression02
			)
			return false
		end

		if not validation:validateEventPartCharacters(progression02) then
			logger:w(
				"Validation fail - progression event - progression02: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
					.. progression02
			)
			return false
		end
	end

	-- progression03
	if not utilities:isStringNullOrEmpty(progression03) then
		if not validation:validateEventPartLength(progression03, false) then
			logger:w(
				"Validation fail - progression event - progression03: Cannot be empty or above 64 characters. String: "
					.. progression03
			)
			return false
		end

		if not validation:validateEventPartCharacters(progression03) then
			logger:w(
				"Validation fail - progression event - progression03: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
					.. progression03
			)
			return false
		end
	end

	return true
end

function validation:validateEventIdLength(eventId)
	if utilities:isStringNullOrEmpty(eventId) then
		return false
	end

	local count = 0
	for s in string.gmatch(eventId, "([^:]+)") do
		count = count + 1
		if count > 5 or #s > 64 then
			return false
		end
	end

	return true
end

function validation:validateEventIdCharacters(eventId)
	if utilities:isStringNullOrEmpty(eventId) then
		return false
	end

	local count = 0
	for s in string.gmatch(eventId, "([^:]+)") do
		count = count + 1
		if count > 5 or not string.find(s, "^[A-Za-z0-9%s%-_%.%(%)!%?]+$") then
			return false
		end
	end

	return true
end

function validation:validateDesignEvent(eventId)
	if not validation:validateEventIdLength(eventId) then
		logger:w(
			"Validation fail - design event - eventId: Cannot be (null) or empty. Only 5 event parts allowed seperated by :. Each part need to be 32 characters or less. String: "
				.. eventId
		)
		return false
	end

	if not validation:validateEventIdCharacters(eventId) then
		logger:w(
			"Validation fail - design event - eventId: Non valid characters. Only allowed A-z, 0-9, -_., ()!?. String: "
				.. eventId
		)
		return false
	end

	-- value: allow 0, negative and nil (not required)
	return true
end

function validation:validateLongString(longString, canBeEmpty)
	-- String is allowed to be empty
	if canBeEmpty and utilities:isStringNullOrEmpty(longString) then
		return true
	end

	if utilities:isStringNullOrEmpty(longString) or #longString > 8192 then
		return false
	end

	return true
end

function validation:validateErrorEvent(severityValues, severity, message)
	if
		severity ~= severityValues.debug
		and severity ~= severityValues.info
		and severity ~= severityValues.warning
		and severity ~= severityValues.error
		and severity ~= severityValues.critical
	then
		logger:w("Validation fail - error event - severity: Severity was unsupported value " .. tostring(severity))
		return false
	end

	if not validation:validateLongString(message, true) then
		logger:w("Validation fail - error event - message: Message cannot be above 8192 characters.")
		return false
	end

	return true
end

return validation]]></ProtectedString>
								<string name="ScriptGuid">{913C558F-D4CA-46D1-8467-990819743F8D}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Validation.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX8D1CCBAFFB574B839FEA51E234BFE913">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[local version = {
	SdkVersion = "2.2.6"
}

return version]]></ProtectedString>
								<string name="ScriptGuid">{433E1A65-839A-4351-9594-5E3F5AE99370}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Version.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX90058FE6193A4BA2978151D51FB465C3">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local module = {}

local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ScriptContext = game:GetService("ScriptContext")

--[[
    The modules are required inside each function because we wouldn't
    want to load the GameAnalytics library if we're just requiring this
    ModuleScript on the client side, and we don't need to hard code
    a require to Postie on the server side because the networking implementation could change.
]]

function module.initClient()
	local Postie = require(script.Parent.GameAnalytics.Postie)

	ScriptContext.Error:Connect(function(message, stackTrace, scriptInst)
		if not scriptInst then
			return
		end

		local scriptName = nil
		local ok, _ = pcall(function()
			scriptName = scriptInst:GetFullName() -- Can't get name of some scripts because of security permission
		end)
		if not ok then
			return
		end

		ReplicatedStorage.GameAnalyticsError:FireServer(message, stackTrace, scriptName)
	end)

	--Functions
	local function getPlatform()
		if GuiService:IsTenFootInterface() then
			return "Console"
		elseif UserInputService.TouchEnabled and not UserInputService.MouseEnabled then
			return "Mobile"
		else
			return "Desktop"
		end
	end

	--Filtering
	Postie.setCallback("getPlatform", getPlatform)
end

return module]]></ProtectedString>
							<string name="ScriptGuid">{65CAF0A3-69FF-4A5B-B9AA-6DA73CB31961}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">GameAnalyticsClient.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXC88A3A1EAA7C43C2831E73212C4E38E9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Modules/PlayerUtils.lua
--
--  Description:
--      Utility module providing all player-related helpers used across
--      the experience: identity handling, developer/admin flags, avatar
--      thumbnails, data lookup, reward helpers, device detection,
--      proximity queries, and UGC ownership checks.
--
--      Features:
--          • Safe UserId resolution (players, instances, strings)
--          • Cached player headshot thumbnails (3-attempt fallback)
--          • Developer/Admin whitelists
--          • Premium membership tagging
--          • Unified GetPlayerData / GetPlayerVal helpers
--          • Reward delivery (Coins/Gems + UI feedback)
--          • Device detection (PC / Mobile / Console)
--          • Nearby-player detection within distance range
--          • Server-side UGC ownership verification
--
--  Last Modified: 2025-11-29 by Darkzeb
--  Version: V2025-11
--
--  Dependencies:
--      Services:
--          - MarketplaceService
--          - UserInputService
--
--      Shared Modules:
--          - Channels (Display_Data remote)
--
--  Notes:
--      • Thumbnails are cached in-memory for performance.
--      • RewardPlayer fires Display_Data for visual notifications.
--      • UGC checks use PlayerOwnsAsset (3 attempts, fail-safe false).
--======================================================================


local MPS = game:GetService("MarketplaceService")
local UIS = game:GetService("UserInputService")

local Channels 					= require(game.ReplicatedStorage.Modules.Channels)
local Display_Data 			    = Channels.Server_Client_Events.Display_Data

local PlayerUtils = {}
local Player_Image_Cache = {}

local function safeFind(parent, name)
	if not parent then return nil end
	return parent:FindFirstChild(name)
end

function PlayerUtils.getSafeId(player)
	if not player then
		return 0
	end

	if typeof(player) == "Instance" and player:IsA("Player") then
		return player.UserId
	elseif typeof(player) == "Instance" then
		local numeric = tonumber(player.Name:match("%d+")) or math.random(1000000, 9999999)
		return 900000000 + numeric
	elseif typeof(player) == "string" then
		local numeric = tonumber(player:match("%d+")) or math.random(1000000, 9999999)
		return 900000000 + numeric
	else
		return math.random(900000000, 900999999)
	end
end

function PlayerUtils.isDeveloper(player)
	local developers = { "champsavenue", "nairoo999", "Asmozer", "yokadkin23", "ali_artisan", "oriane_dev", "ReigateTime", "STAM_Co", "bezkrad" } -- add all devs
	--local developers = {}
	return player and table.find(developers, player.Name) ~= nil
end

function PlayerUtils.isAdmin(player)
	local admins = { "champsavenue"} 
	return player and table.find(admins, player.Name) ~= nil
end

function PlayerUtils.Is_Premium_Member(Plr)
	if(Plr.MembershipType == Enum.MembershipType.Premium)then
		Plr:SetAttribute("Is_Premium", true)
	else
		Plr:SetAttribute("Is_Premium", false)
	end
end

function PlayerUtils.Is_Player_Fighting(Char)
	return typeof(Char) == "Instance"
		and typeof(Char.GetAttribute) == "function"
		and Char:GetAttribute("Is_Fighting") == true
end

function PlayerUtils.Get_Player_Image(P_ID)
	if(Player_Image_Cache[P_ID] == nil)then
		local Type = Enum.ThumbnailType.HeadShot
		local Size = Enum.ThumbnailSize.Size420x420

		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				Data = game.Players:GetUserThumbnailAsync(P_ID, Type, Size)
			end)

			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end

		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				Player_Image_Cache[P_ID] = D
				return D
			end
		end

		return "rbxassetid://80237311442114"
	else
		return Player_Image_Cache[P_ID]
	end
end

function PlayerUtils.GetPlayerData(player)
	if not player then return nil end
	return safeFind(player, "Player_Data")
end

function PlayerUtils.GetPlayerVal(player, key)
	local pd = PlayerUtils.GetPlayerData(player)
	if not pd then return nil end
	return safeFind(pd, key)
end

function PlayerUtils.RewardPlayer(player, reward_type, value)
	if reward_type == "Coins" then
		local Cash_Val = PlayerUtils.GetPlayerVal(player, "Coins")
		if(Cash_Val ~= nil)then
			Cash_Val.Value += value
			Display_Data:FireClient(player,"💸 You won +"..value.." Cash!", Color3.fromRGB(0, 255, 0))
		end
		
	elseif reward_type == "Gems" then
		local Gem_Val = PlayerUtils.GetPlayerVal(player, "Gems")
		if(Gem_Val ~= nil)then
			Gem_Val.Value += value
			Display_Data:FireClient(player,"💎 You won +"..value.." Gems!", Color3.fromRGB(0, 170, 255))
		end
	end
end

function PlayerUtils.GetPlayerDevice()
	if UIS.TouchEnabled then
		return "Mobile"
	elseif UIS.GamepadEnabled then
		return "Console"
	else
		return "PC"
	end
end

function PlayerUtils.GetNearbyPlayers(originPlayer, range)
	local nearby = {}
	local originChar = originPlayer.Character
	if not originChar or not originChar:FindFirstChild("HumanoidRootPart") then return nearby end

	local originPos = originChar.HumanoidRootPart.Position

	for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
		if otherPlayer ~= originPlayer then
			local otherChar = otherPlayer.Character
			if otherChar and otherChar:FindFirstChild("HumanoidRootPart") then
				local dist = (otherChar.HumanoidRootPart.Position - originPos).Magnitude
				if dist <= range then
					table.insert(nearby, otherPlayer)
				end
			end
		end
	end

	table.insert(nearby, originPlayer)

	return nearby
end

function PlayerUtils.Player_Owns_Item_UGC_ServerCheck(Plr, ID)
	
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = MPS:PlayerOwnsAsset(Plr, ID)
		end)

		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end

	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end

	return false
end

function PlayerUtils.GetStartSpawn()
	return game.workspace.Main_World_F.Environment.Spawns.SpawnLocation
end

return PlayerUtils]]></ProtectedString>
						<string name="ScriptGuid">{A837D36D-A0A0-46D0-B603-A7931DFF1BBA}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">PlayerUtils.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1927D9E621934FB28B27BC625BDF38E8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Modules/StartupUIHeader.lua
--
--  Description:
--      Startup sequence controller responsible for orchestrating all
--      initial UI flows shown when a player joins the experience.
--
--      Main Features:
--          • Standard & First-Time player sequences
--          • UI path resolution helper (PlayerGui-safe)
--          • Event-driven close notifications
--          • Mini tutorial integration (async continuation)
--          • Ordered execution pipeline with automatic fallback
--
--  Last Modified: 2025-12-04 by Darkzeb
--  Version: V2025-12
--
--  Dependencies:
--      • Players service
--      • PlayerGui
--      • Channels (BindableEvents)
--      • StartupUIManager :contentReference[oaicite:0]{index=0}
--      • Utils (reference style/model) :contentReference[oaicite:1]{index=1}
--
--  Notes:
--      • The sequence manager runs steps in strict order and handles
--        both special scripted stages and UI screens.
--      • Each UI step may trigger events instead of enabling UI
--        directly, depending on configuration.
--      • Close notifications propagate through StartupUIManager to
--        continue the sequence safely.
--
--======================================================================

local Players 			= game:GetService("Players")
local PlayerGui 		= Players.LocalPlayer:WaitForChild("PlayerGui")
local Channels 			= require(game.ReplicatedStorage.Modules.Channels)

local StartupUIManager = {}

------------------------------------------------------------
-- CONFIG : TWO ORDERS (STANDARD & FIRST TIME)
------------------------------------------------------------
StartupUIManager.StandardOrder = {
	{ path = "StarterGui.Shop.Offer_UI",  event = "Open_Starter_Pack" },
	{ path = "StarterGui.Menus.Rewards_UI", event = "Open_Daily_Rewards" },
}

StartupUIManager.FirstTimePlayerOrder = {
	{ special = "Tutorial" }
}


local currentIndex = 0
local activeOrder = nil
local isRunning = false
local pendingCloseCallback = nil
local activeClosingPath = nil

------------------------------------------------------------
-- Helpers
------------------------------------------------------------
local function resolvePath(path)
	local parts = string.split(path, ".")
	local obj = PlayerGui

	if parts[1] == "StarterGui" then
		table.remove(parts, 1)
	end

	for _, seg in ipairs(parts) do
		obj = obj:FindFirstChild(seg)
		if not obj then
			warn("[StartupUIManager] Missing UI:", path)
			return nil
		end
	end

	return obj
end

------------------------------------------------------------
-- SPECIAL STEP : TUTORIAL
------------------------------------------------------------
local function runMiniTutorial(nextStep)
	local Show_Tutorial_Launcher = Channels.Bindable_Events.Show_Tutorial_Launcher
	local Close_Tutorial = Channels.Bindable_Events.Close_Tutorial

	-- Fire existing system
	Show_Tutorial_Launcher:Fire()

	-- Listen for REAL tutorial completion
	local conn
	conn = Close_Tutorial.Event:Connect(function(itemName)
		if itemName == nil then
			conn:Disconnect()
			nextStep()
		end
	end)
end

------------------------------------------------------------
-- MAIN SEQUENCE LOOP
------------------------------------------------------------
local function showNext()
	currentIndex += 1

	if currentIndex > #activeOrder then
		isRunning = false
		return
	end

	local entry = activeOrder[currentIndex]

	-- SPECIAL STEP
	if typeof(entry) == "table" and entry.special == "Tutorial" then
		return runMiniTutorial(showNext)
	end

	-- NORMAL UI STEP
	if entry.path then
		local path = entry.path
		local ui = resolvePath(path)

		-- If event exists, fire it instead of enabling the UI directly
		if entry.event then
			local ev = Channels.Bindable_Events[entry.event]
			if ev then ev:Fire() end
		else
			-- Default behavior: enable UI directly
			if ui then 
				ui.Enabled = true 
			end
		end

		activeClosingPath = entry.path
		pendingCloseCallback = function()
			pendingCloseCallback = nil
			activeClosingPath = nil
			showNext()
		end
	end
end

function StartupUIManager.notifyClose(path)
	if pendingCloseCallback and path == activeClosingPath then
		pendingCloseCallback()
	end
end

------------------------------------------------------------
-- STARTER
------------------------------------------------------------
function StartupUIManager.start(isFirstTime)
	if isRunning then return end
	isRunning = true
	currentIndex = 0	
	activeOrder = isFirstTime and StartupUIManager.FirstTimePlayerOrder or StartupUIManager.StandardOrder
	showNext()
end

return StartupUIManager]]></ProtectedString>
						<string name="ScriptGuid">{77AA5E06-80D2-4713-B879-CF7E0DE7C574}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">StartupUIManager.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX44AF032AA2C240D5BF87CB2F9830550B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Debug</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXE2E80BE142CD49CABF44E823B57785FB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--[[ 📘 CHANNEL SIGNATURE INSPECTOR v3
===========================================================
📍 Module path:
local CSI = require(game.ReplicatedStorage.Debug.ChannelSignatureInspector)
CSI.scan()
===========================================================
Features:
✅ Ignores commented lines
✅ Merges all Channel sections (no duplicate confusion)
✅ Context-aware (client/server)
✅ Recognizes .OnClientEvent / .OnServerEvent / .Event:Connect
✅ Clean grouped output: ❌ invalid → ⚠ warning → ✅ ok
--]]

local ChannelSignatureInspector = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local StarterPlayer = game:GetService("StarterPlayer")
local StarterGui = game:GetService("StarterGui")
local StarterPack = game:GetService("StarterPack")

local Channels = require(ReplicatedStorage.Modules.Channels)

-------------------------------------------------------
-- CHANNEL SECTIONS
-------------------------------------------------------
local CHANNEL_SECTIONS = {
	"Bindable_Events",
	"Bindable_Functions",
	"CS_Remote_Functions",
	"CS_Remote_Events",
	"SC_Remote_Events",
}

-------------------------------------------------------
-- SCAN TARGETS
-------------------------------------------------------
local SCAN_CONTAINERS = {
	ServerScriptService,
	ReplicatedStorage,
	Workspace,
	StarterPlayer:FindFirstChild("StarterPlayerScripts"),
	StarterPlayer:FindFirstChild("StarterCharacterScripts"),
	StarterGui,
	StarterPack,
}

-------------------------------------------------------
-- HELPERS
-------------------------------------------------------
local function fullPath(inst)
	local parts = {}
	while inst do
		table.insert(parts, 1, inst.Name or "?")
		inst = inst.Parent
	end
	return table.concat(parts, "/")
end

local function isSource(inst)
	return inst:IsA("ModuleScript") or inst:IsA("Script") or inst:IsA("LocalScript")
end

local function getSource(src)
	local ok, code = pcall(function() return src.Source end)
	return ok and code or ""
end

local function isClientScript(src)
	return src:IsA("LocalScript")
		or (src.Parent and src.Parent:IsDescendantOf(StarterPlayer))
		or (src.Parent and src.Parent:IsDescendantOf(StarterGui))
		or (src.Parent and src.Parent:IsDescendantOf(StarterPack))
end

local function getTypeString(obj)
	if typeof(obj) ~= "Instance" then return nil end
	if obj:IsA("BindableEvent") then return "BindableEvent" end
	if obj:IsA("BindableFunction") then return "BindableFunction" end
	if obj:IsA("RemoteEvent") then return "RemoteEvent" end
	if obj:IsA("RemoteFunction") then return "RemoteFunction" end
	return nil
end

-------------------------------------------------------
-- EXPECTED SIGNATURES
-------------------------------------------------------
local EXPECTED = {
	BindableEvent = {
		client = { allowed = { "Fire" }, alsoValid = { "Event" } },
		server = { allowed = { "Fire" }, alsoValid = { "Event" } },
	},
	BindableFunction = {
		client = { allowed = { "OnInvoke" } },
		server = { allowed = { "OnInvoke" } },
	},
	RemoteEvent = {
		client = { allowed = { "FireServer", "OnClientEvent" }, alsoValid = { "Event" } },
		server = { allowed = { "FireClient", "FireAllClients", "OnServerEvent" } },
	},
	RemoteFunction = {
		client = { allowed = { "InvokeServer" } },
		server = { allowed = { "OnServerInvoke" } },
	},
}

-------------------------------------------------------
-- MAIN FUNCTION
-------------------------------------------------------
function ChannelSignatureInspector.scan()
	print("== Channel Signature Inspector v3 started ==")

	local invalids, warnings, oks = {}, {}, {}
	local total = 0

	-- 🔄 Merge all Channels.* into a single unique map
	local allChannels = {}
	for _, sectionName in ipairs(CHANNEL_SECTIONS) do
		local section = Channels[sectionName]
		if type(section) == "table" then
			for name, obj in pairs(section) do
				if typeof(obj) == "Instance" and not allChannels[name] then
					allChannels[name] = obj
				end
			end
		end
	end

	-- 🧩 Gather all Lua sources
	local sources = {}
	for _, container in ipairs(SCAN_CONTAINERS) do
		if container then
			for _, d in ipairs(container:GetDescendants()) do
				if isSource(d) then
					table.insert(sources, d)
				end
			end
		end
	end

	-- 🔍 Analyze usage
	for name, obj in pairs(allChannels) do
		local t = getTypeString(obj)
		if not t then continue end
		total += 1

		local patternName = name:gsub("([^%w_])", "%%%1")
		local foundCorrect, foundInvalid = false, false

		for _, src in ipairs(sources) do
			local code = getSource(src)
			if code == "" then continue end
			local lines = string.split(code, "\n")
			local path = fullPath(src)
			local ctx = isClientScript(src) and "client" or "server"

			local expected = EXPECTED[t]
			local ctxExp = expected and expected[ctx]
			if not ctxExp then continue end

			for lineNum, line in ipairs(lines) do
				local trimmed = line:match("^%s*(.-)%s*$")
				-- 🚫 skip comment lines
				if trimmed:find("^%-%-") or trimmed:find("^%[%[%s*%-%-") then
					continue
				end

				local call = trimmed:match(patternName .. "%s*[:%.]%s*([%w_]+)")
				if call then
					local ok = false
					if table.find(ctxExp.allowed, call) or table.find(ctxExp.alsoValid or {}, call) then
						ok = true
					end

					if ok then
						foundCorrect = true
						table.insert(oks, {
							obj = name, objType = t, ctx = ctx,
							call = call, path = path, line = lineNum,
						})
					else
						foundInvalid = true
						table.insert(invalids, {
							obj = name, objType = t, ctx = ctx,
							found = call, path = path, line = lineNum,
							expected = table.concat(ctxExp.allowed, " / "),
						})
					end
				end
			end
		end

		if not foundCorrect and not foundInvalid then
			table.insert(warnings, {
				obj = name,
				objType = t,
				path = fullPath(obj),
				expected = table.concat(EXPECTED[t]["client"].allowed, " / "),
			})
		end
	end

	-------------------------------------------------------
	-- 📊 REPORT OUTPUT
	-------------------------------------------------------
	print("\n== Channel Signature Inspector Report ==")

	-- ❌ INVALIDS
	if #invalids > 0 then
		print("\n❌ INVALID USAGES:")
		table.sort(invalids, function(a,b) return a.obj < b.obj end)
		for _, e in ipairs(invalids) do
			print(("[%s][%s] %s → invalid call '%s' (expected %s) in %s : line %d")
				:format(e.objType, e.ctx, e.obj, e.found, e.expected, e.path, e.line))
		end
	else
		print("\n❌ INVALID USAGES: none ✅")
	end

	-- ⚠ WARNINGS
	if #warnings > 0 then
		print("\n⚠ WARNINGS (never used):")
		table.sort(warnings, function(a,b) return a.obj < b.obj end)
		for _, w in ipairs(warnings) do
			print(("[%s] %s expected usage: %s (defined at %s)")
				:format(w.objType, w.obj, w.expected, w.path))
		end
	else
		print("\n⚠ WARNINGS: none ✅")
	end

	-- ✅ OKS
	if #oks > 0 then
		print("\n✅ VALID USAGES:")
		table.sort(oks, function(a,b)
			return a.obj == b.obj and a.path < b.path or a.obj < b.obj
		end)
		for _, o in ipairs(oks) do
			print(("[%s][%s] %s used correctly (%s) in %s : line %d")
				:format(o.objType, o.ctx, o.obj, o.call, o.path, o.line))
		end
	else
		print("\n✅ VALID USAGES: none found")
	end

	print(("\n== Scan finished (%d items checked) =="):format(total))
end

return ChannelSignatureInspector
]]></ProtectedString>
						<string name="ScriptGuid">{CF08B012-72C5-4D7D-9F87-99324370C9BE}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">ChannelSignatureInspector.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA714C2EAEE434628A97D8EBD95A96298">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--[[ 📘 REMOTE FUNCTION INSPECTOR COMMANDS (Studio Console)
===========================================================
🔹 MODULE PATH:
local Inspector = require(game.ReplicatedStorage.Debug.RemoteFunctionInspector)
Inspector.scan()
===========================================================
Description:
Scans all RemoteFunctions under Channels.CS_Remote_Functions
and finds where they are invoked in client scripts or shared
modules (ReplicatedStorage, StarterGui, StarterPack, etc).

Supports:
  ✅ Direct calls (MyRemote:InvokeServer())
  ✅ Aliases (local rf = Channels.CS_Remote_Functions.MyRemote)
  ✅ Deduplicated logging
  ✅ "No callers found" summary at the end
--]]

local RemoteFunctionInspector = {}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterPlayer = game:GetService("StarterPlayer")
local StarterGui = game:GetService("StarterGui")
local StarterPack = game:GetService("StarterPack")

local Channels = require(ReplicatedStorage.Modules.Channels)
local CS_Remote_Functions = Channels.CS_Remote_Functions

local SCAN_CONTAINERS = {
	ReplicatedStorage,
	StarterPlayer:FindFirstChild("StarterPlayerScripts"),
	StarterGui,
	StarterPack,
}

-- Helpers
local function fullPath(inst)
	local parts = {}
	while inst do
		table.insert(parts, 1, inst.Name or "<nil>")
		inst = inst.Parent
	end
	return table.concat(parts, "/")
end

local function isSourceContainer(inst)
	return inst:IsA("ModuleScript") or inst:IsA("LocalScript") or inst:IsA("Script")
end

local function getSource(src)
	local ok, code = pcall(function() return src.Source end)
	return ok and code or nil
end

local function getSourceLines(src)
	local code = getSource(src)
	if not code then return {} end
	local lines = {}
	for line in code:gmatch("([^\n]*)\n?") do
		table.insert(lines, line)
	end
	return lines
end

local function buildPatterns(remoteName)
	local escaped = remoteName:gsub("([^%w_])", "%%%1")
	local pattDirect = "%f[%w_]" .. escaped .. "%f[%W]%s*:%s*InvokeServer%s*%("
	local pattFull = "Channels%s*%.%s*CS_Remote_Functions%s*%.%s*" .. escaped .. "%s*:%s*InvokeServer%s*%("
	return pattDirect, pattFull
end

local function findAliases(srcText, remoteName)
	local pattern = "local%s+([%w_]+)%s*=%s*Channels%s*%.%s*CS_Remote_Functions%s*%.%s*" .. remoteName
	local aliases = {}
	for alias in srcText:gmatch(pattern) do
		table.insert(aliases, alias)
	end
	return aliases
end

-- =========================
-- 🔍 MAIN SCAN FUNCTION
-- =========================
function RemoteFunctionInspector.scan()
	if type(CS_Remote_Functions) ~= "table" then
		warn("[RemoteFunctionInspector] Channels.CS_Remote_Functions is not a table or nil.")
		return
	end

	print("== RemoteFunction caller analysis started ==")

	-- Collect scripts/modules once
	local sources = {}
	for _, container in ipairs(SCAN_CONTAINERS) do
		if container then
			for _, desc in ipairs(container:GetDescendants()) do
				if isSourceContainer(desc) then
					table.insert(sources, desc)
				end
			end
		end
	end

	local noCallers = {}

	for remoteName, remote in pairs(CS_Remote_Functions) do
		if typeof(remote) == "Instance" and remote:IsA("RemoteFunction") then
			local pattDirect, pattFull = buildPatterns(remoteName)
			local found = false
			local loggedFiles = {} -- avoid duplicate logging per script
			local fullRemotePath = fullPath(remote)

			for _, src in ipairs(sources) do
				local code = getSource(src)
				if not code then continue end

				local lines = getSourceLines(src)
				local filePath = fullPath(src)

				-- direct calls
				for i, line in ipairs(lines) do
					if line:find(pattDirect) or line:find(pattFull) then
						if not found then
							print(("--- RemoteFunction: %s  (path: %s)"):format(remoteName, fullRemotePath))
							print("  callers:")
							found = true
						end
						if not loggedFiles[filePath] then
							print(("    - %s : line %d (direct match)"):format(filePath, i))
							loggedFiles[filePath] = true
						end
					end
				end

				-- alias detection
				local aliases = findAliases(code, remoteName)
				for _, alias in ipairs(aliases) do
					-- avoid redundant alias logging if alias == remoteName
					if alias ~= remoteName then
						local aliasPattern = alias .. "%s*:%s*InvokeServer%s*%("
						for i, line in ipairs(lines) do
							if line:find(aliasPattern) then
								if not found then
									print(("--- RemoteFunction: %s  (path: %s)"):format(remoteName, fullRemotePath))
									print("  callers:")
									found = true
								end
								if not loggedFiles[filePath] then
									print(("    - %s : line %d (alias '%s')"):format(filePath, i, alias))
									loggedFiles[filePath] = true
								end
							end
						end
					end
				end
			end

			if not found then
				table.insert(noCallers, remoteName)
			end
		end
	end

	-- Print summary for remotes without callers
	if #noCallers > 0 then
		print("\n== No callers found for these RemoteFunctions ==")
		table.sort(noCallers)
		for _, name in ipairs(noCallers) do
			print("  - " .. name)
		end
	end

	print("\n== RemoteFunction caller analysis finished ==")
end

return RemoteFunctionInspector
]]></ProtectedString>
						<string name="ScriptGuid">{5C29458B-6309-451C-8DFB-FAF5076FD8D1}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">RemoteFunctionInspector.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX10FEAC5C47EF48CAAC6DF55C73639950">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ServerScriptService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXFA841461B646456EA61BB7E59C3084F5">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Core</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXB11821721A9E4008A667A5743F654468">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Player</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX5F6563590C874EB6AB17801CA1F2007A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Player/Combination_Handle.server.lua
--
--  Description:
--      Handles player customization of strike combos, submissions,
--      takedowns, equipped clothing, emote slots, and avatar settings.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Animation_Mod
--          * Data_Mods_F/Clothing_Mod
--          * Data_Mods_F/Skin_Tone_Mod
--          * Data_Mods_F/Country_Mod
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Bindable_F/RF
--          * Channels_F/Client_Server_F/RF
--          * Channels_F/Client_Server_F/Events
--      - Roblox Services:
--          * TextService (for safe text filtering)
--      - Player Instances:
--          * Player.Player_Data.Strike Combo (1–3)
--          * Player.Player_Data.Submission Key
--          * Player.Player_Data.Takedown Key
--          * Player.Player_Data.Current Gloves
--          * Player.Player_Data.Current Shorts
--
--  Notes:
--      - Validates ownership before assigning animations or clothing
--      - Updates player strike combos dynamically
--      - Supports equipping gloves/shorts via Clothing_Mod
--      - Handles emote slot assignment and filtering of text
--
--======================================================================

-- Services
local TextService 				= game:GetService("TextService")
local CollectionService 		= game:GetService("CollectionService")
local StarterPlayer 			= game:GetService("StarterPlayer")
-- Modules
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod 			= require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Clothing_Mod 				= require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Skin_Mod 					= require(Data_Mods_F:WaitForChild("Skin_Tone_Mod"))
local Country_Mod 				= require(Data_Mods_F:WaitForChild("Country_Mod"))
local PlayerUtils 				= require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels 					= require(game.ReplicatedStorage.Modules.Channels)
local Combo_Action_Request 		= Channels.CS_Remote_Functions.Combo_Action_Request
local Avatar_Clothing_Request 	= Channels.CS_Remote_Functions.Avatar_Clothing_Request
local Emote_Slot_Request 		= Channels.CS_Remote_Functions.Emote_Slot_Request
local Reset_Sequence 			= Channels.CS_Remote_Events.Reset_Sequence
local Save_Appearance 			= Channels.CS_Remote_Events.Save_Appearance

local Get_Player_Val 			= PlayerUtils.GetPlayerVal

local function getFilterResult(text, fromUserId)
	local filterResult
	local success, errorMessage = pcall(function()
		filterResult = TextService:FilterStringAsync(text, fromUserId)
	end)

	if success then
		local success2, filteredText = pcall(function()
			return filterResult:GetNonChatStringForBroadcastAsync()
		end)

		if success2 then
			return filteredText
		else
			warn("Error filtering text")
			return false
		end
	else
		warn("Error generating TextFilterResult:", errorMessage)
		return false
	end
end

Combo_Action_Request.OnServerInvoke = function(Plr, Entry, Index, Action_Type, Action) --Combo_Name, Strike, Action)
	local PD = Plr:WaitForChild("Player_Data")
	if Entry ~=nil and Index ~= nil then
		local check_if_own = Animation_Mod.Player_Owns_Strike_Key(Plr, Action)
		if (check_if_own == true) then -- free
			local Combo_Value = PD:FindFirstChild(Entry)

			if Combo_Value ~= nil then
				local Combo_List = Combo_Value.Value:split(",")
				Combo_List[Index] = Action 	
				Combo_Value.Value = table.concat(Combo_List, ",")
				return true
			end
		end
	elseif Entry ~=nil then	
		if Animation_Mod.Player_Owns_Action(Plr, Action_Type, Action) then 
			local Entry_Value = PD:FindFirstChild(Entry)
			Entry_Value.Value = Action
			return true
		end
	end

	return false
end

Avatar_Clothing_Request.OnServerInvoke = function(Plr, Equipment_Type, Key) -- plr,(glove/shorts),key
	if (Equipment_Type ~= nil) then
		if (Equipment_Type == "Gloves") then
			--// check if own
			local check_if_own = Clothing_Mod.Player_Owns_Gloves_Key(Plr, Key)
			local CurrentGlov = Get_Player_Val(Plr, "Current Gloves")
			if (check_if_own == true and CurrentGlov and CurrentGlov.Value ~= Key) then
				CurrentGlov.Value = Key
				return true
			end

		elseif (Equipment_Type == "Shorts") then

			local check_if_own = Clothing_Mod.Player_Owns_Shorts_Key(Plr, Key)
			local Current_Shorts = Get_Player_Val(Plr, "Current Shorts")
			if (check_if_own == true and Current_Shorts and Current_Shorts.Value ~= Key) then
				Current_Shorts.Value = Key
				return true
			end

		end
	end

	return false
end

Emote_Slot_Request.OnServerInvoke = function(Plr, Slot_Number, Key)
	--// Verify Players own the emote 
	--// If Player owns emote then replace the emote slot with the new emote.
	if (Slot_Number ~= nil and Key ~= nil) then
		local check_if_own = Animation_Mod.Player_Owns_Emote_Key(Plr, Key)
		if (check_if_own == true) then
			local PD = Plr:WaitForChild("Player_Data")
			local Emote_Slot = PD:FindFirstChild("Current Emotes")
			local EmotesSelected = Emote_Slot.Value:split(",")
			if (Emote_Slot ~= nil) then
				EmotesSelected[tonumber(Slot_Number:match("%d+"))] = Key
				Emote_Slot.Value = table.concat(EmotesSelected, ",")
				return true
			end
		end
	end

	return false
end

Reset_Sequence.OnServerEvent:Connect(function(Plr, Entry, Default_Value)
	local PD = Plr:WaitForChild("Player_Data")
	if(Entry ~= nil) then
		local Entry_Value = PD:FindFirstChild(Entry)
		if (Entry_Value) then
			Entry_Value.Value = Default_Value
		end
	end
end)

local function spawnWithTemplate(player, templateName)
	local templateFolder = game.ServerStorage:WaitForChild("Avatars"):WaitForChild("Standard")
	local template = templateFolder:FindFirstChild(templateName)

	if not player or not template then
		warn("[spawnWithTemplate] Invalid template or player")
		return
	end

	----------------------------------------------------------------------
	-- Cache data from old character
	----------------------------------------------------------------------
	local oldChar = player.Character
	local oldCFrame = nil
	local oldWalkSpeed = nil
	local oldJumpPower = nil
	local oldAnimator = nil
	local oldAnimate = nil
	local oldTags = nil
	local oldAttributes = nil

	if oldChar and oldChar.Parent then
		local hrp = oldChar:FindFirstChild("HumanoidRootPart")
		if hrp then oldCFrame = hrp.CFrame end

		local hum = oldChar:FindFirstChild("Humanoid")
		if hum then
			oldWalkSpeed = hum.WalkSpeed
			oldJumpPower = hum.JumpPower
			oldAnimator  = hum:FindFirstChildOfClass("Animator")
		end

		oldAnimate = oldChar:FindFirstChild("Animate")

		-- Copy attributes
		oldAttributes = {}
		for _, attrName in ipairs(oldChar:GetAttributes()) do
			oldAttributes[attrName] = oldChar:GetAttribute(attrName)
		end

		-- Copy tags (CollectionService)
		oldTags = CollectionService:GetTags(oldChar)
	end

	----------------------------------------------------------------------
	-- Create new character
	----------------------------------------------------------------------
	local newChar = template:Clone()
	newChar.Name = player.Name

	-- Insert into workspace BEFORE setting player.Character to avoid race conditions
	newChar.Parent = workspace

	-- Wait required parts
	local hum = newChar:WaitForChild("Humanoid")
	local hrp = newChar:WaitForChild("HumanoidRootPart")

	----------------------------------------------------------------------
	-- Official character swap
	----------------------------------------------------------------------
	player.Character = newChar

	-- Ensure HRP is not anchored
	hrp.Anchored = false

	----------------------------------------------------------------------
	-- Restore position
	----------------------------------------------------------------------
	if oldCFrame then
		newChar:PivotTo(oldCFrame)
	end

	----------------------------------------------------------------------
	-- StarterCharacterScripts injection (scripts + other objects)
	----------------------------------------------------------------------
	local starterScripts = StarterPlayer:FindFirstChild("StarterCharacterScripts")
	if starterScripts then
		for _, obj in ipairs(starterScripts:GetChildren()) do
			local clone = obj:Clone()
			clone.Parent = newChar
		end
	end

	----------------------------------------------------------------------
	-- Copy Animate script if exists
	----------------------------------------------------------------------
	if oldAnimate then
		local anim = oldAnimate:Clone()
		anim.Parent = newChar
		anim.Disabled = true
		task.wait()
		anim.Disabled = false
	else
		local anim = newChar:FindFirstChild("Animate")
		if anim then
			anim.Disabled = true
			task.wait()
			anim.Disabled = false
		end
	end

	----------------------------------------------------------------------
	-- Restore saved humanoid states, attributes & tags
	----------------------------------------------------------------------
	if oldWalkSpeed then hum.WalkSpeed = oldWalkSpeed end
	if oldJumpPower then hum.JumpPower = oldJumpPower end

	-- Reinject Animator if template removed it
	if not hum:FindFirstChildOfClass("Animator") and oldAnimator then
		local newAnimator = oldAnimator:Clone()
		newAnimator.Parent = hum
	end

	if oldAttributes then
		for attrName, value in pairs(oldAttributes) do
			newChar:SetAttribute(attrName, value)
		end
	end

	if oldTags then
		for _, tag in ipairs(oldTags) do
			CollectionService:AddTag(newChar, tag)
		end
	end

	if oldChar and oldChar ~= newChar and oldChar.Parent then
		task.defer(function()
			oldChar:Destroy()
		end)
	end
end

--game.Players.PlayerAdded:Connect(function(Plr)
--	local isFirstTime=true
--	local PD = Plr:WaitForChild("Player_Data")
--	local BT=PD:FindFirstChild("IsMale")
--	if BT==nil then
--		BT = Instance.new("BoolValue",PD)
--		BT.Name = "IsMale"
--		BT.Value=true
--	end

--	local function loadBody(Char)
--		local function WaitForUI(parent, name)
--			while true do
--				local ui = parent:FindFirstChild(name)
--				if ui then return ui end
--				task.wait()
--			end
--		end
--		local Fight_UI = WaitForUI(Char,"Fighting_UI") 
--		if isFirstTime then
--			isFirstTime=false
--			local templateName=nil
--			if BT.Value == false then
--				templateName="Female_StarterCharacter"
--				spawnWithTemplate(Plr, templateName)
--			end

--		end
--	end

--	-- first time load
--	local Init_Char = Plr.Character
--	if(Init_Char ~= nil)then
--		loadBody(Init_Char)
--	end

--	Plr.CharacterAdded:Connect(function(Char)
--		loadBody(Char)
--	end)
--end)

Save_Appearance.OnServerEvent:Connect(function(Plr, bio, country, skin, isMale)
	if(Plr ~= nil)then
		local PD = Plr:WaitForChild("Player_Data")
		if (PD ~= nil) then
			if isMale == nil then
				if (getFilterResult(bio, Plr.UserId)) then
					PD:FindFirstChild("Bio").Value = getFilterResult(bio, Plr.UserId)
				end
				if Country_Mod.Get_Country_Data()[country] then
					PD:FindFirstChild("Country").Value = country
				end
				if (Skin_Mod.Get_Skin_Tone_Data()[skin]) then
					local color = Skin_Mod.Get_Skin_Tone_Data()[skin]
					local R,G,B 
					R = math.round(color.R * 255)
					G = math.round(color.G * 255)
					B = math.round(color.B * 255)
					PD:FindFirstChild("Skin Tone").Value = R .. "," .. G .. "," .. B
				end
			else
				-- TODO uncomment when body switching will be 100% clean
				
				--local BT = PD:FindFirstChild("IsMale")
				--if BT.Value ~= isMale then
				--	BT.Value = isMale
				--	local templateName = nil
				--	if isMale then
				--		templateName = "Male_StarterCharacter"
				--	else
				--		templateName = "Female_StarterCharacter"
				--	end
				--	spawnWithTemplate(Plr, templateName)
				--end
			end
		end
	end
end)

-- TODO finish that but need the model to be adapted
--Set_Body_Preset.OnServerEvent:Connect(function(player, presetName)

--	local PD = player:WaitForChild("Player_Data")
--	PD.BodyPreset.Value = presetName

--	-- respawn clean
--	local isMale = PD.IsMale.Value
--	local template = isMale and "Male_StarterCharacter" or "Female_StarterCharacter"
--	spawnWithTemplate(player, template)

--	-- apply preset scales
--	task.defer(function()
--		local char = player.Character
--		local hum = char:WaitForChild("Humanoid")

--		-- scales inside humanoid
--		local preset = BodyPresetService.Presets[presetName]

--		hum.BodyHeightScale.Value = preset.HeightScale
--		hum.BodyWidthScale.Value  = preset.WidthScale
--		hum.BodyDepthScale.Value  = preset.DepthScale
--		hum.HeadScale.Value       = preset.HeadScale
--	end)
--end)]]></ProtectedString>
							<string name="ScriptGuid">{B60502F7-9DBF-4958-A8B0-4CF4E0DCE063}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Combination_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX339E3FDD0C774DB38DC872FB589C5E56">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Player/Badge_Attribute_Handle.server.lua
--
--  Description:
--      Handles badge checks, awards, and group membership attributes.
--      Provides Bindable and RemoteFunction interfaces for verifying and
--      awarding badges, and checking player group membership.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Bindable_F/RF
--          * Channels_F/Client_Server_F/RF
--      - Roblox Services:
--          * BadgeService
--          * Players
--
--  Notes:
--      - Uses UserHasBadgeAsync and AwardBadge with retry (3 attempts)
--      - Checks player membership in Group_ID = 35784641
--      - Sets Player attribute "In_Group" accordingly
--      - Exposes:
--          * RF: Player_In_Group, Player_Owns_Badge
--          * BindableEvent: Award_Badge
--
--======================================================================

-- Services
local BS = game:GetService("BadgeService")

-- Modules
local Utils = require(game.ReplicatedStorage.Modules.Utils)

-- Events
local Channels 					= require(game.ReplicatedStorage.Modules.Channels)

local Player_In_Group_RF 		= Channels.Bindable_Functions.Player_In_Group
local Player_In_Group_CS_RF 	= Channels.CS_Remote_Functions.Player_In_Group
local Player_Owns_Badge_RF 		= Channels.Bindable_Functions.Player_Owns_Badge
local Player_Owns_Badge_CS_RF 	= Channels.CS_Remote_Functions.Player_Owns_Badge

local Award_Badge				= Channels.Bindable_Events.Award_Badge

local function Player_Owns_Badge(Plr, Badge_ID)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = BS:UserHasBadgeAsync(Plr.UserId, Badge_ID)
		end)
		
		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end
	
	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end
	
	return false
end

local function Award_Badge_Handle(Plr, Badge_ID)
	if(Player_Owns_Badge(Plr, Badge_ID) == false)then
		local function Async()
			local success, errormessage = pcall(function()
				BS:AwardBadge(Plr.UserId, Badge_ID)
			end)
			
			if(success)then
				return true
			end
			return false
		end
		
		for i = 1, 3 do
			local D = Async()
			if(D)then
				return
			end
		end
	end
end

local function Is_Player_In_Group(Plr)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			local Group_ID = Utils.getGroupId()
			Data = Plr:IsInGroup(Group_ID)
		end)

		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end

	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end
	return false
end


Player_In_Group_RF.OnInvoke = function(Plr)
	local In_Group = Is_Player_In_Group(Plr)
	Plr:SetAttribute("In_Group", In_Group)
	return In_Group
end

Player_In_Group_CS_RF.OnServerInvoke = function(Plr)
	local In_Group = Is_Player_In_Group(Plr)
	Plr:SetAttribute("In_Group", In_Group)
	return In_Group
end

Player_Owns_Badge_RF.OnInvoke = function(Plr, Badge_ID)
	return Player_Owns_Badge(Plr, Badge_ID)
end

Player_Owns_Badge_CS_RF.OnServerInvoke = function(Plr, Badge_ID)
	return Player_Owns_Badge(Plr, Badge_ID)
end


Award_Badge.Event:Connect(function(Plr, Badge_ID)
	Award_Badge_Handle(Plr, Badge_ID)
end)]]></ProtectedString>
							<string name="ScriptGuid">{F732C01D-7C86-43CA-BC0E-F835324A2761}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Badge_Attribute_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX32201B41CB084C42831B4DB63DADFF8E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- ServerScriptService/Modules/BodyPresetService.lua
local BodyPresetService = {}

BodyPresetService.Presets = {
	Slim = {
		HeightScale = 1.03,
		WidthScale  = 0.90,
		DepthScale  = 0.92,
		HeadScale   = 1,
	},

	Fitness = {
		HeightScale = 1.02,
		WidthScale  = 1,
		DepthScale  = 1,
		HeadScale   = 1,
	},

	Muscular = {
		HeightScale = 1.02,
		WidthScale  = 1.10,
		DepthScale  = 1.12,
		HeadScale   = 1,
	},

	Heavy = {
		HeightScale = 1,
		WidthScale  = 1.20,
		DepthScale  = 1.15,
		HeadScale   = 1,
	}
}

function BodyPresetService.ApplyPreset(description, presetName)
	local preset = BodyPresetService.Presets[presetName]
	if not preset then
		warn("Unknown preset:", presetName)
		return description
	end

	for property, value in pairs(preset) do
		description[property] = value
	end

	return description
end

return BodyPresetService
]]></ProtectedString>
							<string name="ScriptGuid">{5EFA83FF-5BA3-4099-A5C0-725C51726044}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">BodyPresetService.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX19A347AB20794CE4BA7B841B793556E1">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Player/Core_Character_Handle.server.lua
--
--  Description:
--      Sets up and manages player characters in fights. Handles ragdoll
--      physics, clothing updates, collision groups, and overhead UI.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Server_Client_F/Events
--          * Channels_F/Client_Server_F/Events
--          * Data_Mods_F/Elo_Mod
--          * Data_Mods_F/Clothing_Mod
--          * Data_Mods_F/Country_Mod
--      - Roblox Services:
--          * PhysicsService (collision groups A, B, Hitbox)
--      - Script Assets:
--          * Name_Tag_UI
--          * Fighting_UI
--      - Player Instances:
--          * Player.Player_Data (Elo, Country, Owned clothes, etc.)
--
--  Notes:
--      - Registers collision groups and disables inter-collision
--      - Implements ragdoll system via BallSocketConstraints
--      - Restores humanoid state after ragdoll period
--      - Updates character cosmetics using Clothing_Mod
--      - Displays player info with NameTag and Fighting_UI
--
--======================================================================

-- Services
local PS = game:GetService("PhysicsService")
PS:RegisterCollisionGroup("A")
PS:RegisterCollisionGroup("B")
PS:RegisterCollisionGroup("Hitbox")
PS:CollisionGroupSetCollidable("A", "B", false)
PS:CollisionGroupSetCollidable("A", "A", false)
PS:CollisionGroupSetCollidable("B", "B", false)
PS:CollisionGroupSetCollidable("Hitbox", "A", false)
PS:CollisionGroupSetCollidable("Hitbox", "B", false)

-- Modules
local Elo_Mod = require(game.ReplicatedStorage.Data_Mods_F.Elo_Mod)
local Clothing_Mod = require(game.ReplicatedStorage.Data_Mods_F.Clothing_Mod)
local Country_Mod = require(game.ReplicatedStorage.Data_Mods_F.Country_Mod)
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)
local Fight_Params_Mod = require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)

-- Events
local Channels				= require(game.ReplicatedStorage.Modules.Channels)
local Update_Player_Device 	= Channels.SC_Remote_Events.Update_Player_Device
local Set_Player_Device		= Channels.CS_Remote_Events.Set_Player_Device
local Award_Badge			= Channels.Bindable_Events.Award_Badge
local Display_Data			= Channels.SC_Remote_Events.Display_Data
local Ragdoll_Player_E		= Channels.Bindable_Events.Ragdoll_Player
local Show_Shield_UI        = Channels.CS_Remote_Events.Show_Shield_UI

local Name_Tag_TMP = script:WaitForChild("Name_Tag_UI")
local Fight_UI_TMP = script:WaitForChild("Fighting_UI")

local Get_Player_Val = PlayerUtils.GetPlayerVal

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

local function Join_Check(t)
	local Joints = {"LeftWrist","RightWrist","LeftAnkle","RightAnkle", "Root"}
	if(table.find(Joints, t) ~= nil)then
		return false
	end
	return true
end

local function Ragdoll_Player(Char)
	local Hum = Char:FindFirstChild("Humanoid")

	local function Set_Up_Character_Ragdoll()
		for _,v in pairs(Char:GetDescendants()) do
			if v:IsA("Motor6D")and Join_Check(v.Name)then
				local b = Instance.new("BallSocketConstraint",v.Parent)
				local a0,a1 = Instance.new("Attachment"),Instance.new("Attachment")

				a0.Parent,a1.Parent = v.Part0,v.Part1
				b.Attachment0,b.Attachment1 = a0,a1
				a0.CFrame,a1.CFrame = v.c0,v.c1
				b.LimitsEnabled = true
				b.TwistLimitsEnabled = true
				b.Enabled = false

			elseif v:IsA'BasePart' or v:IsA("MeshPart") then
				if(v.Name ~= "Hitbox_Part")then
					PS:SetPartCollisionGroup(v, "A")
				else
					v.CanCollide = false
				end

				if v.Name == "HumanoidRootPart" then
					PS:SetPartCollisionGroup(v, "B")
				elseif v.Name=="Head"then
					v.CanCollide = true
				end

			end
		end
		PS:CollisionGroupSetCollidable("A", "B", false)
	end
	Set_Up_Character_Ragdoll()

	Hum:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
	Hum:ChangeState(Enum.HumanoidStateType.Ragdoll)
	Hum.PlatformStand = true

	for _,v in pairs(Char:GetDescendants()) do
		if v:IsA'Motor6D'and Join_Check(v.Name)then
			v.Enabled = false
		elseif v:IsA'BallSocketConstraint' then
			v.Enabled = true
		end
	end

	task.wait(3.5)

	if(Char ~= nil)then
		for _,v in pairs(Char:GetDescendants()) do
			if(v:IsA'BasePart' or v:IsA("MeshPart"))then
				if v.Name == "Hitbox_Part"then
					v.CanCollide = true
				else
					PS:SetPartCollisionGroup(v, "Default")
				end
			end

			if v:IsA'Motor6D'and Join_Check(v.Name)then
				v.Enabled = true
			elseif v:IsA'BallSocketConstraint' then
				v.Enabled = false
				v:Destroy()
			end
		end

		Hum:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
		Hum:ChangeState(Enum.HumanoidStateType.GettingUp)
		Hum.PlatformStand = false
	end
end

local function Update_Shorts(Plr, Char)
	--Get the Default Key, get the Model, Clone it
	--Remove any Previous Models in Character
	--Loop through Each BodyPart, set up CFrame Offset and Weld to BodyPart
	local Shorts_Key, Shorts_TMP = Clothing_Mod.Get_Player_Current_Shorts(Plr)
	local Prev_Shorts = Char:FindFirstChild("Shorts_M")
	if(Prev_Shorts ~= nil)then
		Prev_Shorts:Destroy()
	end

	local New_Shorts = Shorts_TMP:Clone()
	New_Shorts.Parent = Char
	New_Shorts.Name = "Shorts_M"

	local function Configure_New_Shorts()
		local function Set_New_Part(P)
			local Main_BP = Char:FindFirstChild(P.Name)
			local Offset_CF = P:GetAttribute("Spawn_Offset_CF") or CFrame.new()
			--if(Offset_CF == nil)then
			--	P.CFrame = Main_BP.CFrame
			--else
			--	P.CFrame = Main_BP.CFrame:ToWorldSpace(Offset_CF)
			--end

			local W = Instance.new("Weld", P)
			W.Name = "WeldConstraint"
			W.Part0 = Main_BP
			W.Part1 = P
			W.C0 = Offset_CF
		end

		local All_P = New_Shorts:GetChildren()
		for i = 1, #All_P do
			local P = All_P[i]
			if(P ~= nil and Char:FindFirstChild(P.Name) ~= nil)then
				Set_New_Part(P)
			end
		end
	end
	Configure_New_Shorts()
end

local function Update_Gloves(Plr, Char)	
	local Gloves_Key, Gloves_TMP = Clothing_Mod.Get_Player_Current_Gloves(Plr)
	local Prev_Gloves = Char:FindFirstChild("Gloves_M")

	local Default_Gloves =nil
	local IsFemale = Char:GetAttribute("IsFemale")
	if IsFemale then
		Default_Gloves = Char:WaitForChild ("Default_Gloves",10)
		if Default_Gloves then
			for _, item in ipairs(Default_Gloves:GetDescendants()) do
				if item:IsA("BasePart") then
					item.Transparency = 1
				end
			end
		end
	end


	if(Prev_Gloves ~= nil)then
		Prev_Gloves:Destroy()
	end

	local New_Gloves = Gloves_TMP:Clone()
	New_Gloves.Parent = Char
	New_Gloves.Name = "Gloves_M"

	local function Configure_New_Gloves()
		local function Set_New_Part(P, isFlipped)			
			local Main_BP = Char:FindFirstChild(P.Name)
			local HRP = Char:FindFirstChild("HumanoidRootPart")
			local Offset_CF = P:GetAttribute("Spawn_Offset_CF")
			--P.Size = Vector3.new(0.753, 1.094, 0.787)
			if IsFemale and Default_Gloves~=nil then
				P.CFrame = Default_Gloves:FindFirstChild(P.Name).CFrame
			else
				P.CFrame = Main_BP.CFrame
			end
			if isFlipped == true then
				P.CFrame *= CFrame.Angles(0, math.pi, 0)
			end
			--local Dif_V = Vector3.new(0.753, 1.094, 0.787) / Vector3.new(0.772, 0.938, 0.838)

			local W = Instance.new("WeldConstraint", P)
			W.Part0 = P
			local part1 = Main_BP
			if IsFemale and Default_Gloves~=nil then
				if P.Name == "LeftHand" then
					part1 = Char:FindFirstChild("RightHand")
				else
					part1 = Char:FindFirstChild("LeftHand")
				end
			end

			W.Part1 = part1
			W.Enabled = true
		end

		local All_P = New_Gloves:GetChildren()
		for i = 1, #All_P do
			local P = All_P[i]
			if(P ~= nil and Char:FindFirstChild(P.Name) ~= nil)then
				Set_New_Part(P, Gloves_TMP:GetAttribute("FlipGloves"))
			end
		end
	end
	Configure_New_Gloves()
end

local function Update_Skin_Color(Plr, Char)
	--Get the Skin Color Val, Create Color3 Val
	--> Update BodyColors Value
	--> 
	local IsFemaleChar = Char:GetAttribute("IsFemale")

	local Skin_Color_V = Get_Player_Val(Plr, "Skin Tone")
	if(Skin_Color_V ~= nil) then
		local function Configure_Skin_Color()
			local Str = string.split(Skin_Color_V.Value, ",")
			if(Str ~= nil and #Str >= 3)then
				local R, G, B = tonumber(Str[1]), tonumber(Str[2]), tonumber(Str[3])
				R, G, B = math.clamp(R, 0, 255), math.clamp(G, 0, 255), math.clamp(B, 0, 255)
				return Color3.fromRGB(R, G, B)
			end

			return Color3.fromRGB(234, 184, 146)
		end
		local Skin_Col = Configure_Skin_Color()

		local function Configure_Body_Color()
			local BC = Char:FindFirstChildWhichIsA("BodyColors")
			if(BC ~= nil)then
				BC.HeadColor3 = Skin_Col
				BC.LeftArmColor3 = Skin_Col
				BC.RightArmColor3 = Skin_Col
				BC.LeftLegColor3 = Skin_Col
				BC.RightLegColor3 = Skin_Col
				BC.TorsoColor3 = Skin_Col
			end
		end
		Configure_Body_Color()

		local function Update_Surface_Appearance(BP)
			local All_D = BP:GetDescendants()
			for i = 1, #All_D do
				local D = All_D[i]
				if(D ~= nil and D:IsA("SurfaceAppearance"))then
					D.Color = Skin_Col
				end
			end
		end
		if not IsFemaleChar then
			Update_Surface_Appearance(Char:WaitForChild("UpperTorso"))
			Update_Surface_Appearance(Char:WaitForChild("RightUpperLeg"):WaitForChild("Mainheight6.002"))
			Update_Surface_Appearance(Char:WaitForChild("RightUpperArm"))
			Update_Surface_Appearance(Char:WaitForChild("RightLowerLeg"):WaitForChild("Mainheight5.002"))
			Update_Surface_Appearance(Char:WaitForChild("RightLowerArm"))
			Update_Surface_Appearance(Char:WaitForChild("LowerTorso"):WaitForChild("r15 tt.003"))
			Update_Surface_Appearance(Char:WaitForChild("LeftUpperLeg"):WaitForChild("Mainheight6.001"))
			Update_Surface_Appearance(Char:WaitForChild("LeftUpperArm"))
			Update_Surface_Appearance(Char:WaitForChild("LeftLowerLeg"):WaitForChild("Mainheight5.001"))
			Update_Surface_Appearance(Char:WaitForChild("LeftLowerArm"))
		end
		local function Update_Hand_Colors()
			local Hand_M = Char:FindFirstChildWhichIsA("Model")
			if(Hand_M ~= nil)then
				local All_P = Hand_M:GetChildren()
				for i = 1, #All_P do
					local P = All_P[i]
					if(P ~= nil and P:IsA("MeshPart") and string.match(P.Name, "Hand") ~= nil)then
						P.Color = Skin_Col
					end
				end
			end
		end
		Update_Hand_Colors()

		--local function Set_Lat_Colors(Lat_P)
		--	if(Lat_P ~= nil)then
		--		Lat_P.Color = Skin_Col
		--	end
		--end
		--Set_Lat_Colors(Char:WaitForChild("Lat_L"))
		--Set_Lat_Colors(Char:WaitForChild("Lat_R"))
	end
end

local function Get_Device_Image(Plr)
	local Device_Imgs = {
		['PC'] = "rbxassetid://115464285887151",
		['Console'] = "rbxassetid://120642019576021",
		['Mobile'] = "rbxassetid://98548614504710"
	}

	local Device_Atrib = Plr:GetAttribute("Device")
	if(Device_Atrib == nil or Device_Imgs[Device_Atrib] == nil)then
		Update_Player_Device:FireClient(Plr)
	else
		return Device_Imgs[Device_Atrib]
	end

	return Device_Imgs['PC']
end

local function Get_Player_Name_Tag(Plr)
	local Char = Plr.Character
	if(Char ~= nil and Char:FindFirstChild("Name_Tag_UI") ~= nil)then
		return Char:FindFirstChild("Name_Tag_UI")
	end
	return nil
end

local function Update_Name_Tag_Data(Plr, Data_Type)
	--For Health and Stamina
	local Fight_Data_F = Plr:FindFirstChild("Fight_Data")
	local Name_Tag_UI = Get_Player_Name_Tag(Plr)
	if(Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild(Data_Type) ~= nil and Name_Tag_UI ~= nil and  
		Name_Tag_UI:FindFirstChild("Main_F") ~= nil)then

		local Data_V = Fight_Data_F:FindFirstChild(Data_Type)
		local Main_F = Name_Tag_UI:FindFirstChild("Main_F")
		local Bar_F = Main_F:FindFirstChild("Stam_Bar_F")
		if(Data_Type == "Health")then
			Bar_F = Main_F:FindFirstChild("Health_Bar_F")
		end

		if(Bar_F ~= nil and Bar_F:FindFirstChild("Val_Txt") ~= nil and Bar_F:FindFirstChild("Bar_F") ~= nil)then
			local X_Size = math.clamp(Data_V.Value / 100, 0, 1)
			Bar_F:FindFirstChild("Bar_F"):TweenSize(UDim2.new(X_Size, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)

			Bar_F:FindFirstChild("Val_Txt").Text = Data_V.Value .. ""
		end
	end
end

local function Update_Name_Tag_Elo(Plr)
	--For the Rank Display
	local Name_Tag_UI = Get_Player_Name_Tag(Plr)
	if(Name_Tag_UI ~= nil and Name_Tag_UI:FindFirstChild("Main_F") ~= nil and 
		Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Rank_F") ~= nil)then

		local Rank_F = Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Rank_F")
		local Rank_Txt = Rank_F:FindFirstChild("Rank_Txt")
		local Rank_Img = Rank_F:FindFirstChild("Rank_Img")
		local Rank_Data, Elo_Amount = Elo_Mod.Get_Player_Rank_Data(Plr)

		if(Rank_F ~= nil and Rank_Img ~= nil and Rank_Txt ~= nil and Rank_Data ~= nil 
			and Elo_Amount ~= nil)then

			local Rank_Col = Rank_Data['Color'] or Color3.fromRGB(170, 170, 127)
			Rank_Txt.Text = Format_Number(Elo_Amount) .. ""
			Rank_Txt.TextColor3 = Rank_Col
			Rank_Img.Image = Rank_Data['Icon'] or "rbxassetid://89194867048049"
			Rank_Img.ImageColor3 = Rank_Col
		end
	end
end

local function Update_Name_Tag_Country(Plr)
	local Name_Tag_UI = Get_Player_Name_Tag(Plr)
	if(Name_Tag_UI ~= nil and Name_Tag_UI:FindFirstChild("Main_F") ~= nil and 
		Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Country_Img") ~= nil)then

		local Country_Img = Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Country_Img")
		local Country_Key, Country_Icon = Country_Mod.Get_Player_Country_Data(Plr)
		if(Country_Icon ~= nil)then
			Country_Img.Image = Country_Icon
		end
	end
end

local function Update_Name_Tag_Connection(Plr)
	--For the Player Connection Handle
	local Name_Tag_UI = Get_Player_Name_Tag(Plr)
	local Ping = Plr:GetNetworkPing() * 100
	--> less than 100 ms (Green)
	--> Less than 250 ms (Yellow)
	--> Greater than 250 ms (Red)

	if(Name_Tag_UI ~= nil and Name_Tag_UI:FindFirstChild("Main_F") ~= nil and 
		Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Connection_Img") ~= nil)then

		local Connection_Img = Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Connection_Img")
		local UIG = Connection_Img:FindFirstChildWhichIsA("UIGradient")

		if(UIG ~= nil)then
			if(Ping <= 100)then
				UIG.Color = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Color3.new(0, 1, 0)),
					ColorSequenceKeypoint.new(1, Color3.new(0, 1, 0))
				}
			elseif(Ping <= 250)then
				UIG.Color = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Color3.new(1, 1, 0)),
					ColorSequenceKeypoint.new(0.6875, Color3.new(1, 1, 0)),
					ColorSequenceKeypoint.new(0.6876, Color3.fromRGB(200, 200, 200)),
					ColorSequenceKeypoint.new(1, Color3.fromRGB(200, 200, 200))
				}
			else
				UIG.Color = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Color3.new(1, 0, 0)),
					ColorSequenceKeypoint.new(0.3875, Color3.new(1, 0, 0)),
					ColorSequenceKeypoint.new(0.3876, Color3.fromRGB(200, 200, 200)),
					ColorSequenceKeypoint.new(1, Color3.fromRGB(200, 200, 200))
				}
			end
		end
	end
end

local function Update_Playtime_Tracking(Plr)
	local Session_Time_V = Get_Player_Val(Plr, "Total Playtime")
	if(Session_Time_V ~= nil)then
		Session_Time_V.Value += 1
	end
end

local bufferToken = 0
local function Update_Fight_Block_UI(Plr)
	local function Get_Player_Fight_UI()
		local Char = Plr.Character
		if(Char ~= nil and Char:FindFirstChild("Fighting_UI") ~= nil)then
			return Char:FindFirstChild("Fighting_UI")
		end
		return nil
	end
	local Fight_UI = Get_Player_Fight_UI()
	local Fight_Data_F = Plr:FindFirstChild("Fight_Data")

	if(Fight_UI ~= nil and Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild("Block Power") ~= nil 
		and Fight_UI:FindFirstChild("Main_F") ~= nil and 
		Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then

		local Block_Power_V = Fight_Data_F:FindFirstChild("Block Power")
		local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
		local Img = Sheild_F:FindFirstChild("Shield_Img")
		local Txt = Sheild_F:FindFirstChild("Shield_Txt")
		local Spinner = Img:FindFirstChild("Spinner")

		if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
			local UIG = Img:FindFirstChildWhichIsA("UIGradient")
			local Block_Power = Block_Power_V.Value
			local Dif =  math.clamp(Block_Power / Fight_Params_Mod.Block_Power.Max_Value, 0, 1)
			local Offset_Pos_Y = (1 - Dif) - 0.5

			UIG.Offset = Vector2.new(0, Offset_Pos_Y)
			Txt.Text = Block_Power .. ""
			if(Dif <= 0.25)then
				Txt.TextColor3 = Color3.new(1, 0, 0)
			else
				Txt.TextColor3 = Color3.new(1, 1, 1)
			end

			if Spinner ~= nil then
				bufferToken += 1
				local myToken = bufferToken

				-- NE PAS BLOQUER, NE PAS multiplier les boucles
				coroutine.wrap(function()
					while myToken == bufferToken and Block_Power_V:GetAttribute("Is_Buffering") do
						Spinner.Visible = true
						Spinner.Rotation += 10
						task.wait(0.1)
					end

					-- sort de la boucle = stop logique
					Spinner.Visible = false
				end)()
			end
		end
	end
end

local function Toggle_Fight_Block_UI(Plr, Is_Enabled)
	local function Get_Player_Fight_UI()
		local Char = Plr.Character
		if(Char ~= nil and Char:FindFirstChild("Fighting_UI") ~= nil)then
			return Char:FindFirstChild("Fighting_UI")
		end
		return nil
	end
	local Fight_UI = Get_Player_Fight_UI()

	if(Fight_UI ~= nil)then
		Fight_UI.Enabled = Is_Enabled
	end
end

local function Character_Handle(Plr: Player, Char)
	local Hum = Char:WaitForChild("Humanoid")
	local HRP = Char:WaitForChild("HumanoidRootPart")
	local Head = Char:WaitForChild("Head")

	Char:SetAttribute("UserId", Plr.UserId)

	local plrValue = Instance.new("ObjectValue")
	plrValue.Value = Plr
	plrValue.Name = "_PLAYER_VALUE_"
	plrValue.Parent = Char

	--Set up Skin Color Change Handle based on Data
	--Set up Player Accessories and Face from the Default Character
	--Add Player Gloves and Shorted based on the Current Values

	local function Add_Character_Face_Accessories()
		local function Create_Original_Character()
			local function Async()
				local Data = nil
				local success, errormessage = pcall(function()
					Data = game.Players:CreateHumanoidModelFromUserId(Plr.UserId)
				end)

				if(success and Data ~= nil)then
					return Data
				end
				return nil
			end

			for i = 1, 3 do
				local D = Async()
				if(D ~= nil)then
					D.Parent = script
					return D
				end
			end

			return nil
		end
		local Orig_Char = Create_Original_Character()

		if(Orig_Char ~= nil)then
			local All_C = Orig_Char:GetChildren()
			for i = 1, #All_C do
				local C = All_C[i]
				if(C ~= nil and C:IsA("Accessory"))then
					--Hum:AddAccessory(C)
					C.Parent = Char
				elseif(C ~= nil and C.Name == "Head" and C:FindFirstChildWhichIsA("Decal") ~= nil)then
					--C:FindFirstChildWhichIsA("Decal").Parent = Head

					--Create a Face Part for some reason
					local Old_Face_P = Head:FindFirstChild("Face_Part")
					if(Old_Face_P ~= nil)then
						Old_Face_P:Destroy()
					end
					local Face_P = Instance.new("Part", Head)
					Face_P.Name = "Face_Part"
					Face_P.Size = Head.Size
					Face_P.Anchored = false
					Face_P.CanCollide = false
					Face_P.CanTouch = false
					Face_P.Massless = true
					Face_P.Transparency = 1
					Face_P.Material = Enum.Material.SmoothPlastic
					Face_P.CFrame = Head.CFrame

					local W = Instance.new("WeldConstraint", Face_P)
					W.Part0 = Face_P
					W.Part1 = Head
					W.Enabled = true

					local New_Face = C:FindFirstChildWhichIsA("Decal"):Clone()
					New_Face.Parent = Face_P

				end
			end

			Orig_Char:Destroy()
		end

		Hum.BreakJointsOnDeath = false
		Hum.RequiresNeck = false
		Hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
		Hum.HealthDisplayType = Enum.HumanoidHealthDisplayType.AlwaysOff
	end
	Add_Character_Face_Accessories()

	Update_Skin_Color(Plr, Char)
	Update_Gloves(Plr, Char)
	Update_Shorts(Plr, Char)

	local function Disable_Health_Regen()
		local Health = Char:WaitForChild("Health",.01)
		if(Health ~= nil and Health:IsA("Script"))then
			Health:Destroy()
		end
	end
	Disable_Health_Regen()

	local function Auto_Ragdoll_On_Death()
		if(Hum ~= nil)then
			Hum.Died:Connect(function()
				if(Char ~= nil)then
					Ragdoll_Player(Char)
				end
			end)
		end
	end
	Auto_Ragdoll_On_Death()

	local function Name_Tag_Handle()
		if(HRP ~= nil and Char:FindFirstChild("Name_Tag_UI") == nil)then
			--When we have a Name Tag, apply it here
			local Name_Tag_UI = Name_Tag_TMP:Clone()
			Name_Tag_UI.Name = "Name_Tag_UI"
			Name_Tag_UI.Parent = Char
			Name_Tag_UI.Adornee = HRP

			local Main_F = Name_Tag_UI:WaitForChild("Main_F")
			Main_F:WaitForChild("Player_Name_Txt").Text = Plr.DisplayName
			Name_Tag_UI.Enabled = true
			Main_F:WaitForChild("Device_Img").Image = Get_Device_Image(Plr)

			Update_Name_Tag_Data(Plr, "Health")
			Update_Name_Tag_Data(Plr, "Staminia")
			Update_Name_Tag_Elo(Plr)
			Update_Name_Tag_Connection(Plr)
			Update_Name_Tag_Country(Plr)
		end

		if(HRP ~= nil and Char:FindFirstChild("Fighting_UI") == nil)then
			local Fight_UI = Fight_UI_TMP:Clone()
			Fight_UI.Name = "Fighting_UI"
			Fight_UI.Parent = Char
			Fight_UI.Adornee = HRP
			Fight_UI.Enabled = true

			Update_Fight_Block_UI(Plr)
			Toggle_Fight_Block_UI(Plr, false)
		end	
	end
	Name_Tag_Handle()

	local function Create_Collision_Hitbox()
		--local CF, Size = Char:GetBoundingBox()
		--local HB = Instance.new("Part", Char)
		local HB = script:WaitForChild("Round_Hitbox_P"):Clone()
		HB.Parent = Char
		HB.Name = "Hitbox_Part"
		HB.Transparency = 1
		HB.CanTouch = false
		HB.CanCollide = true
		HB.Anchored = false
		HB.Massless = true
		--HB.Size = Size
		--HB.CFrame = CF
		HB.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, 0, 0)
		HB.CollisionGroup = "Hitbox"

		local W = Instance.new("WeldConstraint", HB)
		W.Part0 = HB
		W.Part1 = HRP
		W.Enabled = true		
	end
	Create_Collision_Hitbox()
end

local function Total_Knockout_Badge_Handle(Plr)
	local Badges_Data = {
		[10] = 3359889418756738,
		[50] = 3881066402115385,
		[100] = 2633101226400876,
		[1000] = 873841622513803,
		[10000] = 757308337186417
	}

	local function Compile_Total_Knockouts()
		local Total_KO = 0
		local Punch_KO_V = Get_Player_Val(Plr, "Punch Knockout Wins")
		local Kick_KO_V = Get_Player_Val(Plr, "Leg Knockout Wins")

		if(Punch_KO_V ~= nil)then
			Total_KO += Punch_KO_V.Value
		end

		if(Kick_KO_V ~= nil)then
			Total_KO += Kick_KO_V.Value
		end

		return Total_KO
	end
	local Total_Knockouts = Compile_Total_Knockouts()

	if(Badges_Data[Total_Knockouts] ~= nil)then
		Award_Badge:Fire(Plr, Badges_Data[Total_Knockouts])

		local Txt = "👊 Congrats on over " .. Format_Number(Total_Knockouts) .. " Total Knockouts!"
		Display_Data:FireClient(Plr, Txt, Color3.fromRGB(255, 170, 0))
	end
end

local function Player_Data_Changes_Handle(Plr)
	local PD = Plr:WaitForChild("Player_Data")
	local FD = Plr:WaitForChild("Fight_Data")

	PD:WaitForChild("Skin Tone").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Skin_Color(Plr, Plr.Character)
		end
	end)

	PD:WaitForChild("Current Shorts").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Shorts(Plr, Plr.Character)
		end
	end)

	PD:WaitForChild("Current Gloves").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Gloves(Plr, Plr.Character)
		end
	end)

	PD:WaitForChild("Elo").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Name_Tag_Elo(Plr)
		end
	end)
	Update_Name_Tag_Elo(Plr)

	PD:WaitForChild("Country").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Name_Tag_Country(Plr)
		end
	end)

	PD:WaitForChild("Punch Knockout Wins").Changed:Connect(function()
		if(Plr ~= nil)then
			Total_Knockout_Badge_Handle(Plr)
		end
	end)

	PD:WaitForChild("Leg Knockout Wins").Changed:Connect(function()
		if(Plr ~= nil)then
			Total_Knockout_Badge_Handle(Plr)
		end
	end)

	--Fight Data Changes
	local Health_V = FD:WaitForChild("Health")
	Health_V.Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			if(Health_V.Value <= 0)then
				Ragdoll_Player(Plr.Character)
			end

			Update_Name_Tag_Data(Plr, "Health")
		end
	end)

	FD:WaitForChild("Staminia").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Name_Tag_Data(Plr, "Staminia")
		end
	end)

	FD:WaitForChild("Block Power").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Fight_Block_UI(Plr)
		end
	end)
end

game.Players.PlayerAdded:Connect(function(Plr)	
	local Init_Char = Plr.Character
	if(Init_Char ~= nil)then
		Character_Handle(Plr, Init_Char)
	end

	Plr.CharacterAdded:Connect(function(Char)
		Character_Handle(Plr, Char)
	end)

	Player_Data_Changes_Handle(Plr)
end)

Ragdoll_Player_E.Event:Connect(function(Char)
	if(Char ~= nil and Char:FindFirstChild("Humanoid") ~= nil)then
		Ragdoll_Player(Char)
	end
end)

Set_Player_Device.OnServerEvent:Connect(function(Plr, Device_Str)
	if(Plr ~= nil and Plr:IsA("Player")) then
		Plr:SetAttribute("Device", Device_Str)

		--Update their Name Tag
		local Name_Tag = Get_Player_Name_Tag(Plr)
		if(Name_Tag ~= nil)then
			Name_Tag:WaitForChild("Main_F"):WaitForChild("Device_Img").Image = Get_Device_Image(Plr)
		end
	end
end)

Show_Shield_UI.OnServerEvent:Connect(function(Plr, Is_Enabled)
	if(Plr ~= nil and Plr.Character ~= nil)then
		Toggle_Fight_Block_UI(Plr, Is_Enabled)
	end
end)

function Update_Player_Connections()
	--Update this to run each
	while task.wait(1) do
		local All_P = game.Players:GetPlayers()
		for i = 1, #All_P do
			local P = All_P[i]
			if(P ~= nil and P.Character ~= nil)then
				Update_Playtime_Tracking(P)
				if(i % 10 == 0)then
					Update_Name_Tag_Connection(P)
				end
			end
		end
	end
end

Update_Player_Connections()

--[[
	* Name Tag Changed Events
		-> Elo Changes
		-> Health Value
		-> Stamina Value
		
		On Init
		-> Name
		-> Device
		
	* Server Update Function of Player Ping every 10 Seconds
]]]]></ProtectedString>
							<string name="ScriptGuid">{255A580E-C9D2-499D-B01C-9DB9F3DF5A9E}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Core_Character_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXE62A2EC8DF034356A2C8DCA821ECA713">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Monetization</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX23039B1F58EF4B96B05F7FDA5461F2BF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Codes_Handle.server.lua
--
--  Description:
--      Handles promotional/reward codes. Applies rewards such as cash,
--      gems, free gamepasses, crates, skill tree points, and unlockable
--      animations or moves to eligible players.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Monetization_Mod
--          * Data_Mods_F/Rewards_Mod
--          * Data_Mods_F/Crate_Mod
--          * Data_Mods_F/Skill_Tree_Mod
--          * Data_Mods_F/Animation_Mod
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Bindable_F/RF
--          * Channels_F/Client_Server_F/RF
--          * Channels_F/Client_Server_F/Events
--          * Channels_F/Server_Client_F/Events
--      - Player Instances:
--          * Player.Player_Data.Coins
--          * Player.Player_Data.Gems
--          * Player.Player_Data.Owned Special Submissions
--          * Player.Player_Data.Owned Special Strikes
--          * Player.Player_Data.Owned Gamepasses
--
--  Notes:
--      - Supports cash/gems boost and pack rewards
--      - Grants free gamepasses via BindableEvents
--      - Awards crates with simulated purchase/opening
--      - Unlocks ranked moves or strikes not yet owned
--      - Uses Rewards_Mod to validate code-to-reward mapping
--
--======================================================================

local RunService = game:GetService("RunService")

-- Modules
local Data_Mod_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Monetization_Mod = require(Data_Mod_F:WaitForChild("Monetization_Mod"))
local Rewards_Mod = require(Data_Mod_F:WaitForChild("Rewards_Mod"))
local Crate_Mod = require(Data_Mod_F:WaitForChild("Crate_Mod"))
local Skill_Tree_Mod = require(Data_Mod_F:WaitForChild("Skill_Tree_Mod"))
local Animation_Mod = require(Data_Mod_F:WaitForChild("Animation_Mod"))
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels 					= require(game.ReplicatedStorage.Modules.Channels)
local Grant_Gamepass_Perks		= Channels.Bindable_Events.Grant_Gamepass_Perks
local Grant_Free_Crate			= Channels.SC_Remote_Events.Grant_Free_Crate
local Claim_Daily_Reward		= Channels.CS_Remote_Functions.Claim_Daily_Reward
local Redeem_Skill_Tree_Reward	= Channels.CS_Remote_Functions.Redeem_Skill_Tree_Reward
local Redeem_Code 				= Channels.CS_Remote_Functions.Redeem_Code

local Get_Player_Val = PlayerUtils.GetPlayerVal

--Grant Cash, Cash Packs, Increase Cash Multiplier, Free Car (Or Cash Value of Car if already owned), Free Boosts

local function Boost_Cash(Plr, Amount)
	local Cash_Val = Get_Player_Val(Plr, "Coins")
	Cash_Val.Value += Amount
end

local function Boost_Gems(Plr, Amount)
	local Gems_Val = Get_Player_Val(Plr, "Gems")
	Gems_Val.Value += Amount
end

local function Boost_Cash_Via_Pack(Plr, Cash_Key)
	local Cash_Val = Get_Player_Val(Plr, "Coins")
	local Cash_Boost_Data = Monetization_Mod.Get_Cash_Boost_Amount(Plr)
	local Amount = Cash_Boost_Data[Cash_Key] or 1000
	
	Cash_Val.Value += Amount
end

local function Boost_Gems_Via_Pack(Plr, Gems_Key)
	local Gems_Val = Get_Player_Val(Plr, "Gems")
	local Amount = Monetization_Mod.Get_Gems_Pack_Amount(Gems_Key)

	Gems_Val.Value += Amount
end

local function Grant_Free_Gamepass(Plr, GP_Key)
	local GP_ID = Monetization_Mod.Get_ID_From_Key(true, GP_Key)
	if(GP_ID ~= -1)then
		Grant_Gamepass_Perks:Fire(Plr, GP_ID)
	end	
end

local function Award_Free_Crate(Plr, Crate_Key)
	--[[
		* get Crate Data from Key
		* Award Player the Coins in order to buy the Crate real quick
		* Fire the Shop UI to Play the Effects of the Crate Opening up
	]]--
	
	local Crate_Data = Crate_Mod.GetCrates()[Crate_Key]
	if(Crate_Data ~= nil)then
		local Price_In_Coins = Crate_Data['PriceCoins'] or 0
		Boost_Cash(Plr, Price_In_Coins)
		Grant_Free_Crate:FireClient(Plr, Crate_Data)
	end
end

local function Award_Ranked_Move(Plr, Select_Key)
	--[[
		* Get Moves the Player doesn't own that cost money
		* Get one Randomly, add to Player Data
	]]--
	
	local Owned_Submissions_V = Get_Player_Val(Plr, "Owned Special Submissions")
	if(Plr ~= nil and Owned_Submissions_V ~= nil)then
		local Owned_Keys = string.split(Owned_Submissions_V.Value, ",")
		if(Select_Key == nil or table.find(Owned_Keys, Select_Key) ~= nil)then
			local Keys_To_Give = Animation_Mod.Get_Unlockable_Submission_Keys(Plr)
			if(Keys_To_Give ~= nil and #Keys_To_Give > 0)then
				Select_Key = Keys_To_Give[math.random(1, #Keys_To_Give)]
			end
		end
		
		if(Select_Key ~= nil)then
			table.insert(Owned_Keys, Select_Key)
			Owned_Submissions_V.Value = table.concat(Owned_Keys, ",")

			local Submission_Data = Animation_Mod.Get_Special_Submission_Data(Select_Key)
			if(Submission_Data ~= nil and Submission_Data['Name'] ~= nil)then
				return Submission_Data['Name'] .. "!"
			end
		end
	end
	
	return ""
end

local function Award_Ranked_Strike(Plr, Select_Key)
	--Same as Ranked Move
	local Owned_Strikes_V = Get_Player_Val(Plr, "Owned Special Strikes")
	if(Plr ~= nil and Owned_Strikes_V ~= nil)then
		local Owned_Keys = string.split(Owned_Strikes_V.Value, ",")
		if(Select_Key == nil or table.find(Owned_Keys, Select_Key) ~= nil)then
			local Keys_To_Give = Animation_Mod.Get_Unlockable_Strike_Keys(Plr)
			if(Keys_To_Give ~= nil and #Keys_To_Give > 0)then
				Select_Key = Keys_To_Give[math.random(1, #Keys_To_Give)]
			end
		end

		if(Select_Key ~= nil)then
			table.insert(Owned_Keys, Select_Key)
			Owned_Strikes_V.Value = table.concat(Owned_Keys, ",")

			local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Select_Key)
			if(Strike_Data ~= nil and Strike_Data['Name'] ~= nil)then
				return Strike_Data['Name'] .. "!"
			end
		end
	end

	return ""
end

local function Award_Emotes(Plr, Select_Key)
	local Owned_Emotes_V = Get_Player_Val(Plr, "Owned Emotes")
	if(Plr ~= nil and Owned_Emotes_V ~= nil)then
		local Owned_Keys = string.split(Owned_Emotes_V.Value, ",")
		if(Select_Key == nil or table.find(Owned_Keys, Select_Key) ~= nil)then
			local Keys_To_Give = Animation_Mod.Get_Unlockable_Emotes(Plr)
			if(Keys_To_Give ~= nil and #Keys_To_Give > 0)then
				Select_Key = Keys_To_Give[math.random(1, #Keys_To_Give)]
			end
		end

		if(Select_Key ~= nil)then
			table.insert(Owned_Keys, Select_Key)
			Owned_Emotes_V.Value = table.concat(Owned_Keys, ",")

			local Emote_Data = Animation_Mod.Get_Emote_Data_From_Key(Select_Key)
			if(Emote_Data ~= nil and Emote_Data['Name'] ~= nil)then
				return Emote_Data['Name'] .. "!"
			end
		end
	end

	return ""
end

--local function Give_Free_Boost(Plr, Boost_Data)
--	--BOOST_DATA = {['Key'] = Boost_Key, ['Amount'] = 1}
	
--	local Owned_Products_V = Get_Player_Val(Plr, "Owned Products")
--	local Boost_Key = Boost_Data['Key'] or "D"
--	local Amount = Boost_Data['Amount'] or 1
--	local Owned_Products = string.split(Owned_Products_V.Value, ",")
	
--	for i = 1, Amount do
--		table.insert(Owned_Products, Boost_Key)
--	end
	
--	Owned_Products_V.Value = table.concat(Owned_Products, ",")
	
--	Open_Shop:FireClient(Plr, "Boosts")
--end

local function Boost_Wins(plr, amount)
	local winsVal = Get_Player_Val(plr, "Total Wins")
	if winsVal then
		winsVal.Value += amount
	end
end

local Codes_Data = {
	['A'] = {
		Code = "CHAMPS",
		Reward = Boost_Gems,
		Amount = 100,
		Text = "💎 Successfully Redeemed Code & Earned +100 Gems!",
		ExpirationDate = "2025-07-31",
		Type = "ALL",
	},

	['B'] = {
		Code = "2MILLIONS",
		Reward = Boost_Gems,
		Amount = 165,
		Text = "💎 Successfully Redeemed Code & Earned +165 Gems!",
		ExpirationDate = "2025-07-31",
		Type = "ALL",
	},

	['C'] = {
		Code = "UFCPARIS2025",
		Reward = Boost_Gems,
		Amount = 150,
		Text = "💎 Successfully Redeemed Code & Earned +150 Gems!",
		ExpirationDate = "2025-09-30",
		Type = "ALL",   
	},

	['D'] = {
		Code = "10MILLIONS",
		Reward = Boost_Gems,
		Amount = 100,
		Text = "💎 Thank you ALL for bringing MMA Fighters here +100 Gems!",
		ExpirationDate = "2025-11-30",
		Type = "ALL",
	},
	['E'] = {
		Code = "GEMS",
		Reward = Boost_Gems,
		Amount = 10000,
		Text = "💎 SPECIAL BOOST +10K Gems!",
		ExpirationDate = "2026-12-31",
		Type = "TEAM",
	},
	['F'] = {
		Code = "CASH",
		Reward = Boost_Cash,
		Amount = 10000,
		Text = "💵 SPECIAL BOOST +10K Coins !",
		ExpirationDate = "2026-12-31",
		Type = "TEAM",
	},
	['G'] = {
		Code = "ARENA",
		Reward = Boost_Wins,
		Amount = 10,
		Text = "🏆 +10 victories added to your profile!",
		ExpirationDate = "2026-12-31",
		Type = "TEAM",
	},
	['H'] = {
		Code = "5KDISCORD",
		Reward = Boost_Gems,
		Amount = 150,
		Text = "💎 Thanks for joining our MMA Fighters Discord here +150 Gems!",
		ExpirationDate = "2026-06-30",
		Type = "ALL",
	},
}


local function isCodeExpired(expiration)
	if not expiration then return false end

	local year, month, day = expiration:match("(%d+)%-(%d+)%-(%d+)")
	local expTime = os.time({year = year, month = month, day = day, hour = 23, min = 59, sec = 59})

	return os.time() > expTime
end

local function isCodeAllowedForPlayer(player, codeType)
	if codeType == "ALL" then 
		return true 
	elseif codeType == "TEAM" then
		return PlayerUtils.isDeveloper(player) or RunService:IsStudio()
	else
		return false
	end
end

local function Get_Code_Key(Code)
	for Key, Data in next, Codes_Data do
		if(Data['Code'] == Code)then
			return Key
		end
	end
	return nil
end

-----	Redeem Daily Rewards Handle	-----

local Func_Data = {
	['Gems'] = Boost_Gems,
	['Cash'] = Boost_Cash,
	['Cash Pack'] = Boost_Cash_Via_Pack,
	['Gems Pack'] = Boost_Gems_Via_Pack,
	['Crate'] = Award_Free_Crate,
	['Gamepass'] = Grant_Free_Gamepass,
	['Ranked Move'] = Award_Ranked_Move,
	['Ranked Strike'] = Award_Ranked_Strike,
	['Emotes'] = Award_Emotes
}

Claim_Daily_Reward.OnServerInvoke = function(Plr, Key)
	local Owned_Key_Val =  Get_Player_Val(Plr, "Redeemed Rewards")
	local Owned_Keys = Rewards_Mod.Get_Claimed_Daily_Player_Rewards(Plr)
	local Current_Streak = Rewards_Mod.Get_Player_Retention_Streak(Plr)

	if(Owned_Key_Val ~= nil and Current_Streak >= Key and table.find(Owned_Keys, Key .. "") == nil)then
		local Reward_Data = Rewards_Mod.Get_Specific_Daily_Reward(Key)
		local Reward_Type = Reward_Data['Type']
		local Amount = Reward_Data['Amount']
		Func_Data[Reward_Type](Plr, Amount)

		table.insert(Owned_Keys, Key)
		Owned_Key_Val.Value = table.concat(Owned_Keys, ",")

		return true
	end

	return false
end

Redeem_Skill_Tree_Reward.OnServerInvoke = function(Plr, Key, Tree_Index)
	--[[
		* Verify Player & Data Value
		* Verify the Player hasn't Redeemed already
		* Verify the Reward / Requirement Exists
		* Verify the Player has met the Requirement
		
		- Add Data Packet to the Value
		- Redeem the Reward
		- Process and return the Reward Text
	]]--
	
	local Owned_Skill_Tree_V = Get_Player_Val(Plr, "Redeemed Skill Tree")
	if(Plr ~= nil and Owned_Skill_Tree_V ~= nil and Skill_Tree_Mod.Verify_Tree_Index(Key, Tree_Index) 
		and Skill_Tree_Mod.Has_Player_Can_Redeemed_Reward(Plr, Key, Tree_Index) and 
		Skill_Tree_Mod.Player_Has_Met_Requirement(Plr, Key, Tree_Index))then
		
		local Redeemed_ST_Rewards = string.split(Owned_Skill_Tree_V.Value, ",")
		local Data_Entry = Skill_Tree_Mod.Get_Redeem_Data_Entry(Key, Tree_Index)
		table.insert(Redeemed_ST_Rewards, Data_Entry)
		Owned_Skill_Tree_V.Value = table.concat(Redeemed_ST_Rewards, ",")
		
		local Reward_Data = Skill_Tree_Mod.Get_Reward_Data(Key, Tree_Index)
		local Reward_Type = Reward_Data['Reward']
		local Amount = Reward_Data['Amount']
		local Ret_Txt = Reward_Data['Text'] 
		local Res_Txt = Func_Data[Reward_Type](Plr, Amount)
		if(Res_Txt ~= nil)then
			Ret_Txt = string.gsub(Ret_Txt, "Takedown & Submission Combo!", Res_Txt)
		end
		
		--task.spawn(Unit_Test_For_Progression, Plr, Key, Tree_Index + 1)
		return true, Ret_Txt
	end
	
	return false, ""
end

Redeem_Code.OnServerInvoke = function(Plr, Code)
	local ok = function(msg)
		return msg
	end
	local notOk = function(msg, recurse)
		local UniqueCodeFunc = game.ServerScriptService.Core.Monetization.Unique_Codes_Handle.Function

		if recurse == true then
			local result = UniqueCodeFunc:Invoke(Plr, Code)
			return result
		else
			return msg
		end
	end

	local Code_Key = Get_Code_Key(string.upper(Code))
	if not Code_Key then
		return notOk("❌ Invalid Code! Please try another!", true)
	end

	local CodeData = Codes_Data[Code_Key]

	-- expired?
	if isCodeExpired(CodeData.ExpirationDate) then
		return notOk("⌛ This code has expired!", false)
	end

	-- type mismatch?
	if not isCodeAllowedForPlayer(Plr, CodeData.Type) then
		return notOk("🚫 You are not eligible to redeem this code!", false)
	end

	-- already used?
	if CodeData.Type ~= "TEAM" then
		local Plr_Codes_Val = Get_Player_Val(Plr, "Codes")
		local Used_Codes = string.split(Plr_Codes_Val.Value, ",")
		if table.find(Used_Codes, Code_Key) ~= nil then
			return notOk("⚠️ You've already redeemed this code!", false)
		end

		-- ✅ reward
		table.insert(Used_Codes, Code_Key)
		Plr_Codes_Val.Value = table.concat(Used_Codes, ",")
	end

	local Amount = CodeData.Amount
	CodeData.Reward(Plr, Amount)

	return ok(CodeData.Text)
end

]]></ProtectedString>
							<string name="ScriptGuid">{75E15532-F7BE-44CE-AA0E-955811A98900}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Codes_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8CA8C6BC45D34ED68E63134DB3A95351">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Shop_Handle.lua
--
--  Description:
--      Handles the in-game shop and crate system. Processes purchases,
--      manages currencies, and distributes cosmetic rewards (gloves, shorts).
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Crate_Mod
--          * Data_Mods_F/Clothing_Mod
--          * Data_Mods_F/Monetization_Mod
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Bindable_F/RF
--          * Channels_F/Client_Server_F/RF
--          * Channels_F/Client_Server_F/Events
--          * Channels_F/Server_Client_F/Events
--      - Roblox Services:
--          * Players
--      - Player Instances:
--          * Player.Player_Data.Coins
--          * Player.Player_Data.Gems
--
--  Notes:
--      - Validates crate availability with Crate_Mod
--      - Deducts Coins or Gems before rewarding
--      - Luck multiplier (Monetization_Mod) increases rare drop chances
--      - Rewards handled via Clothing_Mod (gloves, shorts)
--      - Supports weighted random item selection per crate
--      - Broadcasts shop-related messages to all clients
--
--======================================================================


-- Moduless
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Crate_Mod 				= require(Data_Mods_F:WaitForChild("Crate_Mod"))
local Clothing_Mod 				= require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Monetization_Mod 			= require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Utils 					= require(game.ReplicatedStorage.Modules.Utils)
local PlayerUtils 				= require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels 					= require(game.ReplicatedStorage.Modules.Channels)
local Server_Message_Crate 		= Channels.CS_Remote_Events.Server_Message_Crate
local Crate_Action_Request 		= Channels.CS_Remote_Functions.Crate_Action_Request
local Crate_Display 			= Channels.CS_Remote_Events.Crate_Display
local Show_Crate_Effects 		= Channels.SC_Remote_Events.Show_Crate_Effects
local Server_Chat 				= Channels.SC_Remote_Events.Server_Chat
local Shop_Item_Purchased 		= Channels.SC_Remote_Events.Shop_Item_Purchased
local Shop_Purchase_Rejected	= Channels.SC_Remote_Events.Shop_Purchase_Rejected
local Purchase_Cloth_Item 		= Channels.CS_Remote_Events.Purchase_Cloth_Item
local Display_Data 				= Channels.SC_Remote_Events.Display_Data

-- Workspace references
local Main_World_F 				= game.Workspace:WaitForChild("Main_World_F")
local Objects 					= Main_World_F:WaitForChild("Gameplay"):WaitForChild("Objects")
local GymObjects 				= Objects:WaitForChild("GymObjects")
local GymCaseRig				= GymObjects:WaitForChild("GymCaseRig")
local Crates_F 					= Main_World_F:WaitForChild("Gameplay"):WaitForChild("Shop"):WaitForChild("Crates")

local ITEM_PURCHASED 			= "✅ Item purchased you can equip it on your avatar!"
local ITEM_PURCHASED_ALREADY 	= "ℹ️ You already own this item, you can equip it on your avatar!"


local Get_Player_Val 			= PlayerUtils.GetPlayerVal

local function Check_Crate(CrateName)
	local Crates = Crate_Mod.GetCrates()
	for i, crate in pairs(Crates) do
		if (crate["Name"] == CrateName) then
			return true, i
		end
	end
	return false, nil
end


--// Server Message
--Server_Message_Crate.OnServerEvent:Connect(function(Plr, Txt, Clr)
--	if(Plr ~= nil)then
--		Server_Chat:FireAllClients(Txt, Clr)
--		task.wait()
--	end
--end)

Utils.SecureRemote(
	Server_Message_Crate,
	function(player, text, color)
		Server_Chat:FireAllClients(text, color)
	end,
	{ "string", "Color3" },
	{
		RateLimit = 2,
		MaxBurst = 2,
		PunishThreshold = 10
	}
)


Utils.SecureFunction(
	Crate_Action_Request,

	function(Plr, crateName, Currency)
		if typeof(crateName) ~= "string" then return false, nil end
		if typeof(Currency) ~= "string" then return false, nil end

		local Crates = Crate_Mod.GetCrates()
		local CheckCrate, Index = Check_Crate(crateName)

		if (Plr and CheckCrate == true) then
			if (Currency == "Gems" or Currency == "Coins") then

				local Player_Currency = Get_Player_Val(Plr, Currency)
				local Chosen_Currency = "PriceCoins"
				if Currency == "Gems" then
					Chosen_Currency = "PriceGems"
				end

				if(Player_Currency and Player_Currency.Value >= Crates[Index][Chosen_Currency]) then

					Player_Currency.Value -= Crates[Index][Chosen_Currency]

					local Luck = Monetization_Mod.Get_Luck_Multi(Plr)
					local rewardType = Crates[Index].RewardType
					local rewardFunction

					if rewardType == "Gloves" then
						rewardFunction = Clothing_Mod.Give_Player_Gloves
					elseif rewardType == "Shorts" then
						rewardFunction = Clothing_Mod.Give_Player_Shorts
					end

					if rewardFunction == nil then
						Player_Currency.Value += Crates[Index][Chosen_Currency] -- REFUND
						return false, nil
					end

					local items = Crates[Index]["Items"]
					local selectedItem = nil
					local selectedItemKey = nil

					local scaling = 1.0
					local totalWeight = 0
					local adjustedItems = {}

					for _, item in pairs(items) do
						local baseChance = item["Rarity"]
						local boostFactor = 1 + ((1 / baseChance) ^ 0.5 - 1) * (Luck - 1) * scaling
						local adjustedChance = baseChance * boostFactor

						table.insert(adjustedItems, {
							Name = item["Name"],
							Weight = adjustedChance,
							ItemKey = item["ItemKey"],
						})

						totalWeight += adjustedChance
					end

					local roll = Random.new():NextNumber(0, totalWeight)
					local cumulative = 0
					for _, item in ipairs(adjustedItems) do
						cumulative += item.Weight
						if roll <= cumulative then
							selectedItem = item.Name
							selectedItemKey = item.ItemKey
							break
						end
					end

					rewardFunction(Plr, selectedItemKey)
					adjustedItems = nil

					if (selectedItem) then
						return true, selectedItem
					end

				end
			end
		end

		return false, nil
	end,
	{ "string", "string" },

	-- ==== OPTIONS (soft mode) ====
	{
		AllowMissingArgs = false,
		RateLimit = 1,
		MaxBurst = 1,
		PunishThreshold = 10,
		LogOnExploit = true
	}
)

--// Handle Displaying Crate
local function PlayKeyframeCallback(animation, Position, Callback)
	local Animation = animation
	while (task.wait() and Animation.IsPlaying) do
		if (Animation.TimePosition >= Position) then
			if (Callback) then coroutine.wrap(Callback)() end
			break
		end
	end
end

Utils.SecureRemote(
		Crate_Display,
		function(player, item, rarity, color)
			if (player ~= nil and player.Character ~= nil) then
				if (Crates_F:FindFirstChild(player.Name) == nil) then

					local ClothingFolder = game.ReplicatedStorage:WaitForChild("Models"):WaitForChild("Clothing_F")

					if not item or not item.Name then return end
					local template = ClothingFolder:FindFirstChild(item.Name, true)
					if not template then return end

					local char = player.Character
					if not char then return end
					local rootPart = char:FindFirstChild("HumanoidRootPart")
					if not rootPart then return end

					local forwardVec = rootPart.CFrame.LookVector
					local offsetPos = rootPart.Position + forwardVec * 10
					local rayOrigin = offsetPos + Vector3.new(0, 10, 0)
					local rayDirection = Vector3.new(0, -100, 0)

					local rayParams = RaycastParams.new()
					rayParams.FilterDescendantsInstances = {char}
					rayParams.FilterType = Enum.RaycastFilterType.Exclude

					local result = workspace:Raycast(rayOrigin, rayDirection, rayParams)
					if not result then return end

					local groundPos = result.Position

					local crate = GymCaseRig:Clone()
					crate.Name = player.Name
					crate.Parent = Crates_F

					local size = crate:GetExtentsSize()
					local halfHeight = size.Y / 12
					local cratePos = groundPos + Vector3.new(0, halfHeight, 0)
					local flatLookVector = -Vector3.new(forwardVec.X, 0, forwardVec.Z).Unit
					local lookCFrame = CFrame.new(cratePos, cratePos + flatLookVector)

					local anim = Instance.new("Animation")
					anim.AnimationId = "rbxassetid://113179003402113"
					local track_cons = {}
					local track = crate.AnimationController.Animator:LoadAnimation(anim)

					track:Play()
					task.wait(.1)
					crate:PivotTo(lookCFrame * CFrame.new(0,-0.65,0))

					-- Fire client to handle animations/VFX
					local nearbyPlayers = PlayerUtils.GetNearbyPlayers(player, 30) 
					for _, player in ipairs(nearbyPlayers) do
						Show_Crate_Effects:FireClient(player, crate, item.Name, color)
					end

					local glove

					PlayKeyframeCallback(track, 4, function()

						glove = template:Clone()

						if (glove:FindFirstChild("LeftHand")) then

							for _, part in pairs(glove:GetChildren()) do
								if (part:IsA("BasePart") and (part.Name == "LeftHand" or part.Name == "RightHand")) then
									local groupName = part.Name .. "M"
									local group = glove:FindFirstChild(groupName) or Instance.new("Model")
									group.Name = groupName
									group.Parent = glove
									part.Parent = group
									part.Anchored = true
								end
							end

							if (glove:FindFirstChild("LeftHandM") and glove:FindFirstChild("RightHandM")) then
								glove:PivotTo(CFrame.new(0,0,0))
								
								glove:WaitForChild("RightHandM"):PivotTo(CFrame.new(0.5, 0, 0))
								
								glove:WaitForChild("LeftHandM"):PivotTo(CFrame.new(-0.5, 0, 0))
							end


						elseif (glove:FindFirstChild("LowerTorso")) then
							glove.PrimaryPart.PivotOffset = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
						end

						local cf,size = glove:GetBoundingBox()
						local handle = Instance.new("Part")
						handle.Name = "Handle"
						handle.Size = Vector3.new(1, 1, 1)
						handle.CFrame = cf
						handle.Transparency = 1
						handle.Anchored = true
						handle.CanCollide = false
						handle.Parent = glove
						glove.PrimaryPart = handle
						glove:SetAttribute("Owner", player.Name)

						for _, part in pairs(glove:GetDescendants()) do
							if part:IsA("BasePart") then
								part.Anchored = true
								part.CanCollide = false
							end
						end

						glove:PivotTo(crate.PrimaryPart.CFrame + Vector3.new(0, 1, 0))
						glove:ScaleTo(1.5)
						glove.Parent = Crates_F
						task.wait(1)
						track:AdjustSpeed(.2)
						task.wait(6)
						track:AdjustSpeed(1)
					end)

					table.insert(track_cons, track.Stopped:Connect(function()
						crate:Destroy()
						crate = nil

						for i = 1, #track_cons do
							if(track_cons[i] ~= nil)then
								track_cons[i]:Disconnect()
							end
						end
						table.clear(track_cons)

						task.delay(1 + 0.25, function()
							if (glove) then
								glove:Destroy()
								glove = nil
							end
						end)
					end))
					
					task.delay(18, function()
						if (crate) then
							crate:Destroy()
						end
						if (glove) then
							glove:Destroy()
						end
						
						for i = 1, #track_cons do
							if(track_cons[i] ~= nil)then
								track_cons[i]:Disconnect()
							end
						end
						table.clear(track_cons)
					end)
				end
			end
		end,
	{ "Instance", "number", "Color3" },
	{
		RateLimit = 1,
		MaxBurst = 5,
		PunishThreshold = 10
	}
)

Utils.SecureRemote(
	Purchase_Cloth_Item,
	function(player, isGlove, key)
		if not key  or typeof(key) ~= "string" or key == ""  then return end

		if isGlove then
			if Clothing_Mod.Player_Owns_Gloves_Key(player,key) then
				Display_Data:FireClient(player, ITEM_PURCHASED_ALREADY, Color3.fromRGB(255, 0, 0))
				return
			end
		else
			if Clothing_Mod.Player_Owns_Shorts_Key(player,key) then
				Display_Data:FireClient(player, ITEM_PURCHASED_ALREADY, Color3.fromRGB(255, 0, 0))
				return
			end
		end


		local Offers_Config = require(Data_Mods_F:WaitForChild("Offers_Config"))
		local data = Offers_Config.GetClothDataByKey(key, isGlove)
		local PD = player:FindFirstChild("Player_Data")
		local Gems = PD and PD:FindFirstChild("Gems")


		if Gems and tonumber(Gems.Value) >= data.Gems then
			Gems.Value = Gems.Value - data.Gems
			if isGlove then
				Clothing_Mod.Give_Player_Gloves(player, key)
				Shop_Item_Purchased:FireClient(player,"Cloth_Glove",key)
			else
				Clothing_Mod.Give_Player_Shorts(player, key)
				Shop_Item_Purchased:FireClient(player,"Cloth_Shorts",key)
			end
			Display_Data:FireClient(player, ITEM_PURCHASED, Color3.fromRGB(0, 255, 0))
		else
			local MessageTxt = string.format(
				"You don't have enough Gems to buy this. You need %s more.",
				tostring(data.Gems - Gems.Value)
			)
			Shop_Purchase_Rejected:FireClient(player, "NOT_ENOUGH_GEMS", MessageTxt, Color3.fromRGB(255, 0, 0))
		end
	end,
	{ "boolean", "string" },
	{
		RateLimit = 1,
		MaxBurst = 1,
		PunishThreshold = 10
	}
)]]></ProtectedString>
							<string name="ScriptGuid">{50AC8AD6-3084-4C62-B7AF-51AF7E932AE9}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Shop_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFD9FE27642164043B925EED1610C3F13">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Monetization_Handle.server.lua
--
--  Description:
--      Handles monetization logic including Gamepasses, DevProducts,
--      limited items, and emotes. Updates player data, grants rewards,
--      and sends purchase confirmation messages.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ServerScriptService:
--          * GAModule
--      - ReplicatedStorage:
--          * Data_Mods_F/Monetization_Mod
--          * Data_Mods_F/Num_String_Mod
--          * Data_Mods_F/Clothing_Mod
--          * GameAnalytics
--          * CreatorCodes
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Client_Server_F
--          * Channels_F/Server_Client_F/Events/Display_Data
--          * Channels_F/Server_Client_F/Events/Open_Shop
--      - Roblox Services:
--          * MarketplaceService
--          * ExperienceNotificationService
--          * MessagingService
--          * DataStoreService
--      - DataStore:
--          * Limited_Items ("Fury_Gloves", max 1000)
--      - Player Instances:
--          * Player.Player_Data.Coins
--          * Player.Player_Data.Gems
--          * Player.Player_Data.Owned Gamepasses
--          * Player.Player_Data.Owned Emotes
--
--  Notes:
--      - Integrates with GameAnalytics for purchase tracking
--      - Handles VIP, Luck boosts, Cash/ELO multipliers, and emote unlocks
--      - Limited items tracked in DataStore with purchase cap
--      - Broadcasts purchase confirmations to clients
--
--======================================================================

-- Services
local MPS 				= game:GetService("MarketplaceService")
local DatastoreService	= game:GetService("DataStoreService")
local LimitedItemsStore = DatastoreService:GetDataStore("Limited_Items")

-- Modules
local Data_Mod_F 		= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Monetization_Mod 	= require(Data_Mod_F:WaitForChild("Monetization_Mod"))
local Clothing_Mod 		= require(Data_Mod_F:WaitForChild("Clothing_Mod"))
local GAModule 			= require(game.ServerScriptService.Modules.GAModule)
local GameAnalytics 	= require(game.ReplicatedStorage.Modules.GameAnalytics)
local CreatorCodes 		= require(game.ReplicatedStorage.Modules.CreatorCodes)
local PlayerUtils 		= require(game.ReplicatedStorage.Modules.PlayerUtils)
local Utils 			= require(game.ReplicatedStorage.Modules.Utils)
local AntiExploitLogger = require(game.ServerScriptService.Modules.AntiExploitLogger)

local ItemKeyName 		= "Fury_Gloves"
local ItemMaxCount 		= 1000

-- Events
local Channels					= require(game.ReplicatedStorage.Modules.Channels)

local Server_Chat				= Channels.SC_Remote_Events.Server_Chat
local Msg_E 					= Channels.SC_Remote_Events.Display_Data
local Open_Shop_E 				= Channels.SC_Remote_Events.Open_Shop
local Open_Emotes_E 			= Channels.SC_Remote_Events.Open_Emotes
local Convert_Feedback 			= Channels.SC_Remote_Events.Convert_Feedback
local Hide_Special_Gloves_Frame = Channels.SC_Remote_Events.Hide_Special_Gloves_Frame
local Grant_Gamepass_Perks		= Channels.Bindable_Events.Grant_Gamepass_Perks
local Convert_Cash_To_Gems 		= Channels.CS_Remote_Events.Convert_Cash_To_Gems

local Get_Player_Val 			= PlayerUtils.GetPlayerVal

local MAX_TRANSACTION_AMOUNT 	= 5_000_000

local function Award_Cash_Gems(Plr, Data_Type, Amount)
	if typeof(Amount) ~= "number" then return end
	if Amount <= 0 then return end
	if Amount > MAX_TRANSACTION_AMOUNT then return end  -- avoid infinite cash injections

	local Cash_Val = Get_Player_Val(Plr, Data_Type)
	if(Cash_Val ~= nil)then
		Cash_Val.Value = math.clamp(Cash_Val.Value + Amount, 0, MAX_TRANSACTION_AMOUNT)
	end
end

local function Award_Emotes_To_Player(Plr, Emote_Keys)
	local Owned_Emotes_V = Get_Player_Val(Plr, "Owned Emotes")
	if(Owned_Emotes_V ~= nil)then
		local Owned_Emotes_Arr = string.split(Owned_Emotes_V.Value, ",") or {}
		for i = 1, #Emote_Keys do
			local K = string.gsub(Emote_Keys[i], " ", "")
			if(K ~= nil and string.len(K) > 0 and table.find(Owned_Emotes_Arr, K) == nil)then
				table.insert(Owned_Emotes_Arr, K)
			end
		end
		
		Owned_Emotes_V.Value = table.concat(Owned_Emotes_Arr, ",")
	end
end

local function Gamepass_Handle(Plr, ID)
	local Key = Monetization_Mod.Get_Key_From_ID(true, ID)
	local Owned_Gamepass_Val = Get_Player_Val(Plr, "Owned Gamepasses")
	if(Owned_Gamepass_Val ~= nil) then
		local Owned_Keys = string.split(Owned_Gamepass_Val.Value, ",")
		if(table.find(Owned_Keys, Key) == nil)then
			table.insert(Owned_Keys, Key)
			Owned_Gamepass_Val.Value = table.concat(Owned_Keys, ",")
		end

		--Core Logic of Gamepass being Earned
		local GP_Msg_Data = {
			['B'] = {
				['Text'] = "⭐ Successfully purchased! You're now Earning x2 ELO after Winning Ranked Fights!",
				['Color'] = Color3.fromRGB(170, 85, 255)
			},
			
			['C'] = {
				['Text'] = "💸 Successfully purchased! You're now Earning x2 more Cash per Knockout!",
				['Color'] = Color3.new(0, 1, 0)
			},
			
			['E'] = {
				['Text'] = "🍀 Successfully purchased! You'll have x2 more Luck when opening Equipment Crates!",
				['Color'] = Color3.fromRGB(170, 255, 0)
			},
			
			['F'] = {
				['Text'] = "🍀 Successfully purchased! You'll have x3 more Luck when opening Equipment Crates!",
				['Color'] = Color3.fromRGB(170, 85, 255)
			},
			
		}

		if(Key == "A")then
			Plr:SetAttribute("Is_VIP", true)

			local Txt = "👑 You're now a VIP Player! Enjoy + 10% more Cash per Knockout & a VIP Chat Tag!"
			Msg_E:FireClient(Plr, Txt, Color3.fromRGB(255, 170, 0))

			local Txt = Plr.Name .. " is now a VIP Player!"
			Server_Chat:FireAllClients(Txt, Color3.fromRGB(255, 170, 0))

		elseif(Key == "D")then
			local Txt = "💪 Successfully purchased! You've Unlocked 3 Special Emotes!"
			Msg_E:FireClient(Plr, Txt, Color3.fromRGB(0, 170, 255))
			
			--Give to Player
			Award_Emotes_To_Player(Plr, {"I", "J", "K"}) -- Add in the 3 new Emote Keys later when you add these in
			
			Open_Emotes_E:FireClient(Plr)

		elseif(GP_Msg_Data[Key] ~= nil)then
			local D = GP_Msg_Data[Key]
			Msg_E:FireClient(Plr, D['Text'], D['Color'])
			
			if(Key == "E" or Key == "F")then
				Open_Shop_E:FireClient(Plr, "Crates")
			end
		end
	end
end

local function Additional_GP_Security_Delay(Plr, GP_ID)
	--3 Second Delay to check if Player owns Gamepass
	for i = 1, 3 do
		if(Plr == nil)then
			return false
		end

		local Did_Buy = Monetization_Mod.Hard_Gamepass_Check(Plr, GP_ID)
		if(Did_Buy == true)then
			return true
		end

		task.wait(1)
	end

	return false	
end

local GamepassCache = {}
MPS.PromptGamePassPurchaseFinished:Connect(function(Plr, GP_ID, Did_Buy)
	task.wait() -- Wait until Gamepass is fully Processed
	if(Plr ~= nil and Did_Buy)then
		local Secondary_Security_Check = Additional_GP_Security_Delay(Plr, GP_ID)
		if(Secondary_Security_Check)then
			Gamepass_Handle(Plr, GP_ID)
		end
		
		--task.spawn(function()
		--	GameAnalytics:GamepassPurchased(Plr, GP_ID)
		--end)
		task.spawn(function()
			local plrData = Plr:FindFirstChild("Player_Data")
			if plrData ~= nil then
				local creatorCode = plrData:FindFirstChild("Creator Code")
				if creatorCode ~= nil then
					local newCodeIndex = creatorCode.Value
					if CreatorCodes[newCodeIndex] ~= nil then
						local gamepassInfo = GamepassCache[GP_ID]

						--Cache
						if not gamepassInfo then
							--Get
							gamepassInfo = MPS:GetProductInfo(GP_ID, Enum.InfoType.GamePass)
							GamepassCache[GP_ID] = gamepassInfo
						end

						if gamepassInfo then
							GAModule:CreatorSupported(Plr, CreatorCodes[newCodeIndex].Name, gamepassInfo.PriceInRobux)
						end
					end
				end
			end
		end)
	end
end)

Grant_Gamepass_Perks.Event:Connect(function(Plr, GP_ID)
	if(Plr ~= nil)then
		Gamepass_Handle(Plr, GP_ID)
	end
end)

local function Dev_Product_Handle(Plr, ID)
	local Key = Monetization_Mod.Get_Key_From_ID(false, ID)
	local Item_Data = Monetization_Mod.Get_All_Dev_Product_Data()[Key]
	local Type = Item_Data['Type']
	local Owned_Products_Val = Get_Player_Val(Plr, "Owned Products")

	--local function Update_Owned_Products_Val(Key, Amount)
	--	local Owned_Keys = string.split(Owned_Products_Val.Value, ",")
	--	for i = 1, Amount do
	--		table.insert(Owned_Keys, Key)
	--	end

	--	Owned_Products_Val.Value = table.concat(Owned_Keys, ",")
	--end
	
	local HasCreatorCode = false
	local plrData = Plr:FindFirstChild("Player_Data")
	if plrData ~= nil then
		local creatorValue = plrData:FindFirstChild("Creator Code")
		if creatorValue ~= nil then
			local creatorKey = creatorValue.Value
			if CreatorCodes[creatorKey] ~= nil then
				HasCreatorCode = true
			end
		end
	end
	
	local multiplier = 1
	if HasCreatorCode == true then
		multiplier = 1.1
	end

	if(Type == "Cash")then
		local Boost_Amount = math.ceil(Monetization_Mod.Get_Cash_Boost_Amount(Plr)[Key] * multiplier)
		Award_Cash_Gems(Plr, "Coins", Boost_Amount)

		local Txt = "💸 You successfully purchased + $" .. Utils.NumToString(Boost_Amount) .. "!"
		Msg_E:FireClient(Plr, Txt, Color3.fromRGB(170, 255, 0))
		return true
		
	elseif(Type == "Gems")then
		local Boost_Amount = math.ceil((Item_Data['Amount'] or 10) * multiplier)
		Award_Cash_Gems(Plr, "Gems", Boost_Amount)

		local Txt = "💎 You successfully purchased + " .. Utils.NumToString(Boost_Amount) .. " Gems!"
		Msg_E:FireClient(Plr, Txt, Color3.fromRGB(0, 170, 255))
		return true
	elseif (Type == "StarterPack")then
		local plrData = Plr:FindFirstChild("Player_Data")
		if plrData == nil then
			return false
		end
		
		local starterPackTimer = plrData:FindFirstChild("StarterPackTimer")
		if starterPackTimer == nil then
			return false
		end
		local rookieTag = plrData:FindFirstChild("RookieTag")
		if rookieTag == nil then
			return false
		end
		
		local deltaTime = starterPackTimer.Value - os.time()
		if deltaTime <= -10 then
			return false
		end

		local Txt = "You successfully purchased the Starter Pack!"
		Msg_E:FireClient(Plr, Txt, Color3.fromRGB(255, 200, 0))

		Award_Cash_Gems(Plr, "Coins", math.ceil(200 * multiplier))
		Award_Cash_Gems(Plr, "Gems", math.ceil(5 * multiplier))
		Clothing_Mod.Give_Player_Gloves(Plr, "C")
		rookieTag.Value = true
		
		starterPackTimer.Value = os.time() - 15 -- Reset it so that 
		
		return true
	elseif Type == "Special Gloves" then

		local Txt = "You successfully purchased the Special Gloves!"
		Msg_E:FireClient(Plr, Txt, Color3.fromRGB(255, 200, 0))
		
		local value = false
		LimitedItemsStore:UpdateAsync(ItemKeyName, function(oldValue)
			if oldValue == nil then
				oldValue = 0
			end
			
			local newValue = oldValue + 1
			game.Workspace:SetAttribute("Remaining_Special_Gloves", math.min(newValue, ItemMaxCount))
			
			if newValue <= ItemMaxCount then
				value = true
			else
				value = false
			end
			
			if value == true then
				local plrData = Plr:FindFirstChild("Player_Data")
				if plrData ~= nil then
					if Clothing_Mod.Player_Owns_Gloves_Key(Plr, "G2") ~= true then
						Clothing_Mod.Give_Player_Gloves(Plr, "G2")
						Hide_Special_Gloves_Frame:FireClient(Plr)
					end
				end
			end
			
			return newValue
		end)
		
		return true
	end

	return false
end

task.spawn(function()
	while true do
		local currentCount = ItemMaxCount
		pcall(function()
			currentCount = LimitedItemsStore:GetAsync(ItemKeyName) or 0
		end)
		
		game.Workspace:SetAttribute("Total_Special_Gloves", ItemMaxCount)
		game.Workspace:SetAttribute("Remaining_Special_Gloves", currentCount)
		
		task.wait(60)
	end
end)

local Dev_Product_Receipts = {}
local ProductCache = {}

local function Create_Receipt(receiptInfo)
	--Verify Player exists, Verify Dev Product exists
	--Add Result of Purchase to Dev Product Receipt Table
	local P_ID = receiptInfo.PlayerId
	local Dev_ID = tonumber(receiptInfo.ProductId)
	local Plr = game.Players:GetPlayerByUserId(P_ID)
	local Dev_Key = Monetization_Mod.Get_Key_From_ID(false, Dev_ID)

	if(Plr ~= nil and Dev_Key ~= nil)then
		--Add to Data Table
		if(Dev_Product_Receipts[Dev_ID] ~= nil)then
			table.insert(Dev_Product_Receipts[Dev_ID], P_ID)
		else
			Dev_Product_Receipts[Dev_ID] = {P_ID}
		end
		
		task.spawn(function()
			GameAnalytics:ProcessReceiptCallback(receiptInfo)
		end)
		task.spawn(function()
			local plrData = Plr:FindFirstChild("Player_Data")
			if plrData ~= nil then
				local creatorCode = plrData:FindFirstChild("Creator Code")
				if creatorCode ~= nil then
					local newCodeIndex = creatorCode.Value
					if CreatorCodes[newCodeIndex] ~= nil then
						local ProductInfo = ProductCache[receiptInfo.ProductId]

						if not ProductInfo then
							local success, err = pcall(function()
								ProductInfo = MPS:GetProductInfo(receiptInfo.ProductId, Enum.InfoType.Product)
								ProductCache[receiptInfo.ProductId] = ProductInfo
							end)
							if success == false then
								warn(err)
							end
						end

						if ProductInfo then
							GAModule:CreatorSupported(Plr, CreatorCodes[newCodeIndex].Name, ProductInfo.PriceInRobux)
						end
					end
				end
			end
		end)

		return Enum.ProductPurchaseDecision.PurchaseGranted
	end

	return Enum.ProductPurchaseDecision.NotProcessedYet
end
MPS.ProcessReceipt = Create_Receipt

MPS.PromptProductPurchaseFinished:Connect(function(P_ID, Dev_ID, Did_Buy)
	task.wait() -- Wait until Recepit is made and Processed
	if(game.Players:GetPlayerByUserId(P_ID) ~= nil and Did_Buy and Dev_Product_Receipts[Dev_ID] ~= nil)then
		local P_Index = table.find(Dev_Product_Receipts[Dev_ID], P_ID)
		if(P_Index ~= nil)then
			local Plr = game.Players:GetPlayerByUserId(P_ID)
			local Was_Processed = Dev_Product_Handle(Plr, Dev_ID)

			--Don't remove if this is a Home Sale Listing Slot
			if(Was_Processed)then
				table.remove(Dev_Product_Receipts[Dev_ID], P_Index)
			end
		end
	end
end)

-- Listen for the Convert_Cash_To_Gems event for cash to gem conversion (see Client_Shop_Handle in Shop_UI)
-- =========================================================
-- SECURE REMOTE : Convert_Cash_To_Gems
-- =========================================================
Utils.SecureRemote(
	Convert_Cash_To_Gems,

	function(player, amount)
		local Conversion_Settings = Monetization_Mod.Get_Conversion_Settings()
		local RATE = Conversion_Settings.RATE
		local FEE = Conversion_Settings.FEE

		-- Basic validation
		if typeof(amount) ~= "number" then
			AntiExploitLogger.Log(player, "Invalid Argument Type", "Amount was not a number")
			return 
		end
		if amount <= 0 then return end
		if amount > MAX_TRANSACTION_AMOUNT then
			AntiExploitLogger.Log(player, "Excessive Amount", "Tried to convert ".. amount)
			return 
		end  -- hard cap protection

		-- Anti exploit: prevent decimals or tiny spam
		amount = math.floor(amount)

		-- Load player data
		local PD = player:FindFirstChild("Player_Data")
		if not PD then return end

		local cash = PD:FindFirstChild("Coins")
		local gems = PD:FindFirstChild("Gems")
		if not cash or not gems then return end

		-- Player must have enough cash
		if cash.Value < amount then
			Convert_Feedback:FireClient(player, "Not enough cash available.")
			return
		end

		-- Calculate final gems
		local gemsRaw = amount / (1 / RATE)
		local gemsFinal = math.floor(gemsRaw * (1 - FEE))

		if amount >= 20 and gemsFinal < 1 then
			gemsFinal = 1
		end

		if gemsFinal < 1 then
			Convert_Feedback:FireClient(player, "Not enough for 1 gem.")
			return
		end

		-- Apply conversion
		cash.Value -= amount
		gems.Value = math.min(gems.Value + gemsFinal, 9_000_000_000) -- overflow protection

		Convert_Feedback:FireClient(player, cash.Value, gems.Value)
	end,

	{ "number" },

	{
		AllowMissingArgs = false,
		RateLimit = 1,
		MaxBurst = 5,
		PunishThreshold = 8
	}
)]]></ProtectedString>
							<string name="ScriptGuid">{FF9D0881-9CDC-4BD0-A579-9D611E3DE7D2}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Monetization_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXCE9BDA84A8D046E18A2E01E86840A494">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Training_Handle.lua
--
--  Description:
--      Manages gym training machines and player workout sessions.
--      Tracks repetitions, time spent, and rewards players with Cash/Gems.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/GymObjects/Machines_F
--      - ReplicatedStorage:
--          * Data_Mods_F
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Bindable_F/RF
--          * Channels_F/Client_Server_F/RF
--          * Channels_F/Client_Server_F/Events
--          * Channels_F/Server_Client_F/Events
--      - Roblox Services:
--          * RunService
--      - Player Instances:
--          * Player.Player_Data (Cash, Gems, Gym Training, etc.)
--
--  Notes:
--      - Tracks per-player workout times and updates "Gym Training" stat
--      - Small chance to reward Gems instead of Cash per repetition
--      - Grants periodic Cash rewards during training
--      - Welds machine parts together for stability
--      - Cleans up connections on player removal
--
--======================================================================

-- Modules
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels 			= require(game.ReplicatedStorage.Modules.Channels)
local Workout_Rep 		= Channels.CS_Remote_Events.Workout_Rep
local Init_Gym_Training = Channels.SC_Remote_Events.Init_Gym_Training
local Exit_Machine_E 	= Channels.CS_Remote_Events.Exit_Machine

local Get_Player_Val = PlayerUtils.GetPlayerVal

local Machines_F = workspace.Main_World_F.Gameplay.Objects.GymObjects.Machines

--// machine tables
local Prompts = {}
local Cons = {}

--// time tables
local Player_Times = {}
local Server_Plr_Times = {}
local last_RepTime = {}

local Most_Time_Spent = nil

--// track player who spent most time working 

local function len(t)
	local n = 0

	for _ in pairs(t) do
		n = n + 1
	end
	return n
end

local function Check_Training(plr: Player)
	if (plr ~= nil) then
		for _, machine in pairs(Machines_F:GetChildren()) do
			if (machine ~= nil and machine:FindFirstChild("Stats")) then
				if (machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == plr.Name) then
					return true, machine
				end
			end
		end
	end
end

local function Check_Most_Time()
	local n = len(Server_Plr_Times)
	if n >= 1 then
		local most_Time = 0
		local most_Plr = nil

		for player, number in pairs(Server_Plr_Times) do
			if number > most_Time then
				most_Time = number
				most_Plr = player
			end
			
			local playerInstance = game.Players:FindFirstChild(player)
			if not playerInstance then
				continue
			end
			
			local Gym_V = Get_Player_Val(playerInstance, "Gym Training")
			if (number > Gym_V.Value) then
				Gym_V.Value = number
			end
		end

		if (most_Plr) then
			Most_Time_Spent = most_Plr
		end
	end
end

local function Disconnect_PlrCons(PlayerName)
	if not Cons[PlayerName] then return end

	if Cons[PlayerName].Connection then
		task.cancel(Cons[PlayerName].Connection)
	end

	if Cons[PlayerName].Event then
		Cons[PlayerName].Event:Disconnect()
	end

	Cons[PlayerName] = nil
end

--// setup tracking time spent on machine
--// Have a 0.1% chance that the Player can earn +1 Diamond / Gem instead of Cash after each Rep
--// Reward the Player with occasional Cash during/after Reps

--// treadmill : every 30 seconds, do +1 Rep 
local function Weld_Model_Parts(model: Model)
	for _, part in pairs(model:GetDescendants()) do
		if (model.PrimaryPart ~= nil) then
			if (part:IsA("BasePart") and part ~= model.PrimaryPart) then
				local weld = Instance.new("WeldConstraint")
				weld.Part0 = model.PrimaryPart
				weld.Part1 = part
				weld.Parent = model.PrimaryPart
			end
		end
	end
end

local function Weld_Obj(Plr : Player, GymObj : Instance) -- if gym obj has weight then this will weld it to the player
	if (Plr ~= nil and GymObj ~= nil) then
		local char = Plr.Character
		if not char then return end

		local hand = char:FindFirstChild("RightHand")
		if not hand then return end

		local torso = char:FindFirstChild("HumanoidRootPart")
		if not torso then return end

		if (GymObj.Name == "Barbell") then
			local barbell = GymObj:Clone()
			barbell.Name = "GymObj"
			barbell.Parent = workspace[Plr.Name]

			if not barbell.PrimaryPart then
				if barbell:FindFirstChild("BarbellRod") then
					barbell.PrimaryPart = barbell.BarbellRod
				end
			end

			Weld_Model_Parts(barbell)

			for _, part in ipairs(barbell:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Anchored = false
					part.Massless = true
					part.Transparency = 0
				end
			end

			for _, part in ipairs(GymObj:GetChildren()) do
				if part:IsA("BasePart") then
					part.Transparency = 1
				end
			end

			barbell.PrimaryPart:SetNetworkOwner(Plr)

			local handAttachment = hand:FindFirstChild("BarbellAttachment") or Instance.new("Attachment")
			handAttachment.Name = "BarbellAttachment"
			handAttachment.Parent = hand

			local barbellAttachment = Instance.new("Attachment")
			barbellAttachment.Name = "HandleAttachment"
			barbellAttachment.Parent = barbell.PrimaryPart

			local alignPos = Instance.new("AlignPosition")
			alignPos.Attachment0 = barbellAttachment
			alignPos.Attachment1 = handAttachment
			alignPos.RigidityEnabled = true
			alignPos.ReactionForceEnabled = false
			alignPos.MaxForce = math.huge
			alignPos.Responsiveness = 200
			alignPos.Parent = barbell.PrimaryPart

			local alignOri = Instance.new("AlignOrientation")
			alignOri.Attachment0 = barbellAttachment
			alignOri.Attachment1 = handAttachment
			alignOri.RigidityEnabled = true
			alignOri.ReactionTorqueEnabled = false 
			alignOri.MaxTorque = math.huge
			alignOri.Responsiveness = 200
			alignOri.Mode = Enum.OrientationAlignmentMode.OneAttachment
			alignOri.Parent = barbell.PrimaryPart

			alignOri.CFrame = CFrame.Angles(0, math.rad(90), 0) 

			if (GymObj.Parent.Name == "BenchPress") then
				barbellAttachment.CFrame = CFrame.new(0, -0.3, 1.4)
			elseif (GymObj.Parent.Name == "BenchPress2") then
				barbellAttachment.CFrame = CFrame.new(0, -0.3, -1.4)
			elseif (GymObj.Parent.Name == "SquatRack") then
				barbellAttachment.CFrame = CFrame.new(0, -0.3, -1.8)
			end

		elseif (GymObj.Name == "Dumbells") then

			local LDumbell = GymObj:FindFirstChild("Dumbell"):Clone()
			LDumbell.Name = "LDumbell"
			LDumbell.Parent = workspace[Plr.Name]
			LDumbell.Anchored = false
			LDumbell.Massless = true
			LDumbell.Transparency = 0

			local RDumbell = GymObj:FindFirstChild("Dumbell"):Clone()
			RDumbell.Name = "RDumbell"
			RDumbell.Parent = workspace[Plr.Name]
			RDumbell.Anchored = false
			RDumbell.Massless = true
			RDumbell.Transparency = 0

			LDumbell:SetNetworkOwner(Plr)
			RDumbell:SetNetworkOwner(Plr)

			RDumbell:PivotTo(char:FindFirstChild("RightHand").CFrame  * CFrame.new(0, -0.35, 0)) -- * CFrame.new(-1.5, -0.5, 0) * CFrame.Angles(0, math.rad(90), 0)
			LDumbell:PivotTo(char:FindFirstChild("LeftHand").CFrame  * CFrame.new(0, -0.35, 0))

			local weld = Instance.new("WeldConstraint")
			weld.Name = "DumbellWeld"
			weld.Part0 = char:FindFirstChild("RightHand")
			weld.Part1 = RDumbell
			weld.Parent = RDumbell

			local weld2 = Instance.new("WeldConstraint")
			weld2.Name = "DumbellWeld"
			weld2.Part0 = char:FindFirstChild("LeftHand")
			weld2.Part1 = LDumbell
			weld2.Parent = LDumbell
		end
	end
end

local function Detach_Obj(Plr: Player, Machine : Instance)
	if (Plr ~= nil and Machine ~= nil) then
		if (Plr.Character:FindFirstChild("GymObj")) then

			Plr.Character:FindFirstChild("GymObj"):Destroy()

			if (Machine:FindFirstChild("Barbell") ~= nil) then
				for _, part in pairs(Machine:FindFirstChild("Barbell"):GetChildren()) do
					if part:IsA("BasePart") then
						part.Transparency = 0
					end
				end
			end

		elseif (Plr.Character:FindFirstChild("LDumbell")) then
			Plr.Character:FindFirstChild("LDumbell"):Destroy()
			Plr.Character:FindFirstChild("RDumbell"):Destroy()

			if (Machine:FindFirstChild("Dumbells") ~= nil) then
				for _, part in pairs(Machine:FindFirstChild("Dumbells"):GetChildren()) do
					if part:IsA("BasePart") then
						part.Transparency = 0
					end
				end
			end
		end
	end
end

local function Reward_Player(player : Player)
	
	local randomRoll = math.random(1, 100) 
	local reward_value = randomRoll == 1 and 100 or 5 --1% chance to get 100 cash instead of 5
	PlayerUtils.RewardPlayer(player, "Coins", reward_value)
	
	--if randomRoll == 1 then -- 1% chance
	--	--print(player.Name .. " earned 5 GEMS!")
	--	local Gem_Val = Get_Player_Val(player, "Gems")
	--	if(Gem_Val ~= nil)then
	--		Gem_Val.Value += 5
	--	end
	--else
	--	--print(player.Name .. " earned some cash.")
	--	local Cash_Val = Get_Player_Val(player, "Coins")
	--	if(Cash_Val ~= nil)then
	--		Cash_Val.Value += 1
	--	end
	--end
end

local function Update_Stats(Plr : Player, bool : boolean, Object : Instance)
	--// update the stats on the ui and training
	if (Plr ~= nil and Plr.Character ~= nil) then

		local IsTraining, Machine = Check_Training(Plr)
		if (IsTraining == true and bool == true) then
			if (Plr.Character:FindFirstChild("HumanoidRootPart"):FindFirstChild("Training_Stats_UI") == nil) then
				--// start training
				local UI = script:WaitForChild("Training_Stats_UI"):Clone()
				UI.Parent = Plr.Character:FindFirstChild("HumanoidRootPart")
				UI.Adornee = Plr.Character:FindFirstChild("HumanoidRootPart")
				UI.Enabled = true

				if (Most_Time_Spent == Plr.Name and Server_Plr_Times[Plr.Name] ~= nil) then
					UI.Main_F.Longest_Trainer_F.Data_Txt.Text = string.format("%02i:%02i", Server_Plr_Times[Plr.Name]/60, Server_Plr_Times[Plr.Name]%60)
					UI.Main_F.Longest_Trainer_F.Visible = true
				end

				if (Object ~= nil and Object.Name == "Treadmill") then
					Cons[Plr.Name] = {}

					Cons[Plr.Name].Connection = task.spawn(function()
						Player_Times[Plr.Name] = 0
						local current_Time = 0
						local Countdown = 31
						local machine_stats = Machine.Stats

						--// time
						while task.wait(1) do

							--local Check_Training, Machine_Obj = Check_Training(Plr)
							--if not Check_Training then break end
							if not Cons[Plr.Name] then break end
							
							if Plr:FindFirstChild("Player_Data") then
								if Plr.Player_Data:FindFirstChild("Gym Training") then
									Plr.Player_Data["Gym Training"].Value += 1
								end
							end

							Countdown -= 1
							current_Time += 1
							Player_Times[Plr.Name] += 1
							UI.Main_F.Countdown_Timer_F.Data_Txt.Text = tostring(Countdown).."s"
							UI.Main_F.Current_Timer_F.Data_Txt.Text = string.format("%02i:%02i", machine_stats.Time_Spent.Value/60, machine_stats.Time_Spent.Value%60)
							machine_stats.Time_Spent.Value = Player_Times[Plr.Name]

							if current_Time >= 30 then -- every 30 seconds rep time for treadmil
								current_Time = 0

								if Machine and Machine:FindFirstChild("Stats") then
									machine_stats.Reps.Value += 1
									UI.Main_F.Rep_Counter_F.Data_Txt.Text = tostring(machine_stats.Reps.Value).." Reps"
								end
							end

							if (Countdown <= 0) then
								--// reward player cash or gems etc.. 
								--// reward player reward
								Reward_Player(Plr)
								Countdown = 31 -- default
							end
						end
					end)


				elseif (Object ~= nil and Machine:FindFirstChild("Stats") ~= nil) then --and Object.Name == "BenchPress" or Object.Name == "SquatRack"

					local machine_stats = Machine.Stats

					if (Object:FindFirstChild("Barbell") ~= nil) then
						Weld_Obj(Plr, Object:FindFirstChild("Barbell"))
					elseif (Object:FindFirstChild("Dumbells") ~= nil) then
						Weld_Obj(Plr, Object:FindFirstChild("Dumbells"))
					end

					Cons[Plr.Name] = {}
					Cons[Plr.Name].Connection = task.spawn(function()
						Player_Times[Plr.Name] = 0
						local current_Time = 0
						local Countdown = 31

						--// time
						while task.wait(1) do

							--local Check_Training, Machine_Obj = Check_Training(Plr)
							--if not Check_Training then break end
							if not Cons[Plr.Name] then break end

							if not UI then break end
							
							if Plr:FindFirstChild("Player_Data") then
								if Plr.Player_Data:FindFirstChild("Gym Training") then
									Plr.Player_Data["Gym Training"].Value += 1
								end
							end

							Countdown -= 1
							current_Time += 1
							Player_Times[Plr.Name] += 1
							UI.Main_F.Countdown_Timer_F.Data_Txt.Text = tostring(Countdown).."s"
							UI.Main_F.Current_Timer_F.Data_Txt.Text = string.format("%02i:%02i", machine_stats.Time_Spent.Value/60, machine_stats.Time_Spent.Value%60)
							machine_stats.Time_Spent.Value = Player_Times[Plr.Name]

							if current_Time >= 30 then -- every 30 seconds rep time for treadmil
								current_Time = 0
							end

							if (Countdown <= 0) then
								Reward_Player(Plr)
								Countdown = 31 -- default
							end
						end
					end)

					if (Machine.Name ~= "Pusher") then
						Cons[Plr.Name].Event = Workout_Rep.OnServerEvent:Connect(function(player)
							if (player.Name == Plr.Name) then
								local now = tick()
								if last_RepTime[player.Name] and now - last_RepTime[player.Name] < 1 then
									return
								end

								last_RepTime[player.Name] = now
								--// plus 1 rep 
								if Machine and Machine:FindFirstChild("Stats") then
									machine_stats.Reps.Value += 1
									UI.Main_F.Rep_Counter_F.Data_Txt.Text = tostring(machine_stats.Reps.Value).." Reps"
								end
							end
						end)
					elseif (Machine.Name == "Pusher") then
						local initialMachineCFrame = Machine:FindFirstChild("Push").PrimaryPart.CFrame
						local initialPlayerCFrame = Plr.Character.HumanoidRootPart.CFrame
						local PushMachine = Machine:FindFirstChild("Push")
						
						Cons[Plr.Name].Event = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
							if (Plr.Character:FindFirstChild("Humanoid") ~= nil) then
								
								local distance = (Machine:FindFirstChild("End_HitBox").Position - Plr.Character.HumanoidRootPart.Position).Magnitude
								
								local direction = PushMachine.PrimaryPart.CFrame.LookVector
								PushMachine:PivotTo(PushMachine.PrimaryPart.CFrame + direction * 2 * deltaTime)

								local offset = -PushMachine.PrimaryPart.CFrame.LookVector * 3.5
								Plr.Character.HumanoidRootPart.CFrame = PushMachine.PrimaryPart.CFrame * CFrame.new(offset.X, 1.1, offset.Z)
								
								if distance < 4 then
									-- Reset Pusher
									Machine:FindFirstChild("Push"):PivotTo(initialMachineCFrame)
									Plr.Character.HumanoidRootPart.CFrame = initialPlayerCFrame

									if Machine and Machine:FindFirstChild("Stats") then
										machine_stats.Reps.Value += 1
										UI.Main_F.Rep_Counter_F.Data_Txt.Text = tostring(machine_stats.Reps.Value).." Reps"
									end
								end	
							end
							task.wait(0.1)
						end)
					end
				end
			end
		elseif (IsTraining == true and bool == false) then-- end training reset everything finished training

			if (Plr.Character:FindFirstChild("HumanoidRootPart"):FindFirstChild("Training_Stats_UI")) then
				Plr.Character:FindFirstChild("HumanoidRootPart"):FindFirstChild("Training_Stats_UI"):Destroy()
			end

			for _, machine in pairs(Machines_F:GetChildren()) do
				if (machine ~= nil and machine:FindFirstChild("Stats")) then
					if (machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == Plr.Name) then
						machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value = ""
						machine:FindFirstChild("Stats"):FindFirstChild("Reps").Value = 0
						machine:FindFirstChild("Stats"):FindFirstChild("Time_Spent").Value = 0
						break
					end
				end
			end

			if (Machine:FindFirstChild("Barbell") ~= nil or Machine:FindFirstChild("Dumbells") ~= nil) then
				Detach_Obj(Plr, Machine)
			end
			
			if (Machine.Name == "Pusher") then
				Machine:FindFirstChild("Push"):PivotTo(CFrame.new(Machine:FindFirstChild("Push").PrimaryPart.CFrame.X,Machine:FindFirstChild("Push").PrimaryPart.CFrame.Y,-247.739))
			end
	
			if (Prompts[Plr.Name]) then
				Prompts[Plr.Name].Enabled = true
				Prompts[Plr.Name] = nil
			end

			if (Server_Plr_Times[Plr.Name] == nil and Player_Times[Plr.Name] ~= nil) then
				Server_Plr_Times[Plr.Name] = Player_Times[Plr.Name]
			elseif (Server_Plr_Times[Plr.Name] ~= nil and Player_Times[Plr.Name] ~= nil) then
				if (Player_Times[Plr.Name] >= Server_Plr_Times[Plr.Name]) then
					Server_Plr_Times[Plr.Name] = Player_Times[Plr.Name]
				end
			end

			if (last_RepTime[Plr.Name] ~= nil) then
				last_RepTime[Plr.Name] = nil
			end

			if (Cons[Plr.Name]) then
				Disconnect_PlrCons(Plr.Name)
			end
		end
	end
	task.wait()
end

--// setup all the proximity prompts and triggering the basic stuff
local function Setup_Gym() -- dumbells, gymfloormat, treadmill, benchpress, pusher, squatrack
	local Machines = Machines_F:GetChildren()

	for i = 1, #Machines do
		local Machine = Machines[i]
		if(Machine ~= nil and Machine:FindFirstChild("ProximityPrompt", true)) then 
			--if (Machine.Name == "Treadmill") then
			Machine:FindFirstChild("ProximityPrompt", true).Triggered:Connect(function(Plr)
				if (Prompts[Plr.Name] == nil) then
					Prompts[Plr.Name] = Machine:FindFirstChild("ProximityPrompt", true)
					Prompts[Plr.Name].Enabled = false
					if (Machine:FindFirstChild("Stats") ~= nil and Machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == "") then
						if (Plr.Character:FindFirstChild("Humanoid")) then
							local char = Plr.Character
							local hum = char:WaitForChild("Humanoid")
							Machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value = Plr.Name
							char:FindFirstChild("HumanoidRootPart"):PivotTo(Machine:FindFirstChild("Player_Pos").CFrame)
							Init_Gym_Training:FireClient(Plr, true)
							Update_Stats(Plr, true, Machine)
							task.wait(.3)
							char:FindFirstChild("HumanoidRootPart").Anchored = true
						end
					end
				end
			end)
		end
	end

	task.spawn(function()
		while task.wait(100) do
			Check_Most_Time()
		end
	end)
end

local function Exit_Machine(Plr : Player) -- // exit the machine and reset everything 
	task.spawn(Check_Most_Time)
	Update_Stats(Plr, false, nil)
	
	local playerCharacter = Plr.Character
	local hrp:BasePart = playerCharacter:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("Can't get HRP for player",Plr.Name)
		return
	end
	
	if (hrp ~= nil) then
		hrp.Anchored = false
	end

	if (Cons[Plr.Name]) then
		Disconnect_PlrCons(Plr.Name)
	end

	Init_Gym_Training:FireClient(Plr, false)
end

Exit_Machine_E.OnServerEvent:Connect(Exit_Machine)
Setup_Gym()

--// setup player removing and make sure everything is cleaned up and reset in-case they were using a machine and remove them from the server time table
game:GetService("Players").PlayerRemoving:Connect(function(Plr)
	if (Prompts[Plr.Name]) then
		--local Last_Used = nil

		for _, machine in pairs(Machines_F:GetChildren()) do
			if (machine ~= nil and machine:FindFirstChild("Stats")) then
				if (machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == Plr.Name) then
					machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value = ""
					machine:FindFirstChild("Stats"):FindFirstChild("Reps").Value = 0
					machine:FindFirstChild("Stats"):FindFirstChild("Time_Spent").Value = 0
					--Last_Used = machine
					break
				end
			end
		end

		if (Prompts[Plr.Name]) then
			Prompts[Plr.Name].Enabled = true
			Prompts[Plr.Name] = nil
		end	

		if (Cons[Plr.Name]) then
			Disconnect_PlrCons(Plr.Name)
		end
	end
	
	Player_Times[Plr.Name] = nil
	Server_Plr_Times[Plr.Name] = nil
end)]]></ProtectedString>
							<string name="ScriptGuid">{010ED568-84EB-4153-B4DE-0108B5A93847}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Training_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX9E3C4017FAA448EAB542195984D3C462">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Gym_Reward_Handle.server.lua
--
--  Description:
--      Manages gym reward events where players race to hit a highlighted
--      object (punching bag or mannequin). First to strike wins a prize.
--
--  Author(s): Oriane
--
--  Last Modified: 2025-09-29 by Oriane
--
--  Version: V2025-09
--
--  Dependencies:
--      - Workspace:
--          * Main_World_F/Objects/GymObjects/BoxingManequins/BoxingMannequin
--          * Main_World_F/Objects/GymObjects/PunchingBag
--      - ReplicatedStorage:
--          * Channels_F/Server_Client_F/Events/Display_Data
--          * Channels_F/Server_Client_F/Events/Gym_Reward_Testing
--          * Channels_F/Client_Server_F/Events/Gym_Reward_Testing
--          * Channels_F/Bindable_F/Events/Equipment_Strike
--      - Roblox Services:
--          * Players
--
--  Notes:
--      - Designed for a single gym reward event per server
--      - Dynamically selects a punching bag or mannequin for the event
--      - Uses a highlight to mark the selected event object
--      - Sends countdown and result notifications to all clients
--      - Rewards the winning player with a random item from a list
--      - Resets the event after a delay
--      - Cleans up highlight and event state after completion
--
--======================================================================

-- Modules
local DataMods = game:GetService("ReplicatedStorage"):WaitForChild("Data_Mods_F")
local RewardsMod = require(DataMods:WaitForChild("Rewards_Mod"))
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Utils = require(game.ReplicatedStorage.Modules.Utils)
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels = require(game.ReplicatedStorage.Modules.Channels)

-- Events configuration
local Display_Data_E 		=  Channels.SC_Remote_Events.Display_Data
local Gym_Reward_Testing 	= Channels.CS_Remote_Events.Gym_Reward_Testing
local Gym_Reward_Update 	= Channels.Bindable_Events.Gym_Reward_Update
local Equipment_Strike_E	= Channels.Bindable_Events.Equipment_Strike

local GymHighlightTemplate = game.ReplicatedStorage:WaitForChild("Models"):WaitForChild("GymEventAssets"):WaitForChild("Highlight")

local Event_Messages_Color = RewardsMod.Gym_Rewards_Messages_Color ----Color3.fromRGB(255, 208, 21)
--local Event_TimeFrame = RewardsMod.Gym_Rewards_TimeFrame -- 5 minutes
local Event_Duration = RewardsMod.Gym_Rewards_Duration -- 15 secondes
local Event_Data = RewardsMod.Gym_Rewards_Data

local function Get_Children_By_Name(folder, name)
	local results = {}
	for _, obj in ipairs(folder:GetChildren()) do
		if obj.Name == name then
			table.insert(results, obj)
		end
	end
	return results
end

local function Concat_Lists(a, b)
	local result = {}
	for _, v in ipairs(a) do
		table.insert(result, v)
	end
	for _, v in ipairs(b) do
		table.insert(result, v)
	end
	return result
end

local Gameplay = workspace.Main_World_F.Gameplay
local GymObjects = Gameplay.Objects.GymObjects
local Manequins = Get_Children_By_Name(GymObjects.BoxingManequins, "BoxingMannequin")
local BoxingBags = Get_Children_By_Name(GymObjects.PunchingBags, "PunchingBag")
local CandidateObjects = Concat_Lists(Manequins, BoxingBags)

-- Event state
local EventActive = false
local RewardGiven = false
local Highlight = nil

-- Random object selection
local function getRandomObject()
	return CandidateObjects[math.random(1, #CandidateObjects)]
end

-- Add highlight to the chosen Object 
local function highlightObject(obj)
	Highlight = GymHighlightTemplate:Clone()
	Highlight.Parent = GymObjects
	Highlight:PivotTo(obj.PrimaryPart.CFrame)
end

-- Remove highlight
local function unhighlightObject()
	if Highlight then
		Highlight:Destroy()
		Highlight = nil
	end
end

---- Reward the winning player
--local function Give_Reward(player, reward)
--	-- apply reward to player data
--	local PD = player:FindFirstChild("Player_Data")
--	if PD and reward then
--		if reward.type == "Coins" or reward.type == "Cash" then
--			local coins = PD:FindFirstChild("Coins")
--			if coins then
--				coins.Value += reward.amount
--			end
--		elseif reward.type == "Gems" then
--			local gems = PD:FindFirstChild("Gems")
--			if gems then
--				gems.Value += reward.amount
--			end
--		end
--	end
--end

-- Save player's reward count to DataStore
local function Save_DataStore(player)
	local plrData = player:FindFirstChild("Player_Data")
	if not plrData then return false end

	local gymEventRewards = plrData:FindFirstChild("GymEventRewards")
	if not gymEventRewards then
		return false
	end
	gymEventRewards.Value = gymEventRewards.Value+1
	return true
end

local function Send_Message(msg, color)
	Display_Data_E:FireAllClients(msg, color)
end

-- Start event on a random object at a random time in the timeframe
local function Start_Gym_Event(reward)
	if EventActive then return end
	EventActive = true
	RewardGiven = false

	local chosenObject = getRandomObject()
	highlightObject(chosenObject)
	Sound_Mod.PlaySFX(chosenObject, "Start_Fight_Bell_SE")

	local msg = "🎯 Golden Punch target identified in the Gym! Be the first to hit it!"
	Send_Message(msg, Event_Messages_Color)

	-- Detect strike on the chosen object
	Equipment_Strike_E.Event:Connect(function(player, equipment)
		if EventActive and not RewardGiven then
			if chosenObject and chosenObject.Parent then
				if (equipment == chosenObject or equipment.Parent == chosenObject) then
					RewardGiven = true
					local msg = "🏆 "..player.Name .." won the Golden Punch reward! ".. reward.label
					Send_Message(msg, Event_Messages_Color)

					-- ✅ Reward for the player
					PlayerUtils.RewardPlayer(player, reward.type, reward.amount)
					-- Store the reward in the player's datastore
					Save_DataStore(player)

					unhighlightObject()
					EventActive = false
					-- Only for testing
					Gym_Reward_Testing:FireAllClients(false, 0)
				end
			end
		end
	end)

	for i = Event_Duration, 1, -1 do
		if EventActive and not RewardGiven then
			-- Update countdown 
			Gym_Reward_Update:Fire(i)
			-- Only for testing
			Gym_Reward_Testing:FireAllClients(true, i)
		end
		task.wait(1)
	end

	if EventActive and not RewardGiven then
		local msg = "⏳ Golden Punch ended. No one won the reward."
		Send_Message(msg, Event_Messages_Color)
		
		unhighlightObject()
		EventActive = false
		
		-- Only for testing
		Gym_Reward_Testing:FireAllClients(false, 0)
	end
end


local function LaunchGymEvent(timeframe, reward)
	-- Only for testing
	Gym_Reward_Testing:FireAllClients(true, 0)
	
	local msg = "🥊 Golden Punch incoming in less than " .. timeframe .. "min! Get ready!"
	Send_Message(msg, Event_Messages_Color)

	local Delay_Before_Start_In_Sec = math.random(0, timeframe * 60)	
	task.delay(Delay_Before_Start_In_Sec, function()
		Start_Gym_Event(reward)
	end)
end

Utils.SecureRemote(
	Gym_Reward_Testing,
	function(player)
		-- Optional: restrict to developers or group roles
		if not PlayerUtils.IsDeveloper(player) then
			return -- block non-authorized use
		end

		LaunchGymEvent(0.5, { type="Coins", amount=500, label="+500 💰" })
	end,
	{},
	{
		RateLimit = 1,
		MaxBurst = 5,
		PunishThreshold = 3
	}
)

-- 🔹 Daily Event Scheduler (UTC)
-- Launch event every day on a random time in the timeframe bginning at Event_Start_Hour
task.spawn(function()
	while true do
		local now = os.date("!*t") -- UTC (avoid DST issues)
		local Now_Minutes = now.hour * 60 + now.min	

		for _,RewardData in ipairs(Event_Data) do
			local Event_Start_Hour = RewardData.Event_Start_Hour
			local Target_Minutes = Event_Start_Hour * 60 
			if Now_Minutes == Target_Minutes then
				if Utils.GetServerType() == "Public" then
					LaunchGymEvent(RewardsMod.Gym_Rewards_TimeFrame, RewardData.reward)
				end
			end 
		end
		task.wait(60) -- Check Every Minute
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{CDEF00ED-FEA1-47AE-868D-28057024F0FD}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Gym_Reward_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5287C4B0CF6D40EFA4B4888919D12176">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Unique_Codes_Handle.lua
--
--  Description:
--      Handles one-time unique code redemption and rewards for players.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ServerScriptService:
--          * Codes_Unique 
--      - StarterGui:
--          * Codes_UI
--      - Roblox Services:
--          * DataStoreService (UsedUniqueCodes_FINAL DataStore)
--          * ServerStorage
--
--  Notes:
--      - Uses UpdateAsync to prevent race conditions
--      - Validates input code (string, trimmed, uppercase, max length)
--      - Wraps reward execution in pcall for safety
--
--======================================================================

-- Services
local ServerStorage = game:GetService("ServerStorage")
local DataStoreService = game:GetService("DataStoreService")
local UsedCodesStore = DataStoreService:GetDataStore("UsedUniqueCodes_FINAL")

-- Modules
local Codes = require(game.ServerScriptService.Modules.Codes_Unique)
local RewardModules = ServerStorage:WaitForChild("Rewards")

-- Track player cooldowns
local debounceList = {}
game.Players.PlayerAdded:Connect(function(plr)
	debounceList[plr.UserId] = 0
end)
game.Players.PlayerRemoving:Connect(function(plr)
	debounceList[plr.UserId] = nil
end)

-- Utility: sanitize and normalize input code
local function sanitizeCode(input)
	if type(input) ~= "string" then return nil end
	local s = input:match("^%s*(.-)%s*$") -- trim
	if #s == 0 or #s > 128 then return nil end
	return s:upper()
end

script.Function.OnInvoke = function(player: Player, code: any)
	-- Rate limiting per player (by UserId)
	local last = debounceList[player.UserId]
	if last and (tick() - last) <= 1 then
		debounceList[player.UserId] = tick()
		return "? Too many requests. Try again later!"
	end
	debounceList[player.UserId] = tick()

	-- Validate player data container
	local playerData = player:FindFirstChild("Player_Data")
	if not playerData then
		return "? Player data not ready. Try again later!"
	end

	local UniqueCodeUsed = playerData:FindFirstChild("UniqueCodeUsed")
	if UniqueCodeUsed and UniqueCodeUsed.Value then
		return "? Already used a code before!"
	end

	-- Sanitize and normalize code
	local safeCode = sanitizeCode(code)
	if not safeCode then
		return "? Invalid Code format!"
	end

	-- Find code in server-side list
	local codeFound, codeData
	for _, codeInfo in Codes do
		if type(codeInfo.Code) == "string" and codeInfo.Code:upper() == safeCode then
			codeFound = true
			codeData = codeInfo
			break
		end
	end
	if not codeFound then
		return "? Invalid Code! Please try another!"
	end

	-- Atomic check-and-set in DataStore
	local wonRedeem = false
	local ok, err = pcall(function()
		UsedCodesStore:UpdateAsync(safeCode, function(old)
			if old then
				return old -- already redeemed
			end
			wonRedeem = true
			return {
				userId = player.UserId,
				username = player.Name,
				time = os.time()
			}
		end)
	end)
	if not ok then
		warn("DataStore UpdateAsync failed:", err)
		return "? Error checking code. Try again later."
	end
	if not wonRedeem then
		return "? This code has already been redeemed!"
	end

	-- Load reward module safely
	local rewardName = codeData.Reward
	local rewardModule = RewardModules:FindFirstChild(rewardName)
	if not rewardModule or not rewardModule:IsA("ModuleScript") then
		warn("Reward module missing or invalid:", rewardName)
		return "? Reward not available. Contact support."
	end

	local successRequire, giveReward = pcall(require, rewardModule)
	if not successRequire or type(giveReward) ~= "function" then
		warn("Invalid reward module:", rewardName)
		return "? Reward handler error. Contact support."
	end

	local okReward, rewardErr = pcall(function()
		giveReward(player)
	end)
	if not okReward then
		warn("Reward execution failed:", rewardErr)
		return "? Failed to give reward. Contact support."
	end

	-- Mark player as having used a code
	if UniqueCodeUsed then
		UniqueCodeUsed.Value = true
	end

	return "✅ Successfully Redeemed Code!"
end]]></ProtectedString>
							<string name="ScriptGuid">{FD77A14C-5444-4C43-861A-FC6CCF966D42}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Unique_Codes_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1B82390D97AB4EE7A085BEE68B37324A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/UGC_Pack_Handle.lua
--
--  Description:
--      Server-side module managing UGC (User Generated Content) packs.
--      Handles ownership validation, accessory application, cleanup,
--      and MarketplaceService integration for bulk purchases.
--      Communicates with client remotes for preview and purchase flow.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-10-14 by Dark
--
--  Version: V2025-10
--
--  Dependencies:
--      - Roblox Services:
--          * ReplicatedStorage (Remotes, Data_Mods_F, OfferItems)
--          * MarketplaceService (ownership & purchases)
--          * InsertService (load assets dynamically)
--          * Players (join handling & attributes)
--          * Workspace (Main_World_F, Objects)
--
--      - Module Scripts:
--          * Data_Mods_F.UGC_Pack_Config
--          * Data_Mods_F.Offers_Config.OfferStorageData_Mod
--
--  Features:
--      - Player_Owns_Item_UGC_ServerCheck : verifies item ownership safely
--      - giveAccessory                     : loads and attaches accessories
--      - CleanUpPlayer                     : removes all accessories reliably
--      - applyPack                         : applies a full UGC pack to player
--      - SetUpBulkPurchase                 : prepares and triggers bulk buy
--      - Remote events for Apply/Show avatar flows
--      - Automatic player initialization and pack restoration
--
--  Notes:
--      - Uses InsertService for fallback asset loading — requires universe permission
--      - Pack definitions must exist in UGC_Pack_Config.UGCPacks
--      - Add rate limiting or validation via RemoteUtils if used in production
--
--======================================================================

-- Services
local RS  						= game:GetService("ReplicatedStorage")
local MPS 						= game:GetService("MarketplaceService")

-- Modules
local Data_Mods_F       		= RS:WaitForChild("Data_Mods_F")
local UGC_Pack_Config    		= require(Data_Mods_F:WaitForChild("UGC_Pack_Config"))
local Offers_SavedData    		= require(Data_Mods_F.Offers_Config.OfferStorageData_Mod)
local PlayerUtils 				= require(game.ReplicatedStorage.Modules.PlayerUtils)
local Utils 					= require(game.ReplicatedStorage.Modules.Utils)

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local ShowAvatarAndGetTriggerRE = Channels.UGC_Pack.ShowAvatarAndGetTriggerRE

-- Workspace references
local Main_World_F 				= workspace:WaitForChild("Main_World_F")
local Gameplay 					= Main_World_F:WaitForChild("Gameplay")
local OfferFolder 				= Gameplay:WaitForChild("Shop"):WaitForChild("Offers_Data")
local UGCPacks 					= RS.Models.UGC.OfferItems.UGCPacks

for _, model in ipairs(UGCPacks:GetChildren()) do
	if model:FindFirstChild("Humanoid") then
		local humanoid = model.Humanoid
		humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
	end
end

--local function giveAccessory(player, assetId)
--	local character = player.Character or player.CharacterAdded:Wait()
--	local humanoid = character:FindFirstChild("Humanoid")
--	if not humanoid then return end
--	local Child = UGCPacks:GetDescendants()	
--	local Item = nil
--	local model = nil

--	if Item == nil then  
--		model = InsertService:LoadAsset(assetId)
--		Item = model:GetChildren()[1]
--	end

--	if Item == nil then return end
--	if Item:IsA("Accessory") then
--		Item.Parent = character
--		humanoid:AddAccessory(Item)
--	end

--	if model then
--		model:Destroy()
--	end
--end

--local function CleanUpPlayer(player)
--	-- Ensure character exists
--	local char = player.Character or player.CharacterAdded:Wait()
--	local hum  = char:FindFirstChildOfClass("Humanoid")
--	if hum then
--		hum:RemoveAccessories()
--	else
--		for _, inst in ipairs(char:GetChildren()) do
--			if inst:IsA("Accessory") then
--				inst:Destroy()
--			end
--		end
--	end
--end

--local function applyPack(player, PackId)
--	CleanUpPlayer(player)
--	local pack = UGC_Pack_Config.UGCPacks[PackId]
--	for _, item in ipairs(pack.items) do
--		giveAccessory(player, item.id)
--	end
--end

local function SetUpBulkPurchase(plr,PackId)
	local Pack = UGC_Pack_Config.UGCPacks[PackId]

	local lineItems={}
	for _, item in ipairs(Pack.items) do

		table.insert(lineItems,{ Id = item.id, Type = Enum.MarketplaceProductType.AvatarAsset})
	end

	MPS:PromptBulkPurchase(plr, lineItems, {})
end

game.Players.PlayerAdded:Connect(function(plr)

	local Saved = Offers_SavedData.LoadOfferState("UGCActivePack",plr)
	local packId=nil
	local character = plr.Character or plr.CharacterAdded:Wait()
	if Saved~=nil then
		packId = Saved.ActivePack
	end
	local PackNames={}
	local Packs = UGC_Pack_Config.UGCPacks
	local MAX_PACKS = 4
	local sent = 0

	-- Walk Pack1, Pack2, ... until we run out OR send 4 packs
	for i = 1, math.huge do
		local packName = "Pack"..i
		local pack = Packs[packName]
		if not pack then break end

		-- collect only items the player doesn't own
		local itemsToShow = {}
		for _, item in ipairs(pack.items) do
			if not PlayerUtils.Player_Owns_Item_UGC_ServerCheck(plr, item.id) then
				itemsToShow[#itemsToShow+1] = {
					Id = item.id,
					Type = Enum.MarketplaceProductType.AvatarAsset,
					task.wait(0.25)
				}
			end
		end

		-- skip packs where the player owns everything
		if #itemsToShow > 0 then
			table.insert(PackNames,packName)
			sent += 1
			task.wait(1)
			if sent >= MAX_PACKS then break end
		end
	end
	ShowAvatarAndGetTriggerRE:FireClient(plr, PackNames)
end)

--ShowAvatarAndGetTriggerRE.OnServerEvent:Connect(function(player, PackId)
--	SetUpBulkPurchase(player,PackId)
--end)

Utils.SecureRemote(
	ShowAvatarAndGetTriggerRE,
	function(player, packId)

		-- Validate PackId (string "Pack1", "Pack2", etc.)
		if typeof(packId) ~= "string" then return end
		if not UGC_Pack_Config.UGCPacks[packId] then return end

		SetUpBulkPurchase(player, packId)
	end,
	{ "string" }, -- expected args
	{
		RateLimit = 1,
		MaxBurst = 5,
		PunishThreshold = 10
	}
)]]></ProtectedString>
							<string name="ScriptGuid">{65AF8049-6271-4C10-9C72-9F3833390276}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UGC_Pack_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5FCC2C555BD74946BB83C59EB8642575">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/OffersService.lua
--
--  Description:
--      Manages limited-time offers, UGC items, DevProducts, and Gamepasses.
--      Exposes RemoteEvents/RemoteFunctions to clients for requesting and 
--      redeeming offers, and triggers MarketplaceService purchases.
--
--  Author(s): Adnan
--
--  Last Modified: 2025-09-30 by Adnan
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Monetization_Mod
--          * Data_Mods_F/Offers_Config
--          * Remotes/Offers/... (RemoteEvents & RemoteFunctions)
--      - Roblox Services:
--          * MarketplaceService
--          * ReplicatedStorage
--      - Player Instances:
--          * Player.Player_Data.Coins (used for internal currency offers)
--
--  Notes:
--      - Dynamically creates missing RemoteEvents/RemoteFunctions at startup
--      - Validates offers against Offers_Config before purchase
--      - Handles DevProduct, UGC, and Gamepass purchases via MarketplaceService
--      - Supports internal currency ("Coins") for Gamepass-style offers
--      - Uses DataStoreService for persistent offer redemption tracking
--      -
--
--======================================================================
-- Services
local RS  = game:GetService("ReplicatedStorage")
local MPS = game:GetService("MarketplaceService")

-- Modules
local Data_Mods_F       = RS:WaitForChild("Data_Mods_F")
local Monetization_Mod  = require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Offers_Config    	= require(Data_Mods_F:WaitForChild("Offers_Config"))
local Utils 			= require(game.ReplicatedStorage.Modules.Utils)
local Offers_SavedData  = require(game.ReplicatedStorage.Data_Mods_F.Offers_Config.OfferStorageData_Mod)

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Grant_Gamepass_Perks		= Channels.Bindable_Events.Grant_Gamepass_Perks
local GetActiveOffers 			= Channels.Offers.GetActiveOffers
local RequestPurchase 			= Channels.Offers.RequestPurchase
local SendOfferToClient 		= Channels.Offers.SendOfferToClient
local ShowOfferSignalBind 		= Channels.Offers.ShowOfferSignalBind
local GetNewClothOffer			= Channels.Offers.GetNewClothOffer
local ClothItemIdSignal 		= Channels.Offers.ClothItemIdSignal
local SendUGCOfferToClient 		= Channels.Offers.SendUGCOfferToClient
local ShowMessage 				= Channels.Offers.ShowMessage
local Open_InsufficientFundsRE 	= Channels.Offers.Open_InsufficientFunds
local Shop_Item_Purchased = Channels.SC_Remote_Events.Shop_Item_Purchased

-- UI References
local Main_World_F = workspace:WaitForChild("Main_World_F")
local Gameplay = Main_World_F:WaitForChild("Gameplay")
local Offers_Data = Gameplay:WaitForChild("Shop"):WaitForChild("Offers_Data")
local podiums = Offers_Data.UGCPodiums:GetChildren()


local runningOffers={}
local allActiveOffers={}
local TIME_IN_DAYS_UGC = 4 * 24 * 60 * 60
local ITEM_PURCHASED = "✅ Item purchased you can equip it on your avatar!"

local function SendClientAUGCOffer(plr,PodiumName)
	local offer 
	if  next(allActiveOffers) == nil or #allActiveOffers<=0 then
		local best,allOffers = Offers_Config.GetUGCItemNew(plr)
		allActiveOffers = allOffers
	end
	local rand=math.random(1, #allActiveOffers)
	if PodiumName==podiums[1].Name then
		rand=1
	end
	offer = allActiveOffers[rand]
	table.remove(allActiveOffers,rand)

	if runningOffers[PodiumName].Key == offer.Key then
		SendClientAUGCOffer(plr,PodiumName)
		task.wait()
		return
	end
	offer.EndsAt=os.time()+TIME_IN_DAYS_UGC
	Offers_SavedData.SaveUGCOfferState("UGC_1_",PodiumName,plr,offer.RefName,offer.EndsAt)
	local prio, key, title = Offers_Config.parseName(offer.RefName)
	plr:SetAttribute("MyUGCID"..PodiumName,key)
	runningOffers[PodiumName]=offer
	SendUGCOfferToClient:FireClient(plr,offer,PodiumName)
end

local function PurchaseUGC(plr,Name)

	local key =plr:GetAttribute("MyUGCID"..Name)
	MPS:PromptPurchase(plr, key)

end

local function podiumInitialSetUp()

	table.sort(podiums, function(a, b)
		local aNum = tonumber(a.Name:match("^(%d+)"))
		local bNum = tonumber(b.Name:match("^(%d+)"))
		return (aNum or math.huge) < (bNum or math.huge)
	end)

	local function Create_Prompt_Part(podium)
		local P = Instance.new("Attachment", podium)
		P.Name = "OfferAttachment"
		local Prompt = Instance.new("ProximityPrompt", P)
		Prompt.Name = "Prompt"
		Prompt.ClickablePrompt = true
		Prompt.Enabled = true
		Prompt.HoldDuration = 0
		Prompt.MaxActivationDistance = 10
		Prompt.RequiresLineOfSight = false
		Prompt.ActionText = "Purchase"
		Prompt.ObjectText = "Item" .. "!"
		local iFolder = Instance.new("Folder", podium)
		iFolder.Name = "Item"
		return Prompt
	end
	for i, pn in ipairs(podiums) do
		local existingAttach = pn:FindFirstChildOfClass("Attachment")
		local existingPrompt = existingAttach and existingAttach:FindFirstChildOfClass("ProximityPrompt")
		if not existingPrompt then
			existingPrompt=Create_Prompt_Part(pn)
		end
		existingPrompt.Triggered:Connect(function(player)
			PurchaseUGC(player,pn.Name)
		end)
		existingPrompt.Enabled=false
	end

end
podiumInitialSetUp()

function GetNewClothOffer.OnServerInvoke(plr)
	local function IsSameDay(t1)
		local d1 = os.date("!*t", t1)
		local d2 = os.date("!*t", os.time())
		return d1.year == d2.year and d1.yday == d2.yday
	end
	task.wait(1)
	local countData=Offers_SavedData.LoadOfferState("ClothOfferCount",plr)
	local count = 0
	if countData then
		count = countData.PurchasedCount
		if not IsSameDay(countData["LastPurchasedDate"]) then
			count=0
		end
	end


	if count>=3 then
		return nil
	end
	local top = Offers_Config.GetAndCreateClothOffer(plr)
	if not top then return nil end
	return top
end

function GetActiveOffers.OnServerInvoke(plr)
	local top = Offers_Config.pickTopOffer(plr)
	if not top then return {} end
	return { top }
end

game.Players.PlayerAdded:Connect(function(plr)
	local now = os.time()
	local function removeValue(t, value)
		for i, v in ipairs(t) do
			if v == value then
				table.remove(t, i)
				return
			end
		end
	end

	local best,allOffers = Offers_Config.GetUGCItemNew(plr)
	allActiveOffers=allOffers
	local allSavedOffers = Offers_SavedData.LoadOfferState("UGC_1_",plr)
	local activeOffers = allSavedOffers and allSavedOffers.ActiveOffer or {}
	if activeOffers~=nil and next(activeOffers) ~= nil then
		for i, pn in ipairs(podiums) do

			local offer=nil
			local rawoffer = activeOffers[pn.Name]
			if rawoffer then
				offer = Offers_Config.GenerateUGCSavedOffer(rawoffer.CurrentKey)
				if (rawoffer.EndsAt-now)<=0 then
					offer.EndsAt = now+120
				else
					offer.EndsAt = rawoffer.EndsAt
				end
			else
				removeValue(allActiveOffers,best)
				if pn.Name==podiums[1].Name then
					offer = best
				else
					local rand = math.random(1, #allActiveOffers)
					offer=allActiveOffers[rand]
					table.remove(allActiveOffers,rand)
				end
				offer.EndsAt=now+TIME_IN_DAYS_UGC

				Offers_SavedData.SaveUGCOfferState("UGC_1_",podiums[i].Name,plr,offer.RefName,offer.EndsAt)
			end
			local prio, key, title = Offers_Config.parseName(offer.RefName)
			plr:SetAttribute("MyUGCID"..podiums[i].Name,key)
			runningOffers[podiums[i].Name]=offer
			SendUGCOfferToClient:FireClient(plr,offer,podiums[i].Name)
		end
	else
		for i, pn in ipairs(podiums) do
			local PodiumName = pn.Name
			local rand=math.random(1, #allActiveOffers)
			if PodiumName==podiums[1].Name then
				rand=1
			end
			local offer=allActiveOffers[rand]
			table.remove(allActiveOffers,rand)
			offer.EndsAt=os.time()+TIME_IN_DAYS_UGC
			Offers_SavedData.SaveUGCOfferState("UGC_1_",PodiumName,plr,offer.RefName,offer.EndsAt)
			local prio, key, title = Offers_Config.parseName(offer.RefName)
			plr:SetAttribute("MyUGCID"..PodiumName,key)
			runningOffers[PodiumName]=offer
			SendUGCOfferToClient:FireClient(plr,offer,PodiumName)
		end
	end
end)

Utils.SecureRemote(
	SendUGCOfferToClient,
	function(player, podiumName)
		if typeof(podiumName) ~= "string" then return end

		SendClientAUGCOffer(player, podiumName)
	end,
	{ "string" },
	{
		RateLimit = 1,
		MaxBurst = 15,
		PunishThreshold = 15
	}
)

ShowOfferSignalBind.Event:Connect(function(plr, Kind,ItemKey)

	local top = Offers_Config.getOfferByKey(plr,Kind,ItemKey)
	if not top and (Kind=="Gloves" or Kind=="Shorts") then
		local offer = Offers_SavedData.LoadOfferState("ClothOffer_",plr)

		if offer then
			local data = string.split(offer.ActiveOffer.CurrentKey,"_")
				Offers_Config.GetAndCreateClothOfferOnKey(plr,data[1],data[2],offer.ActiveOffer.EndsAt)
			task.wait(1)
		end
			top = Offers_Config.getOfferByKey(plr,Kind,ItemKey)
	end
	
	if not top then return {} end
	SendOfferToClient:FireClient(plr,top )

end)

Utils.SecureRemote(
	RequestPurchase,
	function(player, productKind, productKey)

		if typeof(productKind) ~= "string" then return end
		if typeof(productKey) ~= "string" then return end

		local top = Offers_Config.getOfferByKey(player, productKind, productKey)
		if not top or top.ProductKey ~= productKey then return end

		if top.EndsAt and top.EndsAt > 0 and os.time() > top.EndsAt then return end

		if top.Kind == "DevProduct" then
			local dev = Monetization_Mod.Get_All_Dev_Product_Data()[productKey]
			if dev and dev.ID then MPS:PromptProductPurchase(player, dev.ID) end
			return
		end

		if top.Kind == "Gamepass" then
			local PD    = player:FindFirstChild("Player_Data")
			local coins = PD and PD:FindFirstChild("Coins")
			local price = tonumber(top.NewPrice) or 0

			if coins and coins.Value >= price then
				coins.Value = coins.Value - price

				-- Get the real GP_ID from Monetization_Mod
				local gp = Monetization_Mod.Get_All_Gamepass_Data()[productKey]
				if gp and gp.ID then
					-- Grant perks using the bindable event
					Grant_Gamepass_Perks:Fire(player, gp.ID)

					ShowMessage:FireClient(player, gp.Name .. " unlocked with coins!", true)
				else
					ShowMessage:FireClient(player, "Something went wrong. GP not found.", false)
					coins.Value = coins.Value + price -- refund
				end
			else
				ShowMessage:FireClient(player, "Not enough coins!", false)
			end
			return
		end

		if top.Kind == "Gloves" then
			local key = top.Ownership and top.Ownership.Key
			if not key then return end
			local PD = player:FindFirstChild("Player_Data")
			local Gems = PD and PD:FindFirstChild("Gems")
			if Gems and tonumber(Gems.Value) >= top.NewPrice then
				Gems.Value = Gems.Value - top.NewPrice
				local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
				ClothItemIdSignal:FireClient(player)
				Clothing_Mod.Give_Player_Gloves(player, key)
				ShowMessage:FireClient(player, ITEM_PURCHASED, true)
				Offers_SavedData.SaveOfferPurchaseCount("ClothOfferCount",player)
			else
				Open_InsufficientFundsRE:FireClient(player, false, top.NewPrice - Gems.Value)
			end
			return
		end

		-- Handle Shorts purchase with coins
		if top.Kind == "Shorts" then
			local key = top.Ownership and top.Ownership.Key
			if not key then return end
			local PD = player:FindFirstChild("Player_Data")
			local Gems = PD and PD:FindFirstChild("Gems")
			if Gems and tonumber(Gems.Value) >= top.NewPrice then
				Gems.Value = Gems.Value - top.NewPrice
				local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
				Clothing_Mod.Give_Player_Shorts(player, key)

				ClothItemIdSignal:FireClient(player)
				ShowMessage:FireClient(player, ITEM_PURCHASED, true)
				Offers_SavedData.SaveOfferPurchaseCount("ClothOfferCount", player)
			else
				Open_InsufficientFundsRE:FireClient(player, false, top.NewPrice - Gems.Value)
			end
			return
		end

	end,
	{ "string", "string" },
	{
		RateLimit = 2,
		MaxBurst = 2,
		PunishThreshold = 5
	}
)

MPS.PromptPurchaseFinished:Connect(function(plr, assetId, isPurchased)
	if not isPurchased then return end
	for podiumId, offer in pairs(runningOffers) do
		if tonumber(offer.Key) == tonumber(assetId) then

			SendUGCOfferToClient:FireClient(plr,nil,podiumId)
			task.spawn(function()
				local best,allOffers = Offers_Config.GetUGCItemNew(plr)
				allActiveOffers = allOffers
				SendClientAUGCOffer(plr,podiumId)
			end)

			ShowMessage:FireClient(plr, ITEM_PURCHASED, true)
			return
		end
	end
	Shop_Item_Purchased:FireClient(plr,"UGC_item",tonumber(assetId))
end)]]></ProtectedString>
							<string name="ScriptGuid">{7AB157CF-0F73-4DF8-909A-2508B8C5EF9C}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">OffersService.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD55AEBCD5FE9464CAF2174A57DF90A52">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Monetization/Session_Reward_Handle.lua
--
--  Description:
--      Manages session-based rewards tied to playtime. 
-- 		Tracks elapsed time, enforces daily resets, and validates reward claims via thresholds.
--
--  Author(s): Darkzeb
--
--  Last Modified: 2025-11-03 by Darkzeb
--
--  Version: V2025-11
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Reward_Mod
--          * Channels_F/Server_Client_F/Events/Session_Reward_Progress
--          * Channels_F/Server_Client_F/Events/Session_Reward_Claim_Result
--          * Channels_F/Client_Server_F/RF/Claim_Session_Reward
--          * Channels_F/Client_Server_F/RF/Get_Session_Progress
--      - Roblox Services:
--          * Players
--          * ReplicatedStorage
--      - Player Instances:
--          * Player.Player_Data.SR_Day
--          * Player.Player_Data.SR_Count
--          * Player.Player_Data.SR_ClaimedTimes
--
--  Notes:
--      - Resets reward counters daily (UTC-based)
--      - Prevents duplicate claims with per-player locks
--      - Sends live progress updates via RemoteEvents
--      - Thresholds and claim logic provided by Reward_Mod
--
--======================================================================

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Modules
local DataMods = ReplicatedStorage:WaitForChild("Data_Mods_F")
local RewardsMod = require(DataMods:WaitForChild("Rewards_Mod"))
local Utils = require(game.ReplicatedStorage.Modules.Utils)
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels = require(game.ReplicatedStorage.Modules.Channels)

-- Use centralized references from Channels.Remotes
local Session_Reward_Progress_E    	= Channels.SC_Remote_Events.Session_Reward_Progress
local Session_Reward_Claim_Result_E = Channels.SC_Remote_Events.Session_Reward_Claim_Result
local Claim_Session_Reward_RF       = Channels.CS_Remote_Functions.Claim_Session_Reward
local Get_Session_Progress_RF  		= Channels.CS_Remote_Functions.Get_Session_Progress


-- Ensure flat values under Player_Data
local function ensureSR(pd)
	local day  = pd:FindFirstChild("SR_Day")  or Instance.new("StringValue")
	day.Name = "SR_Day"; if not day.Parent then day.Parent = pd end

	local cnt  = pd:FindFirstChild("SR_Count") or Instance.new("IntValue")
	cnt.Name = "SR_Count"; if not cnt.Parent then cnt.Parent = pd end

	local clm  = pd:FindFirstChild("SR_ClaimedTimes") or Instance.new("StringValue")
	clm.Name = "SR_ClaimedTimes"; if not clm.Parent then clm.Parent = pd end

	if day.Value ~= Utils.todayUTC() then
		day.Value = Utils.todayUTC()
		cnt.Value = 0
		clm.Value = ""
	end
	return day, cnt, clm
end

local function parseClaimed(csv)
	local map = {}
	if csv and csv ~= "" then
		for _, s in ipairs(string.split(csv, ",")) do
			local n = tonumber(s)
			if n then map[n] = true end
		end
	end
	return map
end

local function appendClaimed(claimedSV, tSec)
	local cur = claimedSV.Value
	if cur == "" then claimedSV.Value = tostring(tSec)
	else claimedSV.Value = cur .. "," .. tostring(tSec) end
end

-- Anti double-click per player
local ClaimLock = {}
-- Track join times for authoritative elapsed computation
local JoinTimes = {}

local function sendProgress(p)
	local pd = PlayerUtils.GetPlayerData(p)
	if pd then
		local _, cnt, clm = ensureSR(pd)
		local joinTime = JoinTimes[p.UserId] or os.time()
		local elapsed = os.time() - joinTime
		Session_Reward_Progress_E:FireClient(p, {
			thresholds   = RewardsMod.Session_Rewards_Data, -- ?? merge
			elapsed      = elapsed,
			count        = cnt.Value,
			maxClaims    = RewardsMod.Get_Max_Session_Claims(), -- ?? merge
			claimedTimes = clm.Value,
		})
	end
end

Players.PlayerAdded:Connect(function(p)
	JoinTimes[p.UserId] = os.time()
	sendProgress(p)
end)

Players.PlayerRemoving:Connect(function(p)
	ClaimLock[p] = nil
	JoinTimes[p.UserId] = nil
end)


-- Secure RemoteFunction: Get_Session_Progress_RF
Utils.SecureFunction(
	Get_Session_Progress_RF,
	function(player)
		local pd = PlayerUtils.GetPlayerData(player)
		if not pd then return nil end
		local _, cnt, clm = ensureSR(pd)
		local joinTime = JoinTimes[player.UserId] or os.time()
		local elapsed = os.time() - joinTime
		return {
			thresholds   = RewardsMod.Session_Rewards_Data,
			elapsed      = elapsed,
			count        = cnt.Value,
			maxClaims    = RewardsMod.Get_Max_Session_Claims(),
			claimedTimes = clm.Value,
		}
	end,
	0, -- expected number of args
	{ 
		RateLimit = 2
	}
)


-- Secure RemoteFunction: Claim_Session_Reward_RF
Utils.SecureFunction(
	Claim_Session_Reward_RF,
	function(player, thresholdTime)
		if ClaimLock[player] then
			return { ok = false, reason = "busy" }
		end
		ClaimLock[player] = true

		local ok, res = pcall(function()
			local pd = PlayerUtils.GetPlayerData(player)
			if not pd then return { ok=false, reason="no_pd" } end

			local _, cnt, clm = ensureSR(pd)
			local claimed = parseClaimed(clm.Value)

			local reward = nil
			for _, entry in ipairs(RewardsMod.Session_Rewards_Data) do
				if entry.t == thresholdTime then
					reward = entry.reward
					break
				end
			end
			if not reward then return { ok=false, reason="invalid_threshold" } end

			local joinTime = JoinTimes[player.UserId] or os.time()
			local elapsed = os.time() - joinTime
			if elapsed < thresholdTime then
				return { ok=false, reason="too_early" }
			end
			if claimed[thresholdTime] then
				return { ok=false, reason="already_claimed" }
			end

			local PD = player:FindFirstChild("Player_Data")
			if PD and reward then
				local target = PD:FindFirstChild(reward.type)
				if target then
					target.Value += reward.amount
				else
					warn("[SessionRewards] No " .. reward.type .. " value for", player.Name)
				end
			end

			appendClaimed(clm, thresholdTime)
			cnt.Value += 1
			Session_Reward_Claim_Result_E:FireClient(player, { ok=true, reward=reward })
			return { ok=true, reward=reward }
		end)

		ClaimLock[player] = nil
		return ok and res or { ok=false, reason="error" }
	end,
	{ "number" }, -- expected argument types
	{ 
		RateLimit = 2
	}
)]]></ProtectedString>
							<string name="ScriptGuid">{410ADAB4-EB54-43A0-B425-9E9822EEAA68}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Session_Reward_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX2C73CE9D2D434581B2CE7F84E32D00F4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">System</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXEC6C3806BA344259A5D5FBD92457ED4D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/System/Server_List_Handle.server.lua
--
--  Description:
--      Collects, stores, and shares server statistics across instances.
--      Handles server list compilation and cross-server teleportation.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ServerScriptService/Core:
--          * MS_Module (MemoryStore integration)
--      - ReplicatedStorage:
--          * Channels_F/Bindable_F/Events/Update_Server_Data
--          * Channels_F/Server_Client_F/Events/Update_All_Server_Data
--          * Channels_F/Client_Server_F/RF/Get_All_Server_Data
--      - Roblox Services:
--          * TeleportService
--          * RunService
--      - Player Instances:
--          * Player.Player_Data.Elo
--          * Player.Player_Data.Total Wins
--          * Player.Player_Data.Ranked Wins
--
--  Notes:
--      - Pushes per-server stats into MemoryStore (via MS_Module)
--      - Broadcasts compiled multi-server data to all clients
--      - Provides RemoteFunction for client-side server list requests
--      - Allows teleportation to a specific server ID
--
--======================================================================

-- Services
local Teleport_Service = game:GetService("TeleportService")
local RunService = game:GetService("RunService")

-- Modules
local MS_Mod = require(script:WaitForChild("MS_Module"))
local Utils = require(game.ReplicatedStorage.Modules.Utils)
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels = require(game.ReplicatedStorage.Modules.Channels)

local Update_Server_Data 			= Channels.Bindable_Events.Update_Server_Data
local Get_All_Server_Data_RF		= Channels.CS_Remote_Functions.Get_All_Server_Data
local Update_All_Server_Data		= Channels.SC_Remote_Events.Update_All_Server_Data
local Teleport_To_Server			= Channels.CS_Remote_Functions.Teleport_To_Server


local Get_Player_Val = PlayerUtils.GetPlayerVal

-- Compile les infos du serveur local et les envoie à la MemoryStore
local function Compile_Main_Server_Data()
	local Server_Size_Data = {}
	local Highest_Elo = -1
	local Avg_Elo, Avg_Wins, Avg_Ranked_Wins = 0, 0, 0
	local All_P = game.Players:GetPlayers()

	local function Process_Plr(Plr)
		local P_Elo = Get_Player_Val(Plr, "Elo") 
		local P_Wins = Get_Player_Val(Plr, "Total Wins") 
		local P_Ranked_Wins = Get_Player_Val(Plr, "Ranked Wins") 

		if P_Elo ~= nil then
			P_Elo = P_Elo.Value
		else	
			P_Elo = 0
		end
		
		if P_Wins ~= nil then
			P_Wins = P_Wins.Value
		else	
			P_Wins = 0
		end
		
		if P_Ranked_Wins ~= nil then
			P_Ranked_Wins = P_Ranked_Wins.Value
		else	
			P_Ranked_Wins = 0
		end
		
		Avg_Elo += P_Elo 
		Avg_Wins += P_Wins
		Avg_Ranked_Wins += P_Ranked_Wins

		if P_Elo >= Highest_Elo then
			Highest_Elo = P_Elo
		end

		table.insert(Server_Size_Data, Plr.UserId)
	end

	for _, P in ipairs(All_P) do
		Process_Plr(P)
	end

	local count = #Server_Size_Data
	if count == 0 then count = 1 end -- éviter division par 0

	local S_Data = {
		['Highest Elo'] = Highest_Elo,
		['Average Elo'] = math.ceil(Avg_Elo / count),
		['Average Wins'] = math.ceil(Avg_Wins / count),
		['Average Ranked Wins'] = math.ceil(Avg_Ranked_Wins / count),
		['Server Size'] = Server_Size_Data
	}

	local Server_ID = Utils.getServerId()
	MS_Mod.Add_Data(Server_ID, S_Data)
end
task.spawn(Compile_Main_Server_Data)

-- Mise à jour forcée par événement
Update_Server_Data.Event:Connect(function()
	if not RunService:IsStudio() then		
		Compile_Main_Server_Data()
	end
end)

-- Récupération et broadcast des données de tous les serveurs
local function Get_All_Server_Data()
	local Raw_Data = MS_Mod.Get_All_World_Data()
	local Compiled_Data = {}

	for S_ID, Data in pairs(Raw_Data) do
		local size = Data['Server Size'] and #Data['Server Size'] or 0
		if size > 0 then -- ignore empty servers
			local D = {
				['Highest Elo'] = Data['Highest Elo'] or 0,
				['Average Elo'] = Data['Average Elo'] or 0,
				['Average Wins'] = Data['Average Wins'] or 0,
				['Average Ranked Wins'] = Data['Average Ranked Wins'] or 0,
				['Server Size'] = Data['Server Size'] or {},
				['Server ID'] = S_ID
			}
			table.insert(Compiled_Data, D)
		else
			--print("[Server_List_Handle] Ignored empty server", S_ID)
		end
	end

	--print("[Server_List_Handle] Get_All_Server_Data ->", #Compiled_Data, "servers")
	Update_All_Server_Data:FireAllClients(Compiled_Data)
	return Compiled_Data
end

local All_Server_Data = Get_All_Server_Data()

Get_All_Server_Data_RF.OnServerInvoke = function()
	--print("[Server_List_Handle] Client requested server list, returning", #All_Server_Data)
	return All_Server_Data
end

-- Téléportation inter-serveurs
local function Teleport_Player_To_Server(Plr, S_ID)
	local Place_ID = 117620200631077
	local TP_Data = Instance.new("TeleportOptions")
	TP_Data.ReservedServerAccessCode = ""
	TP_Data.ServerInstanceId = tostring(S_ID)
	TP_Data.ShouldReserveServer = false

	local function Async()
		local success, errormessage = pcall(function()
			Teleport_Service:TeleportAsync(Place_ID, {Plr}, TP_Data)
		end)
		if not success then
			warn("[Server_List_Handle] Teleport failed:", errormessage)
		end
		return success
	end

	for i = 1, 3 do 
		if Async() then
			return true
		end
	end
	return false
end

Teleport_To_Server.OnServerInvoke = function(Plr, S_ID)
	return Teleport_Player_To_Server(Plr, S_ID)
end

-- Boucle d’auto-update
local function Auto_Update_Servers_Data()
	while task.wait(60) do
		-- Forcer une recompilation locale
		Compile_Main_Server_Data()
		-- Mettre à jour la variable globale + notifier clients
		All_Server_Data = Get_All_Server_Data()
	end
end
task.spawn(Auto_Update_Servers_Data)
]]></ProtectedString>
							<string name="ScriptGuid">{69C6783E-CDF9-4ED8-AB04-894561FA1CF3}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Server_List_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXC5E5A01DDA144EA8BF904030AEBA0D79">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Server_List_Handle</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX0FD97438668742CC854B29C20D1D0C25">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Server_List_Handle/MS_Module.lua
--
--  Description:
--      MemoryStore abstraction for cross-server communication. Provides
--      functions to add, retrieve, remove, and list server data entries
--      using a SortedMap with JSON encoding.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * MemoryStoreService (SortedMap "Servers_Data")
--          * HttpService (JSONEncode/Decode)
--          * RunService (Studio detection & fallback key generation)
--
--  Notes:
--      - Default TTL for entries: 1800s (30 minutes), clamped to [5s, 12h]
--      - Safe key generator ensures valid non-empty keys
--      - All operations retried up to 3 times on failure
--      - Get_All_World_Data returns up to 200 entries decoded from JSON
--
--
local funcs = {}
local MSS = game:GetService("MemoryStoreService")
local HttpService = game:GetService("HttpService")

-- Main MemoryStore SortedMap used to share data between servers
local Servers_Data = MSS:GetSortedMap("Servers_Data")

-- Default data duration (time-to-live) in seconds (30 minutes)
local Data_Duration = 1800

-- === Helpers ===

-- Ensure TTL stays in Roblox allowed range (5s - 12h)
local function clampTTL(ttl)
	ttl = tonumber(ttl) or Data_Duration
	if ttl < 5 then ttl = 5 end
	if ttl > 43200 then ttl = 43200 end
	return ttl
end

-- Ensure key is safe (non-empty string).
-- Always generate a fallback if empty.
local function safeKey(key)
	local k = (key ~= nil and tostring(key) or "")
	if k == "" then
		-- fallback key, works both in Studio and production
		k = ("server_%s_%d"):format(game.PlaceId, os.time())
	end
	return k
end

-- Generic retry wrapper for MemoryStore operations
-- action: function(attemptIndex) -> result or nil
local function retry(attempts, action)
	for i = 1, attempts do
		local success, result = pcall(action, i)
		if success and result ~= nil then
			return result
		end
		if not success then
			warn("[Servers_Data] attempt #" .. i .. " failed: " .. tostring(result))
		end
	end
	return nil
end

-- === Core API ===

-- Store a JSON-encoded data table under a given key
function funcs.Add_Data(Key, Data)
	local k = safeKey(Key)
	if not k then
		warn("[Servers_Data] Add_Data ignored: empty key")
		return false
	end

	return retry(3, function()
		Servers_Data:SetAsync(k, HttpService:JSONEncode(Data), clampTTL(Data_Duration))
		return true
	end)
end

-- Retrieve and decode JSON data for a given key
function funcs.Get_Data(Key)
	local k = safeKey(Key)
	if not k then
		warn("[Servers_Data] Get_Data ignored: empty key")
		return nil
	end

	return retry(3, function()
		local data = Servers_Data:GetAsync(k)
		return data and HttpService:JSONDecode(data) or nil
	end)
end

-- Remove a key from the store
function funcs.Remove_Data(Key)
	local k = safeKey(Key)
	if not k then
		warn("[Servers_Data] Remove_Data ignored: empty key")
		return false
	end

	return retry(3, function()
		Servers_Data:RemoveAsync(k)
		return true
	end)
end

-- Retrieve all available entries (up to 200) as a dictionary
-- { key -> decoded JSON value }
function funcs.Get_All_World_Data()
	return retry(3, function()
		local data = Servers_Data:GetRangeAsync(Enum.SortDirection.Descending, 200)
		if not data then return nil end

		local ret = {}
		for _, entry in ipairs(data) do
			ret[entry.key] = HttpService:JSONDecode(entry.value)
		end

		--print("[Servers_Data] Get_All_World_Data ->", #data, "entries")
		return ret
	end) or {}
end

return funcs
]]></ProtectedString>
								<string name="ScriptGuid">{B6FC77A9-2B0E-4123-AFEF-998AA0CB8A52}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">MS_Module.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXA30D5F5D01BF476B9E44558E1BD1BA1E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/System/Bloxlink.lua
--
--  Description:
--      Integrates with the Bloxlink API to verify if a player is linked 
--      to a Discord account in the target guild. Rewards verified players 
--      with exclusive items and sends confirmation messages.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-10-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * Data_Mods_F/Clothing_Mod
--          * Channels_F/Server_Client_F/Events/Display_Data
--      - Roblox Services:
--          * HttpService (HTTP requests, GetSecret, JSONDecode)
--          * Players
--          * RunService
--      - External:
--          * Bloxlink Public API (https://api.blox.link/v4/public/guilds/...)
--
--  Notes:
--      - Requires secret key "BloxLinkAPI" (stored securely via HttpService:GetSecret)
--      - Periodically checks membership and stops once reward is given
--      - Grants "Mystic Gloves" to verified community members
--      - Cleans up background tasks on PlayerRemoving
--
--======================================================================

-- Services
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Modules
local Clothing_Mod = require(game.ReplicatedStorage.Data_Mods_F.Clothing_Mod)

-- Events
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Msg_E = Channels.SC_Remote_Events.Display_Data

local AuthKey = ""
if not RunService:IsStudio() then
	AuthKey = HttpService:GetSecret("BloxLinkAPI") or ""

	if AuthKey == "" then
		warn("[Bloxlink] ⚠️ Missing or empty API key. Verification will be skipped.")
	end
end

-- // Local cache to prevent redundant API calls
local verifiedCache = {}

--======================================================================
--  Function: isInServer
--  Description:
--      Checks via Bloxlink API if a Roblox user is linked to a Discord
--      account in the target guild.
--======================================================================
local function isInServer(userId)
	if verifiedCache[userId] then
		return true
	end
	if AuthKey == "" then
		return false
	end

	local url = "https://api.blox.link/v4/public/guilds/1371423884921933837/roblox-to-discord/" .. userId
	local headers = { ["Authorization"] = AuthKey }

	local success, result = pcall(function()
		return HttpService:GetAsync(url, false, headers)
	end)

	if not success then
		warn(("[Bloxlink] HTTP request failed for user %d: %s"):format(userId, tostring(result)))
		return false
	end

	local ok, data = pcall(function()
		return HttpService:JSONDecode(result)
	end)

	if not ok then
		warn(("[Bloxlink] JSON decode failed for user %d: %s"):format(userId, tostring(data)))
		return false
	end

	if data and data.discordIDs then
		verifiedCache[userId] = true
		return true
	end

	return false
end

--======================================================================
--  Function: awardDiscordReward
--  Description:
--      Grants exclusive Mystic Gloves to verified players who haven't
--      received them yet.
--======================================================================
local function awardDiscordReward(player: Player)
	local plrData = player:FindFirstChild("Player_Data")
	if not plrData then return false end

	local discordReward = plrData:FindFirstChild("DiscordReward")
	if not discordReward or discordReward.Value then
		return false
	end

	if Clothing_Mod.Player_Owns_Gloves_Key(player, "K") then
		return false
	end

	Clothing_Mod.Give_Player_Gloves(player, "K")
	Msg_E:FireClient(player, "✨ You are a member of our community. Here is a pair of Mystic Gloves!", Color3.fromRGB(255, 170, 0))
	discordReward.Value = true
	return true
end

--======================================================================
--  Player Management
--======================================================================
local playertasks = {}

Players.PlayerAdded:Connect(function(player)
	-- Wait for Player_Data to exist (max 30s)
	local plrData = player:WaitForChild("Player_Data", 30)
	if not plrData or not player:IsDescendantOf(Players) then
		return
	end

	-- Background verification task
	playertasks[player] = task.spawn(function()
		while player:IsDescendantOf(Players) do
			local joined = isInServer(player.UserId)
			if joined and awardDiscordReward(player) then
				break
			end
			task.wait(30) -- ✅ safer interval (prevents API rate-limit)
		end
	end)
end)

Players.PlayerRemoving:Connect(function(plr)
	local taskRef = playertasks[plr]
	if taskRef then
		task.cancel(taskRef)
		playertasks[plr] = nil
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{87BA2602-561E-4F02-8B1A-D97990C14484}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Bloxlink.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXEBE00714F1A0447DBE11AE8DA55B46B7">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/System/Video_Player.lua
--
--  Description:
--      Automatically sets up and plays looping videos on tagged SurfaceGuis.
--      Injects a VideoFrame inside a Frame child and assigns the video asset.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Roblox Services:
--          * CollectionService (tagged instances with "VideoFrame")
--      - Instances:
--          * SurfaceGui (with attribute "Video")
--          * Frame (child of SurfaceGui)
--          * VideoFrame (created dynamically)
--
--  Notes:
--      - Uses CollectionService:GetInstanceAddedSignal to handle new tags
--      - Iterates existing tagged objects at startup
--      - Waits for VideoFrame to be loaded before calling :Play()
--      - Loops videos with muted audio (Volume = 0)
--
--======================================================================

-- Services
local CollectionService = game:GetService("CollectionService")

local function setupVideo(surfaceGui: SurfaceGui)
	local frame = surfaceGui:FindFirstChildWhichIsA("Frame")
	if not frame then
		warn("[Video_Player] No Frame found in", surfaceGui:GetFullName())
		return
	end

	local videoId = tonumber(surfaceGui:GetAttribute("Video"))
	if not videoId then
		warn("[Video_Player] Invalid or missing Video attribute in", surfaceGui:GetFullName())
		return
	end

	local videoPlayer = Instance.new("VideoFrame")
	videoPlayer.Name = "VideoPlayer"
	videoPlayer.Size = UDim2.new(1, 0, 1, 0)
	videoPlayer.Looped = true
	videoPlayer.Volume = 0
	videoPlayer.Video = "rbxassetid://" .. videoId
	videoPlayer.Parent = frame

	if not videoPlayer.IsLoaded then
		videoPlayer.Loaded:Wait()
	end

	videoPlayer:Play()

--print("[Video_Player] Playing video", videoId, "on", surfaceGui:GetFullName())
end

-- Helper pour protéger les appels
local function safeSetup(obj)
	local success, err = pcall(setupVideo, obj)
	if not success then
		warn("[Video_Player] Failed to setup video for", obj:GetFullName(), ":", err)
	end
end

-- Connect new tagged instances
CollectionService:GetInstanceAddedSignal("VideoFrame"):Connect(safeSetup)

-- Initialize already tagged instances
for _, obj in CollectionService:GetTagged("VideoFrame") do
	task.spawn(safeSetup, obj)
end
]]></ProtectedString>
							<string name="ScriptGuid">{0A04D9FB-0DB5-4E9B-9EAE-12AA9ED55061}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Video_Player.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX09D80B04E1A64402AA69ECEA4DC1C1FE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/System/Settings.lua
--
--  Description:
--      Server-side handler for saving and updating player settings.
--      Listens for client events, validates incoming data, and writes to
--      the player's settings ValueObjects (BoolValues only).
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-02-10 by Darkzeb
--
--  Version: V2025-02
--
--  Dependencies:
--      - Modules:
--          * PlayerUtils      (GetPlayerVal accessor)
--          * Channels         (Save_Settings remote event)
--          * Data_Mods_F      (general data modules root)
--
--  Used By:
--      - Client UI settings panels
--      - Any system that modifies player preferences
--
--  Notes:
--      - Only boolean settings are supported by design.
--      - Each incoming key is mapped to a ValueObject in player data.
--      - Secure: ignores invalid keys or incorrect data types.
--      - Extendable if numeric or string settings are needed later.
--
--======================================================================


-- Modules
local PlayerUtils 		= require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Events
local Channels 		 	= require(game.ReplicatedStorage.Modules.Channels)
local Save_Settings	 	= Channels.CS_Remote_Events.Save_Settings

local Get_Player_Val 	= PlayerUtils.GetPlayerVal

-----	Save & Update Settings Handle	-----
Save_Settings.OnServerEvent:Connect(function(Plr, New_Data)
	if(Plr ~= nil)then
		for Data_Key, Data_Val in next, New_Data do
			local Val = Get_Player_Val(Plr, Data_Key)
			if(Val ~= nil and Val:IsA("BoolValue") and typeof(Data_Val) == "boolean")then
				Val.Value = Data_Val
			end
		end
	end
end)]]></ProtectedString>
							<string name="ScriptGuid">{D44C5C2D-E8A9-41F8-BC24-53B6A5C5BC67}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Settings.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX4F71030FC81F4565B266A2BB4143625F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Datastore</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX3CCF76A9760F45ED87D1588BAB922304">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Datastore/DS_Module.lua
--
--  Description:
--      Utility module for DataStore operations. Provides abstraction for
--      leaderboards, player data loading/saving, and backup management.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-12-09 by Darkzeb
--
--  Version: V2025-12
--
--  Dependencies:
--      - Roblox Services:
--          * DataStoreService
--          * HttpService (JSONDecode/Encode)
--
--  Notes:
--      - Implements OrderedDataStore helpers for leaderboards
--      - Wraps all calls in pcall with retry (3 attempts)
--      - Provides backup loading if main DataStore fails
--      - Data values stored in JSON format
--
--======================================================================

local DataStoreService 		= game:GetService("DataStoreService")
local WebService 			= game:GetService("HttpService")
local funcs 				= {}


-- NEW MIGRATION CONSTANTS
local NEW_DATASTORE_NAME 	= "PLAYER_DATASTORE_LIVE"
local MIGRATION_LOG 		= "PLAYER_MIGRATION_LOG"
local OLD_SUFFIX 			= "_Game_Data"

local function Log_Migration(userId)
	local ds = DataStoreService:GetDataStore(MIGRATION_LOG)
	pcall(function()
		ds:SetAsync(userId, os.time())
	end)
end

--Set up for Leaderboards pertaining to Wins and Donations!
function funcs.Save_Leaderboard(Key, DataType, Value)
	local function Attempt_To_Save()
		local success, errormessage = pcall(function()
			local ODS = DataStoreService:GetOrderedDataStore(DataType)
			ODS:SetAsync(Key, Value)
		end)

		if(success)then
			return true
		else
			warn(string.format(
				"Saving Error -> Key: %s | Data Type: %s | Error Msg: %s",
				tostring(Key),
				tostring(DataType),
				tostring(errormessage)
				))

			return false
		end
	end

	for i = 1, 3 do
		local Save = Attempt_To_Save()
		if(Save)then
			i = 3
			break
		end
	end
end

function funcs.Load_Leaderboard(DataType, PageSize)
	local function Get_Data()
		local Data = nil
		local success, errormessage = pcall(function()
			local ODS = DataStoreService:GetOrderedDataStore(DataType)
			Data = ODS:GetSortedAsync(false, PageSize)
		end)

		if(success and Data ~= nil)then
			return Data
		else
			return nil
		end
	end

	for i = 1, 3 do
		local Data = Get_Data()
		if(Data ~= nil)then
			return Data:GetCurrentPage()
		end
	end

	return nil
end

function funcs.Delete_Leaderboard(Key, DataType)
	local function Attempt_To_Delete()
		local success, errormessage = pcall(function()
			local ODS = DataStoreService:GetOrderedDataStore(DataType)
			ODS:RemoveAsync(Key)
		end)

		if(success)then
			return true
		else
			return false
		end
	end

	for i = 1, 3 do
		local Removed = Attempt_To_Delete()
		if(Removed)then
			i = 3
			break
		end
	end
end

function funcs.Load_Data(userId, DataType)
	userId = tostring(userId)

	local mainDS = DataStoreService:GetDataStore(NEW_DATASTORE_NAME)
	local backupDS = DataStoreService:GetDataStore(NEW_DATASTORE_NAME .. "_BACKUP")

	---------------------------------------------------------------------
	-- 1) READ NEW DATASTORE (WITH RETRY)
	---------------------------------------------------------------------
	for i = 1, 3 do
		local ok, raw = pcall(function()
			return mainDS:GetAsync(userId)
		end)
		if ok and raw then
			return WebService:JSONDecode(raw)
		end
		task.wait(0.2 * i)
	end

	---------------------------------------------------------------------
	-- 2) FALLBACK ON BACKUP DS
	---------------------------------------------------------------------
	for i = 1, 3 do
		local ok, raw = pcall(function()
			return backupDS:GetAsync(userId)
		end)
		if ok and raw then
			return WebService:JSONDecode(raw)
		end
		task.wait(0.2 * i)
	end

	---------------------------------------------------------------------
	-- 3) OLD DATASTORE AUTO-MIGRATION (comme avant)
	---------------------------------------------------------------------
	local oldKey = userId .. OLD_SUFFIX
	local oldDS = DataStoreService:GetDataStore(oldKey)

	for i = 1, 3 do
		local ok, oldRaw = pcall(function()
			return oldDS:GetAsync(DataType)
		end)
		if ok and oldRaw then
			mainDS:SetAsync(userId, oldRaw)
			backupDS:SetAsync(userId, oldRaw)
			Log_Migration(userId)
			return WebService:JSONDecode(oldRaw)
		end
		task.wait(0.2 * i)
	end

	return nil
end

function funcs.Save_Data(userId, DataType, Value)
	userId = tostring(userId)

	local mainDS = DataStoreService:GetDataStore(NEW_DATASTORE_NAME)
	local backupDS = DataStoreService:GetDataStore(NEW_DATASTORE_NAME .. "_BACKUP")

	local encoded = WebService:JSONEncode(Value)

	---------------------------------------------------------------------
	-- WRITE MAIN DS (3 RETRIES)
	---------------------------------------------------------------------
	for i = 1, 3 do
		local ok = pcall(function()
			mainDS:SetAsync(userId, encoded)
		end)
		if ok then break end
		task.wait(0.2 * i)
	end

	---------------------------------------------------------------------
	-- WRITE BACKUP DS (3 RETRIES)
	---------------------------------------------------------------------
	for i = 1, 3 do
		local ok = pcall(function()
			backupDS:SetAsync(userId, encoded)
		end)
		if ok then break end
		task.wait(0.2 * i)
	end
end

function funcs.Delete_Data(userId)
	userId = tostring(userId)

	local mainDS   = DataStoreService:GetDataStore(NEW_DATASTORE_NAME)
	local backupDS = DataStoreService:GetDataStore(NEW_DATASTORE_NAME .. "_BACKUP")

	---------------------------------------------------------------------
	-- INTERNAL DELETE FUNCTION (WITH RETRIES)
	---------------------------------------------------------------------
	local function Attempt(store, key)
		for i = 1, 3 do
			local ok, err = pcall(function()
				store:RemoveAsync(key)
			end)

			if ok then
				return true
			else
				warn("Delete_Data error:", key, err)
				task.wait(0.2 * i)
			end
		end
		return false
	end

	---------------------------------------------------------------------
	-- DELETE MAIN ENTRY
	---------------------------------------------------------------------
	Attempt(mainDS, userId)

	---------------------------------------------------------------------
	-- DELETE BACKUP ENTRY
	---------------------------------------------------------------------
	Attempt(backupDS, userId)
end

function funcs.Delete_Legacy_DataStore(Key, SubKey)
	local function Attempt_To_Delete(DT)
		local success, errormessage = pcall(function()
			local DataStore = DataStoreService:GetDataStore(Key)
			DataStore:RemoveAsync(DT)
		end)

		if success then
			return true
		else
			warn(string.format(
				"Deleting Legacy Error -> DS: %s | Key: %s | Error: %s",
				tostring(Key),
				tostring(DT),
				tostring(errormessage)
				))
			return false
		end
	end

	for i = 1, 3 do
		if Attempt_To_Delete(SubKey) then break end
		task.wait(0.2 * i)
	end

	for i = 1, 3 do
		if Attempt_To_Delete(SubKey .. "_BACKUP") then break end
		task.wait(0.2 * i)
	end
end


return funcs
]]></ProtectedString>
							<string name="ScriptGuid">{FE5580EA-0A19-47A2-801C-099F50471A1D}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">DS_Module.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6163DF38639445E9B263F2357E1771FC">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Core/Datastore/DS_Handle.lua
--
--  Description:
--      Core handler for player data persistence. 
-- 		Interfaces with DS_Module to save and load player profiles, manages monetization, leaderboards,
--      and premium status checks.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ServerScriptService:
--          * DS_Module
--          * GlobalLeaderBoards
--      - ReplicatedStorage:
--          * Data_Mods_F/Monetization_Mod
--          * Channels_F/Bindable_F/RF
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Server_Client_F/Events
--          * Channels_F/Client_Server_F
--      - Roblox Services:
--          * MarketplaceService
--          * DataStoreService (via DS_Module)
--
--
--  Current Datastores usages into MMA Fighters
--          * $USERID_Game_Data : profile for players | DS_Handle
--          * PlayerOfferState : for podium offers | Offers_Config / Display_Podium_Center / Display_Podium_Left
--          * GA_PlayerDS_1.0.0 : track buying for GA module | GameAnalytics/Store
--          * Limited_Items : see Monetization_Handle
--          * Natio_Elo, Natio_Elo1, Natio_Elo2 : see GlobalLeaderBoards
--
--  Notes:
--      - Player profile schema includes Elo, stats, cosmetics, audio prefs, etc.
--      - Main DataStore key: "PLAYER_DATASTORE_LIVE"
--      - Handles premium membership detection and badge rewards
--      - Tagging system for top players (currently disabled in code)
--
--======================================================================

--Services
local RunService 					= game:GetService("RunService")

-- Modules
local DS_Mod 						= require(script.Parent:WaitForChild("DS_Module"))
local Data_Mods_F 					= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Monetization_Mod 				= require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local GlobalLeaderboardsModule 		= require(game.ServerScriptService.Modules.GlobalLeaderBoards)
local Utils							= require(game.ReplicatedStorage.Modules.Utils)
local PlayerUtils 					= require(game.ReplicatedStorage.Modules.PlayerUtils)
local Fight_Params_Mod 				= require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)

-- Events
local Channels 						= require(game.ReplicatedStorage.Modules.Channels)
local Player_In_Group_RF 			= Channels.Bindable_Functions.Player_In_Group
local Player_Owns_Badge_RF			= Channels.Bindable_Functions.Player_Owns_Badge
local Award_Badge					= Channels.Bindable_Events.Award_Badge
local Player_Leaderboard_Data 		= Channels.Bindable_Events.Player_Leaderboard_Data
local Update_Server_Data 			= Channels.Bindable_Events.Update_Server_Data
local Server_Chat					= Channels.SC_Remote_Events.Server_Chat
local Update_Player_List 			= Channels.SC_Remote_Events.Update_Player_List
local Set_Creator_Reward_Code		= Channels.CS_Remote_Events.Set_Creator_Reward_Code
local Reset_Player_Profile			= Channels.CS_Remote_Events.Reset_Player_Profile
local Game_Startup_Ready 			= Channels.SC_Remote_Events.Game_Startup_Ready

local Leaderboard_Keys 				= {}
local PLAYER_DATA_KEY 				= "PLAYER_DATASTORE_LIVE"
local SAVE_DATA_INTERVAL 			= 30 -- seconds

--[[
	Player Data Profile
	> Stored Player Data
		- Elo
		- Cash
		- Gems
		- Used Codes
		- Retention Streak (and the other Values assosiated with this)
		- Bio
		- Country
		- Skin Tone
		- Right Handed
		- Total Wins
		- Total Ties
		- Total Matches
		- Ranked Wins
		- Total Strikes
		- Dodged Strikes
		- Takedowns Landed
		- Takedowns Attempted
		- Submissions Finished
		- Submissions Attempted
		- Punch Knockout Wins
		- Leg Knockout Wins
		- Submission Wins
		
		- Power per Strike
		- Strike Defense
		- Submission Timeout
		- Submission Defense
		- Staminia
		
		- Current Shorts
		- Current Gloves
		- Inventory Shorts
		- Inventory Gloves
		- Inventory Special Strikes
		- Inventory Special Submissions
		
		- Background Music
		- Sound Effects
		- Voice Over
		- Show Fight Prompt
]]--

local function Update_Retention_Streak(Plr)
	local Current_Time = os.time()
	local PD = Plr:WaitForChild("Player_Data")
	local Prev_Time_Val = PD:WaitForChild("Previous Session Time")
	local Streak_Val = PD:WaitForChild("Retention Streak")
	local Raw_Time_Val = PD:WaitForChild("Raw Prev Session Time")
	local Rewards_Val = PD:WaitForChild("Redeemed Rewards")

	local Dif = Current_Time - Prev_Time_Val.Value
	local Raw_Dif = Current_Time - Raw_Time_Val.Value

	local function Is_Next_Day()
		local Month_Data = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
		local Prev_Data = os.date("!*t", Prev_Time_Val.Value)
		local Prev_Month, Prev_Day = Prev_Data['month'], Prev_Data['day']
		local Current_Day = os.date("!*t", Current_Time)['day'] 

		local Next_Day_Val = Prev_Day + 1
		if(Month_Data[Prev_Month] < Next_Day_Val)then			
			Next_Day_Val = 1
		end

		if(Current_Day == Next_Day_Val or (Dif >= 86400 and Dif <= 172800))then
			return true
		end
		return false
	end

	--[[
	local function Has_Unlocked_All_Rewards()
		if(Rewards_Val ~= nil and Rewards_Val.Value ~= "")then
			local Max_Rewards_Count = Daily_Rewards_Mod.Get_Total_Reward_Amount()
			local Rewards_Keys = string.split(Rewards_Val.Value, ",")
			local Count = 0
			
			for i = 1, #Rewards_Keys do
				local K = string.gsub(Rewards_Keys[i], " ", "")
				if(K ~= nil and K ~= "")then
					Count += 1
				end
			end
			
			if(Count >= Max_Rewards_Count)then
				return true
			end
		end
		
		return false
	end
	local Has_Unlocked_All_R = Has_Unlocked_All_Rewards()
	]]--
	local Has_Unlocked_All_R = false

	if(Is_Next_Day() and Has_Unlocked_All_R == false)then
		Prev_Time_Val.Value = Current_Time
		Streak_Val.Value = Streak_Val.Value + 1
		--print("Is the next Day! Earn new Reward!")

	elseif(Dif > 172800 or Has_Unlocked_All_R == true)then

		--print("Resetting Streak!")
		Prev_Time_Val.Value = Current_Time
		Streak_Val.Value = 1
		Rewards_Val.Value = ""
	end

	Raw_Time_Val.Value = Current_Time
	Plr:SetAttribute("Join_Time", Current_Time)
end

local function Load_Player_Data(Plr)
	-- NEW PARADIGM: one datastore, per-player key
	local Key = tostring(Plr.UserId)
	
	local Default_Data = {
		--General Player Stats
		['Total Sessions'] = 0,
		['Total Playtime'] = 0,
		['Elo'] = 400,
		['Coins'] = 0,
		['Gems'] = 0,
		['Bio'] = "",
		['Country'] = "United States",
		--['League'] = "Rookie",
		--['League_Wins'] = 0,
		--['League_Matches'] = 0,
		--['League_Ties'] = 0,
		['Skin Tone'] = "234,184,146",
		['Right Handed'] = true,
		['Creator Code'] = "",
		['Total Wins'] = 0,
		['Total Ties'] = 0,
		['Total Matches'] = 0,
		['Win Streak'] = 0,
		['Ranked Wins'] = 0,
		['Ranked Matches'] = 0,
		['Ranked Ties'] = 0,
		['Total Strikes'] = 0,
		['Strikes Landed'] = 0,
		['Dodged Strikes'] = 0,
		['Takedowns Landed'] = 0,
		['Takedowns Attempted'] = 0,
		['Submissions Finished'] = 0,
		['Submissions Attempted'] = 0,
		['Punch Knockout Wins'] = 0,
		['Leg Knockout Wins'] = 0,
		['Submissions Wins'] = 0,
		['Gym Training'] = 0,
		['GymEventRewards'] = 0,
		
		['Power per Strike'] = 2.5,
		['Strike Defense'] = 30,
		['Submission Timeout'] = 1,
		['Submission Defense'] = 1,
		['Staminia'] = 100,
		
		['Vip'] = false,
		['Cash2x'] = false,

		['StarterPackTimer'] = nil,
		['RookieTag'] = false,
		['DiscordReward'] = false,
		
		--General Player Data
		['Codes'] = {},
		['Previous Session Time'] = os.time(),
		['Retention Streak'] = 1,
		['Raw Prev Session Time'] = os.time(),
		['Redeemed Rewards'] = {},
		['Owned Gamepasses'] = {},
		['Owned Products'] = {},
		['Redeemed Skill Tree'] = {},
		
		-- Session Rewards (NEW SL)
		['SR_Day'] = os.date("!%Y-%m-%d"),
		['SR_Count'] = 0,
		['SR_ClaimedTimes'] = "",
		
		--Player Inventory Data
		['Current Shorts'] = "A",
		['Current Gloves'] = "A",
		['Current Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Owned Shorts'] = {"A"},
		['Owned Gloves'] = {"A"},
		['Owned Special Strikes'] = {},
		['Owned Special Submissions'] = {},
		['Owned Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Punch Combo'] = {"C", "A", "B","C", "A", "G"},
		['Kick Combo'] = {"F", "D", "E","F", "J", "H"},
		['Strike Combo 1'] = {"C", "A", "B"},
		['Strike Combo 2'] = {"F", "D", "E"},
		['Strike Combo 3'] = {"G", "L", "M"},
		['Strike Combo 4'] = {"F", "J", "H"},
		['Fight Intro Key'] = "A",
		['Fight Outro Key'] = "A",
		['Takedown Key'] = "A",
		['Submission Key'] = "A",
		
		--Player Settings
		['Background Music'] = true,
		['Sound Effects'] = true,
		['Voice Over'] = true,
		['Fight Prompts'] = true,
		['Trading'] = true

	}
	
	local Plr_Data = DS_Mod.Load_Data(Key, PLAYER_DATA_KEY)
	
	if Plr_Data == nil then
		Plr_Data = Default_Data
		GlobalLeaderboardsModule:RegisterNationElo(Plr_Data.Country, Plr_Data.Elo)
	end
	
	if Plr_Data.StarterPackTimer == nil then
		Plr_Data.StarterPackTimer = os.time() + 24 * 60 * 60
	end
	
	if Plr_Data.RookieTag == true then
		Plr:SetAttribute("Rookie", true)
	else
		Plr:SetAttribute("Rookie", false)
	end
	
	local PD = Instance.new("Folder", Plr)
	PD.Name = "Player_Data"

	-----------------------------------

	local function Get_Object_Type(Data)
		local Data_Type = {
			['string'] = "StringValue",
			['table'] = "StringValue",
			['number'] = "NumberValue",
			['boolean'] = "BoolValue"
		}

		local Key = typeof(Data)
		return Data_Type[Key]
	end

	for Data_Key, Data_Val in next, Plr_Data do
		local Obj_Type = Get_Object_Type(Data_Val)
		local V = Instance.new(Obj_Type, PD)
		V.Name = Data_Key

		if(typeof(Data_Val) == "table")then
			V.Value = table.concat(Data_Val, ",")
		else
			V.Value = Data_Val
		end
	end

	for Data_Key, Data_Val in next, Default_Data do
		if not PD:FindFirstChild(Data_Key) then
			local Obj_Type = Get_Object_Type(Data_Val)
			local V = Instance.new(Obj_Type, PD)
			V.Name = Data_Key

			if(typeof(Data_Val) == "table")then
				V.Value = table.concat(Data_Val, ",")
			else
				V.Value = Data_Val
			end
		end
	end
	
	local function Increment_Session_Count()
		local Val = PD:FindFirstChild("Total Sessions")
		if(Val ~= nil)then
			Val.Value += 1
		end
	end
	Increment_Session_Count()
	
	PD:WaitForChild("RookieTag").Changed:Connect(function()
		if PD.RookieTag.Value == true then
			Plr:SetAttribute("Rookie", true)
		end
	end)

	local lastCountry = PD:WaitForChild("Country").Value
	PD:WaitForChild("Country").Changed:Connect(function()
		local newElo = PD:WaitForChild("Elo").Value
		local newCountry = PD:WaitForChild("Country").Value

		GlobalLeaderboardsModule:RegisterNationElo(lastCountry, -newElo)
		GlobalLeaderboardsModule:RegisterNationElo(newCountry, newElo)
		
		lastCountry = newCountry
	end)
	
	local lastElo = PD:WaitForChild("Elo").Value
	PD:WaitForChild("Elo").Changed:Connect(function()
		local newElo = PD:WaitForChild("Elo").Value
		
		GlobalLeaderboardsModule:RegisterNationElo(PD.Country.Value, newElo - lastElo)
		
		lastElo = newElo
	end)
	
	return PD
end

local function Fight_Data_Non_Saveable(Plr)
	local Fight_Data_F = Instance.new("Folder", Plr)
	Fight_Data_F.Name = "Fight_Data"
	
	local Health_V = Instance.new("IntValue", Fight_Data_F)
	Health_V.Name = "Health"
	Health_V.Value = Fight_Params_Mod.Health.Max_Value
	
	local Stam_V = Instance.new("IntValue", Fight_Data_F)
	Stam_V.Name = "Staminia"
	Stam_V.Value = Fight_Params_Mod.Stamina.Max_Value
	Stam_V:SetAttribute("Is_Dodging", false)
	
	local Strike_Power_V = Instance.new("NumberValue", Fight_Data_F)
	Strike_Power_V.Name = "Strike Power"
	Strike_Power_V.Value = Fight_Params_Mod.Punch_Power.Max_Value
	
	local Block_Power_V = Instance.new("IntValue", Fight_Data_F)
	Block_Power_V.Name = "Block Power"
	Block_Power_V.Value = Fight_Params_Mod.Block_Power.Max_Value
	Block_Power_V:SetAttribute("Is_Blocking", false)
end

local function Update_Player_Friend_Boosts()
	local All_Plrs = game.Players:GetPlayers()

	local function Get_Friends_Count(P)
		local function Is_Friends_Async(Other_Plr)
			local function Async()
				local Data = nil
				local success, errormessage = pcall(function()
					Data = P:IsFriendsWith(Other_Plr.UserId)
				end)

				if(success and Data ~= nil)then
					return Data
				end
				return nil
			end

			for i = 1, 3 do
				local D = Async()
				if(D ~= nil)then
					return D
				end
			end
			return false
		end

		local Count = 0

		for i = 1, #All_Plrs do
			if(All_Plrs[i] ~= nil and All_Plrs[i] ~= P and Is_Friends_Async(All_Plrs[i]))then
				Count = Count + 1
			end
		end

		return Count
	end

	for i = 1, #All_Plrs do
		local Plr = All_Plrs[i]
		if(Plr ~= nil)then
			Plr:SetAttribute("Friends_Count", Get_Friends_Count(Plr))
		end
	end
end

local function Init_Gamepass_Data(Plr)
	local Gamepass_Val = Plr:WaitForChild("Player_Data"):WaitForChild("Owned Gamepasses")
	local Gamepass_Data = Monetization_Mod.Get_All_Gamepass_Data()
	local Owned_Keys = Monetization_Mod.Get_Player_Owned_Gamepasses_Keys(Plr)

	for GP_Key, GP_Data in next, Gamepass_Data do
		if(table.find(Owned_Keys, GP_Key) == nil and Monetization_Mod.Hard_Gamepass_Check(Plr, GP_Data['ID']))then
			table.insert(Owned_Keys, GP_Key)
		end
	end
	Gamepass_Val.Value = table.concat(Owned_Keys, ",")
end

local function Save_Player_Data(Plr)
	-- NEW PARADIGM: use only numeric userId key
	local Plr_Key = tostring(Plr.UserId)
	
	local PD_Vals = Plr:FindFirstChild("Player_Data"):GetChildren()
	local Current_Player_Data = {
		--General Player Stats
		['Total Sessions'] = 0,
		['Total Playtime'] = 0,
		['Elo'] = 400,
		['Coins'] = 0,
		['Gems'] = 0,
		['Bio'] = "",
		['Country'] = "United States",
		--['League'] = "Rookie",
		--['League_Wins'] = 0,
		--['League_Matches'] = 0,
		--['League_Ties'] = 0,
		['Skin Tone'] = "234,184,146",
		['Right Handed'] = true,
		['Creator Code'] = "",
		['Win Streak'] = 0,
		['Total Wins'] = 0,
		['Total Ties'] = 0,
		['Total Matches'] = 0,
		['Ranked Wins'] = 0,
		['Ranked Matches'] = 0,
		['Ranked Ties'] = 0,
		['Total Strikes'] = 0,
		['Strikes Landed'] = 0,
		['Dodged Strikes'] = 0,
		['Takedowns Landed'] = 0,
		['Takedowns Attempted'] = 0,
		['Submissions Finished'] = 0,
		['Submissions Attempted'] = 0,
		['Punch Knockout Wins'] = 0,
		['Leg Knockout Wins'] = 0,
		['Submissions Wins'] = 0,
		['Gym Training'] = 0,
		['GymEventRewards'] = 0,

		['Power per Strike'] = 2.5,
		['Strike Defense'] = 30,
		['Submission Timeout'] = 1,
		['Submission Defense'] = 1,
		['Staminia'] = 100,

		['StarterPackTimer'] = nil,
		['DiscordReward'] = false,

		--General Player Data
		['Codes'] = {},
		['Previous Session Time'] = os.time(),
		['Retention Streak'] = 1,
		['Raw Prev Session Time'] = os.time(),
		['Redeemed Rewards'] = {},
		['Owned Gamepasses'] = {},
		['Owned Products'] = {},
		['Redeemed Skill Tree'] = {},

		-- Session Rewards (NEW SL)
		['SR_Day'] = os.date("!%Y-%m-%d"),
		['SR_Count'] = 0,
		['SR_ClaimedTimes'] = "",

		--Player Inventory Data
		['Current Shorts'] = "A",
		['Current Gloves'] = "A",
		['Current Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Owned Shorts'] = {"A"},
		['Owned Gloves'] = {"A"},
		['Owned Special Strikes'] = {},
		['Owned Special Submissions'] = {},
		['Owned Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Punch Combo'] = {"C", "A", "B","C", "A", "G"},
		['Kick Combo'] = {"F", "D", "E","F", "J", "H"},
		['Strike Combo 1'] = {"C", "A", "B"},
		['Strike Combo 2'] = {"F", "D", "E"},
		['Strike Combo 3'] = {"G", "L", "M"},
		['Strike Combo 4'] = {"F", "J", "H"},
		['Fight Intro Key'] = "A",
		['Fight Outro Key'] = "A",
		['Takedown Key'] = "A",
		['Submission Key'] = "A",

		--Player Settings
		['Background Music'] = true,
		['Sound Effects'] = true,
		['Voice Over'] = true,
		['Fight Prompts'] = true,
		['Trading'] = true,

	}

	for i = 1, #PD_Vals do
		local Key, Data = PD_Vals[i].Name, PD_Vals[i].Value
		if(typeof(Current_Player_Data[Key]) == "table")then
			Current_Player_Data[Key] = string.split(Data, ",")
		else
			Current_Player_Data[Key] = Data
		end

		--Leaderboard Data
		if(table.find(Leaderboard_Keys, Key) ~= nil)then
			DS_Mod.Save_Leaderboard(Plr_Key, Key, Data)
		end
	end

	--DS_Mod.Save_Data(Plr_Key, PLAYER_DATA_KEY, Current_Player_Data)
	-- Save always uses the NEW datastore format
	DS_Mod.Save_Data(Plr_Key, PLAYER_DATA_KEY, Current_Player_Data)
end

local function Update_Player_Data_Val(P_ID, Key, New_Data)
	-- NEW PARADIGM
	local Plr_Key = tostring(P_ID)
	
	local P_Data = DS_Mod.Load_Data(Plr_Key, PLAYER_DATA_KEY)
	if(P_Data[Key] ~= nil)then
		P_Data[Key] = New_Data
	end

	DS_Mod.Save_Data(Plr_Key, PLAYER_DATA_KEY, P_Data)
	print("Successfully Updated Player Data Value: " .. Key)
end

local function Handle_Reset_Profile(adminPlayer, targetPlayer, preserveKeys)

	local KEYS_TO_PRESERVE = {
		"Coins",
		"Gems",
		"Owned Gamepasses",
		"Owned Special Strikes",
		"Owned Products",
		"Owned Shorts",
		"Owned Special Submissions",
		"Owned Gloves",
		"Redeemed Skill Tree"
	}

	if not PlayerUtils.isAdmin(adminPlayer) then
		return
	end

	if not targetPlayer then
		targetPlayer = adminPlayer
	end

	local userId = targetPlayer.UserId

	-- Keep backup
	local oldData = preserveKeys and (DS_Mod.Load_Data(userId, PLAYER_DATA_KEY) or {}) or nil

	-- Wipe DS
	DS_Mod.Save_Data(userId, PLAYER_DATA_KEY, nil)

	-- Reset the Player_Data folder
	local pdata = targetPlayer:FindFirstChild("Player_Data")
	if pdata then
		pdata:Destroy()
	end

	task.wait(0.5)
	Load_Player_Data(targetPlayer)
	Fight_Data_Non_Saveable(targetPlayer)

	-- Restore preserved keys
	if preserveKeys and oldData then

		for _, key in ipairs(KEYS_TO_PRESERVE) do
			local value = oldData[key]

			if value ~= nil then
				-- Restore DataStore using the official helper
				Update_Player_Data_Val(userId, key, value)

				-- Restore in-memory Player_Data only if it's a simple value
				local inst = targetPlayer.Player_Data:FindFirstChild(key)
				if inst and typeof(value) ~= "table" and inst:IsA("ValueBase") then
					inst.Value = value
				end
			end
		end
	end

	-- Notify
	Server_Chat:FireClient(
		adminPlayer,
		"Profile for " .. targetPlayer.Name .. " has been reset.",
		Color3.fromRGB(255, 150, 0)
	)

	Server_Chat:FireClient(
		targetPlayer,
		"Your profile has been reset by an administrator.",
		Color3.fromRGB(255, 60, 60)
	)

	Update_Player_List:FireAllClients(targetPlayer, true)
	Update_Server_Data:Fire()
end

Utils.SecureRemote(
	Reset_Player_Profile,
	function(adminPlayer, targetPlayer)

		-- strict server-side admin check
		if not PlayerUtils.isAdmin(adminPlayer) then
			return
		end

		-- default behavior: target = admin
		if targetPlayer == nil then
			targetPlayer = adminPlayer
		end

		Handle_Reset_Profile(adminPlayer, targetPlayer)
	end,
	{ "Instance" }, 
	{
		RateLimit = 1,
		MaxBurst = 5,
		PunishThreshold = 3
	}
)

Utils.SecureRemote(
	Set_Creator_Reward_Code,

	function(plr, newCodeIndex)
		-- Type-check strict
		if typeof(newCodeIndex) ~= "number" then
			return
		end

		-- Hard integer floor to avoid decimals
		newCodeIndex = math.floor(newCodeIndex)

		-- Load player data
		local plrData = plr:FindFirstChild("Player_Data")
		if not plrData then return end

		local creatorCodeVal = plrData:FindFirstChild("Creator Code")
		if not creatorCodeVal then return end

		-- Load creator code table
		local codes = require(game.ReplicatedStorage.Modules.CreatorCodes)

		-- If valid index → apply
		if codes[newCodeIndex] ~= nil then
			creatorCodeVal.Value = newCodeIndex
		else
			-- If invalid, wipe safely (as in your original logic)
			creatorCodeVal.Value = ""
		end
	end,

	{ "number" },

	{
		AllowMissingArgs = false,

		-- Prevent spam resets (super important due to DS hits)
		RateLimit = 1,        -- 1 request per second max
		MaxBurst = 2,         -- small buffer for UI double-clicks
		PunishThreshold = 12, -- only hackers trigger this
	}
)

local function isForcedFirstTimePlayer(Plr)
	if RunService:IsStudio() then
		return false
	else
		local ConfigService = game:GetService("ConfigService")
		local config = ConfigService:GetConfigAsync() 
		local isFirstPlayer = config:GetValue("isFirstPlayer")
		return isFirstPlayer == true	
	end
end

game.Players.PlayerAdded:Connect(function(Plr)
	local pdata = Load_Player_Data(Plr)
	
	Fight_Data_Non_Saveable(Plr)
	
	--Set up Attributes
	Player_In_Group_RF:Invoke(Plr)
	PlayerUtils.Is_Premium_Member(Plr)
	
	Update_Player_Friend_Boosts()

	local Welcome_Badge_ID = Utils.getWelcomeBadgeId()
	local Owns_Welcome = Player_Owns_Badge_RF:Invoke(Plr, Welcome_Badge_ID)
	local isFirstTimePlayer = not Owns_Welcome or isForcedFirstTimePlayer(Plr)
	print(isFirstTimePlayer)
	Plr:SetAttribute("First_Time_Player", isFirstTimePlayer)
	
	--Give Welcome Badge
	if(Owns_Welcome == false)then
		Award_Badge:Fire(Plr, Welcome_Badge_ID)
	end
	
	Update_Retention_Streak(Plr)	
	
	--INIT MONETIZATION HANDLE TO GIVE PLAYERS THE GAMEPASSES THEY INITIALLY BOUGHT FROM WEBSITE
	Init_Gamepass_Data(Plr)
	local Is_VIP = Monetization_Mod.Does_Player_Own_Gamepass_Key(Plr, "A")
	Plr:SetAttribute("Is_VIP", Is_VIP)
	
	if Plr.Player_Data.Vip.Value == true then
		Plr:SetAttribute("Is_VIP", true)
	end

	if Plr:GetAttribute("Is_VIP") then
		local Txt = "A VIP Player has Joined! Welcome back " .. Plr.Name .. "!"
		Server_Chat:FireAllClients(Txt, Color3.fromRGB(255, 170, 0))
	end

	Player_Leaderboard_Data:Fire(Plr)
	Update_Server_Data:Fire()
	Update_Player_List:FireAllClients(Plr, true)	
	
	task.defer(function()
		Game_Startup_Ready:FireClient(Plr, {
			firstTime = Plr:GetAttribute("First_Time_Player")
		})
	end)
end)

game.Players.PlayerMembershipChanged:Connect(function(Plr)
	if(Plr.MembershipType == Enum.MembershipType.Premium)then
		Plr:SetAttribute("Is_Premium", true)
	end
end)

game.Players.PlayerRemoving:Connect(function(Plr)
	task.defer(function()
		Save_Player_Data(Plr)

		Update_Player_Friend_Boosts()
		Update_Server_Data:Fire()
		Update_Player_List:FireAllClients(Plr, false)
	end)
end)

game:BindToClose(function()
	if(game:GetService("RunService"):IsStudio())then
		return
	end	

	local Plrs = game.Players:GetPlayers()
	for i = 1, #Plrs do
		if(Plrs[i] ~= nil)then
			Save_Player_Data(Plrs[i])
		end
	end
end)

while task.wait(SAVE_DATA_INTERVAL) do
	local playerList = game:GetService("Players"):GetPlayers()
	for _, Plr in pairs(playerList) do
		local success, err = pcall(function()
			Save_Player_Data(Plr)
		end)
		print(`Auto-saving for player {Plr} was {success and "successful" or "errored"}`)
	end
end]]></ProtectedString>
							<string name="ScriptGuid">{66D0B3E3-DE55-4B71-BCA4-A6F73F81DF68}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">DS_Handle.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX07871B571FE44B2D9CE6B05AD2980C78">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Archives</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXC59FB2E490D14C9C86175C1037D3788F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Roblox ServerScript : Award Halloween 2025 Badge only during event period
local RS = game:GetService("ReplicatedStorage")
local BadgeService = game:GetService("BadgeService")
local Players = game:GetService("Players")

local Channels 	= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

-- Use centralized references from Channels.Remotes
local Display_Data_E = Channels.Bindable_Events.Display_Data

-- Replace this with your actual Badge ID
local BADGE_ID = 428903715368330

-- Define event period (UTC time)
local EVENT_START = os.time({year = 2025, month = 10, day = 24, hour = 0, min = 0, sec = 0})
local EVENT_END   = os.time({year = 2025, month = 11, day = 14, hour = 0, min = 0, sec = 0})

-- Function to check if the current time is within the event period
local function isWithinEventPeriod()
	local now = os.time()
	return now >= EVENT_START and now < EVENT_END
end

-- Function to award the badge safely
local function awardBadge(player)
	local success, hasBadge = pcall(function()
		return BadgeService:UserHasBadgeAsync(player.UserId, BADGE_ID)
	end)

	if success and not hasBadge then
		local ok, result = pcall(function()
			return BadgeService:AwardBadge(player.UserId, BADGE_ID)
		end)

		if ok then
			Display_Data_E:FireClient(player, "🎃 Halloween Champion 2025 badge awarded to " .. player.Name, Color3.fromRGB(255, 170, 0))
		end
	end
end

-- Main event trigger
Players.PlayerAdded:Connect(function(player)
	if isWithinEventPeriod() then
		task.wait(20)
		awardBadge(player)
	end
end)
]]></ProtectedString>
							<string name="ScriptGuid">{F764747D-EEA4-48FA-B16E-4DAAFD8F1E52}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">HalloweenBadge.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX8432BF6172FF4B0CAD89997AA9F7B7E1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">League_Service</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX949BE97F370A445DB3AFE35879DEB62F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ServerScriptService/League_Service/Tournament_Manager.lua
-- ==========================================================
-- Tournament_Manager : handles weekly tournaments by division
-- ==========================================================
-- TYPE: ModuleScript
-- Requires: League_Manager.lua
-- Triggered by: MessagingService "StartTournament" / "EndTournament"
-- ==========================================================

local DataStoreService 			= game:GetService("DataStoreService")
local RS 						= game:GetService("ReplicatedStorage")
local Players 					= game:GetService("Players")
local ServerScriptService 		= game:GetService("ServerScriptService")

local League_Manager 			= require(ServerScriptService.League_Service:WaitForChild("League_Manager"))
local Tournament_Arena 			= require(ServerScriptService.League_Service:WaitForChild("Tournament_Arena"))
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local League_Mod 				= require(Data_Mods_F:WaitForChild("League_Mod"))
local Bots_Mod 					= require(Data_Mods_F:WaitForChild("Bots_Mod"))

local PromotionConfig 			= League_Mod.PromotionConfig


local TournamentStore 			= DataStoreService:GetDataStore("TournamentDataStore")

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local LeaveEvent 				= Channels.CS_Remote_Events.Tournament_Leave
local Tournament_Update 		= Channels.SC_Remote_Events.Tournament_Update
local Start_Core_Fight 			= Channels.Bindable_Events.Start_Core_Fight
local Tournament_Score_Updated 	= Channels.Bindable_Events.Tournament_Score_Updated
local Tournament_Fight_Ended 	= Channels.Bindable_Events.Tournament_Fight_Ended

local TournamentMode = {
	REAL = "REAL",
	SIMULATION = "SIMULATION"
}

local Tournament_Manager = {}

Tournament_Manager.Mode = TournamentMode.REAL
Tournament_Manager.IsTournamentActive = false
Tournament_Manager.Tournament_Data = {}

-- Active tournaments by division
Tournament_Manager.ActiveTournaments = {}

-- Players waiting for matchmaking
Tournament_Manager.MatchQueue = {}

-- Active fights currently running
Tournament_Manager.ActiveFights = {}

-- ==========================================================
-- UTILITIES
-- ==========================================================

local function getWeekId()
	local now = os.date("!*t")
	local year = now.year
	local yday = now.yday
	local week = math.floor((yday - 1) / 7) + 1
	return string.format("%d-W%02d", year, week)
end

-- Create tournament data structure
local function createTournament(division, week)
	return {
		Division = division,
		Week = week,
		StartTime = os.time(),
		Players = {},
		Matches = {},
		State = "Active",
	}
end

-- Safe datastore update
local function updateTournamentScore(division, week, userId, playerName, points)
	local key = ("TOURNAMENT_%s_%s"):format(division, week)
	pcall(function()
		local data = TournamentStore:GetAsync(key) or {}
		data[userId] = data[userId] or { Name = playerName, Score = 0, Matches = 0, Wins = 0 }
		data[userId].Score += points
		data[userId].Matches += 1
		if points > 0 then data[userId].Wins += 1 end
		TournamentStore:SetAsync(key, data)
	end)
end

----------------------------------------------------------------------
-- CreateSimulatedParticipant
-- Creates a fake tournament participant WITHOUT spawning a real bot in a cage.
-- Produces:
--  - Folder with UserId attribute (negative)
--  - CharacterModel (NPC)
--  - League_Manager registration
--  - Fully compatible participant for TryMatchPlayers
----------------------------------------------------------------------
function Tournament_Manager:CreateSimulatedParticipant(divisionName)
	-- Unique negative UID
	self._simCounter = (self._simCounter or 0) + 1
	local userId = -10000 - self._simCounter
	local name = "SimBot_" .. tostring(self._simCounter)

	------------------------------------------------------------------
	-- Create participant container
	------------------------------------------------------------------
	local participant = Instance.new("Folder")
	participant.Name = name
	participant:SetAttribute("UserId", userId)

	------------------------------------------------------------------
	-- Create CharacterModel for the bot (NPC rig)
	-- MUST NOT spawn into a cage or arena.
	------------------------------------------------------------------
	local botModel

	-- Expecting a BotTemplate model in ServerStorage
	----------------------------------------------------------------
	local templateFolder = Bots_Mod.getBotsTemplateFolder()
	local template = templateFolder:FindFirstChild(Bots_Mod.profiles.NORMAL.Template)
	if not template then
		warn("[Bots_Manager] Bot template not found:", Bots_Mod.profiles.NORMAL.Template)
		return nil
	end
	botModel = template:Clone()
	botModel.Name = name .. "_Model"
	botModel:SetAttribute("IsBot", true)
	botModel.Parent = Bots_Mod.getBotsWorkspaceFolder()

	-- Make sure it's not anchored (fight system handles placement)
	local root = botModel:FindFirstChild("HumanoidRootPart")
	if root then root.Anchored = false end

	------------------------------------------------------------------
	-- Attach character to participant
	------------------------------------------------------------------
	local charRef = Instance.new("ObjectValue")
	charRef.Name = "CharacterModel"
	charRef.Value = botModel
	charRef.Parent = participant

	------------------------------------------------------------------
	-- Register in League standings
	------------------------------------------------------------------
	League_Manager.Players = League_Manager.Players or {}
	League_Manager.Players[userId] = {
		Name = name,
		UserId = userId,
		Division = divisionName,
		LP = 0,
		Points = 0,
		IsBot = true,
	}

	------------------------------------------------------------------
	-- Return a completely valid tournament participant
	------------------------------------------------------------------
	return participant
end


-- ==========================================================
-- MATCHMAKING
-- ==========================================================
function Tournament_Manager:TryMatchPlayers(divisionName)
	if not self.Divisions or not self.Divisions[divisionName] then
		warn(string.format("[TOURNAMENT] TryMatchPlayers() -> Division '%s' not found", divisionName))
		return
	end

	local division = self.Divisions[divisionName]
	local queue = division and division.MatchQueue
	
	if not queue then return end

	if self.Mode ~= TournamentMode.SIMULATION and #queue < 2 then
		return
	end

	print(string.format("[TOURNAMENT][DEBUG] TryMatchPlayers(%s) | %d in MatchQueue | %d in Division",
		divisionName, #queue, division.Players and #division.Players or 0))

	--------------------------------------------------------------------
	-- SIMULATION MODE: auto-generate bots to complete matches
	--------------------------------------------------------------------
	if self.Mode == TournamentMode.SIMULATION then
		-- If only 1 participant -> add 1 bot
		if #queue == 1 then
			local bot = Tournament_Manager:CreateSimulatedParticipant(divisionName)
			table.insert(queue, bot)
			warn(string.format("[TOURNAMENT][SIM] Added bot to pair with %s", queue[1].Name))
		end
	end
	
	-- Process pairs
	local matchCount = math.floor(#queue / 2)
	for matchIndex = 1, matchCount do
		-- Create arena for tournament fight
		local arena = Tournament_Arena:CreateArena()
		
		local p1Data = queue[(matchIndex - 1) * 2 + 1]
		local p2Data = queue[(matchIndex - 1) * 2 + 2]

		if p1Data and p2Data then
			print(string.format("[TOURNAMENT][DEBUG] Match #%d: %s vs %s", matchIndex, p1Data.Name, p2Data.Name))

			-- Retrieve character references (works for both real players and simulated folders)
			local function getCharacterFromParticipant(p)
				if p:IsA("Player") then
					return p.Character
				elseif p:FindFirstChild("CharacterModel") then
					return p.CharacterModel.Value
				end
			end

			local p1Char = getCharacterFromParticipant(p1Data)
			local p2Char = getCharacterFromParticipant(p2Data)

			if p1Char and p2Char then
				task.spawn(function()
					Start_Core_Fight:Fire(arena, p1Char, p2Char)
				end)
			else
				warn(string.format("[TOURNAMENT] ❌ Invalid characters for %s or %s", p1Data.Name, p2Data.Name))
			end
			
			-- Log fight start for tracking
			print(string.format("[TOURNAMENT] 🥊 Fight #%d launched: %s vs %s (Arena: %s)",
				matchIndex, p1Data.Name, p2Data.Name, arena.Name))
		end
	end
end



-- Called when a fight finishes
function Tournament_Manager:OnMatchFinished(result)
	local p1 = result.Players[1]
	local p2 = result.Players[2]
	local winner = result.Winner
	local loser = (winner == p1) and p2 or p1
	local division = result.Division or "?"

	print(("[TOURNAMENT] %s defeated %s in %s"):format(winner.Name, loser.Name, division))

	local winnerUserId = League_Manager:GetSafeUserId(winner)
	local loserUserId = League_Manager:GetSafeUserId(loser)
	
	updateTournamentScore(division, getWeekId(), winnerUserId, winner.Name, 1)
	updateTournamentScore(division, getWeekId(), loserUserId, loser.Name, 0)

	League_Manager:AddWin(winner)
	League_Manager:AddLoss(loser)

	if result.Arena then
		Tournament_Arena:DestroyArena(result.Arena.Name)
	end
	
	-- cleanup
	self.ActiveFights[winner.UserId] = nil
	self.ActiveFights[loser.UserId] = nil

	-- requeue both players for next round
	table.insert(self.MatchQueue[division], winner)
	table.insert(self.MatchQueue[division], loser)
end

-- ==========================================================
-- TOURNAMENT CYCLE
-- ==========================================================

function Tournament_Manager:IsDivisionActive(division)
	local t = self.ActiveTournaments and self.ActiveTournaments[division]
	return t and t.State == "Active"
end

-- Called when a new weekly tournament starts
function Tournament_Manager:StartAllDivisions(week)
	for _, division in ipairs(League_Manager.Divisions) do
		if division ~= "Unranked" then
			self:StartDivisionTournament(division, week)
		end
	end
end

function Tournament_Manager:StartDivisionTournament(division, week)
	print(("[TOURNAMENT] Starting weekly tournament for %s (%s)"):format(division, week))

	self.Divisions = self.Divisions or {}

	-- ✅ Create division data structure if missing
	if not self.Divisions[division] then
		self.Divisions[division] = {
			Players = {},
			MatchQueue = {},
			Week = week,
			State = "Active"
		}
		print(string.format("[TOURNAMENT] ✅ Division '%s' initialized", division))
	end
	
	self.IsTournamentActive = true
	self.Tournament_Data[division]= createTournament(division, week)
	self.MatchQueue[division] = {}
	self.ActiveTournaments[division] = {
		State = "Active",
		Week = week,
	}

	-- register players from this division
	for _, player in ipairs(Players:GetPlayers()) do
		local div = League_Manager:GetDivision(player)
		if div == division then
			table.insert(self.MatchQueue[division], player)
			print(("[TOURNAMENT] %s joined %s division tournament"):format(player.Name, division))
		end
	end

	-- start periodic matchmaking every 60s
	task.spawn(function()
		while self.ActiveTournaments[division] and self.ActiveTournaments[division].State == "Active" do
			self:TryMatchPlayers(division)
			task.wait(60)
		end
	end)
end

-- Called when tournaments end
function Tournament_Manager:EndAllDivisions(week)
	for _, division in ipairs(League_Manager.Divisions) do
		local t = self.ActiveTournaments[division]
		if t and t.Week == week then
			self:EndDivisionTournament(division)
		end
	end
end

--// Ends a tournament for the given division
function Tournament_Manager:EndDivisionTournament(divisionName)
	print(string.format("[TOURNAMENT] Ending tournament for division: %s", divisionName))

	-- Retrieve data from active tournament structures
	local divisionData = self.Tournament_Data and self.Tournament_Data[divisionName]
		or (self.ActiveTournaments and self.ActiveTournaments[divisionName])

	if not divisionData or not divisionData.Players then
		warn(string.format("[TOURNAMENT] ⚠️ No valid player data found for division '%s'", divisionName))
		return
	end

	-- Collect and sort players by score
	local ranking = {}
	for userId, playerData in pairs(divisionData.Players) do
		table.insert(ranking, {
			UserId = userId,
			Name = playerData.Name or ("User_" .. tostring(userId)),
			Score = playerData.Score or 0,
		})
	end

	table.sort(ranking, function(a, b)
		return a.Score > b.Score
	end)

	print(string.format("[TOURNAMENT] %d players ranked in %s", #ranking, divisionName))

	-- ✅ Safe load of tournament configuration
	local cfg = self.PromotionConfig or PromotionConfig or {}
	local promotionCount = cfg.TopPromotionCount or 3
	local demotionCount = cfg.BottomDemotionCount or 2
	local rewardPromo = cfg.RewardPromo or 10
	local rewardDemote = cfg.RewardDemote or -5
	local rewardBase = cfg.RewardBase or 0.5

	-- Ensure finished tournaments table exists
	self.FinishedTournaments = self.FinishedTournaments or {}

	-- Apply LP rewards and promotion/demotion logic
	for i, entry in ipairs(ranking) do
		local lpChange = 0
		local status = "Stable"

		if i <= promotionCount then
			lpChange = rewardPromo
			status = "Promoted"
			if League_Manager and League_Manager.Promote then
				local ok, err = pcall(function()
					League_Manager:Promote(entry.UserId)
				end)
				if not ok then warn("[LEAGUE] Promote() failed:", err) end

			end
		elseif i > #ranking - demotionCount then
			lpChange = rewardDemote
			status = "Demoted"
			if League_Manager and League_Manager.Demote then
				local ok, err = pcall(function()
					League_Manager:Demote(entry.UserId)
				end)
				if not ok then warn("[LEAGUE] Demote() failed:", err) end
			end
		else
			lpChange = math.floor(entry.Score * rewardBase)
			if League_Manager and League_Manager.UpdateLeaguePoints then
				local ok, err = pcall(function()
					League_Manager:UpdateLeaguePoints(entry.UserId, lpChange)
				end)
				if not ok then warn("[LEAGUE] UpdateLeaguePoints() failed:", err) end
			end
		end

		print(string.format(
			"[TOURNAMENT] %-12s | #%d | %3d pts | %+3d LP | %s",
			entry.Name, i, entry.Score, lpChange, status
			))
	end

	-- Archive tournament results
	self.FinishedTournaments[divisionName] = {
		Timestamp = os.time(),
		Ranking = ranking,
		Config = cfg,
	}

	-- Save snapshot for persistence
	if self.SaveTournamentSnapshot then
		self:SaveTournamentSnapshot(divisionName, ranking)
	end

	-- Cleanup
	if self.Tournament_Data and self.Tournament_Data[divisionName] then
		self.Tournament_Data[divisionName].Players = {}
	end

	if self.ActiveTournaments then
		self.ActiveTournaments[divisionName] = nil
	end

	print(string.format(
		"[TOURNAMENT] Rewards applied successfully for %s (%d players)",
		divisionName, #ranking
		))
	print(string.format("[TOURNAMENT] Division %s archived and reset.", divisionName))

	-- Notify clients
	local updateEvent = game.ReplicatedStorage:FindFirstChild("Tournament_Update")
	if updateEvent then
		updateEvent:FireAllClients({
			Type = "finished",
			Division = divisionName,
			Ranking = ranking,
			Timestamp = os.time(),
		})
	end

	self.IsTournamentActive = false
end


--// Utility: Save tournament snapshot (called automatically)
function Tournament_Manager:SaveTournamentSnapshot(divisionName, ranking)
	local ServerStorage = game:GetService("ServerStorage")
	local folder = ServerStorage:FindFirstChild("TournamentHistory")
	if not folder then
		folder = Instance.new("Folder")
		folder.Name = "TournamentHistory"
		folder.Parent = ServerStorage
	end

	local snapshot = Instance.new("Folder")
	snapshot.Name = string.format("%s_%s", divisionName, os.date("%Y%m%d_%H%M%S"))
	snapshot.Parent = folder

	local data = {
		Division = divisionName,
		Date = os.date("%Y-%m-%d %H:%M:%S"),
		Ranking = ranking,
	}

	local json = game:GetService("HttpService"):JSONEncode(data)
	local value = Instance.new("StringValue")
	value.Name = "Snapshot"
	value.Value = json
	value.Parent = snapshot

	print(string.format("[TOURNAMENT] Snapshot saved for %s (%d players)", divisionName, #ranking))
end

function Tournament_Manager:RegisterPlayer(player)
	local division = League_Manager:GetDivision(player)
	self.Divisions = self.Divisions or {}
	self.MatchQueue[division] = self.MatchQueue[division] or {}
	self.Divisions[division] = self.Divisions[division] or { Players = {}, MatchQueue = {} }

	-- Evite les doublons
	for _, existing in ipairs(self.Divisions[division].Players) do
		if existing == player then
			print(string.format("[TOURNAMENT] %s is already registered in %s", player.Name, division))
			return
		end
	end

	table.insert(self.Divisions[division].Players, player)
	table.insert(self.Divisions[division].MatchQueue, player)
	table.insert(self.MatchQueue[division], player)

	print(("[TOURNAMENT] %s registered for %s division"):format(player.Name, division))

	if player and player:IsA("Player") then
		Tournament_Update:FireClient(player, {
			Status = "Registered",
			Division = division
		})
	else
		print(string.format("[SIMULATION] %s registered (mock, no client event)", player.Name))
	end
end

function Tournament_Manager:UnregisterPlayer(player)
	for division, queue in pairs(self.MatchQueue) do
		for i, p in ipairs(queue) do
			if p == player then
				table.remove(queue, i)
				print(("[TOURNAMENT] %s left the %s tournament"):format(player.Name, division))
				Tournament_Update:FireClient(player, { Status = "Unregistered" })
				break
			end
		end
	end
end

function Tournament_Manager:BroadcastRanking(division)
	local divisionData = self.TournamentData[division]
	if not divisionData or not divisionData.Scores then return end

	local ranking = {}
	for playerName, scoreData in pairs(divisionData.Scores) do
		table.insert(ranking, {
			Name = playerName,
			Score = scoreData.Points or 0
		})
	end
	table.sort(ranking, function(a, b) return a.Score > b.Score end)

	local payload = {
		Type = "Tournament_Update",  -- compatible
		Division = division,
		IsActive = true,
		Ranking = ranking,
		Timestamp = os.time(),
	}

	self.Remotes.Tournament_Update:FireAllClients(payload)
end

--// Called when a fight ends (winner vs loser)
--// Called when a fight ends (winner vs loser)
function Tournament_Manager:ReportFightResult(winner, loser)
	-- 🔹 1. Résolution sécurisée des UserIds
	local winnerId = League_Manager:GetSafeUserId(winner)
	local loserId = League_Manager:GetSafeUserId(loser)

	if not winnerId or not loserId then
		warn("[TOURNAMENT] Invalid winner/loser passed to ReportFightResult")
		return
	end

	-- 🔹 2. Récupération des profils
	local winnerData = League_Manager.PlayerCache["LEAGUE_" .. winnerId] or League_Manager:LoadPlayerData(winner)
	local loserData  = League_Manager.PlayerCache["LEAGUE_" .. loserId]  or League_Manager:LoadPlayerData(loser)

	if not winnerData or not loserData then
		warn("[TOURNAMENT] Missing league data for winner/loser")
		return
	end

	-- 🔹 3. Vérifie la division et structure du tournoi
	local division = winnerData.Division or "Unranked"
	local divisionData = self.Tournament_Data[division]

	if not divisionData then
		warn("[TOURNAMENT] No active data for division", division)
		return
	end

	-- ✅ Crée la table Players si elle n'existe pas
	if not divisionData.Players then
		warn(string.format("[TOURNAMENT] Creating Players table for division %s (auto)", division))
		divisionData.Players = {}
	end

	-- 🔹 4. Incrémente les scores
	divisionData.Players[winnerId] = divisionData.Players[winnerId] or { Name = winnerData.Name, Score = 0 }
	divisionData.Players[loserId]  = divisionData.Players[loserId]  or { Name = loserData.Name,  Score = 0 }

	divisionData.Players[winnerId].Score += 1

	-- 🔹 5. Met à jour les données League
	League_Manager:AddWin(winner)
	League_Manager:AddLoss(loser)

	print(string.format("[TOURNAMENT] %s defeated %s (+1 point)", winnerData.Name, loserData.Name))

	-- 🔹 6. Génère le leaderboard live
	local leaderboard = {}
	for userId, pData in pairs(divisionData.Players) do
		table.insert(leaderboard, { Name = pData.Name, Score = pData.Score })
	end
	table.sort(leaderboard, function(a, b)
		return a.Score > b.Score
	end)

	-- 🔹 7. Notifie tous les clients (UI live)
	local TournamentUpdate = game.ReplicatedStorage:FindFirstChild("Tournament_Update")
	if TournamentUpdate then
		TournamentUpdate:FireAllClients({
			Division = division,
			Leaderboard = leaderboard,
			Timestamp = os.time()
		})
	end
end


-- Notifies all clients when a player's score changes mid-tournament
function Tournament_Manager:NotifyScoreUpdate(userId, newLP, result)
	for divisionName, data in pairs(self.Tournament_Data) do
		if data and data.Players[userId] then
			local playerData = data.Players[userId]
			if not playerData then return end

			-- increment score only on win
			if result == "win" then
				playerData.Score = (playerData.Score or 0) + 1
			end

			playerData.LP = newLP or playerData.LP or 0

			local symbol = (result == "win") and "✅" or "❌"
			print(string.format("[TOURNAMENT] %s %s → %d pts | %d LP (%s)",
				symbol, playerData.Name, playerData.Score, playerData.LP, divisionName))

			-- Broadcast live update to all clients
			local event = game.ReplicatedStorage:FindFirstChild("Tournament_Update")
			if event then
				event:FireAllClients({
					Type = "live_update",
					Division = divisionName,
					PlayerName = playerData.Name,
					Score = playerData.Score,
					LP = playerData.LP,
					Result = result,
				})
			end

			break
		end
	end
end


-- Award players at the end of a tournament
function Tournament_Manager:DistributeRewards(divisionName)
	local division = self.ActiveTournaments[divisionName]
	if not division or not division.Ranking then return end

	print(string.format("[TOURNAMENT] Distributing rewards for %s...", divisionName))

	for rank, entry in ipairs(division.Ranking) do
		local player = entry.Player
		local basePoints = entry.Score or 0
		local rewardPoints = math.floor(basePoints * 0.5) + (rank <= 3 and (10 - rank * 2) or 0)
		local rewardCoins = math.floor(basePoints / 10)

		local playerName = entry.Name or (player and player.Name) or "?"
		print(string.format("  #%d %s +%d LP +%d coins", rank, playerName, rewardPoints, rewardCoins))

		-- Update persistent data
		local userId = League_Manager:GetSafeUserId(player)
		if userId then
			League_Manager:AddLeaguePoints(userId, rewardPoints)
			League_Manager:AddCoins(userId, rewardCoins)
		end
	end
	
	
	local DataStoreService = game:GetService("DataStoreService")
	local historyStore = DataStoreService:GetDataStore("TournamentHistory")

	local snapshot = {
		Time = os.time(),
		Division = divisionName,
		Top3 = table.create(3),
	}

	for i = 1, math.min(3, #division.Ranking) do
		snapshot.Top3[i] = {
			Name = division.Ranking[i].Name,
			Score = division.Ranking[i].Score,
		}
	end

	local key = string.format("%s_%d", divisionName, os.time())
	historyStore:SetAsync(key, snapshot)
	print(string.format("[HISTORY] Tournament snapshot saved: %s", key))

end

--========================================================
-- Fetch recent tournament snapshots (for admin panel or UI)
--========================================================
function Tournament_Manager:GetLatestSnapshots(division, count)
	count = count or 3
	local snapshots = {}

	local success, pages = pcall(function()
		return TournamentStore:ListKeysAsync("HISTORY_" .. division .. "_")
	end)

	if not success or not pages then
		warn(string.format("[HISTORY] Unable to list snapshots for %s", division))
		return {}
	end

	local keys = {}
	for key, _ in pages do
		table.insert(keys, key)
	end

	-- Sort keys by date (descending)
	table.sort(keys, function(a, b)
		return a > b
	end)

	for i = 1, math.min(count, #keys) do
		local key = keys[i]
		local ok, snapshot = pcall(function()
			return TournamentStore:GetAsync(key)
		end)
		if ok and snapshot then
			table.insert(snapshots, snapshot)
		else
			warn(string.format("[HISTORY] Could not load snapshot %s: %s", key, tostring(snapshot)))
		end
	end

	print(string.format("[HISTORY] Retrieved %d snapshots for %s", #snapshots, division))
	return snapshots
end

function Tournament_Manager:SetMode(mode)
	self.Mode = mode
	warn("[TOURNAMENT] Mode set to:", mode)
end

--========================================================
-- Events 
--========================================================
RegisterEvent.OnServerEvent:Connect(function(player)
	Tournament_Manager:RegisterPlayer(player)
end)

LeaveEvent.OnServerEvent:Connect(function(player)
	Tournament_Manager:UnregisterPlayer(player)
end)

Tournament_Score_Updated.Event:Connect(function(payload)
	Tournament_Manager:NotifyScoreUpdate(payload.UserId, payload.NewLP, payload.Result)
end)

Tournament_Fight_Ended.Event:Connect(function(result)
	Tournament_Manager:OnMatchFinished(result)
end)

return Tournament_Manager]]></ProtectedString>
						<string name="ScriptGuid">{009FF4A2-7572-44A8-AA36-A7C685570A11}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tournament_Manager.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3B93A6A1C5E440E284443184DC6E82B8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- ServerScriptService/League_Service/League_Manager.lua
-- ==========================================================
-- League_Manager : manages divisions, player ranks, and seasons
-- ==========================================================
-- Features:
--   - Persistent player data across seasons
--   - 8 divisions (Unranked → Legend)
--   - Promotion / demotion handled externally (Tournament_Manager)
--   - Automatic season rollover every 3 months
--   - Compatible with simulated players (Folders with attributes)
-- ==========================================================

local RS = game:GetService("ReplicatedStorage")
local DataStoreService = game:GetService("DataStoreService")
local LeagueStore = DataStoreService:GetDataStore("LeagueDataStore")
local League_Mod = require(game.ReplicatedStorage:WaitForChild("Data_Mods_F"):WaitForChild("League_Mod"))

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))

local Tournament_Score_Updated = Channels.Bindable_Events.Tournament_Score_Updated

local Players = game:GetService("Players")

local League_Manager = {}

-- Ordered list of divisions (lowest to highest)
League_Manager.Divisions = {
	"Unranked",
	"Bronze",
	"Silver",
	"Gold",
	"Emerald",
	"Diamond",
	"Platinum",
	"Legend",
}

-- Current active season (e.g. "2025-Q4")
League_Manager.CurrentSeason = "2026-Q1"

-- In-memory cache (to reduce DataStore hits)
League_Manager.PlayerCache = {}

-- ==========================================================
-- Helper Functions
-- ==========================================================

-- Safe extraction of UserId (works for Player or Folder)
function League_Manager:GetSafeUserId(player)
	if not player then return nil end

	-- Try to read .UserId (works for real Players)
	local userId = nil
	if typeof(player) == "Instance" then
		if player:IsA("Player") then
			userId = player.UserId
		elseif player:FindFirstChild("UserId") and player.UserId:IsA("IntValue") then
			userId = player.UserId.Value
		elseif player:GetAttribute("UserId") then
			userId = player:GetAttribute("UserId")
		end
	end

	return userId
end


-- Returns the next higher division or nil if already top
function League_Manager:GetNextDivision(current)
	for i, name in ipairs(self.Divisions) do
		if name == current then
			return self.Divisions[i + 1]
		end
	end
	return nil
end

-- Returns the previous lower division or nil if already bottom
function League_Manager:GetPreviousDivision(current)
	for i, name in ipairs(self.Divisions) do
		if name == current then
			return self.Divisions[i - 1]
		end
	end
	return nil
end

-- Default structure for a new player
local function DefaultProfile(player)
	local userId = League_Manager:GetSafeUserId(player)
	return {
		UserId = userId,
		Name = player.Name,
		Division = "Unranked",
		Points = 0,
		Wins = 0,
		Losses = 0,
		Season = League_Manager.CurrentSeason,
		LastTournament = nil,
	}
end

function League_Manager:AddLeaguePoints(userId, points)
	local data = self:GetPlayerData(userId)
	if not data then return end
	data.LeaguePoints = (data.LeaguePoints or 0) + points
	self:CheckPromotion(userId)
end

function League_Manager:AddCoins(userId, coins)
	local data = self:GetPlayerData(userId)
	if not data then return end
	data.Coins = (data.Coins or 0) + coins
end

function League_Manager:CheckPromotion(userId)
	local data = self:GetPlayerData(userId)
	if not data then return end

	local currentLeague = data.League or "Unranked"
	local cfg = League_Mod.PromotionConfig
	local nextLeague = League_Mod.GetNextLeague(currentLeague)
	local prevLeague = League_Mod.GetPrevLeague(currentLeague)

	-- Vérifie la promotion
	if nextLeague and data.LeaguePoints >= cfg.BasePromotionPoints then
		data.League = nextLeague
		data.LeaguePoints = 0
		print(string.format("[PROMOTION] %s promoted to %s!", data.Name or userId, nextLeague))

	elseif prevLeague and data.LeaguePoints <= cfg.BaseDemotionPoints then
		data.League = prevLeague
		data.LeaguePoints = 50 -- reset partiel
		print(string.format("[DEMOTION] %s demoted to %s!", data.Name or userId, prevLeague))
	end
end



-- ==========================================================
-- DataStore Load / Save
-- ==========================================================

function League_Manager:LoadPlayerData(player)
	local userId = League_Manager:GetSafeUserId(player)
	if not userId then
		warn("[LEAGUE] Invalid player object passed to LoadPlayerData:", player and player.Name)
		return
	end

	local key = "LEAGUE_" .. userId
	if self.PlayerCache[key] then
		return self.PlayerCache[key]
	end

	local success, data = pcall(function()
		return LeagueStore:GetAsync(key)
	end)

	if not success or not data then
		-- 🧩 Fallback for simulated players (folders)
		if typeof(player) == "Instance" and player:IsA("Folder") then
			data = {
				UserId = userId,
				Name = player.Name,
				Division = "Unranked",
				Points = 0,
				LP = 0,
				Wins = 0,
				Losses = 0,
				Season = self.CurrentSeason
			}
		else
			data = DefaultProfile(player)
		end
	end

	self.PlayerCache[key] = data
	return data
end

function League_Manager:SavePlayerData(player)
	local userId = League_Manager:GetSafeUserId(player)
	if not userId then return end

	local key = "LEAGUE_" .. userId
	local data = self.PlayerCache[key]
	if not data then return end

	pcall(function()
		LeagueStore:SetAsync(key, data)
	end)
end

-- ==========================================================
-- League Logic
-- ==========================================================

function League_Manager:AddWin(player)
	local userId = League_Manager:GetSafeUserId(player)
	if not userId then return end

	local key = "LEAGUE_" .. userId
	local data = self.PlayerCache[key] or self:LoadPlayerData(player)
	
	data.Wins = (data.Wins or 0) + 1
	self:UpdateLeaguePoints(userId, 2)

	print(string.format("[LEAGUE] %s wins a fight (+2 LP)", data.Name))

	-- 🔥 Send live score update (via BindableEvent)
	Tournament_Score_Updated:Fire({
		UserId = userId,
		Name = data.Name,
		Result = "win",
		NewLP = data.LP,
	})
end

function League_Manager:AddLoss(player)
	local userId = League_Manager:GetSafeUserId(player)
	if not userId then return end

	local key = "LEAGUE_" .. userId
	local data = self.PlayerCache[key] or self:LoadPlayerData(player)
	
	data.Losses = (data.Losses or 0) + 1
	self:UpdateLeaguePoints(userId, -1)

	print(string.format("[LEAGUE] %s loses a fight (-1 LP)", data.Name))

	-- 🔥 Send live score update (via BindableEvent)
	Tournament_Score_Updated:Fire({
		UserId = userId,
		Name = data.Name,
		Result = "loss",
		NewLP = data.LP,
	})
end

-- Update player's League Points (LP)
-- Positive = gain, Negative = loss
function League_Manager:UpdateLeaguePoints(userId, amount)
	if not userId then return end
	local key = "LEAGUE_" .. userId
	local data = self.PlayerCache[key]

	-- If not already cached, try loading from datastore
	if not data then
		local fakePlayer = game.Players:GetPlayerByUserId(userId)
		if fakePlayer then
			data = self:LoadPlayerData(fakePlayer)
		else
			-- fallback minimal if it's a simulated player
			data = {
				Name = "Unknown_" .. tostring(userId),
				Division = "Unranked",
				LP = 0,
				Wins = 0,
				Losses = 0
			}
			self.PlayerCache[key] = data
		end
	end

	data.LP = (data.LP or 0) + amount
	data.LastUpdated = os.time()

	self:SavePlayerData(userId)
end


-- Promote a player to the next division
function League_Manager:Promote(player)
	-- 🧩 Skip saving for simulated players (folders)
	if typeof(player) == "Instance" and player:IsA("Folder") then
		print(string.format("[LEAGUE] Simulated promotion for %s (UserId=%s)", player.Name))
		return
	end
	
	local userId = self:GetSafeUserId(player)
	if not userId then
		warn("[LEAGUE] Promote() failed: invalid player")
		return
	end

	local key = "LEAGUE_" .. userId
	local playerData = self.PlayerCache[key] or self:LoadPlayerData(player)
	
	if not playerData then
		warn("[LEAGUE] Promote() failed: no data for player", userId)
		return
	end
	
	

	local divisions = require(game.ReplicatedStorage:WaitForChild("League_Mod")).Divisions
	local currentIndex = table.find(divisions, playerData.Division)
	if not currentIndex then
		warn("[LEAGUE] Invalid division for player", playerData.Division)
		return
	end

	if currentIndex >= #divisions then
		print(string.format("[LEAGUE] %s is already at top division (%s)", playerData.Name, playerData.Division))
		return
	end

	local newDivision = divisions[currentIndex + 1]
	playerData.Division = newDivision
	playerData.LP = 0
	print(string.format("[LEAGUE] %s promoted to %s 🎉", playerData.Name, newDivision))

	self:SavePlayerData(userId)
end

-- Demote a player to the previous division
function League_Manager:Demote(player)
	-- 🧩 Skip saving for simulated players (folders)
	if typeof(player) == "Instance" and player:IsA("Folder") then
		print(string.format("[LEAGUE] Simulated promotion for %s (UserId=%s)", player.Name))
		return
	end
	
	local userId = self:GetSafeUserId(player)
	if not userId then
		warn("[LEAGUE] Demote() failed: invalid player")
		return
	end

	local key = "LEAGUE_" .. userId
	local playerData = self.PlayerCache[key] or self:LoadPlayerData(player)
	
	if not playerData then
		warn("[LEAGUE] Demote() failed: no data for player", userId)
		return
	end

	local divisions = require(game.ReplicatedStorage:WaitForChild("League_Mod")).Divisions
	local currentIndex = table.find(divisions, playerData.Division)
	if not currentIndex then
		warn("[LEAGUE] Invalid division for player", playerData.Division)
		return
	end

	if currentIndex <= 1 then
		print(string.format("[LEAGUE] %s is already at lowest division (%s)", playerData.Name, playerData.Division))
		return
	end

	local newDivision = divisions[currentIndex - 1]
	playerData.Division = newDivision
	playerData.LP = 0
	print(string.format("[LEAGUE] %s demoted to %s 😢", playerData.Name, newDivision))

	self:SavePlayerData(userId)
end


-- Reset points for new season
function League_Manager:StartNewSeason(newSeason)
	print("[LEAGUE] Starting new season:", newSeason)
	self.CurrentSeason = newSeason

	for key, profile in pairs(self.PlayerCache) do
		profile.Season = newSeason
		profile.Points = 0
		profile.Wins = 0
		profile.Losses = 0
	end
end

-- ==========================================================
-- Utility and Events
-- ==========================================================

function League_Manager:GetDivision(player)
	local data = self:LoadPlayerData(player)
	return data and data.Division or "Unranked"
end

function League_Manager:GetStats(player)
	local data = self:LoadPlayerData(player)
	if not data then
		return { Division = "Unranked", Points = 0, Wins = 0, Losses = 0, Season = self.CurrentSeason }
	end
	return {
		Division = data.Division,
		Points = data.Points,
		Wins = data.Wins,
		Losses = data.Losses,
		Season = data.Season,
	}
end

-- Auto-load on join
Players.PlayerAdded:Connect(function(player)
	task.defer(function()
		League_Manager:LoadPlayerData(player)
	end)
end)

-- Auto-save on leave
Players.PlayerRemoving:Connect(function(player)
	task.defer(function()
		League_Manager:SavePlayerData(player)
	end)
end)

return League_Manager
]]></ProtectedString>
						<string name="ScriptGuid">{E2A3ABB1-A746-4CFD-9C87-30B3031D638A}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">League_Manager.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXCFFC0B27BB1046649CBE57EB05D06329">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Fight_Service</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX8CE608DFDDF94234A4BC7C21B747FD8A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Fight_Service/Core_Fight_Handler.server.lua
--
--  Description:
--      Central server-side orchestrator for the entire fight flow.
--      Handles fight initialisation, player teleporting, logic loop
--      management, victory conditions, takedowns, submissions, clinch
--      sequences, and fight termination.
--
--      Features:
--          • Validates cage availability & character readiness
--          • Builds a shared context for all refactored fight modules
--          • Runs initialisation, main loop, and end-of-fight modules
--          • Cleans UI queue elements & resets fight model visuals
--          • Supports bot fighters with modular AI behaviour loading
--          • Handles Ready-To-Fight events & automatically boots bots
--
--  Last Modified: 2025-11-29 
--  Version: V2025-11
--
--  Dependencies:
--      ReplicatedStorage:
--          - Data_Mods_F:
--              Stats_Manager_Mod, Sound_Mod, Animation_Mod,
--              Elo_Mod, Monetization_Mod, Fight_Params_Mod
--          - Modules/Channels
--
--      ServerScriptService:
--          - Fight_Service/TemplateUIs/Player_Display_UI
--
--      Workspace:
--          - Main_World_F.Gameplay.Objects.Fight_Cages_F
--
--      Internal Modules (children of this script):
--          - Fight_Initialization
--          - Fight_Loop
--          - Fight_End
--          - Server_Submission_Minigame
--          - Server_Clinch_Sequence
--
--  Notes:
--      • Core orchestrator only — all gameplay logic lives in the
--        refactored modules.
--      • Bot behaviours are dynamically resolved using _registry
--        stored inside behaviour modules.
--======================================================================

-- Modules
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local Sound_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Monetization_Mod = require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Fight_Params_Mod = require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local Cage_Factory = require(Data_Mods_F:WaitForChild("Cage_Factory"))

-- Events
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Start_Core_Fight = Channels.Bindable_Events.Start_Core_Fight
local Ready_To_Fight	=  Channels.CS_Remote_Events.Ready_To_Fight
local Fight_Intro_Finished	=  Channels.CS_Remote_Events.Fight_Intro_Finished


-- require our refactored modules; they must be children of this script
local Fight_Initialization = require(script:WaitForChild("Fight_Initialization"))
local Fight_Loop = require(script:WaitForChild("Fight_Loop"))
local Fight_End = require(script:WaitForChild("Fight_End"))
local Server_Submission_Minigame = require(script:WaitForChild("Server_Submission_Minigame"))
local Server_Clinch_Sequence = require(script:WaitForChild("Server_Clinch_Sequence"))

----- ASSETS -----
local Player_Display_UI = game.ServerScriptService:WaitForChild("Fight_Service"):WaitForChild("TemplateUIs"):WaitForChild("Player_Display_UI")

-- disconnects all connections stored in the given array
local function Disconnect_Cons(Cons)
	for i = 1, #Cons do
		if Cons[i] ~= nil then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

-- determine whether a fight can start: the round is unused and both
-- characters are valid
local function Verify_Fight_Can_Start(Fight_M, Fight_Char_1, Fight_Char_2)
	local function Is_Fight_Active()
		local Fight_Data_F = Fight_M:FindFirstChild("Fight_Data_F")
		if Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild("Active_Fight") ~= nil then
			local Active_V = Fight_Data_F:FindFirstChild("Active_Fight")
			return Active_V.Value
		end
		return false
	end
	local function Verify_Character(Char)
		if Char ~= nil and Char:FindFirstChildWhichIsA("Humanoid") ~= nil and Char:FindFirstChild("HumanoidRootPart") ~= nil then
			return true
		end
		return false
	end
	if Is_Fight_Active() == false and Verify_Character(Fight_Char_1) and Verify_Character(Fight_Char_2) then
		return true
	end
	return false
end

-- retrieve a character's fight data values (Health and Staminia)
local function Get_Player_Fight_Data_Vals(Char)
	local Fight_Data_F = Char:FindFirstChild("Fight_Data")
	if Fight_Data_F == nil and game.Players:GetPlayerFromCharacter(Char) ~= nil then
		local Plr = game.Players:GetPlayerFromCharacter(Char)
		Fight_Data_F = Plr:FindFirstChild("Fight_Data")
	end
	return Fight_Data_F:FindFirstChild("Health"), Fight_Data_F:FindFirstChild("Staminia")
end

-- core handler that orchestrates fight initialisation, loop and end logic
local function Core_Fight_Logic_Handle(Fight_M, Fight_Char_1, Fight_Char_2)
	-- build a context table to share state across modules
	local context = {}
	context.Cons = {}
	context.Disconnect_Cons = Disconnect_Cons
	context.Fight_M = Fight_M
	context.Fight_Char_1 = Fight_Char_1
	context.Fight_Char_2 = Fight_Char_2
	-- gather fight data values and references
	local Fight_Data_F = Fight_M:WaitForChild("Fight_Data_F")
	context.Fight_Data_F = Fight_Data_F
	context.Inside_Checker_M = Fight_M:WaitForChild("Inside_Checker_M")
	context.Active_V = Fight_Data_F:WaitForChild("Active_Fight")
	context.Char_1_V = Fight_Data_F:WaitForChild("Fight_Char_1")
	context.Char_2_V = Fight_Data_F:WaitForChild("Fight_Char_2")
	context.Round_Count_V = Fight_Data_F:WaitForChild("Round_Count")
	context.Round_Wins_V = Fight_Data_F:WaitForChild("Round_Wins")
	context.Takedown_Track = Fight_Data_F:WaitForChild("Takedown_Track")
	context.Takedown_E = Fight_Data_F:WaitForChild("Takedown_E")
	context.Submission_Char = Fight_Data_F:WaitForChild("Submission_Hold_Character")
	context.C1_Clicked_E = context.Submission_Char:WaitForChild("C1_Clicked_E")
	context.C2_Clicked_E = context.Submission_Char:WaitForChild("C2_Clicked_E")
	context.C1_Health_V, context.C1_Stam_V = Get_Player_Fight_Data_Vals(Fight_Char_1)
	context.C2_Health_V, context.C2_Stam_V = Get_Player_Fight_Data_Vals(Fight_Char_2)
	context.C1_HRP = Fight_Char_1:FindFirstChild("HumanoidRootPart")
	context.C2_HRP = Fight_Char_2:FindFirstChild("HumanoidRootPart")
	context.C1_HUM = Fight_Char_1:FindFirstChild("Humanoid")
	context.C2_HUM = Fight_Char_2:FindFirstChild("Humanoid")
	context.C1_Name = Fight_Char_1.Name
	context.C2_Name = Fight_Char_2.Name
	context.Cage_Parts_M = Fight_M:WaitForChild("Cage_Walls_M")
	context.Cage_Type = Fight_M:GetAttribute("Cage_Type")
	context.Is_Bot_Fight = Fight_M:GetAttribute("Bot_Fight") or false

	-- initial stats snapshots
	context.Init_C1_Data = Stats_Manager_Mod.Create_Fight_Data_Structure(Fight_Char_1)
	context.Init_C2_Data = Stats_Manager_Mod.Create_Fight_Data_Structure(Fight_Char_2)
	context.C1_Rank_Data, context.C1_Elo = Elo_Mod.Get_Player_Rank_Data(game.Players:GetPlayerFromCharacter(Fight_Char_1))
	context.C2_Rank_Data, context.C2_Elo = Elo_Mod.Get_Player_Rank_Data(game.Players:GetPlayerFromCharacter(Fight_Char_2))
	context.Win_Data = {}
	context.Start_Time = os.clock()
	-- expose dependencies to modules
	context.Stats_Manager_Mod = Stats_Manager_Mod
	context.Sound_Mod = Sound_Mod
	context.Animation_Mod = Animation_Mod
	context.Elo_Mod = Elo_Mod
	context.Monetization_Mod = Monetization_Mod
	context.Fight_Params_Mod = Fight_Params_Mod

	-- initialise the fight and teleport players
	Fight_Initialization.Set_Fight_Data(context)
	Fight_Initialization.Move_Players_Into_Fight(context, true, true)
	-- wire up victory detection, takedown tracking and other loops
	Fight_Loop.Victory_Detection_Tracking(context, Fight_End)
	Fight_Loop.Takedown_Handle(context)
	Fight_Loop.Move_To_The_Ground_Handle(context, Fight_End, Server_Submission_Minigame)
	Fight_Loop.Out_Of_Bounds_Handle(context)
	Server_Clinch_Sequence.Cage_Control_Handle(context)
end

-- respond to the Start_Core_Fight event by preparing the arena and
-- launching the fight logic.  This logic reproduces the queue and UI
-- clearing behaviour of the original script before delegating to
-- Core_Fight_Logic_Handle.
Start_Core_Fight.Event:Connect(function(Fight_M, Fight_Char_1, Fight_Char_2)
	if Verify_Fight_Can_Start(Fight_M, Fight_Char_1, Fight_Char_2) then
		-- update fight model UI elements and remove invite buttons
		local fightModels = {
			{Fight_M:FindFirstChild("Fighter_1"), Fight_Char_1},
			{Fight_M:FindFirstChild("Fighter_2"), Fight_Char_2},
		}
		for _, fmData in pairs(fightModels) do
			local FM = fmData[1]
			local char = fmData[2]
			local Main_P = FM:FindFirstChild("Main_P")
			local B1, B2 = Main_P:FindFirstChild("B1"), Main_P:FindFirstChild("B2")
			--local Display_UI = Main_P:FindFirstChild("Player_Display_UI")
			local Empty_Txt = Player_Display_UI:FindFirstChild("Empty_Txt")
			local Player_F = Player_Display_UI:FindFirstChild("Player_F")
			local Outline_P = FM:FindFirstChild("Outline_P")
			local Rot_P = FM:FindFirstChild("Rot_Part")
			local QueueGlow = FM:FindFirstChild("QueueGlow")
			local QueueNeon = FM:FindFirstChild("QueueNeon")
			Player_F.Visible = false
			Empty_Txt.Visible = true
			local Col_Seq = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(248, 248, 248)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(248, 248, 248))
			}
			B1.Color = Col_Seq
			B2.Color = Col_Seq
			Rot_P.Color = Color3.fromRGB(248, 248, 248)
			Outline_P.Color = Color3.fromRGB(248, 248, 248)
			QueueGlow.Color = Color3.fromRGB(207, 172, 169)
			QueueNeon.Color = Color3.fromRGB(207, 172, 169)
			local Prev_Char = char
			if Prev_Char ~= nil and game.Players:GetPlayerFromCharacter(Prev_Char) ~= nil then
				local Prev_Plr = game.Players:GetPlayerFromCharacter(Prev_Char)
				local PG = Prev_Plr:FindFirstChild("PlayerGui")
				local Invite_Buttons_UI = PG:WaitForChild("Fight"):FindFirstChild("Invite_Buttons_UI")
				if PG ~= nil and Invite_Buttons_UI ~= nil then
					Invite_Buttons_UI:Destroy()
				end
			end
		end
		-- launch the refactored fight logic
		Core_Fight_Logic_Handle(Fight_M, Fight_Char_1, Fight_Char_2)
	end
end)

local function IsBot(char)
	return char and char:GetAttribute("IsBot") == true
end

Ready_To_Fight.OnServerEvent:Connect(function(player, cageName)
	local cage = nil
	if cageName and cageName:sub(1, 8) == Fight_Params_Mod.CageType.TUTORIAL then
		cage = Cage_Factory:getCageFolder(Fight_Params_Mod.CageType.TUTORIAL):FindFirstChild(cageName)
	else
		cage = Cage_Factory:getCageFolder(Fight_Params_Mod.CageType.STANDARD):FindFirstChild(cageName)
	end

	if not cage then return end

	local Fight_Data_F = cage:FindFirstChild("Fight_Data_F")

	local char1 = Fight_Data_F:FindFirstChild("Fight_Char_1").Value
	local char2 = Fight_Data_F:FindFirstChild("Fight_Char_2").Value
	if not char1 or not char2 then return end

	local botChar = nil

	if IsBot(char1) then botChar = char1 end
	if IsBot(char2) then botChar = char2 end

	if botChar then
		local behavior
		-- Fallback: look up the behaviour instance from the registry on the module
		local behaviourName = botChar:GetAttribute("Behavior")
		if behaviourName then
			-- normalise to uppercase to match module names
			local modName = string.upper(behaviourName)
			local behavioursFolder = Data_Mods_F:WaitForChild("Bot_Behaviors")
			local behaviourModule = behavioursFolder:FindFirstChild(modName)
			if behaviourModule then
				local mod = require(behaviourModule)
				if mod and mod._registry then
					behavior = mod._registry[botChar]
				end
			end
		end

		-- Only start bot logic when intro is really finished
		if cage:GetAttribute("Intro_Finished") == true then
			if behavior then
				behavior:StartFight()
			end
		else
			-- queue start until intro finished
			local con
			con = game:GetService("RunService").Stepped:Connect(function()
				if cage:GetAttribute("Intro_Finished") == true then
					if con then con:Disconnect() end
					if behavior then
						behavior:StartFight()
					end
				end
			end)
		end
	end

end)

Fight_Intro_Finished.OnServerEvent:Connect(function(player, cageName)
	local cage = nil
	if cageName and cageName:sub(1, 8) == Fight_Params_Mod.CageType.TUTORIAL then
		cage = Cage_Factory:getCageFolder(Fight_Params_Mod.CageType.TUTORIAL):FindFirstChild(cageName)
	else
		cage = Cage_Factory:getCageFolder(Fight_Params_Mod.CageType.STANDARD):FindFirstChild(cageName)
	end
	
	if cage then
		cage:SetAttribute("Intro_Finished", true)
	end
end)
]]></ProtectedString>
						<string name="ScriptGuid">{E426011E-F741-41B1-9A7C-4195FAB1BF88}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Core_Fight_Handle.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXEBABE306C3F74C5C912BAC84B667F656">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Core_Fight_Handle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX8B7E785965934CAB8585986C7B52188A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Events
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Fight_Set_Up = Channels.SC_Remote_Events.Fight_Set_Up


local Fight_Initialization = {}

--[[
    Fight_Initialization
    
    This module encapsulates the logic responsible for preparing a fight.  It
    mirrors the behaviour of the corresponding section of the original
    Core_Fight_Handle.server script without altering any functionality.  All
    state is passed in through the `context` table.  That table should
    contain all values and references used by the original Set_Fight_Data
    and Move_Players_Into_Fight functions (for example Active_V,
    Char_1_V, Char_2_V, Fight_M, C1_HRP, C2_HRP, etc.).

    Functions:
      Set_Fight_Data(context)      -- marks a fight as active and stores initial values
      Move_Players_Into_Fight(context, Init_Fight, initialTP)
        -- teleports characters into the arena, resets their health and
        -- stamina and notifies clients

    It is important that this module is required from the server-side
    Core_Fight_Handle script and the returned functions are invoked with
    the proper context.  No values are stored in the module itself; it
    relies entirely on the supplied context table.
]]

-- Marks a fight as active and sets up round counters.  This function
-- corresponds exactly to the original Set_Fight_Data definition.  It
-- assumes the following keys exist on the context table:
--   Active_V, Char_1_V, Char_2_V, Round_Count_V, Round_Wins_V,
--   Submission_Char, Fight_Char_1, Fight_Char_2
function Fight_Initialization.Set_Fight_Data(context)
	local Active_V = context.Active_V
	local Char_1_V = context.Char_1_V
	local Char_2_V = context.Char_2_V
	local Round_Count_V = context.Round_Count_V
	local Round_Wins_V = context.Round_Wins_V
	local Submission_Char = context.Submission_Char
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2

	-- replicate Set_Fight_Data from the original script
	Active_V.Value = true
	Char_1_V.Value = Fight_Char_1
	Char_2_V.Value = Fight_Char_2
	Round_Count_V.Value = 1
	Round_Wins_V.Value = ""

	local Old_Mid_Point = Submission_Char:FindFirstChild("Midpoint")
	if Old_Mid_Point ~= nil then
		Old_Mid_Point:Destroy()
	end
end

-- Teleports fighters into the arena and prepares their stats.  This
-- corresponds exactly to the Move_Players_Into_Fight function from the
-- original script.  The `Init_Fight` flag determines whether ranked
-- teleport behaviour is used; `initialTP` controls the initial wait
-- before teleporting when not ranked.  The context table must provide
-- numerous values including:
--   Fight_M, C1_HRP, C2_HRP, C1_HUM, C2_HUM, C1_Health_V,
--   C1_Stam_V, C2_Health_V, C2_Stam_V, Fight_Data_F,
--   Fight_Char_1, Fight_Char_2, Char_1_V, Is_Ranked_Match,
--   Sending_Events_F
function Fight_Initialization.Move_Players_Into_Fight(context, Init_Fight, initialTP)
	local C1_HRP = context.C1_HRP
	local C2_HRP = context.C2_HRP
	local C1_HUM = context.C1_HUM
	local C2_HUM = context.C2_HUM
	local C1_Health_V = context.C1_Health_V
	local C1_Stam_V = context.C1_Stam_V
	local C2_Health_V = context.C2_Health_V
	local C2_Stam_V = context.C2_Stam_V
	local Fight_Data_F = context.Fight_Data_F
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2
	local Char_1_V = context.Char_1_V
	local Fight_M = context.Fight_M
	local Is_Ranked_Match = context.Cage_Type == "RANKED"
	
	-- local helper replicating the Client_Set_Up_Event from the original
	local function Client_Set_Up_Event(Char)
		local C_Plr = game.Players:GetPlayerFromCharacter(Char)
		if C_Plr ~= nil then
			local Target_HRP, Target_Char, Is_C1 = C1_HRP, Fight_Char_1, true
			if Char == Char_1_V.Value then
				Target_HRP, Target_Char, Is_C1 = C2_HRP, Fight_Char_2, false
			end

			if Init_Fight then
				local isBot = game.Players:GetPlayerFromCharacter(Target_HRP.Parent) == nil
				if isBot == true then
					Fight_Set_Up:FireClient(C_Plr, Fight_M, true, Target_Char.Name)
				else
					Fight_Set_Up:FireClient(C_Plr, Fight_M, false, Target_Char, Target_HRP)
				end

				wait(1.1)

				if Is_Ranked_Match and Target_HRP ~= nil then
					local Ranked_Spawns_F = Fight_M:FindFirstChild("Ranked_Spawns_F")
					if Ranked_Spawns_F ~= nil then
						if Is_C1 and Ranked_Spawns_F:FindFirstChild("C1_Ranked_Spawn_P") ~= nil then
							local Spawn_P = Ranked_Spawns_F:FindFirstChild("C1_Ranked_Spawn_P")
							Target_HRP.CFrame = Spawn_P.CFrame
						elseif Is_C1 == false and Ranked_Spawns_F:FindFirstChild("C2_Ranked_Spawn_P") ~= nil then
							local Spawn_P = Ranked_Spawns_F:FindFirstChild("C2_Ranked_Spawn_P")
							Target_HRP.CFrame = Spawn_P.CFrame
						end
					end
				end
			end
		end
	end

	-- fire the client setup events concurrently
	task.spawn(Client_Set_Up_Event, Fight_Char_1)
	task.spawn(Client_Set_Up_Event, Fight_Char_2)

	-- wait based on ranked status
	if Init_Fight and Is_Ranked_Match then
		wait(18)
	else
		if initialTP == true then
			wait(1)
		end
	end

	-- teleport and reset fighter 1
	if C1_HRP ~= nil then
		local sp = Fight_Data_F:WaitForChild("Spawn_1")
		C1_HRP.CFrame = sp.CFrame * CFrame.new(0, -sp.Size.Y / 2 + C1_HRP.Size.Y / 2 + C1_HUM.HipHeight, 0)
		if C1_Health_V ~= nil then
			C1_Health_V.Value = 100
		end
		if C1_Stam_V ~= nil then
			C1_Stam_V.Value = 100
		end
		local Reset_Fight_Health_Data_C1 = Fight_Char_1:FindFirstChild("Reset_Fight_Health_Data")
		if Reset_Fight_Health_Data_C1 ~= nil then
			Reset_Fight_Health_Data_C1:Fire()
		end
	end

	-- teleport and reset fighter 2
	if C2_HRP ~= nil then
		local sp = Fight_Data_F:WaitForChild("Spawn_2")
		C2_HRP.CFrame = sp.CFrame * CFrame.new(0, -sp.Size.Y / 2 + C2_HRP.Size.Y / 2 + C2_HUM.HipHeight, 0)
		if C2_Health_V ~= nil then
			C2_Health_V.Value = 100
		end
		if C2_Stam_V ~= nil then
			C2_Stam_V.Value = 100
		end
		local Reset_Fight_Health_Data_C2 = Fight_Char_2:FindFirstChild("Reset_Fight_Health_Data")
		if Reset_Fight_Health_Data_C2 ~= nil then
			Reset_Fight_Health_Data_C2:Fire()
		end
	end
end

return Fight_Initialization]]></ProtectedString>
							<string name="ScriptGuid">{36629340-1A31-4F94-866D-FA43725A2B07}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Fight_Initialization.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFB781FA23FDE481695517892D9C145A7">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Fight_Params_Mod = require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Overhead_Display_E = Channels.SC_Remote_Events.Overhead_Display

local Fight_Loop = {}

--[[
    Fight_Loop

    This module contains the ongoing fight logic once a bout has been
    initialized.  Functions here wire up health change listeners,
    detect takedown conditions, manage submissions, monitor out of
    bounds behaviour and handle per‐second cage proximity checks.  All
    functions expect a `context` table holding the same fields that
    existed as locals inside the original Core_Fight_Handle.server
    script.  Event connections created here are stored in
    context.Cons so that the caller may disconnect them when the fight
    ends.

    Functions:
      Clear_Takedown_Tracking(context)
      Nullify_Takedown_Tracking(context)
      Victory_Detection_Tracking(context, fightEndModule)
      Takedown_Handle(context)
      Move_To_The_Ground_Handle(context, fightEndModule, submissionMinigameModule)
      Out_Of_Bounds_Handle(context)
]]

-- Reset the takedown tracking value and clear all attributes on the
-- takedown tracker.  Mirrors Clear_Takedown_Tracking from the original
-- script.  context must contain Takedown_Track.
function Fight_Loop.Clear_Takedown_Tracking(context)
	local Takedown_Track = context.Takedown_Track
	Takedown_Track.Value = false
	for Key, Val in next, Takedown_Track:GetAttributes() do
		Takedown_Track:SetAttribute(Key, nil)
	end
end

-- Zero out all attributes on the takedown tracker and reset the
-- Start_Time value.  This is equivalent to Nullify_Takedown_Tracking
-- in the original script.  context must contain Takedown_Track and
-- Start_Time.
function Fight_Loop.Nullify_Takedown_Tracking(context)
	local Takedown_Track = context.Takedown_Track
	for Key, Val in next, Takedown_Track:GetAttributes() do
		Takedown_Track:SetAttribute(Key, 0)
	end
	context.Start_Time = os.clock()
end

-- Set up listeners to detect when a fighter has been knocked out or
-- otherwise removed from play.  When a victory condition is met,
-- Victory_Handle on the fightEndModule will be invoked.  context must
-- provide C1_Health_V, C2_Health_V, C1_HUM, C2_HUM, Fight_Char_1,
-- Fight_Char_2 and Cons.
function Fight_Loop.Victory_Detection_Tracking(context, fightEndModule)
	local Cons = context.Cons
	local C1_Health_V = context.C1_Health_V
	local C2_Health_V = context.C2_Health_V
	local C1_HUM = context.C1_HUM
	local C2_HUM = context.C2_HUM
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2

	-- debounce to avoid multiple triggers on fast health changes
	local Died_From_Health_Debounce = false

	if C1_Health_V ~= nil then
		table.insert(Cons, C1_Health_V.Changed:Connect(function()
			if C1_Health_V.Value <= 0 and Died_From_Health_Debounce == false then
				Died_From_Health_Debounce = true
				fightEndModule.Victory_Handle(context, Fight_Char_2, false)
				wait(3)
				Died_From_Health_Debounce = false
			end
		end))
		table.insert(Cons, C1_HUM.Changed:Connect(function()
			if C1_HUM.Health <= 0 and Died_From_Health_Debounce == false then
				Died_From_Health_Debounce = true
				fightEndModule.Victory_Handle(context, Fight_Char_2, true)
				wait(3)
				Died_From_Health_Debounce = false
			end
		end))
	end

	if C2_Health_V ~= nil then
		table.insert(Cons, C2_Health_V.Changed:Connect(function()
			if C2_Health_V.Value <= 0 and Died_From_Health_Debounce == false then
				Died_From_Health_Debounce = true
				fightEndModule.Victory_Handle(context, Fight_Char_1, false)
				wait(3)
				Died_From_Health_Debounce = false
			end
		end))
		table.insert(Cons, C2_HUM.Changed:Connect(function()
			if C2_HUM.Health <= 0 and Died_From_Health_Debounce == false then
				Died_From_Health_Debounce = true
				fightEndModule.Victory_Handle(context, Fight_Char_1, true)
				wait(3)
				Died_From_Health_Debounce = false
			end
		end))
	end

	if Fight_Char_1 ~= nil then
		table.insert(Cons, Fight_Char_1.AncestryChanged:Connect(function()
			if Fight_Char_1 == nil or Fight_Char_1.Parent == nil or not Fight_Char_1:IsDescendantOf(game.Workspace) then
				fightEndModule.Victory_Handle(context, context.Fight_Char_2, true)
			end
		end))
	end

	if Fight_Char_2 ~= nil then
		table.insert(Cons, Fight_Char_2.AncestryChanged:Connect(function()
			if Fight_Char_2 == nil or Fight_Char_2.Parent == nil or not Fight_Char_2:IsDescendantOf(game.Workspace) then
				fightEndModule.Victory_Handle(context, context.Fight_Char_1, true)
			end
		end))
	end
end

-- Track damage taken by each fighter and raise the takedown flag when
-- certain thresholds are exceeded.  This implements the original
-- Takedown_Handle function and relies on Clear_Takedown_Tracking to
-- reset the state before starting.  context must provide
-- Takedown_Track, C1_Name, C2_Name, C1_Health_V, C1_Stam_V,
-- C2_Health_V, C2_Stam_V, Submission_Char and Cons.
function Fight_Loop.Takedown_Handle(context)
	local Takedown_Track = context.Takedown_Track
	local C1_Name = context.C1_Name
	local C2_Name = context.C2_Name
	local C1_Health_V = context.C1_Health_V
	local C1_Stam_V = context.C1_Stam_V
	local C2_Health_V = context.C2_Health_V
	local C2_Stam_V = context.C2_Stam_V
	local Submission_Char = context.Submission_Char
	local Cons = context.Cons

	-- algorithm parameters
	local Min_Difference = Fight_Params_Mod.Takedown.Min_Difference
	-- reset takedown tracking at the beginning
	Fight_Loop.Clear_Takedown_Tracking(context)

	-- update tracking values when a fighter takes damage
	local function Player_Hit_Tracking(Key, Opponent_Health_V, Opponent_Stam_V)
		
		local function Increment_Takedown_Tracker(Health_Dif)
			if Health_Dif > 0 then
				local Prev_Val = Takedown_Track:GetAttribute(Key) or 0
				local New_Value = Prev_Val + 1

				Takedown_Track:SetAttribute(Key, New_Value)
			end
		end
		
		local function Update_Takedown_Bool()
			if Submission_Char.Value == nil then
				local C1_Val = Takedown_Track:GetAttribute(C1_Name) or 0
				local C2_Val = Takedown_Track:GetAttribute(C2_Name) or 0
				local Min_Val = math.min(C1_Val, C2_Val)
				local Difference = math.abs(C1_Val - C2_Val)
				
				Takedown_Track:SetAttribute(C1_Name, C1_Val - Min_Val)
				Takedown_Track:SetAttribute(C2_Name, C2_Val - Min_Val)
				Takedown_Track.Value = Difference >= Min_Difference
			end
		end
		
		local Prev_Health = Opponent_Health_V.Value
		local Debounce_H = false
		table.insert(Cons, Opponent_Health_V.Changed:Connect(function()
			if Debounce_H == false then
				Debounce_H = true
				local Current_Health = Opponent_Health_V.Value
				local Health_Dif = Prev_Health - Current_Health
				Prev_Health = Current_Health
				Increment_Takedown_Tracker(Health_Dif)
				Update_Takedown_Bool()
				-- wait(1)
				Debounce_H = false
			end
		end))
		Takedown_Track:SetAttribute(Key, 0)
	end
	-- start tracking hits for both fighters
	Player_Hit_Tracking(C1_Name, C2_Health_V, C2_Stam_V)
	Player_Hit_Tracking(C2_Name, C1_Health_V, C1_Stam_V)
end

-- Handles all logic associated with takedowns leading to a submission
-- mini–game.  This mirrors the Move_To_The_Ground_Handle function in
-- the original script.  The `submissionMinigame` parameter should
-- expose a function Submission_Handle(context, Submission_Plr) which
-- contains the minigame implementation.  fightEndModule is not used
-- here but is passed to maintain the same signature used elsewhere.
function Fight_Loop.Move_To_The_Ground_Handle(context, fightEndModule, submissionMinigame)
	local Debounce_Takedown = false
	local Takedown_Track = context.Takedown_Track
	local C1_Name = context.C1_Name
	local C2_Name = context.C2_Name
	local C1_HRP = context.C1_HRP
	local C2_HRP = context.C2_HRP
	local C1_HUM = context.C1_HUM
	local C2_HUM = context.C2_HUM
	local C1_Health_V = context.C1_Health_V
	local C1_Stam_V = context.C1_Stam_V
	local C2_Health_V = context.C2_Health_V
	local C2_Stam_V = context.C2_Stam_V
	local Submission_Char = context.Submission_Char
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2
	local Takedown_E = context.Takedown_E
	local C1_HRP = context.C1_HRP
	local C2_HRP = context.C2_HRP
	local Active_V = context.Active_V
	local Cons = context.Cons
	local Stats_Manager_Mod = context.Stats_Manager_Mod

	-- Determine if a player can successfully initiate a takedown
	local function Can_Take_Down_Player(Plr)
		local C1_Val = Takedown_Track:GetAttribute(C1_Name) or 0
		local C2_Val = Takedown_Track:GetAttribute(C2_Name) or 0
		local Dist = (C1_HRP.Position - C2_HRP.Position).Magnitude
		if ((C1_Val > C2_Val and C1_Name == Plr.Name) or (C1_Val < C2_Val and C2_Name == Plr.Name)) and Dist <= 20 then
			return true
		end
		return false
	end

	-- enable or disable the damage UI on a character
	local function Toggle_Players_Damage_Bars(Char, Is_Enabled)
		local Fight_UI = Char:FindFirstChild("Fighting_UI")
		if Fight_UI ~= nil then
			Fight_UI.Enabled = Is_Enabled
		end
	end

	-- reposition fighters and weld them for the takedown and submission sequences
	local function New_Animation_Handle(T_Char, R_Char, Submission_Plr)
		local T_HRP = T_Char:FindFirstChild("HumanoidRootPart")
		local R_HRP = R_Char:FindFirstChild("HumanoidRootPart")
		local destructor = function() end
		local function Assert_Check()
			return T_HRP ~= nil and R_HRP ~= nil and Submission_Plr.Character ~= nil
		end
		if Assert_Check() then
			local Takedown_Data, Submission_Data = context.Animation_Mod.Get_Takedown_Submission_Data(Submission_Plr.Character)
			local R_CF_Origin = R_HRP.CFrame
			T_HRP.CFrame = R_CF_Origin:ToWorldSpace(Takedown_Data['CF Offset'])
			local weld = Instance.new("Weld")
			weld.Part0 = R_HRP
			weld.Part1 = T_HRP
			weld.C0 = Takedown_Data['CF Offset']
			weld.Parent = R_HRP
			Toggle_Players_Damage_Bars(T_Char, false)
			Toggle_Players_Damage_Bars(R_Char, false)
			destructor = function()
				weld:Destroy()
			end
			task.spawn(function()
				task.wait(Takedown_Data['Time Length'] + 0.25)
				if Assert_Check() then
					T_HRP.CFrame = R_CF_Origin:ToWorldSpace(Submission_Data['CF Offset'])
					weld.C0 = Submission_Data['CF Offset']
				end
			end)
		end
		return destructor
	end

	-- reduce the stamina of the attacking player after an attempted takedown
	local function Deduct_Stam(Plr)
		local Stamina_Consumption = Fight_Params_Mod.Stamina.Attempted_Takedown
		if Fight_Char_1 ~= nil and C1_Name == Plr.Name and C1_Stam_V ~= nil then
			local Val = C1_Stam_V.Value - Stamina_Consumption
			C1_Stam_V.Value = math.clamp(Val, 25, 100)
		elseif Fight_Char_2 ~= nil and C2_Name == Plr.Name and C2_Stam_V ~= nil then
			local Val = C2_Stam_V.Value - Stamina_Consumption
			C2_Stam_V.Value = math.clamp(Val, 25, 100)
		end
	end

	-- apply impulse and overhead text when a takedown is missed
	local function Missed_Takedown(Plr)
		local P_Char = Plr.Character
		if P_Char ~= nil and P_Char:FindFirstChild("HumanoidRootPart") ~= nil then
			local P_HRP = P_Char:FindFirstChild("HumanoidRootPart")
			local Hit_Force = 500
			local Dir = P_HRP.CFrame.LookVector
			P_HRP:ApplyImpulse(Dir * Hit_Force * P_HRP:GetMass())
			Overhead_Display_E:FireAllClients(P_Char, "Missed!", Color3.fromRGB(9, 137, 207))
		end
	end

	-- orchestrate a successful takedown leading into a submission
	local function Set_Up_Takedown(Plr)
		Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Takedowns Landed", 1)
		Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Submissions Attempted", 1)
		Submission_Char.Value = Plr.Character
		-- reset tracking before the submission game begins
		Fight_Loop.Nullify_Takedown_Tracking(context)
		-- launch the submission minigame
		submissionMinigame.Submission_Handle(context, Plr)
	end

	-- connect to the takedown remote and handle success or miss
	table.insert(Cons, Takedown_E.OnServerEvent:Connect(function(Plr)
		if Debounce_Takedown == false and Active_V.Value == true and Takedown_Track.Value == true and Submission_Char.Value == nil then
			Debounce_Takedown = true
			Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Takedowns Attempted", 1)
			Deduct_Stam(Plr)
			if Can_Take_Down_Player(Plr) then
				Set_Up_Takedown(Plr)
			else
				Missed_Takedown(Plr)
			end
			wait(10)
			Debounce_Takedown = false
		end
	end))
end

-- Monitor fighters’ positions relative to the fighting area and force
-- them back inside if they stray too far for too long.  Mirrors
-- Out_Of_Bounds_Handle in the original.  context must provide
-- Fight_Char_1, Fight_Char_2, Inside_Checker_M and Cons.
function Fight_Loop.Out_Of_Bounds_Handle(context)
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2
	local Inside_Checker_M = context.Inside_Checker_M
	local Cons = context.Cons

	local function Track_Character(Character)
		local time_outside = 0
		local max_time_outside = 3
		local runCon = game:GetService("RunService").Heartbeat:Connect(function(dt)
			local HRP = Character:FindFirstChild("HumanoidRootPart")
			local isOutside = true
			if HRP then
				local collider = Inside_Checker_M.Collider
				local pos = HRP.Position
				local localPos = collider.CFrame:pointToObjectSpace(pos)
				localPos = Vector2.new(
					localPos.X / (collider.Size.X / 2),
					math.sqrt(localPos.Y ^ 2 + localPos.Z ^ 2) / (collider.Size.Y / 2)
				)
				if math.abs(localPos.X) <= 1 and math.abs(localPos.Y) <= 1 then
					isOutside = false
				end
			end
			if isOutside == true then
				time_outside += dt
			else
				time_outside -= dt
			end
			time_outside = math.clamp(time_outside, 0, max_time_outside)
			if time_outside >= max_time_outside then
				Character:PivotTo(Inside_Checker_M.Position.CFrame * CFrame.new(0, 3, 0))
			end
		end)
		table.insert(Cons, runCon)
	end
	if Fight_Char_1 then Track_Character(Fight_Char_1) end
	if Fight_Char_2 then Track_Character(Fight_Char_2) end
end

return Fight_Loop]]></ProtectedString>
							<string name="ScriptGuid">{EF341251-2473-4A49-B6AF-DFD43969E80D}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Fight_Loop.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA2244B6EA6CA4E43B49B29655BF8EC2E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Fight_Initialization 		= require(script.Parent:WaitForChild("Fight_Initialization"))
local Fight_Loop 				= require(script.Parent:WaitForChild("Fight_Loop"))
local PlayerUtils 				= require(game.ReplicatedStorage.Modules.PlayerUtils)
local Elo_Mod 					= require(game.ReplicatedStorage.Data_Mods_F.Elo_Mod)

local Channels 					= require(game.ReplicatedStorage.Modules.Channels)

local Round_Result_Win 			= Channels.Server_Client_Events.Round_Result_Win
local End_Fight 				= Channels.Server_Client_Events.End_Fight
local Fight_Data_Result 		= Channels.Server_Client_Events.Fight_Data_Result
local Display_Data 				= Channels.Server_Client_Events.Display_Data
local Tournament_Fight_Ended 	= Channels.Bindable_Events.Tournament_Fight_Ended

--[[
    Fight_End

    This module defines the victory resolution logic for the fight system.
    Its primary entry point is Victory_Handle which mirrors the original
    function of the same name found within Core_Fight_Handle.server.
    It accepts a context table carrying all state required to compute
    winner determination, stat rewards and round progression.  The
    function is invoked by the fight loop when a knockout or other
    victory condition is detected.

    The module depends on the Fight_Initialization and Fight_Loop
    modules to reset rounds and clear/nullify takedown tracking when
    necessary.  Those modules are required via script.Parent so that
    they can be found alongside this module in Roblox Studio.
]]

local Fight_End = {}

local ROUND_END_DELAY = 3.5

--------------------------------------------------------
-- UTILITY HELPERS
--------------------------------------------------------

local function FireToWinnerRound(Winning_Char, Was_KO)
	local plr = game.Players:GetPlayerFromCharacter(Winning_Char)
	if plr then
		warn(tostring(Winning_Char) .. " won the round")
		Round_Result_Win:FireClient(plr, Was_KO)
	end
end

-- helper to get the opponent character for teleporting out of the ring
local function GetOpponent(ctx, Char)
	if Char == ctx.Fight_Char_1 then
		return ctx.Fight_Char_2
	end
	return ctx.Fight_Char_1
end

--------------------------------------------------------
-- MATCH WINNER RESOLUTION 
--------------------------------------------------------

local function Get_Winning_Result(ctx, Winning_Char, Dead_Or_KO)
	local Win_Data = ctx.Win_Data
	local C1_Name = ctx.C1_Name
	local Fight_Char_1 = ctx.Fight_Char_1
	local Fight_Char_2 = ctx.Fight_Char_2
	local Is_Ranked_Match = ctx.Cage_Type == "RANKED"

	local Needed_Wins = 2
	if Is_Ranked_Match == true then
		Needed_Wins = 3
	end

	local C1_Wins = 0
	local C2_Wins = 0

	for _, name in ipairs(Win_Data) do
		if name == C1_Name then
			C1_Wins += 1
		else
			C2_Wins += 1
		end
	end

	if Fight_Char_1 == nil then return Fight_Char_2 end
	if Fight_Char_2 == nil then return Fight_Char_1 end

	if Dead_Or_KO then
		if C1_Wins >= C2_Wins then return Fight_Char_1 else return Fight_Char_2 end
	end

	if C1_Wins >= Needed_Wins then return Fight_Char_1 end
	if C2_Wins >= Needed_Wins then return Fight_Char_2 end

	return nil
end

--------------------------------------------------------
-- AWARD STATS 
--------------------------------------------------------
local function Award_Stats(ctx, Char, Winning_Char)
	local Plr = Char['_PLAYER_VALUE_'].Value
	local Did_Win = (Char == Winning_Char)
	local Is_Ranked_Match = ctx.Cage_Type == "RANKED"
	
	-- ELO (Ranked or Standard Cage)
	local EloMode = nil
	if Is_Ranked_Match then
		EloMode = Elo_Mod.EloMode.Ranked
	elseif ctx.Cage_Type == "STANDARD" and not ctx.Is_Bot_Fight then
		EloMode = Elo_Mod.EloMode.Standard
	else
		warn("Unexpected Cage_Type : "..ctx.Cage_Type)
	end

	if EloMode then
		local Opponent_Char = (Char == ctx.Fight_Char_1) and ctx.Fight_Char_2 or ctx.Fight_Char_1
		local Opponent_Plr = Opponent_Char['_PLAYER_VALUE_'].Value

		local myElo = Plr.Player_Data.Elo.Value
		local oppElo = Opponent_Plr.Player_Data.Elo.Value

		local newWinnerElo, newLoserElo = Elo_Mod.Compute_Elo(
			Did_Win and myElo or oppElo,
			Did_Win and oppElo or myElo,
			EloMode
		)

		local myNewElo = Did_Win and newWinnerElo or newLoserElo
		local rawDelta = myNewElo - myElo

		local Elo_Multi = ctx.Monetization_Mod.Get_Elo_Multi(Plr)
		local Final_Elo_Change = math.ceil(rawDelta * Elo_Multi)

		ctx.Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Elo", Final_Elo_Change)

		local msg = Did_Win
			and ("🏆 You won " .. Final_Elo_Change .. " Elo!")
			or  ("❌ You lost " .. math.abs(Final_Elo_Change) .. " Elo!")

		local color = Did_Win and Color3.fromRGB(255,170,0) or Color3.fromRGB(255,60,60)
		Display_Data:FireClient(Plr, msg, color)

		-- Only ranked matches increment these stats
		if Is_Ranked_Match then
			ctx.Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Ranked Matches", 1)
		end
	else
		if ctx.Is_Bot_Fight ~= true then
			ctx.Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Matches", 1)
		end
	end

	-- Wins / Losses
	if Did_Win then
		if Is_Ranked_Match then
			ctx.Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Ranked Wins", 1)
		else
			if ctx.Is_Bot_Fight ~= true then
				ctx.Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Wins", 1)
			end
		end

		if ctx.Is_Bot_Fight ~= true then
			if ctx.Submission_Char.Value ~= nil then
				ctx.Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Submissions Wins", 1)
			else
				local Did_Punch_Last = Plr:GetAttribute("Did_Punch_Last")
				if Did_Punch_Last == false then
					ctx.Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Leg Knockout Wins", 1)
				else
					ctx.Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Punch Knockout Wins", 1)
				end
			end

			ctx.Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Win Streak", 1)

			local Cash_Reward = Is_Ranked_Match and ctx.Fight_Params_Mod.Reward.Ranked_Win_Cash
				or ctx.Fight_Params_Mod.Reward.Standard_Win_Cash
			local Cash_Multi = ctx.Monetization_Mod.Get_Cash_Multi(Plr)
			local Reward = math.ceil(Cash_Reward * Cash_Multi)
			PlayerUtils.RewardPlayer(Plr, "Coins", Reward)
		end
	else
		if ctx.Is_Bot_Fight ~= true then
			ctx.Stats_Manager_Mod.Set_Player_Stats_Data(Plr, "Win Streak", 0)
		end
	end
end

-- move players out of the ring after stats are updated
local function Move_Out_Of_Cage(ctx, Char)
	local Plr = Char['_PLAYER_VALUE_'].Value
	local End_Spawn_P = ctx.Fight_Data_F:WaitForChild("End_Spawn")
	local HRP = Char and Char:FindFirstChild("HumanoidRootPart")

	if Plr and Plr.Character then
		local Chr = Plr.Character
		if Chr.PrimaryPart then

			local IsTutorialRunning = Plr:GetAttribute("IsTutorialRunning")

			-- for tutorial we want to teleport them to the start spawn after the fight is over
			if IsTutorialRunning then
				local spawnLocation = PlayerUtils.GetStartSpawn()
				Chr:PivotTo(spawnLocation.CFrame)
				-- for normal fights we want to teleport them to the end spawn after the fight is over
			else
				Chr:PivotTo(End_Spawn_P.CFrame)
			end

			-- if the character is still anchored, unanchor it
			local hrp2 = Chr:FindFirstChild("HumanoidRootPart")
			if hrp2 then
				hrp2.Anchored = true
				task.spawn(function()
					task.wait(1)
					hrp2.Anchored = false
				end)
			end
		end
	end
end


-- send aggregated fight statistics back to both players
local function Get_Fight_Data(ctx, Winning_Char)
	local Did_C1_Win = (Winning_Char == ctx.Fight_Char_1)

	local Final_C1 = ctx.Stats_Manager_Mod.Create_Fight_Data_Structure(ctx.Fight_Char_1)
	local Final_C2 = ctx.Stats_Manager_Mod.Create_Fight_Data_Structure(ctx.Fight_Char_2)

	local Final_Fight_Data = ctx.Stats_Manager_Mod.Create_Fight_Result_Data(
		ctx.Init_C1_Data,
		ctx.Init_C2_Data,
		Final_C1,
		Final_C2,
		ctx.Win_Data,
		Did_C1_Win
	)

	return Final_Fight_Data
end

local function Process_End_Of_Fight_For_Char(ctx, Char, Winning_Char, Final_Fight_Data)

	local Plr = game.Players:GetPlayerFromCharacter(Char)

	if Char:GetAttribute("UserId") and Plr ~= nil then
		local isBot = Char:GetAttribute("IsBot")
		if not isBot then
			Award_Stats(ctx, Char, Winning_Char)
			Fight_Data_Result:FireClient(Plr, Final_Fight_Data, Winning_Char)
			coroutine.wrap(function()
				task.wait(5)
				End_Fight:FireClient(Plr, GetOpponent(ctx, Char))
				Move_Out_Of_Cage(ctx, Char)
			end)()
		end
	end
end

local function Send_Tournament_Data(ctx, Winning_Char)
	-- Tournament Integration 
	local fightModel = ctx.Fight_M
	if fightModel and fightModel:GetAttribute("Is_Tournament") == true then
		Tournament_Fight_Ended:Fire({
			Players = { ctx.Fight_Char_1, ctx.Fight_Char_2 },
			Winner = Winning_Char,
			Division = ctx.Division or fightModel:GetAttribute("Division"),
			Arena = fightModel
		})
	end
end

-- reset fight data back to an idle state
local function Fight_Data_Reset(ctx)
	ctx.Char_1_V.Value = nil
	ctx.Char_2_V.Value = nil
	ctx.Round_Count_V.Value = 1
	ctx.Round_Wins_V.Value = ""
	ctx.Submission_Char.Value = nil

	task.spawn(function()
		Fight_Loop.Clear_Takedown_Tracking(ctx)
	end)

	if ctx.C1_Health_V then
		task.defer(function()
			task.wait(ROUND_END_DELAY)
			ctx.C1_Health_V.Value = 100
		end)
	end
	if ctx.C2_Health_V then
		task.defer(function()
			task.wait(ROUND_END_DELAY)
			ctx.C2_Health_V.Value = 100
		end)
	end

	if ctx.C1_Stam_V then
		ctx.C1_Stam_V.Value = 100
	end
	if ctx.C2_Stam_V then
		ctx.C2_Stam_V.Value = 100
	end

	if ctx.Is_Bot_Fight then
		task.spawn(function()
			task.wait(ROUND_END_DELAY)
			if ctx.Fight_Char_1 and game.Players:GetPlayerFromCharacter(ctx.Fight_Char_1) == nil then
				ctx.Fight_Char_1:Destroy()
			end
			if ctx.Fight_Char_2 and game.Players:GetPlayerFromCharacter(ctx.Fight_Char_2) == nil then
				ctx.Fight_Char_2:Destroy()
			end
		end)
	end

	ctx.Active_V.Value = false
end

-- no outright winner: prepare for the next round
local function Prepare_Next_Round(ctx)
	task.wait(ROUND_END_DELAY)

	local Plr1 = game.Players:GetPlayerFromCharacter(ctx.Fight_Char_1)
	if Plr1 then
		local Fight_Data_F_Plr = Plr1:FindFirstChild("Fight_Data")
		if Fight_Data_F_Plr then
			local Block_Power_V = Fight_Data_F_Plr:FindFirstChild("Block Power")
			if Block_Power_V then Block_Power_V.Value = 30 end
		end
	end

	local Plr2 = game.Players:GetPlayerFromCharacter(ctx.Fight_Char_2)
	if Plr2 then
		local Fight_Data_F_Plr = Plr2:FindFirstChild("Fight_Data")
		if Fight_Data_F_Plr then
			local Block_Power_V = Fight_Data_F_Plr:FindFirstChild("Block Power")
			if Block_Power_V then Block_Power_V.Value = 30 end
		end
	end

	if ctx.Active_V.Value == true then
		ctx.Round_Count_V.Value += 1
		ctx.Submission_Char.Value = nil
		-- reset takedown tracking so the next round starts fresh
		Fight_Loop.Nullify_Takedown_Tracking(ctx)
		-- teleport fighters back to their starting positions for the new round
		Fight_Initialization.Move_Players_Into_Fight(ctx, false)
	end
end


--------------------------------------------------------
-- DISPATCH FULL MATCH WIN FLOW 
--------------------------------------------------------
local function Process_Full_Victory(ctx, Winning_Char)
	ctx.Disconnect_Cons(ctx.Cons)

	local Final_Fight_Data = Get_Fight_Data(ctx, Winning_Char)

	if ctx.Fight_Char_1 then 
		Process_End_Of_Fight_For_Char(ctx, ctx.Fight_Char_1, Winning_Char, Final_Fight_Data)
	end

	if ctx.Fight_Char_2 then 
		Process_End_Of_Fight_For_Char(ctx, ctx.Fight_Char_2, Winning_Char, Final_Fight_Data)
	end

	Send_Tournament_Data(ctx, Winning_Char)
	Fight_Data_Reset(ctx)
end

--------------------------------------------------------
-- MAIN ENTRY POINT 
--------------------------------------------------------
-- Resolve the winner of a round, update statistics and reset for the
-- next round or end of fight.  Winning_Char is the character that
-- delivered the knockout or otherwise triggered a round end, and
-- End_Fight indicates whether a fighter died (true) or was simply
-- knocked down (false).  All state and services are carried on the
-- context table.
function Fight_End.Victory_Handle(ctx, Winning_Char, Dead_Or_KO)
	local Win_Data = ctx.Win_Data

	-- append the winner’s name to the running list of round winners
	table.insert(Win_Data, Winning_Char.Name)
	ctx.Round_Wins_V.Value = table.concat(Win_Data, ",")

	-- disable takedown tracking for the remainder of the round
	ctx.Takedown_Track.Value = false

	-- determine if the fight as a whole has been won (best of 3 ranked, best of 2 unranked)
	local Winning_Result = Get_Winning_Result(ctx, Winning_Char, Dead_Or_KO)

	-- fire a round result event to the winning player (knockout vs submission)
	task.spawn(function()
		local Was_KO = (ctx.Submission_Char.Value == nil)
		FireToWinnerRound(Winning_Char, Was_KO)
	end)

	-- 5. If match over → full victory flow
	if Winning_Result ~= nil then
		Process_Full_Victory(ctx, Winning_Char)
		return
	end

	-- 6. Otherwise → next round flow
	Prepare_Next_Round(ctx)
end

return Fight_End]]></ProtectedString>
							<string name="ScriptGuid">{04239CF3-FE55-4252-A0BB-C57A975DD3DD}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Fight_End.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6871A03EEFCB483AA3D8AECF77C99E27">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Fight_Params_Mod = require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Cage_Clinch_Start = Channels.SC_Remote_Events.Cage_Clinch_Start
local AI_Training_Cage_Clinch = Channels.Bindable_Events.AI_Training_Cage_Clinch

local Clinch_Sequence = {}

--[[
    Clinch_Sequence

    Encapsulates the "against the cage" clinch logic from the original
    Core_Fight_Handle.server script.  When certain health and stamina
    conditions are met, and fighters are pressed against the cage,
    this module runs a cinematic sequence that drains stamina and
    health.  All state and services are passed in via a context table
    mirroring the local variables of the original script.

    Functions:
      Cage_Control_Handle(context)
        -- monitors fighters during the fight and triggers the cage
        -- clinch sequence when appropriate

    Required context fields:
      Round_Count_V, Fight_Char_1, Fight_Char_2, Submission_Char,
      Takedown_Track, C1_Health_V, C2_Health_V, C1_Stam_V, C2_Stam_V,
      C1_HRP, C2_HRP, Cage_Parts_M, Animation_Mod, Sound_Mod, Active_V.
]]

function Clinch_Sequence.Cage_Control_Handle(context)
	local Prev_Round = 0
	local Distance_To_Cage = 5
	local Max_Opponent_Health = 75
	local Min_Health_To_Trigger = 75
	local Min_Stam_To_Tigger = 50
	local Round_Count_V = context.Round_Count_V
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2
	local Submission_Char = context.Submission_Char
	local Takedown_Track = context.Takedown_Track
	local C1_Health_V = context.C1_Health_V
	local C2_Health_V = context.C2_Health_V
	local C1_Stam_V = context.C1_Stam_V
	local C2_Stam_V = context.C2_Stam_V
	local C1_HRP = context.C1_HRP
	local C2_HRP = context.C2_HRP
	local Cage_Parts_M = context.Cage_Parts_M
	local Animation_Mod = context.Animation_Mod
	local Sound_Mod = context.Sound_Mod
	local Active_V = context.Active_V

	-- play the full clinch sequence for the attacking and defending characters
	local function Against_The_Cage_Sequence(Attacking_Char, Bad_Char, Cage_Pos)
		local Attacking_Offset_CF = CFrame.new(Vector3.new(0.8270339965820312, 0, -4.329065322875977)) * CFrame.Angles(math.rad(180), 0, math.rad(180))
		Prev_Round = Round_Count_V.Value
		-- lock players in place against the cage
		local function Lock_Players_Down()
			local function Move_Bad_Char()
				local Bad_Char_HRP = Bad_Char:FindFirstChild("HumanoidRootPart")
				if Bad_Char_HRP ~= nil then
					local Rot = Bad_Char_HRP.CFrame.Rotation
					Bad_Char_HRP.CFrame = CFrame.new(Cage_Pos) * Rot
					Bad_Char_HRP.Anchored = true
					return Bad_Char_HRP
				end
				return nil
			end
			local Bad_Char_HRP = Move_Bad_Char()
			if Bad_Char_HRP ~= nil then
				local function Move_Attacking_Char()
					local Attack_HRP = Attacking_Char:FindFirstChild("HumanoidRootPart")
					if Attack_HRP ~= nil then
						Attack_HRP.CFrame = Bad_Char_HRP.CFrame:ToWorldSpace(Attacking_Offset_CF)
						Attack_HRP.Anchored = true
					end
				end
				Move_Attacking_Char()
			end
			return Bad_Char_HRP
		end
		local Bar_Char_HRP = Lock_Players_Down()
		-- trigger animations and camera effects for both fighters
		local function Start_Client_Effects()
			local function Get_Cam_Clinch_CF()
				local CF_Offset = CFrame.new(Vector3.new(-7.615234375, 5.331428527832031, -7.482333183288574)) * CFrame.Angles(math.rad(-140), math.rad(-40), math.rad(-155))
				if Bar_Char_HRP ~= nil then
					return Bar_Char_HRP.CFrame:ToWorldSpace(CF_Offset)
				end
				return CF_Offset
			end
			local Cam_Clinch_CF = Get_Cam_Clinch_CF()
			local Sequence_Keys = Animation_Mod.Generate_Clinch_Attack_Keys()
			-- notify the attacking player
			local function Init_Attacking_Player()
				if Attacking_Char ~= nil then
					local Attack_Plr = game.Players:GetPlayerFromCharacter(Attacking_Char)
					if Attack_Plr ~= nil then
						Cage_Clinch_Start:FireClient(Attack_Plr, Sequence_Keys, true, Cam_Clinch_CF)
					else
						AI_Training_Cage_Clinch:Fire(Attacking_Char, Sequence_Keys, true)
					end
				end
			end
			task.spawn(Init_Attacking_Player)
			-- notify the defending player
			local function Init_Bad_Player()
				if Bad_Char ~= nil then
					local Bad_Plr = game.Players:GetPlayerFromCharacter(Bad_Char)
					if Bad_Plr ~= nil then
						Cage_Clinch_Start:FireClient(Bad_Plr, Sequence_Keys, false, Cam_Clinch_CF)
					else
						AI_Training_Cage_Clinch:Fire(Bad_Char, Sequence_Keys, false)
					end
				end
			end
			task.spawn(Init_Bad_Player)
			-- wait for the introduction animations
			wait(2.3)
			for i = 1, 5 do
				if Bar_Char_HRP ~= nil then
					Sound_Mod.PlaySFX(Bar_Char_HRP, "Punch_Hit_SE")
				end
				wait(1)
			end
		end
		Start_Client_Effects()
		-- handle stamina and health adjustments post sequence
		local function End_Sequence_Handle()
			local function Attacking_Char_Handle()
				if Attacking_Char ~= nil then
					local A_HRP = Attacking_Char:FindFirstChild("HumanoidRootPart")
					if A_HRP ~= nil then
						A_HRP.Anchored = false
					end
					if Fight_Char_1 ~= nil and Attacking_Char == Fight_Char_1 and C1_Stam_V ~= nil then
						C1_Stam_V.Value = math.clamp(C1_Stam_V.Value - 25, 0, 100)
					elseif Fight_Char_2 ~= nil and Attacking_Char == Fight_Char_2 and C2_Stam_V ~= nil then
						C2_Stam_V.Value = math.clamp(C2_Stam_V.Value - 25, 0, 100)
					end
				end
			end
			Attacking_Char_Handle()
			local function Bad_Char_Handle()
				if Bad_Char ~= nil then
					local B_HRP = Bad_Char:FindFirstChild("HumanoidRootPart")
					if B_HRP ~= nil then
						B_HRP.Anchored = false
					end
					if Fight_Char_1 ~= nil and Bad_Char == Fight_Char_1 and C1_Health_V ~= nil then
						C1_Health_V.Value -= 25
					elseif Fight_Char_2 ~= nil and Bad_Char == Fight_Char_2 and C2_Health_V ~= nil then
						C2_Health_V.Value -= 25
					end
				end
			end
			Bad_Char_Handle()
		end
		End_Sequence_Handle()
		wait(5)
	end
	-- evaluate whether the clinch sequence should trigger
	local function Detection_Result()
		if Prev_Round < Round_Count_V.Value and Fight_Char_1 ~= nil and Fight_Char_2 ~= nil and Submission_Char ~= nil and Submission_Char.Value == nil and Takedown_Track ~= nil and Takedown_Track.Value == false then
			-- test if a character is pressed against the cage
			local function Get_Attacking_Player()
				local function Is_Against_The_Cage(C_HRP, dist)
					local Dir = -1 * C_HRP.CFrame.LookVector * dist
					local Ray_Parms = RaycastParams.new()
					Ray_Parms.FilterDescendantsInstances = {Cage_Parts_M}
					Ray_Parms.FilterType = Enum.RaycastFilterType.Include
					Ray_Parms.IgnoreWater = true
					local Ray_Res = game.Workspace:Raycast(C_HRP.Position, Dir, Ray_Parms)
					if Ray_Res ~= nil and Ray_Res.Position ~= nil then
						return true, Ray_Res.Position
					end
					return false, nil
				end
				if C1_Health_V.Value <= Max_Opponent_Health and C1_HRP ~= nil and C2_Stam_V.Value >= Min_Stam_To_Tigger and C2_Health_V.Value > Min_Health_To_Trigger then
					local Is_Back_To_Cage, Pos = Is_Against_The_Cage(C1_HRP, Distance_To_Cage)
					if Is_Back_To_Cage == true and Pos ~= nil then
						return Fight_Char_2, Fight_Char_1, Pos
					end
				end
				if C2_Health_V.Value <= Max_Opponent_Health and C2_HRP ~= nil and C1_Stam_V.Value >= Min_Stam_To_Tigger and C1_Health_V.Value > Min_Health_To_Trigger then
					local Is_Back_To_Cage, Pos = Is_Against_The_Cage(C2_HRP, Distance_To_Cage)
					if Is_Back_To_Cage == true and Pos ~= nil then
						return Fight_Char_1, Fight_Char_2, Pos
					end
				end
				return nil, nil, nil
			end
			local Attacking_Player, Bad_Player, Cage_Pos = Get_Attacking_Player()
			if Attacking_Player ~= nil and Bad_Player ~= nil and Cage_Pos ~= nil then
				Against_The_Cage_Sequence(Attacking_Player, Bad_Player, Cage_Pos)
			end
		end
	end
	-- repeatedly check for clinch conditions while the fight is active
	if Fight_Params_Mod.CageClinch.Active then
		while Active_V ~= nil and Active_V.Value == true do
			Detection_Result()
			wait(1)
		end
	end
end

return Clinch_Sequence]]></ProtectedString>
							<string name="ScriptGuid">{C7C6D789-C71A-4F7C-AC57-EA3D10322031}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Server_Clinch_Sequence.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX10F976214879456E901D2EDE1466BA87">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Fight_Params_Mod = require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Submission_Minigame_Update = Channels.SC_Remote_Events.Submission_Minigame_Update
local AI_Training_Submission = Channels.Bindable_Events.AI_Training_Submission

local Submission_Params = Fight_Params_Mod.Submission_Minigame

local Submission_Minigame = {}

--[[
    Submission_Minigame

    This module contains the chokehold mini–game logic that is invoked
    whenever a takedown transitions the fight to the ground.  It
    faithfully reproduces the original `Submission_Handle` function
    from Core_Fight_Handle.server, but parameterises all references
    through the provided context table.  No behavioural changes have
    been made; the module simply organises the code into a reusable
    function.

    Functions:
      Submission_Handle(context, Submission_Plr)
        -- initiates and runs the chokehold mini–game for the
        -- submitting player

    The context table must include at least the following fields:
      Fight_Char_1, Fight_Char_2, C1_HRP, C2_HRP, C1_Health_V, C2_Health_V,
      C1_Stam_V, C2_Stam_V, Submission_Char, C1_Clicked_E, C2_Clicked_E,
      Submission_Minigame, Stats_Manager_Mod, 
      Is_Bot_Fight, Animation_Mod, Disconnect_Cons, Cons, and Monetization_Mod.

    It also requires the Toggle_Players_Damage_Bars and New_Animation_Handle
    helpers which are defined locally below to mirror their counterparts
    in the original script.
]]

-- enable or disable the damage UI on a fighter
local function Toggle_Players_Damage_Bars(Char, Is_Enabled)
	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	if Fight_UI ~= nil then
		Fight_UI.Enabled = Is_Enabled
	end
end

-- weld and reposition fighters for the chokehold mini–game
local function New_Animation_Handle(context, T_Char, R_Char, Submission_Plr)
	local destructor = function() end
	local T_HRP = T_Char:FindFirstChild("HumanoidRootPart")
	local R_HRP = R_Char:FindFirstChild("HumanoidRootPart")
	local function Assert_Check()
		return T_HRP ~= nil and R_HRP ~= nil and Submission_Plr.Character ~= nil
	end
	if Assert_Check() then
		local Takedown_Data, Submission_Data = context.Animation_Mod.Get_Takedown_Submission_Data(Submission_Plr.Character)
		local R_CF_Origin = R_HRP.CFrame
		T_HRP.CFrame = R_CF_Origin:ToWorldSpace(Takedown_Data['CF Offset'])
		local weld = Instance.new("Weld")
		weld.Part0 = R_HRP
		weld.Part1 = T_HRP
		weld.C0 = Takedown_Data['CF Offset']
		weld.Parent = R_HRP
		Toggle_Players_Damage_Bars(T_Char, false)
		Toggle_Players_Damage_Bars(R_Char, false)
		destructor = function()
			weld:Destroy()
		end
		task.spawn(function()
			task.wait(Takedown_Data['Time Length'] + 0.25)
			if Assert_Check() then
				T_HRP.CFrame = R_CF_Origin:ToWorldSpace(Submission_Data['CF Offset'])
				weld.C0 = Submission_Data['CF Offset']
			end
		end)
	end
	return destructor
end

-- primary entry point: run the submission mini–game for the given player
function Submission_Minigame.Submission_Handle(context, Submission_Plr)
	local WAIT_INTERVAL = 0.2
	local gameCounter = 0
	local games = {}
	local Cons = context.Cons
	local Disconnect_Cons = context.Disconnect_Cons
	local Stats_Manager_Mod = context.Stats_Manager_Mod
	local Is_Bot_Fight = context.Is_Bot_Fight
	local Fight_Char_1 = context.Fight_Char_1
	local Fight_Char_2 = context.Fight_Char_2
	local C1_Health_V = context.C1_Health_V
	local C2_Health_V = context.C2_Health_V
	local C1_Stam_V = context.C1_Stam_V
	local C2_Stam_V = context.C2_Stam_V
	local Submission_Char = context.Submission_Char
	local C1_Clicked_E = context.C1_Clicked_E
	local C2_Clicked_E = context.C2_Clicked_E
	local C1_HRP = context.C1_HRP
	local C2_HRP = context.C2_HRP
	-- helper to fetch thumbnails for players
	local function FetchThumbnail(player)
		if player == nil then
			return "rbxassetid://80237311442114"
		end
		local userId = player.UserId
		local thumbType = Enum.ThumbnailType.HeadShot
		local thumbSize = Enum.ThumbnailSize.Size420x420
		local success, result = pcall(function()
			return game.Players:GetUserThumbnailAsync(userId, thumbType, thumbSize)
		end)
		if success then
			return result
		else
			warn("Thumbnail fetching for ", player.Name , " has failed, resulting to default")
			return "rbxthumb://type=AvatarHeadShot&id=1233225830&w=420&h=420"
		end
	end
	-- create and run a chokehold game between two characters
	local function StartChokehold(player1Char, player2Char)
		-- derive Player objects for characters if possible
		local player1 = game.Players:GetPlayerFromCharacter(player1Char)
		local player2 = game.Players:GetPlayerFromCharacter(player2Char)
		local thumbnail1 = FetchThumbnail(player1)
		local thumbnail2 = FetchThumbnail(player2)
		local myGame = {
			player1 = player1 or player1Char,
			player2 = player2 or player2Char,
			score = Submission_Params.Initial_Score,
			status = "Running",
			gameID = gameCounter,
			destructor = nil
		}
		-- update the game score based on which fighter clicks
		local function On_Click_Update(P_Char)
			if P_Char ~= nil then
				if P_Char == Fight_Char_1 then
					myGame.score -= 1
				end

				if P_Char == Fight_Char_2 then
					myGame.score += 1
				end
			end
			
			--print(P_Char.Name.." clicked		>> new score : "..myGame.score)
		end
		
		-- click rate varies depending on device and bot status
		local MIN_INTERVAL = 1/15
		local isBotFight = Is_Bot_Fight or player1 == nil or player2 == nil
		if not isBotFight then
			local Device_Atrib_p1 = player1:GetAttribute("Device")
			local Device_Atrib_p2 = player2:GetAttribute("Device")
			if Device_Atrib_p1 == "Mobile" and Device_Atrib_p2 == "Mobile" then
				MIN_INTERVAL = 1/20
			end
		end
		local lastClick2 = os.clock()
		local lastClick1 = os.clock()
		local C1_Con = C1_Clicked_E.OnServerEvent:Connect(function(player)
			if os.clock() - lastClick1 >= MIN_INTERVAL then
				On_Click_Update(player.Character)
				lastClick1 = os.clock()
			end
		end)
		local C2_Con = C2_Clicked_E.OnServerEvent:Connect(function(player)
			if os.clock() - lastClick2 >= MIN_INTERVAL then
				On_Click_Update(player.Character)
				lastClick2 = os.clock()
			end
		end)
		-- record connections for later cleanup
		table.insert(Cons, C1_Con)
		table.insert(Cons, C2_Con)
		local Choke_Cons = {}
		table.insert(Choke_Cons, C1_Con)
		table.insert(Choke_Cons, C2_Con)
		-- choose the receiving character based on who initiated the submission
		local function Get_R_Char()
			if Fight_Char_1 ~= nil and Submission_Char.Value == Fight_Char_1 then
				return Fight_Char_2
			else
				return Fight_Char_1
			end
		end
		local R_Char = Get_R_Char()
		-- weld fighters together for the submission animation
		local weldDestructor = New_Animation_Handle(context, Submission_Plr.Character, R_Char, Submission_Plr)
		myGame.destructor = weldDestructor
		-- optional AI clicking for bots
		local Bot_C = nil
		local function AI_Clicking_Handle(Bot_Char)
			if Submission_Plr.Character ~= nil then
				AI_Training_Submission:Fire(Bot_Char, Submission_Plr.Character, true)
			end
			Bot_C = Bot_Char
			
			local Minigame_Params = Fight_Params_Mod.Submission_Minigame
			local IsTutorialRunning = Submission_Plr:GetAttribute("IsTutorialRunning")
			local Click_Time_Delay = IsTutorialRunning and Minigame_Params.Coach_Bot_ClickDelay or Minigame_Params.Bot_ClickDelay
			while myGame.status == "Running" and Bot_Char ~= nil do
				On_Click_Update(Bot_Char)
				wait(Click_Time_Delay)
			end
		end
		
		-- initialise the UI for both players or bot
		if player1 ~= nil then
			Submission_Minigame_Update:FireClient(
				player1, 
				"START", 
				{
					imageIDs = {thumbnail1, thumbnail2}, 
					flip = true, 
					P1 = player1, 
					P2 = player2
				}, 
				C1_Clicked_E)
		elseif Is_Bot_Fight == true and player1 == nil and Fight_Char_1 ~= nil then
			task.spawn(AI_Clicking_Handle, Fight_Char_1)
		end
		
		
		if player2 ~= nil then
			Submission_Minigame_Update:FireClient(
				player2, 
				"START", 
				{
					imageIDs = {thumbnail1, thumbnail2}, 
					flip = false, 
					P1 = player1, 
					P2 = player2
				},
				C2_Clicked_E)
		elseif Is_Bot_Fight == true and player2 == nil and Fight_Char_2 ~= nil then
			task.spawn(AI_Clicking_Handle, Fight_Char_2)
		end
		-- core game loop: update the score and apply outcomes
		task.defer(function()
			while myGame.status == "Running" do
				task.wait(WAIT_INTERVAL)
				if myGame.score >= Submission_Params.Winning_Score then
					myGame.status = "Ended"
					
					if player2 ~= nil and player2 == Submission_Plr then
						C1_Health_V.Value = -10
						Stats_Manager_Mod.Add_To_Player_Stats_Data(Submission_Plr, "Submissions Finished", 1)
						
					else
						if C2_Stam_V ~= nil then
							C2_Stam_V.Value = math.clamp(C2_Stam_V.Value * 0.65, 25, 100)
						end
						if C1_Stam_V ~= nil then
							C1_Stam_V.Value = math.clamp(C1_Stam_V.Value * 0.65, 25, 100)
						end
						if C1_Health_V ~= nil then
							C1_Health_V.Value = math.clamp(C1_Health_V.Value * 0.75, 25, 100)
						end
						Submission_Char.Value = nil
					end
					
					break
				elseif myGame.score <= Submission_Params.Loosing_Score then
					myGame.status = "Ended"
					
					if player1 ~= nil and player1 == Submission_Plr then
						C2_Health_V.Value = -10
						Stats_Manager_Mod.Add_To_Player_Stats_Data(Submission_Plr, "Submissions Finished", 1)
					else
						if C1_Stam_V ~= nil then
							C1_Stam_V.Value = math.clamp(C1_Stam_V.Value * 0.65, 25, 100)
						end
						if C2_Stam_V ~= nil then
							C2_Stam_V.Value = math.clamp(C2_Stam_V.Value * 0.65, 25, 100)
						end
						if C2_Health_V ~= nil then
							C2_Health_V.Value = math.clamp(C2_Health_V.Value * 0.75, 25, 100)
						end
						Submission_Char.Value = nil
					end
					break
				end
				if player1 ~= nil then
					C1_Clicked_E:FireClient(player1, {gameProgress = myGame.score})
				end
				if player2 ~= nil then
					C2_Clicked_E:FireClient(player2, {gameProgress = myGame.score})
				end
			end
			-- unwind weld and clean up after the game ends
			weldDestructor()
			local Old_Mid_Point = Submission_Char:FindFirstChild("Midpoint")
			if Old_Mid_Point ~= nil then
				Old_Mid_Point:Destroy()
			end
			if player1 ~= nil then
				Submission_Minigame_Update:FireClient(player1, "STOP")
			end
			if player2 ~= nil then
				Submission_Minigame_Update:FireClient(player2, "STOP")
			end
			myGame.status = "Ended"
			Disconnect_Cons(Choke_Cons)
			if Fight_Char_1 ~= nil then
				Toggle_Players_Damage_Bars(Fight_Char_1, true)
				if C1_HRP ~= nil then
					C1_HRP.Anchored = false
				end
			end
			if Fight_Char_2 ~= nil then
				Toggle_Players_Damage_Bars(Fight_Char_2, true)
				if C2_HRP ~= nil then
					C2_HRP.Anchored = false
				end
			end
			if Is_Bot_Fight and Bot_C ~= nil then
				AI_Training_Submission:Fire(Bot_C, nil, false)
			end
		end)
		games[gameCounter] = myGame
		gameCounter = gameCounter + 1
		return myGame
	end
	-- immediately start a chokehold for the submitting player against the opponent
	if Fight_Char_1 ~= nil and Fight_Char_2 ~= nil then
		StartChokehold(Fight_Char_1, Fight_Char_2)
	end
end

return Submission_Minigame]]></ProtectedString>
							<string name="ScriptGuid">{84F407FB-A08D-4272-AD75-9FF62B1A8BCA}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Server_Submission_Minigame.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXFDCEAF0441994D6EA159F4CBA1D76271">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Fight_Service/Fight_Spawn_Manager.server.lua
--
--  Description:
--      Central server-side handler responsible for all pre-fight logic:
--      player spawning into cages, slot assignment, UI states, bot
--      creation, invite notifications, ranked restrictions, and
--      auto-launching the fight when both slots are valid.
--
--      Core Responsibilities:
--          • Detect players entering cage spawn pads
--          • Populate Fight_Char_1 / Fight_Char_2 dynamically
--          • Render UI preview (rank, icon, display name, glow colors)
--          • Handle invite button injection / cleanup
--          • Validate ranked-match rules (Elo proximity)
--          • Automatically start fights via Start_Core_Fight
--          • Support bot fights (training, tutorial, No_Bots rules)
--          • Reset empty slots when players walk away
--          • Send invite notifications to all players
--          • Handle mini-tutorial state updates
--
--  Last Modified: 2025-09-30
--  Version: V2025-09
--
--  Dependencies:
--      ReplicatedStorage:
--          - Data_Mods_F:
--              Bots_Mod, Elo_Mod
--          - Modules:
--              Channels, Utils, PlayerUtils
--          - Design/ThemeManager
--
--      ServerScriptService:
--          - Fight_Service/TemplateUIs
--
--      Workspace:
--          - Main_World_F.Gameplay.Objects.Fight_Cages_F
--
--      Internal:
--          - Bots_Manager (child of this script)
--
--  Notes:
--      • This script handles ONLY the pre-fight and cage logic.
--      • The actual fight sequence is executed by Core_Fight_Handler.
--      • Bot behaviors rely on Bots_Mod profiles and Bots_Manager.
--======================================================================

----- MODULES -----
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Fight_Params_Mod 			= require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local Bots_Mod = require(Data_Mods_F:WaitForChild("Bots_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Cage_Factory = require(Data_Mods_F:WaitForChild("Cage_Factory"))
local Bots_Manager = require(script:WaitForChild("Bots_Manager"))
local ThemeManager = require(game.ReplicatedStorage.Design.ThemeManager)
local Utils = require(game.ReplicatedStorage.Modules.Utils)
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

----- EVENTS -----
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Elo_Rank_Dif = Channels.SC_Remote_Events.Elo_Rank_Dif
local Start_Core_Fight = Channels.Bindable_Events.Start_Core_Fight
local Create_Training_Bot = Channels.CS_Remote_Functions.Create_Training_Bot
local Destroy_Training_Bot = Channels.CS_Remote_Functions.Destroy_Training_Bot
local Fight_Spawn_Notification = Channels.SC_Remote_Events.Fight_Spawn_Notification
local Send_Invite_Notification = Channels.CS_Remote_Functions.Send_Invite_Notification

----- ASSETS -----
local Invite_Buttons_UI = game.ServerScriptService:WaitForChild("Fight_Service"):WaitForChild("TemplateUIs"):WaitForChild("Invite_Buttons_UI")
local Player_Display_UI = game.ServerScriptService:WaitForChild("Fight_Service"):WaitForChild("TemplateUIs"):WaitForChild("Player_Display_UI")


local function Fight_Spawn_Handle(M)
	local Data_F = M:WaitForChild("Fight_Data_F")
	local Active_Fight_V = Data_F:WaitForChild("Active_Fight")
	local Fight_Char_1_V = Data_F:WaitForChild("Fight_Char_1")
	local Fight_Char_2_V = Data_F:WaitForChild("Fight_Char_2")
	local Fight_M1 = M:WaitForChild("Fighter_1")
	local Fight_M2 = M:WaitForChild("Fighter_2")
	local Is_Ranked_Fight = (M:GetAttribute("Cage_Type") or "") == "RANKED"

	local Occupied_Spawns = {

	}
	
	local function Reset_Spawn_M(FM, Char_V)
		local Main_P = FM:FindFirstChild("Main_P")
		local B1, B2 = Main_P:FindFirstChild("B1"), Main_P:FindFirstChild("B2")
		
		local Display_UI = Main_P:FindFirstChild("Player_Display_UI") or Player_Display_UI:Clone()
		Display_UI.Adornee = Main_P
		Display_UI.Parent = Main_P
	
		local Empty_Txt = Display_UI:FindFirstChild("Empty_Txt")
		local Player_F = Display_UI:FindFirstChild("Player_F")
		local Outline_P = FM:FindFirstChild("Outline_P")
		local Rot_P = FM:FindFirstChild("Rot_Part")
		local QueueGlow = FM:FindFirstChild("QueueGlow")
		local QueueNeon = FM:FindFirstChild("QueueNeon")

		Player_F.Visible = false
		Empty_Txt.Visible = true

		local Col_Seq = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Color3.fromRGB(248, 248, 248)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(248, 248, 248))
		}
		B1.Color = Col_Seq
		B2.Color = Col_Seq
		Rot_P.Color = Color3.fromRGB(248, 248, 248)
		Outline_P.Color = Color3.fromRGB(248, 248, 248)
		QueueGlow.Color = Color3.fromRGB(207, 172, 169)
		QueueNeon.Color = Color3.fromRGB(207, 172, 169)

		local Prev_Char = Char_V.Value
		if(Prev_Char ~= nil and game.Players:GetPlayerFromCharacter(Prev_Char) ~= nil)then
			--Remove the Player's Invite Buttons from Client
			local Prev_Plr = game.Players:GetPlayerFromCharacter(Prev_Char)
			local PG = Prev_Plr:FindFirstChild("PlayerGui")
			local Prev_Player_Invite_Buttons_UI = PG:WaitForChild("Fight"):FindFirstChild("Invite_Buttons_UI")
			if(PG ~= nil and Prev_Player_Invite_Buttons_UI ~= nil)then
				Prev_Player_Invite_Buttons_UI:Destroy()
			end
		end

		Display_UI.PlayerToHideFrom = nil
		Char_V.Value = nil
	end

	local function Verify_Hit_Part(hit)
		if(hit ~= nil and hit.Parent ~= nil and game.Players:GetPlayerFromCharacter(hit.Parent) ~= nil 
			and PlayerUtils.Is_Player_Fighting(hit.Parent) == false)then			
			return game.Players:GetPlayerFromCharacter(hit.Parent), hit.Parent
		end

		return nil, nil
	end

	local function Process_Fighter_Touch(FM, Char_V)
		
		Reset_Spawn_M(FM, Char_V)
		
		local Main_P = FM:WaitForChild("Main_P")
		local B1, B2 = Main_P:WaitForChild("B1"), Main_P:WaitForChild("B2")
		local Display_UI = Main_P:WaitForChild("Player_Display_UI")
		local Empty_Txt = Display_UI:WaitForChild("Empty_Txt")
		local Player_F = Display_UI:WaitForChild("Player_F")
		local Outline_P = FM:WaitForChild("Outline_P")
		local Rot_P = FM:WaitForChild("Rot_Part")
		local QueueGlow = FM:FindFirstChild("QueueGlow")
		local QueueNeon = FM:FindFirstChild("QueueNeon")
		local Touch_P = FM:WaitForChild("Touch_P")
		local Is_Ranked_Match = (M:GetAttribute("Cage_Type") or "") == "RANKED"
		local Debounce_H = false
		local Debounce_Elo_Dif = false

		local function New_Fighter_Added(Plr, Char)
			if(Plr ~= nil and Char ~= nil)then
				Empty_Txt.Visible = false

				local colorHex = ThemeManager.getAttribute("cages.PlayerSpawnGlowColor.Color")
				local Select_Col = colorHex and Color3.fromHex(colorHex) or Color3.new(1, 1, 1)

				if(Is_Ranked_Match ~= nil and Is_Ranked_Match)then
					Select_Col = Color3.new(1, 0, 0)
				end

				local Col_Seq = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Select_Col),
					ColorSequenceKeypoint.new(1, Select_Col)
				}
				B1.Color = Col_Seq
				B2.Color = Col_Seq
				Rot_P.Color = Select_Col
				Outline_P.Color = Select_Col
				QueueGlow.Color = Select_Col
				QueueNeon.Color = Select_Col

				local function Update_Player_Data_F()
					local Rank_Data, Elo_Amount = Elo_Mod.Get_Player_Rank_Data(Plr)
					local Rank_F = Player_F:FindFirstChild("Rank_F")
					local Rank_Img = Rank_F:FindFirstChild("Rank_Img")
					local Rank_Txt = Rank_F:FindFirstChild("Rank_Txt")
					local Rank_Col = Rank_Data['Color'] or Color3.fromRGB(170, 170, 127)
					local Plr_Icon = PlayerUtils.Get_Player_Image(Plr.UserId)
					Rank_Img.Image = Rank_Data['Icon'] or "rbxassetid://89194867048049"
					Rank_Img.ImageColor3 = Rank_Col
					Rank_Txt.Text = Utils.Format_Number(Elo_Amount) .. ""
					Rank_Txt.TextColor3 = Rank_Col
					Rank_F.Visible = true

					Player_F:FindFirstChild("Player_Name").Text = Plr.Name
					Player_F:FindFirstChild("Display_Name").Text = "@" .. Plr.DisplayName
					Player_F:FindFirstChild("Icon_F"):FindFirstChild("Player_Img").Image = Plr_Icon

					Display_UI.PlayerToHideFrom = Plr
					Player_F.Visible = true	

					return {
						['Name'] = Plr.Name, 
						['Rank Icon'] = Rank_Img.Image,
						['Rank Color'] = Rank_Col,
						['Rank Value'] = Rank_Txt.Text,
						['Player Icon'] = Plr_Icon,

						['Main_Char_V'] = Char_V,
						['Char_V1'] = Fight_Char_1_V,
						['Char_V2'] = Fight_Char_2_V,
						['Active_V'] = Active_Fight_V
					}
				end
				Update_Player_Data_F()

				local function Add_Player_Invite_Buttons()
					local PG = Plr:FindFirstChild("PlayerGui")
					local New_Player_Invite_Buttons_UI = PG:WaitForChild("Fight"):FindFirstChild("Invite_Buttons_UI")

					if(PG ~= nil)then
						if New_Player_Invite_Buttons_UI ~= nil then
							New_Player_Invite_Buttons_UI:Destroy()
						end
						local New_Invite_Buttons = Invite_Buttons_UI:Clone()
						New_Invite_Buttons:WaitForChild("Cage_M").Value = M
						New_Invite_Buttons:WaitForChild("No_Bots").Value = M:GetAttribute("No_Bots")
						New_Invite_Buttons.Adornee = Main_P
						New_Invite_Buttons.Parent = PG:WaitForChild("Fight")						
					end
				end
				Add_Player_Invite_Buttons()

				Char_V.Value = Char

				--If both Char Values are filled ~ Start the Fight
				--> Else, tell the whole server that the 2nd Fight Slot is vacant

				Occupied_Spawns[FM] = {
					['Model'] = FM,
					['Char_V'] = Char_V,
					['Main Char'] = Char,
					['Touch_P'] = Touch_P,
					['Active_V'] = Active_Fight_V
				}

				local function Process_Ranked_Match_Check(C1, C2)
					if(Is_Ranked_Fight ~= nil and Is_Ranked_Fight == true)then
						local P_C1 = game.Players:GetPlayerFromCharacter(C1)
						local P_C2 = game.Players:GetPlayerFromCharacter(C2)

						if(P_C1 ~= nil and P_C2 ~= nil)then
							if not Elo_Mod.Adjacent_Elo_Ranks(P_C1, P_C2) then 
								if(Debounce_Elo_Dif == false)then
									task.spawn(function()
										Debounce_Elo_Dif = true
										Elo_Rank_Dif:FireClient(P_C1, P_C2)
										Elo_Rank_Dif:FireClient(P_C2, P_C1)
										task.wait(3)
										Debounce_Elo_Dif = false
									end)
								end
								return false
							else 
								return true
							end
						end
					end

					return true
				end

				if(Fight_Char_1_V.Value ~= nil and Fight_Char_2_V.Value ~= nil and 
					Fight_Char_1_V.Value ~= Fight_Char_2_V.Value and Active_Fight_V.Value == false)then

					if(Process_Ranked_Match_Check(Fight_Char_1_V.Value, Fight_Char_2_V.Value))then
						M:SetAttribute("Bot_Fight", false)
						Start_Core_Fight:Fire(M, Fight_Char_1_V.Value, Fight_Char_2_V.Value)
						Display_UI.PlayerToHideFrom = nil
					end
				end
			else
				Reset_Spawn_M(FM, Char_V)
			end
		end

		Touch_P.Touched:Connect(function(hit)
			if hit.Name ~= "HumanoidRootPart" then
				return
			end

			if(Active_Fight_V.Value == false and Debounce_H == false and Char_V.Value == nil and 
				hit ~= nil and hit.Parent ~= nil)then
				Debounce_H = true

				local Plr, Char = Verify_Hit_Part(hit)
				if(Plr ~= nil and Char ~= nil and Fight_Char_1_V.Value ~= Char 
					and Fight_Char_2_V.Value ~= Char)then

					New_Fighter_Added(Plr, Char)
					task.wait(0.25)
				end
				Debounce_H = false
			end
		end)
	end
	Process_Fighter_Touch(Fight_M1, Fight_Char_1_V)
	Process_Fighter_Touch(Fight_M2, Fight_Char_2_V)

	local function Check_Removal()	
		local function Delete_Old_Fight_Teleports()
			local All_P = game.Players:GetPlayers()

			for i = 1, #All_P do
				local P = All_P[i]
				if(P ~= nil and P:FindFirstChild("PlayerGui") ~= nil)then
					local PG = P:FindFirstChild("PlayerGui")					
					local Invite_Buttons_UI = PG:WaitForChild("Fight"):FindFirstChild("Invite_Buttons_UI")
					if(Invite_Buttons_UI ~= nil and Invite_Buttons_UI:FindFirstChild("Cage_Name").Value == M.Name)then
						Invite_Buttons_UI:Destroy()
					end
				end
			end
		end
		
		local function Switch_To_Empty_Label()
			local Fighters = {Fight_M1, Fight_M2}
			for _,FM in pairs(Fighters) do
				local Main_P = FM:FindFirstChild("Main_P")
				local Display_UI = Main_P:FindFirstChild("Player_Display_UI")
				if Display_UI then
					local Empty_Txt = Display_UI:FindFirstChild("Empty_Txt")
					local Player_F = Display_UI:FindFirstChild("Player_F")
					Empty_Txt.Visible = true
					Player_F.Visible = false
				end
			end
		end
		
		Active_Fight_V.Changed:Connect(function()
			if(Active_Fight_V.Value == false)then
				Delete_Old_Fight_Teleports()
				Switch_To_Empty_Label()
			end
		end)

		local function Should_Reset_Occupied_Slot()
			local function Check_Char_In_Region(Char, Touch_P)
				local Overlap_P = OverlapParams.new()
				Overlap_P.FilterType = Enum.RaycastFilterType.Include
				Overlap_P.FilterDescendantsInstances = {Char}
				Overlap_P.MaxParts = 50

				local Region_Data = game.Workspace:GetPartsInPart(Touch_P, Overlap_P)
				if(Region_Data ~= nil and #Region_Data > 0)then
					return true
				end

				return false
			end

			for FM, Data in next, Occupied_Spawns do
				local Active_V = Data['Active_V']
				if(Active_V ~= nil and Active_V.Value == false)then
					--Check the Distance or if the HRP is nil
					local Char_V = Data['Char_V']
					local Touch_P = Data['Touch_P']
					local Main_Char = Data['Main Char']

					if(Char_V ~= nil and Touch_P ~= nil and (Main_Char ~= nil and 
						Check_Char_In_Region(Main_Char, Touch_P) == false) or Main_Char == nil)then

						--Reset, not in Region
						Reset_Spawn_M(FM, Char_V)

						--Remove from Occupied
						Occupied_Spawns[FM] = nil
					end
				end
			end
		end

		while task.wait(0.1) do
			--Handle Resetting Slots of the Player jumps offs
			Should_Reset_Occupied_Slot()
		end
	end
	task.spawn(Check_Removal)
end


--======================================================================
--  Called remotely by the client (via the "Bot Fight" button) to
--  request spawning of a training bot inside the specified cage.
--
--  Parameters:
--      cageName (string) : The name of the fight cage where the player requested a bot.
--      botProfile (string) : The type of bot to spawn (e.g., "NORMAL", "COACH").
--
--  Behavior:
--      1. Locates the cage model in the workspace.
--      2. Determines which fighter slot (Fight_Char_1 or Fight_Char_2)
--         is vacant and can receive a bot.
--      3. Calls Bots_Manager.SpawnBotInCage() to instantiate the bot.
--      4. Validates that both characters are now present in the cage.
--      5. Fires Start_Core_Fight to begin the fight between the player
--         and the bot.
--
--  Returns:
--      (bool, string?)
--          true if the bot was created successfully.
--          false and an error message otherwise.
--======================================================================
local function Update_Player_Display_For_Bot(Cage_M, bot)
	local fightData = Cage_M:WaitForChild("Fight_Data_F") 
	local char1 = fightData:WaitForChild("Fight_Char_1").Value
	local char2 = fightData:WaitForChild("Fight_Char_2").Value
	
	local Fighter_Model = nil
	if bot == char1 then
		Fighter_Model = Cage_M:WaitForChild("Fighter_1")
	elseif bot == char2 then
		Fighter_Model = Cage_M:WaitForChild("Fighter_2")
	end
	
	if Fighter_Model ~= nil then
	
		local Main_P = Fighter_Model:FindFirstChild("Main_P")
		local Display_UI = Main_P:FindFirstChild("Player_Display_UI") or Player_Display_UI:Clone()
		Display_UI.Adornee = Main_P
		Display_UI.Parent = Main_P
		local Empty_Txt = Display_UI:WaitForChild("Empty_Txt")
		local Player_F = Display_UI:WaitForChild("Player_F")
		local Rank_F = Player_F:FindFirstChild("Rank_F")
		
		Player_F:FindFirstChild("Player_Name").Text = bot:GetAttribute("Display_Name")
		Player_F:FindFirstChild("Display_Name").Text = "@BOT" 
		Player_F:FindFirstChild("Icon_F"):FindFirstChild("Player_Img").Image = "rbxassetid://134663290660847"
		Rank_F.Visible = false
		
		Display_UI.PlayerToHideFrom = nil
		Player_F.Visible = true	
		Empty_Txt.Visible = false
	end
end

Create_Training_Bot.OnServerInvoke = function(player, cageType, cageName, botProfile)
	local res = {
		success = false, 
		err = "",
		cageName = cageName
	}
	
	local cageModel = nil
	
	if cageType == Fight_Params_Mod.CageType.STANDARD then
		cageModel = workspace.Main_World_F.Gameplay.Objects.Fight_Cages_F:FindFirstChild(cageName)
		if not cageModel then 
			res.err = "Invalid cage name" 
			return res
		end
		if cageModel:GetAttribute("No_Bots") then
			res.err = "No bots cage"
			return res
		end
		
	elseif cageType == Fight_Params_Mod.CageType.TUTORIAL then
		cageModel = Cage_Factory:CreateCage(cageType)
		cageModel:SetAttribute("Cage_Type", "TUTORIAL")
		local char1 = cageModel:WaitForChild("Fight_Data_F"):WaitForChild("Fight_Char_1")
		char1.Value = player.Character
		res.cageName = cageModel.Name
		player:SetAttribute("IsTutorialRunning", true)
		
	elseif cageType == Fight_Params_Mod.CageType.LEAGUE then		
		-- TODO
		-- dont forget to add Attribute Cage_Type = 	
		--CageType = {
		--STANDARD = "STANDARD",
		--RANKED   = "RANKED",
		--TUTORIAL = "TUTORIAL",
		--LEAGUE   = "LEAGUE"
		--},
	else
		-- TODO
	end
	
	-- Create bot in the cage 
	if not botProfile then
		botProfile = Bots_Mod.profiles.COACH
	end

	local bot = Bots_Manager.SpawnBotInCage(player, cageModel, botProfile)
	if not bot then res.err = "Bot spawn failed" return res end

	-- Check Fight data before Starting Fight
	local fightData = cageModel:WaitForChild("Fight_Data_F")
	local char1 = fightData:WaitForChild("Fight_Char_1").Value
	local char2 = fightData:WaitForChild("Fight_Char_2").Value
	if not (char1 and char2) then res.err = "Fight not ready" return res end

	Start_Core_Fight:Fire(cageModel, char1, char2)
	
	-- Add bot data in Player_Display_UI
	Update_Player_Display_For_Bot(cageModel, bot)
	
	res.success = true
	return res
end

Destroy_Training_Bot.OnServerInvoke = function(player, cageName)
	local bot =workspace.Main_World_F.Gameplay.Objects.Bots:FindFirstChild(cageName.."_Bot")
	if bot then
		bot:Destroy()
		return true
	end
	return false
end

--======================================================================
--  Called remotely by the client (via the "Send Invite" button) to
--  invite every player of the room to fight.
--
--  Parameters:
--      cageName (string)
--          The name of the fight cage where the player requested an invite to
--          fight.
-- 		Plr (Player)
--			The inviting Player 
--
--  Behavior:
--      1. Locates the cage model in the workspace.
--      2. Check if the player can invite someone to this cage if ranked
--      3. Prepare invitation Data to send
-- 		4. Send the invite to All other player in the room
--======================================================================
local function Get_Invitation_Data(Cage, Plr)
	local Inviting_Char = Plr.Character
	-- Cage Infos
	local Fight_Data = Cage:WaitForChild("Fight_Data_F")
	local Active_Fight_V = Fight_Data:WaitForChild("Active_Fight")
	local Fight_Char_1_V = Fight_Data:WaitForChild("Fight_Char_1")
	local Fight_Char_2_V = Fight_Data:WaitForChild("Fight_Char_2")

	local Fight_M1 = Cage:WaitForChild("Fighter_1")
	local Fight_M2 = Cage:WaitForChild("Fighter_2")

	local Main_Char_V = nil
	local Spawn_Location = nil
	if Inviting_Char == Fight_Char_1_V.Value then
		Main_Char_V = Fight_Char_1_V
		Spawn_Location = Fight_M2:FindFirstChild("Player_Spawn_P").CFrame

	elseif Inviting_Char == Fight_Char_2_V.Value then
		Main_Char_V = Fight_Char_2_V
		Spawn_Location = Fight_M1:FindFirstChild("Player_Spawn_P").CFrame
	end

	-- Player Info
	local Rank_Data, Elo_Amount = Elo_Mod.Get_Player_Rank_Data(Plr)
	local Rank_Col = Rank_Data['Color'] or Color3.fromRGB(170, 170, 127)
	local Plr_Icon = PlayerUtils.Get_Player_Image(Plr.UserId)
	
	local Is_Ranked_Fight = (Cage:GetAttribute("Cage_Type") or "") == "RANKED"

	return {
		['Name'] = Plr.Name, 
		['Rank Icon'] = Rank_Data['Icon'] or "rbxassetid://89194867048049",
		['Rank Color'] = Rank_Col,
		['Rank Value'] = Utils.Format_Number(Elo_Amount) .. "",
		['Player Icon'] = Plr_Icon,

		['Main_Char_V'] = Main_Char_V,
		['Spawn_Location'] = Spawn_Location,
		['Active_V'] = Active_Fight_V,
		['Ranked_Fight'] = Is_Ranked_Fight,
	}
end

Send_Invite_Notification.OnServerInvoke = function(Plr, cageName)

	local cagesFolder = workspace.Main_World_F.Gameplay.Objects.Fight_Cages_F
	local cageModel = cagesFolder:FindFirstChild(cageName)
	if not cageModel then
		return false, "Invalid cage reference"
	end

	local Is_Ranked_Fight = (cageModel:GetAttribute("Cage_Type") or "") == "RANKED"
	
	local Total_Wins_V = PlayerUtils.GetPlayerVal(Plr, "Total Wins")
	if(Is_Ranked_Fight ~= nil and Is_Ranked_Fight == true and Total_Wins_V ~= nil and 
		Total_Wins_V.Value < Fight_Params_Mod.Ranked_Arena_Required_Wins)then
		return false, "Player cannot start a fight in a Ranked Cage"
	end

	local Invitation_Data = Get_Invitation_Data(cageModel, Plr)
	if Invitation_Data == nil then
		return false, "Invited player is not in cage anymore"
	else
		Fight_Spawn_Notification:FireAllClients(Plr, Invitation_Data)
		return true
	end
end

------ INITIALISATION 
function Init_Fight_Spawn_Handles()
	task.wait(1)
	local cageFolder = Cage_Factory:getCageFolder(Fight_Params_Mod.CageType.STANDARD)
	local All_M = cageFolder:GetChildren()
	for i = 1, #All_M do
		if(All_M[i] ~= nil)then
			Fight_Spawn_Handle(All_M[i])
		end
	end
end
Init_Fight_Spawn_Handles()
]]></ProtectedString>
						<string name="ScriptGuid">{9169D707-B70F-46B3-BCDE-4DEEF1AFDECD}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_Assignment_Handle.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX95AF6A88D64D4489AE2EF8ABB19C9D21">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_Assignment_Handle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX07C8AB6C8B234C91AEEC262BE31A1099">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[--======================================================================
--  Module: Bots_Manager
--
--  Description:
--      Handles spawning and configuration of training bots for fights.
--      Uses Bots_Mod for per-cage configuration (template + difficulty).
--
--  Usage:
--      local Bots_Manager = require(script:WaitForChild("Bots_Manager"))
--      Receiving_RF.Create_Training_Bot.OnServerInvoke = function(plr)
--          return Bots_Manager.CreateTrainingBot(plr)
--      end
--======================================================================
local RS 				= game:GetService("ReplicatedStorage")
local Bots_Mod 			= require(game.ReplicatedStorage.Data_Mods_F.Bots_Mod)
local Fight_Params_Mod 	= require(game.ReplicatedStorage.Data_Mods_F.Fight_Params_Mod)

local Bots_Manager = {}

--======================================================================
--  Creates and configures a training bot for the given cage.
--  This function is responsible for:
--     - selecting the correct bot profile (NORMAL, COACH, etc.)
--     - cloning the corresponding bot template
--     - setting its attributes (DisplayName, Behavior)
--     - attaching it to the cage slot (Fight_Char_1 / Fight_Char_2)
--     - dynamically injecting the correct behavior module
--
--  Parameters:
--      cageModel (Model)
--          The cage model in which the bot will be spawned.
--
--      vacantCharValue (ObjectValue)
--          The ObjectValue (Fight_Char_1 or Fight_Char_2) representing
--          the empty slot that should receive the bot.
--
--  Behavior:
--      - Reads the cage’s configured profile from Bots_Mod.
--      - Clones the bot template from ServerStorage/Training_Bots.
--      - Assigns bot metadata and marks the cage as a "Bot Fight".
--      - Loads and runs the corresponding AI behavior (NORMAL, COACH).
--
--  Returns:
--      bot (Model)
--          The newly spawned bot instance ready for the fight.
--      nil
--          If any step fails (missing template, invalid profile, etc.)
--======================================================================

local function getVacantSlot(cageModel)
	local data = cageModel:WaitForChild("Fight_Data_F")
	local char1 = data:WaitForChild("Fight_Char_1")
	local char2 = data:WaitForChild("Fight_Char_2")

	if char1.Value == nil then return char1 end
	if char2.Value == nil then return char2 end
	return nil
end

function Bots_Manager.SpawnBotInCage(player, cageModel, botProfile)
	local vacantCharValue = getVacantSlot(cageModel)
	if not vacantCharValue then
		warn("[Bots_Manager] No vacant slot available")
		return nil
	end
	
	----------------------------------------------------------------
	-- Load bot configuration
	----------------------------------------------------------------
	local cageName = cageModel.Name
	local profile = nil
	
	if botProfile then
		profile = botProfile
	else
		profile = Bots_Mod.getProfileForCage(cageName)
		if not profile then
			warn("[Bots_Manager] Missing profile for cage:", cageName)
			return nil
		end
	end

	----------------------------------------------------------------
	-- Clone bot template
	----------------------------------------------------------------
	local templateFolder = Bots_Mod.getBotsTemplateFolder()
	local template = templateFolder:FindFirstChild(profile.Template)
	if not template then
		warn("[Bots_Manager] Bot template not found:", profile.Template)
		return nil
	end

	local bot = template:Clone()
	local displayName = profile.DisplayName or "Bot"
	bot.Name = cageName .. "_Bot"
	bot.Parent = Bots_Mod.getBotsWorkspaceFolder()

	----------------------------------------------------------------
	-- Apply attributes (metadata)
	----------------------------------------------------------------
	bot:SetAttribute("Display_Name", displayName)
	bot:SetAttribute("IsBot", true)
	bot:SetAttribute("UserId", -1)
	bot:SetAttribute("Behavior", profile.Behavior or "NORMAL")

	
	local playerVal = Instance.new("IntValue")
	playerVal.Name = "_PLAYER_VALUE_"
	playerVal.Value = -1 -- bots n’ont pas de vrai UserId
	playerVal.Parent = bot

	-- Optionnel : ajouter un dossier Fight_Data si inexistant
	if not bot:FindFirstChild("Fight_Data") then
		local fightData = Instance.new("Folder")
		fightData.Name = "Fight_Data"

		local health = Instance.new("IntValue")
		health.Name = "Health"
		health.Value = Fight_Params_Mod.Health.Max_Value
		health.Parent = fightData

		local stamina = Instance.new("IntValue")
		stamina.Name = "Staminia"
		stamina.Value = Fight_Params_Mod.Stamina.Max_Value
		stamina.Parent = fightData

		local block = Instance.new("IntValue")
		block.Name = "Block Power"
		block.Value = Fight_Params_Mod.Block_Power.Max_Value
		block.Parent = fightData

		local strike = Instance.new("IntValue")
		strike.Name = "Strike Power"
		strike.Value = Fight_Params_Mod.Punch_Power.Max_Value
		strike.Parent = fightData

		fightData.Parent = bot
	end
	
	
	vacantCharValue.Value = bot
	
	cageModel:SetAttribute("Bot_Fight", true)

	----------------------------------------------------------------
	-- Inject the bot behavior module dynamically
	----------------------------------------------------------------
	task.spawn(function()		
		local behaviorModuleName = string.upper(profile.Behavior)
		local behaviorModulePath = RS:WaitForChild("Data_Mods_F"):WaitForChild("Bot_Behaviors")
		local behaviorModule = behaviorModulePath:FindFirstChild(behaviorModuleName)

		if not behaviorModule then
			warn("[Bots_Manager] Behavior module not found:", behaviorModuleName)
			return
		end

		print("[Bots_Manager] Initializing bot behavior:", behaviorModuleName)

		local behavior = require(behaviorModule)
		local ai = behavior.new()
		ai:Init(player, bot)
	end)

	return bot
end

return Bots_Manager]]></ProtectedString>
							<string name="ScriptGuid">{09613CA6-8F91-4FCA-A3B0-DD641AA3B85E}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Bots_Manager.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX9FC9DC9A8E9642DA9C87514D9E3CD66B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TemplateUIs</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXE15973AC50264FCAAFBAE395E2A069F1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Invite_Buttons_UI</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX10A24EFC4191495B8903B676E55F09AD">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- Services
local RS 						= game:GetService("ReplicatedStorage")
local TS 						= game:GetService("TweenService")
local Plr 						= game.Players.LocalPlayer
local Char 						= Plr.Character or Plr.CharacterAdded:Wait()

-- Modules
local Data_Mods_F 				= game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Fight_Params_Mod 			= require(Data_Mods_F:WaitForChild("Fight_Params_Mod"))
local SE_Mod 					= require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Bots_Mod 					= require(Data_Mods_F:WaitForChild("Bots_Mod"))

-- Events
local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Create_Training_Bot		= Channels.CS_Remote_Functions.Create_Training_Bot
local Send_Invite_Notification	= Channels.CS_Remote_Functions.Send_Invite_Notification
local Display_Data				= Channels.Bindable_Events.Display_Data

-- UI References
local Buttons_F = script.Parent:WaitForChild("Buttons_F")
local Cons = {}

function Setup(Button_Data)	
	local uis = game:GetService("UserInputService")
	local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)	
	local Debounce_C = false

	for _, Button in ipairs(Button_Data) do
		local B = Buttons_F:WaitForChild(Button.Name)
		B.Visible = Button.Visible
		if Button.Visible == true then
			B:WaitForChild("Selected").MouseButton1Click:Connect(function()
				if(Debounce_C == false)then
					Debounce_C = true
					SE_Mod.PlaySFX(Plr, "Click_SE")
					TS:Create(B, Tween_Click, {Size = UDim2.new(0.61875, 0, 0.3, 0)}):Play()
					Button.Callback()
					task.wait(0.25)
					Debounce_C = false
				end
			end)
			B.Xbox.Visible = uis.GamepadEnabled
		end
	end

	-- Gamepad input support
	table.insert(Cons,uis.InputBegan:Connect(function(inp, bool)  
		if bool == true then
			return
		end

		for _, Button in pairs(Button_Data) do
			local B = Buttons_F:WaitForChild(Button.Name)
			if Button.Visible then
				if inp.KeyCode == Button.Gamepad_Button then
					Button.Callback()
				end
			end
		end
	end))
end

function Destroy()
	for _, con in pairs(Cons) do
		con:Disconnect()
	end
	Cons = {}
end

local Error_Color = Color3.fromRGB(225, 0, 0)
local Message_Color = Color3.fromRGB(0, 170, 0)
local Cage_M = script.Parent:WaitForChild("Cage_M").Value
local No_bots = script.Parent:WaitForChild("No_Bots").Value
local Button_Data = {
	{
		Name = "Invite_Friends_B",
		Callback = function() 
			local success, err = Send_Invite_Notification:InvokeServer(Cage_M.Name)
			if not success and err then
				Display_Data:Fire(err, Error_Color)
			end
			SE_Mod.Play_Voice_Over("Matchmaking")
			Display_Data:Fire("Invite sent to all other players in the room ...", Message_Color)	
		end,
		Gamepad_Button = Enum.KeyCode.DPadLeft,
		Visible = not Plr:GetAttribute("IsTutorialRunning"),
	},
	{
		Name = "Bot_Fight_B",
		Callback = function() 
			local isTutorial = Plr:GetAttribute("IsTutorialRunning") 
			local Cage_Type = isTutorial and Fight_Params_Mod.CageType.TUTORIAL or Fight_Params_Mod.CageType.STANDARD
			local Cage_Name = Cage_M.Name
			local Bot_Profile = isTutorial and Bots_Mod.profiles.COACH or Bots_Mod.profiles.NORMAL
			
			local res = Create_Training_Bot:InvokeServer(Cage_Type, Cage_Name, Bot_Profile)
			if res.success == false then
				Display_Data:Fire(res.err, Error_Color)
			end	
		end,
		Gamepad_Button = Enum.KeyCode.DPadRight,
		Visible = not No_bots
	}
}

Setup(Button_Data)
]]></ProtectedString>
								<string name="ScriptGuid">{F197BA10-1759-438D-8DAA-5CDA942FD8E3}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Invite_Buttons_Handle.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX72819AD24781418B88D4A31AB484FDD2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Modules</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXFBCD0CE0DE134D6EA3B47F7758A5270D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Security/AntiExploitLogger.lua
--
--  Description:
--      Lightweight server-side module for reporting suspicious or
--      exploit-related activity to a Discord webhook. Provides a
--      simple Log(player, category, details) API producing structured
--      embed messages.
--
--      Features:
--          • Async webhook posting (non-blocking)
--          • JSON encoded payload (Discord embed)
--          • Automatic player identity formatting
--          • Safe error-handling via pcall
--
--  Last Modified: 2025-09-30
--  Version: V2025-09
--
--  Dependencies:
--      Services:
--          - HttpService
--
--  Configuration:
--      • Set WEBHOOK_URL to your Discord webhook before use.
--
--  Notes:
--      • Intended to be required by server-only code.
--      • Logging silently fails if the webhook is unavailable.
--======================================================================

local HttpService = game:GetService("HttpService")
local AntiExploitLogger = {}
local WEBHOOK_URL = "https://discord.com/api/webhooks/1442964977316270273/xBDgrJG8Vq3rL7b-Dz1xxRf2XVtaO6Ykwdh0XVaxBpdQWHyMAdxBSdeuYEvdQidn75JF"

local function SendWebhook(data)
	if not WEBHOOK_URL or WEBHOOK_URL == "" then
		warn("[AntiExploitLogger] No webhook URL configured.")
		return
	end

	task.spawn(function()
		local jsonData = HttpService:JSONEncode(data)

		local success, err = pcall(function()
			HttpService:PostAsync(WEBHOOK_URL, jsonData, Enum.HttpContentType.ApplicationJson)
		end)

		if not success then
			warn("[AntiExploitLogger] Failed to send log:", err)
		end
	end)
end

function AntiExploitLogger.Log(player, category, details)
	SendWebhook({
		["username"] = "Anti-Exploit Bot",
		["embeds"] = {{
			["title"] = "🚨 Exploit Detected",
			["color"] = 16711680,
			["fields"] = {
				{
					["name"] = "Player",
					["value"] = string.format("**%s** (%s)", player.Name, player.UserId),
					["inline"] = false
				},
				{
					["name"] = "Type",
					["value"] = category,
					["inline"] = false
				},
				{
					["name"] = "Details",
					["value"] = details or "N/A",
					["inline"] = false
				}
			},
			["timestamp"] = DateTime.now():ToIsoDate()
		}}
	})
end

return AntiExploitLogger]]></ProtectedString>
						<string name="ScriptGuid">{59027B7F-5DF6-4B3A-A371-763230EDCB28}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">AntiExploitLogger.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDB188E0A89214BCC8E6743E873D77F1E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Modules/GAModule.lua
--
--  Description:
--      Wrapper module for GameAnalytics integration.
--      Handles initialization and business event logging for purchases.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ReplicatedStorage:
--          * GameAnalytics (module)
--      - Roblox Services:
--          * Players (used indirectly through function parameters)
--
--  Notes:
--      - Initializes GameAnalytics server SDK with game keys
--      - Disables verbose/info logs on startup
--      - Logs Robux purchase events with Creator Codes
--      - Contains hardcoded secrets (⚠ should be secured properly)
--
--======================================================================

local GAModule = {}

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local GameAnalytics = require(game.ReplicatedStorage.Modules.GameAnalytics)

function GAModule:CreatorSupported(player:Player, creatorId: string, robuxAmount: number)
	if not creatorId or not robuxAmount then
		warn("Missing creatorId or robuxAmount for GA log.")
		return
	end

	GameAnalytics:addBusinessEvent(
		player.UserId,
		{
			currency = "Robux",
			amount = robuxAmount,
			itemType = "DevProduct",
			itemId = "WithCreatorCode",
			cartType = tostring(creatorId)
		}
	)
end

local function SafeGetSecret(name: string)
	-- Only Roblox Cloud environments expose HttpService:GetSecret()
	if HttpService.GetSecret and not RunService:IsStudio() then
		local ok, value = pcall(function()
			return HttpService:GetSecret(name)
		end)
		if ok and value and value ~= "" then
			return value
		end
	end
	return nil
end

function GAModule:Init()
	GameAnalytics:setEnabledInfoLog(false)
	GameAnalytics:setEnabledVerboseLog(false)
	
	-- Try to load keys securely
	local key = SafeGetSecret("GameAnalyticsKey") or "acf2fbabbd9612a55e53d758fa5f8184"
	local secret = SafeGetSecret("GameAnalyticsSecret") or "108c93f6570a18f37d56abda957bbb2c1a8bfb2e"
	
	if key and secret then
		GameAnalytics:initServer(key, secret) 
	end
end

GAModule:Init()

return GAModule
]]></ProtectedString>
						<string name="ScriptGuid">{4BDC8E2C-DAE9-413A-90AB-6C9AC730A0E4}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GAModule.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX02BDE2AC70954B26813EA47C3B444A93">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Modules/GlobalLeaderBoards.lua
--
--  Description:
--      Handles the setup and updating of global leaderboards for players.
--      Retrieves stats, sorts them, and publishes results on in-game boards.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - Workspace:
--          * Leaderboards
--      - ReplicatedStorage:
--          * Data_Mods_F/Num_String_Mod
--          * Data_Mods_F/Country_Mod
--          * Channels_F/Bindable_F/Events
--          * Channels_F/Server_Client_F/Events/Top3_Players_Updated
--      - Roblox Services:
--          * Players
--          * UserService
--          * DataStoreService (OrderedDataStore & DataStore for Elo, Wins, etc.)
--
--  Notes:
--      - Uses OrderedDataStore for ranked global leaderboards
--      - Custom DataStoreQueue system to prevent throttling
--      - Wraps DataStore calls in pcall for resilience
--      - Generates player thumbnails with Enum.ThumbnailType.HeadShot
--        and Enum.ThumbnailSize.Size180x180
--
--======================================================================

local module = {
	NationElos = {},
	TopPlayers = { -1, -1, -1 }
}

-- Services
local Players = game:GetService("Players")
local UserService = game:GetService("UserService")
local DataStoreService = game:GetService("DataStoreService")

-- Modules
local Data_Mod_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Country_Mod = require(Data_Mod_F:WaitForChild("Country_Mod"))
local Utils = require(game.ReplicatedStorage.Modules.Utils)

-- Events
local Channels = require(game.ReplicatedStorage.Modules.Channels)
local Top3_Players_Updated = Channels.SC_Remote_Events.Top3_Players_Updated

-- Workspace References
local Main_World_F = game.Workspace:WaitForChild("Main_World_F")
local Objects = Main_World_F:WaitForChild("Gameplay"):WaitForChild("Objects")
local Leaderboards_F = Objects:WaitForChild("Leaderboards")

local DEFAULT_COUNTRY = "United States"
local THUMBNAIL_TYPE = Enum.ThumbnailType.HeadShot
local THUMBNAIL_SIZE = Enum.ThumbnailSize.Size180x180

local LeaderboarKeys = {
	Elo = "Best Elo",
	Wins = "Total Wins",
	WinStreak = "Win Streak",
	Knockouts = "Knockouts",
	Submissions = "Submissions Wins",
	GymTraining = "Gym Training",
	RankedWins = "Ranked Wins"
}


local LeaderboardKey = 2

local LeaderboarStores = {}
for i, v in pairs(LeaderboarKeys) do
	LeaderboarStores[i] = DataStoreService:GetOrderedDataStore(v .. LeaderboardKey)
end

local NationEloStore = DataStoreService:GetDataStore("Natio_Elo" .. LeaderboardKey)
local NationEloKey = "_KEYS_"
local NationEloData = {}

local Player_Info_Data = {}
local Player_Thumbnail_Data = {}
local LastPlayerValues = {}

-- ============================================================
-- DataStore Queue System
-- ============================================================
local DataStoreQueue = {}
DataStoreQueue.Queue = {}
DataStoreQueue.Busy = false

function DataStoreQueue:Add(store, key, value, mode, callback)
	table.insert(self.Queue, {
		store = store,
		key = key,
		value = value,
		mode = mode,
		callback = callback
	})
end

function DataStoreQueue:Process()
	if self.Busy then return end
	self.Busy = true
	task.spawn(function()
		while #self.Queue > 0 do
			local req = table.remove(self.Queue, 1)
			local success, err
			if req.mode == "set" then
				success, err = pcall(function()
					req.store:SetAsync(req.key, req.value)
				end)
			elseif req.mode == "update" then
				success, err = pcall(function()
					req.store:UpdateAsync(req.key, req.value)
				end)
			end
			if not success then
				warn("DataStoreQueue error:", err)
				table.insert(self.Queue, req)
				task.wait(2)
			elseif req.callback then
				req.callback()
			end
			task.wait(0.1)
		end
		self.Busy = false
	end)
end

-- ============================================================
-- Player thumbnails and info
-- ============================================================
local function Get_Player_Thumbnail(ID)
	if Player_Thumbnail_Data[ID] then
		return Player_Thumbnail_Data[ID]
	end
	for _ = 1, 3 do
		local success, data = pcall(function()
			return Players:GetUserThumbnailAsync(ID, THUMBNAIL_TYPE, THUMBNAIL_SIZE)
		end)
		if success and data then
			Player_Thumbnail_Data[ID] = data
			return data
		end
		task.wait(1)
	end
	return "rbxassetid://100127687172105"
end

local function Get_Player_Info_Data(ID)
	if Player_Info_Data[ID] then
		return Player_Info_Data[ID]
	end
	for _ = 1, 3 do
		local success, data = pcall(function()
			return UserService:GetUserInfosByUserIdsAsync({tonumber(ID)})
		end)
		if success and data and data[1] and data[1].Username then
			local entry = {
				Username = data[1].Username,
				DisplayName = data[1].DisplayName
			}
			Player_Info_Data[ID] = entry
			return entry
		end
		task.wait(1)
	end
	return { Username = "PlayerName", DisplayName = "Player" }
end

-- ============================================================
-- Utils
-- ============================================================
local function SerializeDataAndCountry(data: number, country: string)
	local countryId = Country_Mod.Get_Country_Number_From_Index(country)
	data = math.round(data)
	return tonumber(tostring(data) .. string.format("%04d", countryId))
end

local function DeserializeDataAndCountry(serialized: number)
	local str = tostring(serialized)
	local dataPart = 0
	if #str >= 5 then dataPart = tonumber(string.sub(str, 1, #str - 4)) end
	local countryId = tonumber(string.sub(str, -4))
	return math.round(dataPart), countryId
end

-- ============================================================
-- Update leaderboards display
-- ============================================================
local function Update_All_Leaderboard_Displays()
	local function Get_LB_UI_Data(Key)
		local LB_M = Leaderboards_F:FindFirstChild(Key)
		if LB_M and LB_M.PrimaryPart and LB_M.PrimaryPart:FindFirstChildWhichIsA("SurfaceGui") then
			local Main_UI = LB_M.PrimaryPart:FindFirstChildWhichIsA("SurfaceGui")
			local Main_Data_F = Main_UI:FindFirstChild("Main_Data_F")
			if Main_Data_F and Main_Data_F:FindFirstChild("Tabs_F") and Main_Data_F:FindFirstChild("Tab_TMP") then
				Main_Data_F.CanvasPosition = Vector2.new(0, 0)
				return Main_Data_F:FindFirstChild("Tabs_F"), Main_Data_F:FindFirstChild("Tab_TMP")
			end
		end
		return nil, nil
	end

	local function Update_Leaderboard_Display(Key, Data)
		local Y_Pos = 0.0875
		local Tabs_F, Tab_TMP = Get_LB_UI_Data(Key)
		if Tabs_F and Tab_TMP then
			Tabs_F:ClearAllChildren()
			local UIList = Instance.new("UIListLayout")
			UIList.Parent = Tabs_F
			UIList.Padding = UDim.new(0.02, 0)
			UIList.SortOrder = Enum.SortOrder.LayoutOrder

			local function Create_New_Tab(Rank, Data)
				local ID = Data['ID'] or -1
				local Sort_Val = Data['Sort Val'] or 0
				local Country = Data['Country'] or "USA"

				local Tab = Tab_TMP:Clone()
				local Plr_Img = Tab:WaitForChild("Plr_Img")
				local Rank_Txt = Tab:WaitForChild("Rank_Txt")
				local P_Name_Txt = Tab:WaitForChild("P_Name_Txt")
				local P_DisplayName_Txt = Tab:WaitForChild("P_DisplayName_Txt")
				local P_Data_Val = Tab:WaitForChild("P_Data_Val")
				Tab.Parent = Tabs_F
				Tab.Position = UDim2.new(0.5, 0, Y_Pos, 0)
				Tab.Name = "Tab_" .. Rank
				Tab.LayoutOrder = Rank

				Tab:WaitForChild("Country_Img").Image = Country_Mod.Get_Flag_ID(Country)
				P_Data_Val.Text = Utils.NumToString(Sort_Val)
				if Key == "Gym Training" then
					P_Data_Val.Text = Utils.Time_Conversion(Sort_Val)
				end
				P_Data_Val.TextXAlignment = Enum.TextXAlignment.Center

				if Key == "Nation Elo" then
					Plr_Img.Visible = false
					Rank_Txt.Visible = true
					Rank_Txt.Text = "#" .. Rank
					P_DisplayName_Txt.Text = "Country"
					P_Name_Txt.Text = Country
				else
					if Rank <= 3 then
						Plr_Img.Image = Get_Player_Thumbnail(ID)
						Rank_Txt.Visible = false
						Plr_Img.Visible = true
					else
						Rank_Txt.Text = "#" .. Rank
						Rank_Txt.Visible = true
						Plr_Img.Visible = false
					end
					local Plr_Info_Data = Get_Player_Info_Data(ID)
					P_Name_Txt.Text = Plr_Info_Data.DisplayName or "Player Name"
					P_DisplayName_Txt.Text = "@" .. (Plr_Info_Data.Username or "Player")
				end

				Y_Pos += 0.175
				Tab.Visible = true
			end

			for i = 1, #Data do
				Create_New_Tab(i, Data[i])
			end
		end
	end

	local function tryGetData(leaderboardStore: OrderedDataStore)
		local success, data = pcall(function()
			return leaderboardStore:GetSortedAsync(false, 100)
		end)
		if success then return data else warn("Could not get leaderboard pages", data) end
	end

	local function tryGetPage(pages: DataStorePages)
		local success, page = pcall(function()
			return pages:GetCurrentPage()
		end)
		if success then return page else warn("Could not get page") end
	end

	for leaderboardType, leaderboardStore in pairs(LeaderboarStores) do

		local lbKey = LeaderboarKeys[leaderboardType]
		
		if not lbKey then continue end
		local leaderboardPages = tryGetData(leaderboardStore)
		if not leaderboardPages then continue end
		local currentPage = tryGetPage(leaderboardPages)
		if not currentPage then continue end

		local finalValues = {}
		for _, data in currentPage do
			local playerKey, playerValue = data.key, data.value
			if playerKey and playerValue then
				local score, countryId = DeserializeDataAndCountry(playerValue)
				local countryName = Country_Mod.Get_Country_Index_From_Number(countryId) or DEFAULT_COUNTRY
				table.insert(finalValues, {["Sort Val"] = score, Country = countryName, ID = playerKey})
			end
		end
		table.sort(finalValues, function(a, b) return a["Sort Val"] > b["Sort Val"] end)

		if lbKey == "Total Wins" then
			-- Save previous top 3
			local oldTop = {
				[1] = module.TopPlayers[1],
				[2] = module.TopPlayers[2],
				[3] = module.TopPlayers[3],
			}

			-- Build new indexed top 3
			module.TopPlayers = {}
			for rank = 1, 3 do
				local entry = finalValues[rank]
				module.TopPlayers[rank] = entry and tonumber(entry.ID) or nil
			end

			-- Compare index by index
			local changed = false
			for i = 1, 3 do
				if oldTop[i] ~= module.TopPlayers[i] then
					changed = true
					break
				end
			end

			-- Fire only if change detected
			if changed then
				Top3_Players_Updated:FireAllClients(module.TopPlayers)
			end
		end
		Update_Leaderboard_Display(lbKey, finalValues)
	end

	local finalValues = {}
	for i, v in pairs(NationEloData) do
		finalValues[#finalValues + 1] = {["Sort Val"] = v, Country = i, ID = 1}
	end
	table.sort(finalValues, function(a, b) return a["Sort Val"] > b["Sort Val"] end)
	Update_Leaderboard_Display("Nation Elo", finalValues)
end

-- ============================================================
-- Nation Elo
-- ============================================================
function module:ProcessNationElo()
	local entries = {}
	for _, v in pairs(module.NationElos) do
		entries[v[1]] = (entries[v[1]] or 0) + v[2]
	end
	for _ = 1, 5 do
		local success, err = pcall(function()
			NationEloStore:UpdateAsync(NationEloKey, function(data)
				data = data or {}
				for i in Country_Mod.Get_Country_Data() do
					if not data[i] then data[i] = 0 end
				end
				for i, v in pairs(entries) do
					if data[i] then data[i] += v end
				end
				NationEloData = data
				return data
			end)
		end)
		if success then break else warn(err) task.wait(1) end
	end
end

function module:RegisterNationElo(countryIndex: string, eloCount: number)
	if not countryIndex or not Country_Mod.Get_Country_Data()[countryIndex] then
		error(`Invalid Country Index {countryIndex}`)
	end
	if not eloCount or typeof(eloCount) ~= "number" then
		error(`Invalid Elo {eloCount}`)
	end
	table.insert(module.NationElos, {countryIndex, eloCount})
end

function module:_ClearNationElo()
	module.NationElos = {}
end

game:BindToClose(function()
	module:ProcessNationElo()
	module:_ClearNationElo()
end)

local function RunDataStoreLoop()
	module:ProcessNationElo()
	module:_ClearNationElo()

	for _, plr in ipairs(Players:GetPlayers()) do
		local key = plr.UserId
		local player_Data = plr:FindFirstChild("Player_Data")
		if player_Data and player_Data:FindFirstChild("Country") then
			task.spawn(function()
				local countryId = player_Data["Country"].Value
				local updates = {
					{LeaderboarStores.Wins, "Total Wins"},
					{LeaderboarStores.Elo, "Elo"},
					{LeaderboarStores.Knockouts, "Leg Knockout Wins", "Punch Knockout Wins"},
					{LeaderboarStores.GymTraining, "Gym Training"},
					{LeaderboarStores.Submissions, "Submissions Wins"},
					{LeaderboarStores.RankedWins, "Ranked Wins"},
				}

				for _, entry in ipairs(updates) do
					local store, stat1, stat2 = entry[1], entry[2], entry[3]
					local val = player_Data[stat1].Value
					if stat2 then val += player_Data[stat2].Value end

					local serialized = SerializeDataAndCountry(val, countryId)
					if LastPlayerValues[key .. stat1] ~= serialized then
						LastPlayerValues[key .. stat1] = serialized
						DataStoreQueue:Add(store, key, serialized, "set")
					end
				end

				DataStoreQueue:Add(
					LeaderboarStores.WinStreak,
					key,
					function(old)
						local oldScore = 0
						if old then oldScore = DeserializeDataAndCountry(old) end
						return SerializeDataAndCountry(math.max(oldScore, player_Data["Win Streak"].Value), countryId)
					end,
					"update"
				)

				DataStoreQueue:Process()
			end)
		end
	end

	task.delay(120 + math.random() * 30, RunDataStoreLoop)
end
task.defer(RunDataStoreLoop)

local function RunUILoop()
	Update_All_Leaderboard_Displays()
	task.delay(30, RunUILoop)
end

task.defer(RunUILoop)

return module]]></ProtectedString>
						<string name="ScriptGuid">{240CDAFA-5360-4844-8874-C1C1A454080B}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GlobalLeaderBoards.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX169B03D8335A429DB57EDE50383E3550">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: ServerScriptService/Modules/Codes_Unique.lua
--
--  Description:
--      Contains a static list of one-time unique codes and associated rewards.
--      Used by Unique_Codes_Handle.lua for code redemption validation.
--
--  Author(s): Darkzeb, Exclusible
--
--  Last Modified: 2025-09-29 by Darkzeb
--
--  Version: V2025-09
--
--  Dependencies:
--      - ServerScriptService/Unique_Codes_Handle.lua
--
--  Notes:
--      - Codes are stored as { Code = "...", Reward = "..." }
--      - Referenced by 
--      - Includes multiple reward tiers (e.g., LargediamondsPack, HugeMoneyPack)
--
--======================================================================


local module = {
	[1] = { Code = "0F4AA7QH", Reward = "LargediamondsPack" },
	[2] = { Code = "0HKYWSP8", Reward = "LargediamondsPack" },
	[3] = { Code = "10IZX44L", Reward = "LargediamondsPack" },
	[4] = { Code = "14GN6X52", Reward = "LargediamondsPack" },
	[5] = { Code = "15UT4E3Z", Reward = "LargediamondsPack" },
	[6] = { Code = "19913MO4", Reward = "LargediamondsPack" },
	[7] = { Code = "1BNUVK7F", Reward = "LargediamondsPack" },
	[8] = { Code = "1C2U1RLN", Reward = "LargediamondsPack" },
	[9] = { Code = "1KRDOF81", Reward = "LargediamondsPack" },
	[10] = { Code = "1M10ZJZP", Reward = "LargediamondsPack" },
	[11] = { Code = "1QSWL6VL", Reward = "LargediamondsPack" },
	[12] = { Code = "1SX2XT0B", Reward = "LargediamondsPack" },
	[13] = { Code = "1WZ655T9", Reward = "LargediamondsPack" },
	[14] = { Code = "20R8HC0Y", Reward = "LargediamondsPack" },
	[15] = { Code = "2KXHOT67", Reward = "LargediamondsPack" },
	[16] = { Code = "2NDJ5X2Y", Reward = "LargediamondsPack" },
	[17] = { Code = "2NQT277O", Reward = "LargediamondsPack" },
	[18] = { Code = "2P19PY2A", Reward = "LargediamondsPack" },
	[19] = { Code = "2ZFYZXRM", Reward = "LargediamondsPack" },
	[20] = { Code = "3CXNXNU1", Reward = "LargediamondsPack" },
	[21] = { Code = "3UBMQZTV", Reward = "LargediamondsPack" },
	[22] = { Code = "3X8Z3Z4K", Reward = "LargediamondsPack" },
	[23] = { Code = "3XYU6H8Y", Reward = "LargediamondsPack" },
	[24] = { Code = "439W6RGZ", Reward = "LargediamondsPack" },
	[25] = { Code = "48JMAB7T", Reward = "LargediamondsPack" },
	[26] = { Code = "4KW3OAJW", Reward = "LargediamondsPack" },
	[27] = { Code = "4OU7J8DA", Reward = "LargediamondsPack" },
	[28] = { Code = "501AZUM9", Reward = "LargediamondsPack" },
	[29] = { Code = "558ZPVB5", Reward = "LargediamondsPack" },
	[30] = { Code = "5KZBMKTH", Reward = "LargediamondsPack" },
	[31] = { Code = "5UNQFNRJ", Reward = "LargediamondsPack" },
	[32] = { Code = "5URZ9ZYB", Reward = "LargediamondsPack" },
	[33] = { Code = "5YW22ETQ", Reward = "LargediamondsPack" },
	[34] = { Code = "5Z7N0JDV", Reward = "LargediamondsPack" },
	[35] = { Code = "60S4ANMM", Reward = "LargediamondsPack" },
	[36] = { Code = "61TI1NOA", Reward = "LargediamondsPack" },
	[37] = { Code = "62X05UA0", Reward = "LargediamondsPack" },
	[38] = { Code = "6K1VDR98", Reward = "LargediamondsPack" },
	[39] = { Code = "6Z8HT6GY", Reward = "LargediamondsPack" },
	[40] = { Code = "7CBC4PEM", Reward = "LargediamondsPack" },
	[41] = { Code = "7CLGYJVG", Reward = "LargediamondsPack" },
	[42] = { Code = "7DISFT94", Reward = "LargediamondsPack" },
	[43] = { Code = "7E77HGYF", Reward = "LargediamondsPack" },
	[44] = { Code = "7KBQE13T", Reward = "LargediamondsPack" },
	[45] = { Code = "83C5IK6X", Reward = "LargediamondsPack" },
	[46] = { Code = "8BTB895M", Reward = "LargediamondsPack" },
	[47] = { Code = "8OO3JRS8", Reward = "LargediamondsPack" },
	[48] = { Code = "8UHZ7DJJ", Reward = "LargediamondsPack" },
	[49] = { Code = "8VAT7N9S", Reward = "LargediamondsPack" },
	[50] = { Code = "8WNNHFNH", Reward = "LargediamondsPack" },
	[51] = { Code = "8XG2UAEB", Reward = "HugeMoneyPack" },
	[52] = { Code = "97SOH11Q", Reward = "HugeMoneyPack" },
	[53] = { Code = "9D5IS95K", Reward = "HugeMoneyPack" },
	[54] = { Code = "9FHE5UQ0", Reward = "HugeMoneyPack" },
	[55] = { Code = "9KI14Z3K", Reward = "HugeMoneyPack" },
	[56] = { Code = "9NL4KFHW", Reward = "HugeMoneyPack" },
	[57] = { Code = "9UPTYD0D", Reward = "HugeMoneyPack" },
	[58] = { Code = "A9REG5P5", Reward = "HugeMoneyPack" },
	[59] = { Code = "ABI9E1ZX", Reward = "HugeMoneyPack" },
	[60] = { Code = "B32J2CF1", Reward = "HugeMoneyPack" },
	[61] = { Code = "BCFAM7CY", Reward = "HugeMoneyPack" },
	[62] = { Code = "BEN0HJZE", Reward = "HugeMoneyPack" },
	[63] = { Code = "BISF3AP6", Reward = "HugeMoneyPack" },
	[64] = { Code = "BJT67NX4", Reward = "HugeMoneyPack" },
	[65] = { Code = "BLS4SV10", Reward = "HugeMoneyPack" },
	[66] = { Code = "BNUCD9P5", Reward = "HugeMoneyPack" },
	[67] = { Code = "BPQ18UV6", Reward = "HugeMoneyPack" },
	[68] = { Code = "BXXAIZVZ", Reward = "HugeMoneyPack" },
	[69] = { Code = "C39CESVQ", Reward = "HugeMoneyPack" },
	[70] = { Code = "C6MRCELC", Reward = "HugeMoneyPack" },
	[71] = { Code = "CBX6NGHM", Reward = "HugeMoneyPack" },
	[72] = { Code = "CESP2Y9G", Reward = "HugeMoneyPack" },
	[73] = { Code = "CLZ4WKKS", Reward = "HugeMoneyPack" },
	[74] = { Code = "CZMCBMUT", Reward = "HugeMoneyPack" },
	[75] = { Code = "D1HQGIVK", Reward = "HugeMoneyPack" },
	[76] = { Code = "D2R9HWU5", Reward = "HugeMoneyPack" },
	[77] = { Code = "D5WUIDLT", Reward = "HugeMoneyPack" },
	[78] = { Code = "D6AXGQA6", Reward = "HugeMoneyPack" },
	[79] = { Code = "D9GRWTMP", Reward = "HugeMoneyPack" },
	[80] = { Code = "DEL8JP7S", Reward = "HugeMoneyPack" },
	[81] = { Code = "E4IC5E9Q", Reward = "HugeMoneyPack" },
	[82] = { Code = "E4UCF9NN", Reward = "HugeMoneyPack" },
	[83] = { Code = "EI2IRGNC", Reward = "HugeMoneyPack" },
	[84] = { Code = "EIMW91OJ", Reward = "HugeMoneyPack" },
	[85] = { Code = "EJLXZ3YK", Reward = "HugeMoneyPack" },
	[86] = { Code = "ELS9BZFW", Reward = "HugeMoneyPack" },
	[87] = { Code = "ENVZQ2L4", Reward = "HugeMoneyPack" },
	[88] = { Code = "F483ND4N", Reward = "HugeMoneyPack" },
	[89] = { Code = "F8DGP7A2", Reward = "HugeMoneyPack" },
	[90] = { Code = "FW1NR7Y8", Reward = "HugeMoneyPack" },
	[91] = { Code = "G1LJIZMD", Reward = "HugeMoneyPack" },
	[92] = { Code = "G7DNO6SH", Reward = "HugeMoneyPack" },
	[93] = { Code = "GCNET6FQ", Reward = "HugeMoneyPack" },
	[94] = { Code = "GEXLW8H6", Reward = "HugeMoneyPack" },
	[95] = { Code = "GG6OO722", Reward = "HugeMoneyPack" },
	[96] = { Code = "GO7JN55V", Reward = "HugeMoneyPack" },
	[97] = { Code = "GOX4DJJ6", Reward = "HugeMoneyPack" },
	[98] = { Code = "GSGWHS1Y", Reward = "HugeMoneyPack" },
	[99] = { Code = "GUIWQY3D", Reward = "HugeMoneyPack" },
	[100] = { Code = "GUR2DBGA", Reward = "HugeMoneyPack" },
	[101] = { Code = "HN0ORKU6", Reward = "VIP" },
	[102] = { Code = "HUKUZG4W", Reward = "VIP" },
	[103] = { Code = "I6DC05DZ", Reward = "VIP" },
	[104] = { Code = "IJXCWQR7", Reward = "VIP" },
	[105] = { Code = "IK20LRQJ", Reward = "VIP" },
	[106] = { Code = "IO3I638K", Reward = "VIP" },
	[107] = { Code = "ISC3QNEV", Reward = "VIP" },
	[108] = { Code = "J6AZ1DBA", Reward = "VIP" },
	[109] = { Code = "JCHVHFU6", Reward = "VIP" },
	[110] = { Code = "JEZ0RRGT", Reward = "VIP" },
	[111] = { Code = "JGTQ289T", Reward = "VIP" },
	[112] = { Code = "JHDNSMCY", Reward = "VIP" },
	[113] = { Code = "JLA0ZLLK", Reward = "VIP" },
	[114] = { Code = "JWPLUJQU", Reward = "VIP" },
	[115] = { Code = "KAMBCNKU", Reward = "VIP" },
	[116] = { Code = "KDOLBVY9", Reward = "VIP" },
	[117] = { Code = "KG0XLM7H", Reward = "VIP" },
	[118] = { Code = "KUAEPF43", Reward = "VIP" },
	[119] = { Code = "KZDR7M6P", Reward = "VIP" },
	[120] = { Code = "L65PVTC6", Reward = "VIP" },
	[121] = { Code = "L8WNRB3X", Reward = "VIP" },
	[122] = { Code = "L92W30LG", Reward = "VIP" },
	[123] = { Code = "LL2U23RZ", Reward = "VIP" },
	[124] = { Code = "M3WE3SJA", Reward = "VIP" },
	[125] = { Code = "M9AUXMUK", Reward = "VIP" },
	[126] = { Code = "MBXLA7HO", Reward = "VIP" },
	[127] = { Code = "MI4RY2NU", Reward = "VIP" },
	[128] = { Code = "MJQP6P2Q", Reward = "VIP" },
	[129] = { Code = "MM8DJY4F", Reward = "VIP" },
	[130] = { Code = "MTTVWRZB", Reward = "VIP" },
	[131] = { Code = "MZV8TM0L", Reward = "VIP" },
	[132] = { Code = "N00V9RW5", Reward = "VIP" },
	[133] = { Code = "N1AZZT33", Reward = "VIP" },
	[134] = { Code = "N50DSEZ5", Reward = "VIP" },
	[135] = { Code = "NK8G3SYJ", Reward = "VIP" },
	[136] = { Code = "NKMENE1T", Reward = "VIP" },
	[137] = { Code = "NMFSXPUE", Reward = "VIP" },
	[138] = { Code = "NNQ2Z7AM", Reward = "VIP" },
	[139] = { Code = "NSE40IB6", Reward = "VIP" },
	[140] = { Code = "NWLL7JR2", Reward = "VIP" },
	[141] = { Code = "OEPW0FJN", Reward = "VIP" },
	[142] = { Code = "OMTHR179", Reward = "VIP" },
	[143] = { Code = "OZ64Q44N", Reward = "VIP" },
	[144] = { Code = "P2KV2XQD", Reward = "VIP" },
	[145] = { Code = "P3GSMKG4", Reward = "VIP" },
	[146] = { Code = "PCGX5IGZ", Reward = "VIP" },
	[147] = { Code = "PHXXAJ24", Reward = "VIP" },
	[148] = { Code = "Q6926TK4", Reward = "VIP" },
	[149] = { Code = "Q8DWMJP3", Reward = "VIP" },
	[150] = { Code = "QEEVIM6I", Reward = "VIP" },
	[151] = { Code = "QIPH9CDC", Reward = "2xCash" },
	[152] = { Code = "QV3TA3XW", Reward = "2xCash" },
	[153] = { Code = "R4ZRV0G7", Reward = "2xCash" },
	[154] = { Code = "ROYACZQP", Reward = "2xCash" },
	[155] = { Code = "RXQTR3PF", Reward = "2xCash" },
	[156] = { Code = "RZHKP3VU", Reward = "2xCash" },
	[157] = { Code = "S0HN2Q71", Reward = "2xCash" },
	[158] = { Code = "S4SX17ZW", Reward = "2xCash" },
	[159] = { Code = "S7WENIJ0", Reward = "2xCash" },
	[160] = { Code = "SERAD7DM", Reward = "2xCash" },
	[161] = { Code = "TNBMLWWI", Reward = "2xCash" },
	[162] = { Code = "TUFTJEFV", Reward = "2xCash" },
	[163] = { Code = "TVWFDAN2", Reward = "2xCash" },
	[164] = { Code = "TXU3HWWQ", Reward = "2xCash" },
	[165] = { Code = "TYOFWCLR", Reward = "2xCash" },
	[166] = { Code = "U3O0748S", Reward = "2xCash" },
	[167] = { Code = "U8Q6GCEL", Reward = "2xCash" },
	[168] = { Code = "URXJNJ20", Reward = "2xCash" },
	[169] = { Code = "VCFB0AY3", Reward = "2xCash" },
	[170] = { Code = "VECCLQZI", Reward = "2xCash" },
	[171] = { Code = "VGDDDCZ5", Reward = "2xCash" },
	[172] = { Code = "VOT6PV9H", Reward = "2xCash" },
	[173] = { Code = "VWI6J4GP", Reward = "2xCash" },
	[174] = { Code = "W5G7WRK1", Reward = "2xCash" },
	[175] = { Code = "W67HTAI0", Reward = "2xCash" },
	[176] = { Code = "WJE2L2AH", Reward = "2xCash" },
	[177] = { Code = "WNHGGXV6", Reward = "2xCash" },
	[178] = { Code = "X1TX6ML2", Reward = "2xCash" },
	[179] = { Code = "X2AV6CMJ", Reward = "2xCash" },
	[180] = { Code = "X6CXG5N3", Reward = "2xCash" },
	[181] = { Code = "X8O4T9WZ", Reward = "2xCash" },
	[182] = { Code = "XAA9X32H", Reward = "2xCash" },
	[183] = { Code = "XFLOVDT6", Reward = "2xCash" },
	[184] = { Code = "XIA3MHHW", Reward = "2xCash" },
	[185] = { Code = "XPJXNJTP", Reward = "2xCash" },
	[186] = { Code = "XR8C5UP5", Reward = "2xCash" },
	[187] = { Code = "XTT1WSWW", Reward = "2xCash" },
	[188] = { Code = "XV42E9FY", Reward = "2xCash" },
	[189] = { Code = "XWRH3238", Reward = "2xCash" },
	[190] = { Code = "Y6KB215X", Reward = "2xCash" },
	[191] = { Code = "Y97K6RSD", Reward = "2xCash" },
	[192] = { Code = "Y9WZ853N", Reward = "2xCash" },
	[193] = { Code = "YX3L9RI7", Reward = "2xCash" },
	[194] = { Code = "Z2MKCG7I", Reward = "2xCash" },
	[195] = { Code = "Z2PB5XLR", Reward = "2xCash" },
	[196] = { Code = "ZBQK5OCX", Reward = "2xCash" },
	[197] = { Code = "ZK4HTGHR", Reward = "2xCash" },
	[198] = { Code = "ZLLMN82A", Reward = "2xCash" },
	[199] = { Code = "ZNDD0LEH", Reward = "2xCash" },
	[200] = { Code = "ZRE97OI4", Reward = "2xCash" },
	

	[201] = { Code = "S8CNP5LB", Reward = "LargediamondsPack" },
	[202] = { Code = "3XJSEW6B", Reward = "LargediamondsPack" },
	[203] = { Code = "QLSOODMH", Reward = "LargediamondsPack" },
	[204] = { Code = "XL035IAI", Reward = "LargediamondsPack" },
	[205] = { Code = "PDGV1BTL", Reward = "LargediamondsPack" },
	[206] = { Code = "DH4SS86R", Reward = "LargediamondsPack" },
	[207] = { Code = "7OSE00LH", Reward = "LargediamondsPack" },
	[208] = { Code = "7NSW0NZE", Reward = "LargediamondsPack" },
	[209] = { Code = "Q7VTBWJ0", Reward = "LargediamondsPack" },
	[210] = { Code = "W4XRZM10", Reward = "LargediamondsPack" },
	[211] = { Code = "XFQ65JKB", Reward = "LargediamondsPack" },
	[212] = { Code = "DYW32ZGI", Reward = "LargediamondsPack" },
	[213] = { Code = "DJI5GQJG", Reward = "LargediamondsPack" },
	[214] = { Code = "0ZPKFVTS", Reward = "LargediamondsPack" },
	[215] = { Code = "HK6F1ZFF", Reward = "LargediamondsPack" },
	[216] = { Code = "8KAKSGUY", Reward = "LargediamondsPack" },
	[217] = { Code = "MVNJBLNG", Reward = "LargediamondsPack" },
	[218] = { Code = "2DOQ4HZY", Reward = "LargediamondsPack" },
	[219] = { Code = "BSZX4SJ9", Reward = "LargediamondsPack" },
	[220] = { Code = "LDY8OOHZ", Reward = "LargediamondsPack" },
	[221] = { Code = "4F78D3FM", Reward = "LargediamondsPack" },
	[222] = { Code = "6CCK0IDS", Reward = "LargediamondsPack" },
	[223] = { Code = "8L9UZSL2", Reward = "LargediamondsPack" },
	[224] = { Code = "9DXA8HUN", Reward = "LargediamondsPack" },
	[225] = { Code = "DQNFSXIZ", Reward = "LargediamondsPack" },
	[226] = { Code = "LFKAC83L", Reward = "LargediamondsPack" },
	[227] = { Code = "V49JM0BG", Reward = "LargediamondsPack" },
	[228] = { Code = "76BVVTA1", Reward = "LargediamondsPack" },
	[229] = { Code = "GVS2ITMR", Reward = "LargediamondsPack" },
	[230] = { Code = "NJW8S8IZ", Reward = "LargediamondsPack" },
	[231] = { Code = "ZBMKUOD5", Reward = "LargediamondsPack" },
	[232] = { Code = "BIDBL2RR", Reward = "LargediamondsPack" },
	[233] = { Code = "EL1KRM26", Reward = "LargediamondsPack" },
	[234] = { Code = "7FB8VO3N", Reward = "LargediamondsPack" },
	[235] = { Code = "ZH5CPNCM", Reward = "LargediamondsPack" },
	[236] = { Code = "CFXG835S", Reward = "LargediamondsPack" },
	[237] = { Code = "DGP731KN", Reward = "LargediamondsPack" },
	[238] = { Code = "PXTP8WYW", Reward = "LargediamondsPack" },
	[239] = { Code = "DF63M6E9", Reward = "LargediamondsPack" },
	[240] = { Code = "E24QZLBG", Reward = "LargediamondsPack" },
	[241] = { Code = "63WK497B", Reward = "LargediamondsPack" },
	[242] = { Code = "WHZ991HD", Reward = "LargediamondsPack" },
	[243] = { Code = "RWD44SRY", Reward = "LargediamondsPack" },
	[244] = { Code = "H0K61DOY", Reward = "LargediamondsPack" },
	[245] = { Code = "OIIRN9MM", Reward = "LargediamondsPack" },
	[246] = { Code = "4ULM3WX8", Reward = "LargediamondsPack" },
	[247] = { Code = "RMAURGSB", Reward = "LargediamondsPack" },
	[248] = { Code = "2UFUQHIP", Reward = "LargediamondsPack" },
	[249] = { Code = "OKIUDD4N", Reward = "LargediamondsPack" },
	[250] = { Code = "1YY4D94V", Reward = "LargediamondsPack" },
	[251] = { Code = "XC6ND0PP", Reward = "LargediamondsPack" },
	[252] = { Code = "G2AK3VJD", Reward = "LargediamondsPack" },
	[253] = { Code = "A5S8CMV7", Reward = "LargediamondsPack" },
	[254] = { Code = "VFC9MXW5", Reward = "LargediamondsPack" },
	[255] = { Code = "TCP2C0P0", Reward = "LargediamondsPack" },
	[256] = { Code = "OC8VS7RY", Reward = "LargediamondsPack" },
	[257] = { Code = "KAIVDZSD", Reward = "LargediamondsPack" },
	[258] = { Code = "P25SAMVJ", Reward = "LargediamondsPack" },
	[259] = { Code = "47NVVMY0", Reward = "LargediamondsPack" },
	[260] = { Code = "N6NLDKXC", Reward = "LargediamondsPack" },
	[261] = { Code = "41OV62VW", Reward = "LargediamondsPack" },
	[262] = { Code = "2Z3TTGD0", Reward = "LargediamondsPack" },
	[263] = { Code = "ZVYO5EIR", Reward = "LargediamondsPack" },
	[264] = { Code = "Y1ZMNKBM", Reward = "LargediamondsPack" },
	[265] = { Code = "U04VI1WP", Reward = "LargediamondsPack" },
	[266] = { Code = "NDQ8EWGE", Reward = "LargediamondsPack" },
	[267] = { Code = "GBM227XY", Reward = "LargediamondsPack" },
	[268] = { Code = "3G04V90V", Reward = "LargediamondsPack" },
	[269] = { Code = "NYO8NFUJ", Reward = "LargediamondsPack" },
	[270] = { Code = "I2825ANM", Reward = "LargediamondsPack" },
	[271] = { Code = "T1UCF27J", Reward = "LargediamondsPack" },
	[272] = { Code = "28UI1Z6J", Reward = "LargediamondsPack" },
	[273] = { Code = "JJZ2JQZH", Reward = "LargediamondsPack" },
	[274] = { Code = "U41Y1GS2", Reward = "LargediamondsPack" },
	[275] = { Code = "1CWROZCB", Reward = "LargediamondsPack" },
	[276] = { Code = "KI7AATOC", Reward = "HugeMoneyPack" },
	[277] = { Code = "5KLHVGYZ", Reward = "HugeMoneyPack" },
	[278] = { Code = "PFW8QVWG", Reward = "HugeMoneyPack" },
	[279] = { Code = "CWP52RO6", Reward = "HugeMoneyPack" },
	[280] = { Code = "W4AX1MJV", Reward = "HugeMoneyPack" },
	[281] = { Code = "B7HA9TFE", Reward = "HugeMoneyPack" },
	[282] = { Code = "V2NFVIRD", Reward = "HugeMoneyPack" },
	[283] = { Code = "90VUI4G2", Reward = "HugeMoneyPack" },
	[284] = { Code = "I27K2VCA", Reward = "HugeMoneyPack" },
	[285] = { Code = "M8NB007X", Reward = "HugeMoneyPack" },
	[286] = { Code = "1IJ8JLD0", Reward = "HugeMoneyPack" },
	[287] = { Code = "P8B0EGCU", Reward = "HugeMoneyPack" },
	[288] = { Code = "JW60CRJH", Reward = "HugeMoneyPack" },
	[289] = { Code = "4D9ZRO2V", Reward = "HugeMoneyPack" },
	[290] = { Code = "AAIKNDRE", Reward = "HugeMoneyPack" },
	[291] = { Code = "S99UEG1N", Reward = "HugeMoneyPack" },
	[292] = { Code = "ZGONI1C0", Reward = "HugeMoneyPack" },
	[293] = { Code = "SJ2PYB17", Reward = "HugeMoneyPack" },
	[294] = { Code = "4BW8N04E", Reward = "HugeMoneyPack" },
	[295] = { Code = "NXNWQSW4", Reward = "HugeMoneyPack" },
	[296] = { Code = "6FK2BTBP", Reward = "HugeMoneyPack" },
	[297] = { Code = "BNCUL0P5", Reward = "HugeMoneyPack" },
	[298] = { Code = "DP9A12LQ", Reward = "HugeMoneyPack" },
	[299] = { Code = "6OZDYX4T", Reward = "HugeMoneyPack" },
	[300] = { Code = "ZC62LYRU", Reward = "HugeMoneyPack" },
	[301] = { Code = "2ISL57QK", Reward = "HugeMoneyPack" },
	[302] = { Code = "T7WKTVCU", Reward = "HugeMoneyPack" },
	[303] = { Code = "HRB6JTTS", Reward = "HugeMoneyPack" },
	[304] = { Code = "3QWQ9DHN", Reward = "HugeMoneyPack" },
	[305] = { Code = "PZOSP170", Reward = "HugeMoneyPack" },
	[306] = { Code = "3QBP1C7R", Reward = "HugeMoneyPack" },
	[307] = { Code = "YBCE8G57", Reward = "HugeMoneyPack" },
	[308] = { Code = "8CVM386Z", Reward = "HugeMoneyPack" },
	[309] = { Code = "8LCX5HIF", Reward = "HugeMoneyPack" },
	[310] = { Code = "DNMCHQRG", Reward = "HugeMoneyPack" },
	[311] = { Code = "DAT14YRN", Reward = "HugeMoneyPack" },
	[312] = { Code = "PRTRJNS7", Reward = "HugeMoneyPack" },
	[313] = { Code = "PTPQJLVZ", Reward = "HugeMoneyPack" },
	[314] = { Code = "4WBEB73T", Reward = "HugeMoneyPack" },
	[315] = { Code = "P4DBLH4C", Reward = "HugeMoneyPack" },
	[316] = { Code = "4IRUS17M", Reward = "HugeMoneyPack" },
	[317] = { Code = "IWED5SE6", Reward = "HugeMoneyPack" },
	[318] = { Code = "AD9TT6G6", Reward = "HugeMoneyPack" },
	[319] = { Code = "4PUEU091", Reward = "HugeMoneyPack" },
	[320] = { Code = "29F8FTI6", Reward = "HugeMoneyPack" },
	[321] = { Code = "9RDV2JAN", Reward = "HugeMoneyPack" },
	[322] = { Code = "HOVBV0LA", Reward = "HugeMoneyPack" },
	[323] = { Code = "Y14OST8E", Reward = "HugeMoneyPack" },
	[324] = { Code = "7ZD4AH4M", Reward = "HugeMoneyPack" },
	[325] = { Code = "XXICT35N", Reward = "HugeMoneyPack" },
	[326] = { Code = "BYIAIYX5", Reward = "HugeMoneyPack" },
	[327] = { Code = "IJICQ681", Reward = "HugeMoneyPack" },
	[328] = { Code = "SFWMYU3C", Reward = "HugeMoneyPack" },
	[329] = { Code = "L5P402IS", Reward = "HugeMoneyPack" },
	[330] = { Code = "MUX2BDMQ", Reward = "HugeMoneyPack" },
	[331] = { Code = "EZV6CBUV", Reward = "HugeMoneyPack" },
	[332] = { Code = "ZJLHT63H", Reward = "HugeMoneyPack" },
	[333] = { Code = "7K1Z14SN", Reward = "HugeMoneyPack" },
	[334] = { Code = "Q09RAF37", Reward = "HugeMoneyPack" },
	[335] = { Code = "LCXY3MDB", Reward = "HugeMoneyPack" },
	[336] = { Code = "MW73LTEG", Reward = "HugeMoneyPack" },
	[337] = { Code = "CA32A6KM", Reward = "HugeMoneyPack" },
	[338] = { Code = "RC82WIDM", Reward = "HugeMoneyPack" },
	[339] = { Code = "W8220JQJ", Reward = "HugeMoneyPack" },
	[340] = { Code = "EIS2VFGV", Reward = "HugeMoneyPack" },
	[341] = { Code = "0H9IWDEV", Reward = "HugeMoneyPack" },
	[342] = { Code = "TJSLQ6HP", Reward = "HugeMoneyPack" },
	[343] = { Code = "22WJB57C", Reward = "HugeMoneyPack" },
	[344] = { Code = "66JNO0MA", Reward = "HugeMoneyPack" },
	[345] = { Code = "8GJKI20K", Reward = "HugeMoneyPack" },
	[346] = { Code = "ZUX1SR8Q", Reward = "HugeMoneyPack" },
	[347] = { Code = "NRFDYD84", Reward = "HugeMoneyPack" },
	[348] = { Code = "L5EYCK0Z", Reward = "HugeMoneyPack" },
	[349] = { Code = "YXFMW2XB", Reward = "HugeMoneyPack" },
	[350] = { Code = "XYFTO5BB", Reward = "HugeMoneyPack" },
	[351] = { Code = "EN34JXR3", Reward = "VIP" },
	[352] = { Code = "S8ICOB2W", Reward = "VIP" },
	[353] = { Code = "UXJ4BCYF", Reward = "VIP" },
	[354] = { Code = "SUKHH4K7", Reward = "VIP" },
	[355] = { Code = "HQCIDIKL", Reward = "VIP" },
	[356] = { Code = "MY51Z4YE", Reward = "VIP" },
	[357] = { Code = "CEVQG2K8", Reward = "VIP" },
	[358] = { Code = "G6I8I5X1", Reward = "VIP" },
	[359] = { Code = "VNQ5OWNV", Reward = "VIP" },
	[360] = { Code = "VCJ7EXQ4", Reward = "VIP" },
	[361] = { Code = "K4D3WDJZ", Reward = "VIP" },
	[362] = { Code = "VAHTVFYV", Reward = "VIP" },
	[363] = { Code = "4Y4G4EDC", Reward = "VIP" },
	[364] = { Code = "46W05LOU", Reward = "VIP" },
	[365] = { Code = "3N5QQKOG", Reward = "VIP" },
	[366] = { Code = "IKXZU11E", Reward = "VIP" },
	[367] = { Code = "8EI8IC4C", Reward = "VIP" },
	[368] = { Code = "1JC0YG6P", Reward = "VIP" },
	[369] = { Code = "PWL6C3B7", Reward = "VIP" },
	[370] = { Code = "NM0PITXK", Reward = "VIP" },
	[371] = { Code = "DTIOTHKR", Reward = "VIP" },
	[372] = { Code = "X5B2D25U", Reward = "VIP" },
	[373] = { Code = "6ELDCSOJ", Reward = "VIP" },
	[374] = { Code = "B4MF7KQ9", Reward = "VIP" },
	[375] = { Code = "ARUYR5R2", Reward = "VIP" },
	[376] = { Code = "EO5CN5PM", Reward = "VIP" },
	[377] = { Code = "XGGRGOR3", Reward = "VIP" },
	[378] = { Code = "09BMAYH0", Reward = "VIP" },
	[379] = { Code = "MDGPU025", Reward = "VIP" },
	[380] = { Code = "LJHK33SV", Reward = "VIP" },
	[381] = { Code = "BP16M77R", Reward = "VIP" },
	[382] = { Code = "MF5ULG0I", Reward = "VIP" },
	[383] = { Code = "PHXZ478J", Reward = "VIP" },
	[384] = { Code = "IOXCQVDS", Reward = "VIP" },
	[385] = { Code = "Q2EUAY81", Reward = "VIP" },
	[386] = { Code = "WVN37RNR", Reward = "VIP" },
	[387] = { Code = "YJANS37L", Reward = "VIP" },
	[388] = { Code = "US8VYL5O", Reward = "VIP" },
	[389] = { Code = "DY01W3UX", Reward = "VIP" },
	[390] = { Code = "BIZ9S2SF", Reward = "VIP" },
	[391] = { Code = "DR5YJHXT", Reward = "VIP" },
	[392] = { Code = "F71M2PQR", Reward = "VIP" },
	[393] = { Code = "G5UGCMSZ", Reward = "VIP" },
	[394] = { Code = "DFGKAJNA", Reward = "VIP" },
	[395] = { Code = "4OQCU4W3", Reward = "VIP" },
	[396] = { Code = "7MBKO086", Reward = "VIP" },
	[397] = { Code = "M64FFPX6", Reward = "VIP" },
	[398] = { Code = "481XCJDT", Reward = "VIP" },
	[399] = { Code = "9BIKKTBU", Reward = "VIP" },
	[400] = { Code = "TTSTWATK", Reward = "VIP" },
	[401] = { Code = "Y1UINTKD", Reward = "VIP" },
	[402] = { Code = "8MR8D3BE", Reward = "VIP" },
	[403] = { Code = "Z3GLT2KN", Reward = "VIP" },
	[404] = { Code = "GZVXKS9K", Reward = "VIP" },
	[405] = { Code = "08KHTPD7", Reward = "VIP" },
	[406] = { Code = "14C2Y52M", Reward = "VIP" },
	[407] = { Code = "I7JULYBD", Reward = "VIP" },
	[408] = { Code = "7VR3YRDB", Reward = "VIP" },
	[409] = { Code = "N4RZIAE3", Reward = "VIP" },
	[410] = { Code = "29VWZCPO", Reward = "VIP" },
	[411] = { Code = "GYY44TXG", Reward = "VIP" },
	[412] = { Code = "HGNTT2UG", Reward = "VIP" },
	[413] = { Code = "60KZNFQP", Reward = "VIP" },
	[414] = { Code = "XVYOAH54", Reward = "VIP" },
	[415] = { Code = "145XJ3ZL", Reward = "VIP" },
	[416] = { Code = "KJ0CTSCG", Reward = "VIP" },
	[417] = { Code = "YDAT5704", Reward = "VIP" },
	[418] = { Code = "ET0ECGNR", Reward = "VIP" },
	[419] = { Code = "RCRVF7HB", Reward = "VIP" },
	[420] = { Code = "MI7BE4QM", Reward = "VIP" },
	[421] = { Code = "PLDYPQU6", Reward = "VIP" },
	[422] = { Code = "XD6Y0TLA", Reward = "VIP" },
	[423] = { Code = "FHA7W109", Reward = "VIP" },
	[424] = { Code = "ZJ6V268L", Reward = "VIP" },
	[425] = { Code = "T5MPFAVU", Reward = "VIP" },
	[426] = { Code = "IVQFGDA0", Reward = "2xCash" },
	[427] = { Code = "IF1C81MZ", Reward = "2xCash" },
	[428] = { Code = "X2BXEKJ3", Reward = "2xCash" },
	[429] = { Code = "U7VK1MCC", Reward = "2xCash" },
	[430] = { Code = "P5BA4WQA", Reward = "2xCash" },
	[431] = { Code = "OZV24I1M", Reward = "2xCash" },
	[432] = { Code = "ECTXNLA1", Reward = "2xCash" },
	[433] = { Code = "93247GZR", Reward = "2xCash" },
	[434] = { Code = "DWGFK46R", Reward = "2xCash" },
	[435] = { Code = "FF9HXH2F", Reward = "2xCash" },
	[436] = { Code = "6U0WKZZM", Reward = "2xCash" },
	[437] = { Code = "Y9E7GBC9", Reward = "2xCash" },
	[438] = { Code = "J3LMVTV0", Reward = "2xCash" },
	[439] = { Code = "J5PXWZH3", Reward = "2xCash" },
	[440] = { Code = "DLKF1ZW0", Reward = "2xCash" },
	[441] = { Code = "GPV818U4", Reward = "2xCash" },
	[442] = { Code = "PGFCM7X5", Reward = "2xCash" },
	[443] = { Code = "I4GK0ZKF", Reward = "2xCash" },
	[444] = { Code = "GFWK918G", Reward = "2xCash" },
	[445] = { Code = "03PO6269", Reward = "2xCash" },
	[446] = { Code = "O4Y8X0QS", Reward = "2xCash" },
	[447] = { Code = "OYEPR498", Reward = "2xCash" },
	[448] = { Code = "WNH09X6J", Reward = "2xCash" },
	[449] = { Code = "LYZUCFKX", Reward = "2xCash" },
	[450] = { Code = "M8R96551", Reward = "2xCash" },
	[451] = { Code = "BK7YXQQ2", Reward = "2xCash" },
	[452] = { Code = "TN5RAI7O", Reward = "2xCash" },
	[453] = { Code = "UXTOPGMK", Reward = "2xCash" },
	[454] = { Code = "IPBJZBQN", Reward = "2xCash" },
	[455] = { Code = "VJ8F8XZF", Reward = "2xCash" },
	[456] = { Code = "ACYZD2RL", Reward = "2xCash" },
	[457] = { Code = "9XO0F40U", Reward = "2xCash" },
	[458] = { Code = "UDNMT2B0", Reward = "2xCash" },
	[459] = { Code = "27RXFWGP", Reward = "2xCash" },
	[460] = { Code = "42UFZJDJ", Reward = "2xCash" },
	[461] = { Code = "WA1GEA65", Reward = "2xCash" },
	[462] = { Code = "4LM2MG7X", Reward = "2xCash" },
	[463] = { Code = "XU3TV27R", Reward = "2xCash" },
	[464] = { Code = "R8F54DC3", Reward = "2xCash" },
	[465] = { Code = "4A8DP8C3", Reward = "2xCash" },
	[466] = { Code = "KDDMD7WB", Reward = "2xCash" },
	[467] = { Code = "OQLIBAIP", Reward = "2xCash" },
	[468] = { Code = "M6D93MQ6", Reward = "2xCash" },
	[469] = { Code = "V0BUZE8I", Reward = "2xCash" },
	[470] = { Code = "ZWZMXTUL", Reward = "2xCash" },
	[471] = { Code = "PI28LN0B", Reward = "2xCash" },
	[472] = { Code = "FB6BH30M", Reward = "2xCash" },
	[473] = { Code = "KSMO8BAQ", Reward = "2xCash" },
	[474] = { Code = "QEHN8WCX", Reward = "2xCash" },
	[475] = { Code = "PFRAJJW6", Reward = "2xCash" },
	[476] = { Code = "PVZT7LCJ", Reward = "2xCash" },
	[477] = { Code = "57NXTPK8", Reward = "2xCash" },
	[478] = { Code = "CUO5F2GA", Reward = "2xCash" },
	[479] = { Code = "5TX7Y2WA", Reward = "2xCash" },
	[480] = { Code = "I6UYGFES", Reward = "2xCash" },
	[481] = { Code = "9G5QUK1Y", Reward = "2xCash" },
	[482] = { Code = "8EZ9OEIL", Reward = "2xCash" },
	[483] = { Code = "Y2KAWO4R", Reward = "2xCash" },
	[484] = { Code = "SVXTO11B", Reward = "2xCash" },
	[485] = { Code = "RKUYM5I1", Reward = "2xCash" },
	[486] = { Code = "HZZVVVCH", Reward = "2xCash" },
	[487] = { Code = "BX95ETUY", Reward = "2xCash" },
	[488] = { Code = "7R75UZV4", Reward = "2xCash" },
	[489] = { Code = "1REMDIJG", Reward = "2xCash" },
	[490] = { Code = "N9K537BB", Reward = "2xCash" },
	[491] = { Code = "819NN9FF", Reward = "2xCash" },
	[492] = { Code = "NF05ZHRD", Reward = "2xCash" },
	[493] = { Code = "1HL0QTC3", Reward = "2xCash" },
	[494] = { Code = "NQV9J0AH", Reward = "2xCash" },
	[495] = { Code = "SGF2E6M7", Reward = "2xCash" },
	[496] = { Code = "LAWFRHWU", Reward = "2xCash" },
	[497] = { Code = "BUE0TS0Q", Reward = "2xCash" },
	[498] = { Code = "GR66HY75", Reward = "2xCash" },
	[499] = { Code = "8QYN92ZR", Reward = "2xCash" },
	[500] = { Code = "415FTHKP", Reward = "2xCash" },
}

return module]]></ProtectedString>
						<string name="ScriptGuid">{1D0F823D-3875-4C0B-9AAF-91B593E67BF8}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Codes_Unique.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX0E8176371D73405CA9BA5B9FDFAA86E5">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Debug</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX5C1D859340134AA7AED59E00E73CECDC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Monetization/UGC_Data_Generator.server.lua
--
--  Description:
--      Pre-generates all UGC item metadata to avoid expensive calls to
--      MarketplaceService:GetProductInfo(). This script fetches prices,
--      names, and thumbnails once, then outputs a Lua table ready to be
--      used as a replacement for Monetization_Mod.UGC_Data.
--
--      Features:
--          • Safe wrapper around GetProductInfo (pcall protected)
--          • Automatic construction of a clean Lua data table
--          • Generates ID, Name, Price, and Thumbnail URL per UGC item
--          • Intended for offline precomputation / debug console usage
--
--  Last Modified: 2025-11-29 by Darkzeb
--  Version: V2025-11
--
--  Dependencies:
--      Services:
--          - MarketplaceService
--          - ReplicatedStorage
--
--      Modules:
--          - Data_Mods_F/Monetization_Mod
--
--  Notes:
--      • This script only *prints* the generated table. It does NOT save it.
--      • Prices default to 0 if the request fails.
--======================================================================

local MPS = game:GetService("MarketplaceService")
local RS = game:GetService("ReplicatedStorage")

local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local Monetization_Mod = require(Data_Mods_F:WaitForChild("Monetization_Mod"))

local UGC_Data = Monetization_Mod.Get_All_UGC_Data()

local function safeGetInfo(id)
	local ok, info = pcall(function()
		return MPS:GetProductInfo(id)
	end)
	if ok then return info end
	warn("FAILED to fetch product info for ID:", id)
	return { PriceInRobux = 0 }
end

local output = {}
table.insert(output, "return {")

for key, values in pairs(UGC_Data) do
	local id = values.ID
	local name = values.Name
	local info = safeGetInfo(id)
	local price = info.PriceInRobux or 0
	local thumbnail = "rbxthumb://type=Asset&Id=" .. tostring(id) .. "&w=150&h=150"

	-- Format a Lua entry
	local line = string.format(
		"\t[%q] = { Name = %q, ID = %d, Price = %d, Thumbnail = %q },",
		key, name, id, price, thumbnail
	)

	table.insert(output, line)
end

table.insert(output, "}")

-- Print final output
print(table.concat(output, "\n"))
]]></ProtectedString>
						<string name="ScriptGuid">{2C41B6DE-FBFB-4236-B546-5C22AA96B84E}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Get_All_UGCs.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2432EE233BA34503BD51E45A6E9C83AB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--======================================================================
--  File: Moderation/PurgeBannedUsers.server.lua
--
--  Description:
--      Removes manually banned UserIds from all OrderedDataStores
--      related to global leaderboards. Intended to run server-side
--      on startup to clean stored ranking data for banned players.
--
--      Features:
--          • Configurable list of banned UserIds
--          • Retries RemoveAsync safely (pcall + retry loop)
--          • Processes every leaderboard key consistently
--          • Non-blocking (task.spawn)
--
--  Last Modified: 2025-11-20 by Darkzeb
--  Version: V2025-09
--
--  Dependencies:
--      Services:
--          - DataStoreService
--
--      Data:
--          - OrderedDataStore keys from GlobalLeaderBoards.lua
--
--  Notes:
--      • Only removes entries from OrderedDataStores.
--      • Does not affect standard DataStores.
--      • Safe to keep in ServerScriptService for maintenance runs.
--======================================================================

local DataStoreService = game:GetService("DataStoreService")

---------------------------------------------------------------------
-- 🔥 EDIT THIS LIST YOURSELF – these are the banned UserIds
---------------------------------------------------------------------
local BANNED_USERS = {
	1567117245, --REQUIS
	7847209012, -- Manny
	3589858455 -- MBK Japan
}
---------------------------------------------------------------------

-- Must match the keys used in GlobalLeaderBoards.lua (+ LeaderboardKey = 2)
local LEADERBOARD_KEYS = {
	"Best Elo2",
	"Total Wins2",
	"Win Streak2",
	"Knockouts2",
	"Submissions Wins2",
	"Gym Training2",
	"Ranked Wins2"
}

local function removeFromStore(store, userId)
	for i = 1, 5 do
		local success, err = pcall(function()
			store:RemoveAsync(userId)
		end)

		if success then
			print("[Purge] Removed", userId, "from", store.Name)
			return
		end

		warn("[Purge] Failed removing:", userId, "Try:", i, "Error:", err)
		task.wait(1)
	end
end

local function purgeUser(userId)
	print("[Purge] Processing banned user:", userId)
	for _, key in ipairs(LEADERBOARD_KEYS) do
		local store = DataStoreService:GetOrderedDataStore(key)
		removeFromStore(store, userId)
	end
end

task.spawn(function()
	print("[Purge] Starting purge of banned players...")
	for _, userId in ipairs(BANNED_USERS) do
		purgeUser(userId)
	end
	print("[Purge] Completed.")
end)
]]></ProtectedString>
						<string name="ScriptGuid">{DA842F1C-41A3-4958-8DB5-CE9247E7462A}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CheatersLeaderboardsPurge.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX63D3EA933A2F44BCAD6E96AEC7BF303D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">MigrationDS</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXF96B51EC0C6D4EBC93AD57C0494B1DD3">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local DataStoreService = game:GetService("DataStoreService")
local M_LOG = "PLAYER_MIGRATION_LOG"
local OLD_SUFFIX = "_Game_Data"

local DS_Mod = require(script.Parent.Parent.Core.Datastore.DS_Module)
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

-- Recursively process pages
local function ProcessPage(plr, pages, count)
	for _, entry in ipairs(pages:GetCurrentPage()) do
		local userId = entry.KeyName
		local oldKey = userId .. OLD_SUFFIX
		DS_Mod.Delete_Legacy_DataStore(oldKey, "PLAYER_DATASTORE_LIVE")
		count += 1
	end

	if pages.IsFinished then
		return count
	end

	-- load next page and continue
	pages:AdvanceToNextPageAsync()
	return ProcessPage(plr, pages, count)
end

game.Players.PlayerAdded:Connect(function(plr)
	plr.Chatted:Connect(function(msg)
		if msg == "/cleanup_migrated" then
			if not PlayerUtils.isAdmin(plr) then
				plr:Kick("You are not allowed to run migration cleanup.")
				return
			end

			local logDS = DataStoreService:GetDataStore(M_LOG)

			local ok, pages = pcall(function()
				return logDS:ListKeysAsync()
			end)

			if not ok or not pages then
				warn("Cannot list migration log keys: ", pages)
				return
			end

			local count = ProcessPage(plr, pages, 0)

			plr:SendNotification({
				Title = "Migration Cleanup Done",
				Text = "Deleted old datastores for " .. tostring(count) .. " players",
				Duration = 8
			})

			print("[Migration] Cleanup complete, deleted:", count)
		end
	end)
end)
]]></ProtectedString>
							<string name="ScriptGuid">{396AC423-D1B6-4105-ADE4-E32E02F6BD2E}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">MigrationCleanup.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5B7C591F435342F78B7ADAAEE9E271D7">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local RS = game:GetService("ReplicatedStorage")
local DataStoreService = game:GetService("DataStoreService")
local PlayerUtils = require(game.ReplicatedStorage.Modules.PlayerUtils)

local M_LOG = "PLAYER_MIGRATION_LOG"
local OLD_SUFFIX = "_Game_Data"

local Channels = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Admin_Notification = Channels.SC_Remote_Events.Admin_Notification

local function countKeys(dsName)
	local ds = DataStoreService:GetDataStore(dsName)

	local ok, pages = pcall(function()
		return ds:ListKeysAsync()
	end)

	if not ok or not pages then
		return 0
	end

	local function processPage(pageObj, acc)
		acc += #pageObj:GetCurrentPage()

		if pageObj.IsFinished then
			return acc
		end

		local okNext = pcall(function()
			pageObj:AdvanceToNextPageAsync()
		end)

		if not okNext then
			return acc
		end

		return processPage(pageObj, acc)
	end

	return processPage(pages, 0)
end

game.Players.PlayerAdded:Connect(function(plr)
	plr.Chatted:Connect(function(msg)
		if msg == "/migration_stats" then
			if not PlayerUtils.isAdmin(plr) then
				return
			end

			local migrated = countKeys(M_LOG)

			Admin_Notification:FireClient(
				plr,
				"Migration Stats",
				string.format("Migrated players: %d", migrated)
			)

			print("[Migration] Migrated count:", migrated)
		end
	end)
end)
]]></ProtectedString>
							<string name="ScriptGuid">{2AF9E298-550D-4AAF-8904-1C2FAD8DCF55}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">MigrationStats.server.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX4135A5052B81461CB9FDD6AE38000F65">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Tests</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX9DEAEDA9593C469BBAA750D1980D40D3">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- Elo_Mod_Compute_Elo.spec.lua
-- Compute_Elo tests with detailed logging

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TestService = game:GetService("TestService")

local Elo_Mod = require(ReplicatedStorage.Data_Mods_F.Elo_Mod)

-- ===== Helpers =====

local function logResult(modeName, w0, l0, w1, l1)
	local winGain = w1 - w0
	local loseLoss = l0 - l1

	print(string.format(
		"[Compute_Elo] Mode=%s | Winner %d → %d (+%d) | Loser %d → %d (-%d)",
		modeName,
		w0, w1, winGain,
		l0, l1, loseLoss
		))
end

local function assertWinnerLoser(w0, l0, w1, l1)
	-- Winner must not lose Elo
	assert(w1 >= w0, "Winner Elo should not decrease")

	-- Loser must not gain Elo
	assert(l1 <= l0, "Loser Elo should not increase")

	-- Hard cap must be respected
	assert(w1 <= Elo_Mod.ELO_MAX, "Winner Elo exceeds hard cap")

	local winDelta = w1 - w0
	local loseDelta = l0 - l1

	-- Symmetry only applies below soft cap and below hard cap
	local symmetryApplies =
		w0 < Elo_Mod.SOFT_CAP_ELO and
		w1 < Elo_Mod.ELO_MAX

	if symmetryApplies then
		assert(
			winDelta == loseDelta,
			"Elo gain/loss should be symmetrical below soft cap"
		)
	end

	-- Ensure minimum Elo movement when not capped
	if w0 < Elo_Mod.ELO_MAX then
		assert(
			winDelta >= 1 or w1 == Elo_Mod.ELO_MAX,
			"Winner should gain at least 1 Elo unless capped"
		)
	end
end

-- ===== Test matrix =====

local eloPairs = {
	{ winner = 400, loser = 400 },
	{ winner = 400, loser = 450 },
	{ winner = 450, loser = 400 },
	{ winner = 1000, loser = 1000 },
	{ winner = 1200, loser = 800  },
	{ winner = 800,  loser = 1200 },
	{ winner = 2000,  loser = 2000 },
	{ winner = 2100,  loser = 2000 },
	{ winner = 2500,  loser = 2500 },
	{ winner = 2700,  loser = 2700 },
	{ winner = 2900,  loser = 2900 },
	{ winner = 3000,  loser = 3000 }
}

local modes = {
	Elo_Mod.EloMode.Standard,
	--Elo_Mod.EloMode.League,
	--Elo_Mod.EloMode.Tournament,
	Elo_Mod.EloMode.Ranked,
}

-- ===== Tests =====

print("=== START Compute_Elo tests ===")

for _, mode in ipairs(modes) do
	for _, pair in ipairs(eloPairs) do
		local w0 = pair.winner
		local l0 = pair.loser

		local w1, l1 = Elo_Mod.Compute_Elo(w0, l0, mode)

		logResult(mode.Name, w0, l0, w1, l1)
		assertWinnerLoser(w0, l0, w1, l1)
	end
end

print("=== END Compute_Elo tests ===")
TestService:Message("Compute_Elo unit tests passed (all modes & configurations)")
]]></ProtectedString>
						<string name="ScriptGuid">{1D1A4186-C495-4EB2-A9C5-CD198986D476}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Elo_Mod_Compute_Elo.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA50915D9A3C84749953FB840C9360A20">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local TeleportService = game:GetService("TeleportService")
local MemoryStoreService = game:GetService("MemoryStoreService")
local MessagingService = game:GetService("MessagingService")

local ARENA_PLACE_ID = 107371070938662 -- your arena place ID
local MATCHMAKING_QUEUE = {} -- simple queue

local matchStore = MemoryStoreService:GetSortedMap("ArenaServers")

-- Add player to queue
game.Players.PlayerAdded:Connect(function(player)
	if player.Name == "champsavenue" then
		print(player.Name, "joined matchmaking queue.")
		table.insert(MATCHMAKING_QUEUE, player)
	end
end)

-- Simple loop to pair players
while true do
	task.wait(10)
	print("pairing players")
	--if #MATCHMAKING_QUEUE >= 2 then
		local p1 = table.remove(MATCHMAKING_QUEUE, 1)
		--local p2 = table.remove(MATCHMAKING_QUEUE, 1)

		-- Request a free arena slot
		local arenaServer = nil
		local servers = matchStore:GetRangeAsync(Enum.SortDirection.Ascending, 100)
		for _, s in ipairs(servers) do
			if s.value.free > 0 then
				arenaServer = s
				break
			end
		end

		-- No existing arena server available? Create one.
		if not arenaServer then
			print("no arenaServer => ReserveServer")
			local code = TeleportService:ReserveServer(ARENA_PLACE_ID)
			arenaServer = {
				key = tostring(os.time()),
				value = { code = code, free = 10 },
			}
			matchStore:SetAsync(arenaServer.key, arenaServer.value, 60 * 1)
		end

		-- Reserve one slot
		arenaServer.value.free -= 1
		matchStore:SetAsync(arenaServer.key, arenaServer.value, 60 * 1)

		-- Send match data
		local options = Instance.new("TeleportOptions")
		options.ReservedServerAccessCode = arenaServer.value.code
		options:SetTeleportData({
			matchId = "MMA-" .. math.random(100000, 999999),
			serverKey = arenaServer.key,
			fighters = { p1.UserId, nil },
			--fighters = { p1.UserId, p2.UserId },
		})

		print("TeleportAsync")
		TeleportService:TeleportAsync(ARENA_PLACE_ID, { p1, nil }, options)
	--end
end
]]></ProtectedString>
						<string name="ScriptGuid">{5B31DD58-8D44-49D7-95EC-4CA30F07E0A6}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">LobbyMatchmaker.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9830CCFD697D4F55B0C96C242AACF38E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local MessagingService = game:GetService("MessagingService")

MessagingService:SubscribeAsync("MatchResults", function(msg)
	local data = msg.Data
	print("🏁 Match finished:", data.matchId, "Winner:", data.winner)
	-- You can save results to DataStore or update tournament bracket here
end)]]></ProtectedString>
						<string name="ScriptGuid">{D81C1F69-C7FC-4AA2-BD2F-2FB4DAA6058F}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">LobbyResult.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3B80EC0910CE4EACB18E8E64C9975DE6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[--// Tournament_Simulator.lua
-- Full-scale tournament simulation (Hybrid: real players + bots)
-- Now aligned with the updated Tournament_Manager and CreateArena logic
-- ❇️ Bots are created ONLY by Tournament_Manager:CreateSimulatedBot()

local RS                = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Players           = game:GetService("Players")
local Debris            = game:GetService("Debris")

local IS_SIMULATION = true
if not IS_SIMULATION then return end

-- Core modules
local League_Manager       = require(ServerScriptService.League_Service:WaitForChild("League_Manager"))
local Tournament_Manager   = require(ServerScriptService.League_Service:WaitForChild("Tournament_Manager"))

-- Remote functions
local Data_Mods_F          = RS:WaitForChild("Data_Mods_F")
local Channels             = require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Create_Training_Bot  = Channels.CS_Remote_Functions.Create_Training_Bot
local Bots_Mod             = require(Data_Mods_F:WaitForChild("Bots_Mod"))
local Tournament_Fight_Ended 	= Channels.Bindable_Events.Tournament_Fight_Ended

-- Simulation parameters
local NB_SIMULATED_ROUNDS   = 1
local WAIT_BEFORE_START     = 5
local START_DELAY           = 5
local DIVISION              = "Unranked"
local INCLUDE_REAL_PLAYERS  = true

-- Internal state
local realPlayers = {}
local fakePlayers = {}
local currentWeek = nil

-------------------------------------------------------
-- REGISTER REAL PLAYERS
-------------------------------------------------------
local function registerRealPlayers()
	if not INCLUDE_REAL_PLAYERS then return end
	realPlayers = {}

	for _, player in ipairs(Players:GetPlayers()) do
		local alreadyInDivision = false
		local division = Tournament_Manager.Divisions and Tournament_Manager.Divisions[DIVISION]
		if division and division.Players then
			for _, existing in pairs(division.Players) do
				if existing.UserId == player.UserId then
					alreadyInDivision = true
					break
				end
			end
		end

		if not alreadyInDivision then
			Tournament_Manager:RegisterPlayer(player)
			print(string.format("[SIMULATION] Registered real player: %s", player.Name))
		else
			print(string.format("[SIMULATION] Real player already registered: %s", player.Name))
		end

		table.insert(realPlayers, player)
	end
end

-------------------------------------------------------
-- INJECT PARTICIPANTS INTO DIVISION QUEUE
-------------------------------------------------------
local function injectMatchQueue()
	local q = {}
	for _, plr in ipairs(realPlayers) do table.insert(q, plr) end
	for _, fake in pairs(fakePlayers) do table.insert(q, fake) end

	Tournament_Manager.MatchQueue[DIVISION] = q

	print(string.format("[SIMULATION] Injected %d fighters into queue (%s)",
		#q, DIVISION))
end

-------------------------------------------------------
-- START TOURNAMENT
-------------------------------------------------------
local function initializeTournament()
	currentWeek = "SimWeek_" .. os.date("%Y%m%d_%H%M%S")
	Tournament_Manager:StartDivisionTournament(DIVISION, currentWeek)

	print(string.format("[SIMULATION] Tournament '%s' started for %s",
		currentWeek, DIVISION))

	-- wait for division data to appear
	local waited = 0
	local timeout = 6
	while not (Tournament_Manager.Divisions and Tournament_Manager.Divisions[DIVISION])
		and waited < timeout
	do
		task.wait(0.5)
		waited += 0.5
	end

	if Tournament_Manager.Divisions and Tournament_Manager.Divisions[DIVISION] then
		print(string.format("[SIMULATION] Division '%s' ready after %.1fs",
			DIVISION, waited))
	else
		warn(string.format("[SIMULATION] ⚠️ Division '%s' missing after %.1fs",
			DIVISION, waited))
	end
end

-------------------------------------------------------
-- SIMULATE A ROUND
-------------------------------------------------------
local function simulateRound(roundIndex)
	print(string.format("[SIMULATION] ▶ ROUND %d starting...", roundIndex))
	Tournament_Manager:TryMatchPlayers(DIVISION)
	
	local finished = false

	local conn
	conn = Tournament_Fight_Ended.Event:Connect(function(matchResult)
		finished = true
		conn:Disconnect()
	end)

	Tournament_Manager:TryMatchPlayers(DIVISION)

	-- Wait until combat ends
	while not finished do
		task.wait(0.2)
	end
end

-------------------------------------------------------
-- PRINT FINAL RANKING
-------------------------------------------------------
local function printFinalRanking(divisionName)
	local division = Tournament_Manager.Divisions and Tournament_Manager.Divisions[divisionName]
	if not division or not division.Players then
		warn("[SIMULATION] No ranking data!")
		return
	end

	local players = {}
	for id, stats in pairs(division.Players) do
		table.insert(players, {
			Name = stats.Name or tostring(id),
			Points = stats.Points or 0,
			LP = stats.LP or 0
		})
	end

	table.sort(players, function(a,b)
		if a.Points == b.Points then
			return a.LP > b.LP
		end
		return a.Points > b.Points
	end)

	print("\n===== 🏁 FINAL RANKING =====")
	for i, p in ipairs(players) do
		print(string.format("#%d | %-12s | %2d pts | %3d LP",
			i, p.Name, p.Points, p.LP))
	end
	print("=================================\n")
end

-------------------------------------------------------
-- CLEANUP BOT MODELS
-------------------------------------------------------
local function cleanupBots()
	for _, fake in pairs(fakePlayers) do
		local ref = fake:FindFirstChild("CharacterModel")
		if ref and ref.Value then
			Debris:AddItem(ref.Value, 2)
		end
	end
	print("[SIMULATION] Bot model cleanup done")
end

-------------------------------------------------------
-- MAIN SIMULATION WORKFLOW
-------------------------------------------------------
local function runFullSimulation()
	print(string.format("[SIMULATION] Waiting %d seconds for real players...",
		WAIT_BEFORE_START))
	task.wait(WAIT_BEFORE_START)

	initializeTournament()
	registerRealPlayers()
	injectMatchQueue()

	print(string.format("[SIMULATION] Tournament begins in %d seconds", START_DELAY))
	for i = START_DELAY, 1, -1 do
		print("[SIMULATION] ...", i)
		task.wait(1)
	end

	for round = 1, NB_SIMULATED_ROUNDS do
		simulateRound(round)
	end

	print("[SIMULATION] Applying rewards and ending tournament...")
	Tournament_Manager:EndDivisionTournament(DIVISION)

	printFinalRanking(DIVISION)
	cleanupBots()
end

-------------------------------------------------------
-- EXECUTION
-------------------------------------------------------
Tournament_Manager:SetMode("SIMULATION")
task.spawn(runFullSimulation)
]]></ProtectedString>
						<string name="ScriptGuid">{A4228EAE-057C-4B0F-8D85-629DA376B2BF}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tournament_Simulator.server.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX8290AB08426D411EBB462980C93DFCBF">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ServerStorage</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX14957BAEB9FE4765825952A1B59DB276">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Rewards</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXB2EB9A74837044FEB892176600782059">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[return function(player)
	local playerData = player:FindFirstChild("Player_Data")

	if playerData then
		playerData.Cash2x.Value = true
	end
end]]></ProtectedString>
						<string name="ScriptGuid">{E3B1F021-6FD4-4493-A350-E98AF4FF594B}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">2xCash.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6D8563EDD83847D9B6B82892DB5368EC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[return function(player)
	local playerData = player:FindFirstChild("Player_Data")

	if playerData then
		playerData.Coins.Value += 3000
	end
end]]></ProtectedString>
						<string name="ScriptGuid">{42FC5E4E-5B5D-4DAD-915E-0414E9688547}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">HugeMoneyPack.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9CA79D8F7BFF4234AC0E1399664105C5">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[return function(player)
	local playerData = player:FindFirstChild("Player_Data")

	if playerData then
		playerData.Gems.Value += 500
	end
end]]></ProtectedString>
						<string name="ScriptGuid">{3FC181A7-4418-4D08-95D8-578D7F24ED86}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">LargediamondsPack.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX63CAF4340EE04022B7D1245CC1808C42">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[return function(player)
	local playerData = player:FindFirstChild("Player_Data")

	if playerData then
		playerData.Vip.Value = true
	end
end]]></ProtectedString>
						<string name="ScriptGuid">{314CC444-F87D-4687-A0AA-38D7D6DDC907}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">VIP.lua</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX7577F66E21CD42BEA97ACD5026A36539">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Debug</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX4D6D8653F26E4D8386BE931BB9C3C8B9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">AdminConsole</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXCF5F3E37C61F459B915567A82CCE0D98">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local player = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local remote = ReplicatedStorage:WaitForChild("Debug"):WaitForChild("DatastoreRemote")


-- get the ScreenGui, not the Frame
local gui = script.Parent
local frame = gui.Frame

-- Hide at start
gui.Enabled = false

player.Chatted:Connect(function(msg)
	if msg:lower() == "!console" then
		gui.Enabled = not gui.Enabled
	end
end)

local storeBox = frame.StoreBox
local keyBox = frame.KeyBox
local valueBox = frame.ValueBox
local output = frame.Output.TextLabel

local HttpService = game:GetService("HttpService")

local function log(msg)
	output.Text = output.Text .. "\n" .. msg
end

frame.ListBtn.MouseButton1Click:Connect(function()
	local result = remote:InvokeServer("list", storeBox.Text)
	if result.success then
		log("Keys: " .. table.concat(result.data, ", "))
	else
		log("Error: " .. tostring(result.message))
	end
end)

frame.GetBtn.MouseButton1Click:Connect(function()
	local result = remote:InvokeServer("get", storeBox.Text, keyBox.Text)
	if result.success then
		log("Value: " .. HttpService:JSONEncode(result.data))
	else
		log("Error: " .. tostring(result.message))
	end
end)

frame.SetBtn.MouseButton1Click:Connect(function()
	local result = remote:InvokeServer("set", storeBox.Text, keyBox.Text, valueBox.Text)
	log(result.success and "Value set" or "Set failed")
end)

frame.RemoveBtn.MouseButton1Click:Connect(function()
	local result = remote:InvokeServer("remove", storeBox.Text, keyBox.Text)
	log(result.success and "Key removed" or "Remove failed")
end)]]></ProtectedString>
							<string name="ScriptGuid">{F4EF020C-7470-4BAC-9017-2936C720846E}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">LocalScript.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXF0241AA19381476988398ACB548A76D9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GymEventConsole</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX9F58B73C0E094AF58C23BCD2ED3C2D97">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[local RS = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local gui = script.Parent
local Frame = gui.Main_F
local Launch_Test_B = Frame.Launch_B
local Count_Down_L = Frame.Countdown_L

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Gym_Reward_Testing = Channels.CS_Remote_Events.Gym_Reward_Testing


-- Hide at start
gui.Enabled = false

player.Chatted:Connect(function(msg)
	if msg:lower() == "!gymevent" then
		gui.Enabled = not gui.Enabled
	end
end)

Launch_Test_B.MouseButton1Click:Connect(function()
	if Launch_Test_B.Active then		
		Gym_Reward_Testing:FireServer()
	end
end)

Gym_Reward_Testing.OnClientEvent:Connect(function(active, i)
	Launch_Test_B.Visible = not active
	local msg = ""
	if active then
		if i==0 then
			msg = "Will start soon..."
		else
			msg = "⏳ Remaining time : " .. i .. "s"
		end
	end
	Count_Down_L.Text = msg
end)
]]></ProtectedString>
							<string name="ScriptGuid">{7C569FA9-DD9D-4843-BC3E-7F926C49B5EA}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Gym_Event_Test_Handle.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXDBF3806D035E441DB7FE4BAD80938DD3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Training_Bots</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX789CF959CA0044C88E2BEDA0E7E0CEEA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Halloween</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXEFF8A082783A4839A7572E84059548CD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Skeleton_Zombie</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX927E5E8D7F8547BEBA1F35EED4AA2A3E">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
								<string name="ScriptGuid">{7C7C6C0E-469F-4B92-B246-798F085B54F6}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animate.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX95D1D4BEAE484AC5B71EF9743D1A9648">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Init_AI_Training_Bot</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXEE6CA417BC634828915E8E22492CC2CC">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local Init_E = script.Parent
local Char = Init_E.Parent

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Overhead_Display 			= Channels.SC_Remote_Events.Overhead_Display
local Got_Hit_Effect 			= Channels.SC_Remote_Events.Got_Hit_Effect
local AI_Training_Cage_Clinch	= Channels.Bindable_Events.AI_Training_Cage_Clinch
local AI_Training_Submission 	= Channels.Bindable_Events.AI_Training_Submission
local Ragdoll_Player			= Channels.Bindable_Events.Ragdoll_Player

local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")
local Head = Char:WaitForChild("Head")
local Fight_Data_F = Char:WaitForChild("Fight_Data")
local Stamina_V = Fight_Data_F:WaitForChild("Staminia") -- adjust name if it's 'Stamina'

-- Direct stamina regeneration for bot (server-side)
local function Reload_Stamina()
	while Stamina_V.Value < 40 do
		Stamina_V.Value = math.min(Stamina_V.Value + 1, 100) -- regen step, adjust as needed
		task.wait(0.1)
	end
end
local Fight_UI = Char:WaitForChild("Fighting_UI")
local Health_V = Fight_Data_F:WaitForChild("Health")
local Stam_V = Fight_Data_F:WaitForChild("Staminia")
local Block_Power_V = Fight_Data_F:WaitForChild("Block Power")
local Strike_Power_V = Fight_Data_F:WaitForChild("Strike Power")

local Fight_Walkspeed = 12
local Is_Active = false
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Get_Fighting_UI()
	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
		local Main_F = Fight_UI:FindFirstChild("Main_F") 
		local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
		if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
			return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
		end
	end

	return nil, nil
end

local function Reset_AI()
	Disconnect_Cons()

	Health_V.Value = 100
	Stam_V.Value = 100
	Block_Power_V.Value = 30
	Strike_Power_V.Value = 6

	if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
		HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
	end

	if(Hum ~= nil)then
		Hum.AutoRotate = false
		Hum.WalkSpeed = 12
		Hum.JumpPower = 0

		Animation_Mod.Reset_Character_Animations(Char)

		Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
	end

	Char:SetAttribute("Is_Fighting", false)
	Is_Active = false
end

local function Core_AI_Handle(T_Plr, T_Char)
	local T_HRP = T_Char:WaitForChild("HumanoidRootPart")
	local T_Fight_Data = T_Plr:FindFirstChild("Fight_Data")
	local T_Health_V = T_Fight_Data:WaitForChild("Health")
	local T_Stam_V = T_Fight_Data:WaitForChild("Staminia")
	local T_Block_Power_V = T_Fight_Data:WaitForChild("Block Power")
	local T_Strike_Power_V = T_Fight_Data:WaitForChild("Strike Power")
	local Is_Submission = false

	Char:SetAttribute("Is_Fighting", true)
	Reset_AI()
	Is_Active = true

	task.wait(3)
	if(Is_Active == false)then
		return
	end

	--Fight Data Changes
	table.insert(Cons, Health_V.Changed:Connect(function()
		if(Char ~= nil and Health_V.Value <= 0)then
			Ragdoll_Player:Fire(Char)
		end
	end))

	local function Create_BG()
		local OldG = HRP:FindFirstChildWhichIsA("BodyGyro")
		if(OldG ~= nil)then
			OldG:Destroy()
		end

		local bodyG = Instance.new("BodyGyro", HRP)
		bodyG.P = 1000
		bodyG.MaxTorque = Vector3.new(0, 1000, 0)
		bodyG.D = 10

		return bodyG
	end
	local BG = Create_BG()

	local function Movement_Handle()
		local function Update_Player_Movement()
			local function Get_Target_Position()
				if(T_HRP ~= nil)then
					local Move_Speed = T_HRP.Velocity
					local Def_Pos = T_HRP.Position + T_HRP.CFrame.LookVector * 3.5

					if(math.floor(Move_Speed.Magnitude) <= 0)then
						return Def_Pos, T_HRP.Position
					else
						local Ping = T_Plr:GetNetworkPing()
						local Dir = Move_Speed.Unit
						local Speed = Move_Speed.Magnitude
						local Extrapolated_Pos = Def_Pos + Dir * (Speed * Ping)
						local Travel_Time = ((Extrapolated_Pos - HRP.Position).Magnitude) / Hum.WalkSpeed
						return Extrapolated_Pos + Dir * (Hum.WalkSpeed * Travel_Time), Extrapolated_Pos
					end
				end

				return HRP.Position, HRP.Position + HRP.CFrame.LookVector * 3
			end
			local Move_Pos, Look_Pos = Get_Target_Position()

			BG.CFrame = CFrame.new(HRP.Position, Look_Pos)
			Hum:MoveTo(Move_Pos)
		end

		table.insert(Cons, RunService.Stepped:Connect(function()
			if(BG ~= nil and HRP ~= nil and Hum ~= nil and Hum.PlatformStand == false and T_Plr ~= nil and T_HRP ~= nil)then
				if(T_Health_V ~= nil and T_Health_V.Value > 0 and Is_Submission == false)then
					Update_Player_Movement()
				else
					Hum:MoveTo(HRP.Position)
				end
			end
		end))

		table.insert(Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
			if(Hum.PlatformStand == true)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			else
				BG.P = 1000
				BG.MaxTorque = Vector3.new(0, 1000, 0)
				BG.D = 10
			end
		end))
	end
	Movement_Handle()

	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
		Damage_UIG.Offset = Vector2.new(0, -0.5)
		Damage_Bar_Img.Visible = false
	end

	local function Create_Anim_Arr_Data(Anim_Track_Data)
		local D = {}
		for Key, Anim_Track in next, Anim_Track_Data do
			table.insert(D, Anim_Track)
		end
		return D
	end

	local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	local Combo_Strike_Index = 1
	local Combo_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(T_Plr, Hum, "Bot Combo")
	local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)

	local Debounce_Striking = false
	local Debounce_Dodge = false
	local Debounce_Blocking = false
	local Debounce_Takedown = false
	local Is_Hit = false

	local function Striking_Movement_Handle()
		--> Update Movement, Moving Forward or Backwards | Moving Left to Right | Standing Idle
		--> Track Humanoid MoveDirection
		table.insert(Cons, Hum:GetPropertyChangedSignal("WalkToPoint"):Connect(function()
			local Move_Speed = math.floor(HRP.Velocity.Magnitude)
			if(Move_Speed > 3 and Anim_Track_Data['Shuffle Forward'].IsPlaying == false)then
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				Anim_Track_Data['Shuffle Forward']:Play()
				Anim_Track_Data['Shuffle Forward']:AdjustSpeed(-1)

			elseif(Move_Speed <= 3 and 
				(Anim_Track_Data['Shuffle Forward'].IsPlaying == true or 
					Anim_Track_Data['Shuffle Side'].IsPlaying == true))then

				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
			end
		end))

		Anim_Track_Data['Idle']:Play()
		Anim_Track_Data['Idle']:AdjustSpeed(0.5)
	end
	Striking_Movement_Handle()

	local function On_Hit_Effects()
		--[[
			* When Health goes Down!
				> Camera Shake Effects
					-> Quick Shake
				> Apply Hit Effects
					-> Reset all Animations, Play the Hit One
				> Set Debounce till Hit Effect goes Away
		]]--

		local Prev_Health = Health_V.Value
		local Hit_Anim_Track = Striking_Anim_Tracks['Taking Hit']

		local function Show_Sweat_Effects()
			if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
				local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
				local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
				if(PE ~= nil)then
					PE:Emit(25)
				end
			end
		end

		table.insert(Cons, Health_V.Changed:Connect(function()
			local Current_V = Health_V.Value
			if(Current_V < Prev_Health and Is_Hit == false)then
				Is_Hit = true

				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Show_Sweat_Effects()

				task.spawn(function()
					Animation_Mod.Play_Animation_Track(Hit_Anim_Track)
					Is_Hit = false
				end)
			end

			Prev_Health = Current_V
		end))
	end
	On_Hit_Effects()

	local function Blocking_Effects()
		--[[
			* On Sheild Blocking Power goes down (Greater than 0) and Debounce_Blocking == true
			* Get the Opponent Handed Type
				> Play the Coresponding Animation
		]]--

		local Prev_Blocking = Block_Power_V.Value
		local Tween_Health_Con = nil
		local Tween_Stam_Con = nil
		local Tween_Block_Con = nil
		Block_Power_V:SetAttribute("Is_Blocking", false)

		local function Reset_Healing_Cons()
			if(Tween_Health_Con ~= nil)then
				Tween_Health_Con:Cancel()
				Tween_Health_Con = nil
			end

			if(Tween_Stam_Con ~= nil)then
				Tween_Stam_Con:Cancel()
				Tween_Stam_Con = nil
			end
		end

		local function Set_Healing_Cons()
			local Health_Time = math.clamp((100 - Health_V.Value) * 0.6, 0.6, 60)
			local Tween_Full_Health = TweenInfo.new(Health_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
			Tween_Health_Con = TS:Create(Health_V, Tween_Full_Health, {Value = 100})
			Tween_Health_Con:Play()

			local Stam_Time = math.clamp((100 - Stam_V.Value) * 0.1, 0.1, 10)
			local Tween_Full_Stam = TweenInfo.new(Stam_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)	
			Tween_Stam_Con = TS:Create(Stam_V, Tween_Full_Stam, {Value = 100})
			Tween_Stam_Con:Play()
		end

		table.insert(Cons, Block_Power_V.AttributeChanged:Connect(function(Attrib_Key)
			if(Attrib_Key == "Is_Blocking" and Block_Power_V:GetAttribute("Is_Blocking") ~= nil)then
				Reset_Healing_Cons()
				if(Block_Power_V:GetAttribute("Is_Blocking") == true)then
					Set_Healing_Cons()
				end
			end
		end))


		local function Update_Fight_Block_UI()
			if(Fight_UI ~= nil and Block_Power_V ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil and 
				Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then

				local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
				local Img = Sheild_F:FindFirstChild("Shield_Img")
				local Txt = Sheild_F:FindFirstChild("Shield_Txt")

				if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
					local UIG = Img:FindFirstChildWhichIsA("UIGradient")
					local Block_Power = Block_Power_V.Value
					local Dif =  math.clamp(Block_Power / 30, 0, 1)
					local Offset_Pos_Y = (1 - Dif) - 0.5

					UIG.Offset = Vector2.new(0, Offset_Pos_Y)
					Txt.Text = Block_Power .. ""
					if(Dif <= 0.25)then
						Txt.TextColor3 = Color3.new(1, 0, 0)
					else
						Txt.TextColor3 = Color3.new(1, 1, 1)
					end

				end
			end

		end

		table.insert(Cons, Block_Power_V.Changed:Connect(function()
			local Current_V = Block_Power_V.Value
			if(Current_V > 0 and Current_V < Prev_Blocking and Debounce_Blocking == true)then
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Striking_Anim_Tracks['Body Block Left'])

				if(Block_Power_V.Value < 30)then
					if(Tween_Block_Con ~= nil)then
						Tween_Block_Con:Cancel()
						Tween_Block_Con = nil
					end

					local Block_Time = math.clamp((30 - Block_Power_V.Value) * 0.2667, 0.2667, 8)
					local Tween_Block_Power = TweenInfo.new(Block_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 6)
					Tween_Block_Con = TS:Create(Block_Power_V, Tween_Block_Power, {Value = 30})
					Tween_Block_Con:Play()
					Tween_Block_Con.Completed:Wait()
					Tween_Block_Con = nil
				end
			end

			Update_Fight_Block_UI()
			Prev_Blocking = Current_V

		end))

	end
	Blocking_Effects()

	local function Get_Core_Strike_Handles()
		local Funcs = {}

		local function Has_Enough_Stam(Min_V)
			if(Stam_V ~= nil and Stam_V.Value >= Min_V)then
				Stam_V.Value -= Min_V
				return true
			end
			return false
		end

		local function Get_Player_To_Hit()
			local Whitelist_Chars = {T_Char}
			local Overlap_P = OverlapParams.new()
			Overlap_P.MaxParts = 1
			Overlap_P.FilterType = Enum.RaycastFilterType.Include
			Overlap_P.FilterDescendantsInstances = {Whitelist_Chars}

			local function Create_Region_CF()
				local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
				local Distance = (Speed + 3)
				local Head_Dir = Head.CFrame.LookVector
				local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

				local cframe = HRP.CFrame * CFrame.new(0, 0, -3)
				return cframe
			end
			local Spawn_CF = Create_Region_CF()
			local Hitbox_Size = Vector3.new(4, 8, 4)

			local function Create_Hitbox_Part()
				local P = Instance.new("Part", game.Workspace)
				P.Name = "Hitbox_Part"
				P.Anchored = true
				P.CanCollide = false
				P.Transparency = 0.5
				P.Color = Color3.new(1, 0, 0)
				P.Material = Enum.Material.SmoothPlastic
				P.Size = Hitbox_Size
				P.CFrame = Spawn_CF

				Debris:AddItem(P, 5)
			end
			--Create_Hitbox_Part()

			local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
			if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
				local function Get_Char_From_BP()
					for i = 1, #Whitelist_Chars do
						local C = Whitelist_Chars[i]
						if(C ~= nil and Region_Data[1]:IsDescendantOf(C))then
							return C
						end
					end

					return Whitelist_Chars[1]
				end

				return Get_Char_From_BP()
			end

			return nil
		end

		local function Get_Punch_Power()
			local Tween_Punch_Power_Back = TweenInfo.new(1.75, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
			local Strike_Power = Strike_Power_V.Value
			Strike_Power_V.Value = 0
			TS:Create(Strike_Power_V, Tween_Punch_Power_Back, {Value = 6}):Play()
			return Strike_Power
		end

		local function Get_Target_Fight_Data(Hit_Char)
			local Hit_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
			if(Hit_Plr ~= nil)then
				return Hit_Plr:FindFirstChild("Fight_Data")
			else
				return Hit_Char:FindFirstChild("Fight_Data")
			end
		end

		function Funcs.Strike_Handle()
			if Stamina_V.Value < 20 then Reload_Stamina() end
			--[[
				* Play Woosh Sound Effect locally
				* Play Animation
				* Tell the Server that you are Striking
			]]--

			Debounce_Striking = true
			-- AI is Striking!
			SE_Mod.PlaySFX(Char, "Punch_Woosh_SE")

			local function Play_Strike_Animation()
				local Track = Combo_Anim_Arr[Combo_Strike_Index]
				local Key = Track:GetAttribute("Strike_Key") or "A"

				task.spawn(function()
					if(HRP ~= nil and Has_Enough_Stam(10))then
						local Base_Punch_Power = Get_Punch_Power()
						local Hit_Char = Get_Player_To_Hit()
						local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Key)
						local Power_Inc = Strike_Data['Power Multi'] or 0
						local Punch_Power = math.ceil(Base_Punch_Power * (1  + Power_Inc))
						--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Strikes", 1)

						if(Hit_Char ~= nil)then
							local Hit_Fight_Data = Get_Target_Fight_Data(Hit_Char)
							if(Hit_Fight_Data ~= nil and Hit_Fight_Data:FindFirstChild("Health") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Block Power") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Staminia") ~= nil)then

								local T_Health = Hit_Fight_Data:FindFirstChild("Health")
								local T_Block_Power = Hit_Fight_Data:FindFirstChild("Block Power")
								local T_Staminia = Hit_Fight_Data:FindFirstChild("Staminia")

								local function Is_Dodging_Check()
									local Is_Dodging = T_Staminia:GetAttribute("Is_Dodging")
									if(Is_Dodging ~= nil and Is_Dodging == true)then
										local Target_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if(Target_Plr ~= nil)then
											Stats_Manager_Mod.Add_To_Player_Stats_Data(Target_Plr, "Dodged Strikes", 1)
										end

										return true
									end
									return false
								end

								local function Is_Blocking_Check()
									local Is_Block = T_Block_Power:GetAttribute("Is_Blocking")
									if(Is_Block ~= nil and Is_Block == true)then
										T_Block_Power.Value -= Punch_Power
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.fromRGB(170, 85, 255))

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										if(T_Block_Power.Value < 0)then
											local Dif = math.abs(T_Block_Power.Value)
											T_Health.Value = math.clamp(T_Health.Value - Dif, 0, 100)
											T_Block_Power.Value = 0

											SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
											--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)

											Overhead_Display:FireAllClients(Hit_Char, "-" .. Dif, Color3.new(1, 0, 0))

										else
											SE_Mod.PlaySFX(HRP, "Blocked_Hit_SE")	
										end

										return true
									end

									return false
								end

								if(Is_Dodging_Check())then
									--Play Dodging Text
									Overhead_Display:FireAllClients(Hit_Char, "Dodged", Color3.fromRGB(35, 244, 68))
								elseif(Is_Blocking_Check())then
									--Play Blocking 
								else
									--Apply the Hit
									local function Apply_Strike()
										T_Health.Value = math.clamp(T_Health.Value - Punch_Power, 0, 100)
										SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
										--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.new(1, 0, 0))
										--Punch_Hit_VFX:FireClient(Plr, Hit_Char)
										--Play Damage Val Show

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										local T_HRP = Hit_Char:FindFirstChild("HumanoidRootPart")
										if(T_HRP ~= nil)then
											local Hit_Force = 625 -- Was 350 then 500
											local Dir = HRP.CFrame.LookVector 
											T_HRP:ApplyImpulse(Dir * Hit_Force * T_HRP:GetMass())
										end
									end
									Apply_Strike()
								end
							end

						end
					end
				end)

				Combo_Strike_Index += 1
				if(Combo_Strike_Index > #Combo_Anim_Arr)then
					Combo_Strike_Index = 1
				end

				Animation_Mod.Stop_Animation_Tracks(Combo_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Track)
			end
			task.spawn(Play_Strike_Animation)
			task.wait(0.5)

			Debounce_Striking = false
		end

		local Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left']
		local Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		local Back_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		function Funcs.Dodge_Handle(Dodge_Type)
			--[[
				* Get the Type First
					-> First Index? Just play the Slip Animation
					-> 2nd Index? Play the Dodge Animation AND apply Force to the Player in the direction
				
					-> Tell the Server that you are Dodging and should reduce Staminia Value
			]]--

			Debounce_Dodge = true
			-- AI is Dodging

			local function Apply_Force(Dir)
				HRP:ApplyImpulse(Dir * (Fight_Walkspeed * 65) * HRP:GetMass())
			end

			task.spawn(function()
				if(Has_Enough_Stam(5))then
					--Play the Sound Effect
					--Toggle Value
					SE_Mod.PlaySFX(HRP, "Missed_SE")
					Stam_V:SetAttribute("Is_Dodging", true)
					task.wait(0.5)
					Stam_V:SetAttribute("Is_Dodging", false)
				end
			end)
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})

			local function Increment_Anim()
				if(Dodge_Type == "Dodge Left")then
					if(Left_Dodge_Ani == Striking_Anim_Tracks['Slip Left'])then
						Left_Dodge_Ani = Striking_Anim_Tracks['Headblock Left']
					else
						Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left'] 
					end
				else
					--Right
					if(Right_Dodge_Ani == Striking_Anim_Tracks['Slip Right'])then
						Right_Dodge_Ani = Striking_Anim_Tracks['Headblock Right']
					else
						Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right'] 
					end
				end
			end

			if(Dodge_Type == "Dodge Left")then
				--Left
				if(Left_Dodge_Ani == Striking_Anim_Tracks['Headblock Left'])then
					--Apply_Force(HRP.CFrame.RightVector * -1)
				end
				Apply_Force(HRP.CFrame.RightVector * -1)
				Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Right")then
				--Right
				if(Right_Dodge_Ani == Striking_Anim_Tracks['Headblock Right'])then
					--Apply_Force(HRP.CFrame.RightVector)
				end
				Apply_Force(HRP.CFrame.RightVector)
				Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Back")then
				Apply_Force(HRP.CFrame.LookVector * -1)
				Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
			end

			Debounce_Dodge = false
		end

		local function Toggle_Sheild_Icon(Is_Enabled)
			local Main_F =  Fight_UI:FindFirstChild("Main_F")
			if(Main_F ~= nil and Main_F:FindFirstChild("Shield_F") ~= nil)then
				local SF = Main_F:FindFirstChild("Shield_F")
				SF.Visible = true
				
				local Img = SF:FindFirstChild("Shield_Img")
				if(Img ~= nil)then
					if(Is_Enabled)then
						Img.Image = "rbxassetid://130871917395731"
					else
						Img.Image = "rbxassetid://125284121534949"
					end
				end
			end
		end

		local function Toggle_Heal_PE(Is_Enabled)
			local PE = HRP:GetChildren()
			for i = 1, #PE do
				if(PE[i] ~= nil and PE[i].Name == "Heal_PE" and PE[i]:IsA("ParticleEmitter"))then
					PE[i].Enabled = Is_Enabled
				end
			end

			Toggle_Sheild_Icon(Is_Enabled)
		end

		local Low_Block_Con = nil
		local function Disable_Blocking_Handle()
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed
			end

			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Block_Power_V:SetAttribute("Is_Blocking", false)
			Toggle_Heal_PE(false)

			Debounce_Blocking = false
		end

		local function Play_Blocking_Animation()
			local Anim_Track = Striking_Anim_Tracks['Main Block']
			if(Anim_Track ~= nil)then
				Anim_Track:Play()
				Anim_Track:AdjustSpeed(1)
				task.wait(Anim_Track.Length * 0.9)

				if(Anim_Track ~= nil and Debounce_Blocking == true)then
					Anim_Track:AdjustSpeed(0)
				end
			end
		end

		function Funcs.Disable_Blocking_Handle()
			-- AI is turning off Blocking
			Disable_Blocking_Handle()
		end

		function Funcs.Blocking_Handle()
			Debounce_Blocking = true
			-- AI Is Blocking

			if(Hum ~= nil)then
				Hum.WalkSpeed = 8
			end

			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			Low_Block_Con = Block_Power_V.Changed:Connect(function()
				if(Block_Power_V.Value <= 0 and Debounce_Blocking == true)then
					if(Low_Block_Con ~= nil)then
						Low_Block_Con:Disconnect()
						Low_Block_Con = nil
					end

					Disable_Blocking_Handle()
				end
			end)
			table.insert(Cons, Low_Block_Con)
			task.spawn(Play_Blocking_Animation)

			if(Block_Power_V ~= nil and Block_Power_V.Value > 0)then
				Block_Power_V:SetAttribute("Is_Blocking", true)
				Toggle_Heal_PE(true)
			end
		end

		function Funcs.Get_Hitbox_Res()
			return (Get_Player_To_Hit() ~= nil)
		end		

		function Funcs.Get_Dodge_Type()
			local function Get_Ray_Distance_Data()
				local Origin = HRP.Position
				local Ray_Parm = RaycastParams.new()
				Ray_Parm.FilterType = Enum.RaycastFilterType.Exclude
				Ray_Parm.FilterDescendantsInstances = {Char, T_Char}

				local function Get_Ray_Dist(Dir)
					local Ray_Res = game.Workspace:Raycast(Origin, Dir * 10, Ray_Parm)
					if(Ray_Res ~= nil and Ray_Res.Distance ~= nil)then
						return Ray_Res.Distance
					end
					return 15
				end

				return {
					{
						['Type'] = "Dodge Back",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.LookVector * -1)
					},

					{
						['Type'] = "Dodge Left",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector * -1)
					},

					{
						['Type'] = "Dodge Right",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector)
					},

				}
			end
			local Ray_Dist_Arr = Get_Ray_Distance_Data()

			table.sort(Ray_Dist_Arr, function(A, B)
				return A['Distance'] > B['Distance']
			end)

			return Ray_Dist_Arr[1]['Type']
		end

		function Funcs.Is_Player_Striking_You()
			if(T_Strike_Power_V ~= nil and T_Strike_Power_V.Value < 4)then
				return true
			end
			return false
		end

		return Funcs
	end
	local Core_Strike_Funcs = Get_Core_Strike_Handles()

	--[[
		Core AI Decision Making goes here
		
		* If within Striking Distance ~ 5 Studs
			* If Player is Striking too, Dodge Left Right or Back (Max 2 Dodges)
			* Has to Strike (Max 3 Strikes)
				* Dodge Back if Strike (or left or Right)
		* Default to Blocking Handle
	]]--

	local function Submission_Handle(Is_Submitting, Attacking_Char)
		Animation_Mod.Reset_Character_Animations(Char)
		if(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end

		if(Is_Submitting)then
			Is_Submission = true
			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end

			if(HRP ~= nil)then
				--HRP.Anchored = true
				--HRP.CFrame *= CFrame.new(Vector3.new(0, 0.15, 0))
			end

			--> Play Animation
			--> Get Submission Character & Player
			--> Get their Takedown and Submission Data

			--> If Attacking Player, Set HRP CFrame Position
			--> Play Take Down Animation

			--> Play Submission Animation
			--> Play Submission Loop Animation

			local function Get_Takedown_Submission_Tracks()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)
				return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Receiving ID'], Submission_Data['Receiving ID'], Submission_Data['Receiving Loop ID'])
			end
			local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()

			Takedown_Track.Priority = Enum.AnimationPriority.Action2
			Animation_Mod.Play_Animation_Track(Takedown_Track, true)

			task.wait(0.25)

			Submission_Track.Priority = Enum.AnimationPriority.Action3
			Animation_Mod.Play_Animation_Track(Submission_Track)

			Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
		else
			Is_Hit = false

			if(HRP ~= nil)then
				HRP.Anchored = false
			end

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
			Is_Submission = false
		end
	end

	table.insert(Cons, AI_Training_Submission.Event:Connect(function(AI_Char, Attacking_Char, Is_Submitting)
		if(AI_Char == Char)then
			Submission_Handle(Is_Submitting, Attacking_Char)
		end
	end))


	local function Clinch_Handle(Animation_Sequence_Data, Is_Attacking)
		local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(Char)

			if(Debounce_Blocking == true)then
				task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
			end

			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
		end
		Freeze_Character()

		local function Play_Strike_Sequences()
			local Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
			Animation_Mod.Play_Animation_Track(Clinch_Tracks_Data['Init_Clinch'], true)
			task.spawn(Animation_Mod.Play_Animation_Track, Clinch_Tracks_Data['Loop_Clinch'])
			task.wait(1)

			for i = 1, #Animation_Sequence_Data do
				local Strike_Key = Animation_Sequence_Data[i]
				local Strike_Track = Clinch_Tracks_Data[Strike_Key]

				if(Strike_Track ~= nil)then
					--Play Flash, Play Hit Sound Effect, Quick Camera Shake
					Animation_Mod.Play_Animation_Track(Strike_Track)
					--wait(0.5)
				end
			end

		end
		Play_Strike_Sequences()

		local function Clinch_Reset_Handle()
			Animation_Mod.Reset_Character_Animations(Char)
			Is_Hit = false

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
		end	
		Clinch_Reset_Handle()
	end

	table.insert(Cons, AI_Training_Cage_Clinch.Event:Connect(function(AI_Char, Sequence_Keys, Is_Attacking)
		if(AI_Char == Char)then
			Clinch_Handle(Sequence_Keys, Is_Attacking)
		end
	end))


	local Strike_Count, Dodge_Count = 0, 0
	local function Main_AI_Logic_Gate()
		if(Health_V.Value > 0 and Is_Hit == false and T_Health_V ~= nil and T_Health_V.Value > 0)then
			if(Core_Strike_Funcs.Get_Hitbox_Res())then -- Within Strike Zone
				local Is_Player_Hitting_You = Core_Strike_Funcs.Is_Player_Striking_You()
				if(Is_Player_Hitting_You)then
					--Take the HIts until you're below 20 Block Power
					-- Dodge? or Strike
					if(Block_Power_V.Value > 10)then
						if(Dodge_Count < 2 or Strike_Count >= 3)then
							--Dodge
							if(Debounce_Dodge == false and Stam_V.Value >= 5)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								local Dodge_Type = Core_Strike_Funcs.Get_Dodge_Type()
								Core_Strike_Funcs.Dodge_Handle(Dodge_Type)

								Dodge_Count += 1
								if(Strike_Count >= 3)then
									Strike_Count = 0
								end
							end

						else
							--Strike
							if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								Core_Strike_Funcs.Strike_Handle()
								Strike_Count += 1
								if(Dodge_Count >= 2)then
									Dodge_Count = 0
								end
							end
						end
					elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
						--Not within Strike Zone, resort to Blocking
						Core_Strike_Funcs.Blocking_Handle()
					end
				else
					--Strike
					if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
						if(Debounce_Blocking == true)then
							task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
						end

						Core_Strike_Funcs.Strike_Handle()
						Strike_Count += 1
						if(Dodge_Count >= 2)then
							Dodge_Count = 0
						end
					end
				end
			elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
				--Not within Strike Zone, resort to Blocking
				Core_Strike_Funcs.Blocking_Handle()
			end

		elseif(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end
	end

	while Is_Active do
		if(Is_Submission == false)then
			Main_AI_Logic_Gate()
		end
		task.wait(0.5)
	end
end

Init_E.Event:Connect(function(T_Plr, T_Char,OtherStuff)	
	if(Is_Active == false and T_Plr ~= nil and T_Char ~= nil)then
		Core_AI_Handle(T_Plr, T_Char)
	elseif(Is_Active)then
		Reset_AI()
	end
end)]]></ProtectedString>
									<string name="ScriptGuid">{F4F6DA89-2512-4411-878B-A266924675F8}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AI_Training_Bot_Handle.server.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXCDB21D6C4E3A4BB69EF015C803D96686">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Stiches_Zombie</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXA402501FF6684B58B4AC980C0B2AB225">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
								<string name="ScriptGuid">{22DE8707-9C32-4AAE-BB5E-5D5B076245A1}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animate.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXCC6579D4946B44859812BE315F39E9C9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Init_AI_Training_Bot</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX19FC934DFCF94CE48C017A7B9EB38303">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local Init_E = script.Parent
local Char = Init_E.Parent

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Overhead_Display 			= Channels.SC_Remote_Events.Overhead_Display
local Got_Hit_Effect 			= Channels.SC_Remote_Events.Got_Hit_Effect
local AI_Training_Cage_Clinch	= Channels.Bindable_Events.AI_Training_Cage_Clinch
local AI_Training_Submission 	= Channels.Bindable_Events.AI_Training_Submission
local Ragdoll_Player			= Channels.Bindable_Events.Ragdoll_Player

local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")
local Head = Char:WaitForChild("Head")
local Fight_Data_F = Char:WaitForChild("Fight_Data")
local Stamina_V = Fight_Data_F:WaitForChild("Staminia") -- adjust name if it's 'Stamina'

-- Direct stamina regeneration for bot (server-side)
local function Reload_Stamina()
	while Stamina_V.Value < 40 do
		Stamina_V.Value = math.min(Stamina_V.Value + 1, 100) -- regen step, adjust as needed
		task.wait(0.1)
	end
end
local Fight_UI = Char:WaitForChild("Fighting_UI")
local Health_V = Fight_Data_F:WaitForChild("Health")
local Stam_V = Fight_Data_F:WaitForChild("Staminia")
local Block_Power_V = Fight_Data_F:WaitForChild("Block Power")
local Strike_Power_V = Fight_Data_F:WaitForChild("Strike Power")

local Fight_Walkspeed = 12
local Is_Active = false
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Get_Fighting_UI()
	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
		local Main_F = Fight_UI:FindFirstChild("Main_F") 
		local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
		if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
			return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
		end
	end

	return nil, nil
end

local function Reset_AI()
	Disconnect_Cons()

	Health_V.Value = 100
	Stam_V.Value = 100
	Block_Power_V.Value = 30
	Strike_Power_V.Value = 6

	if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
		HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
	end

	if(Hum ~= nil)then
		Hum.AutoRotate = false
		Hum.WalkSpeed = 12
		Hum.JumpPower = 0

		Animation_Mod.Reset_Character_Animations(Char)

		Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
	end

	Char:SetAttribute("Is_Fighting", false)
	Is_Active = false
end

local function Core_AI_Handle(T_Plr, T_Char)
	local T_HRP = T_Char:WaitForChild("HumanoidRootPart")
	local T_Fight_Data = T_Plr:FindFirstChild("Fight_Data")
	local T_Health_V = T_Fight_Data:WaitForChild("Health")
	local T_Stam_V = T_Fight_Data:WaitForChild("Staminia")
	local T_Block_Power_V = T_Fight_Data:WaitForChild("Block Power")
	local T_Strike_Power_V = T_Fight_Data:WaitForChild("Strike Power")
	local Is_Submission = false

	Char:SetAttribute("Is_Fighting", true)
	Reset_AI()
	Is_Active = true

	task.wait(3)
	if(Is_Active == false)then
		return
	end

	--Fight Data Changes
	table.insert(Cons, Health_V.Changed:Connect(function()
		if(Char ~= nil and Health_V.Value <= 0)then
			Ragdoll_Player:Fire(Char)
		end
	end))

	local function Create_BG()
		local OldG = HRP:FindFirstChildWhichIsA("BodyGyro")
		if(OldG ~= nil)then
			OldG:Destroy()
		end

		local bodyG = Instance.new("BodyGyro", HRP)
		bodyG.P = 1000
		bodyG.MaxTorque = Vector3.new(0, 1000, 0)
		bodyG.D = 10

		return bodyG
	end
	local BG = Create_BG()

	local function Movement_Handle()
		local function Update_Player_Movement()
			local function Get_Target_Position()
				if(T_HRP ~= nil)then
					local Move_Speed = T_HRP.Velocity
					local Def_Pos = T_HRP.Position + T_HRP.CFrame.LookVector * 3.5

					if(math.floor(Move_Speed.Magnitude) <= 0)then
						return Def_Pos, T_HRP.Position
					else
						local Ping = T_Plr:GetNetworkPing()
						local Dir = Move_Speed.Unit
						local Speed = Move_Speed.Magnitude
						local Extrapolated_Pos = Def_Pos + Dir * (Speed * Ping)
						local Travel_Time = ((Extrapolated_Pos - HRP.Position).Magnitude) / Hum.WalkSpeed
						return Extrapolated_Pos + Dir * (Hum.WalkSpeed * Travel_Time), Extrapolated_Pos
					end
				end

				return HRP.Position, HRP.Position + HRP.CFrame.LookVector * 3
			end
			local Move_Pos, Look_Pos = Get_Target_Position()

			BG.CFrame = CFrame.new(HRP.Position, Look_Pos)
			Hum:MoveTo(Move_Pos)
		end

		table.insert(Cons, RunService.Stepped:Connect(function()
			if(BG ~= nil and HRP ~= nil and Hum ~= nil and Hum.PlatformStand == false and T_Plr ~= nil and T_HRP ~= nil)then
				if(T_Health_V ~= nil and T_Health_V.Value > 0 and Is_Submission == false)then
					Update_Player_Movement()
				else
					Hum:MoveTo(HRP.Position)
				end
			end
		end))

		table.insert(Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
			if(Hum.PlatformStand == true)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			else
				BG.P = 1000
				BG.MaxTorque = Vector3.new(0, 1000, 0)
				BG.D = 10
			end
		end))
	end
	Movement_Handle()

	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
		Damage_UIG.Offset = Vector2.new(0, -0.5)
		Damage_Bar_Img.Visible = false
	end

	local function Create_Anim_Arr_Data(Anim_Track_Data)
		local D = {}
		for Key, Anim_Track in next, Anim_Track_Data do
			table.insert(D, Anim_Track)
		end
		return D
	end

	local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	local Combo_Strike_Index = 1
	local Combo_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(T_Plr, Hum, "Bot Combo")
	local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)

	local Debounce_Striking = false
	local Debounce_Dodge = false
	local Debounce_Blocking = false
	local Debounce_Takedown = false
	local Is_Hit = false

	local function Striking_Movement_Handle()
		--> Update Movement, Moving Forward or Backwards | Moving Left to Right | Standing Idle
		--> Track Humanoid MoveDirection
		table.insert(Cons, Hum:GetPropertyChangedSignal("WalkToPoint"):Connect(function()
			local Move_Speed = math.floor(HRP.Velocity.Magnitude)
			if(Move_Speed > 3 and Anim_Track_Data['Shuffle Forward'].IsPlaying == false)then
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				Anim_Track_Data['Shuffle Forward']:Play()
				Anim_Track_Data['Shuffle Forward']:AdjustSpeed(-1)

			elseif(Move_Speed <= 3 and 
				(Anim_Track_Data['Shuffle Forward'].IsPlaying == true or 
					Anim_Track_Data['Shuffle Side'].IsPlaying == true))then

				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
			end
		end))

		Anim_Track_Data['Idle']:Play()
		Anim_Track_Data['Idle']:AdjustSpeed(0.5)
	end
	Striking_Movement_Handle()

	local function On_Hit_Effects()
		--[[
			* When Health goes Down!
				> Camera Shake Effects
					-> Quick Shake
				> Apply Hit Effects
					-> Reset all Animations, Play the Hit One
				> Set Debounce till Hit Effect goes Away
		]]--

		local Prev_Health = Health_V.Value
		local Hit_Anim_Track = Striking_Anim_Tracks['Taking Hit']

		local function Show_Sweat_Effects()
			if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
				local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
				local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
				if(PE ~= nil)then
					PE:Emit(25)
				end
			end
		end

		table.insert(Cons, Health_V.Changed:Connect(function()
			local Current_V = Health_V.Value
			if(Current_V < Prev_Health and Is_Hit == false)then
				Is_Hit = true

				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Show_Sweat_Effects()

				task.spawn(function()
					Animation_Mod.Play_Animation_Track(Hit_Anim_Track)
					Is_Hit = false
				end)
			end

			Prev_Health = Current_V
		end))
	end
	On_Hit_Effects()

	local function Blocking_Effects()
		--[[
			* On Sheild Blocking Power goes down (Greater than 0) and Debounce_Blocking == true
			* Get the Opponent Handed Type
				> Play the Coresponding Animation
		]]--

		local Prev_Blocking = Block_Power_V.Value
		local Tween_Health_Con = nil
		local Tween_Stam_Con = nil
		local Tween_Block_Con = nil
		Block_Power_V:SetAttribute("Is_Blocking", false)

		local function Reset_Healing_Cons()
			if(Tween_Health_Con ~= nil)then
				Tween_Health_Con:Cancel()
				Tween_Health_Con = nil
			end

			if(Tween_Stam_Con ~= nil)then
				Tween_Stam_Con:Cancel()
				Tween_Stam_Con = nil
			end
		end

		local function Set_Healing_Cons()
			local Health_Time = math.clamp((100 - Health_V.Value) * 0.6, 0.6, 60)
			local Tween_Full_Health = TweenInfo.new(Health_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
			Tween_Health_Con = TS:Create(Health_V, Tween_Full_Health, {Value = 100})
			Tween_Health_Con:Play()

			local Stam_Time = math.clamp((100 - Stam_V.Value) * 0.1, 0.1, 10)
			local Tween_Full_Stam = TweenInfo.new(Stam_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)	
			Tween_Stam_Con = TS:Create(Stam_V, Tween_Full_Stam, {Value = 100})
			Tween_Stam_Con:Play()
		end

		table.insert(Cons, Block_Power_V.AttributeChanged:Connect(function(Attrib_Key)
			if(Attrib_Key == "Is_Blocking" and Block_Power_V:GetAttribute("Is_Blocking") ~= nil)then
				Reset_Healing_Cons()
				if(Block_Power_V:GetAttribute("Is_Blocking") == true)then
					Set_Healing_Cons()
				end
			end
		end))


		local function Update_Fight_Block_UI()
			if(Fight_UI ~= nil and Block_Power_V ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil and 
				Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then

				local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
				local Img = Sheild_F:FindFirstChild("Shield_Img")
				local Txt = Sheild_F:FindFirstChild("Shield_Txt")

				if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
					local UIG = Img:FindFirstChildWhichIsA("UIGradient")
					local Block_Power = Block_Power_V.Value
					local Dif =  math.clamp(Block_Power / 30, 0, 1)
					local Offset_Pos_Y = (1 - Dif) - 0.5

					UIG.Offset = Vector2.new(0, Offset_Pos_Y)
					Txt.Text = Block_Power .. ""
					if(Dif <= 0.25)then
						Txt.TextColor3 = Color3.new(1, 0, 0)
					else
						Txt.TextColor3 = Color3.new(1, 1, 1)
					end

				end
			end

		end

		table.insert(Cons, Block_Power_V.Changed:Connect(function()
			local Current_V = Block_Power_V.Value
			if(Current_V > 0 and Current_V < Prev_Blocking and Debounce_Blocking == true)then
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Striking_Anim_Tracks['Body Block Left'])

				if(Block_Power_V.Value < 30)then
					if(Tween_Block_Con ~= nil)then
						Tween_Block_Con:Cancel()
						Tween_Block_Con = nil
					end

					local Block_Time = math.clamp((30 - Block_Power_V.Value) * 0.2667, 0.2667, 8)
					local Tween_Block_Power = TweenInfo.new(Block_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 6)
					Tween_Block_Con = TS:Create(Block_Power_V, Tween_Block_Power, {Value = 30})
					Tween_Block_Con:Play()
					Tween_Block_Con.Completed:Wait()
					Tween_Block_Con = nil
				end
			end

			Update_Fight_Block_UI()
			Prev_Blocking = Current_V

		end))

	end
	Blocking_Effects()

	local function Get_Core_Strike_Handles()
		local Funcs = {}
		
		local function Has_Enough_Stam(Min_V)
			if(Stam_V ~= nil and Stam_V.Value >= Min_V)then
				Stam_V.Value -= Min_V
				return true
			end
			return false
		end

		local function Get_Player_To_Hit()
			local Whitelist_Chars = {T_Char}
			local Overlap_P = OverlapParams.new()
			Overlap_P.MaxParts = 1
			Overlap_P.FilterType = Enum.RaycastFilterType.Include
			Overlap_P.FilterDescendantsInstances = {Whitelist_Chars}

			local function Create_Region_CF()
				local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
				local Distance = (Speed + 3)
				local Head_Dir = Head.CFrame.LookVector
				local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

				local cframe = HRP.CFrame * CFrame.new(0, 0, -3)
				return cframe
			end
			local Spawn_CF = Create_Region_CF()
			local Hitbox_Size = Vector3.new(4, 8, 4)

			local function Create_Hitbox_Part()
				local P = Instance.new("Part", game.Workspace)
				P.Name = "Hitbox_Part"
				P.Anchored = true
				P.CanCollide = false
				P.Transparency = 0.5
				P.Color = Color3.new(1, 0, 0)
				P.Material = Enum.Material.SmoothPlastic
				P.Size = Hitbox_Size
				P.CFrame = Spawn_CF

				Debris:AddItem(P, 5)
			end
			--Create_Hitbox_Part()

			local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
			if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
				local function Get_Char_From_BP()
					for i = 1, #Whitelist_Chars do
						local C = Whitelist_Chars[i]
						if(C ~= nil and Region_Data[1]:IsDescendantOf(C))then
							return C
						end
					end

					return Whitelist_Chars[1]
				end

				return Get_Char_From_BP()
			end

			return nil
		end

		local function Get_Punch_Power()
			local Tween_Punch_Power_Back = TweenInfo.new(1.75, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
			local Strike_Power = Strike_Power_V.Value
			Strike_Power_V.Value = 0
			TS:Create(Strike_Power_V, Tween_Punch_Power_Back, {Value = 6}):Play()
			return Strike_Power
		end

		local function Get_Target_Fight_Data(Hit_Char)
			local Hit_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
			if(Hit_Plr ~= nil)then
				return Hit_Plr:FindFirstChild("Fight_Data")
			else
				return Hit_Char:FindFirstChild("Fight_Data")
			end
		end

		function Funcs.Strike_Handle()
			if Stamina_V.Value < 20 then Reload_Stamina() end
			--[[
				* Play Woosh Sound Effect locally
				* Play Animation
				* Tell the Server that you are Striking
			]]--

			Debounce_Striking = true
			-- AI is Striking!
			SE_Mod.PlaySFX(Char, "Punch_Woosh_SE")

			local function Play_Strike_Animation()
				local Track = Combo_Anim_Arr[Combo_Strike_Index]
				local Key = Track:GetAttribute("Strike_Key") or "A"

				task.spawn(function()
					if(HRP ~= nil and Has_Enough_Stam(10))then
						local Base_Punch_Power = Get_Punch_Power()
						local Hit_Char = Get_Player_To_Hit()
						local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Key)
						local Power_Inc = Strike_Data['Power Multi'] or 0
						local Punch_Power = math.ceil(Base_Punch_Power * (1  + Power_Inc))
						--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Strikes", 1)

						if(Hit_Char ~= nil)then
							local Hit_Fight_Data = Get_Target_Fight_Data(Hit_Char)
							if(Hit_Fight_Data ~= nil and Hit_Fight_Data:FindFirstChild("Health") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Block Power") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Staminia") ~= nil)then

								local T_Health = Hit_Fight_Data:FindFirstChild("Health")
								local T_Block_Power = Hit_Fight_Data:FindFirstChild("Block Power")
								local T_Staminia = Hit_Fight_Data:FindFirstChild("Staminia")

								local function Is_Dodging_Check()
									local Is_Dodging = T_Staminia:GetAttribute("Is_Dodging")
									if(Is_Dodging ~= nil and Is_Dodging == true)then
										local Target_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if(Target_Plr ~= nil)then
											Stats_Manager_Mod.Add_To_Player_Stats_Data(Target_Plr, "Dodged Strikes", 1)
										end

										return true
									end
									return false
								end

								local function Is_Blocking_Check()
									local Is_Block = T_Block_Power:GetAttribute("Is_Blocking")
									if(Is_Block ~= nil and Is_Block == true)then
										T_Block_Power.Value -= Punch_Power
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.fromRGB(170, 85, 255))

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										if(T_Block_Power.Value < 0)then
											local Dif = math.abs(T_Block_Power.Value)
											T_Health.Value = math.clamp(T_Health.Value - Dif, 0, 100)
											T_Block_Power.Value = 0

											SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
											--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)

											Overhead_Display:FireAllClients(Hit_Char, "-" .. Dif, Color3.new(1, 0, 0))

										else
											SE_Mod.PlaySFX(HRP, "Blocked_Hit_SE")	
										end

										return true
									end

									return false
								end

								if(Is_Dodging_Check())then
									--Play Dodging Text
									Overhead_Display:FireAllClients(Hit_Char, "Dodged", Color3.fromRGB(35, 244, 68))
								elseif(Is_Blocking_Check())then
									--Play Blocking 
								else
									--Apply the Hit
									local function Apply_Strike()
										T_Health.Value = math.clamp(T_Health.Value - Punch_Power, 0, 100)
										SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
										--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.new(1, 0, 0))
										--Punch_Hit_VFX:FireClient(Plr, Hit_Char)
										--Play Damage Val Show

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										local T_HRP = Hit_Char:FindFirstChild("HumanoidRootPart")
										if(T_HRP ~= nil)then
											local Hit_Force = 625 -- Was 350 then 500
											local Dir = HRP.CFrame.LookVector 
											T_HRP:ApplyImpulse(Dir * Hit_Force * T_HRP:GetMass())
										end
									end
									Apply_Strike()
								end
							end

						end
					end
				end)

				Combo_Strike_Index += 1
				if(Combo_Strike_Index > #Combo_Anim_Arr)then
					Combo_Strike_Index = 1
				end

				Animation_Mod.Stop_Animation_Tracks(Combo_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Track)
			end
			task.spawn(Play_Strike_Animation)
			task.wait(0.5)

			Debounce_Striking = false
		end

		local Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left']
		local Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		local Back_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		function Funcs.Dodge_Handle(Dodge_Type)
			--[[
				* Get the Type First
					-> First Index? Just play the Slip Animation
					-> 2nd Index? Play the Dodge Animation AND apply Force to the Player in the direction
				
					-> Tell the Server that you are Dodging and should reduce Staminia Value
			]]--

			Debounce_Dodge = true
			-- AI is Dodging

			local function Apply_Force(Dir)
				HRP:ApplyImpulse(Dir * (Fight_Walkspeed * 65) * HRP:GetMass())
			end

			task.spawn(function()
				if(Has_Enough_Stam(5))then
					--Play the Sound Effect
					--Toggle Value
					SE_Mod.PlaySFX(HRP, "Missed_SE")
					Stam_V:SetAttribute("Is_Dodging", true)
					task.wait(0.5)
					Stam_V:SetAttribute("Is_Dodging", false)
				end
			end)
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})

			local function Increment_Anim()
				if(Dodge_Type == "Dodge Left")then
					if(Left_Dodge_Ani == Striking_Anim_Tracks['Slip Left'])then
						Left_Dodge_Ani = Striking_Anim_Tracks['Headblock Left']
					else
						Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left'] 
					end
				else
					--Right
					if(Right_Dodge_Ani == Striking_Anim_Tracks['Slip Right'])then
						Right_Dodge_Ani = Striking_Anim_Tracks['Headblock Right']
					else
						Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right'] 
					end
				end
			end

			if(Dodge_Type == "Dodge Left")then
				--Left
				if(Left_Dodge_Ani == Striking_Anim_Tracks['Headblock Left'])then
					--Apply_Force(HRP.CFrame.RightVector * -1)
				end
				Apply_Force(HRP.CFrame.RightVector * -1)
				Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Right")then
				--Right
				if(Right_Dodge_Ani == Striking_Anim_Tracks['Headblock Right'])then
					--Apply_Force(HRP.CFrame.RightVector)
				end
				Apply_Force(HRP.CFrame.RightVector)
				Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Back")then
				Apply_Force(HRP.CFrame.LookVector * -1)
				Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
			end

			Debounce_Dodge = false
		end

		local function Toggle_Sheild_Icon(Is_Enabled)
			local Main_F =  Fight_UI:FindFirstChild("Main_F")
			if(Main_F ~= nil and Main_F:FindFirstChild("Shield_F") ~= nil)then
				local SF = Main_F:FindFirstChild("Shield_F")
				SF.Visible = true
				
				local Img = SF:FindFirstChild("Shield_Img")
				if(Img ~= nil)then
					if(Is_Enabled)then
						Img.Image = "rbxassetid://130871917395731"
					else
						Img.Image = "rbxassetid://125284121534949"
					end
				end
			end
		end

		local function Toggle_Heal_PE(Is_Enabled)
			local PE = HRP:GetChildren()
			for i = 1, #PE do
				if(PE[i] ~= nil and PE[i].Name == "Heal_PE" and PE[i]:IsA("ParticleEmitter"))then
					PE[i].Enabled = Is_Enabled
				end
			end

			Toggle_Sheild_Icon(Is_Enabled)
		end

		local Low_Block_Con = nil
		local function Disable_Blocking_Handle()
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed
			end

			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Block_Power_V:SetAttribute("Is_Blocking", false)
			Toggle_Heal_PE(false)

			Debounce_Blocking = false
		end

		local function Play_Blocking_Animation()
			local Anim_Track = Striking_Anim_Tracks['Main Block']
			if(Anim_Track ~= nil)then
				Anim_Track:Play()
				Anim_Track:AdjustSpeed(1)
				task.wait(Anim_Track.Length * 0.9)

				if(Anim_Track ~= nil and Debounce_Blocking == true)then
					Anim_Track:AdjustSpeed(0)
				end
			end
		end

		function Funcs.Disable_Blocking_Handle()
			-- AI is turning off Blocking
			Disable_Blocking_Handle()
		end

		function Funcs.Blocking_Handle()
			Debounce_Blocking = true
			-- AI Is Blocking

			if(Hum ~= nil)then
				Hum.WalkSpeed = 8
			end

			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			Low_Block_Con = Block_Power_V.Changed:Connect(function()
				if(Block_Power_V.Value <= 0 and Debounce_Blocking == true)then
					if(Low_Block_Con ~= nil)then
						Low_Block_Con:Disconnect()
						Low_Block_Con = nil
					end

					Disable_Blocking_Handle()
				end
			end)
			table.insert(Cons, Low_Block_Con)
			task.spawn(Play_Blocking_Animation)

			if(Block_Power_V ~= nil and Block_Power_V.Value > 0)then
				Block_Power_V:SetAttribute("Is_Blocking", true)
				Toggle_Heal_PE(true)
			end
		end

		function Funcs.Get_Hitbox_Res()
			return (Get_Player_To_Hit() ~= nil)
		end		

		function Funcs.Get_Dodge_Type()
			local function Get_Ray_Distance_Data()
				local Origin = HRP.Position
				local Ray_Parm = RaycastParams.new()
				Ray_Parm.FilterType = Enum.RaycastFilterType.Exclude
				Ray_Parm.FilterDescendantsInstances = {Char, T_Char}

				local function Get_Ray_Dist(Dir)
					local Ray_Res = game.Workspace:Raycast(Origin, Dir * 10, Ray_Parm)
					if(Ray_Res ~= nil and Ray_Res.Distance ~= nil)then
						return Ray_Res.Distance
					end
					return 15
				end

				return {
					{
						['Type'] = "Dodge Back",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.LookVector * -1)
					},

					{
						['Type'] = "Dodge Left",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector * -1)
					},

					{
						['Type'] = "Dodge Right",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector)
					},

				}
			end
			local Ray_Dist_Arr = Get_Ray_Distance_Data()

			table.sort(Ray_Dist_Arr, function(A, B)
				return A['Distance'] > B['Distance']
			end)

			return Ray_Dist_Arr[1]['Type']
		end

		function Funcs.Is_Player_Striking_You()
			if(T_Strike_Power_V ~= nil and T_Strike_Power_V.Value < 4)then
				return true
			end
			return false
		end

		return Funcs
	end
	local Core_Strike_Funcs = Get_Core_Strike_Handles()

	--[[
		Core AI Decision Making goes here
		
		* If within Striking Distance ~ 5 Studs
			* If Player is Striking too, Dodge Left Right or Back (Max 2 Dodges)
			* Has to Strike (Max 3 Strikes)
				* Dodge Back if Strike (or left or Right)
		* Default to Blocking Handle
	]]--

	local function Submission_Handle(Is_Submitting, Attacking_Char)
		Animation_Mod.Reset_Character_Animations(Char)
		if(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end

		if(Is_Submitting)then
			Is_Submission = true
			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end

			if(HRP ~= nil)then
				--HRP.Anchored = true
				--HRP.CFrame *= CFrame.new(Vector3.new(0, 0.15, 0))
			end

			--> Play Animation
			--> Get Submission Character & Player
			--> Get their Takedown and Submission Data

			--> If Attacking Player, Set HRP CFrame Position
			--> Play Take Down Animation

			--> Play Submission Animation
			--> Play Submission Loop Animation

			local function Get_Takedown_Submission_Tracks()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)
				return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Receiving ID'], Submission_Data['Receiving ID'], Submission_Data['Receiving Loop ID'])
			end
			local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()

			Takedown_Track.Priority = Enum.AnimationPriority.Action2
			Animation_Mod.Play_Animation_Track(Takedown_Track, true)

			task.wait(0.25)

			Submission_Track.Priority = Enum.AnimationPriority.Action3
			Animation_Mod.Play_Animation_Track(Submission_Track)

			Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
		else
			Is_Hit = false

			if(HRP ~= nil)then
				HRP.Anchored = false
			end

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
			Is_Submission = false
		end
	end

	table.insert(Cons, AI_Training_Submission.Event:Connect(function(AI_Char, Attacking_Char, Is_Submitting)
		if(AI_Char == Char)then
			Submission_Handle(Is_Submitting, Attacking_Char)
		end
	end))


	local function Clinch_Handle(Animation_Sequence_Data, Is_Attacking)
		local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(Char)

			if(Debounce_Blocking == true)then
				task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
			end

			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
		end
		Freeze_Character()

		local function Play_Strike_Sequences()
			local Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
			Animation_Mod.Play_Animation_Track(Clinch_Tracks_Data['Init_Clinch'], true)
			task.spawn(Animation_Mod.Play_Animation_Track, Clinch_Tracks_Data['Loop_Clinch'])
			task.wait(1)

			for i = 1, #Animation_Sequence_Data do
				local Strike_Key = Animation_Sequence_Data[i]
				local Strike_Track = Clinch_Tracks_Data[Strike_Key]

				if(Strike_Track ~= nil)then
					--Play Flash, Play Hit Sound Effect, Quick Camera Shake
					Animation_Mod.Play_Animation_Track(Strike_Track)
					--wait(0.5)
				end
			end

		end
		Play_Strike_Sequences()

		local function Clinch_Reset_Handle()
			Animation_Mod.Reset_Character_Animations(Char)
			Is_Hit = false

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
		end	
		Clinch_Reset_Handle()
	end

	table.insert(Cons, AI_Training_Cage_Clinch.Event:Connect(function(AI_Char, Sequence_Keys, Is_Attacking)
		if(AI_Char == Char)then
			Clinch_Handle(Sequence_Keys, Is_Attacking)
		end
	end))


	local Strike_Count, Dodge_Count = 0, 0
	local function Main_AI_Logic_Gate()
		if(Health_V.Value > 0 and Is_Hit == false and T_Health_V ~= nil and T_Health_V.Value > 0)then
			if(Core_Strike_Funcs.Get_Hitbox_Res())then -- Within Strike Zone
				local Is_Player_Hitting_You = Core_Strike_Funcs.Is_Player_Striking_You()
				if(Is_Player_Hitting_You)then
					--Take the HIts until you're below 20 Block Power
					-- Dodge? or Strike
					if(Block_Power_V.Value > 10)then
						if(Dodge_Count < 2 or Strike_Count >= 3)then
							--Dodge
							if(Debounce_Dodge == false and Stam_V.Value >= 5)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								local Dodge_Type = Core_Strike_Funcs.Get_Dodge_Type()
								Core_Strike_Funcs.Dodge_Handle(Dodge_Type)

								Dodge_Count += 1
								if(Strike_Count >= 3)then
									Strike_Count = 0
								end
							end

						else
							--Strike
							if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								Core_Strike_Funcs.Strike_Handle()
								Strike_Count += 1
								if(Dodge_Count >= 2)then
									Dodge_Count = 0
								end
							end
						end
					elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
						--Not within Strike Zone, resort to Blocking
						Core_Strike_Funcs.Blocking_Handle()
					end
				else
					--Strike
					if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
						if(Debounce_Blocking == true)then
							task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
						end

						Core_Strike_Funcs.Strike_Handle()
						Strike_Count += 1
						if(Dodge_Count >= 2)then
							Dodge_Count = 0
						end
					end
				end
			elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
				--Not within Strike Zone, resort to Blocking
				Core_Strike_Funcs.Blocking_Handle()
			end

		elseif(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end
	end

	while Is_Active do
		if(Is_Submission == false)then
			Main_AI_Logic_Gate()
		end
		task.wait(0.5)
	end
end

Init_E.Event:Connect(function(T_Plr, T_Char,OtherStuff)	
	if(Is_Active == false and T_Plr ~= nil and T_Char ~= nil)then
		Core_AI_Handle(T_Plr, T_Char)
	elseif(Is_Active)then
		Reset_AI()
	end
end)]]></ProtectedString>
									<string name="ScriptGuid">{A68540FA-5C45-4251-ADD7-4DC70D8C3656}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AI_Training_Bot_Handle.server.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX40923F65D98B440DAE9C8981EAE12170">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Bones_Zombie</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX2EA816F1F2764643AFA0132D3A81661F">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
								<string name="ScriptGuid">{B5A88915-01DA-460F-8988-CA6210684424}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animate.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX1F598496CD2E4A9BB2994800B5D64024">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Init_AI_Training_Bot</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX39150FB5B80942F7B4F3CF998ED580BF">
								<Properties>
									<Content name="LinkedSource"><null></null></Content>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local RS = game:GetService("ReplicatedStorage")
local TS = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local Init_E = script.Parent
local Char = Init_E.Parent

local Channels 					= require(RS:WaitForChild("Modules"):WaitForChild("Channels"))
local Overhead_Display 			= Channels.SC_Remote_Events.Overhead_Display
local Got_Hit_Effect 			= Channels.SC_Remote_Events.Got_Hit_Effect
local AI_Training_Cage_Clinch	= Channels.Bindable_Events.AI_Training_Cage_Clinch
local AI_Training_Submission 	= Channels.Bindable_Events.AI_Training_Submission
local Ragdoll_Player			= Channels.Bindable_Events.Ragdoll_Player

local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")
local Head = Char:WaitForChild("Head")
local Fight_Data_F = Char:WaitForChild("Fight_Data")
local Stamina_V = Fight_Data_F:WaitForChild("Staminia") -- adjust name if it's 'Stamina'

-- Direct stamina regeneration for bot (server-side)
local function Reload_Stamina()
	while Stamina_V.Value < 40 do
		Stamina_V.Value = math.min(Stamina_V.Value + 1, 100) -- regen step, adjust as needed
		task.wait(0.1)
	end
end
local Fight_UI = Char:WaitForChild("Fighting_UI")
local Health_V = Fight_Data_F:WaitForChild("Health")
local Stam_V = Fight_Data_F:WaitForChild("Staminia")
local Block_Power_V = Fight_Data_F:WaitForChild("Block Power")
local Strike_Power_V = Fight_Data_F:WaitForChild("Strike Power")

local Fight_Walkspeed = 12
local Is_Active = false
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Get_Fighting_UI()
	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
		local Main_F = Fight_UI:FindFirstChild("Main_F") 
		local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
		if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
			return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
		end
	end

	return nil, nil
end

local function Reset_AI()
	Disconnect_Cons()

	Health_V.Value = 100
	Stam_V.Value = 100
	Block_Power_V.Value = 30
	Strike_Power_V.Value = 6

	if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
		HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
	end

	if(Hum ~= nil)then
		Hum.AutoRotate = false
		Hum.WalkSpeed = 12
		Hum.JumpPower = 0

		Animation_Mod.Reset_Character_Animations(Char)

		Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
	end

	Char:SetAttribute("Is_Fighting", false)
	Is_Active = false
end

local function Core_AI_Handle(T_Plr, T_Char)
	local T_HRP = T_Char:WaitForChild("HumanoidRootPart")
	local T_Fight_Data = T_Plr:FindFirstChild("Fight_Data")
	local T_Health_V = T_Fight_Data:WaitForChild("Health")
	local T_Stam_V = T_Fight_Data:WaitForChild("Staminia")
	local T_Block_Power_V = T_Fight_Data:WaitForChild("Block Power")
	local T_Strike_Power_V = T_Fight_Data:WaitForChild("Strike Power")
	local Is_Submission = false

	Char:SetAttribute("Is_Fighting", true)
	Reset_AI()
	Is_Active = true

	task.wait(3)
	if(Is_Active == false)then
		return
	end

	--Fight Data Changes
	table.insert(Cons, Health_V.Changed:Connect(function()
		if(Char ~= nil and Health_V.Value <= 0)then
			Ragdoll_Player:Fire(Char)
		end
	end))

	local function Create_BG()
		local OldG = HRP:FindFirstChildWhichIsA("BodyGyro")
		if(OldG ~= nil)then
			OldG:Destroy()
		end

		local bodyG = Instance.new("BodyGyro", HRP)
		bodyG.P = 1000
		bodyG.MaxTorque = Vector3.new(0, 1000, 0)
		bodyG.D = 10

		return bodyG
	end
	local BG = Create_BG()

	local function Movement_Handle()
		local function Update_Player_Movement()
			local function Get_Target_Position()
				if(T_HRP ~= nil)then
					local Move_Speed = T_HRP.Velocity
					local Def_Pos = T_HRP.Position + T_HRP.CFrame.LookVector * 3.5

					if(math.floor(Move_Speed.Magnitude) <= 0)then
						return Def_Pos, T_HRP.Position
					else
						local Ping = T_Plr:GetNetworkPing()
						local Dir = Move_Speed.Unit
						local Speed = Move_Speed.Magnitude
						local Extrapolated_Pos = Def_Pos + Dir * (Speed * Ping)
						local Travel_Time = ((Extrapolated_Pos - HRP.Position).Magnitude) / Hum.WalkSpeed
						return Extrapolated_Pos + Dir * (Hum.WalkSpeed * Travel_Time), Extrapolated_Pos
					end
				end

				return HRP.Position, HRP.Position + HRP.CFrame.LookVector * 3
			end
			local Move_Pos, Look_Pos = Get_Target_Position()

			BG.CFrame = CFrame.new(HRP.Position, Look_Pos)
			Hum:MoveTo(Move_Pos)
		end

		table.insert(Cons, RunService.Stepped:Connect(function()
			if(BG ~= nil and HRP ~= nil and Hum ~= nil and Hum.PlatformStand == false and T_Plr ~= nil and T_HRP ~= nil)then
				if(T_Health_V ~= nil and T_Health_V.Value > 0 and Is_Submission == false)then
					Update_Player_Movement()
				else
					Hum:MoveTo(HRP.Position)
				end
			end
		end))

		table.insert(Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
			if(Hum.PlatformStand == true)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			else
				BG.P = 1000
				BG.MaxTorque = Vector3.new(0, 1000, 0)
				BG.D = 10
			end
		end))
	end
	Movement_Handle()

	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
		Damage_UIG.Offset = Vector2.new(0, -0.5)
		Damage_Bar_Img.Visible = false
	end

	local function Create_Anim_Arr_Data(Anim_Track_Data)
		local D = {}
		for Key, Anim_Track in next, Anim_Track_Data do
			table.insert(D, Anim_Track)
		end
		return D
	end

	local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	local Combo_Strike_Index = 1
	local Combo_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(T_Plr, Hum, "Bot Combo")
	local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)

	local Debounce_Striking = false
	local Debounce_Dodge = false
	local Debounce_Blocking = false
	local Debounce_Takedown = false
	local Is_Hit = false

	local function Striking_Movement_Handle()
		--> Update Movement, Moving Forward or Backwards | Moving Left to Right | Standing Idle
		--> Track Humanoid MoveDirection
		table.insert(Cons, Hum:GetPropertyChangedSignal("WalkToPoint"):Connect(function()
			local Move_Speed = math.floor(HRP.Velocity.Magnitude)
			if(Move_Speed > 3 and Anim_Track_Data['Shuffle Forward'].IsPlaying == false)then
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				Anim_Track_Data['Shuffle Forward']:Play()
				Anim_Track_Data['Shuffle Forward']:AdjustSpeed(-1)

			elseif(Move_Speed <= 3 and 
				(Anim_Track_Data['Shuffle Forward'].IsPlaying == true or 
					Anim_Track_Data['Shuffle Side'].IsPlaying == true))then

				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
			end
		end))

		Anim_Track_Data['Idle']:Play()
		Anim_Track_Data['Idle']:AdjustSpeed(0.5)
	end
	Striking_Movement_Handle()

	local function On_Hit_Effects()
		--[[
			* When Health goes Down!
				> Camera Shake Effects
					-> Quick Shake
				> Apply Hit Effects
					-> Reset all Animations, Play the Hit One
				> Set Debounce till Hit Effect goes Away
		]]--

		local Prev_Health = Health_V.Value
		local Hit_Anim_Track = Striking_Anim_Tracks['Taking Hit']

		local function Show_Sweat_Effects()
			if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
				local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
				local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
				if(PE ~= nil)then
					PE:Emit(25)
				end
			end
		end

		table.insert(Cons, Health_V.Changed:Connect(function()
			local Current_V = Health_V.Value
			if(Current_V < Prev_Health and Is_Hit == false)then
				Is_Hit = true

				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Show_Sweat_Effects()

				task.spawn(function()
					Animation_Mod.Play_Animation_Track(Hit_Anim_Track)
					Is_Hit = false
				end)
			end

			Prev_Health = Current_V
		end))
	end
	On_Hit_Effects()

	local function Blocking_Effects()
		--[[
			* On Sheild Blocking Power goes down (Greater than 0) and Debounce_Blocking == true
			* Get the Opponent Handed Type
				> Play the Coresponding Animation
		]]--

		local Prev_Blocking = Block_Power_V.Value
		local Tween_Health_Con = nil
		local Tween_Stam_Con = nil
		local Tween_Block_Con = nil
		Block_Power_V:SetAttribute("Is_Blocking", false)

		local function Reset_Healing_Cons()
			if(Tween_Health_Con ~= nil)then
				Tween_Health_Con:Cancel()
				Tween_Health_Con = nil
			end

			if(Tween_Stam_Con ~= nil)then
				Tween_Stam_Con:Cancel()
				Tween_Stam_Con = nil
			end
		end

		local function Set_Healing_Cons()
			local Health_Time = math.clamp((100 - Health_V.Value) * 0.6, 0.6, 60)
			local Tween_Full_Health = TweenInfo.new(Health_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
			Tween_Health_Con = TS:Create(Health_V, Tween_Full_Health, {Value = 100})
			Tween_Health_Con:Play()

			local Stam_Time = math.clamp((100 - Stam_V.Value) * 0.1, 0.1, 10)
			local Tween_Full_Stam = TweenInfo.new(Stam_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)	
			Tween_Stam_Con = TS:Create(Stam_V, Tween_Full_Stam, {Value = 100})
			Tween_Stam_Con:Play()
		end

		table.insert(Cons, Block_Power_V.AttributeChanged:Connect(function(Attrib_Key)
			if(Attrib_Key == "Is_Blocking" and Block_Power_V:GetAttribute("Is_Blocking") ~= nil)then
				Reset_Healing_Cons()
				if(Block_Power_V:GetAttribute("Is_Blocking") == true)then
					Set_Healing_Cons()
				end
			end
		end))


		local function Update_Fight_Block_UI()
			if(Fight_UI ~= nil and Block_Power_V ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil and 
				Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then

				local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
				local Img = Sheild_F:FindFirstChild("Shield_Img")
				local Txt = Sheild_F:FindFirstChild("Shield_Txt")

				if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
					local UIG = Img:FindFirstChildWhichIsA("UIGradient")
					local Block_Power = Block_Power_V.Value
					local Dif =  math.clamp(Block_Power / 30, 0, 1)
					local Offset_Pos_Y = (1 - Dif) - 0.5

					UIG.Offset = Vector2.new(0, Offset_Pos_Y)
					Txt.Text = Block_Power .. ""
					if(Dif <= 0.25)then
						Txt.TextColor3 = Color3.new(1, 0, 0)
					else
						Txt.TextColor3 = Color3.new(1, 1, 1)
					end

				end
			end

		end

		table.insert(Cons, Block_Power_V.Changed:Connect(function()
			local Current_V = Block_Power_V.Value
			if(Current_V > 0 and Current_V < Prev_Blocking and Debounce_Blocking == true)then
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Striking_Anim_Tracks['Body Block Left'])

				if(Block_Power_V.Value < 30)then
					if(Tween_Block_Con ~= nil)then
						Tween_Block_Con:Cancel()
						Tween_Block_Con = nil
					end

					local Block_Time = math.clamp((30 - Block_Power_V.Value) * 0.2667, 0.2667, 8)
					local Tween_Block_Power = TweenInfo.new(Block_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 6)
					Tween_Block_Con = TS:Create(Block_Power_V, Tween_Block_Power, {Value = 30})
					Tween_Block_Con:Play()
					Tween_Block_Con.Completed:Wait()
					Tween_Block_Con = nil
				end
			end

			Update_Fight_Block_UI()
			Prev_Blocking = Current_V

		end))

	end
	Blocking_Effects()

	local function Get_Core_Strike_Handles()
		local Funcs = {}
	
		local function Has_Enough_Stam(Min_V)
			if(Stam_V ~= nil and Stam_V.Value >= Min_V)then
				Stam_V.Value -= Min_V
				return true
			end
			return false
		end

		local function Get_Player_To_Hit()
			local Whitelist_Chars = {T_Char}
			local Overlap_P = OverlapParams.new()
			Overlap_P.MaxParts = 1
			Overlap_P.FilterType = Enum.RaycastFilterType.Include
			Overlap_P.FilterDescendantsInstances = {Whitelist_Chars}

			local function Create_Region_CF()
				local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
				local Distance = (Speed + 3)
				local Head_Dir = Head.CFrame.LookVector
				local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

				local cframe = HRP.CFrame * CFrame.new(0, 0, -3)
				return cframe
			end
			local Spawn_CF = Create_Region_CF()
			local Hitbox_Size = Vector3.new(4, 8, 4)

			local function Create_Hitbox_Part()
				local P = Instance.new("Part", game.Workspace)
				P.Name = "Hitbox_Part"
				P.Anchored = true
				P.CanCollide = false
				P.Transparency = 0.5
				P.Color = Color3.new(1, 0, 0)
				P.Material = Enum.Material.SmoothPlastic
				P.Size = Hitbox_Size
				P.CFrame = Spawn_CF

				Debris:AddItem(P, 5)
			end
			--Create_Hitbox_Part()

			local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
			if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
				local function Get_Char_From_BP()
					for i = 1, #Whitelist_Chars do
						local C = Whitelist_Chars[i]
						if(C ~= nil and Region_Data[1]:IsDescendantOf(C))then
							return C
						end
					end

					return Whitelist_Chars[1]
				end

				return Get_Char_From_BP()
			end

			return nil
		end

		local function Get_Punch_Power()
			local Tween_Punch_Power_Back = TweenInfo.new(1.75, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
			local Strike_Power = Strike_Power_V.Value
			Strike_Power_V.Value = 0
			TS:Create(Strike_Power_V, Tween_Punch_Power_Back, {Value = 6}):Play()
			return Strike_Power
		end

		local function Get_Target_Fight_Data(Hit_Char)
			local Hit_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
			if(Hit_Plr ~= nil)then
				return Hit_Plr:FindFirstChild("Fight_Data")
			else
				return Hit_Char:FindFirstChild("Fight_Data")
			end
		end

		function Funcs.Strike_Handle()
			if Stamina_V.Value < 20 then Reload_Stamina() end
			--[[
				* Play Woosh Sound Effect locally
				* Play Animation
				* Tell the Server that you are Striking
			]]--

			Debounce_Striking = true
			-- AI is Striking!
			SE_Mod.PlaySFX(Char, "Punch_Woosh_SE")
			
			local function Play_Strike_Animation()
				local Track = Combo_Anim_Arr[Combo_Strike_Index]
				local Key = Track:GetAttribute("Strike_Key") or "A"

				task.spawn(function()
					if(HRP ~= nil and Has_Enough_Stam(10))then
						local Base_Punch_Power = Get_Punch_Power()
						local Hit_Char = Get_Player_To_Hit()
						local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Key)
						local Power_Inc = Strike_Data['Power Multi'] or 0
						local Punch_Power = math.ceil(Base_Punch_Power * (1  + Power_Inc))
						--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Strikes", 1)

						if(Hit_Char ~= nil)then
							local Hit_Fight_Data = Get_Target_Fight_Data(Hit_Char)
							if(Hit_Fight_Data ~= nil and Hit_Fight_Data:FindFirstChild("Health") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Block Power") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Staminia") ~= nil)then

								local T_Health = Hit_Fight_Data:FindFirstChild("Health")
								local T_Block_Power = Hit_Fight_Data:FindFirstChild("Block Power")
								local T_Staminia = Hit_Fight_Data:FindFirstChild("Staminia")

								local function Is_Dodging_Check()
									local Is_Dodging = T_Staminia:GetAttribute("Is_Dodging")
									if(Is_Dodging ~= nil and Is_Dodging == true)then
										local Target_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if(Target_Plr ~= nil)then
											Stats_Manager_Mod.Add_To_Player_Stats_Data(Target_Plr, "Dodged Strikes", 1)
										end

										return true
									end
									return false
								end

								local function Is_Blocking_Check()
									local Is_Block = T_Block_Power:GetAttribute("Is_Blocking")
									if(Is_Block ~= nil and Is_Block == true)then
										T_Block_Power.Value -= Punch_Power
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.fromRGB(170, 85, 255))

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										if(T_Block_Power.Value < 0)then
											local Dif = math.abs(T_Block_Power.Value)
											T_Health.Value = math.clamp(T_Health.Value - Dif, 0, 100)
											T_Block_Power.Value = 0

											SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
											--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)

											Overhead_Display:FireAllClients(Hit_Char, "-" .. Dif, Color3.new(1, 0, 0))

										else
											SE_Mod.PlaySFX(HRP, "Blocked_Hit_SE")	
										end

										return true
									end

									return false
								end

								if(Is_Dodging_Check())then
									--Play Dodging Text
									Overhead_Display:FireAllClients(Hit_Char, "Dodged", Color3.fromRGB(35, 244, 68))
								elseif(Is_Blocking_Check())then
									--Play Blocking 
								else
									--Apply the Hit
									local function Apply_Strike()
										T_Health.Value = math.clamp(T_Health.Value - Punch_Power, 0, 100)
										SE_Mod.PlaySFX(HRP, "Punch_Hit_SE")
										--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
										Overhead_Display:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.new(1, 0, 0))
										--Punch_Hit_VFX:FireClient(Plr, Hit_Char)
										--Play Damage Val Show

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Got_Hit_Effect:FireClient(targetPlr)
										end

										local T_HRP = Hit_Char:FindFirstChild("HumanoidRootPart")
										if(T_HRP ~= nil)then
											local Hit_Force = 625 -- Was 350 then 500
											local Dir = HRP.CFrame.LookVector 
											T_HRP:ApplyImpulse(Dir * Hit_Force * T_HRP:GetMass())
										end
									end
									Apply_Strike()
								end
							end

						end
					end
				end)

				Combo_Strike_Index += 1
				if(Combo_Strike_Index > #Combo_Anim_Arr)then
					Combo_Strike_Index = 1
				end

				Animation_Mod.Stop_Animation_Tracks(Combo_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Track)
			end
			task.spawn(Play_Strike_Animation)
			task.wait(0.5)

			Debounce_Striking = false
		end

		local Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left']
		local Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		local Back_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		function Funcs.Dodge_Handle(Dodge_Type)
			--[[
				* Get the Type First
					-> First Index? Just play the Slip Animation
					-> 2nd Index? Play the Dodge Animation AND apply Force to the Player in the direction
				
					-> Tell the Server that you are Dodging and should reduce Staminia Value
			]]--

			Debounce_Dodge = true
			-- AI is Dodging

			local function Apply_Force(Dir)
				HRP:ApplyImpulse(Dir * (Fight_Walkspeed * 65) * HRP:GetMass())
			end

			task.spawn(function()
				if(Has_Enough_Stam(5))then
					--Play the Sound Effect
					--Toggle Value
					SE_Mod.PlaySFX(HRP, "Missed_SE")
					Stam_V:SetAttribute("Is_Dodging", true)
					task.wait(0.5)
					Stam_V:SetAttribute("Is_Dodging", false)
				end
			end)
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})

			local function Increment_Anim()
				if(Dodge_Type == "Dodge Left")then
					if(Left_Dodge_Ani == Striking_Anim_Tracks['Slip Left'])then
						Left_Dodge_Ani = Striking_Anim_Tracks['Headblock Left']
					else
						Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left'] 
					end
				else
					--Right
					if(Right_Dodge_Ani == Striking_Anim_Tracks['Slip Right'])then
						Right_Dodge_Ani = Striking_Anim_Tracks['Headblock Right']
					else
						Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right'] 
					end
				end
			end

			if(Dodge_Type == "Dodge Left")then
				--Left
				if(Left_Dodge_Ani == Striking_Anim_Tracks['Headblock Left'])then
					--Apply_Force(HRP.CFrame.RightVector * -1)
				end
				Apply_Force(HRP.CFrame.RightVector * -1)
				Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Right")then
				--Right
				if(Right_Dodge_Ani == Striking_Anim_Tracks['Headblock Right'])then
					--Apply_Force(HRP.CFrame.RightVector)
				end
				Apply_Force(HRP.CFrame.RightVector)
				Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Back")then
				Apply_Force(HRP.CFrame.LookVector * -1)
				Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
			end

			Debounce_Dodge = false
		end

		local function Toggle_Sheild_Icon(Is_Enabled)
			local Main_F =  Fight_UI:FindFirstChild("Main_F")
			if(Main_F ~= nil and Main_F:FindFirstChild("Shield_F") ~= nil)then
				local SF = Main_F:FindFirstChild("Shield_F")
				SF.Visible = true
				
				local Img = SF:FindFirstChild("Shield_Img")
				if(Img ~= nil)then
					if(Is_Enabled)then
						Img.Image = "rbxassetid://130871917395731"
					else
						Img.Image = "rbxassetid://125284121534949"
					end
				end
			end
		end

		local function Toggle_Heal_PE(Is_Enabled)
			local PE = HRP:GetChildren()
			for i = 1, #PE do
				if(PE[i] ~= nil and PE[i].Name == "Heal_PE" and PE[i]:IsA("ParticleEmitter"))then
					PE[i].Enabled = Is_Enabled
				end
			end

			Toggle_Sheild_Icon(Is_Enabled)
		end

		local Low_Block_Con = nil
		local function Disable_Blocking_Handle()
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed
			end

			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Block_Power_V:SetAttribute("Is_Blocking", false)
			Toggle_Heal_PE(false)

			Debounce_Blocking = false
		end

		local function Play_Blocking_Animation()
			local Anim_Track = Striking_Anim_Tracks['Main Block']
			if(Anim_Track ~= nil)then
				Anim_Track:Play()
				Anim_Track:AdjustSpeed(1)
				task.wait(Anim_Track.Length * 0.9)

				if(Anim_Track ~= nil and Debounce_Blocking == true)then
					Anim_Track:AdjustSpeed(0)
				end
			end
		end

		function Funcs.Disable_Blocking_Handle()
			-- AI is turning off Blocking
			Disable_Blocking_Handle()
		end

		function Funcs.Blocking_Handle()
			Debounce_Blocking = true
			-- AI Is Blocking

			if(Hum ~= nil)then
				Hum.WalkSpeed = 8
			end

			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			Low_Block_Con = Block_Power_V.Changed:Connect(function()
				if(Block_Power_V.Value <= 0 and Debounce_Blocking == true)then
					if(Low_Block_Con ~= nil)then
						Low_Block_Con:Disconnect()
						Low_Block_Con = nil
					end

					Disable_Blocking_Handle()
				end
			end)
			table.insert(Cons, Low_Block_Con)
			task.spawn(Play_Blocking_Animation)

			if(Block_Power_V ~= nil and Block_Power_V.Value > 0)then
				Block_Power_V:SetAttribute("Is_Blocking", true)
				Toggle_Heal_PE(true)
			end
		end

		function Funcs.Get_Hitbox_Res()
			return (Get_Player_To_Hit() ~= nil)
		end		

		function Funcs.Get_Dodge_Type()
			local function Get_Ray_Distance_Data()
				local Origin = HRP.Position
				local Ray_Parm = RaycastParams.new()
				Ray_Parm.FilterType = Enum.RaycastFilterType.Exclude
				Ray_Parm.FilterDescendantsInstances = {Char, T_Char}

				local function Get_Ray_Dist(Dir)
					local Ray_Res = game.Workspace:Raycast(Origin, Dir * 10, Ray_Parm)
					if(Ray_Res ~= nil and Ray_Res.Distance ~= nil)then
						return Ray_Res.Distance
					end
					return 15
				end

				return {
					{
						['Type'] = "Dodge Back",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.LookVector * -1)
					},

					{
						['Type'] = "Dodge Left",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector * -1)
					},

					{
						['Type'] = "Dodge Right",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector)
					},

				}
			end
			local Ray_Dist_Arr = Get_Ray_Distance_Data()

			table.sort(Ray_Dist_Arr, function(A, B)
				return A['Distance'] > B['Distance']
			end)

			return Ray_Dist_Arr[1]['Type']
		end

		function Funcs.Is_Player_Striking_You()
			if(T_Strike_Power_V ~= nil and T_Strike_Power_V.Value < 4)then
				return true
			end
			return false
		end

		return Funcs
	end
	local Core_Strike_Funcs = Get_Core_Strike_Handles()

	--[[
		Core AI Decision Making goes here
		
		* If within Striking Distance ~ 5 Studs
			* If Player is Striking too, Dodge Left Right or Back (Max 2 Dodges)
			* Has to Strike (Max 3 Strikes)
				* Dodge Back if Strike (or left or Right)
		* Default to Blocking Handle
	]]--

	local function Submission_Handle(Is_Submitting, Attacking_Char)
		Animation_Mod.Reset_Character_Animations(Char)
		if(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end

		if(Is_Submitting)then
			Is_Submission = true
			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end

			if(HRP ~= nil)then
				--HRP.Anchored = true
				--HRP.CFrame *= CFrame.new(Vector3.new(0, 0.15, 0))
			end

			--> Play Animation
			--> Get Submission Character & Player
			--> Get their Takedown and Submission Data

			--> If Attacking Player, Set HRP CFrame Position
			--> Play Take Down Animation

			--> Play Submission Animation
			--> Play Submission Loop Animation

			local function Get_Takedown_Submission_Tracks()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)
				return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Receiving ID'], Submission_Data['Receiving ID'], Submission_Data['Receiving Loop ID'])
			end
			local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()

			Takedown_Track.Priority = Enum.AnimationPriority.Action2
			Animation_Mod.Play_Animation_Track(Takedown_Track, true)

			task.wait(0.25)

			Submission_Track.Priority = Enum.AnimationPriority.Action3
			Animation_Mod.Play_Animation_Track(Submission_Track)

			Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
		else
			Is_Hit = false

			if(HRP ~= nil)then
				HRP.Anchored = false
			end

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
			Is_Submission = false
		end
	end

	table.insert(Cons, AI_Training_Submission.Event:Connect(function(AI_Char, Attacking_Char, Is_Submitting)
		if(AI_Char == Char)then
			Submission_Handle(Is_Submitting, Attacking_Char)
		end
	end))


	local function Clinch_Handle(Animation_Sequence_Data, Is_Attacking)
		local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(Char)

			if(Debounce_Blocking == true)then
				task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
			end

			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
		end
		Freeze_Character()

		local function Play_Strike_Sequences()
			local Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
			Animation_Mod.Play_Animation_Track(Clinch_Tracks_Data['Init_Clinch'], true)
			task.spawn(Animation_Mod.Play_Animation_Track, Clinch_Tracks_Data['Loop_Clinch'])
			task.wait(1)

			for i = 1, #Animation_Sequence_Data do
				local Strike_Key = Animation_Sequence_Data[i]
				local Strike_Track = Clinch_Tracks_Data[Strike_Key]

				if(Strike_Track ~= nil)then
					--Play Flash, Play Hit Sound Effect, Quick Camera Shake
					Animation_Mod.Play_Animation_Track(Strike_Track)
					--wait(0.5)
				end
			end

		end
		Play_Strike_Sequences()

		local function Clinch_Reset_Handle()
			Animation_Mod.Reset_Character_Animations(Char)
			Is_Hit = false

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
		end	
		Clinch_Reset_Handle()
	end

	table.insert(Cons, AI_Training_Cage_Clinch.Event:Connect(function(AI_Char, Sequence_Keys, Is_Attacking)
		if(AI_Char == Char)then
			Clinch_Handle(Sequence_Keys, Is_Attacking)
		end
	end))


	local Strike_Count, Dodge_Count = 0, 0
	local function Main_AI_Logic_Gate()
		if(Health_V.Value > 0 and Is_Hit == false and T_Health_V ~= nil and T_Health_V.Value > 0)then
			if(Core_Strike_Funcs.Get_Hitbox_Res())then -- Within Strike Zone
				local Is_Player_Hitting_You = Core_Strike_Funcs.Is_Player_Striking_You()
				if(Is_Player_Hitting_You)then
					--Take the HIts until you're below 20 Block Power
					-- Dodge? or Strike
					if(Block_Power_V.Value > 10)then
						if(Dodge_Count < 2 or Strike_Count >= 3)then
							--Dodge
							if(Debounce_Dodge == false and Stam_V.Value >= 5)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								local Dodge_Type = Core_Strike_Funcs.Get_Dodge_Type()
								Core_Strike_Funcs.Dodge_Handle(Dodge_Type)

								Dodge_Count += 1
								if(Strike_Count >= 3)then
									Strike_Count = 0
								end
							end

						else
							--Strike
							if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								Core_Strike_Funcs.Strike_Handle()
								Strike_Count += 1
								if(Dodge_Count >= 2)then
									Dodge_Count = 0
								end
							end
						end
					elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
						--Not within Strike Zone, resort to Blocking
						Core_Strike_Funcs.Blocking_Handle()
					end
				else
					--Strike
					if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
						if(Debounce_Blocking == true)then
							task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
						end

						Core_Strike_Funcs.Strike_Handle()
						Strike_Count += 1
						if(Dodge_Count >= 2)then
							Dodge_Count = 0
						end
					end
				end
			elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
				--Not within Strike Zone, resort to Blocking
				Core_Strike_Funcs.Blocking_Handle()
			end

		elseif(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end
	end

	while Is_Active do
		if(Is_Submission == false)then
			Main_AI_Logic_Gate()
		end
		task.wait(0.5)
	end
end

Init_E.Event:Connect(function(T_Plr, T_Char,OtherStuff)	
	if(Is_Active == false and T_Plr ~= nil and T_Char ~= nil)then
		Core_AI_Handle(T_Plr, T_Char)
	elseif(Is_Active)then
		Reset_AI()
	end
end)]]></ProtectedString>
									<string name="ScriptGuid">{B879C7B2-03BF-404D-96A3-5A52712328C7}</string>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">AI_Training_Bot_Handle.server.lua</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX8C74854D70D54DEB95A72F7BE3BC2BB6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Standard</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXAF8D748CB0E04C34A0264081A1491F5F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Training_Bot</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX6E290E8AB183456F92E617708E8BBBBD">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
								<string name="ScriptGuid">{D2B7EF01-5EFA-49B4-9C3E-C5784A4A120A}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animate.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX4BED16CC39294D749127550228248B4D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Female_Bot</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX7AE392BFB46A45F6806E4C9EFC531B6C">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
								<string name="ScriptGuid">{D673115B-4F66-47A2-9F49-CF9382F27F9B}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animate.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXAC21AED22256486ABDA619D61F3551D4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Coach_Bot</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX40DD8CFC2BD548ECBB17CD6349AF597A">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = task.wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
								<string name="ScriptGuid">{FD2E5CB8-DE4B-456A-A1A8-54B86983A08B}</string>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animate.client.lua</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX392C61751F3C427E8B2664A9E144FE38">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Archives</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX209FF651C1824B359722E269F0E7A108">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Male_StarterCharacter_old</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX4770B75780AD4FEAAEF60F0EBD2D07AB">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<ProtectedString name="Source"><![CDATA[-- Modernized Animate.lua (R15) – 100% backward-compatible version
-- Changes:
--   - Replaced Humanoid:LoadAnimation() → Animator:LoadAnimation()
--   - Ensured Animator exists
--   - Added safe loop exit on death
--   - Converted all globals to locals
--   - Used :Disconnect() instead of :disconnect()
--   - Guarded LocalPlayer usage

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop")
end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun")
end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2
local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil
local PreloadedAnims = {}
local animTable = {}

local animNames = {
	idle = {
		{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
		{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
		{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 },
	},
	walk = {
		{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 },
	},
	run = {
		{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 },
	},
	swim = {
		{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 },
	},
	swimidle = {
		{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 },
	},
	jump = {
		{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 },
	},
	fall = {
		{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 },
	},
	climb = {
		{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 },
	},
	sit = {
		{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 },
	},
	toolnone = {
		{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 },
	},
	toolslash = {
		{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 },
	},
	toollunge = {
		{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 },
	},
	wave = {
		{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 },
	},
	point = {
		{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 },
	},
	dance = {
		{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 },
	},
	dance2 = {
		{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 },
	},
	dance3 = {
		{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 },
		{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 },
	},
	laugh = {
		{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 },
	},
	cheer = {
		{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 },
	},
}

local emoteNames = {
	wave = false,
	point = false,
	dance = true,
	dance2 = true,
	dance3 = true,
	laugh = false,
	cheer = false,
}

math.randomseed(tick())

-- Ensure animator exists
local animator = Humanoid:FindFirstChildOfClass("Animator")
if not animator then
	animator = Instance.new("Animator")
	animator.Parent = Humanoid
end

local function findExistingAnimationInSet(set, anim)
	if not set or not anim then return 0 end
	for idx = 1, set.count, 1 do
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	return 0
end

local function configureAnimationSet(name, fileList)
	if animTable[name] then
		for _, connection in pairs(animTable[name].connections) do
			connection:Disconnect()
		end
	end
	animTable[name] = { count = 0, totalWeight = 0, connections = {} }

	local allowCustomAnimations = true
	pcall(function()
		allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations
	end)

	local config = script:FindFirstChild(name)
	if allowCustomAnimations and config then
		table.insert(animTable[name].connections, config.ChildAdded:Connect(function() configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:Connect(function() configureAnimationSet(name, fileList) end))
		for _, childPart in pairs(config:GetChildren()) do
			if childPart:IsA("Animation") then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if weightObject then newWeight = weightObject.Value end
				animTable[name].count += 1
				local idx = animTable[name].count
				animTable[name][idx] = { anim = childPart, weight = newWeight }
				animTable[name].totalWeight += newWeight
				table.insert(animTable[name].connections, childPart.Changed:Connect(function() configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:Connect(function() configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:Connect(function() configureAnimationSet(name, fileList) end))
			end
		end
	end

	if animTable[name].count <= 0 then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {
				anim = Instance.new("Animation"),
				weight = anim.weight,
			}
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name].count += 1
			animTable[name].totalWeight += anim.weight
		end
	end

	for _, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			local id = animType[idx].anim.AnimationId
			if not PreloadedAnims[id] then
				animator:LoadAnimation(animType[idx].anim)
				PreloadedAnims[id] = true
			end
		end
	end
end

local function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if fileList then configureAnimationSet(child.Name, fileList) end
end

script.ChildAdded:Connect(scriptChildModified)
script.ChildRemoved:Connect(scriptChildModified)

for name, fileList in pairs(animNames) do
	configureAnimationSet(name, fileList)
end

local toolAnim, toolAnimTime = "None", 0
local jumpAnimTime, jumpAnimDuration = 0, 0.31
local toolTransitionTime, fallTransitionTime = 0.1, 0.2
local currentlyPlayingEmote = false

local function stopAllAnimations()
	local oldAnim = currentAnim
	if emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false then oldAnim = "idle" end
	if currentlyPlayingEmote then oldAnim = "idle" currentlyPlayingEmote = false end
	currentAnim = ""
	if currentAnimKeyframeHandler then currentAnimKeyframeHandler:Disconnect() end
	if currentAnimTrack then currentAnimTrack:Stop() currentAnimTrack:Destroy() currentAnimTrack = nil end
	if runAnimKeyframeHandler then runAnimKeyframeHandler:Disconnect() end
	if runAnimTrack then runAnimTrack:Stop() runAnimTrack:Destroy() runAnimTrack = nil end
	return oldAnim
end

-- [All the remaining functions and event handlers stay identical, only updated for local scope and Animator use]

local function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			return getRigScale()
		end
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if not AnimationSpeedDampeningObject then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) *
				AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	return speedScaled / heightScale
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5
	local normalizedRunSpeed = 1
	local runSpeed = rootMotionCompensation(speed)
	local walkAnimationWeight, runAnimationWeight, timeWarp =
		smallButNotZero, smallButNotZero, 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight, timeWarp = 1, runSpeed / normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fade = (runSpeed - normalizedWalkSpeed) /
			(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight, runAnimationWeight = 1 - fade, fade
	else
		timeWarp, runAnimationWeight = runSpeed / normalizedRunSpeed, 1
	end

	if currentAnimTrack then
		currentAnimTrack:AdjustWeight(walkAnimationWeight)
		currentAnimTrack:AdjustSpeed(timeWarp)
	end
	if runAnimTrack then
		runAnimTrack:AdjustWeight(runAnimationWeight)
		runAnimTrack:AdjustSpeed(timeWarp)
	end
end

local function setAnimationSpeed(speed)
	if currentAnim == "walk" then
		setRunSpeed(speed)
	elseif currentAnimTrack and speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(speed)
	end
end

local function keyFrameReachedFunc(frameName)
	if frameName ~= "End" then return end
	if currentAnim == "walk" then
		if userNoUpdateOnLoop then
			if runAnimTrack and not runAnimTrack.Looped then runAnimTrack.TimePosition = 0 end
			if currentAnimTrack and not currentAnimTrack.Looped then currentAnimTrack.TimePosition = 0 end
		else
			if runAnimTrack then runAnimTrack.TimePosition = 0 end
			if currentAnimTrack then currentAnimTrack.TimePosition = 0 end
		end
	else
		local repeatAnim = currentAnim
		if emoteNames[repeatAnim] == false then repeatAnim = "idle" end
		if currentlyPlayingEmote then
			if currentAnimTrack and currentAnimTrack.Looped then return end
			repeatAnim = "idle"
			currentlyPlayingEmote = false
		end
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.15, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

local function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight)
	local idx = 1
	while roll > animTable[animName][idx].weight do
		roll -= animTable[animName][idx].weight
		idx += 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	if anim == currentAnimInstance then return end
	if currentAnimTrack then currentAnimTrack:Stop(transitionTime) currentAnimTrack:Destroy() end
	if runAnimTrack then runAnimTrack:Stop(transitionTime) runAnimTrack:Destroy() end
	currentAnimSpeed = 1

	currentAnimTrack = animator:LoadAnimation(anim)
	currentAnimTrack.Priority = Enum.AnimationPriority.Core
	currentAnimTrack:Play(transitionTime)
	currentAnim, currentAnimInstance = animName, anim

	if currentAnimKeyframeHandler then currentAnimKeyframeHandler:Disconnect() end
	currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:Connect(keyFrameReachedFunc)

	if animName == "walk" then
		local runIdx = rollAnimation("run")
		runAnimTrack = animator:LoadAnimation(animTable["run"][runIdx].anim)
		runAnimTrack.Priority = Enum.AnimationPriority.Core
		runAnimTrack:Play(transitionTime)
		if runAnimKeyframeHandler then runAnimKeyframeHandler:Disconnect() end
		runAnimKeyframeHandler = runAnimTrack.KeyframeReached:Connect(keyFrameReachedFunc)
	end
end

function playAnimation(animName, transitionTime, humanoid)
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim
	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

local function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-- Tool animation management
local toolAnimName, toolAnimTrack, toolAnimInstance, currentToolAnimKeyframeHandler = "", nil, nil, nil
local function toolKeyFrameReachedFunc(frameName)
	if frameName == "End" then playToolAnimation(toolAnimName, 0.0, Humanoid) end
end

function playToolAnimation(animName, transitionTime, humanoid, priority)
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim
	if anim == toolAnimInstance then return end

	if toolAnimTrack then toolAnimTrack:Stop() toolAnimTrack:Destroy() transitionTime = 0 end
	toolAnimTrack = animator:LoadAnimation(anim)
	if priority then toolAnimTrack.Priority = priority end
	toolAnimTrack:Play(transitionTime)
	toolAnimName, toolAnimInstance = animName, anim
	if currentToolAnimKeyframeHandler then currentToolAnimKeyframeHandler:Disconnect() end
	currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:Connect(toolKeyFrameReachedFunc)
end

local function stopToolAnimations()
	if currentToolAnimKeyframeHandler then currentToolAnimKeyframeHandler:Disconnect() end
	if toolAnimTrack then toolAnimTrack:Stop() toolAnimTrack:Destroy() end
	toolAnimName, toolAnimInstance, toolAnimTrack = "", nil, nil
end

-- State change handlers
local function onRunning(speed)
	local heightScale = userAnimateScaleRun and getHeightScale() or 1
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0,0,0)
	local threshold = movedDuringEmote and (Humanoid.WalkSpeed/heightScale) or 0.75
	if speed > threshold * heightScale then
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / 16.0)
		pose = "Running"
	elseif emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
		playAnimation("idle", 0.2, Humanoid)
		pose = "Standing"
	end
end

local function onDied() pose = "Dead" end
local function onJumping() playAnimation("jump", 0.1, Humanoid); jumpAnimTime = jumpAnimDuration; pose="Jumping" end
local function onClimbing(speed)
	if userAnimateScaleRun then speed /= getHeightScale() end
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 5)
	pose="Climbing"
end
local function onFreeFall()
	if jumpAnimTime <= 0 then playAnimation("fall", 0.2, Humanoid) end
	pose="FreeFall"
end
local function onSeated() pose="Seated" end
local function onSwimming(speed)
	if userAnimateScaleRun then speed /= getHeightScale() end
	if speed > 1 then playAnimation("swim", 0.4, Humanoid); setAnimationSpeed(speed/10); pose="Swimming"
	else playAnimation("swimidle", 0.4, Humanoid); pose="Standing" end
end

Humanoid.Died:Connect(onDied)
Humanoid.Running:Connect(onRunning)
Humanoid.Jumping:Connect(onJumping)
Humanoid.Climbing:Connect(onClimbing)
Humanoid.FreeFalling:Connect(onFreeFall)
Humanoid.Seated:Connect(onSeated)
Humanoid.Swimming:Connect(onSwimming)

-- Safe chat emote trigger
local player = game:GetService("Players").LocalPlayer
if player then
	player.Chatted:Connect(function(msg)
		local emote = ""
		if msg:sub(1,3)=="/e " then emote=msg:sub(4)
		elseif msg:sub(1,7)=="/emote " then emote=msg:sub(8) end
		if pose=="Standing" and emoteNames[emote]~=nil then
			playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		end
	end)
end

-- Emote bindable
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	if pose ~= "Standing" then return end
	if emoteNames[emote] ~= nil then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		return true, currentAnimTrack
	elseif typeof(emote)=="Instance" and emote:IsA("Animation") then
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)
		return true, currentAnimTrack
	end
	return false
end

-- Initial idle
if Character.Parent then playAnimation("idle", 0.1, Humanoid); pose="Standing" end

-- Animation loop with safe termination
local alive = true
Humanoid.Died:Connect(function() alive = false end)

local lastTick = 0
while Character.Parent and alive do
	local _, currentGameTime = task.wait(0.1)
	local deltaTime = currentGameTime - lastTick
	lastTick = currentGameTime
	if jumpAnimTime > 0 then jumpAnimTime -= deltaTime end
	if pose=="FreeFall" and jumpAnimTime<=0 then playAnimation("fall",0.2,Humanoid)
	elseif pose=="Seated" then playAnimation("sit",0.5,Humanoid)
	elseif pose=="Running" then playAnimation("walk",0.2,Humanoid)
	elseif pose=="Dead" then stopAllAnimations() end
end
]]></ProtectedString>
							<string name="ScriptGuid">{78FE784D-21DD-48FD-B3AC-6A3F8B1DF3B7}</string>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Animate.client.lua</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>