<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXE8E41460E1BE4295B832F1BA600DF02F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">_ScriptExport</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBXD3184CA13BBC4130BCA3561CC2010E4D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Workspace</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX2A3681CDF9434BE5AB8888C1524BF17D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Animation_Testing_Handle.server.lua</string>
					<string name="ScriptGuid">{F2A4FE9B-9754-413B-A89C-DDFC3E57BD90}</string>
					<ProtectedString name="Source"><![CDATA[local Receiving_Char_Hum = game.Workspace.Receiving_Plr.Humanoid
local Takedown_Char_Hum = game.Workspace.Takedown_Plr.Humanoid

local function Reset_Animation(Hum)
	local Anim_Tracks = Hum:GetPlayingAnimationTracks()
	for i = 1, #Anim_Tracks do
		local Ani_T = Anim_Tracks[i]
		if(Ani_T ~= nil and Ani_T.IsPlaying == true)then
			Ani_T:Stop()
		end
	end
end

local function Play_Animation(Hum, ID)
	Reset_Animation(Hum)
	
	local function Create_Ani_Obj()
		local Key = ID .. "_Ani"
		local Ani_O = Hum:FindFirstChild(Key)
		if(Ani_O == nil)then
			Ani_O = Instance.new("Animation", Hum)
			Ani_O.Name = Key
			Ani_O.AnimationId = "rbxassetid://" .. ID
		end
		
		return Ani_O
	end
	local Ani_Obj = Create_Ani_Obj()
	local Track = Hum:LoadAnimation(Ani_Obj)
	Track.Looped = true
	Track.Priority = Enum.AnimationPriority.Action
	
	task.spawn(function()
		Track:Play()
		task.wait(Track.Length - 0.001)
		Track:AdjustSpeed(0)
	end)
end

local function Get_CF_Offset()
	local Receiving_Char_Hum = game.Workspace.Receiving_Plr.Humanoid
	local Takedown_Char_Hum = game.Workspace.Takedown_Plr.Humanoid
	local R_CF = Receiving_Char_Hum.Parent.HumanoidRootPart.CFrame
	local T_CF = Takedown_Char_Hum.Parent.HumanoidRootPart.CFrame
	
	local Offset_CF = R_CF:ToObjectSpace(T_CF)
	local X,Y,Z = Offset_CF:ToEulerAnglesXYZ()
end
Get_CF_Offset()

function Testing_Handle()
	Play_Animation(Takedown_Char_Hum, 131555693143885)
	Play_Animation(Receiving_Char_Hum, 114826200035426)
end
Testing_Handle()

local CF_Offset = CFrame.new(Vector3.new(0, 0, -3.90583)) * CFrame.Angles(-3.14, 0, -3.14)
local R_HRP = game.Workspace.Receiving_Plr.HumanoidRootPart
local T_HRP = game.Workspace.Takedown_Plr.HumanoidRootPart

local function get_Cam_Offset()
	local R_HRP = game.Workspace.Receiving_Plr.HumanoidRootPart
	local Cam = game.Workspace.Camera
	
	local Offset = R_HRP.CFrame:ToObjectSpace(Cam.CFrame)
	local X, Y, Z = Offset:ToEulerAnglesXYZ()
end
get_Cam_Offset()

local function Get_CF_Pos_Offset()
	local R_HRP = game.Workspace.Receiving_Plr.HumanoidRootPart
	local T_HRP = game.Workspace.Takedown_Plr.HumanoidRootPart
	local Offset = R_HRP.CFrame:ToObjectSpace(T_HRP.CFrame)
	local X, Y, Z = Offset:ToEulerAnglesXYZ()
	local X_Deg, Y_Deg, Z_Deg = math.deg(X), math.deg(Y), math.deg(Z)
end
Get_CF_Pos_Offset()]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXD6987EFB2BBA4988B52315390C5CBB81">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Takedown_Plr</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXC39E0616557A41328E713FA8075CA919">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Animate.client.lua</string>
						<string name="ScriptGuid">{F8EA5497-CFCC-4903-A08D-26D113710330}</string>
						<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXF8E03FAE81614A9398CD36DDE9C4E7D7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Receiving_Plr</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXFCA8439A13254A92A446DEC6B2671E46">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Animate.client.lua</string>
						<string name="ScriptGuid">{6EC8864F-8955-4281-B517-B347976926D9}</string>
						<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX65029C4D3B354625A8549B508F0F4150">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main_World_F</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXD6E71F99709643CE83D46815BCE324D4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Map</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX1986A1FBF07A4CD7A1BE7E5FC7303A9F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Art</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXE8E7075F900942CFA26E9C620D8EB0D0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Scary Guy</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXD017CC5374B3476E9CA6FDA2EE6A26BA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Animate.client.lua</string>
									<string name="ScriptGuid">{BC6BBE0D-BCEE-4107-A1F6-DA2D0E2483D5}</string>
									<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX7D58D48DF3804CA7B5177849E6320010">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Clothes_F</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXF8F131FF86BB42C2A85B78BF99262ADD">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Format_Clothing_Handle.server.lua</string>
						<string name="ScriptGuid">{FEAD5496-6160-4629-8A03-0E94D53BB402}</string>
						<ProtectedString name="Source"><![CDATA[local Clothes_F = game.Workspace.Clothes_F
local Shorts_F = Clothes_F.Shorts
local Gloves_F = Clothes_F.Gloves

--Configure Each part to be Massless, Anchored False, CanCollide False, CanTouch False
--Name each Part based on their Weld Part 1 BodyPart
--Get the CF Offset of their BodyPart right now, set as Attribute
--Delete the Weld Object

local function Format_Models(M)
	local function Configure_Parts(Main_M)
		local function Set_Up_Part(P)
			local W = P:FindFirstChildWhichIsA("ManualWeld")
			local Main_BP = W.Part1
			local Spawn_CF = Main_BP.CFrame:ToObjectSpace(P.CFrame)
			
			P.Name = Main_BP.Name
			P.Anchored = false
			P.CanCollide = false
			P.Massless = true
			P.CanTouch = false
			P:SetAttribute("Spawn_Offset_CF", Spawn_CF)
			W:Destroy()
		end
		
		local All_P = Main_M:GetChildren()
		for i = 1, #All_P do
			Set_Up_Part(All_P[i])
		end
	end
	
	local function New_Config(Char_M)
		local Clothing_M = Instance.new("Model", game.Workspace.Clothes_F.New_Clothes)
		Clothing_M.Name = "New"
		
		local function Move_Main_Part(W)
			local Main_P = W.Parent
			local Main_BP = W.Part1
			local Spawn_CF = Main_BP.CFrame:ToObjectSpace(Main_P.CFrame)

			Main_P.Name = Main_BP.Name
			Main_P.Anchored = false
			Main_P.CanCollide = false
			Main_P.Massless = true
			Main_P.CanTouch = false
			Main_P:SetAttribute("Spawn_Offset_CF", Spawn_CF)
			W:Destroy()
			
			Main_P.Parent = Clothing_M
		end
		
		local All_D = Char_M:GetDescendants()
		for i = 1, #All_D do
			local P = All_D[i]
			if(P ~= nil and P:IsA("ManualWeld") and P.Parent ~= nil)then
				Move_Main_Part(P)
			end
		end
		
		Char_M:Destroy()	
	end
	
	for i = 1, #M do
		--Configure_Parts(M[i])
		New_Config(M[i])
	end
end
--Format_Models(Shorts_F:GetChildren())
Format_Models(Gloves_F:GetChildren())

local function Set_Prim_Part(M)
	for i = 1, #M do
		M[i].PrimaryPart = M[i]:FindFirstChild("LowerTorso")
	end
end
Set_Prim_Part(game.Workspace.Clothes_F.New_Clothes:GetChildren())

local function Clear_Models_For_Gloves(M)
	local function Parse_Glove(GM)
		local All_C = GM:GetChildren()
		for i = 1, #All_C do
			if(string.match(All_C[i].Name, "Hand") == nil)then
				All_C[i]:Destroy()
			end
		end
	end
	
	for i = 1, #M do
		Parse_Glove(M[i])
	end
end
Clear_Models_For_Gloves(game.Workspace.Clothes_F.New_Clothes:GetChildren())

local CF_Offset_Data = {
	['LeftHand'] = CFrame.new(Vector3.new(-0.2106170654296875, -0.21133995056152344, -0.040771484375)) * CFrame.Angles(0, 0, 0),
	['RightHand'] = CFrame.new(Vector3.new(0.2071075439453125, -0.21133995056152344, -0.040771484375)) * CFrame.Angles(0, 0, 0)
}

local function Fix_Country_Gloves()
	local function Configure_Glove_Part(G_Part)
		local Hand_P = G_Part.Parent
		local W = G_Part:FindFirstChildWhichIsA("WeldConstraint")
		W.Enabled = false
		G_Part.CFrame = Hand_P.CFrame:ToWorldSpace(CF_Offset_Data[Hand_P.Name])
		W.Enabled = true
	end
	
	local All_Glove_Parts = game.ReplicatedStorage.Clothing_F.Gloves_F:GetDescendants()
	for i = 1, #All_Glove_Parts do
		local GP = All_Glove_Parts[i]
		if(GP ~= nil and GP.Name == "Flag_P" and GP.Parent ~= nil and
			GP:FindFirstChildWhichIsA("WeldConstraint") ~= nil)then
			
			Configure_Glove_Part(GP)
		end
	end
end
Fix_Country_Gloves()

local function Fix_Glove_Handle(GM)
	local All_C = GM:GetChildren()
	local Left_Hand_P = {}
	local Right_Hand_P = {}
	
	for i = 1, #All_C do
		if(All_C[i].Name == "LeftHand")then
			table.insert(Left_Hand_P, All_C[i])
		else
			table.insert(Right_Hand_P, All_C[i])
		end
	end
	
	table.sort(Left_Hand_P, function(A, B)
		return A.Size.Magnitude > B.Size.Magnitude
	end)
	
	table.sort(Right_Hand_P, function(A, B)
		return A.Size.Magnitude > B.Size.Magnitude
	end)
	
	local function Configure_Hand_Parts(Main_Glove, Country_P)
		local Dif_V = Vector3.new(0.753, 1.094, 0.787) / Main_Glove.Size
		local Country_CF_Offset = Main_Glove.CFrame:ToObjectSpace(Country_P.CFrame)
		Country_P.Name = "Flag_P"
		Main_Glove.Size = Vector3.new(0.753, 1.094, 0.787) 
		Country_P.Size = Country_P.Size * Dif_V
		Country_P.CFrame = Main_Glove.CFrame:ToWorldSpace(Country_CF_Offset)
		Country_P.Parent = Main_Glove
		
		local W = Instance.new("WeldConstraint", Country_P)
		W.Part0 = Country_P
		W.Part1 = Main_Glove
		W.Enabled = true
		
		if(Main_Glove.Name == "LeftHand")then
			Main_Glove.Name = "RightHand"
		else
			Main_Glove.Name = "LeftHand"
		end
	end
	Configure_Hand_Parts(Left_Hand_P[1], Left_Hand_P[2])
	Configure_Hand_Parts(Right_Hand_P[1], Right_Hand_P[2])
end

local N = {
	"Italian Gloves",
	"Jamacian Gloves",
	"Japanese Gloves",
	"Mexican Gloves",
	"Moldovan Gloves",
	"New Zealand Gloves",
	"Nigerian Gloves",
	"Polish Gloves",
	"Russian Gloves",
	"Spanish Gloves",
	"USA Gloves"
}

for i = 1, #N do
	local GM = game.ReplicatedStorage.Clothing_F.Gloves_F:FindFirstChild(N[i])
	Fix_Glove_Handle(GM)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXF34A31ACB4BA4DBA9F5415A92823830D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">StarterCharacter</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXF09FCF89841B487788B7B3E8CA9A114C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Animate.client.lua</string>
						<string name="ScriptGuid">{8CE56453-A7E9-4C5C-BF5D-06DBE8FB127F}</string>
						<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCF123BC58E57435E87361CAA08611DBB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Animate.client.lua (2)</string>
						<string name="ScriptGuid">{839D058D-2C95-49DF-B02B-C61A6FD028B5}</string>
						<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX318F3EA58A984893A801AF10DA878BE0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">HoltSvardo_Dif</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX18B69DA43F7B4B2396D6178DCB436451">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Cage_Camera_Handle.client.lua</string>
						<string name="ScriptGuid">{07938DC0-D12D-44F1-A37C-9CE85B0C12B5}</string>
						<ProtectedString name="Source"><![CDATA[local RS = game:GetService("RunService")
local Plr = game.Players.LocalPlayer
local Char =  Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Fight_Cages_F = game.Workspace:WaitForChild("Fight_Cages_F")
local Cam = game.Workspace.CurrentCamera

local Part_Names = {"CageFence", "CornerTrim", "PaddingCorner", "PaddingFenceDoor", "FenceDoor", 
	"PaddingFence", "FenceFrame"}
local Selected_M = nil

local function Get_Whitelist()
	local Cages_M = {}
	local All_Fight_Cages = Fight_Cages_F:GetChildren()
	for i = 1, #All_Fight_Cages do
		local FCM = All_Fight_Cages[i]
		if(FCM ~= nil and FCM:FindFirstChild("MMA_Cage") ~= nil)then
			table.insert(Cages_M, FCM:FindFirstChild("MMA_Cage"))
		end
	end
	
	return Cages_M
end

local function Get_Cage_M()
	local Dist = (Cam.CFrame.Position - HRP.Position).Magnitude
	local Dir = Cam.CFrame.LookVector
	local Raycast_Parm = RaycastParams.new()
	Raycast_Parm.FilterDescendantsInstances = Get_Whitelist()
	Raycast_Parm.FilterType = Enum.RaycastFilterType.Include

	local Ray_Res = game.Workspace:Raycast(Cam.CFrame.Position, Dir * Dist, Raycast_Parm)
	if(Ray_Res ~= nil and Ray_Res.Instance ~= nil and 
		Ray_Res.Instance:FindFirstAncestorWhichIsA("Model") ~= nil)then
		
		return Ray_Res.Instance:FindFirstAncestorWhichIsA("Model")
	end
	
	return nil
end

local function Toggle_Cage_Parts(M, Is_Visible)
	for i = 1, #Part_Names do
		local PN = Part_Names[i]
		local P = M:FindFirstChild(PN)
		if(P ~= nil)then
			if(Is_Visible)then
				if(PN == "CageFence")then
					P.Transparency = 0.6
				else
					P.Transparency = 0
				end
			else
				P.Transparency = 0.75
			end
		end
	end
end

RS:BindToRenderStep("CAGE_GAMERA", Enum.RenderPriority.Camera - 1, function()
	local Is_Fighting = Char:GetAttribute("Is_Fighting") or false
	if(Is_Fighting)then
		local Cage_M = Get_Cage_M()
		if(Cage_M ~= nil and Cage_M ~= Selected_M)then
			if(Selected_M ~= nil)then
				Toggle_Cage_Parts(Selected_M, true)
			end

			Toggle_Cage_Parts(Cage_M, false)
			Selected_M = Cage_M

		elseif(Cage_M == nil and Selected_M ~= nil)then
			Toggle_Cage_Parts(Selected_M, true)
			Selected_M = nil
		end
	elseif(Selected_M ~= nil)then
		Toggle_Cage_Parts(Selected_M, true)
		Selected_M = nil
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB2BDF36F61DE4505ADBDFE10F4859336">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Ranked_Arena_Effects_Handle.client.lua</string>
						<string name="ScriptGuid">{285337D8-0C5E-4257-A3F2-987EE4934F59}</string>
						<ProtectedString name="Source"><![CDATA[--Once a Players Character passes this Z Value
	--turn it on until the Player Leaves
	
	--When inside, Play the Crowd Ambient Sound Effect
	--Play the Lighting Spark Effects over all the Seats
	
local Debris = game:GetService("Debris")
local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Crowd_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Crowd_SE")
local Flash_PE = script:WaitForChild("Flash_PE")

local Is_Within_Arena_Region = false
local Pos_Min = 120

local function Effects_Handle()
	if(Crowd_SE ~= nil)then
		Crowd_SE:Play()
	end
	
	local function Flash_Camera_From_Seats()
		--10% of Seating
		--Pick Random Seats, Create Flash Parts, Debris, Emit Flash Particle on them
		local function Get_Arena_Seating()
			local World_F = game.Workspace:FindFirstChild("Main_World_F")
			if(World_F ~= nil and World_F:FindFirstChild("Map") ~= nil)then
				local Map_F = World_F:FindFirstChild("Map")
				local Seating_F = Map_F:FindFirstChild("Arena_Seating_F")
				if(Seating_F ~= nil)then
					return Seating_F:GetChildren()
				end
			end
			return {}
		end
		local Seats_Arr = Get_Arena_Seating()
		local Amount = 100 -- Can Change
		
		if(Seats_Arr ~= nil and #Seats_Arr > Amount)then
			local function Play_Camera_Flash()
				local Seat_Index = math.random(1, #Seats_Arr)
				local Seat_M = Seats_Arr[Seat_Index]
				if(Seat_M ~= nil and Seat_M:FindFirstChild("Chair_SeatColor") ~= nil)then
					table.remove(Seats_Arr, Seat_Index)
					
					local Main_P = Seat_M:FindFirstChild("Chair_SeatColor")
					local A = Instance.new("Attachment", Main_P)
					A.Name = "Flash_A"
					A.Visible = false
					A.CFrame = CFrame.new(0, 0.775, 0) * CFrame.Angles(0, 0, 0)
					
					local Emit_Count = math.random(2, 8)
					local PE = Flash_PE:Clone()
					PE.Parent = A
					PE:Emit(Emit_Count)
					
					Debris:AddItem(A, 0.25)
				end
			end
			
			for i = 1, Amount do
				Play_Camera_Flash()
				if(i % 2 == 0)then
					wait(0.02)
				end
			end
			
			return
		end
		
		wait(1)
	end

	warn("STARTED")
	while Is_Within_Arena_Region do
		Flash_Camera_From_Seats()
	end
	
	warn("STOPPED")
	
	--End all
	if(Crowd_SE ~= nil)then
		Crowd_SE:Stop()
	end
end

function On_Init_Check()
	local function Is_Within_Region()
		if(HRP ~= nil and HRP.Position.Z > Pos_Min)then
			return true
		end
		return false
	end
	
	while wait(1) do
		local Is_In_Region = Is_Within_Region()
		warn(Is_In_Region, Is_Within_Arena_Region)
		if(Is_In_Region and Is_Within_Arena_Region == false)then
			Is_Within_Arena_Region = true
			Effects_Handle()
			
		elseif(Is_In_Region == false and Is_Within_Arena_Region == true)then
			Is_Within_Arena_Region = false
		end
	end
end
On_Init_Check()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD39A0D21249C4280BF717F0FD84FAB2D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Animate.client.lua</string>
						<string name="ScriptGuid">{45AA010F-61FB-48D4-A64B-8666D83F3FA9}</string>
						<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX8431C08357134E8FAD3045DC05DE2D3D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Offers_Data</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX2F908F54A3CE4C7394197F679835E828">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Display_Podium_Left</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX065486A85A2E4B56B0376321FA647AC3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">OfferAttachment</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX1727A5BC017A4EDDAC3C694BAC4038AA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Display_Podium_Left.server.lua</string>
								<string name="ScriptGuid">{334E3115-814D-48C1-B125-49A4BBF0E667}</string>
								<ProtectedString name="Source"><![CDATA[
local DSS = game:GetService("DataStoreService")
local OfferStore = DSS:GetDataStore("PlayerOfferState")
local Remotes = game.ReplicatedStorage:WaitForChild("Remotes") 
local Offers  = Remotes:WaitForChild("Offers")
local UGC = Offers:WaitForChild("UGC")

local ShowOfferSignalBind = UGC:WaitForChild("ShowOfferSignalBind")
local GetCurrentClothOffer = Offers:WaitForChild("GetCurrentClothOffer")
local ClothItemIdSignal = Offers:WaitForChild("ClothItemIdSignal")

local parent = script.Parent
local GateToEnterPrompt=parent.Prompt







GateToEnterPrompt.Triggered:Connect(function(player)

	local Itype = player:GetAttribute("ClothItemData_Type")
	local IKey = player:GetAttribute("ClothItemData_Key")
	ShowOfferSignalBind:Fire(player,Itype,IKey)
	
end)




local function loadOfferState(plr)
	local key = "ClothOffer_" .. plr.UserId

	local ok, err = pcall(function()
		return OfferStore:GetAsync(key)
	end)
	if ok and err then
		return err
	else
		--print("Failed to load offer state for", plr.UserId, err)
	end
	return nil
end

local function saveOfferState(plr, offerAC)
	local key = "ClothOffer_" .. plr.UserId
	local now=os.time() 
	local ok, err = pcall(function()
		OfferStore:UpdateAsync(key, function(old)
			old = old or {}
			old.expiredItems = old.expiredItems or {}
			local prev = old.ActiveOffer

			if prev then
				local expCount = #old.expiredItems
				if expCount == 30 then
					old.expiredItems={}
				else
					table.insert(old.expiredItems, {
						Key = prev.CurrentKey,
						EndedAt = now,
						EndReason ="expired",
					})
				end
			end

			old.ActiveOffer = {
				CurrentKey =offerAC.Key.."_"..offerAC.Kind,
				offer = offerAC
			}
			return old
		end)
	end)

	if not ok then
		warn("Failed to save offer state:", err)
	end
end


GetCurrentClothOffer.OnServerInvoke=function(player)
	local PP=	loadOfferState(player)
	task.wait()
	if PP then
		return PP.ActiveOffer 
	end
	return nil
end


ClothItemIdSignal.OnServerEvent:Connect(function(plr, offer)
	
	local Itype = plr:SetAttribute("ClothItemData_Type",offer.Kind)
	local IKey = plr:SetAttribute("ClothItemData_Key",offer.Key)
	local profile = loadOfferState(plr)
	
	if profile ~= nil and profile.ActiveOffer ~= nil then
		
		if offer.Kind == profile.ActiveOffer.offer.Kind and offer.Key == profile.ActiveOffer.offer.Key then
			return
		end
	end
	saveOfferState(plr, offer)
end)
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXA3068C6CCA924A93A7953299B0180B00">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">RegionLite</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX060A6C23E57343B9A5EF4361CBE84207">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">RingAlpha</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXA266EF8FF54647848D8CDB2A634DD6FD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Rotate.server.lua</string>
									<string name="ScriptGuid">{A88AA52B-A612-4F8A-9390-E65DF8029AD4}</string>
									<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX67726CDF70E44241A72FDFC598D0E161">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Base</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX232AA67CDC4C44E9866DEFB35A482FD1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Rotate.server.lua</string>
									<string name="ScriptGuid">{A66050C3-F10A-4207-A9F7-7309F9734980}</string>
									<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXC7D00684AE574DB1810134760116B7A6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Display_Podium_Center</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX9D923ED3A8024823B3544CFABA15344D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">OfferAttachment</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX83CD70BEC6E744068C892B85DBFD72AA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Display_Podium_Center.server.lua</string>
								<string name="ScriptGuid">{7C2BE2D6-EB42-40BC-971A-E88B754921CC}</string>
								<ProtectedString name="Source"><![CDATA[local MPS = game:GetService("MarketplaceService")

local Remotes = game.ReplicatedStorage:WaitForChild("Remotes") 
local Offers  = Remotes:WaitForChild("Offers")
local UGC = Offers:FindFirstChild("UGC")
local UGCItemItemIdSignal = UGC:WaitForChild("UGCItemItemIdSignal")
local GetCurrentItemOffer = UGC:WaitForChild("GetCurrentItemOffer")

local parent = script.Parent

local GateToEnterPrompt=parent.Prompt
UGCInner = parent.Parent.Item

local TIME_IN_DAYS = 4 * 24 * 60 * 60


local DSS = game:GetService("DataStoreService")
local OfferStore = DSS:GetDataStore("PlayerOfferState")



local function loadOfferState(plr)
	local key = "offer_1_" .. plr.UserId

	local ok, err = pcall(function()
		--print("Here is the code", OfferStore:GetAsync(key))
		return OfferStore:GetAsync(key)
	end)
	if ok and err then
		--print("Here is the code 2", err,ok)
		return err
	--	plr:SetAttribute("Offer_CurrentKey", data.CurrentKey or "")
	--	plr:SetAttribute("Offer_StartAt", data.StartAt or 0)
	--	plr:SetAttribute("Offer_EndsAt", data.EndsAt or 0)
	else
	--	print("Failed to load offer state for", plr.UserId, err)
	--	-- no saved data  roll new offer
	--	local nextKey, nextData = pickBestUnownedUGC(plr)
	--	if nextKey then startOfferWindow(plr, nextKey) end
	end
	return nil
end






local function saveOfferState(plr, itemName, endTime)
	local key = "offer_1_" .. plr.UserId
	local now = os.time()

	local ok, err = pcall(function()
		OfferStore:UpdateAsync(key, function(old)
			old = old or {}
			old.expiredItems = old.expiredItems or {}
			local prev = old.ActiveOffer

			-- If there was a previous active offer, expire it when:
			-- 1) it has actually expired, OR
			-- 2) we are replacing it with a different one
			if prev then
				--local replacing = (prev.CurrentKey ~= itemName)
				--local isExpired = true
				--if replacing or isExpired then
				local expCount = #old.expiredItems
				local folderCount=#game.ReplicatedStorage.OfferItems.UGCItems:GetChildren()
				if expCount >= 70 then
					old.expiredItems={}
				else
					table.insert(old.expiredItems, {
						Key = prev.CurrentKey,
						EndedAt = now,
					EndReason ="expired",-- replacing and "replaced" or expired,
					})
				end
			end

			-- Set new active
			old.ActiveOffer = {
				CurrentKey = itemName,
				EndsAt     = endTime,
				StartedAt  = now,
			}

			return old
		end)
	end)

	if not ok then
		warn("Failed to save offer state:", err)
	end
end
--local function saveOfferState(plr,ItemName,EndTime,oldProfile)
--	local data = {
--		CurrentKey = ItemName,
--		EndsAt     = EndTime,
--	}
--	local OldItems={}
--	if (oldProfile~=nil) then
--		 OldItems=oldProfile.expiredItems 
--	end
--	table.insert(OldItems,ItemName)
--	local profile={
--		expiredItems=OldItems,
--		ActiveOffer=data
--	}
--	local ok, err = pcall(function()
--		OfferStore:SetAsync("offer_" .. plr.UserId, profile)
--	end)
--	if not ok then warn("Failed to save offer state:", err) end
--end








GateToEnterPrompt.Triggered:Connect(function(player)
	
	MPS:PromptPurchase(player, player:GetAttribute("MyUGCID"))

end)

 GetCurrentItemOffer.OnServerInvoke=function(player)
  local PP=	loadOfferState(player)
	task.wait()
	return PP
 end

--UGCItemItemIdSignal.OnServerEvent:Connect(function(plr,id,Name)
--	plr:SetAttribute("MyUGCID",id)
--	local PP=loadOfferState(plr)
--	task.wait(1)
--	if PP==nil then
--		saveOfferState(plr,Name, os.time()+FOUR_DAYS,PP)
--		return
--	end
--	if Name~=PP.ActiveOffer.CurrentKey or PP.ActiveOffer.CurrentKey==nil or PP.ActiveOffer.CurrentKey=="" then
--		saveOfferState(plr,Name, os.time()+FOUR_DAYS,PP)
--	end
--end)
UGCItemItemIdSignal.OnServerEvent:Connect(function(plr, id, name)
	if typeof(name) ~= "string" or name == "" then return end

	plr:SetAttribute("MyUGCID", id)
	local now = os.time()
	local endsAt = now + TIME_IN_DAYS
	local profile = loadOfferState(plr)

	-- First time: just save
	if profile == nil or profile.ActiveOffer == nil then
		saveOfferState(plr, name, endsAt)
		return
	end

	-- If different key OR previous has expired, update
	local currentKey = profile.ActiveOffer and profile.ActiveOffer.CurrentKey or nil
	local currentEnds = profile.ActiveOffer and profile.ActiveOffer.EndsAt or 0

	if currentKey ~= name or (type(currentEnds) == "number" and currentEnds <= now) then
		saveOfferState(plr, name, endsAt)
	end
end)

MPS.PromptPurchaseFinished:Connect(function(plr, assetId, isPurchased)
	if not isPurchased then return end
	--print("Purchased "..assetId)
	UGCItemItemIdSignal:FireClient(plr)
end)

]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX379E97D360A94C2EA54B6264F81E4B0F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">RegionLite</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX8565179734974D808802A797E786F7AE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">RingAlpha</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX99DA091D9CCC4CEABD79EB33AAE838AD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Rotate.server.lua</string>
									<string name="ScriptGuid">{D659FEB9-9096-470B-994D-6B54187FD403}</string>
									<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXE3E3277E9F8D4A0EBF94625597593C0A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Base</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX027B9FA3B68B4F0C9DC897ED9F04E047">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Rotate.server.lua</string>
									<string name="ScriptGuid">{0828A299-BAEB-46F9-AB25-1B7CC774B251}</string>
									<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXF17553D1CB534DCDB27024E29A0D8112">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Display_Podium_Right</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX465231471A8B4653A4D1182B8217F9A6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">OfferAttachment</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX693EA77F43F14BB098FFF989A435B176">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Display_Podium_Right.server.lua</string>
								<string name="ScriptGuid">{DE170CF8-62FC-4851-916C-D02D67194301}</string>
								<ProtectedString name="Source"><![CDATA[local MPS = game:GetService("MarketplaceService")
local parent = script.Parent
local GateToEnterPrompt=parent.Prompt
local cointLimit=5000  



GateToEnterPrompt.Triggered:Connect(function(player)

	local PD    = player:FindFirstChild("Player_Data")
	local coins = PD and PD:FindFirstChild("Coins")
	local id=3306908329 -- Coins ID
	if(coins.Value>=cointLimit) then
		id=3306910278 -- Gems ID
	end
	
	MPS:PromptProductPurchase(player, id)

end)]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX819ECB971DC54F05906226F35FEDBDED">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">RegionLite</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX77E42AC6C235485D9415B6462135885D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">RingAlpha</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX057664221CA646158B6040BA4EBA5102">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Rotate.server.lua</string>
									<string name="ScriptGuid">{78A6B849-C74F-427F-B673-ED3830BC2EA0}</string>
									<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXB3F6103C1BCF4B6E9E0757E2FAABF840">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Base</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX4BB6AA45B54F4570B4FFCFF6F2C2374D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Rotate.server.lua</string>
									<string name="ScriptGuid">{688086AE-37B2-4863-864F-D6CE47BB9610}</string>
									<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local part = script.Parent  -- your MeshPart (anchored is fine)

-- Cache the starting CFrame so we rotate relative to its local axes
local baseCF = part.CFrame

-- Angle driver
local angle = Instance.new("NumberValue")
angle.Value = 0

-- Update rotation each tick of the tween
angle:GetPropertyChangedSignal("Value"):Connect(function()
	-- Local Y spin: multiply on the RIGHT
	part.CFrame = baseCF * CFrame.Angles(0, math.rad(angle.Value), 0)
end)

-- One full rotation
local info = TweenInfo.new(
	7.5,                       -- seconds per revolution
	Enum.EasingStyle.Linear, -- constant speed
	Enum.EasingDirection.In,
	-1,                      -- repeat forever
	false,                   -- no reverse
	0
)

local tween = TweenService:Create(angle, info, { Value = 360 })
tween:Play()
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8B0CFC3032564925BC0F3880C6807636">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">DiscoLights.server.lua</string>
									<string name="ScriptGuid">{683D5B0B-12B4-4A49-95EB-983263931FD3}</string>
									<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local parent = script.Parent.Parent  -- parent of your MeshPart

-- Tween settings
local tweenInfo = TweenInfo.new(
	1,                      -- duration for each color change
	Enum.EasingStyle.Linear,  -- smooth change
	Enum.EasingDirection.InOut,
	0, false, 0
)

-- Function to make a random bright color
local function randomDiscoColor()
	return Color3.fromHSV(math.random(), 1, 1) -- random hue, full saturation, full brightness
end

while true do
	for _, obj in ipairs(parent:GetDescendants()) do
		if obj:IsA("MeshPart") then
			local goal = {Color = randomDiscoColor()}
			local tween = TweenService:Create(obj, tweenInfo, goal)
			tween:Play()
		end
	end
	task.wait(1) -- sync with tween duration
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX44095742E0A54A9296F67F7BE949C884">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ReplicatedFirst</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX5E0F4F0203E644BF89B35DCF5A2EE89F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LoadAssets.client.lua</string>
					<string name="ScriptGuid">{0C9D4B93-3E40-48DB-8889-9E995A8BE172}</string>
					<ProtectedString name="Source"><![CDATA[-- preload the video
game:GetService("ContentProvider"):PreloadAsync({"rbxassetid://102361135053325"})]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1BD277CA07E94E80BB655F6F72752949">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LoadingScreen.client.lua</string>
					<string name="ScriptGuid">{F4EADAD8-1097-46C6-A5EA-EBBDA096D1F1}</string>
					<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local ContentProvider = game:GetService("ContentProvider")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

--  UIs to preload
local CriticalUIs = {"Offer_UI", "Daily_Rewards_UI"}


-- UI references
local ui = script:WaitForChild("Loading_UI", 5)
if not ui then return warn("[LoadingUI] Missing Loading_UI") end
ui.Parent = player:WaitForChild("PlayerGui", 5)
ui.Enabled = true

local canvas = ui:WaitForChild("CanvasGroup")
local Logo = canvas:WaitForChild("Logo")
local ScalingLogo = Logo:WaitForChild("Frame")
ScalingLogo.Size = UDim2.new(1, 0, 0, 0)

local FightImages = {
	canvas:WaitForChild("FightImage1"),
	canvas:WaitForChild("FightImage2"),
}

-- Assets
local allImages = {
	"rbxassetid://133655844729939", -- Jon Jones
	"rbxassetid://77228773105758",  -- Khabib vs McGregor
	"rbxassetid://82383919298361",  -- Roblox fights
	"rbxassetid://127946909806988", -- Roblox kick
}

-- === Helpers ===
local function safePreload(instances, timeoutSec)
	local done, ok = false, false
	task.spawn(function()
		ok = pcall(function() ContentProvider:PreloadAsync(instances) end)
		done = true
	end)
	local t0 = time()
	while not done and time() - t0 < (timeoutSec or 3) do
		RunService.Heartbeat:Wait()
	end
	return ok or done
end

local function setImage(imgObj, assetId)
	if not imgObj then return false end
	local ok, err = pcall(function() imgObj.Image = assetId end)
	if not ok then warn("[LoadingUI] Failed to set image:", assetId, err) end
	return ok
end

-- === UI Animations ===
local function showInitialImage()
	for _,img in ipairs(FightImages) do img.Visible = false end

	math.randomseed(tick() % 1 * 1e6)
	local chosenImage = allImages[math.random(1, #allImages)]
	setImage(FightImages[1], chosenImage)

	safePreload({FightImages[1], ScalingLogo}, 2.0)

	FightImages[1].Visible = true
	TweenService:Create(ScalingLogo, TweenInfo.new(0.3), {
		Size = UDim2.new(1, 0, 0.25, 0)
	}):Play()
end

local function startCarousel()
	task.spawn(function()
		local frames = {FightImages[1], FightImages[2]}
		local idx, previous = 1, FightImages[1]

		while ui and ui.Parent do
			task.wait(3)

			local frame = frames[idx]
			frame.Position = UDim2.new(0.55, 0, 0.5, 0)
			frame.ImageTransparency = 1
			setImage(frame, allImages[math.random(1, #allImages)])

			if previous then
				TweenService:Create(previous, TweenInfo.new(0.3), {ImageTransparency = 1}):Play()
			end
			TweenService:Create(frame, TweenInfo.new(3, Enum.EasingStyle.Linear), {
				Position = UDim2.new(0.45, 0, 0.5, 0),
				ImageTransparency = 0
			}):Play()

			previous = frame
			idx = (idx % #frames) + 1
		end
	end)
end

local function exitLoading()
	task.spawn(function()
		for i = 1, 4 do
			task.wait(0.15 + math.random()*0.05)
			TweenService:Create(ScalingLogo, TweenInfo.new(0.2), {
				Size = UDim2.new(1, 0, i/4, 0)
			}):Play()
		end
		task.wait(0.6)
		TweenService:Create(canvas, TweenInfo.new(0.25), {GroupTransparency = 1}):Play()
		task.wait(0.4)
		if ui then ui:Destroy() end
	end)
end


local function preloadCriticalUIs()
	local PlayerGui = player:WaitForChild("PlayerGui")
	local toPreload = {}

	for _, name in ipairs(CriticalUIs) do
		local uiObj = PlayerGui:WaitForChild(name, 5)
		if uiObj then
			for _, d in ipairs(uiObj:GetDescendants()) do
				if d:IsA("ImageLabel") or d:IsA("ImageButton") or d:IsA("Sound") then
					table.insert(toPreload, d)
				end
			end
		end
	end

	if #toPreload > 0 then
		safePreload(toPreload, 3.0)
	end
end


-- === Main Flow ===
showInitialImage()
startCarousel()
preloadCriticalUIs()
exitLoading()]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX6ED2A03E4FE54784955E43A67D54A356">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">LoadingScreen</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX13ED48F35A6843D2BD1C95C758131363">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Loading_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXDC785B3AFFBF4AD282E83600FFD3AE22">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">CanvasGroup</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX35F76ECEC7C546828F5790A2323C89F2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">TextLabel</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX731CA5BC81924E79B5FF070C6AE3C7F7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">LocalScript.client.lua</string>
									<string name="ScriptGuid">{D793C9C1-F162-42DB-80AF-1A7B6D57216F}</string>
									<ProtectedString name="Source"><![CDATA[local textOne = script.Parent
local textTwo = textOne:WaitForChild("TextLabel")

local updateDelay = 1/5

local iterator = 1

while textOne do
	local text = `Loading{string.rep(".",iterator%4)}`
	textOne.Text = text
	textTwo.Text = text
	task.wait(updateDelay)
	iterator += 1
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX56779D8DEDAC47CA84F2A7780C8A1D85">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">StarterPlayer</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX63B583CEF42C4F0DA3866A349EB5B93E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">StarterPlayerScripts</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXA8E13A54153C4E179D5B3BBA9BF15C02">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Effects_Handle.client.lua</string>
						<string name="ScriptGuid">{3019B79F-AE73-4AFA-AE03-EB881F378439}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	* Handle Spinning all the Fight Spawn Circles
		> Determine when they enter your Client via ChildAdded and On Init
		> Loop Tween apply to the Rotational CFrame Values
]]--

local TS = game:GetService("TweenService")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Fight_Cages_F = game.Workspace:WaitForChild("Fight_Cages_F")
local Tween_Rot = TweenInfo.new(5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, math.huge, false, 0)

local function Set_Up_Fight_Model_Effects(FM)
	local function Set_Up_Rot_Effects(M)
		if(M ~= nil and M:FindFirstChild("Rot_Part") ~= nil)then
			local Rot_P = M:FindFirstChild("Rot_Part")
			TS:Create(Rot_P, Tween_Rot, {CFrame = Rot_P.CFrame * CFrame.Angles(0, math.rad(179), 0)}):Play()
		end
	end
	Set_Up_Rot_Effects(FM:FindFirstChild("Fighter_1"))
	Set_Up_Rot_Effects(FM:FindFirstChild("Fighter_2"))
end

game.Workspace.ChildAdded:Connect(function(C)
	if(C:IsA("Model") and C.Parent ~= nil and C.Parent == Fight_Cages_F)then
		Set_Up_Fight_Model_Effects(C)
	end
end)


Receiving_Events_F:WaitForChild("Show_Punch_Effects").OnClientEvent:Connect(function(Hit_Char)
	if(Hit_Char ~= nil and Hit_Char:FindFirstChild("Head") ~= nil)then
		local Head = Hit_Char:FindFirstChild("Head")
		local Hit_VFX = Head:FindFirstChild("Hit_VFX")
		if(Hit_VFX ~= nil)then
			local All_PE = Hit_VFX:GetChildren()
			for i = 1, #All_PE do
				local PE = All_PE[i]
				if(PE ~= nil and PE:IsA("ParticleEmitter"))then
					PE:Emit(2)
				end
			end
		end
	end
end)

Receiving_Events_F:WaitForChild("Got_Hit_Effect").OnClientEvent:Connect(function()
	local hep = Instance.new("HapticEffect")
	game.Debris:AddItem(hep, 3)
	
	hep.Parent = game.Workspace
	hep.Name = "PUNCHED"
	hep.Type = Enum.HapticEffectType.UINotification
	hep:Play()
end)

local function Init_Fight_Model_Effects()
	wait(3)
	
	local All_FM = Fight_Cages_F:GetChildren()
	for i = 1, #All_FM do
		if(All_FM[i] ~= nil)then
			Set_Up_Fight_Model_Effects(All_FM[i])
		end
	end
end
Init_Fight_Model_Effects()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX020EB704C40A4EE0B8F33D6C8A8B7582">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Custom_Chat_Handle.client.lua</string>
						<string name="ScriptGuid">{5F5554A9-C4D6-4909-AF0E-74DBD026992C}</string>
						<ProtectedString name="Source"><![CDATA[local TCS = game:GetService("TextChatService")
local Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Bindable_RF = Channels_F:WaitForChild("Bindable_F"):WaitForChild("RF")
local Bindable_Events = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")

local VIP_Tag, VIP_Color = "[ VIP]", "rgb(255, 175, 0)"
local Rookie_Tag, Rookie_Color = "[Rookie]", "rgb(205, 127, 50)"


local Top3_Players_Updated = Receiving_Events_F:WaitForChild("Top3_Players_Updated")
local TopPlayers = {
}

Top3_Players_Updated.OnClientEvent:Connect(function(newTop, oldTop)
	TopPlayers = newTop
end)

TCS.OnIncomingMessage = function(msg:TextChatMessage)
	if msg.TextSource then
		local Sending_Plr = game.Players:GetPlayerByUserId(msg.TextSource.UserId)		
		if(Sending_Plr ~= nil and 
			(Sending_Plr:GetAttribute("Is_VIP") == true or Sending_Plr:GetAttribute("Is_Ultimate_VIP_Sub") == true))then
			local p = Instance.new("TextChatMessageProperties")

			local VIP_String = "<font color= '" .. VIP_Color .. "'>" .. VIP_Tag .. "</font> "
			p.PrefixText = VIP_String .. msg.PrefixText
			
			
			-- Tag for top 3 players
			local rank = TopPlayers[Sending_Plr.UserId]

			if rank then
				p.PrefixText = "[TOP #" .. rank .. "] " .. p.PrefixText
			end
			
			return p
		end
		
		if(Sending_Plr ~= nil and Sending_Plr:GetAttribute("Rookie") == true) then
			local p = Instance.new("TextChatMessageProperties")

			local RookieString = "<font color= '" .. Rookie_Color .. "'>" .. Rookie_Tag .. "</font> "
			p.PrefixText = RookieString .. msg.PrefixText
			return p
		end
		
		
	end
end

local function Parse_Color_Data(Col)
	local R, G, B = math.floor(Col.R * 255), math.floor(Col.G * 255), math.floor(Col.B * 255)
	local RGB_Txt = R .. "," .. G .. "," .. B
	return "<font color = \"rgb(" .. RGB_Txt .. ")\">"
end

Receiving_Events_F:WaitForChild("Server_Chat").OnClientEvent:Connect(function(Txt, Col)
	local TextChannels = TCS:WaitForChild("TextChannels")
	local Txt_Color = Parse_Color_Data(Col)
	
	Txt = "[SERVER] " .. Txt
	TextChannels.RBXSystem:DisplaySystemMessage(Txt_Color .. Txt .. "</font>")
end)

Bindable_RF:WaitForChild("Is_Chatbox_Typing").OnInvoke = function()
	local ChatInputBarConfiguration = TCS:FindFirstChildOfClass("ChatInputBarConfiguration")
	if(ChatInputBarConfiguration ~= nil and ChatInputBarConfiguration.IsFocused == true)then
		return true
	end
	return false
end

local function Server_Tips()
	local Tips = {
		"Find out latest MMA Fighters features through the tutorial, see '?'",
		"The longer you play, the more you are rewarded, see Rewards",
		"Earn more luck by inviting your friends!",
	}

	-- Tip color
	local TIP_COLOR = "#FFFF00" -- Yellow

	local function Display_Tip(Txt)
		local TextChannels = TCS:WaitForChild("TextChannels")

		-- Bold prefix + yellow color
		local message = string.format("<font color='%s'><b>[TIP]</b> %s</font>", TIP_COLOR, Txt)
		TextChannels.RBXSystem:DisplaySystemMessage(message)
	end

	task.spawn(function()
		-- Initial delay before first tip
		task.wait(60)

		local index = 1
		while true do
			Display_Tip(Tips[index])

			-- Rotation in order
			index += 1
			if index > #Tips then
				index = 1
			end

			task.wait(120) -- interval between tips
		end
	end)


end
Server_Tips()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC39AAF6F48FF4C6ABE9B0AFB390D7651">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">General_Client_Handle.client.lua</string>
						<string name="ScriptGuid">{9493BD8F-A813-4586-8178-B38859F16419}</string>
						<ProtectedString name="Source"><![CDATA[local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Sending_Events_F = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("Events")

local function Get_Player_Device()
	if(UIS.TouchEnabled)then
		return "Mobile"
	elseif(UIS.GamepadEnabled)then
		return "Console"
	else
		return "PC"
	end
end

Receiving_Events_F:WaitForChild("Update_Player_Device").OnClientEvent:Connect(function()
	Sending_Events_F:WaitForChild("Set_Player_Device"):FireServer(Get_Player_Device())
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5DDED9397BA34975AE128325B8981F9F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Overhead_Display_Handle.client.lua</string>
						<string name="ScriptGuid">{618522DE-3627-49BC-B9B9-C4CDECDB3B3A}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Damage_TMP = script:WaitForChild("Damage_TMP")

local function Apply_Damage_UI(Target_P, Damage, Col)
	local Pos_Options = {
		{
			['Rotation'] = -10,
			['End Pos'] = Vector3.new(-5, 10, 0)
		},

		{
			['Rotation'] = 0,
			['End Pos'] = Vector3.new(0, 10, 0)
		},

		{
			['Rotation'] = 10,
			['End Pos'] = Vector3.new(5, 10, 0)
		},
	}

	local Tween_In = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
	local Tween_Move = TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
	local Tween_Out = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)

	local Pos_Data = Pos_Options[math.random(1, #Pos_Options)]
	local Head = Target_P:FindFirstChild("Head")
	if(Head ~= nil)then
		local D_Tab = Damage_TMP:Clone()
		D_Tab.Damage_Detail.Text = Damage .. ""
		D_Tab.Damage_Detail.TextColor3 = Col

		D_Tab.Damage_Detail.Rotation = Pos_Data['Rotation']
		D_Tab.Damage_Detail.TextTransparency = 1
		D_Tab.Damage_Detail.TextStrokeTransparency = 1
		D_Tab.Parent = Head
		D_Tab.Adornee = Head
		D_Tab.ExtentsOffset = Vector3.new(0, 2.75, 0)
		D_Tab.Enabled = true

		TS:Create(D_Tab.Damage_Detail, Tween_In, {TextTransparency = 0, TextStrokeTransparency = 0}):Play()
		TS:Create(D_Tab, Tween_Move, {ExtentsOffset = Pos_Data['End Pos']}):Play()
		wait(1.5)
		if(D_Tab ~= nil)then
			TS:Create(D_Tab.Damage_Detail, Tween_Out, {TextColor3 = Color3.new(1, 1, 1), TextTransparency = 1, 
				TextStrokeTransparency = 1}):Play()
			wait(1)

			if(D_Tab ~= nil)then
				D_Tab:Destroy()
			end
		end

	end
end

Receiving_Events_F:WaitForChild("Overhead_Display").OnClientEvent:Connect(function(T_Char, Damage_Txt, Damage_Col)
	if(T_Char ~= nil and T_Char:FindFirstChild("Head") ~= nil)then
		Apply_Damage_UI(T_Char, Damage_Txt, Damage_Col)
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA0145C3A8E6142629F6271552922CCA9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Ranked_Wall_Handle.client.lua</string>
						<string name="ScriptGuid">{B4EE3E57-2A59-4D5B-B869-88435EA6A223}</string>
						<ProtectedString name="Source"><![CDATA[local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Total_Wins_V = PD:WaitForChild("Total Wins")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Wall_P = script:WaitForChild("Ranked_Arena_Wall")
local Spawn_CF = CFrame.new(Vector3.new(-342.939, 103.164, 144.812)) * CFrame.Angles(0, 0, 0)
local Wins_Requirement = 10 -- Change this if you want to make more Wins required to enter or not

local function Create_Wall_Handle()
	local P = Wall_P:Clone()
	local UI = P:WaitForChild("SurfaceGui")
	local Prog_Bar_F = UI:WaitForChild("Main_F"):WaitForChild("Prog_Bar_F")
	local Bar_F = Prog_Bar_F:WaitForChild("Bar_F")
	P.Parent = game.Workspace
	P.Name = "Ranked_Arena_Wall"
	P.CFrame = Spawn_CF
	
	local function Update_Size()
		local Tot_Wins = Total_Wins_V.Value or 0
		local Dif = math.clamp(Tot_Wins / Wins_Requirement, 0, 1, 0)
		Bar_F:TweenSize(UDim2.new(Dif, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.375, true, nil)
	end
	Update_Size()
	
	local Change_Con = nil
	Change_Con = Total_Wins_V.Changed:Connect(function()
		if(Total_Wins_V.Value < Wins_Requirement)then
			Update_Size()
		else
			if(Change_Con ~= nil)then
				Change_Con:Disconnect()
				Change_Con = nil
			end
			
			if(P ~= nil and P:IsDescendantOf(game.Workspace))then
				P:Destroy()
			end
			
			--Send message out to Player
			local Txt = " You can now engage in Ranked Fights at The Arena!"
			Bindable_Events_F:WaitForChild("Display_Data"):Fire(Txt, Color3.fromRGB(255, 170, 0))
		end
	end)
end

Bindable_RF:WaitForChild("Player_Can_Access_Arena").OnInvoke = function()
	if(Total_Wins_V ~= nil and Total_Wins_V.Value >= Wins_Requirement)then
		return true
	end
	return false
end

function On_Init()
	repeat wait(5) until Total_Wins_V ~= nil
	
	if(Total_Wins_V.Value < Wins_Requirement)then
		Create_Wall_Handle()
	end
end
On_Init()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE526D15BFC3D4DF7A3DB69BE41F545DE">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Colliders_Open_Handle.client.lua</string>
						<string name="ScriptGuid">{D166A6FD-E5CB-48F2-AD73-3006181B19D0}</string>
						<ProtectedString name="Source"><![CDATA[local Plr = game.Players.LocalPlayer
local PlrGui = Plr:WaitForChild("PlayerGui")
local Shop_UI = PlrGui:WaitForChild("Shop_UI")

local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local ShopOpenBindable = Bindable_Events_F:WaitForChild("Open_Shop")

function On_Init()
	for i, openType in pairs(game.Workspace:WaitForChild("OpenColliders"):GetChildren()) do
		for _, collider in pairs(openType:GetDescendants()) do
			if collider:IsA("BasePart") == false then
				continue
			end
			
			collider.Transparency = 1
			
			collider.Touched:Connect(function(part)
				if part.Name == "HumanoidRootPart" and part.Parent == Plr.Character then
					ShopOpenBindable:Fire(openType.Name)
				end
			end)
		end
	end
end
On_Init()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD24533D519D34554AA15DDB94AA5C2A9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">In-Game_Shop_Handle.client.lua</string>
						<string name="ScriptGuid">{BA0C65A1-50B9-4C3D-B654-F60A6AB0B615}</string>
						<ProtectedString name="Source"><![CDATA[local MPS = game:GetService("MarketplaceService")
local Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Msg_E = Bindable_Events_F:WaitForChild("Display_Data")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effects_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))

local Item_Data = {
	[101474119058173] = {
		['Name'] = 'Cowboy Hat',
		['Pos'] = Vector3.new(-407.815, 95.967, -330.416)
	},
	
	[83795788626582] = {
		['Name'] = 'Colorful Dreads Breads',
		['Pos'] = Vector3.new(-416.745, 96.102, -330.229)
	},
	
	[95997013721520] = {
		['Name'] = 'Snake Glasses Y2K - Green',
		['Pos'] = Vector3.new(-425.607, 95.889, -330.637)
	},
	
	[107974793938990] = {
		['Name'] = 'MMA Fighter Helmet',
		['Pos'] = Vector3.new(-434.851, 96.035, -330.497)
	},
	
	[85169596622861] = {
		['Name'] = 'Nerd Glasses',
		['Pos'] = Vector3.new(-455.254, 96.874, -348.311)
	},
	
	[75995119815868] = {
		['Name'] = 'Cowboy Hat',
		['Pos'] = Vector3.new(-461.261, 97.275, -356.943)
	},
	
	[114656167427986] = {
		['Name'] = 'Muay Thai Fighter Crown - Red White',
		['Pos'] = Vector3.new(-461.963, 96.123, -372.977)
	},
	
	[91774845227721] = {
		['Name'] = 'Face Bandages',
		['Pos'] = Vector3.new(-460.93, 96.458, -381.417)
	},
	
	[98181442625165] = {
		['Name'] = 'Protein Shaker - Red',
		['Pos'] = Vector3.new(-419.703, 95.859, -404.845)
	},
	
	[97647774814364] = {
		['Name'] = 'Motorcycle Helmet',
		['Pos'] = Vector3.new(-413.684, 95.754, -405.015)
	},
	
	[81219496918209] = {
		['Name'] = 'Black Gold VVS Chain Diamonds',
		['Pos'] = Vector3.new(-447.433, 95.922, -344.358)
	},
	
	[114922634621014] = {
		['Name'] = 'Big Metal Chain',
		['Pos'] = Vector3.new(-461.305, 96.694, -365.3)
	},
}

local function Player_Owns_Item(Plr, ID)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = MPS:PlayerOwnsAsset(Plr, ID)
		end)
		
		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end
	
	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end
	
	return false
end

function On_Init()
	--Create Prompt Parts
	-- Set up Promp Triggers Handle
	local Click_SE = Sound_Effects_Mod.Get_SE_Object(Plr, "Click_SE")
	local Sold_SE = Sound_Effects_Mod.Get_SE_Object(Plr, "Sold_SE")
	
	local function Create_Prompt_Folder()
		local F = Instance.new("Folder", game.Workspace)
		F.Name = "Item_Prompt_Parts_F"
		return F
	end
	local Prompt_F = Create_Prompt_Folder()
	
	local function Create_Prompt_Part(Data)
		local P = Instance.new("Part", Prompt_F)
		P.Name = Data['Name'] .. "_Prompt_P"
		P.Transparency = 1
		P.Size = Vector3.new(1, 1, 1)
		P.CFrame = CFrame.new(Data['Pos']) * CFrame.Angles(0, 0, 0)
		P.Anchored = true
		P.CanCollide = false
		P.CanTouch = false
		P.Massless = true
		P.Material = Enum.Material.SmoothPlastic
		
		local Prompt = Instance.new("ProximityPrompt", P)
		Prompt.Name = Data['Name'] .. "_Prompt"
		Prompt.ClickablePrompt = true
		Prompt.Enabled = true
		Prompt.HoldDuration = 0
		Prompt.MaxActivationDistance = 10
		Prompt.RequiresLineOfSight = false
		Prompt.ActionText = "Purchase"
		Prompt.ObjectText = Data['Name'] .. "!"
		
		return Prompt
	end
	
	local function Item_Handle(Item_ID, Data)
		local Prompt = Create_Prompt_Part(Data)
		local Debounce_P = false
		
		Prompt.Triggered:Connect(function(P)
			if(P ~= nil and P == Plr and Debounce_P == false)then
				Debounce_P = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				
				if(Player_Owns_Item(Plr, Item_ID) == false)then
					local Txt = " Purchase the " .. Data['Name'] .. "!"
					Msg_E:Fire(Txt, Color3.fromRGB(255, 170, 0))

					wait(1)
					
					MPS:PromptPurchase(Plr, Item_ID)
				else
					Msg_E:Fire(" You already own this Item!", Color3.fromRGB(35, 244, 68))
				end
				
				wait(0.25)
				Debounce_P = false
			end
		end)
	end
	
	for Item_ID, Data in next, Item_Data do
		Item_Handle(Item_ID, Data)
	end
	
	MPS.PromptPurchaseFinished:Connect(function(P, Asset_ID, Did_Buy)
		if(Did_Buy and P ~= nil and P == Plr and Item_Data[Asset_ID] ~= nil)then
			local Data = Item_Data[Asset_ID]
			
			if(Sold_SE ~= nil)then
				Sold_SE:Play()
			end
			
			local Txt = " Successfully purchased the " .. Data['Name'] .. "!"
			Msg_E:Fire(Txt, Color3.fromRGB(35, 244, 68))
		end
	end)
end
On_Init()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX90F8A2E2166C4E459CCB50E9F93C7198">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_GA_Init.client.lua</string>
						<string name="ScriptGuid">{660B087D-111F-4AC4-8F32-1380CD60C5FF}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
-- using wally package
--local GameAnalytics = require(ReplicatedStorage.Packages.GameAnalytics)
-- using rojo or manually copied in
local GameAnalytics = require(ReplicatedStorage.GameAnalytics)

GameAnalytics:initClient()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX80AA68D423244782B86F80FF5D18D48A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Display_Podium_Left_Handle.client.lua</string>
						<string name="ScriptGuid">{53B41B14-8C9B-4CD3-B9ED-A50950C253FE}</string>
						<ProtectedString name="Source"><![CDATA[local OfferFolder = game.Workspace.Offers_Data
local Remotes = game.ReplicatedStorage:WaitForChild("Remotes") 
local Offers  = Remotes:WaitForChild("Offers")
local Data_Mods_F       = game.ReplicatedStorage:WaitForChild("Data_Mods_F")


local GetCurrentClothOffer = Offers:WaitForChild("GetCurrentClothOffer")

local GetNewClothOffer = Offers:WaitForChild("GetNewClothOffer")
local ClothItemIdSignal = Offers:WaitForChild("ClothItemIdSignal")

local ClothsFolder=game.ReplicatedStorage.Clothing_F
local ClothShowableItemPlace=OfferFolder.Display_Podium_Left.Item
ramingTimeTxt = OfferFolder.Display_Podium_Left.OfferAttachment.BillboardGui.TextLabel
local setData=false
local plr = game.Players.LocalPlayer
local PingServerForNewCloth
task.wait(2)


local LeftHandPos= Vector3.new(-291.284, 97.812, -328.563)
local RightHandPos= Vector3.new(-289.072, 97.812, -328.563)


local countdownThread 
local countdownRev = 0 

local function formatDHMS(rem: number): string
	rem = math.max(0, rem)
	local d = math.floor(rem / 86400)
	local h = math.floor((rem % 86400) / 3600)
	local m = math.floor((rem % 3600) / 60)
	local s = rem % 60

	if d > 0 then
		return string.format("LIMITED TIME OFFER\n%dd %dh %dm", d, h, m)
	elseif h > 0 then
		return string.format("LIMITED TIME OFFER\n%dh %dm %ds", h, m, s)
	else
		return string.format("LIMITED TIME OFFER\n%dm %ds", m, s)
	end
end

local function stopCountdown()
	countdownRev += 1

	local label = ramingTimeTxt
	if label then label.Text = "" end
end

local function startCountdown(endsAt: number)

	if typeof(endsAt) ~= "number" or endsAt <= 0 then
		stopCountdown()
		return
	end
	countdownRev += 1
	local myRev = countdownRev

	countdownThread = task.spawn(function()
		while myRev == countdownRev do
			local label = ramingTimeTxt
			if not label then
				break
			end

			local now = os.time()
			local rem = math.max(0, endsAt - now)

			if rem <= 0 then
				label.Text = "OFFER ENDED"
				if typeof(setData) == "boolean" or setData == nil then
					pcall(function() setData = true end)
				end
				if typeof(PingServerForNewCloth) == "function" then
					pcall(PingServerForNewCloth)
				end
				if myRev == countdownRev then
					countdownRev += 1
				end
				break
			end

			label.Text = formatDHMS(rem)

			-- If our script (or ancestors) were removed from game, exit
			local p = script.Parent
			if not p or not p.Parent or not p.Parent:IsDescendantOf(game) then
				break
			end

			task.wait(1)
		end
		if myRev == countdownRev then
			countdownThread = nil
		end
	end)
end

local function SetPosition(ObjectMesh,pos)
	local rotOnly = ObjectMesh.CFrame - ObjectMesh.CFrame.Position
	ObjectMesh.CFrame = CFrame.new(pos) * rotOnly
end
local function AnchoredModel(model)
	for _, descendant in ipairs(model:GetDescendants()) do
		if descendant:IsA("BasePart") then
			descendant.Anchored = true
		end
	end
end
PingServerForNewCloth = function ()
	for _, d in ipairs(ClothShowableItemPlace:GetDescendants()) do
		d:Destroy()
	end
	local CurrentOfferData=""

	if not setData  then
		
		CurrentOfferData = GetCurrentClothOffer:InvokeServer() 
		
	end
	--print("CurrentOfferData",CurrentOfferData)
	task.wait()
	local item
	
	if CurrentOfferData then
		item = CurrentOfferData.offer
	end

	if not CurrentOfferData or not CurrentOfferData.offer  then
		 item = GetNewClothOffer:InvokeServer()
		
	end
	--item.EndsAt=os.time()+30
	if item then
		local ClothItemsParent
		if item.Kind == "Shorts" then
			ClothItemsParent = ClothsFolder:WaitForChild("Shorts_F")
		else
			ClothItemsParent = ClothsFolder:WaitForChild("Gloves_F")
		end
		local showableItem = ClothItemsParent:FindFirstChild(item.Title)
		if showableItem then
			local showableItemModel = showableItem:Clone()
			showableItemModel.Parent=ClothShowableItemPlace
			AnchoredModel(showableItemModel)
			if item.Kind == "Shorts" then
				showableItemModel:ScaleTo(1)
				showableItemModel:MoveTo(Vector3.new(-290.355, 98.235, -328.298))
			else
				showableItemModel:ScaleTo(1)
				showableItemModel:MoveTo(Vector3.new(0, 0, 0))
				SetPosition(showableItemModel:FindFirstChild("LeftHand"),LeftHandPos)
				SetPosition(showableItemModel:FindFirstChild("RightHand"),RightHandPos)
			end
			ClothItemIdSignal:FireServer(item)
			startCountdown(item.EndsAt)
		end
	end
end
PingServerForNewCloth()

ClothItemIdSignal.OnClientEvent:Connect(function ()
	wait(1)
	--print("check.....")
	setData=true
	PingServerForNewCloth()
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBBA8002C22134B2E877F6447F246F79F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Display_Podium_Center_Handle.client.lua</string>
						<string name="ScriptGuid">{698B22A3-2729-45CF-A01D-E6BF36048A57}</string>
						<ProtectedString name="Source"><![CDATA[local MarketplaceService = game:GetService("MarketplaceService")
local OfferFolder = game.Workspace.Offers_Data
local Remotes = game.ReplicatedStorage:WaitForChild("Remotes") 
local Offers  = Remotes:WaitForChild("Offers")

local ShowMessage = Offers:WaitForChild("ShowMessage")
local UGC = Offers:WaitForChild("UGC")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local PingServerForOwnershop = UGC:WaitForChild("PingServerForOwnershop")
local SendOwnershipDataClient = UGC:WaitForChild("SendOwnershipDataClient")
local Msg_E = Bindable_Events_F:WaitForChild("Display_Data")
local Sound_Effects_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local GetUGCItemOffer = UGC:WaitForChild("GetUGCItemOffer")
local UGCItemItemIdSignal = UGC:WaitForChild("UGCItemItemIdSignal")
local GetCurrentItemOffer = UGC:WaitForChild("GetCurrentItemOffer")

local UCGItemsFolder=game.ReplicatedStorage.OfferItems.UGCItems
local UGCShowableItemPlace=OfferFolder.Display_Podium_Center.Item
local GateToEnterPrompt=OfferFolder.Display_Podium_Center.OfferAttachment.Prompt
local setData=false
local remainingTimeTxt = OfferFolder.Display_Podium_Center.OfferAttachment.BillboardGui.TextLabel
task.wait(2)


PingServerForOwnershop:FireServer()

local PingServerForNewUGC


-- State
local countdownThread 
local countdownRev = 0  -- increments each start; older loops auto-exit

-- Try to find the label safely (re-resolve each tick in case GUI reloads)

local function formatDHMS(rem: number): string
	rem = math.max(0, rem)
	local d = math.floor(rem / 86400)
	local h = math.floor((rem % 86400) / 3600)
	local m = math.floor((rem % 3600) / 60)
	local s = rem % 60

	if d > 0 then
		return string.format("LIMITED TIME OFFER\n%dd %dh %dm", d, h, m)
	elseif h > 0 then
		return string.format("LIMITED TIME OFFER\n%dh %dm %ds", h, m, s)
	else
		return string.format("LIMITED TIME OFFER\n%dm %ds", m, s)
	end
end

local function stopCountdown()
	-- Invalidate any running loop; do NOT cancel threads (avoids cancel-on-dead errors)
	countdownRev += 1
	-- Optionally clear text
	local label = remainingTimeTxt
	if label then label.Text = "" end
end

local function startCountdown(endsAt: number)
	-- Validate input
	if typeof(endsAt) ~= "number" or endsAt <= 0 then
		stopCountdown()
		return
	end

	-- Invalidate any prior loop and capture this generation
	countdownRev += 1
	local myRev = countdownRev

	-- Optional small debounce if you want (remove if not needed)
	-- task.wait(0.05)

	-- Spawn loop
	countdownThread = task.spawn(function()
		while myRev == countdownRev do
			

			local now = os.time()
			local rem = math.max(0, endsAt - now)

			if rem <= 0 then
				remainingTimeTxt.Text = "OFFER ENDED"
				-- mark data + ask server for a fresh UGC (if these exist)
				if typeof(setData) == "boolean" or setData == nil then
					-- if setData is supposed to be a boolean flag elsewhere, set it
					pcall(function() setData = true end)
				end
				if typeof(PingServerForNewUGC) == "function" then
					pcall(PingServerForNewUGC)
				end
				-- Invalidate loop
				if myRev == countdownRev then
					countdownRev += 1
				end
				break
			end

			remainingTimeTxt.Text = formatDHMS(rem)

			-- If our script (or ancestors) were removed from game, exit
			local p = script.Parent
			if not p or not p.Parent or not p.Parent:IsDescendantOf(game) then
				break
			end

			task.wait(1)
		end

		-- loop finished: clear handle if we are the current thread
		if myRev == countdownRev then
			countdownThread = nil
		end
	end)
end












local function playerOwnsAsset(player, assetId)
	local success, owns = pcall(function()
		return MarketplaceService:PlayerOwnsAsset(player, assetId)
	end)
	if success then
		return owns
	else
		warn("Check failed:", owns)
		return false
	end
end


local function setModelVisibleForClient(model, visible)
	for _, d in ipairs(model:GetDescendants()) do
		if d:IsA("BasePart") then
			d.LocalTransparencyModifier = visible and 0 or 1
			d.CanCollide = visible
			d.CanTouch = visible
			d.CanQuery = visible
		elseif d:IsA("ProximityPrompt") then
			d.Enabled = visible
		elseif d:IsA("BillboardGui") then
			d.Enabled = visible
		end
	end
end



local function showMessage(message,isSuccess)
	if isSuccess then
		local Txt = " "..message
		Msg_E:Fire(Txt, Color3.fromRGB(35, 244, 68))
	else
		local Txt = " "..message
		Msg_E:Fire(Txt, Color3.new(1, 0, 0))
	end
	
end

SendOwnershipDataClient.OnClientEvent:Connect(function(isOwned,ItemName,CanPlaySound)

	local model = OfferFolder:FindFirstChild(ItemName)
	if model then
		local Sold_SE = Sound_Effects_Mod.Get_SE_Object(game.Players.LocalPlayer, "Sold_SE")
		if(Sold_SE ~= nil) and CanPlaySound then
			
			Sold_SE:Play()
			local Txt = " Successfully purchased!"
			Msg_E:Fire(Txt, Color3.fromRGB(35, 244, 68))
		end
		setModelVisibleForClient(model, isOwned==false)
	end
    --print(isOwned,ItemName)
end)



ShowMessage.OnClientEvent:Connect(function (message,isSuccess)
	
	showMessage(message,isSuccess)
	
end)


local function parseName(name)
	local prio, key, title = string.match(name, "^(%d+)%s*/%s*(%d+)%s*/%s*(.+)$")
	if not prio then return end
	return tonumber(prio), tostring(key), title
end


local TIME_IN_DAYS = 4 * 24 * 60 * 60
PingServerForNewUGC = function ()
	for _, d in ipairs(UGCShowableItemPlace:GetDescendants()) do
		d:Destroy()
	end
	local CurrentOfferData=""
		
	if not setData  then
		
		CurrentOfferData = GetCurrentItemOffer:InvokeServer() 
	end
		
	task.wait()
	local item
	local currentOfferItemName = ""
	if CurrentOfferData then
		currentOfferItemName = CurrentOfferData.CurrentKey
		if  currentOfferItemName and currentOfferItemName~="" then
			
			local prio, key, title = parseName(currentOfferItemName)
			item={
				Key = key,
				Kind = "UGC",
				Title = title,
				RefName=currentOfferItemName,
				Priority = prio,
				EndsAt = CurrentOfferData.EndsAt,           -- 0 = no end
			}
		end
	end
	
	if not currentOfferItemName or currentOfferItemName =="" or currentOfferItemName==nil then
		 item = GetUGCItemOffer:InvokeServer()
		if item then
			
			item.EndsAt=os.time()+TIME_IN_DAYS
		end
	end
	
	if item then
		local showableItem = UCGItemsFolder:FindFirstChild(item.RefName)
		if showableItem then
			local showableItemModel = showableItem:Clone()
			showableItemModel.Parent=UGCShowableItemPlace
			UGCItemItemIdSignal:FireServer(item.Key,item.RefName)
			GateToEnterPrompt.Enabled=true
			startCountdown(item.EndsAt)
		end
	end
end
PingServerForNewUGC()
--local function CheckForVisiBaleUGC ()
--	local isFound1=false
--	for _, d in ipairs(UGCInner:GetDescendants()) do
--		setModelVisibleForClient(d, false)
--	end
	
--	local player = game.Players.LocalPlayer

--	for i = 1, #UGCInner:GetDescendants() do
--		local d = UGCInner:GetDescendants()[i]
--		local data = string.split(d.Name, "/")
--		print(d.Name)
--		local id = data[2]

--		if id ~= nil and not isFound1 then
--			local isOwn = playerOwnsAsset(player, tonumber(id))
--			if isOwn then
--				setModelVisibleForClient(d, false)
--				return
--			else
--				setModelVisibleForClient(d, true)
--				UGCInnerPurchaseId = id
--				isFound1 = true
--			end
--		end
--	end
--end

--CheckForVisiBaleUGC ()
UGCItemItemIdSignal.OnClientEvent:Connect(function ()
	wait(1)
	--print("check.....")
	stopCountdown()
	GateToEnterPrompt.Enabled=false
	setData=true
	remainingTimeTxt.Text=""
	PingServerForNewUGC()
end)
--wait(2)
--UGCInnerSinal:FireServer(UGCInnerPurchaseId)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX0F810045240B4974B944573B8648164E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">StarterCharacterScripts</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXAD00673E64534D26AFAF5F68D0A3AF71">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Cage_Camera_Handle.client.lua</string>
						<string name="ScriptGuid">{A7415981-061B-440E-B698-E31892454E52}</string>
						<ProtectedString name="Source"><![CDATA[local RS = game:GetService("RunService")
local Plr = game.Players.LocalPlayer
local Char =  Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Fight_Cages_F = game.Workspace:WaitForChild("Fight_Cages_F")
local Cam = game.Workspace.CurrentCamera

local Part_Names = {"CageFence", "CornerTrim", "PaddingCorner", "PaddingFenceDoor", "FenceDoor", 
	"PaddingFence", "FenceFrame"}
local Selected_M = nil

local function Get_Whitelist()
	local Cages_M = {}
	local All_Fight_Cages = Fight_Cages_F:GetChildren()
	for i = 1, #All_Fight_Cages do
		local FCM = All_Fight_Cages[i]
		if(FCM ~= nil and FCM:FindFirstChild("MMA_Cage") ~= nil)then
			table.insert(Cages_M, FCM:FindFirstChild("MMA_Cage"))
		end
	end
	
	return Cages_M
end

local function Get_Cage_M()
	local Dist = (Cam.CFrame.Position - HRP.Position).Magnitude
	local Dir = Cam.CFrame.LookVector
	local Raycast_Parm = RaycastParams.new()
	Raycast_Parm.FilterDescendantsInstances = Get_Whitelist()
	Raycast_Parm.FilterType = Enum.RaycastFilterType.Include

	local Ray_Res = game.Workspace:Raycast(Cam.CFrame.Position, Dir * Dist, Raycast_Parm)
	if(Ray_Res ~= nil and Ray_Res.Instance ~= nil and 
		Ray_Res.Instance:FindFirstAncestorWhichIsA("Model") ~= nil)then
		
		return Ray_Res.Instance:FindFirstAncestorWhichIsA("Model")
	end
	
	return nil
end

local function Toggle_Cage_Parts(M, Is_Visible)
	for i = 1, #Part_Names do
		local PN = Part_Names[i]
		local P = M:FindFirstChild(PN)
		if(P ~= nil)then
			if(Is_Visible)then
				if(PN == "CageFence")then
					P.Transparency = 0.6
				else
					P.Transparency = 0
				end
			else
				P.Transparency = 0.75
			end
		end
	end
end

RS.RenderStepped:Connect(function()
	local Is_Fighting = Char:GetAttribute("Is_Fighting") or false
	if(Is_Fighting)then
		local Cage_M = Get_Cage_M()
		if(Cage_M ~= nil and Cage_M ~= Selected_M)then
			if(Selected_M ~= nil)then
				Toggle_Cage_Parts(Selected_M, true)
			end

			Toggle_Cage_Parts(Cage_M, false)
			Selected_M = Cage_M

		elseif(Cage_M == nil and Selected_M ~= nil)then
			Toggle_Cage_Parts(Selected_M, true)
			Selected_M = nil
		end
	elseif(Selected_M ~= nil)then
		Toggle_Cage_Parts(Selected_M, true)
		Selected_M = nil
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX66C9336E84454DA1AB57ECDF0FE6ECC7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Ranked_Arena_Effects_Handle.client.lua</string>
						<string name="ScriptGuid">{4DAC8939-257B-4BA8-A3AC-89A758C75544}</string>
						<ProtectedString name="Source"><![CDATA[--Once a Players Character passes this Z Value
	--turn it on until the Player Leaves
	
	--When inside, Play the Crowd Ambient Sound Effect
	--Play the Lighting Spark Effects over all the Seats
	
local Debris = game:GetService("Debris")
local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_RF = Channels_F:WaitForChild("Bindable_F"):WaitForChild("RF")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Crowd_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Crowd_SE")
local BG_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Main_BG_SE")
local Arena_BG_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Arena_BG_SE")
local Flash_PE = script:WaitForChild("Flash_PE")

local Is_Within_Arena_Region = false
local Pos_Min = 120

local function Effects_Handle()
	if(Crowd_SE ~= nil)then
		Crowd_SE:Play()
	end
	
	if(Arena_BG_SE ~= nil)then
		Arena_BG_SE:Play()
	end

	if(BG_SE ~= nil)then
		BG_SE:Stop()
	end
	
	local Can_Access_Arena = Bindable_RF:WaitForChild("Player_Can_Access_Arena"):Invoke()
	if(Can_Access_Arena)then
		Sound_Effect_Mod.Play_Voice_Over("Entering_Arena")
	else
		Sound_Effect_Mod.Play_Voice_Over("Locked_Arena")
	end
	
	local function Flash_Camera_From_Seats()
		--10% of Seating
		--Pick Random Seats, Create Flash Parts, Debris, Emit Flash Particle on them
		local function Get_Arena_Seating()
			local World_F = game.Workspace:FindFirstChild("Main_World_F")
			if(World_F ~= nil and World_F:FindFirstChild("Map") ~= nil)then
				local Map_F = World_F:FindFirstChild("Map")
				local Seating_F = Map_F:FindFirstChild("Arena_Seating_F")
				if(Seating_F ~= nil)then
					return Seating_F:GetChildren()
				end
			end
			return {}
		end
		local Seats_Arr = Get_Arena_Seating()
		local Amount = 100 -- Can Change
		
		if(Seats_Arr ~= nil and #Seats_Arr > Amount)then
			local function Play_Camera_Flash()
				local Seat_Index = math.random(1, #Seats_Arr)
				local Seat_M = Seats_Arr[Seat_Index]
				if(Seat_M ~= nil and Seat_M:FindFirstChild("Chair_SeatColor") ~= nil)then
					table.remove(Seats_Arr, Seat_Index)
					
					local Main_P = Seat_M:FindFirstChild("Chair_SeatColor")
					local A = Instance.new("Attachment", Main_P)
					A.Name = "Flash_A"
					A.Visible = false
					A.CFrame = CFrame.new(0, 0.775, 0) * CFrame.Angles(0, 0, 0)
					
					local Emit_Count = math.random(2, 8)
					local PE = Flash_PE:Clone()
					PE.Parent = A
					PE:Emit(Emit_Count)
					
					Debris:AddItem(A, 0.25)
				end
			end
			
			for i = 1, Amount do
				Play_Camera_Flash()
				if(i % 2 == 0)then
					wait(0.02)
				end
			end
			
			return
		end
		
		wait(1)
	end
	
	warn("STARTED")
	
	while Is_Within_Arena_Region do
		Flash_Camera_From_Seats()
	end

	warn("FINISHED")
	
	--End all
	if(Crowd_SE ~= nil)then
		Crowd_SE:Stop()
	end
	
	if(Arena_BG_SE ~= nil)then
		Arena_BG_SE:Stop()
	end
	
	if(BG_SE ~= nil)then
		BG_SE:Play()
	end
end

function On_Init_Check()
	local function Is_Within_Region()
		if(HRP ~= nil and HRP.Position.Z > Pos_Min)then
			return true
		end
		return false
	end
	
	if(BG_SE ~= nil)then
		BG_SE:Play()
	end
	
	if(Arena_BG_SE ~= nil)then
		Arena_BG_SE:Stop()
	end
	
	while wait(0.5) do
		local Is_In_Region = Is_Within_Region()
		if(Is_In_Region and Is_Within_Arena_Region == false)then
			Is_Within_Arena_Region = true
			task.spawn(Effects_Handle)
			
		elseif(Is_In_Region == false and Is_Within_Arena_Region == true)then
			Is_Within_Arena_Region = false
		end
	end
end
On_Init_Check()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0EAE9054EFE84654ACFB3E85F61EA6AE">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Trail_Handle.client.lua</string>
						<string name="ScriptGuid">{B0DB0219-9FCB-4137-875F-69B6D384A12C}</string>
						<ProtectedString name="Source"><![CDATA[local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Beam = script:WaitForChild("Beam")

local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")

local function Create_Attachment(Main_P)
	local A = Main_P:FindFirstChild("Trail_Attachment")
	if(A == nil)then
		A = Instance.new("Attachment", Main_P)
		A.Name = "Trail_Attachment"
	end

	return A
end

local function Create_Beam()
	local B = Beam:Clone()
	B.Parent = Char
	B.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 170, 0)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 170, 0))
	}
	B.Attachment0 = Create_Attachment(HRP)

	return B
end
local Beam = Create_Beam()

local function Delete_A1_Part()
	if(Beam ~= nil and Beam.Attachment1 ~= nil and Beam.Attachment1.Parent ~= nil)then
		Beam.Attachment1.Parent:Destroy()
		Beam.Attachment1 = nil
	end
end

local function Set_Trail_Handle(Pos, Col)
	if(Beam.Enabled == true)then
		Delete_A1_Part()
		Beam.Enabled = false
	end
	
	local function Create_A1_Part()
		local P = Instance.new("Part", game.Workspace)
		P.Name = "Trail_Target_Part"
		P.Transparency = 1
		P.Material = Enum.Material.SmoothPlastic
		P.CanCollide = false
		P.CanTouch = false
		P.Anchored = true
		P.Size = Vector3.new(1, 1, 1)
		P.CFrame = CFrame.new(Pos) * CFrame.Angles(0, 0, 0)
		
		return P
	end
	local A1_Part = Create_A1_Part()
	
	Beam.Attachment1 = Create_Attachment(A1_Part)
	Beam.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Col),
		ColorSequenceKeypoint.new(1, Col)
	}
	Beam.Enabled = true
end

Bindable_Events_F:WaitForChild("Set_Trail").Event:Connect(function(Pos, Col)
	if(Beam ~= nil)then
		Set_Trail_Handle(Pos, Col)
	end
end)

Bindable_Events_F:WaitForChild("Remove_Trail").Event:Connect(function()
	if(Beam ~= nil and Beam.Enabled == true)then
		Delete_A1_Part()
		Beam.Enabled = false
	end
end)

game.Lighting.ChildAdded:Connect(function(C)
	if(C ~= nil and C:IsA("BlurEffect") and Beam ~= nil and Beam.Enabled == true)then
		Beam.Enabled = false
		Delete_A1_Part()
	end
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA9E9FE1BC20A485D9C4D712A123A7468">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Tutorial_Handle.client.lua</string>
						<string name="ScriptGuid">{D85E0A43-DE21-4EEF-9DE4-4007C626EAC2}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Display_Data_E = Bindable_Events_F:WaitForChild("Display_Data")
local Display_Tuto_Message = Bindable_Events_F:WaitForChild("Display_Tuto_Message")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Cam = game.Workspace.CurrentCamera

--[[
	* Every step of the tutorial is describe with a object following this structure
	{
		title= "", -- Title of the Step
		txt="", -- Text of the Step
		camera_key="", -- Key of object for position and orientation of camera (see Workspace.Tutorial_Parts_F)
		destination_key="", -- Key of object for position trail destination (see Workspace.Tutorial_Parts_F)
		open_panel_event = "" -- Name of the event to open the panel
	}
	
	* Camera, Destination and Panel fields are optional
	* If a step has no camera_key, the camera will not move
	* If a step has no destination_key, the trail will show
	* If a step has no open_panel_event, no panel will open
]]--

local Tutorial_Step = 0
local Tuto_Blur = nil
local Trail_color = Color3.fromRGB(35, 244, 68)
local Tutorial_Steps = {
	{
		title= " WELCOME",
		txt="Welcome to <b>MMA Fighters</b> !\nTrain hard, fight smart, and become the ultimate MMA champion!"
	}, 
	{
		title= " GYM",
		txt="Head to the <b>training gym</b> !\nThis is where youll learn the basics: movements, combos, and controlling your fighter.",
		camera_key="Gym_Cam_P"
	},
	{
		title= " GYM",
		txt="Each training session gives you <b>Cash </b>.\nThe more you practice, the more comfortable youll be with combosand ready to enter the cage!",
		destination_key="Gym_Destination_P"
	},
	{
		title= " FIGHT MODE",
		txt="Its time to <b>enter the cage</b> !\nThis is where you prove your worth against opponents.",
		camera_key="Cages_Cam_P"
	},
	{
		title= " FIGHT MODE",
		txt="Find an empty cage and choose your opponent:\n-  a <b>bot</b> to warm up\n-  a <b>PvP fight</b> to challenge a real player!",
		destination_key="Cages_Destination_P"
	},
	{
		title= " COMBO SELECTION",
		txt="Customize your fighting style by choosing your favorite <b>combos</b>!\nUnlock new moves as you progress and create unique chains to surprise your opponents .",
		open_panel_event = "Open_Combos"
	},
	{
		title= " RANKED ARENA",
		txt="Welcome to the <b>Ranked Arena</b> !\n- Battles are fought in <b>5 intense rounds</b>\n- Each win boosts your Elo  and brings you closer to the champions\n- This is where true <b>octagon legends</b> are born ",
		camera_key="Arena_Cam_P"
	},
	{
		title=" RANKED ARENA",
		txt=" <b>Ranked Arena</b> is only accessible after <b>10 victories</b> in classic cages... and thats when the real challenge begins .",
		camera_key="Cages_Cam_P"
	},
	{
		title= " LEADERBOARD",
		txt="Check out the <b>Global Leaderboard</b> !\nClimb the ranks, put your name at the top , and show your style to the whole community.",
		camera_key="LB_Cam_P"
	},
	{
		title= " AVATAR",
		txt="Build your unique style !\nCustomize your avatar with skins, outfits, and exclusive items.\nThe more original your look, the more youll shine in the arena .",
		open_panel_event = "Open_Avatar"
	},
	{
		title= " SHOP",
		txt="In the shop , spend your <b>Cash </b> and <b>Gems </b> earned from fights and training.\nIts the perfect place to unlock exclusive items and style up your avatar.",
		camera_key="Shop_Cam_P"
	},
	{
		title= " SHOP",
		txt=" Browse the available items, open special crates, and discover surprise rewards !\nSome items are ultra rare get them to stand out in the cage .",
		destination_key="Shop_Destination_P"
	},
	{
		title= " GOALS",
		txt="Advance to glory by completing <b>objectives</b> !\n- Score 5 KOs \n- Win your first fight \n- Land 10 KOs with kicks \nEach goal unlocks rewards and new steps in your journey to become a champion.",
		open_panel_event = "Open_Skill_Tree"
	}
}


local function Go_To_Camera(Key)
	local Tween_Cam = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
	Bindable_Events_F:WaitForChild("Toggle_Cutscene"):Fire(true)

	Tuto_Blur = Instance.new("BlurEffect", game.Lighting)
	Tuto_Blur.Name = "Tutorial_Blurr"
	Tuto_Blur.Size = 0
	
	local Tutorial_Parts_F = game.Workspace:FindFirstChild("Tutorial_Parts_F")
	local Camera_CFrame = Tutorial_Parts_F:FindFirstChild(Key).CFrame
	
	if(Camera_CFrame == nil)then
		warn("Missing Tutorial camera for keay:"..Key)
		return
	end

	Cam.CameraType = Enum.CameraType.Scriptable
	TS:Create(Cam, Tween_Cam, {CFrame = Camera_CFrame}):Play()
	wait(0.75)
end

local function Camera_Back_To_Player()
	if(Tuto_Blur ~= nil) then 
		Tuto_Blur:Destroy()
	end
	Bindable_Events_F:WaitForChild("Toggle_Cutscene"):Fire(false)
	Cam.CameraType = Enum.CameraType.Custom
	Cam.CameraSubject = Hum
end

local function Show_Message(Title, Txt)
	Display_Tuto_Message:Fire(Title, Txt)
end

local function Show_Trail(Destination_Key)
	local Tutorial_Parts_F = game.Workspace:FindFirstChild("Tutorial_Parts_F")
	local Destination_Position = Tutorial_Parts_F:FindFirstChild(Destination_Key).Position
	Bindable_Events_F:WaitForChild("Set_Trail"):Fire(Destination_Position, Trail_color)
end

local function Remove_Trail()
	Bindable_Events_F:WaitForChild("Remove_Trail"):Fire()
end

local function Open_Panel(Event_Name)
	Bindable_Events_F:WaitForChild(Event_Name):Fire()
end

local function Tutorial_Handle()
	Tutorial_Step +=1
	local step = Tutorial_Steps[Tutorial_Step]

	-- show modal message
	Show_Message(step["title"], step["txt"])
	
	-- camera tween
	if step["camera_key"] ~= nil and step["camera_key"] ~= "" then 
		Go_To_Camera(step["camera_key"]) 
	else
		Camera_Back_To_Player()
	end
	
	-- trail to destination
	if step["destination_key"] ~= nil and step["destination_key"] ~= "" then 
		Show_Trail(step["destination_key"]) 
	else
		Remove_Trail() 
	end
	
	-- open panel
	if step["open_panel_event"] ~= nil and step["open_panel_event"] ~= "" then
		Open_Panel(step["open_panel_event"])
	end
end

local function Tutorial_Close()
	Tutorial_Step = 0
	Camera_Back_To_Player()
	Remove_Trail()
	Bindable_Events_F:WaitForChild("End_Tutorial"):Fire()
end

Bindable_Events_F:WaitForChild("Show_Tutorial").Event:Connect(function()
	Tutorial_Step = 0
	Tutorial_Handle()
end)

Bindable_Events_F:WaitForChild("Next_Tutorial_Step").Event:Connect(function()
	if Tutorial_Step > 0 then
		if Tutorial_Step < #Tutorial_Steps then
			Tutorial_Handle()
		else
			warn("Tutorial finished")
			Tutorial_Close()
		end
	else
		warn("Tutorial not running")
	end
end)

Bindable_Events_F:WaitForChild("Close_Tutorial").Event:Connect(function()
	Tutorial_Close()
end)

local function Close_Commands_Panel()
	if Tutorial_Step > 0 then
		Bindable_Events_F:WaitForChild("Toggle_Commands_Panel"):Fire(false)
	end
end

Bindable_Events_F:WaitForChild("Enter_Fight_Mode").Event:Connect(function()
	if Tutorial_Step > 0 then
		Bindable_Events_F:WaitForChild("Toggle_Commands_Panel"):Fire()
	end
end)

local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")

Receiving_Events_F:WaitForChild("End_Fight").OnClientEvent:Connect(function(Target_Char)
	Close_Commands_Panel()
end)

Bindable_Events_F:WaitForChild("Disable_Fight_Mode").Event:Connect(function()
	Close_Commands_Panel()
end)

Bindable_Events_F:WaitForChild("Close_Fight_Result").Event:Connect(function()
	Close_Commands_Panel()
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX66DFCBD078E84AFC80FEDD1217D2FE2F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Toggle_Reset_Button.client.lua</string>
						<string name="ScriptGuid">{0E6C80A4-6249-4EB8-BA78-F9983C770A78}</string>
						<ProtectedString name="Source"><![CDATA[local StarterGUI = game:GetService("StarterGui")
local Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")

local function Toggle_Reset_Call_Back(Enable)
	local function Async()
		local success = pcall(function() 
			StarterGUI:SetCore("ResetButtonCallback", Enable) 
		end)
		
		if(success)then
			return true
		end
		return false
	end
	
	while Async() == false do
		wait(1)
	end
end

Bindable_Events_F:WaitForChild("Toggle_Reset").Event:Connect(function(Is_Enabled)
	task.spawn(Toggle_Reset_Call_Back, Is_Enabled)
end)

task.spawn(Toggle_Reset_Call_Back, true)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXF7878075F59A491599B2165D09D77925">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">StarterCharacterNew</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX7C7FF7EB0B714F3DAA2440D1E93E4894">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Animate.client.lua</string>
						<string name="ScriptGuid">{5BFC7735-3E91-49F3-928F-9512565BB793}</string>
						<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXC7B552AAE0604EC6BE6B6769E9809A35">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">StarterCharacter</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXFB586BBC30AD4911B8D341615F58D34F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Animate.client.lua</string>
						<string name="ScriptGuid">{9D57EE06-8FDF-42E1-95B6-31FC283B50A9}</string>
						<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX4FA283A5E3DB46ED9CE1309A0839E19E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">StarterPack</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXDA092D926C7644DDBF0967E2DBF213AF">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Takedown_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXD4F3450783F04248A179D0DB7DB338D5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Takedown_Display_Handle.client.lua</string>
						<string name="ScriptGuid">{44A540B1-0EA5-411F-9242-FF19099ED75F}</string>
						<ProtectedString name="Source"><![CDATA[local UIS = game:GetService("UserInputService")
local RS = game:GetService("RunService")
local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Fight_Cages_F = game.Workspace:WaitForChild("Fight_Cages_F")

local Main_F = script.Parent.Takedown_Bar_F
local Main_Txt = Main_F.Main_Txt
local Your_Prog_Bar_F = Main_F.Your_Prog_Bar_F
local Your_Name_Txt = Your_Prog_Bar_F.P_Name_Txt
local Your_Bar_F = Your_Prog_Bar_F.Bar_F
local Other_Player_F = Main_F.Other_Player_F
local Other_Name_Txt = Other_Player_F.P_Name_Txt
local Other_Bar_F = Other_Player_F.Bar_F
local Middle_F = Main_F.Middle_F
local Key_Txt = Middle_F.Key_Txt
local Icon_Img = Middle_F.Icon_Img
local Your_Health_F = Main_F.Your_Health_F
local Your_Health_Bar_F = Your_Health_F.Bar_F
local Your_Health_Txt = Your_Health_F.Val_Txt
local Your_Stam_F = Main_F.Your_Stam_F
local Your_Stam_Bar_F = Your_Stam_F.Bar_F
local Your_Stam_Txt = Your_Stam_F.Val_Txt
local Other_Health_F = Main_F.Other_Health_F
local Other_Health_Bar_F = Other_Health_F.Bar_F
local Other_Health_Txt = Other_Health_F.Val_Txt
local Other_Stam_F = Main_F.Other_Stam_F
local Other_Stam_Bar_F = Other_Stam_F.Bar_F
local Other_Stam_Txt = Other_Stam_F.Val_Txt
local Round_Change_F = script.Parent.Round_Change_F
local Bottom_Move_F = Round_Change_F.Bottom_F
local Round_Main_F = Round_Change_F.Main_F
local Round_Main_Txt = Round_Main_F.Main_Txt

local Takedown_Prog_F = script.Parent.Takedown_Progress_Display_F
local Key_F = Takedown_Prog_F.Key_F
local Button_F = Takedown_Prog_F.Button_F
local Per_Data_Txt = Takedown_Prog_F.Per_Txt
local Tabs_F = Takedown_Prog_F.Tabs_F
local Main_Cover = Tabs_F.Main_Cover
local First_Half = Tabs_F.First_Half_C
local Second_Half = Tabs_F.Second_Half_C


local Debounce_UI = false
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	
	table.clear(Cons)
end

local function Special_Txt(T, C)
	local RGB_Txt = string.format("rgb(%d, %d, %d)", C.R * 255, C.G * 255, C.B * 255)
	return [[<font color="]] .. RGB_Txt .. [[">]] .. T .. [[</font>]]
end

local function Show_Round_Change(Round_Num)
	local Ding_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Start_Fight_Bell_SE")
	if(Ding_SE ~= nil)then
		Ding_SE:Play()
	end
	Sound_Effect_Mod.Play_Voice_Over("Round_" .. Round_Num)

	local function Reset_Display()
		local function Get_Max_Rounds()
			local All_Cages_M = Fight_Cages_F:GetChildren()
			
			local function Is_Main_Cage(Cage_M)
				local FD = Cage_M:FindFirstChild("Fight_Data_F")
				if(FD ~= nil and FD:FindFirstChild("Fight_Char_1") ~= nil and 
					FD:FindFirstChild("Fight_Char_2") ~= nil)then

					local C1_V = FD:FindFirstChild("Fight_Char_1")
					local C2_V = FD:FindFirstChild("Fight_Char_2")
					if(C1_V.Value == Char or C2_V.Value == Char) then
						return true
					end
				end

				return false
			end

			for i = 1, #All_Cages_M do
				local Cage_M = All_Cages_M[i]
				if(Cage_M ~= nil and Is_Main_Cage(Cage_M))then
					local Is_Ranked = Cage_M:GetAttribute("Ranked_Match")
					if(Is_Ranked ~= nil and Is_Ranked == true)then
						return 5
					end
				end
			end
			
			return 3
		end
		
		Round_Change_F.Visible = false
		Round_Main_F.Position = UDim2.new(1, 0, 0, 0)
		Bottom_Move_F.Position = UDim2.new(-1, 0, 0, 0)
		Round_Main_Txt.Text = "ROUND " .. Round_Num .. " OF " .. Get_Max_Rounds()
		Round_Main_Txt.Visible = true
		Round_Main_Txt.Position = UDim2.new(0.5, 0, 0.5, 0)
		Bindable_Events_F:WaitForChild("Mobile_Takedown_Toggle"):Fire(false)
	end
	Reset_Display()

	local function Show_Main()
		Round_Change_F.Visible = true
		Bottom_Move_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		Round_Main_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		wait(0.25)
	end
	Show_Main()

	local function Slight_Move()
		Bottom_Move_F:TweenPosition(UDim2.new(0.125, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 1, true, nil)
		Round_Main_F:TweenPosition(UDim2.new(-0.125, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 1, true, nil)

		wait(1)
	end
	Slight_Move()

	local function Move_Out()
		Bottom_Move_F:TweenPosition(UDim2.new(1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		Round_Main_F:TweenPosition(UDim2.new(-1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		wait(0.25)	
	end
	Move_Out()

	Reset_Display()
end

local function Round_Change_Handle(Round_V)
	table.insert(Cons, Round_V.Changed:Connect(function()
		if(Round_V.Value > 1)then
			wait(0.5)
			Show_Round_Change(Round_V.Value)
		end
	end))
end

Bindable_Events_F:WaitForChild("New_Round_Display").Event:Connect(function(Round_Num)
	Show_Round_Change(Round_Num)
end)


local function Get_Takedown_Tracking_Val()
	local function Is_Fighting_Model(Cage_M)
		local Fight_Data_F = Cage_M:FindFirstChild("Fight_Data_F")
		if(Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild("Fight_Char_1") ~= nil and 
			Fight_Data_F:FindFirstChild("Fight_Char_2") ~= nil and 
			Fight_Data_F:FindFirstChild("Active_Fight") ~= nil and 
			Fight_Data_F:FindFirstChild("Takedown_Track") ~= nil)then
			
			local Char_V1 = Fight_Data_F:FindFirstChild("Fight_Char_1")
			local Char_V2 = Fight_Data_F:FindFirstChild("Fight_Char_2")
			local Active_Fight_V = Fight_Data_F:FindFirstChild("Active_Fight")
			
			if(Active_Fight_V.Value == true and (Char_V1.Value == Char or Char_V2.Value == Char))then
				return true
			end
		end
		
		return false
	end
	
	local function Get_Takedown_Tracking(Cage_M)
		local Fight_Data_F = Cage_M:FindFirstChild("Fight_Data_F")
		if(Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild("Takedown_Track") ~= nil)then
			return Fight_Data_F:FindFirstChild("Takedown_Track")
		end

		return nil
	end
	
	local All_Cages_M = Fight_Cages_F:GetChildren()
	for i = 1, #All_Cages_M do
		local Cage_M = All_Cages_M[i] 
		if(Cage_M ~= nil and Is_Fighting_Model(Cage_M))then
			return Get_Takedown_Tracking(Cage_M)
		end
	end
	
	return nil
end

local function Get_Fight_Data_Vals(C_Name, root)
	local P_Char
	if root == nil then
		P_Char = game.Workspace:FindFirstChild(C_Name)
	else
		P_Char = root:FindFirstChild(C_Name)
	end
	if(P_Char ~= nil)then
		local Plr_Obj = game.Players:GetPlayerFromCharacter(P_Char)
		if(Plr_Obj ~= nil and Plr_Obj:FindFirstChild("Fight_Data") ~= nil)then
			local FD = Plr_Obj:FindFirstChild("Fight_Data")
			return FD:FindFirstChild("Health"), FD:FindFirstChild("Staminia")
			
		elseif(P_Char:FindFirstChild("Fight_Data") ~= nil)then
			local FD = P_Char:FindFirstChild("Fight_Data")
			return FD:FindFirstChild("Health"), FD:FindFirstChild("Staminia")
		end
	else
		if root == nil then
			return Get_Fight_Data_Vals(C_Name, game.Workspace._BOTS_FOLDER_)
		end
	end
	
	return nil, nil
end

local function Reset_Display()
	Disconnect_Cons()
	
	local Click_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Click_SE")
	if(Click_SE ~= nil)then
		Click_SE:Play()
	end
	
	Main_F:TweenPosition(UDim2.new(0.5, 0, -0.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
	if(UIS.TouchEnabled)then
		Takedown_Prog_F.Visible = false
	else
		Takedown_Prog_F:TweenPosition(UDim2.new(0.625, 0, 1.15, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
	end
	
	--Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true)
	--Bindable_Events_F:WaitForChild("Mobile_Takedown_Toggle"):Fire(false)
	Debounce_UI = false
end

local function Display_Tracking(Tracking_Val)
	local Your_Name, Other_Name = Char.Name, Char.Name
	
	local function Reset_UI()
		Disconnect_Cons()
		Main_F.Position = UDim2.new(0.5, 0, -0.5, 0)
		Main_Txt.Text = "Takedown Tracking: " .. Special_Txt("Continue to Inflict Strikes!", Color3.fromRGB(170, 0, 0))
		
		if(UIS.GamepadEnabled)then
			Key_Txt.Text = "Y"
		else
			Key_Txt.Text = "R"
		end
		
		local function Reset_Takedown_Prog_Circle()
			Takedown_Prog_F.Visible = false
			Takedown_Prog_F.Position = UDim2.new(0.5, 0, -1.15, 0)
			
			Per_Data_Txt.Text = "0%"
			Per_Data_Txt.TextColor3 = Color3.fromRGB(200, 200, 200)
			
			First_Half.Rotation = 0
			Second_Half.Rotation = 0
			Main_Cover.Rotation = 0
			
			if(UIS.TouchEnabled == true)then
				Button_F.Visible = false
				Key_F.Visible = false
			elseif(UIS.GamepadEnabled)then
				Button_F.Visible = true
				Key_F.Visible = false
			else
				Button_F.Visible = false
				Key_F.Visible = true
			end
		end
		Reset_Takedown_Prog_Circle()
		
		Key_Txt.Visible = false
		Icon_Img.Visible = true
		
		for Plr_Name, Prog in next, Tracking_Val:GetAttributes() do
			if(Plr_Name == Char.Name)then
				Your_Name_Txt.Text = Plr_Name .. ""
				Your_Bar_F.Size = UDim2.new(0, 0, 1, 0)
				Your_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
			else
				local name = if string.len(Plr_Name) > string.len("ONLYTWENTYCHARACTERS") then "Bot" else Plr_Name .. ""
				Other_Name_Txt.Text = name
				Other_Bar_F.Size = UDim2.new(0, 0, 1, 0)
				Other_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
				
				Other_Name = Plr_Name
			end
		end
	end
	Reset_UI()
	
	local function Set_Up_Connections()
		local function Get_Prog_Total()
			local Total, Your_Val, Other_Val = 0, 0, 0

			for Plr_Name, Prog in next, Tracking_Val:GetAttributes() do
				if(Plr_Name == Char.Name)then
					Your_Val = Prog
				else
					Other_Val = Prog
				end
				
				Total += Prog
			end
			
			
			return Total, Your_Val, Other_Val
		end
		
		local function Update_Prog_Wheel(Your_X, Prog_Total)
			--need at least 75% of the total, 850 is minimum
			local Tween_Rot = TweenInfo.new(0.375, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
			
			Prog_Total *= 0.75
			if(Prog_Total < 850)then
				Prog_Total = 850
			end
			
			local Dif = math.clamp(Your_X / Prog_Total, 0, 1)
			local Per_Txt = math.round(Dif * 100)
			Per_Data_Txt.Text = math.clamp(Per_Txt, 0, 100) .. "%"
			
			if(Per_Txt >= 100)then
				Per_Data_Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
			else
				Per_Data_Txt.TextColor3 = Color3.fromRGB(200, 200, 200)
			end
			
			if(Dif < 0.5) then
				--less than Half
				Main_Cover.Visible = true
				local Rot_Dif = (Dif / 0.5) * 180
				TS:Create(Main_Cover, Tween_Rot, {Rotation = Rot_Dif}):Play()
				TS:Create(Second_Half, Tween_Rot, {Rotation = 0}):Play()
			else
				--Over Half
				Main_Cover.Visible = false
				local Rot_Dif = ((Dif - 0.5) / 0.5) * 180
				TS:Create(Second_Half, Tween_Rot, {Rotation = Rot_Dif}):Play()
			end
		end
		
		local function Update_Prog_Displays()
			local Prog_Total, Your_Val, Other_Val = Get_Prog_Total()
			local Your_X = math.clamp(Your_Val / Prog_Total, 0, 1)
			local Other_X = math.clamp(Other_Val / Prog_Total, 0, 1)
			
			Update_Prog_Wheel(Your_Val, Prog_Total)
			
			if(Your_X > 0)then
				Your_X /= 2
			end
			
			if(Other_X > 0)then
				Other_X /= 2
			end
			
			Your_Bar_F:TweenSize(UDim2.new(Your_X, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.375, true, nil)
			Other_Bar_F:TweenSize(UDim2.new(Other_X, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.375, true, nil)	
			
			if(Tracking_Val.Value == true)then
				if(Your_Val > Other_Val)then
					Your_Bar_F.BackgroundColor3 = Color3.fromRGB(35, 244, 68)
					Other_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
				else
					Your_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
					Other_Bar_F.BackgroundColor3 = Color3.fromRGB(35, 244, 68)
				end
			else
				Your_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
				Other_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
			end	
		end
		Update_Prog_Displays()
		
		table.insert(Cons, Tracking_Val.AttributeChanged:Connect(function(Attrib_Key)
			Update_Prog_Displays()
		end))
		
		local RS_Con = nil
		local function Update_Tracking_Displays()
			if(RS_Con ~= nil)then
				RS_Con:Disconnect()
				RS_Con = nil
			end
			
			if(Tracking_Val.Value == true)then
				local Prog_Total, Your_Val, Other_Val = Get_Prog_Total()
				
				if(Your_Val > Other_Val)then
					--Your Turn
					Your_Bar_F.BackgroundColor3 = Color3.fromRGB(35, 244, 68)
					Other_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
					
					Key_Txt.Visible = true
					Icon_Img.Visible = false
					
					Main_Txt.Text = "Takedown Tracking: " .. Special_Txt("Get within Strking Distance!", Color3.fromRGB(35, 244, 68))
				
					local function Get_Other_HRP()
						for Plr_Name, Prog in next, Tracking_Val:GetAttributes() do
							if(Plr_Name ~= Char.Name and game.Workspace:FindFirstChild(Plr_Name) ~= nil)then
								local Other_Char = game.Workspace:FindFirstChild(Plr_Name)
								local O_HRP = Other_Char:FindFirstChild("HumanoidRootPart")
								if(O_HRP ~= nil)then
									return O_HRP
								end
							end
						end

						return nil
					end
					local O_HRP = Get_Other_HRP()
				
					local function Is_Within_Striking_Distance()
						--Get the other Character & HRP from the Tracking Data
						--Get the Distance between the 2 HRP's
						--True or False return
						if(HRP ~= nil and O_HRP ~= nil and 
							(HRP.Position - O_HRP.Position).Magnitude <= 10)then
							
							return true
						end
						
						return false
					end
				
					RS_Con = RS.Stepped:Connect(function()
						if(Is_Within_Striking_Distance())then
							Main_Txt.Text = "Takedown Tracking: " .. Special_Txt("Go To the Ground!", Color3.fromRGB(35, 244, 68))
						else
							Main_Txt.Text = "Takedown Tracking: " .. Special_Txt("Get within Strking Distance!", Color3.new(1, 0, 0))
						end
					end)
					table.insert(Cons, RS_Con)
					
					Bindable_Events_F:WaitForChild("Mobile_Takedown_Toggle"):Fire(true)
				else
					--Avoid the other Guy
					Your_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
					Other_Bar_F.BackgroundColor3 = Color3.fromRGB(35, 244, 68)
					
					Key_Txt.Visible = false
					Icon_Img.Visible = true
					
					Main_Txt.Text = "Takedown Tracking: " .. Special_Txt("Keep your Distance!", Color3.fromRGB(255, 170, 0))
					
					Bindable_Events_F:WaitForChild("Mobile_Takedown_Toggle"):Fire(false)
				end
			else
				Key_Txt.Visible = false
				Icon_Img.Visible = true
				
				Your_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
				Other_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
				
				Main_Txt.Text = "Takedown Tracking: " .. Special_Txt("Continue to Inflict Strikes!", Color3.fromRGB(170, 0, 0))
				Bindable_Events_F:WaitForChild("Mobile_Takedown_Toggle"):Fire(false)	
			end
		end
		Update_Tracking_Displays()
		
		table.insert(Cons, Tracking_Val.Changed:Connect(function()
			Update_Tracking_Displays()
		end))
		
		--Health and Stam display Tracking
		
		local function Update_Bar_Prog(Bar_F, Val_Txt, Current_Val)
			local Dif = math.clamp(Current_Val / 100, 0, 1)
			Bar_F:TweenSize(UDim2.new(Dif, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
			Val_Txt.Text = Current_Val .. ""
			
			if(string.match(Bar_F.Parent.Name, "Health") ~= nil)then
				local function Update_Color(Col)
					local All_C = Bar_F:GetChildren()
					for i = 1, #All_C do
						if(All_C[i] ~= nil and All_C[i]:IsA("Frame"))then
							All_C[i].BackgroundColor3 = Col
						end
					end
				end
				
				if(Dif <= 0.25)then
					Update_Color(Color3.fromRGB(170, 0, 0))
				elseif(Dif <= 0.6)then
					Update_Color(Color3.new(1, 1, 0))
				else
					Update_Color(Color3.fromRGB(0, 255, 127))
				end
			end
		end
		
		local Your_Health_V, Your_Stam_V = Get_Fight_Data_Vals(Your_Name)
		if(Your_Health_V ~= nil)then
			Update_Bar_Prog(Your_Health_Bar_F, Your_Health_Txt, Your_Health_V.Value)
			
			table.insert(Cons, Your_Health_V.Changed:Connect(function()
				Update_Bar_Prog(Your_Health_Bar_F, Your_Health_Txt, Your_Health_V.Value)
			end))
		end
		
		if(Your_Stam_V ~= nil)then
			Update_Bar_Prog(Your_Stam_Bar_F, Your_Stam_Txt, Your_Stam_V.Value)

			table.insert(Cons, Your_Stam_V.Changed:Connect(function()
				Update_Bar_Prog(Your_Stam_Bar_F, Your_Stam_Txt, Your_Stam_V.Value)
			end))
		end
		
		local Other_Health_V, Other_Stam_V = Get_Fight_Data_Vals(Other_Name)
		if(Other_Health_V ~= nil)then
			warn(Other_Health_V.Value)
			Update_Bar_Prog(Other_Health_Bar_F, Other_Health_Txt, Other_Health_V.Value)

			table.insert(Cons, Other_Health_V.Changed:Connect(function()
				warn(Other_Health_V.Value)
				Update_Bar_Prog(Other_Health_Bar_F, Other_Health_Txt, Other_Health_V.Value)
			end))
		end

		if(Other_Stam_V ~= nil)then
			Update_Bar_Prog(Other_Stam_Bar_F, Other_Stam_Txt, Other_Stam_V.Value)

			table.insert(Cons, Other_Stam_V.Changed:Connect(function()
				Update_Bar_Prog(Other_Stam_Bar_F, Other_Stam_Txt, Other_Stam_V.Value)
			end))
		end
	
		if(Tracking_Val.Parent ~= nil and Tracking_Val.Parent:FindFirstChild("Round_Count") ~= nil)then
			local Round_Count_V = Tracking_Val.Parent:FindFirstChild("Round_Count")
			Round_Change_Handle(Round_Count_V)
		end
		
		table.insert(Cons, Bindable_Events_F:WaitForChild("Toggle_Takedown_Prog_Button").Event:Connect(function(Should_Show)
			Takedown_Prog_F.Visible = Should_Show
		end))	
	end
	Set_Up_Connections()
	
	local function Display_UI()
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
		
		if(UIS.TouchEnabled == false)then
			Takedown_Prog_F.Visible = true
			Takedown_Prog_F:TweenPosition(UDim2.new(0.625, 0, 0.9125, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
		else
			task.spawn(function()
				wait()
				--Configure based on Mobile Button Size and Position
				local Size, Pos = Bindable_RF:WaitForChild("Get_Mobile_Button_Data"):Invoke()
				if(Size ~= nil and Pos ~= nil)then
					Takedown_Prog_F.Size = Size
					Takedown_Prog_F.Position = Pos
					Takedown_Prog_F.Visible = true
				end
			end)
		end
		
		local Click_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Click_SE")
		if(Click_SE ~= nil)then
			Click_SE:Play()
		end
		Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false)

		Debounce_UI = true
	end
	Display_UI()
end

Bindable_Events_F:WaitForChild("Display_Takedown_Tracking").Event:Connect(function(Can_Takedown)
	if(Debounce_UI == false and Can_Takedown)then
		local Tracking_Val = Get_Takedown_Tracking_Val()
		if(Tracking_Val ~= nil)then
			Display_Tracking(Tracking_Val)
		end
	else
		Reset_Display()
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXA6E79C1633EE47ECBC239F93E5747C9C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Submission_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXD723BB37739A41D88A1004E5EAFBE1D1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Old_Client_Fight_Code.client.lua</string>
							<string name="ScriptGuid">{ADFBB337-E049-4917-8EA4-AB0AB3A6234E}</string>
							<ProtectedString name="Source"><![CDATA[local MPS = game:GetService("MarketplaceService")
local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local Debis = game:GetService("Debris")
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")
local Sword_Swing_UI = PG:WaitForChild("Sword_Swing_UI")
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")
local Head = Char:WaitForChild("Head")
local Cam = game.Workspace.CurrentCamera
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Receiving_F = Channels_F:WaitForChild("Server_Client_F")
local Sending_F = Channels_F:WaitForChild("Client_Server_F")
local Sending_RF = Sending_F:WaitForChild("RF")
local Data_Mod_F = game.ReplicatedStorage:WaitForChild("Data_Modules_F")
local Monetization_Mod = require(Data_Mod_F:WaitForChild("Monetization_Mod"))
local Client_Swing_Events_F = game.ReplicatedStorage:WaitForChild("Client_Click_Events_F")

local SE = script.Parent.SE
local PVP_Leave_B = script.Parent.Leave_PVP_Button
local CD_Txt = script.Parent.CD_Txt
local Auto_Click_B = script.Parent.Auto_Click_B
local Double_Wins_B = script.Parent.Double_Wins_B
local Main_F = script.Parent.Main_Bar_F

local Debounce_C = false
local Debounce_E = false
local Debounce_UI = false
local Is_Auto_Clicking = false

local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Format_Number(V)
	local function Format_Number(n)
		n = tostring(n)
		return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
	end

	if(V < 1000000)then
		return Format_Number(V)
	else
		local function Net_Worth_Convert(V)
			if(V < 1000)then
				return V .. ""
			else
				local FM_Txt = Format_Number(V)
				local FM = string.split(FM_Txt, ",")

				local function Truncate_Txt(Txt)
					local First_P = FM[1]
					local Sec_P = FM[2]

					if(string.len(First_P) == 3)then
						Sec_P = string.sub(Sec_P, 1, 1)
					elseif(string.len(Sec_P) == 3)then
						Sec_P = string.sub(Sec_P, 1, 2)
					end

					if(Sec_P == "00" or Sec_P == "000")then
						Sec_P = "0"
					end

					return First_P .. "." .. Sec_P .. Txt
				end

				if(V < 1000000)then
					--K
					return Truncate_Txt("K")
				elseif(V < 1000000000)then
					--M
					return Truncate_Txt("M")
				elseif(V < 1000000000000)then
					--B
					return Truncate_Txt("B")
				elseif(V < 1000000000000000)then
					--TRILLION
					return Truncate_Txt("T")
				else
					--Bigger than 1 Trillion!
					local Num_String_Mod = require(game.ReplicatedStorage:FindFirstChild("Data_Modules_F"):FindFirstChild("NumToString"))
					return Num_String_Mod.NumToString(V)
				end
			end
		end
		return Net_Worth_Convert(V)
	end
end

local function Get_Player_Val(Plr, Val_Name)
	local PD = Plr:WaitForChild("Player_Data")
	if(PD ~= nil)then
		local Val = PD:WaitForChild(Val_Name)
		if(Val ~= nil)then
			return Val.Value
		end
	end	

	return nil
end

local function Get_Thumbnail_Pic(P)
	local function Async()
		local Data = nil
		local Type = Enum.ThumbnailType.HeadShot
		local Size = Enum.ThumbnailSize.Size420x420
		local success, errormessage = pcall(function()
			Data = game.Players:GetUserThumbnailAsync(P.UserId, Type, Size)
		end)
		
		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end
	
	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end
	return "0000"
end
local Avatar_Pic = Get_Thumbnail_Pic(Plr)

local function Update_Swing_Button(Show)
	local Button = Sword_Swing_UI:WaitForChild("Swing_Button_F")
	if(Show == false and (UIS.GamepadEnabled or UIS.TouchEnabled == false))then
		Button.Visible = false
	else
		Button.Visible = true
	end
end

local function Toggle_NPC_Fight_Prompts(Show)
	local NPC_F = game.Workspace:WaitForChild("NPC_Fights_F"):GetChildren()
	for i = 1, #NPC_F do
		local Prompt = NPC_F[i]:FindFirstChild("Prompt_P"):FindFirstChildWhichIsA("ProximityPrompt")
		if(Prompt ~= nil)then
			Prompt.Enabled = Show
		end
	end
end

local function Show_UI(Fight_Data, Is_Inc)
	local Swing_Event = Client_Swing_Events_F:WaitForChild(Plr.UserId .. "_Event")
	local Fight_M = Fight_Data['Model']
	local Cam_P = Fight_M:FindFirstChild("Cam_P")
	local Damage_Index = Fight_M:FindFirstChild("Damage_Index_" .. Plr.UserId)
	local Swing_BF = Sword_Swing_UI:WaitForChild("Local_Bindables_F")
	local Is_PVP_Fight = (Fight_Data['Player_1'] ~= nil or Fight_Data['Player_2'] ~= nil)
	
	if(Is_PVP_Fight or Damage_Index == nil)then
		--Is PVP Fighting Handle
		Damage_Index = Fight_M:FindFirstChild("Damage_Index")
	end

	local function Auto_Clicking_Handle()
		--Update Text Bar
			--> Send Event to Click Handle
		--> Have special function for this on Server
		local Local_BF = Sword_Swing_UI:WaitForChild("Local_Bindables_F")
		local Swing_Ani = Local_BF:WaitForChild("Play_Single_Swing") 
		
		while Debounce_UI do
			if(Main_F.Click_Txt.Visible == true)then
				Main_F.Click_Txt.Text = "Start Tapping! (20/s)"
				Swing_Ani:Fire(Color3.new(0, 1, 0))
				Swing_Event:FireServer("Auto Click")
				local WT = math.clamp(0.125 - (Plr:GetNetworkPing() * 2000), 0.05, 0.125)
				wait(WT)

				if(Debounce_UI)then
					Swing_Ani:Fire(Color3.new(0, 1, 0))
					wait(0.125)
				end
				
			else
				wait(0.125)
			end
		end
	end

	local function Auto_Fight_Handle()
		
		local Local_BF = Sword_Swing_UI:WaitForChild("Local_Bindables_F")
		local Swing_Ani = Local_BF:WaitForChild("Play_Single_Swing") 

		while Debounce_UI and Swing_BF:WaitForChild("Is_Auto_On"):Invoke(true) and Is_Auto_Clicking == false do
			
			if(Main_F.Click_Txt.Visible == true)then
				Main_F.Click_Txt.Text = "Start Tapping! (5/s)"
				Swing_Ani:Fire(Color3.new(0, 1, 0))
				Swing_Event:FireServer("Fighting")
				local WT = math.clamp(0.125 - (Plr:GetNetworkPing() * 2000), 0.05, 0.125)
				wait(WT)
			else
				wait(0.125)
			end
		end
	end
	
	local function Reset_UI()
		Disconnect_Cons()
		CD_Txt.Visible = false
		
		PVP_Leave_B.Visible = false
		PVP_Leave_B.Position = UDim2.new(0.5, 0, 1.5, 0)
		
		Main_F.Position = UDim2.new(0.5, 0, 0.95, 0)
		Auto_Click_B.Position = UDim2.new(0.7875, 0, 0.8875, 0)
		Double_Wins_B.Position = UDim2.new(0.2125, 0, 0.8875, 0)
		
		Main_F.Player_Bar_F.Size = UDim2.new(0.5, 0, 1, 0)
		Main_F.Click_Txt.Visible = false
		Main_F.Click_Txt.Text = "Start Tapping! (0%)"
		
		Cam.FieldOfView = 60
		Cam.CameraType = Enum.CameraType.Scriptable
		Cam.CFrame = Cam_P.CFrame
		
		Main_F.Visible = true
		
		Is_Auto_Clicking = false
		
		if(Is_PVP_Fight)then
			Auto_Click_B.Visible = false
			Double_Wins_B.Visible = false
			
			Auto_Click_B.Position = UDim2.new(0.7875, 0, 1.5, 0)
			Double_Wins_B.Position = UDim2.new(0.2125, 0, 1.5, 0)
		else
			Auto_Click_B.Visible = true
			Double_Wins_B.Visible = true
		end
		
		local Destroy_Blur = Instance.new("BlurEffect", game.Lighting)
		Destroy_Blur.Name = "FIGHTINGBLUR"
		Destroy_Blur.Enabled = false
		Debis:AddItem(Destroy_Blur, 0.1)
		
		PG:WaitForChild("Cover_UI").Enabled = true
	end
	Reset_UI()
	
	local function Update_Opponent_Tab()
		local Opp_F = Main_F.Opponent_F
		
		if(Is_PVP_Fight == false)then
			Opp_F.Power_F.Power_Txt.Text = Format_Number(Fight_Data['NPC Power'])
			Opp_F.P_Name.Text = Fight_Data['Name']
			Opp_F.Image = Fight_Data['Icon Img']
		else
			local Opp_Plr = Fight_Data['Player_1']
			if(Opp_Plr == Plr)then
				Opp_Plr = Fight_Data['Player_2']
			end
			
			if(Opp_Plr == nil)then
				return
			end
			
			local Power_V = Get_Player_Val(Opp_Plr, "Power")
			Opp_F.Power_F.Power_Txt.Text = Format_Number(Power_V)
			Opp_F.P_Name.Text = Opp_Plr.Name
			Opp_F.Image = Get_Thumbnail_Pic(Opp_Plr)
		end
	end
	Update_Opponent_Tab()
	
	local function Update_Your_Tab()
		local Plr_F = Main_F.Plr_F
		local Power_V = Get_Player_Val(Plr, "Power")
		Plr_F.Power_F.Power_Txt.Text = Format_Number(Power_V)
		Plr_F.P_Name.Text = Plr.Name
		Plr_F.Image = Avatar_Pic
	end
	Update_Your_Tab()
	
	local function Button_Handle()
		local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
		local B_Def_X, B_Def_Y = 0.1125, 0.0675
		local B_Def_Size = UDim2.new(B_Def_X, 0, B_Def_Y, 0)
		local B_Hover_Size = UDim2.new(0.75, 0, 0.075, 0)
		local B_Click_Size = UDim2.new(B_Def_X * 0.75, 0, B_Def_Y * 0.75, 0)
		
		local function Hover_Effects(B, Default_Size, Hover_Size)
			local Selected = B:FindFirstChild("Selected")
			B.Size = Default_Size

			table.insert(Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false and B.Visible == true)then
					Debounce_E = true
					SE.Hover_SE:Play()
					B:TweenSize(Hover_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
					wait(0.125)
					Debounce_E = false
				end
			end))

			table.insert(Cons, Selected.MouseLeave:Connect(function()
				B:TweenSize(Default_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
			end))
		end
		Hover_Effects(Auto_Click_B, B_Def_Size, B_Hover_Size)
		Hover_Effects(Double_Wins_B, B_Def_Size, B_Hover_Size)
		
		table.insert(Cons, Auto_Click_B.Selected.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				SE.Click_SE:Play()
				TS:Create(Auto_Click_B, Tween_Click, {Size = B_Click_Size}):Play()
				
				local Owned_Keys = Monetization_Mod.Get_Player_Owned_Gamepasses_Keys(Plr)
				if(table.find(Owned_Keys, "B") == nil)then
					MPS:PromptGamePassPurchase(Plr, 262397442)
				elseif(Is_Auto_Clicking == false)then
					Is_Auto_Clicking = true
					Bindable_F:WaitForChild("Events"):WaitForChild("Display_Data"):Fire(" Auto Clicking is On!", Color3.fromRGB(0, 170, 255))
					Auto_Clicking_Handle()
				end
				
				wait(0.25)
				Debounce_C = false
			end
		end))
		
		table.insert(Cons, Double_Wins_B.Selected.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				SE.Click_SE:Play()
				TS:Create(Auto_Click_B, Tween_Click, {Size = B_Click_Size}):Play()

				local Owned_Keys = Monetization_Mod.Get_Player_Owned_Gamepasses_Keys(Plr)
				if(table.find(Owned_Keys, "E") == nil)then
					MPS:PromptGamePassPurchase(Plr, 262398078)
				else
					Bindable_F:WaitForChild("Events"):WaitForChild("Display_Data"):Fire(" You already own Double Wins!", Color3.fromRGB(0, 225, 0))
				end

				wait(0.25)
				Debounce_C = false
			end
		end))
	end
	
	if(Is_PVP_Fight == false)then
		Button_Handle()
	end
	
	Update_Swing_Button(false)
	
	local function Update_Damage_Data()
		--Update the Power Bar, Camera FOV, Update Clicking per Second data
		local function Get_X_Size()
			--> If Closer to 0
				--> Losing, Should be smaller
				--> Winning, should be bigger
			--FLIP IF IS_INC == FALSE
			local Midpoint = math.ceil(Fight_Data['Max Damage'] / 2)
			if(Is_Inc)then
				if(Damage_Index.Value > Midpoint)then
					--Winning
					local Dif = (Fight_Data['Max Damage'] - Damage_Index.Value) / Midpoint
					local Multi = 1 - Dif
					return 0.5 + (0.5 * Multi)
				else
					--Losing
					local Dif = (Midpoint - Damage_Index.Value) / Midpoint
					local Multi = 1 - Dif
					return 0.5 * Multi
				end
			else
				--Winning Closer to 0 == 1
				return (Fight_Data['Max Damage'] - Damage_Index.Value) / Fight_Data['Max Damage']
			end

		end
		local X_Size = math.clamp(Get_X_Size(), 0, 1)
		Main_F.Player_Bar_F:TweenSize(UDim2.new(X_Size, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
		
		local Update_Tween = TweenInfo.new(0.125, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
		local FOV = math.clamp(50 + (40 * X_Size), 50, 90)
		TS:Create(Cam, Update_Tween, {FieldOfView = FOV}):Play()
	end
	
	local function Victory_Or_Loss_Sound(Did_Lose)
		if(Did_Lose)then
			SE.Lost_SE:Play()
		else
			SE.Win_SE:Play()
		end
		
		Toggle_NPC_Fight_Prompts(true)
	end
	
	table.insert(Cons, Damage_Index.AncestryChanged:Connect(function()
		
		if(Damage_Index:IsDescendantOf(game.Workspace) == false)then
			--End
			local Tween_Cam = TweenInfo.new(3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)

			Disconnect_Cons()
			Victory_Or_Loss_Sound(Damage_Index.Value <= 0 and Is_Inc)

			CD_Txt.Visible = false
			Main_F.Click_Txt.Visible = false
			Main_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
			Auto_Click_B:TweenPosition(UDim2.new(0.7875, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
			Double_Wins_B:TweenPosition(UDim2.new(0.2125, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)

			TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
			PG:WaitForChild("Cover_UI").Enabled = false

			wait(3)

			Cam.CameraSubject = Hum
			Cam.CameraType = Enum.CameraType.Custom
			Cam.CFrame = Head.CFrame
			Cam.FieldOfView = 70

			Main_F.Visible = false
			Auto_Click_B.Visible = false
			Double_Wins_B.Visible = false

			Main_F.Position = UDim2.new(0.5, 0, 0.95, 0)
			Auto_Click_B.Position = UDim2.new(0.7875, 0, 0.8875, 0)
			Double_Wins_B.Position = UDim2.new(0.2125, 0, 0.8875, 0)

			Debounce_UI = false
			Debounce_C = false
			Debounce_E = false

			Update_Swing_Button(true)

			--Check if Auto Fighting then, run it!
			wait(0.75)
			if(Swing_BF:WaitForChild("Is_Auto_On"):Invoke(true))then
				local Current_Fight_M = Bindable_F:WaitForChild("RF"):WaitForChild("Get_Current_Auto_Fight"):Invoke()
				if(Current_Fight_M == nil)then
					Bindable_F:WaitForChild("Events"):WaitForChild("Open_Auto_Fight"):Fire()
				else
					local Res = Sending_RF:WaitForChild("Auto_Fight_Handle"):InvokeServer(Current_Fight_M)
					if(Res == false)then
						local Txt = " Someone else is Fighting that Samurai, Select a different Samurai!"
						Bindable_F:WaitForChild("Events"):WaitForChild("Display_Data"):Fire(Txt, Color3.new(1, 0, 0))
						Bindable_F:WaitForChild("Events"):WaitForChild("Open_Auto_Fight"):Fire()
					end
				end
			end
		end
	end))
	
	table.insert(Cons, Damage_Index.Changed:Connect(function()
		--Update the Power Bar, Camera FOV, Update Clicking per Second data
		Update_Damage_Data()
		
		--[[
		if(Damage_Index.Value <= 0 or Damage_Index.Value >= Fight_Data['Max Damage'])then
			--End
			local Tween_Cam = TweenInfo.new(3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
			
			Disconnect_Cons()
			Victory_Or_Loss_Sound(Damage_Index.Value <= 0 and Is_Inc)
			
			CD_Txt.Visible = false
			Main_F.Click_Txt.Visible = false
			Main_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
			Auto_Click_B:TweenPosition(UDim2.new(0.7875, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
			Double_Wins_B:TweenPosition(UDim2.new(0.2125, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
			
			TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
			PG:WaitForChild("Cover_UI").Enabled = false
			
			wait(3)
			
			Cam.CameraSubject = Hum
			Cam.CameraType = Enum.CameraType.Custom
			Cam.CFrame = Head.CFrame
			Cam.FieldOfView = 70
			
			Main_F.Visible = false
			Auto_Click_B.Visible = false
			Double_Wins_B.Visible = false
			
			Main_F.Position = UDim2.new(0.5, 0, 0.95, 0)
			Auto_Click_B.Position = UDim2.new(0.7875, 0, 0.8875, 0)
			Double_Wins_B.Position = UDim2.new(0.2125, 0, 0.8875, 0)
			
			Debounce_UI = false
			Debounce_C = false
			Debounce_E = false
			
			Update_Swing_Button(true)
			
			--Check if Auto Fighting then, run it!
			wait(0.75)
			if(Swing_BF:WaitForChild("Is_Auto_On"):Invoke(true))then
				local Current_Fight_M = Bindable_F:WaitForChild("RF"):WaitForChild("Get_Current_Auto_Fight"):Invoke()
				if(Current_Fight_M == nil)then
					Bindable_F:WaitForChild("Events"):WaitForChild("Open_Auto_Fight"):Fire()
				else
					local Res = Sending_RF:WaitForChild("Auto_Fight_Handle"):InvokeServer(Current_Fight_M)
					if(Res == false)then
						local Txt = " Someone else is Fighting that Samurai, Select a different Samurai!"
						Bindable_F:WaitForChild("Events"):WaitForChild("Display_Data"):Fire(Txt, Color3.new(1, 0, 0))
						Bindable_F:WaitForChild("Events"):WaitForChild("Open_Auto_Fight"):Fire()
					end
				end
			end
		end
		
				
		]]--
	end))
	
	table.insert(Cons, Receiving_F:WaitForChild("Events"):WaitForChild("Fight_Ended").OnClientEvent:Connect(function(Did_Win)
		--End
		local Tween_Cam = TweenInfo.new(3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)

		Disconnect_Cons()
		Victory_Or_Loss_Sound(not Did_Win)

		CD_Txt.Visible = false
		Main_F.Click_Txt.Visible = false
		Main_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
		Auto_Click_B:TweenPosition(UDim2.new(0.7875, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
		Double_Wins_B:TweenPosition(UDim2.new(0.2125, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
		PG:WaitForChild("Cover_UI").Enabled = false

		wait(3)

		Cam.CameraSubject = Hum
		Cam.CameraType = Enum.CameraType.Custom
		Cam.CFrame = Head.CFrame
		Cam.FieldOfView = 70

		Main_F.Visible = false
		Auto_Click_B.Visible = false
		Double_Wins_B.Visible = false

		Main_F.Position = UDim2.new(0.5, 0, 0.95, 0)
		Auto_Click_B.Position = UDim2.new(0.7875, 0, 0.8875, 0)
		Double_Wins_B.Position = UDim2.new(0.2125, 0, 0.8875, 0)

		Debounce_UI = false
		Debounce_C = false
		Debounce_E = false

		Update_Swing_Button(true)

		--Check if Auto Fighting then, run it!
		wait(0.75)
		if(Swing_BF:WaitForChild("Is_Auto_On"):Invoke(true))then
			local Current_Fight_M = Bindable_F:WaitForChild("RF"):WaitForChild("Get_Current_Auto_Fight"):Invoke()
			if(Current_Fight_M == nil)then
				Bindable_F:WaitForChild("Events"):WaitForChild("Open_Auto_Fight"):Fire()
			else
				local Res = Sending_RF:WaitForChild("Auto_Fight_Handle"):InvokeServer(Current_Fight_M)
				if(Res == false)then
					local Txt = " Someone else is Fighting that Samurai, Select a different Samurai!"
					Bindable_F:WaitForChild("Events"):WaitForChild("Display_Data"):Fire(Txt, Color3.new(1, 0, 0))
					Bindable_F:WaitForChild("Events"):WaitForChild("Open_Auto_Fight"):Fire()
				end
			end
		end
	end))
	
	local function CD_Handle()
		Toggle_NPC_Fight_Prompts(false)
		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
		
		local Trans_Tween = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
		
		local function Text_Effects(Txt)
			SE.Count_SE:Play()
			CD_Txt.Visible = false
			CD_Txt.TextTransparency = 1
			CD_Txt.TextStrokeTransparency = 1
			CD_Txt.Size = UDim2.new(0.75, 0, 0.75, 0)
			CD_Txt.Text = Txt
			
			CD_Txt.Visible = true
			TS:Create(CD_Txt, Trans_Tween, {TextTransparency = 0, TextStrokeTransparency = 0}):Play()
			CD_Txt:TweenSize(UDim2.new(0.15, 0, 0.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.125, true, nil)
			if Txt == "GO!" then
				local int = Instance.new("IntValue")
				local Tween = TS:Create(int, TweenInfo.new(0.875), {Value = 5})
				Tween:Play()
				Tween.Completed:Connect(function()
					int:Destroy()
					TS:Create(CD_Txt, Trans_Tween, {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
					CD_Txt:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.125, true, nil)
				end)
				wait(.5)
			else
				wait(0.875)
				TS:Create(CD_Txt, Trans_Tween, {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
				CD_Txt:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.125, true, nil)
				wait(0.125)
			end
		end
		--
		
		Text_Effects("3")
		Text_Effects("2")
		Text_Effects("1")

		Main_F.Click_Txt.Visible = true
		Text_Effects("GO!")
		
		Bindable_F:WaitForChild("Events"):WaitForChild("Click_Rate_Reset"):Fire()
		
		if(Is_Auto_Clicking == false and Swing_BF:WaitForChild("Is_Auto_On"):Invoke(true))then
			Auto_Fight_Handle()
		end
	end
	CD_Handle()
end

Receiving_F:WaitForChild("Events"):WaitForChild("Show_Fight_Data").OnClientEvent:Connect(function(Fight_M, Is_Inc, Cf)
	local int = Instance.new("IntValue")
	local tween = TS:Create(int, TweenInfo.new(.25), {Value = 5})
	tween:Play()
	tween.Completed:Connect(function()
		tween = TS:Create(int, TweenInfo.new(.25), {Value = 5})
		tween:Play()
		tween.Completed:Connect(function()
			int:Destroy()
			Plr.Character.PrimaryPart.CFrame = Cf
		end)
		Plr.Character.PrimaryPart.CFrame = Cf
	end)
	Show_UI(Fight_M, Is_Inc)
end)

Bindable_F:WaitForChild("RF"):WaitForChild("Is_Client_Fighting").OnInvoke = function()
	if(Debounce_UI)then
		if(Is_Auto_Clicking)then
			return "Auto"
		else
			return "Yes"
		end
	else
		return "No"
	end
end

Bindable_F:WaitForChild("RF"):WaitForChild("Idling_For_Fight").OnInvoke = function()
	if(Debounce_UI and Main_F.Click_Txt.Visible == false)then
		return true
	end
	
	return false
end

Bindable_F:WaitForChild("Events"):WaitForChild("Click_Rate_Update").Event:Connect(function(Rate)
	Main_F.Click_Txt.Text = "Start Tapping! (" .. Rate .. "/s)"
end)


local function PVP_Leave_Button_Handle()
	local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
	local B_Def_X, B_Def_Y = 0.15, 0.1
	local B_Def_Size = UDim2.new(B_Def_X, 0, B_Def_Y, 0)
	local B_Hover_Size = UDim2.new(0.1625, 0, 0.1125, 0)
	local B_Click_Size = UDim2.new(B_Def_X * 0.75, 0, B_Def_Y * 0.75, 0)

	local function Hover_Effects(B, Default_Size, Hover_Size)
		local Selected = B:FindFirstChild("Selected")
		B.Size = Default_Size

		Selected.MouseEnter:Connect(function()
			if(Debounce_E == false and B.Visible == true)then
				Debounce_E = true
				SE.Hover_SE:Play()
				B:TweenSize(Hover_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
				wait(0.125)
				Debounce_E = false
			end
		end)

		Selected.MouseLeave:Connect(function()
			B:TweenSize(Default_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
		end)
	end
	Hover_Effects(PVP_Leave_B, B_Def_Size, B_Hover_Size)

	PVP_Leave_B.Selected.MouseButton1Click:Connect(function()
		if(Debounce_C == false and PVP_Leave_B.Visible == true and 
			PVP_Leave_B.Position == UDim2.new(0.5, 0, 0.9, 0))then
			
			Debounce_C = true
			SE.Click_SE:Play()
			
			--Reset Camera
			--Move Button down
			--Send Event to Server to get them off Platform & Data, Reset WalkSpeed and Jump, 
			
			Update_Swing_Button(true)
			PVP_Leave_B:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
			Cam.CameraSubject = Hum
			Cam.CameraType = Enum.CameraType.Custom
			Cam.CFrame = Head.CFrame
			Cam.FieldOfView = 70
			
			Sending_F:WaitForChild("Events"):WaitForChild("Remove_From_PVP"):FireServer()
			
			wait(0.75)
			PVP_Leave_B.Visible = false
			PVP_Leave_B.Position = UDim2.new(0.5, 0, 1.5, 0)
			
			Debounce_C = false
		end
	end)
end
PVP_Leave_Button_Handle()

Receiving_F:WaitForChild("Events"):WaitForChild("Show_PVP_Leave").OnClientEvent:Connect(function(Cam_CF)
	SE.Click_SE:Play()
	Update_Swing_Button(false)
	
	PVP_Leave_B.Visible = false
	PVP_Leave_B.Position = UDim2.new(0.5, 0, 1.5, 0)
	PVP_Leave_B.Size = UDim2.new(0.15, 0, 0.1, 0)
	PVP_Leave_B.Visible = true
	PVP_Leave_B:TweenPosition(UDim2.new(0.5, 0, 0.9, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
	
	Cam.FieldOfView = 60
	Cam.CameraType = Enum.CameraType.Scriptable
	Cam.CFrame = Cam_CF
end)

function Init_Camera_Reset()
	if(Cam.CameraType == Enum.CameraType.Scriptable)then
		Cam.CameraSubject = Hum
		Cam.CameraType = Enum.CameraType.Custom
		Cam.CFrame = Head.CFrame
		Cam.FieldOfView = 70
	end
end
Init_Camera_Reset()]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB2DDCF8F84B24B41A64767ECA99DF25B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Click_Rate_System.client.lua</string>
							<string name="ScriptGuid">{17D8D7DA-3554-4D10-BA8D-A19DDBAB7B84}</string>
							<ProtectedString name="Source"><![CDATA[--Use to track Client Clicking Speed
	--> On Click Event
		--> Sent Rate Event
	--> Reset Rate Event
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")

local Start_Time, Total_Clicks = os.time(), 0

local function Round_Rate(Raw_Rate)
	local Boosted_Rate = math.ceil(Raw_Rate * 10)
	return Boosted_Rate / 10
end

Bindable_Events_F:WaitForChild("Click_Rate_Reset").Event:Connect(function()
	Start_Time, Total_Clicks = os.time(), 0
end)

Bindable_Events_F:WaitForChild("Click_Rate_Inc").Event:Connect(function()
	local Current_Time = os.time()
	if(Total_Clicks == 0)then
		Start_Time = Current_Time
		Total_Clicks = 1
	else
		Total_Clicks = Total_Clicks + 1
	end
	
	local Rate = Round_Rate(Total_Clicks / (Current_Time - Start_Time))
	Bindable_Events_F:WaitForChild("Click_Rate_Update"):Fire(Rate)
end)]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX150D94F931104375829CA581EC9D3836">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Client_Submission_Handle.client.lua</string>
							<string name="ScriptGuid">{704C9206-843B-4EAB-BB05-F7E1CE3EF876}</string>
							<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------
-- Client_Submission_Handle
-- Author : Dark
-- Created: 2025-09-20
--------------------------------------------------------------------

local storage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TS = game:GetService("TweenService")
local myPlayer = game.Players.LocalPlayer
local Char = myPlayer.Character or myPlayer.CharacterAdded:Wait()
local Cam = game.Workspace.CurrentCamera
local PlayerModule = require(myPlayer:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"))
--Remotes
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Show_Flash_E = Bindable_Events_F:WaitForChild("Show_White_Fade")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local startEvent = Receiving_Events_F:WaitForChild("Start_Submission")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Heart_Beat_SE = Sound_Effect_Mod.Get_SE_Object(myPlayer, "Heartbeat_SE")
--UI Elements
local fightingGui = script.Parent
local mainBarFrame = fightingGui:WaitForChild("Main_Bar_F")
local myPlayerBar = mainBarFrame:WaitForChild("Player_Bar_F")
local Click_Txt = mainBarFrame:WaitForChild("Click_Txt")
local opponentThumbnail = mainBarFrame:WaitForChild("Opponent_F")
local playerThumbnail = mainBarFrame:WaitForChild("Plr_F")
local inGame = false
local clickConnection = nil
local progressConnection = nil
local Player_Thumbnail_Data = {
	}
	local function Get_Player_Thumbnail(ID)
	if(Player_Thumbnail_Data[ID] ~= nil)then
		return Player_Thumbnail_Data[ID]
	else
	local Type = Enum.ThumbnailType.HeadShot
	local Size = Enum.ThumbnailSize.Size420x420
	local function Async()
	local Data = nil
	local success, errormessage = pcall(function()
	Data = game.Players:GetUserThumbnailAsync(ID, Type, Size)
	end)
	if(success and Data ~= nil)then
		return Data
	end
	return nil
end
for i = 1, 3 do
	local D = Async()
	if(D ~= nil)then
		Player_Thumbnail_Data[ID] = D
		return D
	end
end
return "rbxassetid://100127687172105"
end
end
local function StartGame(flip : boolean, clickedEvent, P1, P2)
PlayerModule:GetControls():Enable(false)

local Update_Tween = TweenInfo.new(0.125, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
TS:Create(Cam, Update_Tween, {FieldOfView = 70}):Play()

clickConnection = UserInputService.InputBegan:Connect(function(input : InputObject, gpe : boolean)
if gpe then
	return
end

if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 or input.KeyCode == Enum.KeyCode.ButtonR2 then
	clickedEvent:FireServer()
	Bindable_Events_F:WaitForChild("Click_Rate_Inc"):Fire()
end
end)

progressConnection = clickedEvent.OnClientEvent:Connect(function(informationTable)
	local progress = informationTable.gameProgress / 100
	if flip then
		progress = 1 - progress
	end
	myPlayerBar.Size = UDim2.fromScale(progress, myPlayerBar.Size.Y.Scale)

	local FOV = math.clamp(70 - (25 * progress), 45, 70)
	TS:Create(Cam, Update_Tween, {FieldOfView = FOV}):Play()
end)

inGame = true

local Submission_Char_V = clickedEvent.Parent
local Is_Attacking = (Submission_Char_V.Value == Char)
Bindable_Events_F:WaitForChild("On_Submission_Handle"):Fire(Is_Attacking, true)

local function Display_Handle()
Bindable_Events_F:WaitForChild("Click_Rate_Reset"):Fire()

local function Update_Icon_Images()
opponentThumbnail.Image = "rbxassetid://100127687172105"
playerThumbnail.Image = "rbxassetid://100127687172105"

if(P1 ~= nil)then
	local Image = Get_Player_Thumbnail(P1.UserId)
	if(P1 == myPlayer)then
		playerThumbnail.Image = Image
	else
	opponentThumbnail.Image = Image
end
end

if(P2 ~= nil)then
	local Image = Get_Player_Thumbnail(P2.UserId)
	if(P2 == myPlayer)then
		playerThumbnail.Image = Image
	else
	opponentThumbnail.Image = Image
end
end
end
Update_Icon_Images()

mainBarFrame.Visible = false
mainBarFrame.Position = UDim2.new(0.5, 0, 1.25, 0)
mainBarFrame:TweenPosition(UDim2.new(0.5, 0, 0.975, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
mainBarFrame.Visible = true

Bindable_Events_F:WaitForChild("Toggle_Takedown_Prog_Button"):Fire(false)
end
Display_Handle()

local function Show_Heart_Beat_Effects()
if(Heart_Beat_SE ~= nil)then
	Heart_Beat_SE:Play()
end

while inGame do
	for i = 1, 2 do
		if(inGame)then
			Show_Flash_E:Fire(Color3.fromRGB(255, 75, 75))
			wait(0.75)
		end
	end
	wait(1)
end

if(Heart_Beat_SE ~= nil)then
	Heart_Beat_SE:Stop()
end
end
task.spawn(Show_Heart_Beat_Effects)
end
local function EndGame()
PlayerModule:GetControls():Enable(true)

if clickConnection then
	clickConnection:Disconnect()
end

if progressConnection then
	progressConnection:Disconnect()
end

inGame = false

mainBarFrame:TweenPosition(UDim2.new(0.5, 0, 1.25, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.375, true, nil)
Bindable_Events_F:WaitForChild("On_Submission_Handle"):Fire(false, false)
Bindable_Events_F:WaitForChild("Toggle_Takedown_Prog_Button"):Fire(true)
end
startEvent.OnClientEvent:Connect(function(command : string, args : {}, clicked_Event)
if command == "START" then
	if inGame then
		warn("Player in game already")
		return
	end
	--print(args)
	--opponentThumbnail.Image = args.imageIDs[2]
	--playerThumbnail.Image = args.imageIDs[1]
	
	StartGame(args.flip, clicked_Event, args.P1, args.P2)
elseif command == "STOP" then
	EndGame()
end

end)
Bindable_Events_F:WaitForChild("Click_Rate_Update").Event:Connect(function(Rate)
Click_Txt.Text = "Start Tapping! (" .. Rate .. "/s)"
end)]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX5445C2672625401E81E619E4044F2C8B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Main_Bar_F</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX63D426D61CC54CF28F4FBC68CDFCF440">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PlayerBarEffects.client.lua</string>
								<string name="ScriptGuid">{10D219EC-9550-47E6-9430-A87415C762A0}</string>
								<ProtectedString name="Source"><![CDATA[local MainSize = script.Parent.Size
local PlayerBar = script.Parent:WaitForChild("Player_Bar_F")
local Bool = true
local Ts = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer

PlayerBar:GetPropertyChangedSignal("Size"):Connect(function()
	if Bool == true then
		Bool = false
		local Swinging = false
		for i, v in pairs(Plr.Character.Humanoid:GetPlayingAnimationTracks()) do
			if v.Name:split("Swing")[2] then
				Swinging = true
				break
			end
		end
		if Swinging == true then
			local Tween = Ts:Create(script.Parent, TweenInfo.new(0.1, Enum.EasingStyle.Linear), {Size = UDim2.new(MainSize.X.Scale * 1.2,0,MainSize.Y.Scale * 1.075,0)})
			Tween:Play()
			Tween.Completed:Connect(function()
				local Tween2 = Ts:Create(script.Parent, TweenInfo.new(0.1, Enum.EasingStyle.Linear), {Size = MainSize})
				Tween2:Play()
				Tween2.Completed:Connect(function()
					Bool = true
				end)
			end)
		else
			Bool = true
		end
	end
end)

script.Parent:GetPropertyChangedSignal("Position"):Connect(function()
	while script.Parent.Position.Y.Scale ~= 1.5 do
		wait()
		local MainTween = Ts:Create(script.Parent, TweenInfo.new(1, Enum.EasingStyle.Linear), {Rotation = 3.5})
		MainTween:Play()
		MainTween.Completed:Wait()
		MainTween = Ts:Create(script.Parent, TweenInfo.new(1, Enum.EasingStyle.Linear), {Rotation = -3.5})
		MainTween:Play()
		MainTween.Completed:Wait()
	end
end)

]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX4930989225E540A9A583ED1A5E893663">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">StarterGui</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX82C883835DA243BEB61F03A8DCFE4CE4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Check_Screen_Orientation.client.lua</string>
					<string name="ScriptGuid">{B0E8A62A-12FE-465F-8270-4DC7436CA7E1}</string>
					<ProtectedString name="Source"><![CDATA[-- LocalScript dans StarterGui

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local camera = workspace.CurrentCamera

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Main ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "OrientationWarning"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

-- Blocker (invisible button to block all interactions)
local blocker = Instance.new("TextButton")
blocker.Size = UDim2.new(1, 0, 1, 0)
blocker.BackgroundTransparency = 1
blocker.Text = ""
blocker.Visible = false
blocker.Modal = true --  empche toute autre interaction
blocker.Parent = screenGui

-- Background overlay
local frame = Instance.new("Frame")
frame.Size = UDim2.new(1, 0, 1, 0)
frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
frame.BackgroundTransparency = 0.5
frame.Visible = false
frame.Parent = blocker --  mettre dans blocker pour bloquer en mme temps

-- Center container
local container = Instance.new("Frame")
container.AnchorPoint = Vector2.new(0.5, 0.5)
container.Position = UDim2.new(0.5, 0, 0.5, 0)
container.Size = UDim2.new(0.8, 0, 0.4, 0)
container.BackgroundTransparency = 1
container.Parent = frame

-- Icon
local icon = Instance.new("ImageLabel")
icon.AnchorPoint = Vector2.new(0.5, 0.5)
icon.Position = UDim2.new(0.5, 0, 0.3, 0)
icon.Size = UDim2.new(0.2, 0, 0.4, 0)
icon.BackgroundTransparency = 1
icon.Image = "rbxassetid://6035047409"
icon.ImageColor3 = Color3.fromRGB(255, 255, 255)
icon.Parent = container

-- Text
local textLabel = Instance.new("TextLabel")
textLabel.AnchorPoint = Vector2.new(0.5, 0)
textLabel.Position = UDim2.new(0.5, 0, 0.65, 0)
textLabel.Size = UDim2.new(1, 0, 0.3, 0)
textLabel.BackgroundTransparency = 1
textLabel.Text = "Please rotate your device to landscape "
textLabel.TextScaled = true
textLabel.Font = Enum.Font.GothamBold
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
textLabel.Parent = container

-- Function to check orientation
local function checkOrientation()
	local size = camera.ViewportSize
	local isPortrait = size.X < size.Y

	-- scuriser l'accs aux UI si elles existent
	local offerUI = playerGui:FindFirstChild("Offer_UI")
	local dailyRewardUI = playerGui:FindFirstChild("DailyReward_UI")

	if RunService:IsStudio() then
		blocker.Visible = isPortrait
		frame.Visible = isPortrait
	else
		if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled then
			blocker.Visible = isPortrait
			frame.Visible = isPortrait
		else
			blocker.Visible = false
			frame.Visible = false
		end
	end

	-- forcer le blocage/dsactivation des popups
	if offerUI then
		offerUI.Enabled = not isPortrait
	end
	if dailyRewardUI then
		dailyRewardUI.Enabled = not isPortrait
	end
end


-- Initial check
task.wait(1)
checkOrientation()

-- Update on screen resize/orientation change
camera:GetPropertyChangedSignal("ViewportSize"):Connect(checkOrientation)
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXC3243C78C37047689BBAC854C450DBD1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Fight_Teleport_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX22F5CBA1DD4E4D51B21F49857893A592">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Fight_Teleport_Handle.client.lua</string>
						<string name="ScriptGuid">{4610C834-DCEB-4B98-AF61-1B00F40A0492}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Fight_Prompts_V = PD:WaitForChild("Fight Prompts")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))

local Hide_B = script.Parent.Hide_B
local Main_F = script.Parent.Main_F
local Fight_B = Main_F.Fight_B
local Player_F = Main_F.Player_F
local Icon_F = Player_F.Icon_F
local Player_Img = Icon_F.Player_Img
local Rank_F = Player_F.Rank_F
local Rank_Img = Rank_F.Rank_Img
local Rank_Txt = Rank_F.Rank_Txt
local Player_Name = Player_F.Player_Name

local Debounce_UI = false
local Debounce_C = false

local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	
	table.clear(Cons)
end

local function Is_Player_Fighting()
	local Char = Plr.Character or Plr.CharacterAdded:Wait()
	local Is_Fighting = Char:GetAttribute("Is_Fighting")
	if(Is_Fighting ~= nil and Is_Fighting == true)then
		return true
	end

	return false
end

local Y_Pos_Data = {
	[true] = {
		[Main_F] = 0.525,
		[Hide_B] = 0.5875
	},
	
	[false] = { -- PC and Console Showing
		[Main_F] = 0.8625,
		[Hide_B] = 0.925
	},
}

local function Get_Y_Pos(B)
	return Y_Pos_Data[UIS.TouchEnabled][B]
end

local function Remove_Fight_Spawn()
	Disconnect_Cons()

	Main_F:TweenPosition(UDim2.new(-0.2, 0, Get_Y_Pos(Main_F), 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.25, true, nil)
	Hide_B:TweenPosition(UDim2.new(-0.15, 0, Get_Y_Pos(Hide_B), 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.25, true, nil)
end

local function Show_Fight_Spawn(Display_Data, Spawn_CF)
	local function Reset_Display()
		Disconnect_Cons()
		
		Main_F.Position = UDim2.new(-0.2, 0, Get_Y_Pos(Main_F), 0)
		Hide_B.Position = UDim2.new(-0.15, 0, Get_Y_Pos(Hide_B), 0)
		
		Hide_B.Visible = false
		Main_F.Visible = false
	end
	Reset_Display()
	
	local function Update_Player_Display()
		local Rank_Col = Display_Data['Rank Color'] or Color3.fromRGB(170, 170, 127)
		
		Player_Img.Image = Display_Data['Player Icon'] or "rbxassetid://80237311442114"
		Rank_Img.Image = Display_Data['Rank Icon'] or "rbxassetid://89194867048049"
		Rank_Img.ImageColor3 = Rank_Col
		Rank_Txt.Text = Display_Data['Rank Value'] or "0"
		Rank_Txt.TextColor3 = Rank_Col
		Player_Name.Text = Display_Data['Name'] or "Player"
	end
	Update_Player_Display()
	
	local function Button_Handle()
		local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
		local Click_SE = SE_Mod.Get_SE_Object(Plr, "Click_SE")
		
		local function Move_To_Fight_Spawn()
			Bindable_Events_F:WaitForChild("Transition_Hole"):Fire(Color3.fromRGB(50, 50, 50))
			wait(0.5)
			
			local Char = Plr.Character
			if(Char ~= nil and Spawn_CF ~= nil and Is_Player_Fighting() == false and 
				Char:FindFirstChild("HumanoidRootPart") ~= nil)then
				
				local HRP = Char:FindFirstChild("HumanoidRootPart")
				HRP.CFrame = Spawn_CF
			end
		end
		
		Fight_B.Size = UDim2.new(0.75, 0, 0.325, 0)
		table.insert(Cons, Fight_B:FindFirstChild("Selected").MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				Click_SE:Play()
				TS:Create(Fight_B, Tween_Click, {Size = UDim2.new(0.5625, 0, 0.24375, 0)}):Play()
				
				Remove_Fight_Spawn()
				Move_To_Fight_Spawn()
				
				wait(0.25)
				Debounce_C = false
			end
		end))
		
		Hide_B.Size = UDim2.new(0.1, 0, 0.075, 0)
		table.insert(Cons, Hide_B:FindFirstChild("Selected").MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				Click_SE:Play()
				TS:Create(Hide_B, Tween_Click, {Size = UDim2.new(0.075, 0, 0.05625, 0)}):Play()
				
				Remove_Fight_Spawn()
				Bindable_Events_F:WaitForChild("Open_Settings"):Fire()
				
				wait(0.25)
				Debounce_C = false
			end
		end))
	end
	Button_Handle()

	local function Display_UI()
		Main_F:TweenPosition(UDim2.new(0.025, 0, Get_Y_Pos(Main_F), 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.375, true, nil)
		Hide_B:TweenPosition(UDim2.new(0.075, 0, Get_Y_Pos(Hide_B), 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.375, true, nil)
		
		Main_F.Visible = true
		Hide_B.Visible = true
	end
	Display_UI()
	
	local function Removal_Handle()
		local Char_V1 = Display_Data['Char_V1']
		local Main_Char_V = Display_Data['Main_Char_V'] or Char_V1
		if(Char_V1 ~= nil)then
			table.insert(Cons, Char_V1.Changed:Connect(function()
				if((Main_Char_V == Char_V1 and Char_V1.Value == nil) or 
					(Main_Char_V ~= Char_V1 and Char_V1.Value ~= nil))then

					Remove_Fight_Spawn()
				end
			end))
		end

		local Char_V2 = Display_Data['Char_V2']
		if(Char_V2 ~= nil)then
			table.insert(Cons, Char_V2.Changed:Connect(function()
				if((Main_Char_V == Char_V2 and Char_V2.Value == nil) or 
					(Main_Char_V ~= Char_V2 and Char_V2.Value ~= nil))then

					Remove_Fight_Spawn()
				end
			end))
		end

		local Active_V = Display_Data['Active_V']
		if(Active_V ~= nil)then
			table.insert(Cons, Active_V.Changed:Connect(function()
				if(Active_V.Value == true)then
					Remove_Fight_Spawn()
				end
			end))
		end

		--
		local Char = Plr.Character
		if(Char ~= nil)then
			table.insert(Cons, Char.AttributeChanged:Connect(function(Attrib_Name)
				if(Attrib_Name ~= nil and Attrib_Name == "Is_Fighting" and Is_Player_Fighting())then
					Remove_Fight_Spawn()
				end
			end))
		end

	end
	Removal_Handle()
end

Receiving_Events_F:WaitForChild("Fight_Spawn_Notification").OnClientEvent:Connect(function(Ignore_Plr, Display_Data, Spawn_CF)
	if(Debounce_UI == false and Fight_Prompts_V ~= nil and Fight_Prompts_V.Value == true and 
		Is_Player_Fighting() == false and Ignore_Plr ~= nil and Ignore_Plr ~= Plr)then
		
		Debounce_UI = true
		Show_Fight_Spawn(Display_Data, Spawn_CF)
		
		wait(5)
		
		Debounce_UI = false
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXD09A807FAC404457A47717745B5E93CD">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Idle_Fight_Buttons</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXFCF87038CC974E20B950E1E795210B96">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Idle_Fight_Button_Handle.client.lua</string>
						<string name="ScriptGuid">{D725AA3E-0C10-4A8C-9242-6F5F2DC3A6EC}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Sending_RF = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("RF")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))

local Main_F = script.Parent

local function Fight_Button_Handle(UI: BillboardGui)
	local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
	local Click_SE = SE_Mod.Get_SE_Object(Plr, "Click_SE")
	local Buttons_F = UI:WaitForChild("Buttons_F")
	local Invite_B = Buttons_F:WaitForChild("Invite_Friends_B")
	local Bot_B = Buttons_F:WaitForChild("Bot_Fight_B")
	local Fight_M = UI:WaitForChild("Fight_M")
	
	local Debounce_C = false
	
	local inviteFriends = function()
		if(Debounce_C == false)then
			Debounce_C = true
			Click_SE:Play()
			TS:Create(Invite_B, Tween_Click, {Size = UDim2.new(0.61875, 0, 0.3, 0)}):Play()

			Bindable_Events_F:WaitForChild("Prompt_Invite"):Fire()

			wait(0.25)
			Debounce_C = false
		end
	end
	
	Invite_B:WaitForChild("Selected").MouseButton1Click:Connect(function()
		inviteFriends()
	end)
	
	
	local function Is_Active_Fight()
		if(Fight_M.Value ~= nil and Fight_M.Value:FindFirstChild("Fight_Data_F") ~= nil)then
			local Data_F = Fight_M.Value:FindFirstChild("Fight_Data_F") 
			local Active_V = Data_F:FindFirstChild("Active_Fight")
			if(Active_V ~= nil and Active_V.Value == false)then
				return false
			end
		end
		
		return true
	end
	
	local botFight = function()
		if(Debounce_C == false and Is_Active_Fight() == false)then
			Debounce_C = true
			Click_SE:Play()
			TS:Create(Bot_B, Tween_Click, {Size = UDim2.new(0.61875, 0, 0.3, 0)}):Play()

			local Res, Txt = Sending_RF:WaitForChild("Create_Training_Bot"):InvokeServer()
			if(Res == false and Txt ~= nil)then
				Bindable_Events_F:WaitForChild("Display_Data"):Fire(Txt, Color3.fromRGB(225, 0, 0))
			end

			--Bindable_Events_F:WaitForChild("Display_Data"):Fire("Bot Fighting Disabled, Renable it here!", Color3.fromRGB(225, 0, 0))

			wait(0.25)
			Debounce_C = false
		end
	end
	
	Bot_B:WaitForChild("Selected").MouseButton1Click:Connect(function()
		botFight()
	end)
	
	local uis = game:GetService("UserInputService")
	local conn1 = uis.InputBegan:Connect(function(inp, bool)
		if bool == true then
			return
		end
		
		if inp.KeyCode == Enum.KeyCode.DPadLeft then
			if Bot_B.Visible == false then
				return
			end
			
			botFight()
		elseif inp.KeyCode == Enum.KeyCode.DPadRight then
			inviteFriends()
		end
	end)
	
	UI.Enabled = true	
	
	local updateXbox = function(enabled)
		Bot_B.Xbox.Visible = enabled
		Invite_B.Xbox.Visible = enabled
	end
	
	if uis.GamepadEnabled then
		updateXbox(true)
	else
		updateXbox(false)
	end
	local conn2 = uis.GamepadConnected:Connect(function()
		if uis.GamepadEnabled then
			updateXbox(true)
		else
			updateXbox(false)
		end
	end)
	local conn2 = uis.GamepadDisconnected:Connect(function()
		if uis.GamepadEnabled then
			updateXbox(true)
		else
			updateXbox(false)
		end
	end)
	
	UI.Destroying:Connect(function()
		conn1:Disconnect()
		conn2:Disconnect()
	end)
	
	SE_Mod.Play_Voice_Over("Matchmaking")
end

Main_F.ChildAdded:Connect(function(UI)
	if(UI ~= nil and UI:IsA("BillboardGui"))then
		Fight_Button_Handle(UI)	
	end
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX4ECB099EFB5E4FBB8235DC8EA74CD637">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Hole_Transition_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX798765C2F4384B7081D3A42D0D7C2A5F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Main_Code.client.lua</string>
						<string name="ScriptGuid">{039C89CA-AF49-4F4D-B7C4-2149BDF8507C}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local Channel_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_F = Channel_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Bindable_Events_F = Channel_F:WaitForChild("Bindable_F"):WaitForChild("Events")

local Main_F = script.Parent.Main
local Fade_F =  script.Parent.Fade_F
local Debounce_Effect = false

local function Set_Color(BG_Col)
	Main_F.ImageColor3 = BG_Col
	local Tabs = Main_F:GetChildren()
	for i = 1, #Tabs do
		if(Tabs[i]:IsA("Frame"))then
			Tabs[i].BackgroundColor3 = BG_Col
		end
	end
end

local function Apply_Effect()
	Main_F.Visible = false
	Main_F.Size = UDim2.new(3, 0, 3, 0)
	Main_F.Visible = true
	Main_F:TweenSize(UDim2.new(0.0125, 0, 0.3, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quart, 0.375, true, nil)
	wait(0.5)
	Main_F:TweenSize(UDim2.new(3, 0, 3, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quad, 0.375, true, nil)
	wait(0.375)
	Main_F.Visible = false
	Main_F.Size = UDim2.new(3, 0, 3, 0)
end

Receiving_F:WaitForChild("Transition_Hole").OnClientEvent:Connect(function(BG_Col)
	if(Debounce_Effect == false)then
		Debounce_Effect = true
		Set_Color(BG_Col)
		Apply_Effect()
		Debounce_Effect = false
	end
end)

Bindable_Events_F:WaitForChild("Transition_Hole").Event:Connect(function(BG_Col)
	if(Debounce_Effect == false)then
		Debounce_Effect = true
		Set_Color(BG_Col)
		Apply_Effect()
		Debounce_Effect = false
	end
end)

local function Transition_Fade(Tween_Time, Delay_Time)
	local Tween_I = TweenInfo.new(Tween_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
	Fade_F.Visible = false
	Fade_F.BackgroundTransparency = 1
	Fade_F.Visible = true
	TS:Create(Fade_F, Tween_I, {BackgroundTransparency = 0}):Play()
	wait(Delay_Time)
	TS:Create(Fade_F, Tween_I, {BackgroundTransparency = 1}):Play()
	wait(Tween_Time)
	Fade_F.Visible = false
end

Receiving_F:WaitForChild("Transition_Fade").OnClientEvent:Connect(function(Tween_Time, Delay_Time)
	Transition_Fade(Tween_Time, Delay_Time)
end)

Bindable_Events_F:WaitForChild("Transition_Fade").Event:Connect(function(Tween_Time, Delay_Time)
	Transition_Fade(Tween_Time, Delay_Time)
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX082E3BC8222448DFA2FF9C477FF64F5E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main_Fight_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXC1E39D9FBB5142459384BAE03A302474">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Fight_Handle.client.lua</string>
						<string name="ScriptGuid">{B3EFBD15-BF56-434A-AEA6-0CB88BD2FC93}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local RS = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Head = Char:WaitForChild("Head")
local Fight_Data_F = Plr:WaitForChild("Fight_Data")
local Cam = game.Workspace.CurrentCamera
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Sending_Events_F = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("Events")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Cam_Shake_Mod = require(Data_Mods_F:WaitForChild("CameraShaker"))
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Fight_Cages_F = game.Workspace:WaitForChild("Fight_Cages_F")

local KeybindsFrames = {
	PC = script.Parent:WaitForChild("Key_Labels_F"),
	Console = script.Parent:WaitForChild("Key_Labels_G"),
	PS5 = script.Parent:WaitForChild("Key_Labels_PS5")
}

local Can_Enter_Fight = true
local Locked_In_Fight = false
local Events_F = script.Parent.Local_Events_F
local Mobile_Buttons_F = script.Parent.Mobile_Buttons_F
local Fight_Walkspeed = 10
local Cam_FOV = 45
--local Cam_Offset = Vector3.new(2.75, -2.75, -2.75)
local Cam_Offset = Vector3.new(4, -3, -5)
local Min_Angle = math.rad(-35) 
local Max_Angle = math.rad(-25)

local Tween_Cam = TweenInfo.new(0.375, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
local RS_Con = nil
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end

	RS:UnbindFromRenderStep("UpdateLoop")

	table.clear(Cons)
end

local function Is_Player_Fighting(T_Char)
	local Is_Fighting = T_Char:GetAttribute("Is_Fighting")
	if(Is_Fighting ~= nil and Is_Fighting == true)then
		return true
	end

	return false
end

local function Set_Cam_Adjustments(Is_Alone)
	if(Is_Alone)then
		TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
		TS:Create(Hum, Tween_Cam, {CameraOffset = Vector3.new(0, 0, 0)}):Play()
		Cam.CameraType = Enum.CameraType.Custom
	else
		TS:Create(Cam, Tween_Cam, {FieldOfView = Cam_FOV}):Play()
		TS:Create(Hum, Tween_Cam, {CameraOffset = Cam_Offset}):Play()
		Cam.CameraType = Enum.CameraType.Scriptable
	end
end

local function Get_Fighting_UI()
	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
		local Main_F = Fight_UI:FindFirstChild("Main_F") 
		local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
		if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
			return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
		end
	end

	return nil, nil
end

local function Get_Current_Fighting_M()
	local All_Cages_M = Fight_Cages_F:GetChildren()

	local function Is_Main_Cage(Cage_M)
		local FD = Cage_M:FindFirstChild("Fight_Data_F")
		if(FD ~= nil and FD:FindFirstChild("Fight_Char_1") ~= nil and 
			FD:FindFirstChild("Fight_Char_2") ~= nil)then

			local C1_V = FD:FindFirstChild("Fight_Char_1")
			local C2_V = FD:FindFirstChild("Fight_Char_2")
			if(C1_V.Value == Char or C2_V.Value == Char) then
				return true
			end
		end

		return false
	end

	for i = 1, #All_Cages_M do
		local Cage_M = All_Cages_M[i]
		if(Cage_M ~= nil and Is_Main_Cage(Cage_M))then
			return Cage_M
		end
	end

	return nil
end

local function Reset_BG()
	if(RS_Con ~= nil)then
		RS_Con:Disconnect()
		RS_Con = nil
	end
	Disconnect_Cons()

	if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
		HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
	end

	if(Hum ~= nil)then
		Hum.AutoRotate = true
		Hum.WalkSpeed = 16
		Hum.JumpPower = 50

		Animation_Mod.Reset_Character_Animations(Char)

		Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
		Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, true)
		Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
	end

	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil)then
		Damage_Bar_Img.Visible = false
	end

	Plr.CameraMaxZoomDistance = game.StarterPlayer.CameraMaxZoomDistance
	Plr.CameraMinZoomDistance = game.StarterPlayer.CameraMinZoomDistance

	Cam.CameraType = Enum.CameraType.Custom
	UIS.MouseBehavior = Enum.MouseBehavior.Default
	UIS.MouseIconEnabled = true
	UIS.MouseDeltaSensitivity = 1
	Hum.CameraOffset = Vector3.new(0, 0, 0)
	Cam.FieldOfView = 70
	Char:SetAttribute("Is_Fighting", false)

	Bindable_Events_F:WaitForChild("Display_Takedown_Tracking"):Fire(false)

	--Hard Reset Player Blocking Handle
	task.spawn(function()
		Events_F:WaitForChild("Unblocking_Strike"):FireServer()
		Bindable_Events_F:WaitForChild("Toggle_Binds_Info"):Fire(false)
	end)
end
Reset_BG()

local function Init_Testing_For_Camera(Target_HRP)
	--[[
		* Adjust Camera Offset and FOV
		* Lock the Mouse to Center of the Screen, Hide the Cursor
		* Apply BodyGyro to HRP
		* Get a Target Player ~ if not, let the Mouse Free Rotate
		
		* When no Target Player is selected or Found, Keep your Mouse / Camera in a relaxed View
		* Else, Set the Target and Lock in
		
	]]--

	local function Rotate_Connection_Handle()
		Reset_BG()

		local function Create_BG()
			local OldG = HRP:FindFirstChildWhichIsA("BodyGyro")
			if(OldG ~= nil)then
				OldG:Destroy()
			end

			local bodyG = Instance.new("BodyGyro", HRP)
			bodyG.P = 1000
			bodyG.MaxTorque = Vector3.new(0, 1000, 0)
			bodyG.D = 10

			return bodyG
		end
		local BG = Create_BG()

		--Cam.CameraType = Enum.CameraType.Track
		Plr.CameraMaxZoomDistance = 18
		Plr.CameraMinZoomDistance = 18
		UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
		UIS.MouseIconEnabled = false
		UIS.MouseDeltaSensitivity = 0.5

		if(Hum ~= nil)then
			Hum.AutoRotate = false
			Hum.WalkSpeed = Fight_Walkspeed
			Hum.JumpPower = 0

			Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
			Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
			Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
		end

		Char:SetAttribute("Is_Fighting", true)

		return BG
	end
	local BG = Rotate_Connection_Handle()
	local Is_Hit = false

	local function Get_Target_Player()
		local All_P = game.Players:GetPlayers()
		local Max_Dist, T_HRP = 60, nil

		for i = 1, #All_P do
			local T_Plr = All_P[i]
			if(T_Plr ~= nil and T_Plr ~= Plr and T_Plr.Character ~= nil and 
				Is_Player_Fighting(T_Plr.Character) == false and 
				T_Plr.Character:FindFirstChild("HumanoidRootPart") ~= nil)then

				local Char_HRP = T_Plr.Character:FindFirstChild("HumanoidRootPart")
				local Dist = (HRP.Position - Char_HRP.Position).Magnitude
				if(Dist <= Max_Dist)then
					Max_Dist = Dist
					T_HRP = Char_HRP
				end

			end
		end

		return T_HRP
	end
	--local Target_HRP = Get_Target_Player()
	--Target_HRP = game.Workspace.StarterCharacter.HumanoidRootPart

	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false)
	if(Target_HRP ~= nil)then
		Locked_In_Fight = true
		Bindable_Events_F:WaitForChild("Toggle_Tool_Buttons"):Fire(false)
		Bindable_Events_F:WaitForChild("Toggle_BG_Volume"):Fire(false)
		Bindable_Events_F:WaitForChild("Display_Takedown_Tracking"):Fire(true)
	end

	Set_Cam_Adjustments((Target_HRP == nil))

	table.insert(Cons, Receiving_Events_F:WaitForChild("Set_Player_Fight_Opponent").OnClientEvent:Connect(function(Opp_Char)
		if(Opp_Char ~= nil and Opp_Char:FindFirstChild("HumanoidRootPart") ~= nil)then
			Target_HRP = Opp_Char:FindFirstChild("HumanoidRootPart")
		else
			Target_HRP = nil
		end

		Set_Cam_Adjustments((Target_HRP == nil))
	end))

	table.insert(Cons, Hum.Died:Connect(function()
		Target_HRP = nil
		Reset_BG()
	end))

	local function Update_BG()
		local LookPos  = HRP.Position + (Cam.CFrame.LookVector * 25)
		if(Target_HRP ~= nil)then
			LookPos = Target_HRP.Position
		end
		BG.CFrame = CFrame.new(HRP.Position, LookPos)
	end
	Update_BG()

	RS_Con = RS.Stepped:Connect(function()
		if(BG ~= nil and Cam ~= nil)then
			Update_BG()
		end
	end)
	table.insert(Cons, RS_Con) 

	table.insert(Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
		if(Hum.PlatformStand == true)then
			BG.P = 0
			BG.MaxTorque = Vector3.new(0, 0, 0)
			BG.D = 0
		else
			BG.P = 1000
			BG.MaxTorque = Vector3.new(0, 1000, 0)
			BG.D = 10
		end
	end))

	local offset = CFrame.new()
	local lastCFrame = Cam.CFrame
	--Disable Custom Camera Movement when in a Cutscene-based State (Takedown, Knockout, Cage Clinch)
	RS:BindToRenderStep("UpdateLoop", Enum.RenderPriority.Camera.Value - 1, function(dt)
		if (Target_HRP == nil) then

		else
			if(Hum ~= nil and Hum.WalkSpeed > 0 and HRP ~= nil and HRP.Anchored == false)then
				local vec = (Target_HRP.Position - HRP.Position) * Vector3.new(1, 0, 1)
				if vec.Magnitude <= 0.001 then
					vec = Vector3.zAxis
				end
				vec = vec.Unit

				local lerp = if Is_Hit == false then 0.3 else 0.1
				local alpha = 1 - (1 - lerp) ^ (60 * dt)
				local targetCFrame = CFrame.new(HRP.Position, HRP.Position + vec) * CFrame.Angles(Max_Angle, 0, 0) * CFrame.new(3, 2, 13)
				Cam.CFrame = lastCFrame:Lerp(targetCFrame, alpha)

				lastCFrame = Cam.CFrame
			end
		end
		--local rX, rY, rZ = Cam.CFrame:ToOrientation()
		--Cam.CFrame = CFrame.new(Cam.CFrame.p) * CFrame.fromOrientation(Max_Angle, rY, rZ)
	end)

	-------------------
	-- Set up the Fight UI
	-- Set up the Actual Connections to start Swinging, Blocking, Moving, Ect

	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
		Damage_UIG.Offset = Vector2.new(0, -0.5)
		Damage_Bar_Img.Visible = true
	end

	local function Create_Anim_Arr_Data(Anim_Track_Data)
		local D = {}
		for Key, Anim_Track in next, Anim_Track_Data do
			table.insert(D, Anim_Track)
		end
		return D
	end

	local function Get_Fight_Data_Vals()
		local FD_Vals = Fight_Data_F:GetChildren()
		local Vals = {

		}

		for i = 1, #FD_Vals do
			local V = FD_Vals[i]
			if(V ~= nil)then
				Vals[V.Name] = V
			end
		end

		return Vals
	end
	local Fight_Data_Vals = Get_Fight_Data_Vals()
	local Health_V = Fight_Data_Vals['Health']
	local Blocking_Power_V = Fight_Data_Vals['Block Power']
	local Staminia_V = Fight_Data_Vals['Staminia']
	local Punch_Power_V = Fight_Data_Vals['Strike Power']
	local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	local Combo_Strike_Index = 1
	local Combo_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(Plr, Hum)
	local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)

	local Debounce_Striking = false
	local Debounce_Dodge = false
	local Debounce_Blocking = false
	local Debounce_Takedown = false
	local Is_Cage_Submission = false

	local function Striking_Movement_Handle()
		--> Update Movement, Moving Forward or Backwards | Moving Left to Right | Standing Idle
		--> Track Humanoid MoveDirection
		local Cam_Move_Tween = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
		local Reset_Cam_Move_Tween = TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
		local Cam_Tween = nil

		table.insert(Cons, Hum:GetPropertyChangedSignal("MoveDirection"):Connect(function()
			local Move_Dir = Hum.MoveDirection
			if(Move_Dir.Magnitude > 0 and Anim_Track_Data['Shuffle Forward'].IsPlaying == false)then
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				Anim_Track_Data['Shuffle Forward']:Play()
				--Anim_Track_Data['Shuffle Forward']:AdjustSpeed(-1)

				if(Is_Hit == false)then
					if(Cam_Tween ~= nil)then
						Cam_Tween:Cancel()
						Cam_Tween = nil
					end
					Cam_Tween = TS:Create(Cam, Cam_Move_Tween, {FieldOfView = 55})
					Cam_Tween:Play()
				end

			elseif(Move_Dir.Magnitude <= 0 and 
				(Anim_Track_Data['Shuffle Forward'].IsPlaying == true or 
					Anim_Track_Data['Shuffle Side'].IsPlaying == true))then

				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})

				if(Is_Hit == false)then
					if(Cam_Tween ~= nil)then
						Cam_Tween:Cancel()
						Cam_Tween = nil
					end
					Cam_Tween = TS:Create(Cam, Reset_Cam_Move_Tween, {FieldOfView = Cam_FOV})
					Cam_Tween:Play()
				end
			end
		end))

		Anim_Track_Data['Idle']:Play()
		Anim_Track_Data['Idle']:AdjustSpeed(0.5)
	end
	Striking_Movement_Handle()

	local function On_Hit_Effects()
		--[[
			* When Health goes Down!
				> Camera Shake Effects
					-> Quick Shake
				> Apply Hit Effects
					-> Reset all Animations, Play the Hit One
				> Set Debounce till Hit Effect goes Away
		]]--

		local Prev_Health = Health_V.Value
		local Hit_Anim_Track = Striking_Anim_Tracks['Taking Hit']

		local function Cam_Shake()
			local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
				Cam.CFrame = Cam.CFrame * shakeCf
			end)
			return CS
		end
		local CamShake = Cam_Shake()

		local function Show_Sweat_Effects()
			if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
				local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
				local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
				if(PE ~= nil)then
					PE:Emit(25)
				end
			end
		end

		table.insert(Cons, Health_V.Changed:Connect(function()
			local Current_V = Health_V.Value
			if(Current_V < Prev_Health and Is_Hit == false)then
				Is_Hit = true

				CamShake:Start()
				CamShake:Shake(Cam_Shake_Mod.Presets.Bump)
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Show_Sweat_Effects()

				task.spawn(function()
					Animation_Mod.Play_Animation_Track(Hit_Anim_Track)
					CamShake:Stop()

					--Make sure you're not in a Submission Hold
					if(Is_Cage_Submission == false)then
						Is_Hit = false
					end
				end)
			end

			Prev_Health = Current_V
		end))
	end
	On_Hit_Effects()

	local function Get_Target_Players_Hand()
		if(Target_HRP ~= nil and Target_HRP.Parent ~= nil and 
			game.Players:GetPlayerFromCharacter(Target_HRP.Parent) ~= nil)then

			local T_Plr = game.Players:GetPlayerFromCharacter(Target_HRP.Parent)
			local T_Plr_PD = T_Plr:FindFirstChild("Player_Data")

			if(T_Plr_PD ~= nil and T_Plr_PD:FindFirstChild("Right Handed") ~= nil)then
				return T_Plr_PD:FindFirstChild("Right Handed").Value
			end
		end

		return true
	end

	local function Play_Blocking_Animation()
		local Anim_Track = Striking_Anim_Tracks['Main Block']
		if(Anim_Track ~= nil)then
			Anim_Track:Play()
			Anim_Track:AdjustSpeed(1)
			wait(Anim_Track.Length * 0.9)

			if(Anim_Track ~= nil and Debounce_Blocking == true)then
				Anim_Track:AdjustSpeed(0)
			end
		end
	end

	local function Blocking_Effects()
		--[[
			* On Sheild Blocking Power goes down (Greater than 0) and Debounce_Blocking == true
			* Get the Opponent Handed Type
				> Play the Coresponding Animation
		]]--
		local Prev_Blocking = Blocking_Power_V.Value

		local function Get_Blocking_Animation()
			if(Get_Target_Players_Hand())then
				--Target is Right Handed, Block with your Left
				return Striking_Anim_Tracks['Body Block Left']
			else
				return Striking_Anim_Tracks['Body Block Right']
			end
		end

		table.insert(Cons, Blocking_Power_V.Changed:Connect(function()
			local Current_V = Blocking_Power_V.Value
			if(Current_V > 0 and Current_V < Prev_Blocking and Debounce_Blocking == true)then
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Get_Blocking_Animation())

				if(Debounce_Blocking == true)then
					task.spawn(Play_Blocking_Animation)
				end
			end

			Prev_Blocking = Current_V
		end))
	end
	Blocking_Effects()

	local function Strike_Power_Handle()
		local function Update_Damage_Bar()
			local Dif =  math.clamp(Punch_Power_V.Value / 6, 0, 1)
			local Offset_Pos_Y = (1 - Dif) - 0.5
			Damage_UIG.Offset = Vector2.new(0, Offset_Pos_Y)
		end
		Update_Damage_Bar()

		table.insert(Cons, Punch_Power_V.Changed:Connect(function()
			Update_Damage_Bar()
		end))
	end
	Strike_Power_Handle()

	--Striking Handle
	local function Client_Striking_Handle()
		--[[
			* On Click / R2 ~ Strike
			* Q / X ~ Dodge Left
			* E / B ~ Dodge Right
			* Space / L2 ~ Blocking Handle
		]]--
		local Wooshes = {
			SE_Mod.Get_SE_Object(Plr, "Woosh_1_SE"),
			SE_Mod.Get_SE_Object(Plr, "Woosh_2_SE"),
			SE_Mod.Get_SE_Object(Plr, "Woosh_3_SE"),
			SE_Mod.Get_SE_Object(Plr, "Woosh_4_SE"),
			SE_Mod.Get_SE_Object(Plr, "Woosh_5_SE"),
			SE_Mod.Get_SE_Object(Plr, "Woosh_6_SE"),
			SE_Mod.Get_SE_Object(Plr, "Woosh_7_SE"),
			SE_Mod.Get_SE_Object(Plr, "Woosh_8_SE"),
		}

		local function play_random_woosh()
			local random_index = math.random(1, #Wooshes)
			local random_woosh = Wooshes[random_index]
			random_woosh:Play()
		end

		local function Strike_Handle()
			--[[
				* Play Woosh Sound Effect locally
				* Play Animation
				* Tell the Server that you are Striking
			]]--

			Debounce_Striking = true
			play_random_woosh()

			local function Play_Strike_Animation()
				local Track = Combo_Anim_Arr[Combo_Strike_Index]
				local Key = Track:GetAttribute("Strike_Key") or "A"
				--if(Key == "C")then
				--	print(Track)
				--	print(Track:GetAttribute("Reverses"))
				--end

				task.spawn(function()
					Events_F:WaitForChild("Throwing_Strike"):FireServer(Key)
				end)

				Combo_Strike_Index += 1
				if(Combo_Strike_Index > #Combo_Anim_Arr)then
					Combo_Strike_Index = 1
				end

				Animation_Mod.Stop_Animation_Tracks(Combo_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Track)
			end
			task.spawn(Play_Strike_Animation)
			wait(0.5)

			if(UIS.TouchEnabled == false)then
				wait(0.25)
			end

			Debounce_Striking = false
		end

		local Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left']
		local Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		local Back_Dodge_Ani = Striking_Anim_Tracks['Dodge Back']
		local function Dodge_Handle(Dodge_Type)
			--[[
				* Get the Type First
					-> First Index? Just play the Slip Animation
					-> 2nd Index? Play the Dodge Animation AND apply Force to the Player in the direction
				
					-> Tell the Server that you are Dodging and should reduce Staminia Value
			]]--

			Debounce_Dodge = true

			local function Apply_Force(Dir)
				local Force = 68
				if(Dodge_Type == "Dodge Back")then
					Force = 90
				end

				HRP:ApplyImpulse(Dir * (Fight_Walkspeed * Force) * HRP:GetMass())
			end

			task.spawn(function()
				Events_F:WaitForChild("Dodging_Strike"):FireServer()
			end)
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Bindable_Events_F:WaitForChild("Show_White_Fade"):Fire(Color3.new(1, 1, 1))

			if(Dodge_Type == "Dodge Left")then
				--Left
				if(Left_Dodge_Ani == Striking_Anim_Tracks['Headblock Left'])then
					--Apply_Force(HRP.CFrame.RightVector * -1)
				end
				Apply_Force(HRP.CFrame.RightVector * -1)
				Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
			elseif(Dodge_Type == "Dodge Right")then
				--Right
				if(Right_Dodge_Ani == Striking_Anim_Tracks['Headblock Right'])then
					--Apply_Force(HRP.CFrame.RightVector)
				end
				Apply_Force(HRP.CFrame.RightVector)
				Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)

			else
				Apply_Force(HRP.CFrame.LookVector * -1)
				Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
			end


			local function Increment_Anim()
				if(Dodge_Type == "Dodge Left")then
					if(Left_Dodge_Ani == Striking_Anim_Tracks['Slip Left'])then
						Left_Dodge_Ani = Striking_Anim_Tracks['Headblock Left']
					else
						Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left'] 
					end
				elseif(Dodge_Type == "Dodge Right")then
					--Right
					if(Right_Dodge_Ani == Striking_Anim_Tracks['Slip Right'])then
						Right_Dodge_Ani = Striking_Anim_Tracks['Headblock Right']
					else
						Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right'] 
					end
				end
			end
			Increment_Anim()

			Debounce_Dodge = false
		end

		local Low_Block_Con = nil
		local function Disable_Blocking_Handle()
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed
			end

			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Events_F:WaitForChild("Unblocking_Strike"):FireServer()
			Events_F:WaitForChild("Release_Mobile_Blocking"):Fire()
			Debounce_Blocking = false
		end

		local lastBlock = os.clock()
		local function Blocking_Handle()
			if os.clock() - lastBlock <= 0.15 then
				return
			end

			lastBlock = os.clock()
			Debounce_Blocking = true

			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed * 0.2
			end

			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			Low_Block_Con = Blocking_Power_V.Changed:Connect(function()
				if(Blocking_Power_V.Value <= 0 and Debounce_Blocking == true)then
					if(Low_Block_Con ~= nil)then
						Low_Block_Con:Disconnect()
						Low_Block_Con = nil
					end

					Disable_Blocking_Handle()
				end
			end)
			table.insert(Cons, Low_Block_Con)

			task.spawn(Play_Blocking_Animation)

			Events_F:WaitForChild("Blocking_Strike"):FireServer()
		end

		local function Takedown_Handle()
			--[[
				* Get the Takedown Event
					- Get the Fight Model
					- Get the Event
					- Get check the Takedown Tracker
					- Make sure you're not already on the ground
			]]--

			local function Get_Takedown_Event()
				local function Check_Takedown_Data(Takedown_V)
					local Your_V, Other_V = 0, 0
					for Plr_Name, Val in next, Takedown_V:GetAttributes() do
						if(Plr_Name == Char.Name)then
							Your_V = Val
						else
							Other_V = Val
						end
					end

					if(Your_V > Other_V)then
						return true
					end
					return false
				end

				local function Is_Fighting_Model(Cage_M)
					local Fight_Data_F = Cage_M:FindFirstChild("Fight_Data_F")
					if(Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild("Fight_Char_1") ~= nil and 
						Fight_Data_F:FindFirstChild("Fight_Char_2") ~= nil and 
						Fight_Data_F:FindFirstChild("Active_Fight") ~= nil and 
						Fight_Data_F:FindFirstChild("Takedown_Track") ~= nil and 
						Fight_Data_F:FindFirstChild("Submission_Hold_Character") and 
						Fight_Data_F:FindFirstChild("Takedown_E") ~= nil)then

						local Char_V1 = Fight_Data_F:FindFirstChild("Fight_Char_1")
						local Char_V2 = Fight_Data_F:FindFirstChild("Fight_Char_2")
						local Can_Takedown = Fight_Data_F:FindFirstChild("Takedown_Track")
						local Active_Fight_V = Fight_Data_F:FindFirstChild("Active_Fight")
						local Submission_Hold_V = Fight_Data_F:FindFirstChild("Submission_Hold_Character")

						if(Active_Fight_V.Value == true and Can_Takedown.Value == true and
							(Char_V1.Value == Char or Char_V2.Value == Char) and 
							Submission_Hold_V.Value ~= Char and Check_Takedown_Data(Can_Takedown))then

							return Fight_Data_F:FindFirstChild("Takedown_E")
						end
					end

					return nil
				end

				local All_Cages_M = Fight_Cages_F:GetChildren()
				for i = 1, #All_Cages_M do
					local Cage_M = All_Cages_M[i] 
					if(Cage_M ~= nil)then
						local Takedown_E = Is_Fighting_Model(Cage_M)
						if(Takedown_E ~= nil)then
							return Takedown_E
						end
					end
				end

				return nil
			end
			local Takedown_E = Get_Takedown_Event()

			if(Takedown_E ~= nil)then
				Debounce_Takedown = true

				--Play the Animation
				SE_Mod.Play_Voice_Over("Submission_Attempt")
				Takedown_E:FireServer()

				wait(10)
				Debounce_Takedown = false
			end
		end

		if(UIS.TouchEnabled == false)then
			local Is_Chat_Typing = Bindable_RF:WaitForChild("Is_Chatbox_Typing")

			local function Input_Handle(input)
				if(input.UserInputType == Enum.UserInputType.MouseButton1 or 
					input.KeyCode == Enum.KeyCode.ButtonR2)then

					return "Striking"
				elseif(input.KeyCode == Enum.KeyCode.Q or input.KeyCode == Enum.KeyCode.ButtonX)then
					return "Dodge Left"
				elseif(input.KeyCode == Enum.KeyCode.E or input.KeyCode == Enum.KeyCode.ButtonB)then
					return "Dodge Right"
				elseif(input.KeyCode == Enum.KeyCode.F or input.KeyCode == Enum.KeyCode.ButtonA)then
					return "Dodge Back"
				elseif(input.KeyCode == Enum.KeyCode.Space or input.KeyCode == Enum.KeyCode.ButtonL2)then
					return "Blocking"
				elseif(input.KeyCode == Enum.KeyCode.R or input.KeyCode == Enum.KeyCode.ButtonY)then
					return "Takedown"
				end

				return "None"
			end

			table.insert(Cons, UIS.InputBegan:Connect(function(input, GPE)
				if(Is_Chat_Typing:Invoke() == false and Health_V.Value > 0 and Is_Hit == false)then
					local Input_Type = Input_Handle(input)
					if(Input_Type == "Striking" and Debounce_Striking == false and 
						Staminia_V.Value >= 3 and Punch_Power_V.Value > 0)then

						if(Debounce_Blocking == true)then
							task.spawn(Disable_Blocking_Handle)
						end

						Strike_Handle()

					elseif(Input_Type == "Blocking" and Debounce_Blocking == false and 
						Blocking_Power_V.Value > 0)then

						Blocking_Handle()

					elseif((Input_Type == "Dodge Left" or Input_Type == "Dodge Right" or Input_Type == "Dodge Back") and 
						Debounce_Dodge == false and Staminia_V.Value >= 7)then

						if(Debounce_Blocking == true)then
							task.spawn(Disable_Blocking_Handle)
						end

						Dodge_Handle(Input_Type)

					elseif(Input_Type == "Takedown"and Debounce_Takedown == false and 
						Staminia_V.Value >= 15)then

						Takedown_Handle()
					end
				end
			end))

			table.insert(Cons, UIS.InputEnded:Connect(function(input, GPE)
				if(Is_Chat_Typing:Invoke() == false and Input_Handle(input) == "Blocking" and 
					Debounce_Blocking == true)then

					Disable_Blocking_Handle()
				end
			end))

			Events_F:WaitForChild("Toggle_Key_Labels"):Fire(true)
		else
			--Set up Mobile Button Handle

			script.Parent.Parent
				:WaitForChild("Takedown_UI")
				:WaitForChild("Takedown_Progress_Display_F")
				:WaitForChild("MobileActivate").Activated:Connect(function()

					if Debounce_Takedown == false and Staminia_V.Value >= 15 then
						Takedown_Handle()
					end
				end)

			local Mobile_Button_Data = Events_F:WaitForChild("Get_Mobile_Buttons"):Invoke()
			local Click_SE = SE_Mod.Get_SE_Object(Plr, "Click_SE")

			local function Get_Click_Size()
				local B = Mobile_Button_Data['Strike_B']
				local Def_Size = B.Size.X.Offset
				local CS = Def_Size * 0.75
				return B.Size, UDim2.new(0, CS, 0, CS)
			end
			local Def_Size, Click_Size = Get_Click_Size()

			local function Input_Handle(Input_Type)
				if(Input_Type == "Striking" and Debounce_Striking == false and 
					Staminia_V.Value >= 3 and Punch_Power_V.Value > 0)then

					if(Debounce_Blocking == true)then
						task.spawn(Disable_Blocking_Handle)
					end

					Strike_Handle()

				elseif(Input_Type == "Blocking" and Debounce_Blocking == false and 
					Blocking_Power_V.Value > 0)then

					Blocking_Handle()

				elseif((Input_Type == "Dodge Left" or Input_Type == "Dodge Right" or Input_Type == "Dodge Back") and 
					Debounce_Dodge == false and Staminia_V.Value >= 7)then

					if(Debounce_Blocking == true)then
						task.spawn(Disable_Blocking_Handle)
					end

					Dodge_Handle(Input_Type)

				elseif(Input_Type == "Takedown"and Debounce_Takedown == false and 
					Staminia_V.Value >= 15)then

					Takedown_Handle()
				end
			end

			local function Click_Handle(B, Input_Type)
				local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
				local Selected = B:FindFirstChild("Selected")
				local Debounce_C = false
				B.Visible = true

				table.insert(Cons, Selected.MouseButton1Click:Connect(function()
					if(Debounce_C == false and B.Visible == true and Health_V.Value > 0 and Is_Hit == false)then
						Debounce_C = true
						if(Click_SE ~= nil)then
							Click_SE:Play()
						end
						TS:Create(B, Tween_Click, {Size = Click_Size}):Play()

						Input_Handle(Input_Type)

						wait(0.25)
						Debounce_C = false
					end
				end))
			end
			Click_Handle(Mobile_Button_Data['Strike_B'], "Striking")
			Click_Handle(Mobile_Button_Data['Dodge_Left_B'], "Dodge Left")
			Click_Handle(Mobile_Button_Data['Dodge_Right_B'], "Dodge Right")
			Click_Handle(Mobile_Button_Data['Takedown_B'], "Takedown")
			Click_Handle(Mobile_Button_Data['Dodge_Back_B'], "Dodge Back")

			local function Blocking_Handle(B)
				local Selected = B:FindFirstChild("Selected")
				local Icon_Img = B:FindFirstChild("Icon_Img")
				local Debounce_C = false
				B.Visible = true
				Icon_Img.ImageColor3 = Color3.new(1, 1, 1)

				table.insert(Cons, Selected.MouseButton1Down:Connect(function()
					if(Debounce_C == false and B.Visible == true and Health_V.Value > 0 and Is_Hit == false)then
						Debounce_C = true
						if(Click_SE ~= nil)then
							Click_SE:Play()
						end
						Icon_Img.ImageColor3 = Color3.fromRGB(150, 150, 150)
						B:TweenSize(Click_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.125, true, nil)
						Input_Handle("Blocking")
					end
				end))

				table.insert(Cons, Selected.MouseButton1Up:Connect(function()
					if(Debounce_C)then
						if(Click_SE ~= nil)then
							Click_SE:Play()
						end
						Icon_Img.ImageColor3 = Color3.new(1, 1, 1)
						B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.125, true, nil)

						if(Debounce_Blocking == true)then
							task.spawn(Disable_Blocking_Handle)
						end

						Debounce_C = false
					end
				end))	

				table.insert(Cons, Events_F:WaitForChild("Release_Mobile_Blocking").Event:Connect(function()
					if(Debounce_C and B.Size == Click_Size)then
						if(Click_SE ~= nil)then
							Click_SE:Play()
						end
						Icon_Img.ImageColor3 = Color3.new(1, 1, 1)
						B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.125, true, nil)
						Debounce_C = false
					end
				end))
			end
			Blocking_Handle(Mobile_Button_Data['Block_B'])

			Mobile_Button_Data['Takedown_B'].Visible = false
		end
	end
	Client_Striking_Handle()


	--Set up Submission Handle
	local Prev_Camera_Offset, Cam_Tween, Cam_RS_Con = nil, TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0), nil
	local function On_Submission_Handle(Is_Attacking, Is_Submission)
		Animation_Mod.Reset_Character_Animations(Char)
		Events_F:WaitForChild("Toggle_Key_Labels"):Fire(not Is_Submission)

		if(Cam_RS_Con ~= nil)then
			Cam_RS_Con:Disconnect()
			Cam_RS_Con = nil
		end

		if(Is_Submission)then
			Is_Hit = true
			Is_Cage_Submission = true

			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end

			if(HRP ~= nil)then
				--HRP.Anchored = true

				if(Is_Attacking == false)then
					HRP.CFrame *= CFrame.new(Vector3.new(0, 0.15, 0))
				end
			end

			--> Play Animation
			--> Get Submission Character & Player
			--> Get their Takedown and Submission Data

			--> If Attacking Player, Set HRP CFrame Position
			--> Play Take Down Animation

			--> Play Submission Animation
			--> Play Submission Loop Animation


			local function Get_Takedown_Submission_Tracks()
				local function Get_Fighting_Character()
					local All_FM = Fight_Cages_F:GetChildren()

					local function Check_Fight_Data(FD_F)
						local Char_V1 = FD_F:FindFirstChild("Fight_Char_1")
						local Char_V2 = FD_F:FindFirstChild("Fight_Char_2")
						local Submission_Char = FD_F:FindFirstChild("Submission_Hold_Character")

						if(Char ~= nil and Char_V1 ~= nil and Char_V2 ~= nil and 
							(Char_V1.Value == Char or Char_V2.Value == Char) and 
							Submission_Char ~= nil and Submission_Char.Value ~= nil)then

							return Submission_Char.Value 
						end

						return nil
					end

					for i = 1, #All_FM do
						local FM = All_FM[i]
						if(FM ~= nil and FM:FindFirstChild("Fight_Data_F") ~= nil)then
							local Fight_Data_F = FM:FindFirstChild("Fight_Data_F")
							local Other_Char = Check_Fight_Data(Fight_Data_F)
							if(Other_Char ~= nil)then
								return Other_Char
							end
						end
					end

					return nil
				end
				local Attacking_Char = Get_Fighting_Character()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)

				if(Is_Attacking)then
					local function Set_HRP_CFrame()
						local Attack_HRP = Attacking_Char:FindFirstChild("HumanoidRootPart")
						local CF_Offset = Takedown_Data['CF Offset']
						local Offset_Pos = CF_Offset.Position
						local Offset_Rot = CF_Offset.Rotation

						if(Attack_HRP ~= nil and CF_Offset ~= nil and HRP ~= nil)then
							local New_Pos = Attack_HRP.Position + (Attack_HRP.CFrame.LookVector * math.abs(Offset_Pos.Z))
							local Rot_CF = CFrame.new(HRP.Position, New_Pos)
							--HRP.CFrame = CFrame.new(New_Pos) * Rot_CF.Rotation
						end
					end
					--Set_HRP_CFrame()

					return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Takedown ID'], Submission_Data['Submission ID'], Submission_Data['Submission Loop ID'])
				else
					return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Receiving ID'], Submission_Data['Receiving ID'], Submission_Data['Receiving Loop ID'])
				end
			end
			local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()

			local function Play_Init_Camera_Effects()
				if(Prev_Camera_Offset == nil)then
					Prev_Camera_Offset = HRP.CFrame:ToObjectSpace(Cam.CFrame)
				end

				local function Get_Receiving_HRP()
					local Cage_M = Get_Current_Fighting_M()
					if(Cage_M ~= nil and Cage_M:FindFirstChild("Fight_Data_F") ~= nil)then
						local FD = Cage_M:FindFirstChild("Fight_Data_F")
						local Submission_Char_V = FD:FindFirstChild("Submission_Hold_Character")
						local Fight_Char_1_V = FD:FindFirstChild("Fight_Char_1")
						local Fight_Char_2_V = FD:FindFirstChild("Fight_Char_2")

						if(Submission_Char_V ~= nil and Fight_Char_1_V ~= nil and Fight_Char_2_V ~= nil)then
							if(Fight_Char_1_V.Value ~= Submission_Char_V.Value)then
								local T_HRP = Fight_Char_1_V.Value:FindFirstChild("UpperTorso")
								if(T_HRP ~= nil)then
									return T_HRP
								end
							else
								local T_HRP = Fight_Char_2_V.Value:FindFirstChild("UpperTorso")
								if(T_HRP ~= nil)then
									return T_HRP
								end
							end
						end
					end

					return HRP
				end
				local T_HRP = Get_Receiving_HRP()

				local CF_Offset_Pos = CFrame.new(Vector3.new(4.31428, 5.22440, -5.47107))
				local Final_Pos = T_HRP.CFrame:ToWorldSpace(CF_Offset_Pos).Position
				local Rot_CF = CFrame.new(Final_Pos, T_HRP.Position)
				local Final_CF = CFrame.new(Final_Pos) * Rot_CF.Rotation

				Cam.CameraType = Enum.CameraType.Scriptable
				TS:Create(Cam, Tween_Cam, {CFrame = Final_CF}):Play()	
				--TS:Create(Hum, Tween_Cam, {CameraOffset = Vector3.new(0, 0, 0)}):Play()	

				if(Cam_RS_Con ~= nil)then
					Cam_RS_Con:Disconnect()
					Cam_RS_Con = nil
				end

				Cam_RS_Con = RS.Stepped:Connect(function()
					if(Cam ~= nil and T_HRP ~= nil and Cam.CameraType == Enum.CameraType.Scriptable)then
						Cam.CFrame = CFrame.new(Cam.CFrame.Position, T_HRP.Position)
					end
				end)
				table.insert(Cons, Cam_RS_Con)
			end
			Play_Init_Camera_Effects()

			Takedown_Track.Priority = Enum.AnimationPriority.Action2
			Animation_Mod.Play_Animation_Track(Takedown_Track, true)

			wait(0.25)

			Submission_Track.Priority = Enum.AnimationPriority.Action3
			Animation_Mod.Play_Animation_Track(Submission_Track)

			Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
		else
			Is_Hit = false
			Is_Cage_Submission = false

			if(HRP ~= nil)then
				HRP.Anchored = false

				local function Reset_Player_Camera()
					if(Prev_Camera_Offset == nil)then
						Prev_Camera_Offset = CFrame.new(Vector3.new()) * CFrame.Angles(0, 0, 0)
					end

					local Cam_CF = HRP.CFrame:ToWorldSpace(Prev_Camera_Offset)
					Cam.CameraType = Enum.CameraType.Scriptable
					TS:Create(Cam, Cam_Tween, {CFrame = Cam_CF}):Play()
					TS:Create(Hum, Tween_Cam, {CameraOffset = Cam_Offset}):Play()

					wait(0.75)

					Set_Cam_Adjustments((Target_HRP == nil))
				end
				task.spawn(Reset_Player_Camera)
			end

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
				Cam.FieldOfView = Cam_FOV
			end

		end
	end

	table.insert(Cons, Bindable_Events_F:WaitForChild("On_Submission_Handle").Event:Connect(function(Is_Attacking, Is_Submission)
		On_Submission_Handle(Is_Attacking, Is_Submission)
	end))


	--Set up Cage Clinch Handle
	local Attack_Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, true)
	local Non_Attack_Clinch_Tracks = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, false)
	local function Cage_Clinch_Handle(Animation_Sequence_Data, Is_Attacking, Camera_CF)
		--[[	
			* Freeze Character
			* Lock the Camera into Position
			* Play Cage Clinch Init
			* Play the Cage Clinch Loop
			* Play the Animation Sequence
			* Reset the Player Animations
			* Play the Idle Animation
			* Reset Player Camera
		]]--

		local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(Char)
			Events_F:WaitForChild("Toggle_Key_Labels"):Fire(false)

			Is_Hit = true
			Is_Cage_Submission = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
		end
		Freeze_Character()

		local function Lock_Camera()
			local Tween_Cam_Clinch = TweenInfo.new(0.375, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
			local Cam_Offset = HRP.CFrame:ToObjectSpace(Cam.CFrame)
			local Init_FOV = Cam.FieldOfView

			Cam.CameraType = Enum.CameraType.Scriptable
			TS:Create(Cam, Cam_Tween, {CFrame = Camera_CF, FieldOfView = 50}):Play()

			return Cam_Offset, Init_FOV
		end
		local Cam_CF_Offset, Init_Cam_FOV = Lock_Camera()

		local function Cam_Shake()
			local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
				Cam.CFrame = Cam.CFrame * shakeCf
			end)
			return CS
		end
		local CamShake = Cam_Shake()

		local function Play_Strike_Sequences()
			local function Get_Clinch_Tracks_Data()
				if(Is_Attacking)then
					return Attack_Clinch_Tracks_Data
				else
					return Non_Attack_Clinch_Tracks
				end
			end
			local Clinch_Tracks_Data = Get_Clinch_Tracks_Data()

			Animation_Mod.Play_Animation_Track(Clinch_Tracks_Data['Init_Clinch'], true)
			task.spawn(Animation_Mod.Play_Animation_Track, Clinch_Tracks_Data['Loop_Clinch'])
			wait(1)

			CamShake:Start()
			local function Play_Clinch_Hit_Effects()
				local Col = Color3.new(1, 0, 0)
				if(Is_Attacking)then
					Col = Color3.new(1, 1, 1)
				end

				Bindable_Events_F:WaitForChild("Show_White_Fade"):Fire(Col)
				CamShake:Shake(Cam_Shake_Mod.Presets.Bump)
			end

			for i = 1, #Animation_Sequence_Data do
				local Strike_Key = Animation_Sequence_Data[i]
				local Strike_Track = Clinch_Tracks_Data[Strike_Key]

				if(Strike_Track ~= nil)then
					--Play Flash, Play Hit Sound Effect, Quick Camera Shake
					Play_Clinch_Hit_Effects()
					Animation_Mod.Play_Animation_Track(Strike_Track)
					--wait(0.5)
				end
			end

			CamShake:Stop()
		end
		Play_Strike_Sequences()

		local function Clinch_Reset_Handle()
			local function Reset_Player_Camera()
				local Tween_Cam_Clinch = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.In, 0, false, 0)
				local Cam_CF = HRP.CFrame:ToWorldSpace(Cam_CF_Offset)
				Cam.CameraType = Enum.CameraType.Scriptable
				TS:Create(Cam, Tween_Cam_Clinch, {CFrame = Cam_CF, FieldOfView = Init_Cam_FOV}):Play()

				wait(0.75)

				Set_Cam_Adjustments((Target_HRP == nil))
			end
			task.spawn(Reset_Player_Camera)

			Animation_Mod.Reset_Character_Animations(Char)
			Events_F:WaitForChild("Toggle_Key_Labels"):Fire(true)
			Is_Hit = false
			Is_Cage_Submission = false

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
				Cam.FieldOfView = Cam_FOV
			end
		end	
		Clinch_Reset_Handle()
	end

	table.insert(Cons, Receiving_Events_F:WaitForChild("Cage_Clinch_Start").OnClientEvent:Connect(function(Sequence_Keys, Is_Attacking, Camera_CF)
		Cage_Clinch_Handle(Sequence_Keys, Is_Attacking, Camera_CF)
	end))	
end

local fightInputLocked = false

Bindable_Events_F:WaitForChild("Set_Fight_Mode_Lock").Event:Connect(function(bool: boolean)
	fightInputLocked = bool
end)

Bindable_Events_F:WaitForChild("Enter_Fight_Mode").Event:Connect(function(Target_HRP, forced: boolean?)
	if fightInputLocked == true and forced ~= true then
		return
	end

	if(Locked_In_Fight == false)then
		if(Char ~= nil and RS_Con == nil and Can_Enter_Fight == true)then
			if(Target_HRP ~= nil)then
				Locked_In_Fight = true
			end

			task.spawn(function()
				Sending_Events_F:WaitForChild("Show_Shield_UI"):FireServer(true)
			end)
			Init_Testing_For_Camera(Target_HRP)


			Bindable_Events_F:WaitForChild("Toggle_Binds_Info"):Fire(true)
			Bindable_Events_F:WaitForChild("Toggle_TopBar"):Fire(false)
		else
			Reset_BG()
			Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true)
			Bindable_Events_F:WaitForChild("Toggle_TopBar"):Fire(true)

			Events_F:WaitForChild("Toggle_Key_Labels"):Fire(false)
			Events_F:WaitForChild("Toggle_Mobile_Buttons"):Fire(false)

			task.spawn(function()
				Sending_Events_F:WaitForChild("Show_Shield_UI"):FireServer(false)
			end)
		end
	end
end)

Bindable_Events_F:WaitForChild("Disable_Fight_Mode").Event:Connect(function(forced: boolean?)
	if fightInputLocked == true and forced ~= true then
		return
	end

	Can_Enter_Fight = false
	Locked_In_Fight = false
	Reset_BG()
	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true)
	Bindable_Events_F:WaitForChild("Toggle_TopBar"):Fire(true)
	Events_F:WaitForChild("Toggle_Key_Labels"):Fire(false)
	Events_F:WaitForChild("Toggle_Mobile_Buttons"):Fire(false)

	task.spawn(function()
		Sending_Events_F:WaitForChild("Show_Shield_UI"):FireServer(false)
	end)

	wait(3)
	Can_Enter_Fight = true
end)


local function Reset_Name_Tag_Handle(C)
	local Name_Tag = C:FindFirstChild("Name_Tag_UI")
	local Toggle_Tabs = {"UIStroke", "Rank_F", "Connection_Img", "Device_Img", "Country_Img", 
		"Player_Name_Txt"}

	if(Name_Tag ~= nil and Name_Tag:FindFirstChild("Main_F") ~= nil)then
		local Main_F = Name_Tag:FindFirstChild("Main_F")

		for i = 1, #Toggle_Tabs do
			local Tab = Main_F:FindFirstChild(Toggle_Tabs[i])
			if(Tab ~= nil)then
				if(Tab:IsA("UIStroke"))then
					Tab.Enabled = true
				else
					Tab.Visible = true
				end
			end
		end

		Main_F.BackgroundTransparency = 0.125

		if(C ~= Char)then
			Name_Tag.StudsOffset = Vector3.new(0, -4, 0)
		end

		Name_Tag.Enabled = true
	end
end

Receiving_Events_F:WaitForChild("End_Fight").OnClientEvent:Connect(function(Target_Char)
	Reset_BG()

	Reset_Name_Tag_Handle(Char)
	if(Target_Char ~= nil)then
		Reset_Name_Tag_Handle(Target_Char)
	end

	Bindable_Events_F:WaitForChild("Toggle_Tool_Buttons"):Fire(false)
	Bindable_Events_F:WaitForChild("Toggle_BG_Volume"):Fire(true)
	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true)
	Bindable_Events_F:WaitForChild("Toggle_TopBar"):Fire(true)
	Events_F:WaitForChild("Toggle_Key_Labels"):Fire(false)
	Events_F:WaitForChild("Toggle_Mobile_Buttons"):Fire(false)

	task.spawn(function()
		Sending_Events_F:WaitForChild("Show_Shield_UI"):FireServer(false)
	end)

	local Ding_SE = SE_Mod.Get_SE_Object(Plr, "Start_Fight_Bell_SE")
	if(Ding_SE ~= nil)then
		Ding_SE:Play()
	end

	Locked_In_Fight = false

	Bindable_Events_F:WaitForChild("Set_Fight_Mode_Lock"):Fire(false)
end)



local bindsState = false
local function UpdateKeybindsUI()
	local device
	if UIS.KeyboardEnabled == true and UIS.GamepadEnabled == false then
		device = "PC"
	elseif UIS.GamepadEnabled == true then
		device = "Console"

		local Mapped_Key = UIS:GetStringForKeyCode(Enum.KeyCode.ButtonX)
		if(Mapped_Key ~= nil and Mapped_Key ~= "ButtonX")then
			device = "PS5"
		end
	else
		device = "Mobile"
	end

	KeybindsFrames.PC.Visible = device == "PC" and bindsState == true
	KeybindsFrames.Console.Visible = device == "Console" and bindsState == true
	KeybindsFrames.PS5.Visible = device == "PS5" and bindsState == true
end

Bindable_Events_F:WaitForChild("Toggle_Binds_Info").Event:Connect(function(state)
	if state ~= bindsState then
		bindsState = state
		UpdateKeybindsUI()
	end
end)

while task.wait(1) do
	UpdateKeybindsUI()
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXD2A35B385931499E9777D21E27293700">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Client_Fight_Handle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXD657110405E64BC6887987FBBC8CAEB6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Mobile_Buttons_Handle.client.lua</string>
							<string name="ScriptGuid">{B828CC71-1E89-4C34-BCD7-7DCB80CE7C13}</string>
							<ProtectedString name="Source"><![CDATA[local UIS = game:GetService("UserInputService")
local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")

local Main_UI = script.Parent.Parent
local Mobile_Buttons_F = Main_UI.Mobile_Buttons_F
local Key_Labels_F = Main_UI.Key_Labels_F
local Events_F = Main_UI.Local_Events_F
local Toggle_Key_Labels_E = Events_F.Toggle_Key_Labels
local Get_Mobile_Buttons_BF = Events_F.Get_Mobile_Buttons
local Toggle_Mobile_Buttons_E = Events_F.Toggle_Mobile_Buttons

local function Toggle_Mobile_Buttons(Should_Show)
	local All_B = Mobile_Buttons_F:GetChildren()
	for i = 1, #All_B do
		if(All_B[i] ~= nil)then
			All_B[i].Visible = Should_Show
		end
	end
end

local function Toggle_Key_Labels(Should_Show)
	if(Should_Show and UIS.TouchEnabled == false)then
		local function Configure_Buttons()
			local function Update_Tab_Display(T)
				local Key_F = T:FindFirstChild("Key_F")
				local Button_F = T:FindFirstChild("Button_F")

				if(Key_F ~= nil and Button_F ~= nil)then
					if(UIS.GamepadEnabled)then
						Key_F.Visible = false
						Button_F.Visible = true
					else
						Key_F.Visible = true
						Button_F.Visible = false
					end
				end
			end

			local All_Tabs = Key_Labels_F:GetChildren()
			for i = 1, #All_Tabs do
				local T = All_Tabs[i]
				if(T ~= nil and T:IsA("Frame"))then
					Update_Tab_Display(T)
				end
			end
		end
		Configure_Buttons()

		Key_Labels_F:TweenPosition(UDim2.new(1, 0, 0.975, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.5, true, nil)
	else
		Key_Labels_F:TweenPosition(UDim2.new(1.15, 0, 0.975, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.375, true, nil)
	end
end

Toggle_Key_Labels_E.Event:Connect(function(Should_Show)
	Toggle_Key_Labels(Should_Show)
end)


local function Configure_Mobile_Buttons()
	local function Get_Size_Origin_Pos()
		local T_Gui = PG:FindFirstChild("TouchGui")
		if(T_Gui ~= nil and T_Gui:FindFirstChild("TouchControlFrame") ~= nil)then
			local TCF = T_Gui:FindFirstChild("TouchControlFrame")
			local JB = TCF:FindFirstChild("JumpButton")

			if(JB ~= nil)then
				local S = JB.Size
				local Main_S = S.X.Offset
				local Split = Main_S / 2
				local Pos = JB.Position
				local Pos_X = Pos.X.Offset + Split
				local Pos_Y = Pos.Y.Offset + Split
				local Origin_Pos = UDim2.new(1, Pos_X, 1, Pos_Y)

				return S, Origin_Pos 
			end
		end

		return UDim2.new(0, 70, 0, 70), UDim2.new(1, -60, 1, -55)
	end
	local Size, Origin_Pos = Get_Size_Origin_Pos()
	local Scale_Inc = Size.X.Offset * 1.3

	local All_B = Mobile_Buttons_F:GetChildren()
	local Button_Data = {

	}

	local function Configure_Button(B)
		local Y_Index = B:GetAttribute("Y_Index") or 0
		local X_Index = B:GetAttribute("X_Index") or 0
		local X_Pos = Origin_Pos.X.Offset + (X_Index * Scale_Inc)
		local Y_Pos = Origin_Pos.Y.Offset + (Y_Index * Scale_Inc)

		B.Size = Size
		B.Position = UDim2.new(1, X_Pos, 1, Y_Pos)
		B.Visible = true
		Button_Data[B.Name] = B
	end

	for i = 1, #All_B do
		local B = All_B[i]
		if(B ~= nil)then
			Configure_Button(B)
		end
	end

	return Button_Data
end

Get_Mobile_Buttons_BF.OnInvoke = function()
	return Configure_Mobile_Buttons()
end

Toggle_Mobile_Buttons_E.Event:Connect(function(Should_Show)
	if(UIS.TouchEnabled == false)then
		Should_Show = false
	end

	Toggle_Mobile_Buttons(Should_Show)
end)

Bindable_Events_F:WaitForChild("Mobile_Takedown_Toggle").Event:Connect(function(Should_Show)
	if(UIS.TouchEnabled)then
		local B = Mobile_Buttons_F:FindFirstChild("Takedown_B")
		if(B ~= nil)then
			B.Visible = Should_Show
		end
	end
end)

]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX2290526C3105400B8BB06644AD23D008">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Server_Fight_Handle.server.lua</string>
						<string name="ScriptGuid">{D339E9B0-8C22-4069-B780-F077A7B967E3}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	* Everything important should happen on the Server
		-> Hit Detection? Check Player's Hitbox Region
			-> Player Found? Use the Damage Power Val and Multiply it by the Damage Power Bar
			-> Apply Damage to Player's Health Value
			-> Apply Force to Player's RootPart
			
			-> Not Blocking? Play Hit Animation on to the Player, Debounce their ability to hit until
]]--
local Debris = game:GetService("Debris")
local TS = game:GetService("TweenService")
local Plr = script.Parent:FindFirstAncestorWhichIsA("Player")
local PD = Plr:WaitForChild("Player_Data")
local FD = Plr:WaitForChild("Fight_Data")
local Health_V = FD:WaitForChild("Health")
local Block_Power_V = FD:WaitForChild("Block Power")
local Stam_V = FD:WaitForChild("Staminia")
local Strike_Power_V = FD:WaitForChild("Strike Power")
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Head = Char:WaitForChild("Head")
local Reset_Fight_Health_Data_E = Char:WaitForChild("Reset_Fight_Health_Data")
local Fight_UI = Char:WaitForChild("Fighting_UI")
local Shield_Img = Fight_UI:WaitForChild("Main_F"):WaitForChild("Shield_F"):WaitForChild("Shield_Img")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Sending_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Bindable_E = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Overhead_Display_E = Sending_Events_F:WaitForChild("Overhead_Display")
local Punch_Hit_VFX = Sending_Events_F:WaitForChild("Show_Punch_Effects")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Sound_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))

local Events_F = script.Parent:WaitForChild("Local_Events_F")
local Heal_PE_TMP = script:WaitForChild("Heal_PE")
local Boxing_Manequins = game.Workspace:WaitForChild("Main_World_F"):WaitForChild("BoxingManequins"):GetChildren()

local function Compile_Punching_Bags()
	local Gym_Equipment_F = game.Workspace:WaitForChild("Main_World_F"):WaitForChild("ScriptableObjects"):WaitForChild("GymObjects")
	local All_E = Gym_Equipment_F:GetChildren()
	local Bags = {}
	
	for i = 1, #All_E do
		local M = All_E[i]
		if(M ~= nil and M.Name == "PunchingBag" and M:FindFirstChild("PunchingBag") ~= nil)then
			local P_Bag = M:FindFirstChild("PunchingBag")
			local Rope_Con = P_Bag:FindFirstChildWhichIsA("RopeConstraint")
			
			if(Rope_Con ~= nil and P_Bag.Anchored == false)then
				P_Bag:SetNetworkOwner(nil)
				table.insert(Bags, P_Bag)
			end
		end
	end
	
	return Bags
end
local Punching_Bags = Compile_Punching_Bags()

local function Get_Player_Val(Key, Get_Object)
	local Val = PD:FindFirstChild(Key)
	if(Val ~= nil)then
		if(Get_Object)then
			return Val
		else
			return Val.Value
		end
	end

	return nil
end

local function Verify_Player(P)
	if(P ~= nil and P == Plr and Char ~= nil and Hum ~= nil)then
		return true
	end
	return false
end

local function Has_Enough_Stam(Min_V)
	if(Stam_V ~= nil and Stam_V.Value >= Min_V)then
		Stam_V.Value -= Min_V
		return true
	end
	return false
end

Events_F:WaitForChild("Dodging_Strike").OnServerEvent:Connect(function(P)
	if(Verify_Player(P) and Has_Enough_Stam(7))then
		--Play the Sound Effect
		--Toggle Value
		Sound_Mod.Play_Sound_Effect(HRP, "Missed_SE")
		Stam_V:SetAttribute("Is_Dodging", true)
		wait(0.5)
		Stam_V:SetAttribute("Is_Dodging", false)
	end
end)


local function Toggle_Heal_PE(Is_Enabled)
	local All_C = HRP:GetChildren()
	for i = 1, #All_C do
		local C = All_C[i]
		if(C ~= nil and C.Name == "Heal_PE" and C:IsA("ParticleEmitter"))then
			C.Enabled = Is_Enabled
		end
	end
	
	if(Shield_Img ~= nil)then
		if(Is_Enabled)then
			Shield_Img.Image = "rbxassetid://130871917395731"
		else
			Shield_Img.Image = "rbxassetid://125284121534949"
		end
	end
end

Events_F:WaitForChild("Blocking_Strike").OnServerEvent:Connect(function(P)
	if(Verify_Player(P) and Block_Power_V ~= nil and Block_Power_V.Value > 0)then
		Block_Power_V:SetAttribute("Is_Blocking", true)
		Toggle_Heal_PE(true)
	end
end)

Events_F:WaitForChild("Unblocking_Strike").OnServerEvent:Connect(function(P)
	if(Verify_Player(P))then
		Block_Power_V:SetAttribute("Is_Blocking", false)
		Toggle_Heal_PE(false)
	end
end)


local function Get_Player_To_Hit()
	local function Create_Whitelist()
		local All_C = game.Workspace:GetChildren()
		local Ret_Chars = {}
		
		for i = 1, #All_C do
			local C = All_C[i]
			if(C ~= nil and C:IsA("Model") and C:FindFirstChildWhichIsA("Humanoid") ~= nil 
				and C ~= Char and C:FindFirstChildWhichIsA("Humanoid").Health > 0)then
				
				table.insert(Ret_Chars, C)
			end
		end
		
		for i, v in pairs(game.Workspace._BOTS_FOLDER_:GetChildren()) do
			table.insert(Ret_Chars, v)
		end
		
		return Ret_Chars
	end
	local Whitelist_Chars = Create_Whitelist()
	local Overlap_P = OverlapParams.new()
	Overlap_P.MaxParts = 1
	Overlap_P.FilterType = Enum.RaycastFilterType.Include
	Overlap_P.FilterDescendantsInstances = {Whitelist_Chars}
	
	local function Create_Region_CF()
		local Plr_Ping = math.clamp(Plr:GetNetworkPing(), 0, 0.5)
		local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
		local Distance = ((Speed * Plr_Ping) + 3)
		local Head_Dir = Head.CFrame.LookVector
		local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)
		
		--local cframe = CFrame.new(Adjusted_Pos) * HRP.CFrame.Rotation
		local cframe = HRP.CFrame * CFrame.new(0, 0, -3)
		return cframe
	end
	local Spawn_CF = Create_Region_CF()
	local Hitbox_Size = Vector3.new(4, 8, 4)
	
	--local part = Instance.new("Part")
	--part.CFrame = Spawn_CF
	--part.Size = Hitbox_Size
	--part.Transparency = 0.5
	--part.BrickColor = BrickColor.Red()
	--part.CanCollide = false
	--part.Anchored = true
	--part.Parent = game.Workspace
	
	--task.delay(1, function()
	--	part:Destroy()
	--end)
	
	local function Create_Hitbox_Part()
		local P = Instance.new("Part", game.Workspace)
		P.Name = "Hitbox_Part"
		P.Anchored = true
		P.CanCollide = false
		P.Transparency = 0.5
		P.Color = Color3.new(1, 0, 0)
		P.Material = Enum.Material.SmoothPlastic
		P.Size = Hitbox_Size
		P.CFrame = Spawn_CF
		
		Debris:AddItem(P, 5)
	end
	--Create_Hitbox_Part()
	
	local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
	if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
		local function Get_Char_From_BP()
			for i = 1, #Whitelist_Chars do
				local C = Whitelist_Chars[i]
				if(C ~= nil and Region_Data[1]:IsDescendantOf(C))then
					return C
				end
			end
			
			return Whitelist_Chars[1]
		end
		
		return Get_Char_From_BP()
	end
	
	return nil
end

local function Get_Bag_You_Hit()
	local Overlap_P = OverlapParams.new()
	Overlap_P.MaxParts = 1
	Overlap_P.FilterType = Enum.RaycastFilterType.Include
	Overlap_P.FilterDescendantsInstances = Punching_Bags

	local function Create_Region_CF()
		local Plr_Ping = math.clamp(Plr:GetNetworkPing(), 0, 0.5)
		local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
		local Distance = ((Speed * Plr_Ping) + 3)
		local Head_Dir = Head.CFrame.LookVector
		local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

		return CFrame.new(Adjusted_Pos) * HRP.CFrame.Rotation
	end
	local Spawn_CF = Create_Region_CF()
	local Hitbox_Size = Vector3.new(4, 8, 4)

	local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
	if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
		return Region_Data[1]
	end

	return nil
end

local function Get_Boxing_Dummy_You_Hit()
	local Overlap_P = OverlapParams.new()
	Overlap_P.MaxParts = 1
	Overlap_P.FilterType = Enum.RaycastFilterType.Include
	Overlap_P.FilterDescendantsInstances = Boxing_Manequins

	local function Create_Region_CF()
		local Plr_Ping = math.clamp(Plr:GetNetworkPing(), 0, 0.5)
		local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
		local Distance = ((Speed * Plr_Ping) + 3)
		local Head_Dir = Head.CFrame.LookVector
		local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

		return CFrame.new(Adjusted_Pos) * HRP.CFrame.Rotation
	end
	local Spawn_CF = Create_Region_CF()
	local Hitbox_Size = Vector3.new(4, 8, 4)

	local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
	if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
		return Region_Data[1]
	end

	return nil
end

local function Apply_Boxing_Dummy_Effects(Dummy_M)
	local Anim_Controller = Dummy_M:FindFirstChildWhichIsA("AnimationController")
	local Ani_ID = 80256702338294
	
	if(Anim_Controller ~= nil)then
		local function Create_Animation_Obj()
			local Ani = Dummy_M:FindFirstChild(Ani_ID .. "_Ani")
			if(Ani == nil)then
				Ani = Instance.new("Animation", Dummy_M)
				Ani.Name = Ani_ID .. "_Ani"
				Ani.AnimationId = "rbxassetid://" .. Ani_ID
			end
			
			return Ani
		end
		local Ani_Obj = Create_Animation_Obj()
		local Anim_Track = Anim_Controller:LoadAnimation(Ani_Obj)
		Anim_Track.Looped = false
		Anim_Track:Play()
		
		--Play Hit Sound Effect
		Sound_Mod.Play_Sound_Effect(HRP, "Punch_Hit_SE")
	end
end

local function Get_Punch_Power()
	local Tween_Punch_Power_Back = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0.75)
	local Strike_Power = Strike_Power_V.Value
	Strike_Power_V.Value = 1
	TS:Create(Strike_Power_V, Tween_Punch_Power_Back, {Value = 6}):Play()
	return Strike_Power
end

local function Get_Target_Fight_Data(Hit_Char)
	local Hit_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
	if(Hit_Plr ~= nil)then
		return Hit_Plr:FindFirstChild("Fight_Data")
	else
		return Hit_Char:FindFirstChild("Fight_Data")
	end
end

Events_F:WaitForChild("Throwing_Strike").OnServerEvent:Connect(function(P, Strike_Key, Dir)
	--> Verify Player, Verify owns the Strike Key, Verify has Enough Stam to throw the Punch
		--> Get & Reset Punch Power
		--> Check if There is a Character within the Region Box 
			--> Are they Blocking and do they have Enough Block Power? ~ Damage the Block Power & Play Damage Text
			--> Are they Dodging? Play the Dodging Text above their Head
			--> Hit them, Apply Health Deduct ~ Apply Force to HRP, Play Sound Effect
			
	if(Verify_Player(P) and HRP ~= nil and Animation_Mod.Player_Owns_Strike_Key(P, Strike_Key) and 
		Has_Enough_Stam(3))then
		
		local Base_Punch_Power = Get_Punch_Power()
		local Hit_Char = Get_Player_To_Hit()
		local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Strike_Key)
		local Power_Inc = Strike_Data['Power Multi'] or 0
		local Punch_Power = math.ceil(Base_Punch_Power * (1  + Power_Inc))
		Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Strikes", 1)
		Plr:SetAttribute("Did_Punch_Last", Strike_Data['Punch'])
		
		if(Hit_Char ~= nil)then
			local Hit_Fight_Data = Get_Target_Fight_Data(Hit_Char)
			if(Hit_Fight_Data ~= nil and Hit_Fight_Data:FindFirstChild("Health") ~= nil and 
				Hit_Fight_Data:FindFirstChild("Block Power") ~= nil and 
				Hit_Fight_Data:FindFirstChild("Staminia") ~= nil)then
				
				local T_Health = Hit_Fight_Data:FindFirstChild("Health")
				local T_Block_Power = Hit_Fight_Data:FindFirstChild("Block Power")
				local T_Staminia = Hit_Fight_Data:FindFirstChild("Staminia")
				
				local function Is_Dodging_Check()
					local Is_Dodging = T_Staminia:GetAttribute("Is_Dodging")
					if(Is_Dodging ~= nil and Is_Dodging == true)then
						local Target_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
						if(Target_Plr ~= nil)then
							Stats_Manager_Mod.Add_To_Player_Stats_Data(Target_Plr, "Dodged Strikes", 1)
						end
						
						return true
					end
					return false
				end

				local function Is_Blocking_Check()
					local Is_Block = T_Block_Power:GetAttribute("Is_Blocking")
					if(Is_Block ~= nil and Is_Block == true)then
						T_Block_Power.Value -= Punch_Power
						Overhead_Display_E:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.fromRGB(170, 85, 255))
						
						local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
						if targetPlr ~= nil then
							Sending_Events_F:WaitForChild("Got_Hit_Effect"):FireClient(targetPlr)
						end
						
						if(T_Block_Power.Value < 0)then
							local Dif = math.abs(T_Block_Power.Value)
							T_Health.Value = math.clamp(T_Health.Value - Dif, 0, 100)
							T_Block_Power.Value = 0
							
							Sound_Mod.Play_Sound_Effect(HRP, "Punch_Hit_SE")
							Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
							
							Overhead_Display_E:FireAllClients(Hit_Char, "-" .. Dif, Color3.new(1, 0, 0))
						
						else
							Sound_Mod.Play_Sound_Effect(HRP, "Blocked_Hit_SE")
						end
						
						return true
					end
					
					return false
				end

				if(Is_Dodging_Check())then
					--Play Dodging Text
					Overhead_Display_E:FireAllClients(Hit_Char, "Dodged", Color3.fromRGB(35, 244, 68))
				elseif(Is_Blocking_Check())then
					--Play Blocking 
				else
					--Apply the Hit
					local function Apply_Strike()
						T_Health.Value = math.clamp(T_Health.Value - Punch_Power, 0, 100)
						
						Sound_Mod.Play_Sound_Effect(HRP, "Punch_Hit_SE")
						
						
						Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
						Overhead_Display_E:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.new(1, 0, 0))
						Punch_Hit_VFX:FireClient(Plr, Hit_Char)
						
						local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
						if targetPlr ~= nil then
							Sending_Events_F:WaitForChild("Got_Hit_Effect"):FireClient(targetPlr)
						end
						--Play Damage Val Show
						
						local T_HRP = Hit_Char:FindFirstChild("HumanoidRootPart")
						if(T_HRP ~= nil)then
							local Hit_Force = 625 -- Was 350 then 500
							local Dir = HRP.CFrame.LookVector 
							T_HRP:ApplyImpulse(Dir * Hit_Force * T_HRP:GetMass())
						end
					end
					Apply_Strike()
				end
			end
		
		else
			local Hit_Punching_Bag = Get_Bag_You_Hit()
			if(Hit_Punching_Bag ~= nil)then
				local Hit_Force = 50 -- Was 350 then 500
				local Dir = HRP.CFrame.LookVector 
				Hit_Punching_Bag:ApplyImpulse(Dir * Hit_Force * Hit_Punching_Bag:GetMass())
				
				Sound_Mod.Play_Sound_Effect(HRP, "Punch_Hit_SE")
			else
				local Hit_Dummy = Get_Boxing_Dummy_You_Hit()
				if(Hit_Dummy ~= nil and Hit_Dummy:FindFirstAncestorWhichIsA("Model") ~= nil)then
					local Dummy_M = Hit_Dummy:FindFirstAncestorWhichIsA("Model")
					Apply_Boxing_Dummy_Effects(Dummy_M)
				end
			end
			
			
		end
	end
end)


local function Fight_Data_Growth_Handle()
	--Autonatically Heal the Player when Blocking and Blocking Power is >0
	--Automatically Heal the Block Power 
	repeat wait() until Block_Power_V:GetAttribute("Is_Blocking") ~= nil
	
	local Tween_Health_Con = nil
	local Tween_Stam_Con = nil
	local Tween_Block_Con = nil

	local function Reset_Healing_Cons()
		if(Tween_Health_Con ~= nil)then
			Tween_Health_Con:Cancel()
			Tween_Health_Con = nil
		end
		
		if(Tween_Stam_Con ~= nil)then
			Tween_Stam_Con:Cancel()
			Tween_Stam_Con = nil
		end
	end
	
	local function Set_Healing_Cons()
		local Health_Time = math.clamp((100 - Health_V.Value) * 0.6, 0.6, 60) * 3
		local Tween_Full_Health = TweenInfo.new(Health_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
		Tween_Health_Con = TS:Create(Health_V, Tween_Full_Health, {Value = 100})
		Tween_Health_Con:Play()
		
		local Stam_Time = math.clamp((100 - Stam_V.Value) * 0.1, 0.1, 10)
		local Tween_Full_Stam = TweenInfo.new(Stam_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)	
		Tween_Stam_Con = TS:Create(Stam_V, Tween_Full_Stam, {Value = 100})
		Tween_Stam_Con:Play()
	end

	Block_Power_V.AttributeChanged:Connect(function(Attrib_Key)
		if(Attrib_Key == "Is_Blocking" and Block_Power_V:GetAttribute("Is_Blocking") ~= nil)then
			Reset_Healing_Cons()
			if(Block_Power_V:GetAttribute("Is_Blocking") == true)then
				Set_Healing_Cons()
			end
		end
	end)
	
	local Prev_Block_Val = Block_Power_V.Value
	Block_Power_V.Changed:Connect(function()
		--Wait 3 Seconds, If Block Power not maxed
			--> Tween the 
		local Main_Prev = Prev_Block_Val
		Prev_Block_Val = Block_Power_V.Value
		if(Block_Power_V.Value < 30 and Block_Power_V.Value < Main_Prev)then
			if(Tween_Block_Con ~= nil)then
				Tween_Block_Con:Cancel()
				Tween_Block_Con = nil
			end
			
			local Block_Time = math.clamp((30 - Block_Power_V.Value) * 0.2667, 0.2667, 8)
			local Tween_Block_Power = TweenInfo.new(Block_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 6)
			Tween_Block_Con = TS:Create(Block_Power_V, Tween_Block_Power, {Value = 30})
			Tween_Block_Con:Play()
			Tween_Block_Con.Completed:Wait()
			--Tween_Block_Con:Disconnect()
			Tween_Block_Con = nil
		end
	end)
	
	Reset_Fight_Health_Data_E.Event:Connect(function()
		Reset_Healing_Cons()
		
		if(Tween_Block_Con ~= nil)then
			Tween_Block_Con:Cancel()
			Tween_Block_Con = nil
		end
		
		Health_V.Value = 100
		Stam_V.Value = 100
		Block_Power_V.Value = 30
	end)
end
Fight_Data_Growth_Handle()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX4BF05327BAC64DC8A43C11AFE672AA48">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">HUD</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX34E901DF899441AFA7ECF7760B787D86">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">HUD_Handler.client.lua</string>
						<string name="ScriptGuid">{650DBA65-F487-4154-800B-FE29773B6001}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	HUD Handler
	
	Made by ArtisticVampyre
]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players:Players = game:GetService("Players")
local Player = Players.LocalPlayer

local Vendor:Folder = ReplicatedStorage:FindFirstChild("Vendor")
local Find = require(Vendor:FindFirstChild("Find"))
local Spr = require(Vendor:FindFirstChild("Spr"))

local BindCurrency = require(script.BindCurrency)
local BindTopbar = require(script.BindTopbar)
local BindTools = require(script.BindTools)
local BindMenu = require(script.BindMenu)

local Channels_F = ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")

local Bindable_Events_F = Bindable_F:WaitForChild("Events")

local HUD:ScreenGui = script.Parent
local CurrencyFrame:Frame = HUD:WaitForChild("CurrencyIndicators")
local ToolsFrame:Frame = HUD:WaitForChild("Tools")
local MenuFrame:Frame = HUD:WaitForChild("Menu")

local ToggleSideButtons:BindableEvent = Bindable_Events_F:FindFirstChild("Toggle_Side_Buttons")
local ToggleToolButtons:BindableEvent = Bindable_Events_F:FindFirstChild("Toggle_Tool_Buttons")


local function ToggleMenu(toggleValue:boolean, affectsBottomBar:boolean)
	CurrencyFrame.Visible = toggleValue
	MenuFrame.Visible = toggleValue
	
	if affectsBottomBar == true then
		ToolsFrame.Visible = toggleValue
	end
end

local function ToggleTools(toggleValue:boolean)
	ToolsFrame.Fight.Visible = toggleValue
end

local function Init()
	--ToggleToolButtons.Event:Connect(ToggleTools)
	ToggleSideButtons.Event:Connect(ToggleMenu)
	task.spawn(BindCurrency,CurrencyFrame)
	task.spawn(BindTools,ToolsFrame)
	task.spawn(BindMenu,MenuFrame)
	task.spawn(BindTopbar)
end

Init()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXCE2CA362BF9245E6B569B7259E67224B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">HUD_Handler</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX55B8ECA8BFC6482297E4C22AA8529447">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Friend_Invite_Handle.client.lua</string>
							<string name="ScriptGuid">{BC666216-88A3-453D-9B58-B81006C365F4}</string>
							<ProtectedString name="Source"><![CDATA[local SS = game:GetService("SocialService")
local VCS = game:GetService("VoiceChatService")
local Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Display_Data_E = Bindable_Events_F:WaitForChild("Display_Data")

local Invite_Options = Instance.new("ExperienceInviteOptions")
Invite_Options.PromptMessage = "Invite your Friends for +10% Luck!"
Invite_Options.InviteMessageId = "bc7cffbc-7709-214a-8ecb-b6452021927d"

local function Display_Invite_UI(Show_Msg)
	local function Can_Send_Invite()
		local function Async()
			local success, errormessage = pcall(function()
				return SS:CanSendGameInviteAsync(Plr)
			end)

			if(success)then
				return true
			end
			return false
		end

		for i = 1, 3 do
			local D = Async()
			if(D)then
				return D
			end
		end

		return false
	end

	if(Show_Msg)then
		Display_Data_E:Fire(" Invite your Friends to earn more Luck!", Color3.new(1, 1, 0))
	end

	if(Can_Send_Invite())then
		local function Show_Invite()
			local function Async()
				local success, errormessage = pcall(function()
					SS:PromptGameInvite(Plr, Invite_Options)
				end)

				if(success)then
					return true
				end
				return false
			end

			for i = 1, 3 do
				local D = Async()
				if(D)then
					return
				end
			end
		end
		Show_Invite()
	end
end

Bindable_Events_F:WaitForChild("Prompt_Invite").Event:Connect(function()
	Display_Invite_UI(true)
end)


local function VC_Prompt()
	local function Can_Prompt_VC()
		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				VCS:IsVoiceEnabledForUserIdAsync(Plr.UserId)
			end)
			
			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end
		
		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				return D
			end
		end	
		
		return false
	end
	
	if(Can_Prompt_VC() == false)then
		local Txt = " You must enable your Voice Chat within your Roblox Settings!"
		Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
	else
		local Txt = " Trash Talk with Voice Chat!"
		Display_Data_E:Fire(Txt, Color3.fromRGB(0, 170, 255))
	end
end

Bindable_Events_F:WaitForChild("Voice_Chat_Prompt").Event:Connect(function()
	VC_Prompt()
end)]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX00F72B91DC004C55A55DE17893665A64">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BindCurrency.lua</string>
							<string name="ScriptGuid">{B0FE9282-AB2B-4EA5-9FAE-9E93246B63CA}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players:Players = game:GetService("Players")
local Player = Players.LocalPlayer

local PlayerDataDir:Folder = Player:WaitForChild("Player_Data")
local PlayerCash:NumberValue = PlayerDataDir:WaitForChild("Coins")
local PlayerGems:NumberValue = PlayerDataDir:WaitForChild("Gems")

local Num_Str_Mod = require(ReplicatedStorage.Data_Mods_F.Num_String_Mod)
local Find = require(ReplicatedStorage.Vendor.Find)

local Channels_F = ReplicatedStorage:FindFirstChild("Channels_F")
local Bindable_F = Channels_F:FindFirstChild("Bindable_F")

local Bindable_Events_F = Bindable_F:FindFirstChild("Events")
local OpenShopEvent = Bindable_Events_F:FindFirstChild("Open_Shop")

return function(currencyFrame:Frame, self)
	local function SetupCurrency(valueObject:NumberValue,index:string)
		local targetFrame:Frame = currencyFrame:WaitForChild(index)
		Find(targetFrame,"Currency",function(currencyField:TextLabel)
			currencyField.Text = Num_Str_Mod.NumToString(valueObject.Value)
			valueObject.Changed:Connect(function()
				currencyField.Text = Num_Str_Mod.NumToString(valueObject.Value)
			end)
		end)

		Find(targetFrame,"AddCurrency",function(addButton:ImageButton)
			addButton.Activated:Connect(function()
				OpenShopEvent:Fire(index)
			end)
		end)
	end

	SetupCurrency(PlayerCash,"Cash")
	SetupCurrency(PlayerGems,"Gems")
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8C2F706C20F84BB68C3310720793485F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BindMenu.lua</string>
							<string name="ScriptGuid">{CDA6996C-E03E-4ADF-BFB8-DCBBBC580FAD}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players:Players = game:GetService("Players")
local Player = Players.LocalPlayer

local Channels_F = ReplicatedStorage:FindFirstChild("Channels_F")
local Bindable_F = Channels_F:FindFirstChild("Bindable_F")

local Bindable_Events_F = Bindable_F:FindFirstChild("Events")

local PlayerDataDir:Folder = Player:WaitForChild("Player_Data")
local PlayerCash:NumberValue = PlayerDataDir:WaitForChild("Coins")
local PlayerGems:NumberValue = PlayerDataDir:WaitForChild("Gems")

local Num_Str_Mod = require(ReplicatedStorage.Data_Mods_F.Num_String_Mod)
local Find = require(ReplicatedStorage.Vendor.Find)
local Spr = require(ReplicatedStorage.Vendor.Spr)

local EventsList = {
	['SkillTree'] = Bindable_Events_F:FindFirstChild("Open_Skill_Tree"),
	['Servers'] = Bindable_Events_F:FindFirstChild("Open_Servers"),
	['Avatar'] = Bindable_Events_F:FindFirstChild("Open_Avatar"),
	['Combo'] = Bindable_Events_F:FindFirstChild("Open_Combos"),
	['Codes'] = Bindable_Events_F:FindFirstChild("Open_Codes"),
	['Stats'] = Bindable_Events_F:FindFirstChild("Open_Stats"),
	['Shop'] = Bindable_Events_F:FindFirstChild("Open_Shop"),
	['SessionRewards'] = Bindable_Events_F:FindFirstChild("Open_Session_Rewards"),
}

local function CreateButton(root:Frame)
	local newButton = Instance.new("ImageButton")
	newButton.Size = UDim2.fromScale(1,1)
	newButton.BackgroundTransparency = 1
	newButton.ImageTransparency = 1
	newButton.Parent = root
	return newButton
end

return function(menuFrame:Frame)
	local function SetupButton(entryFrame:Frame)
		local mainEntry:Frame = entryFrame:FindFirstChild("Entry")
		if not mainEntry then
			return
		end

		local entryButton:ImageButton = CreateButton(mainEntry)
		local animationLocked = false

		entryButton.MouseEnter:Connect(function()
			if animationLocked then
				return
			end
			Spr.target(mainEntry,0.6,3,{
				Size = UDim2.fromScale(1.1,1.1)
			})
		end)

		entryButton.MouseLeave:Connect(function()
			if animationLocked then
				return
			end
			Spr.target(mainEntry,0.6,3,{
				Size = UDim2.fromScale(1,1)
			})
		end)

		entryButton.Activated:Connect(function()
			animationLocked = true

			Spr.target(mainEntry,0.6,3,{
				Size = UDim2.fromScale(0.9,0.9)
			})

			task.delay(1/8,function()
				animationLocked = false
				Spr.target(mainEntry,0.6,3,{
					Size = UDim2.fromScale(1,1)
				})
			end)

			if(EventsList[entryFrame.Name] ~= nil)then
				EventsList[entryFrame.Name]:Fire()
			end
		end)
	end

	local skillTreeFrame:Frame = menuFrame:FindFirstChild("SkillTree")
	local mainFrame:Frame = menuFrame:FindFirstChild("MainFrame")
	if mainFrame then
		for _, entryFrame:Frame in mainFrame:GetChildren() do
			if not entryFrame:IsA("Frame") then
				continue
			end

			task.spawn(SetupButton,entryFrame)
		end
	end
	if skillTreeFrame then
		task.spawn(SetupButton,skillTreeFrame)
	end
end
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE810D27288C041B7814572AAF3BCA27B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BindTools.lua</string>
							<string name="ScriptGuid">{DEED0A85-06A3-47BF-9867-18D9E41F7AF0}</string>
							<ProtectedString name="Source"><![CDATA[local UserInputService:UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local Player:Player = Players.LocalPlayer

local Bindables = ReplicatedStorage:FindFirstChild("Channels_F"):FindFirstChild("Bindable_F")
local BindableEvents:Folder = Bindables:FindFirstChild("Events")
local BindableFunctions:Folder = Bindables:FindFirstChild("RF")

local OpenEmotes = BindableEvents:FindFirstChild("Open_Emotes")
local EnterFightMode = BindableEvents:FindFirstChild("Enter_Fight_Mode")
local ToggleToolButtons = BindableEvents:FindFirstChild("Toggle_Tool_Buttons")
local OnSubmissionHandle = BindableEvents:FindFirstChild("On_Submission_Handle")

local Is_Chatbox_Typing = BindableFunctions:FindFirstChild("Is_Chatbox_Typing") 

local Data_Mods_F = ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Click_SE = SE_Mod.Get_SE_Object(Player, "Click_SE")
local Spr = require(ReplicatedStorage.Vendor.Spr)
local Gym_Entry = workspace:WaitForChild("Gym_Entry")
local Gym_Exit = workspace:WaitForChild("Gym_Exit")

local function CreateButton(root:Frame)
	local newButton = Instance.new("ImageButton")
	newButton.Size = UDim2.fromScale(1,1)
	newButton.BackgroundTransparency = 1
	newButton.ImageTransparency = 1
	newButton.Parent = root
	return newButton
end

return function(toolsFrame:Frame)
	local emotesFrame:Frame = toolsFrame:WaitForChild("Emotes")
	local fightFrame:Frame = toolsFrame:WaitForChild("Fight")

	local emotesKeybind:Frame = emotesFrame:WaitForChild("Keybind")
	local fightKeybind:Frame = fightFrame:WaitForChild("Keybind")

	local emotesKey:TextLabel = emotesKeybind:WaitForChild("Keybind"):WaitForChild("Txt")
	local fightKey:TextLabel = fightKeybind:WaitForChild("Keybind"):WaitForChild("Txt")
	
	local emotesButton = CreateButton(emotesFrame)
	local fightButton = CreateButton(fightFrame)
	
	local function SetupButton(rootFrame:Frame,callback)
		local newButton = CreateButton(rootFrame)
		local animLocked = false
		newButton.MouseEnter:Connect(function()
			if animLocked then
				return
			end
			Spr.target(rootFrame,0.6,3,{
				Size = UDim2.fromScale(1.1,1.1)
			})
		end)
		newButton.MouseLeave:Connect(function()
			if animLocked then
				return
			end
			Spr.target(rootFrame,0.6,3,{
				Size = UDim2.fromScale(1,1)
			})
		end)
		newButton.Activated:Connect(function()
			animLocked = true
			Spr.target(rootFrame,0.6,3,{
				Size = UDim2.fromScale(0.9,0.9)
			})
			task.delay(1/5,function()
				animLocked = false
				Spr.target(rootFrame,0.6,3,{
					Size = UDim2.fromScale(1,1)
				})
				callback()
			end)
		end)
	end

	local function Keycode_Display_Handle()
		if(UserInputService.TouchEnabled)then
			emotesKeybind.Visible = false
			fightKeybind.Visible = false
		else
			if(UserInputService.GamepadEnabled)then
				fightKey.Text = "L1"
				emotesKey.Text = "R1"
			else
				fightKey.Text = "1"
				emotesKey.Text = "2"
			end

			emotesKeybind.Visible = true
			fightKeybind.Visible = true
		end
	end

	Keycode_Display_Handle()
	--UserInputService.LastInputTypeChanged:Connect(Keycode_Display_Handle)

	if(UserInputService.TouchEnabled == false)then
		UserInputService.InputBegan:Connect(function(input, GPE)
			if (Is_Chatbox_Typing:Invoke() == true) then
				return
			end
			
			if ((input.KeyCode == Enum.KeyCode.One or input.KeyCode == Enum.KeyCode.ButtonL1)) then
				if(fightFrame.Visible) then
					Click_SE:Play()
					EnterFightMode:Fire()
				end
			elseif(input.KeyCode == Enum.KeyCode.Two or input.KeyCode == Enum.KeyCode.ButtonR1)then
				Click_SE:Play()
				OpenEmotes:Fire()
			end
		end)
	end
	
	SetupButton(emotesFrame,function()
		OpenEmotes:Fire()
	end)
	SetupButton(fightFrame,function()
		EnterFightMode:Fire()
	end)
	
	local function Toggle_Button_Display(Is_Enabled)
		if(Is_Enabled)then
			fightFrame.Visible = true
		else
			fightFrame.Visible = false
		end
	end
	Toggle_Button_Display(false)

	local function Toggle_Whole_Menu(Is_Enabled)
		toolsFrame.Visible = Is_Enabled
	end
	
	ToggleToolButtons.Event:Connect(function(Is_Enabled)
		Toggle_Button_Display(Is_Enabled)
	end)

	OnSubmissionHandle.Event:Connect(function(Is_Attacking, Is_Submission)
		local state = not (Is_Attacking or Is_Submission)
		Toggle_Whole_Menu(state)
	end)


	-- Dtection quand un joueur entre
	local fight_enabled=false
	Gym_Entry.Touched:Connect(function(hit)
		if(not fight_enabled) then
			local character = hit.Parent
			local player = game.Players:GetPlayerFromCharacter(character)
			if player and player == game.Players.LocalPlayer then
				warn("entry")
				fight_enabled=true
				Toggle_Button_Display(true)
			end
		end
	end)

	-- Dtection quand un joueur sort
	Gym_Exit.Touched:Connect(function(hit)
		if(fight_enabled) then
			local character = hit.Parent
			local player = game.Players:GetPlayerFromCharacter(character)
			if player and player == game.Players.LocalPlayer then
				warn("exit")
				fight_enabled = false
				Toggle_Button_Display(false)
				
				-- fire un nouvel event Exit_Fight_Mode
				local Bindable_Events_F = game.ReplicatedStorage:WaitForChild("Channels_F"):WaitForChild("Bindable_F"):WaitForChild("Events")
				Bindable_Events_F:WaitForChild("Disable_Fight_Mode"):Fire()
			end
		end
	end)
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD5966EA63F8B4078B06F1B7993AC867E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BindTopbar.lua</string>
							<string name="ScriptGuid">{6332B333-1FBC-45BC-8B62-3A7F01D85D09}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-- Events 
local OpenSettings = ReplicatedStorage.Channels_F.Bindable_F.Events.Open_Settings
local PromptInvite = ReplicatedStorage.Channels_F.Bindable_F.Events.Prompt_Invite
local OpenTutorial = ReplicatedStorage.Channels_F.Bindable_F.Events.Show_Tutorial
local CloseTutorial = ReplicatedStorage.Channels_F.Bindable_F.Events.Close_Tutorial
local PromptVC = ReplicatedStorage.Channels_F.Bindable_F.Events.Voice_Chat_Prompt
local ToggleList = ReplicatedStorage.Channels_F.Bindable_F.Events.Toggle_Player_List
local ToggleToBar = ReplicatedStorage.Channels_F.Bindable_F.Events.Toggle_TopBar
local OpenChangelog = ReplicatedStorage.Channels_F.Bindable_F.Events.Open_Changelog
local CloseChangelog = ReplicatedStorage.Channels_F.Bindable_F.Events.Close_Changelog
local EnterFightMode = ReplicatedStorage.Channels_F.Bindable_F.Events.Enter_Fight_Mode
local CloseFightResult = ReplicatedStorage.Channels_F.Bindable_F.Events.Close_Fight_Result


local function findTopbarPlus()
	-- Priorit: Packages/TopbarPlus (Wally) -> ReplicatedStorage/TopbarPlus (modle)
	local pkg = ReplicatedStorage:FindFirstChild("Vendor")
	if pkg and pkg:FindFirstChild("TopbarPlus") then
		return pkg.TopbarPlus
	end
	return ReplicatedStorage:FindFirstChild("TopbarPlus")
end


local TopbarPlusModule = findTopbarPlus()
assert(TopbarPlusModule, "TopBarPlus module not found. Place it in ReplicatedStorage or ReplicatedStorage/Packages.")

local TopbarPlus = require(TopbarPlusModule) -- retourne lAPI v3 (Icon)

return function()
	-- Settings button
	local settingsButton = TopbarPlus.new()
		:align("Left")
		:setLabel("", "Deselected")
		:setLabel("", "Selected")
		:setCaption("Settings")

	settingsButton.toggled:Connect(function(isSelected)
		OpenSettings:Fire(isSelected)
	end)

	ReplicatedStorage.Channels_F.Bindable_F.Events.Close_Settings.Event:Connect(function()
		settingsButton:deselect()
	end)

	-- Invite button
	local inviteButton = TopbarPlus.new():setImage("rbxassetid://13436732683"):align("Left")
	inviteButton.toggled:Connect(function()
		PromptInvite:Fire()
	end)

	-- Bouton What's New (changelog) en premier
	local changelogButton = TopbarPlus.new()
		:align("Left")
		:setCaption("What's New")  
		:setLabel("","Deselected")
		:setLabel("","Selected")

	changelogButton.toggled:Connect(function(isSelected)
		if isSelected then
			OpenChangelog:Fire()
		else
			CloseChangelog:Fire()
		end
	end)

	-- Quand lUI Changelog se ferme (via bouton close interne)
	ReplicatedStorage.Channels_F.Bindable_F.Events.End_Changelog.Event:Connect(function()
		changelogButton:deselect()
	end)

	-- Tutorial button
	local helpButton = TopbarPlus.new()
		:align("Left")
		:setCaption("Tutorial")
		:setLabel("", "Deselected")
		:setLabel("", "Selected")

	-- helpButton:deselect()

	helpButton.toggled:Connect(function(isSelected)
		if isSelected then
			OpenTutorial:Fire()
		else
			CloseTutorial:Fire()
		end
	end)

	ReplicatedStorage.Channels_F.Bindable_F.Events.End_Tutorial.Event:Connect(function()
		helpButton:deselect()
	end)

	-- List button on the right side
	local listButton = TopbarPlus.new():setImage("rbxassetid://100127687172105"):align("Right")
	listButton.toggled:Connect(function()
		ToggleList:Fire()
	end)


	local visible = true
	ToggleToBar.Event:Connect(function(bool)
		if bool == nil then
			visible = not visible
		else
			visible = bool
		end

		inviteButton:setEnabled(visible)
		settingsButton:setEnabled(visible)
		changelogButton:setEnabled(visible)
		helpButton:setEnabled(visible)
	end)

	-- Quand lUI dailyrewards se ferme
	local DailyRewardsClosed = ReplicatedStorage.Channels_F.Bindable_F.Events:WaitForChild("Close_DailyRewards")
	DailyRewardsClosed.Event:Connect(function()
		-- commented until we find a satisfying way to pulse with TopBar plus button
		--highlightButton(changelogButton, 5)
		--highlightButton(helpButton, 5)
	end)

end

]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX8E6D850CEC9A478CAB87232C40797897">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Main_Code.client.lua</string>
						<string name="ScriptGuid">{D4270ECF-14A5-47BD-93F1-C20E33BB50E6}</string>
						<ProtectedString name="Source"><![CDATA[local MPS = game:GetService("MarketplaceService")
local TS = game:GetService("TweenService")
local SS = game:GetService("SocialService")
local Plr = game.Players.LocalPlayer
local Channel_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channel_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Msg_E = Bindable_Events_F:WaitForChild("Display_Notification")
local Module_F = game.ReplicatedStorage:WaitForChild("Modules_F")
local Monetization_Mod = require(Module_F:WaitForChild("Monetization_Mod"))

local SE = script.Parent.SE
local Main_F = script.Parent.Main_F

local Debounce_E = false
local Debounce_C = false

local GP_Data = Monetization_Mod.Get_All_Gamepass_Data()
local Invite_Options = Instance.new("ExperienceInviteOptions")
Invite_Options.PromptMessage = "Invite your Friends for +10 Health!"
Invite_Options.InviteMessageId = "7b5f8fd4-c329-4f4c-bf16-b833ab2e12ab"

local function Invite_Handle()
	local function Can_Send_Invite()
		local function Async()
			local success, errormessage = pcall(function()
				return SS:CanSendGameInviteAsync(Plr)
			end)

			if(success)then
				return true
			end
			return false
		end

		for i = 1, 3 do
			local D = Async()
			if(D)then
				return D
			end
		end

		return false
	end

	if(Can_Send_Invite())then
		local function Show_Invite()
			local function Async()
				local success, errormessage = pcall(function()
					SS:PromptGameInvite(Plr, Invite_Options)
				end)

				if(success)then
					return true
				end
				return false
			end

			for i = 1, 3 do
				local D = Async()
				if(D)then
					return
				end
			end
		end
		Show_Invite()
	end
end

local function Set_Button_Effects()
	local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
	local All_B = Main_F:GetChildren()
	local Owned_Color_Sequence = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(170, 255, 0)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 170, 0))
	}
	
	
	local function Effects(B)
		local GP_Key = B:GetAttribute("GP_Key")
		if(GP_Key ~= nil and Monetization_Mod.Does_Player_Own_Gamepass(Plr, GP_Key))then
			B:FindFirstChild("UIGradient").Color = Owned_Color_Sequence
		end
		
		B.Selected.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				SE.Hover_SE:Play()
				B:TweenSize(UDim2.new(0.5, 0, 0.33, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
				wait(0.25)
				Debounce_E = false
			end
		end)
		
		B.Selected.MouseLeave:Connect(function()
			B:TweenSize(UDim2.new(0.375, 0, 0.275, 0), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
		end)
		
		B.Selected.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				SE.Click_SE:Play()
				TS:Create(B, Tween_Click, {Size = UDim2.new(0.28125, 0, 0.20625, 0)}):Play()
				
				if(B.Name == "Invite_B")then
					Invite_Handle()
				else
					local D = GP_Data[GP_Key]
					
					if(B.UIGradient.Color == Owned_Color_Sequence)then
						Msg_E:Fire(" You already own this gamepass!", Color3.fromRGB(85, 255, 127))
					else
						Msg_E:Fire(" You must purchase the " .. D['Name'] .. " gamepass!!!", Color3.fromRGB(225, 0, 0))
						Monetization_Mod.Prompt_Gamepass_Purchase(Plr, GP_Key)
					end
				end
				
				wait(0.25)
				Debounce_C = false
			end
		end)
	end
	
	for i = 1, #All_B do
		if(All_B[i]:IsA("Frame"))then
			Effects(All_B[i])
		end
	end
	
	local function Purchased_GP_Button_Update(Key)
		for i = 1, #All_B do
			if(All_B[i]:IsA("Frame") and All_B[i]:GetAttribute("GP_Key") ~= nil and 
				All_B[i]:GetAttribute("GP_Key") == Key and All_B[i]:FindFirstChild("UIGradient") ~= nil)then
				
				All_B[i]:FindFirstChild("UIGradient").Color = Owned_Color_Sequence
				return
			end
		end
	end
	
	MPS.PromptGamePassPurchaseFinished:Connect(function(P, ID, Did_Buy)
		if(P == Plr and Did_Buy)then
			local GP_Key = Monetization_Mod.Get_GP_Key_From_ID(ID)
			
			Msg_E:Fire(" You successfully purchased the " .. GP_Key .. " gamepass!", Color3.fromRGB(170, 170, 255))
			Purchased_GP_Button_Update(GP_Key)
		end
	end)
end
Set_Button_Effects()




]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX2B90C612D8794FDB8D3DD10395A4814B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CurrencyIndicators</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX99C7C1B62FB646B5AB45D5FBC3B9F5C1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIScale</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXA9668756F036414FB4686077FAD3C935">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LocalScript.client.lua</string>
								<string name="ScriptGuid">{65E09EFA-A9C7-4285-B845-6D5CAA5ABEAD}</string>
								<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local function getDevice()
	if (uis.TouchEnabled == true and uis.KeyboardEnabled == false) then
		return "Mobile"
	elseif (uis.GamepadEnabled == true) then
		return "Console"
	else
		return "PC"
	end
end

while task.wait(1) do
	local device = getDevice()
	if device ~= "Mobile" then
		script.Parent.Scale = 0.8
	else
		script.Parent.Scale = 1
	end
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX6CF749F6D3AC499C9D394049E1E4A4C2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Menu</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXA6779C17F3814FD8B6A3451F78405428">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIScale</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX3C07A8DA465148CB879DC853C2A6CCF7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LocalScript.client.lua</string>
								<string name="ScriptGuid">{20856576-9AE9-4EE7-93EF-0D4311F5F1C2}</string>
								<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local function getDevice()
	if (uis.TouchEnabled == true and uis.KeyboardEnabled == false) then
		return "Mobile"
	elseif (uis.GamepadEnabled == true) then
		return "Console"
	else
		return "PC"
	end
end

while task.wait(1) do
	local device = getDevice()
	if device ~= "Mobile" then
		script.Parent.Scale = 0.8
	else
		script.Parent.Scale = 1
	end
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXE2A59A3A3C2343CCBEC1BA520E7A57F2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Tools</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXD3363A55D99E43B293F1508208D2D85A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">UIScale</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXFC3A52811C5841EF843C06C69904B0E7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LocalScript.client.lua</string>
								<string name="ScriptGuid">{8FC7145E-DCA9-4CDD-A7E5-FDA936131E9A}</string>
								<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local function getDevice()
	if (uis.TouchEnabled == true and uis.KeyboardEnabled == false) then
		return "Mobile"
	elseif (uis.GamepadEnabled == true) then
		return "Console"
	else
		return "PC"
	end
end

while task.wait(1) do
	local device = getDevice()
	if device ~= "Mobile" then
		script.Parent.Scale = 0.6
	else
		script.Parent.Scale = 1
	end
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXD52879516E014192A71A59E4C18F9896">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Sound_Effects_F</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXC6FAA587096F4B5CA24273C1BD4CA6C9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Sound_Effect_Settings_Toggle.client.lua</string>
						<string name="ScriptGuid">{7FDC8B73-3FF5-4883-B4F0-A1D9B364779F}</string>
						<ProtectedString name="Source"><![CDATA[local Plr = game.Players.LocalPlayer
local Sound_Groups_F = game.ReplicatedStorage:WaitForChild("Sound_Groups_F")
local Sound_Effect_Group = Sound_Groups_F:WaitForChild("Sound_Effects")
local Missed_Hit_SE_Group = Sound_Groups_F:WaitForChild("Missed_Hit_Sound_Effects")
local BG_SE_Group = Sound_Groups_F:WaitForChild("BG_Sound")
local PD = Plr:WaitForChild("Player_Data")
local Sound_Effects_V = PD:WaitForChild("Sound Effects")
local BG_V = PD:WaitForChild("Background Music")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")

local function Update_Sound_Group()
	if(Sound_Effects_V ~= nil and Sound_Effects_V.Value == true)then
		Sound_Effect_Group.Volume = 1
		Missed_Hit_SE_Group.Volume = 2
	else
		Sound_Effect_Group.Volume = 0
		Missed_Hit_SE_Group.Volume = 0
	end
end
Update_Sound_Group()

Sound_Effects_V.Changed:Connect(function()
	Update_Sound_Group()
end)


local function Update_BG_Sound_Group()
	if(BG_V ~= nil and BG_V.Value == true)then
		BG_SE_Group.Volume = 0.5
	else
		BG_SE_Group.Volume = 0
	end
end
Update_BG_Sound_Group()

BG_V.Changed:Connect(function()
	Update_BG_Sound_Group()
end)

Bindable_Events_F:WaitForChild("Toggle_BG_Volume").Event:Connect(function(Toggle_On)
	if(Toggle_On and BG_V ~= nil and BG_V.Value == true)then
		BG_SE_Group.Volume = 0.5
	else
		BG_SE_Group.Volume = 0
	end
end)

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX0AF3DA9B0E874E1796F231C830FEA6BA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Fight_Intro_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX783CC675218442C6A7596A5C26A50FFE">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Fight_Intro_Handle.client.lua</string>
						<string name="ScriptGuid">{B4BBE09E-C939-4732-A1F0-1FA860DBDE8D}</string>
						<ProtectedString name="Source"><![CDATA[--> Display the Transition, Fight Data, Reset your Fight Handle and Disable it=
--> Force you into Fight Handle
local Controls = require(game.Players.LocalPlayer.PlayerScripts:WaitForChild("PlayerModule")):GetControls()

local TS = game:GetService("TweenService")
local RS = game:GetService("RunService")
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effects_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Num_Str_Mod = require(Data_Mods_F:WaitForChild("Num_String_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Cam = game.Workspace.CurrentCamera
local Fight_Cages_F = game.Workspace:WaitForChild("Fight_Cages_F")

local Transiton_Tabs_F = script.Parent.Teleport_Transition_F
local Left_F, Right_F = Transiton_Tabs_F.Left_F, Transiton_Tabs_F.Right_F
local Covers_F = script.Parent.Covers_F
local Top_F, Bottom_F = Covers_F.Top_F, Covers_F.Bottom_F
local Player_Fight_Data_F = script.Parent.Main_F
local Top_Fight_Data_F = Player_Fight_Data_F.Top_F
local Rank_Img = Top_Fight_Data_F.Rank_Img
local Stats_Fight_Data_F = Player_Fight_Data_F.Stats_F.Data_Tabs_F

local Debounce_Display = false
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Toggle_UI(Show)
	local UIs = {"Fight_Teleport_UI", "Tool_Select_UI", "Side_Button_UI"}
	for i = 1, #UIs do
		local UI = PG:FindFirstChild(UIs[i])
		if(UI ~= nil)then
			UI.Enabled = Show
		end
	end
end
Toggle_UI(true)

local function Get_Current_Fighting_M()
	local All_Cages_M = Fight_Cages_F:GetChildren()

	local function Is_Main_Cage(Cage_M)
		local FD = Cage_M:FindFirstChild("Fight_Data_F")
		if(FD ~= nil and FD:FindFirstChild("Fight_Char_1") ~= nil and 
			FD:FindFirstChild("Fight_Char_2") ~= nil)then

			local C1_V = FD:FindFirstChild("Fight_Char_1")
			local C2_V = FD:FindFirstChild("Fight_Char_2")
			if(C1_V.Value == Char or C2_V.Value == Char) then
				return true
			end
		end

		return false
	end

	for i = 1, #All_Cages_M do
		local Cage_M = All_Cages_M[i]
		if(Cage_M ~= nil and Is_Main_Cage(Cage_M))then
			return Cage_M
		end
	end

	return nil
end

local function Is_Ranked_Match()
	local Cage_M = Get_Current_Fighting_M()
	if(Cage_M ~= nil)then
		local Ranked_CS_F = Cage_M:FindFirstChild("Ranked_Cutscene_Parts_F")
		local Is_Ranked = Cage_M:GetAttribute("Ranked_Match")
		
		if(Is_Ranked ~= nil and Is_Ranked and Ranked_CS_F ~= nil)then
			return true, Ranked_CS_F
		end
	end
	
	return false, nil
end

local function Is_Bot_Fight()
	local Cage_M = Get_Current_Fighting_M()
	if(Cage_M ~= nil)then
		local Is_Bot = Cage_M:GetAttribute("Bot_Fight")
		if(Is_Bot ~= nil and Is_Bot == true)then
			return true
		end
	end
	
	return false
end

local function Toggle_Player_Controls(Is_Enabled)
	local Plr_Scripts_F = Plr:FindFirstChild("PlayerScripts")
	if(Plr_Scripts_F ~= nil and Plr_Scripts_F:FindFirstChild("PlayerModule") ~= nil)then
		local P_Mod = require(Plr_Scripts_F:FindFirstChild("PlayerModule"))
		local Controls = P_Mod:GetControls()
		
		if(Controls ~= nil)then
			if(Is_Enabled)then
				Controls:Enable()
			else
				Controls:Disable()
			end
		end
	end
end

local function Set_Up_Fight(isBot, Target_Char, Target_HRP)
	Debounce_Display = true
	Bindable_Events_F:WaitForChild("Toggle_Reset"):Fire(false)
	local Is_Ranked, Ranked_CS_F = Is_Ranked_Match()

	local function Init_Reset()
		Left_F.Visible = false
		Right_F.Visible = false
		Player_Fight_Data_F.Visible = false
		Left_F.Position = UDim2.new(-1, 0, 0, 0)
		Right_F.Position = UDim2.new(1, 0, 0, 0)
		
		Top_F.Visible = false
		Bottom_F.Visible = false
		Top_F.Position = UDim2.new(0, 0, -0.15, 0)
		Bottom_F.Position = UDim2.new(0, 0, 1.15, 0)
		Player_Fight_Data_F.Position = UDim2.new(0.5, 0, 1.5, 0)
		
		Left_F.Visible = true
		Right_F.Visible = true
		Top_F.Visible = true
		Bottom_F.Visible = true
		Player_Fight_Data_F.Visible = true
		
		Bindable_Events_F:WaitForChild("Set_Fight_Mode_Lock"):Fire(true)
		
		Bindable_Events_F:WaitForChild("Disable_Fight_Mode"):Fire(true)
		Bindable_Events_F:WaitForChild("Close_Fight_Result"):Fire()
		Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false)
	end
	Init_Reset()
	
	local function Configure_Name_Tag_Handle(C)
		local Name_Tag = C:FindFirstChild("Name_Tag_UI")
		local Toggle_Tabs = {"UIStroke", "Rank_F", "Connection_Img", "Device_Img", "Country_Img", 
			"Player_Name_Txt"}
		
		if(Name_Tag ~= nil and Name_Tag:FindFirstChild("Main_F") ~= nil)then
			local Main_F = Name_Tag:FindFirstChild("Main_F")
			
			for i = 1, #Toggle_Tabs do
				local Tab = Main_F:FindFirstChild(Toggle_Tabs[i])
				if(Tab ~= nil)then
					if(Tab:IsA("UIStroke"))then
						Tab.Enabled = false
					else
						Tab.Visible = false
					end
				end
			end
			
			Main_F.BackgroundTransparency = 1
			
			if(C ~= Char)then
				Name_Tag.StudsOffset = Vector3.new(0, 3, 0)
			end
			
			Name_Tag.Enabled = false
		end
	end
	Configure_Name_Tag_Handle(Char)
	Configure_Name_Tag_Handle(Target_Char)

	
	local function Show_Transition()
		local Woosh_SE = Sound_Effects_Mod.Get_SE_Object(Plr, "Transition_Woosh_SE")
		if(Woosh_SE ~= nil)then
			Woosh_SE:Play()
		end
		
		Left_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
		Right_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
		
		wait(1)
		Bindable_Events_F:WaitForChild("On_Submission_Handle"):Fire(true, true)
		Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false)
		
		if(Woosh_SE ~= nil)then
			Woosh_SE:Play()
		end
		
		Left_F:TweenPosition(UDim2.new(-1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
		Right_F:TweenPosition(UDim2.new(1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)

		wait(0.375)
		
		Left_F.Visible = false
		Right_F.Visible = false
		Left_F.Position = UDim2.new(-1, 0, 0, 0)
		Right_F.Position = UDim2.new(1, 0, 0, 0)
	end
	Show_Transition()
	
	local function Update_Stats_Display(C)
		local C_Plr = game.Players:GetPlayerFromCharacter(C)
		local Tabs_Txt = Stats_Fight_Data_F:GetChildren()
		
		if(C_Plr ~= nil and C_Plr:FindFirstChild("Player_Data") ~= nil)then
			local PD = C_Plr:FindFirstChild("Player_Data")
			
			local function Get_Values(Key)
				local V = PD:FindFirstChild(Key)
				if(V ~= nil)then
					return V.Value
				end
				return 0
			end
			
			local function Get_Win_Percentage()
				local Wins_V = Get_Values("Total Wins")
				local Matches_V = Get_Values("Total Matches")
				if(Is_Ranked)then
					Wins_V = Get_Values("Ranked Wins")
					Matches_V = Get_Values("Ranked Matches")
				end
				
				local Dif = math.clamp(Wins_V / Matches_V, 0, 1) * 100
				if tostring(Dif) == "nan" then
					return "0%"
				end
				return math.floor(Dif) .. "%"
			end
			
			for i = 1, #Tabs_Txt do	
				local Txt = Tabs_Txt[i]
				if(Txt ~= nil)then
					local Key = Txt.Name
					if(Is_Ranked and Key == "Total Wins")then
						Key = "Ranked Wins"
					end
					
					local Data_V = PD:FindFirstChild(Key)
					if(Data_V ~= nil)then
						Txt.Text = Num_Str_Mod.NumToString(Data_V.Value) .. ""
					else
						Txt.Text = Get_Win_Percentage() 
					end
					
					if(Is_Ranked)then
						Txt.TextColor3 = Color3.fromRGB(255, 170, 0)
					else
						Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					end
				end
			end
			
			local Elo_Data = Elo_Mod.Get_Player_Rank_Data(C_Plr)
			Rank_Img.Image = Elo_Data['Icon'] or "rbxassetid://89194867048049"
			Rank_Img.ImageColor3 = Elo_Data['Color'] or Color3.fromRGB(170, 170, 127)
			Top_Fight_Data_F:FindFirstChild("Plr_Name_Txt").Text = C_Plr.DisplayName .. ""
			
		else
			--Bot
			for i = 1, #Tabs_Txt do	
				local Txt = Tabs_Txt[i]
				if(Txt ~= nil)then
					Txt.Text = "BOT"
					Txt.TextColor3 = Color3.fromRGB(170, 0, 0)
				end
			end
			
			local Elo_Data = Elo_Mod.Get_Player_Rank_Data(Plr)
			Rank_Img.Image = Elo_Data['Icon'] or "rbxassetid://89194867048049"
			Rank_Img.ImageColor3 = Elo_Data['Color'] or Color3.fromRGB(170, 170, 127)
			Top_Fight_Data_F:FindFirstChild("Plr_Name_Txt").Text = "Bot"
		end
		
		Player_Fight_Data_F:TweenPosition(UDim2.new(0.5, 0, 0.875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.5, true, nil)
	end
	
	local function Intro_Cutscene()
		Toggle_UI(false)
		Top_F:TweenPosition(UDim2.new(0.5, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Bottom_F:TweenPosition(UDim2.new(0.5, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Toggle_Player_Controls(false)
		
		HRP.Anchored = true
		if(Is_Ranked and Ranked_CS_F ~= nil)then
			local function Play_Ranked_Cutscene()
				local Tween_Cam = TweenInfo.new(2.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
				Cam.CameraType = Enum.CameraType.Scriptable
				
				for i = 1, #Ranked_CS_F:GetChildren() do
					local P = Ranked_CS_F:FindFirstChild("P" .. i)
					if(P ~= nil)then
						if(i == 1)then
							Cam.CFrame = P.CFrame
						else
							TS:Create(Cam, Tween_Cam, {CFrame = P.CFrame}):Play()
							if(i == 3)then
								wait(2)
								Bindable_Events_F:WaitForChild("Transition_Fade"):Fire(0.5, 0.5)
								wait(0.5)
							else
								wait(2.5)
							end
						end
					end
				end
				
				-- Add on to this!
				-- Create a whole Walk out Sequence to display Player Stats on
				-- Spawn Players in Tunnels, have them Walk towards the Final Point
					--> Will Display Stats here instead of just having them Flex
					
			end
			Play_Ranked_Cutscene()
			
			if(HRP ~= nil and Hum ~= nil)then
				local function Move_Yourself()
					local Final_Pos = HRP.CFrame.Position + HRP.CFrame.LookVector * 110
					HRP.Anchored = false
					Hum.WalkSpeed = 10

					for i = 1, 2 do
						if(Hum ~= nil)then
							Hum:MoveTo(Final_Pos)
							wait(5)
						end
					end
				end
				task.spawn(Move_Yourself)
			end
			
			--Show yourself
			--Show the other Player
			
			local function Track_Player(T_HRP, T_Char)
				local Tween_Init = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
				local Orig_Pos = T_HRP.CFrame.Position
				local Init_Pos = Orig_Pos + T_HRP.CFrame.LookVector * ((0.75 * 10) + 7)
				local Init_Rot = CFrame.new(Init_Pos, Orig_Pos).Rotation
				local Init_CF = CFrame.new(Init_Pos) * Init_Rot
				
				Cam.CameraType = Enum.CameraType.Scriptable
				TS:Create(Cam, Tween_Init, {CFrame = Init_CF}):Play()
				wait(0.75)
				
				if(T_Char ~= nil and Char ~= nil and T_Char == Char)then
					Sound_Effects_Mod.Play_Voice_Over("Fighter_1_Intro")
				else
					Sound_Effects_Mod.Play_Voice_Over("Fighter_2_Intro")
				end
				
				local RS_Con = RS.Stepped:Connect(function()
					if(Cam ~= nil and T_HRP ~= nil)then
						local Orig_Pos = T_HRP.CFrame.Position
						local Init_Pos = Orig_Pos + T_HRP.CFrame.LookVector * 7
						local Init_Rot = CFrame.new(Init_Pos, Orig_Pos).Rotation
						
						Cam.CFrame = CFrame.new(Init_Pos) * Init_Rot
					end
				end)
				table.insert(Cons, RS_Con)
			
				Update_Stats_Display(T_Char)
				
				wait(4.25)
				
				if(RS_Con ~= nil)then
					RS_Con:Disconnect()
					RS_Con = nil
				end
			end
			Track_Player(HRP, Char)
			
			if(Target_HRP ~= nil and Target_Char ~= nil)then
				Track_Player(Target_HRP, Target_Char)
			end
			
		else
			--Play Animation
			Animation_Mod.Play_Emote_Track_From_Key(Plr, Hum, "A", true)
			if isBot == true then
				local botHum = Target_Char:FindFirstChild("Humanoid")
				if botHum then
					Animation_Mod.Force_Play_Emote_Track_From_Key(botHum, "A", false)
				end
			end

			local RS_Con = nil
			local Tween_Init = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
			local Init_Pos = HRP.Position + HRP.CFrame.LookVector * 5
			local Look_CF = CFrame.new(Init_Pos, HRP.Position)
			local Follow_P = nil

			RS_Con = RS.Stepped:Connect(function()
				if(Follow_P ~= nil and Cam ~= nil)then
					Cam.CFrame = CFrame.new(Cam.CFrame.Position, Follow_P.Position)
				end
			end)
			table.insert(Cons, RS_Con)

			Cam.CameraType = Enum.CameraType.Scriptable
			TS:Create(Cam, Tween_Init, {CFrame = CFrame.new(Init_Pos) * Look_CF.Rotation}):Play()
			wait(0.75)
			Follow_P = HRP
			Update_Stats_Display(Char)

			wait(3)

			if(Target_HRP ~= nil)then
				Follow_P = nil
				Init_Pos = Target_HRP.Position + Target_HRP.CFrame.LookVector * 5
				Look_CF = CFrame.new(Init_Pos, Target_HRP.Position)
				TS:Create(Cam, Tween_Init, {CFrame = CFrame.new(Init_Pos) * Look_CF.Rotation}):Play()
				Player_Fight_Data_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.25, true, nil)
				wait(0.75)
				if(Target_HRP ~= nil)then
					Follow_P = Target_HRP
				end

				Update_Stats_Display(Target_Char)

				wait(3)
				Follow_P = nil
			end

			if(RS_Con ~= nil)then
				RS_Con:Disconnect()
				RS_Con = nil
			end
		end
		
		Player_Fight_Data_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 1, true, nil)
		Top_F:TweenPosition(UDim2.new(0.5, 0, -0.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Bottom_F:TweenPosition(UDim2.new(0.5, 0, 1.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		
		Cam.CameraSubject = Hum
		Cam.CameraType = Enum.CameraType.Custom
		Cam.CFrame = Char:FindFirstChild("Head").CFrame
		Cam.FieldOfView = 70
		
		wait(1)

		Top_F.Visible = false
		Bottom_F.Visible = false
		Player_Fight_Data_F.Visible = false
		Toggle_UI(true)
		Toggle_Player_Controls(true)
		HRP.Anchored = false
	end
	
	--if(Is_Bot_Fight() == false)then
	--	Intro_Cutscene()
	--else
	--	wait(2)
	--end
	Intro_Cutscene()
	
	Bindable_Events_F:WaitForChild("New_Round_Display"):Fire(1)
	
	wait(1.5) -- Temp Wait
	Bindable_Events_F:WaitForChild("Enter_Fight_Mode"):Fire(Target_HRP, true)
	Debounce_Display = false
	
	Bindable_Events_F:WaitForChild("On_Submission_Handle"):Fire(false, false)
end

Receiving_Events_F:WaitForChild("Fight_Set_Up").OnClientEvent:Connect(function(isBot, ...)
	workspace:SetAttribute("FIGHT_INTRO", true)
	local args = {...}
	local Target_Char, Target_HRP
	if isBot == true then
		local botName = args[1]
		repeat
			Target_Char = game.Workspace._BOTS_FOLDER_:FindFirstChild(botName)
			if Target_Char == nil then
				task.wait()
				continue
			else
				Target_HRP = Target_Char:FindFirstChild("HumanoidRootPart")
			end
		until Target_Char ~= nil and Target_HRP ~= nil
	else
		Target_Char, Target_HRP = args[1], args[2]
	end
	
	if(Debounce_Display == false)then
		Set_Up_Fight(isBot, Target_Char, Target_HRP)
	end
	workspace:SetAttribute("FIGHT_INTRO", nil)
end)

Bindable_Events_F:WaitForChild("Toggle_Cutscene").Event:Connect(function(Is_Enabled)
	if(Is_Enabled)then
		Toggle_UI(false)
		Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false)
		Top_F:TweenPosition(UDim2.new(0.5, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Bottom_F:TweenPosition(UDim2.new(0.5, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
	else
		Top_F:TweenPosition(UDim2.new(0.5, 0, -0.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Bottom_F:TweenPosition(UDim2.new(0.5, 0, 1.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 1, true, nil)
		Toggle_UI(true)
		Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true)
	end
end)

game.Players.LocalPlayer.CharacterAdded:Connect(function() -- Fixes hard-lock after user resets in a match
	Toggle_Player_Controls(true)
end)
Toggle_Player_Controls(true)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXAC6CDAAEFAE3494B97739A7D40161DE9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Skill_Tree_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX73CA9E4613824EB8BEDF5E26926037C1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Skill_Tree_Handle.client.lua</string>
						<string name="ScriptGuid">{17DAF85A-EF0B-4050-A3A4-A9264243B579}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Char = Plr.Character
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Is_Chat_Type = Bindable_RF:WaitForChild("Is_Chatbox_Typing")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Display_Data_E = Bindable_Events_F:WaitForChild("Display_Data")
local Sending_RF = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("RF")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Skill_Tree_Mod = require(Data_Mods_F:WaitForChild("Skill_Tree_Mod"))
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))

local Main_F = script.Parent.Main_F
local Exit_B = Main_F.Exit_B
local Data_F = Main_F.Data_F
local Tabs_F = Data_F.Tabs_F
local Update_Tabs_E = script.Parent.Update_Tabs

local Debounce_UI = false
local Debounce_C = false
local Debounce_E = false

local UNLOCKED_TRANSPARENCY = 0.8

local Skill_Tree_Data, Reward_Data = Skill_Tree_Mod.Get_All_Skill_Tree_Data()
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

local function Format_Time(sec)
	return math.floor(sec / 3600)
end

local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.25, true, nil)
	wait(0.25)
	
	Main_F.Visible = false
	
	Debounce_C = false
	Debounce_E = false
	Debounce_UI = false
end

local function Show_Skill_Tree()
	local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
	local Hover_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Hover_SE")
	local Click_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Click_SE")
	
	local function Reset_Display()
		Main_F.Visible = false
		Main_F.Size = UDim2.new(0, 0, 0, 0)
		Data_F.Position = UDim2.new(0.5, 0, 0.5, 0)
	end
	Reset_Display()
	
	local function Tree_Button_Configs()
		--[[
			* Assess each Button
			- Have you unlocked it yet? Add Check
			- Can you redeem it? Show the Reward
			- Can you see it? Show the Locked and Requirements
			- Can't see it? Visible  = false
		]]--

		local Owned_Rewards = Skill_Tree_Mod.Compile_Skill_Tree_Data(Plr)
		
		local Reward_Vectors = {
			['Cash'] = "rbxassetid://119234133505316",
			['Gems'] = "rbxassetid://101452762537147",
			['Cash Pack'] = "rbxassetid://15365698744",
			['Ranked Move'] = "rbxassetid://107665571679632",
			['Crate'] = "rbxassetid://113984353478299",
			['Ranked Strike'] = "rbxassetid://83651269157787",
			['Emotes'] = "rbxassetid://96813195617891"
		}
		
		local Skill_Vectors = {
			['Total Wins'] = "rbxassetid://108423557329774",
			['Ranked Wins'] = "rbxassetid://84882681331411",
			['Punch Knockout Wins'] = "rbxassetid://110581737976151",
			['Leg Knockout Wins'] = "rbxassetid://136568604314712",
			['Submissions Wins'] = "rbxassetid://104272697213386",
			['Total Playtime'] = "rbxassetid://104629740938145"
		}
		
		local Skill_Txt = {
			['Total Wins'] = {" Wins!", " Win!"},
			['Ranked Wins'] = {" Ranked Wins!", " Ranked Win!"},
			['Punch Knockout Wins'] = {" KO's!", " KO!"},
			['Leg Knockout Wins'] = {" Kick KO's!", " Kick KO!"},
			['Submissions Wins'] = {" Submissions!", " Submission!"},
			['Total Playtime'] = {" Hours!", " Hour!"},
		}
		
		local function Get_Reward_Txt(R_Data)
			if(R_Data['Reward'] == "Crate")then
				return "Free Crate!"
			elseif(R_Data['Reward'] == "Emotes")then
				return "Special Emote!"
			elseif(R_Data['Reward'] == "Ranked Move")then
				return "Special Combo!"
			elseif(R_Data['Reward'] == "Ranked Strike")then
				return "Special Strike!"
			elseif(R_Data['Reward'] == "Cash Pack")then
				return "Cash Pack!"
			else
				local Amount = R_Data['Amount']
				local Text = R_Data['Reward']
				if math.round(Amount) == 1 then
					warn(Text)
					Text = string.sub(Text, 1, string.len(Text) - 1)
					warn(Text)
					warn()
				end

				return "+" .. Amount .. " " .. Text .. "!"
			end
		end
		
		local function Adjust_Frame_Position(Tab)
			--get the Difference Away from the Center Position
				--Center Position = Current Data_F Position
			local T_Pos = Tab.Position
			local X_Dif = 0.5 - T_Pos.X.Scale
			local Y_Dif = 0.5 - T_Pos.Y.Scale
			local X_Pos = 0.5 + X_Dif
			local Y_Pos = 0.5 + Y_Dif
			
			local New_Pos = UDim2.new(X_Pos, 0, Y_Pos, 0)
			Data_F:TweenPosition(New_Pos, Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
		end

		local function Configure_Data_Type(TF)
			local Key = TF.Name
			local Index = TF:GetAttribute("Index")
			local Tabs = TF:GetChildren()
			local Data_V = PD:FindFirstChild(Key)
			
			local function Process_Tab(Tab)
				local Selected = Tab:FindFirstChild("Selected")
				local Main_Img = Tab:FindFirstChild("Main_Img")
				local Main_Txt = Tab:FindFirstChild("Main_Txt")
				local Tree_Index = string.gsub(Tab.Name, "Tab_", "")
				Tree_Index = tonumber(Tree_Index)
				
				local function Already_Claimed()
					if(Owned_Rewards ~= nil and Owned_Rewards[Key] ~= nil and #Owned_Rewards[Key] > 0 and 
						table.find(Owned_Rewards[Key], Tree_Index) ~= nil)then
						
						return true
					end
					return false
				end

				if(Already_Claimed())then
					--> Show the Claimed Status
					Main_Img.Image = "rbxassetid://122099475285175"
					Main_Img.ImageColor3 = Color3.new(1, 1, 1)
					
					Main_Txt.Text = "Claimed!"
					Main_Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					
					Tab.Image = "rbxassetid://104891328720619"
					Tab.ImageColor3 = Color3.new(1, 1, 1)
					
					Tab.Visible = true
					Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					
					Tab:SetAttribute("Process_Data", "Claimed")
					return "Claimed"
				end


				local function Can_Redeem_Button()
					--> Check Requirements
					local D_Val = PD:FindFirstChild(Key)
					local Max_Amount = Skill_Tree_Data[Key][Tree_Index] or math.huge
					
					if(D_Val ~= nil and D_Val.Value >= Max_Amount) then
						return true
					end
					return false
				end

				if(Can_Redeem_Button()) then
					--> Show the Reward avaiable
					local R_Data = Skill_Tree_Mod.Get_Reward_Data_Arr(Key)[Tree_Index]
					Main_Img.Image = Reward_Vectors[R_Data['Reward']]
					Main_Img.ImageColor3 = Color3.new(1, 1, 1)

					Main_Txt.Text = Get_Reward_Txt(R_Data)
					Main_Txt.TextColor3 = Color3.new(1, 1, 1)

					Tab.Image = "rbxassetid://138946019587089"
					Tab.ImageColor3 = Color3.new(1, 1, 1)
					
					Tab.Visible = true
					Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					
					Tab:SetAttribute("Process_Data", "Redeem")
					return "Redeem"
				end


				local function Can_See_On_Progress()
					--> If Ranked Wins or Total Wins, get the next 2 from their most Selected
					--> If not, get the next one
					local function Get_Starting_Index()
						local Max = 0
						local Redeemed_Vals = Owned_Rewards[Key] or {}
						
						for i = 1, #Redeemed_Vals do
							local Val = Redeemed_Vals[i]
							if(Val ~= nil)then
								local Num = tonumber(Val) 
								if(Num ~= nil and Num > Max)then
									Max = Num
								end
							end
						end
						
						return Max
					end
					local Start_Index = Get_Starting_Index()
					local Max_Index = Start_Index + 1
					
					if(Start_Index > 0 and (Key == "Total Wins" or Key == "Ranked Wins"))then
						Max_Index += 1
					end
					
					if(Tree_Index <= Max_Index)then
						return true
					end
					
					return false
				end
				
				if(Can_See_On_Progress())then
					--> Unknown					
					Main_Img.Image = Skill_Vectors[Key]
					Main_Img.ImageColor3 = Color3.new(1, 1, 1)

					if(Key == "Total Playtime")then
						local Txt = Skill_Txt[Key]
						if math.round(Skill_Tree_Data[Key][Tree_Index]) <= 3600 then
							Txt = Txt[2]
						else
							Txt = Txt[1]
						end
						
						Main_Txt.Text = Format_Time(Skill_Tree_Data[Key][Tree_Index]) .. "" .. Txt
					else
						local Txt = Skill_Txt[Key]
						if math.round(Skill_Tree_Data[Key][Tree_Index]) <= 1.25 then
							Txt = Txt[2]
						else
							Txt = Txt[1]
						end
						
						Main_Txt.Text = Format_Number(Skill_Tree_Data[Key][Tree_Index]) .. "" .. Txt
					end
					
					Main_Txt.TextColor3 = Color3.new(1, 1, 1)

					Tab.Image = "rbxassetid://138946019587089"
					Tab.ImageColor3 = Color3.new(1, 1, 1)
					
					Tab.Visible = true
					Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					
					Tab:SetAttribute("Process_Data", "Show")
					return "Show"
				else
					--Tab.Visible = false
					--Tab.Size = UDim2.new(0, 0, 0, 0)
					--Tab:SetAttribute("Process_Data", "N/A")
					--return nil
					-- LOCKED: affichage gris/disabled
					
					Main_Img.Image = Skill_Vectors[Key]
					Main_Img.ImageColor3 = Color3.fromRGB(170,170,170)
					Main_Img.ImageTransparency = UNLOCKED_TRANSPARENCY

					local Txt = Skill_Txt[Key]
					if Key == "Total Playtime" then
						Txt = (math.round(Skill_Tree_Data[Key][Tree_Index]) <= 3600) and Txt[2] or Txt[1]
					else
						Txt = (math.round(Skill_Tree_Data[Key][Tree_Index]) <= 1.25) and Txt[2] or Txt[1]
					end
					Main_Txt.Text = Format_Number(Skill_Tree_Data[Key][Tree_Index]) .. Txt
					Main_Txt.TextColor3 = Color3.fromRGB(180,180,180)
					Main_Txt.TextTransparency = UNLOCKED_TRANSPARENCY

					Tab.Image = "rbxassetid://138946019587089"
					Tab.ImageColor3 = Color3.fromRGB(130,130,130)
					Tab.ImageTransparency = UNLOCKED_TRANSPARENCY + 0.05

					Tab.Visible = true
					Tab.Size = UDim2.new(0.125, 0, 0.25, 0)
					Tab:SetAttribute("Process_Data", "Locked")
					return "Locked"
				end
			end
			
			local function Tab_Handle(Tab)
				local Selected = Tab:FindFirstChild("Selected")
				local Main_Img = Tab:FindFirstChild("Main_Img")
				local Main_Txt = Tab:FindFirstChild("Main_Txt")
				local Tree_Index = string.gsub(Tab.Name, "Tab_", "")
				Tree_Index = tonumber(Tree_Index)
				
				Tab.Visible = false
				Tab.Size = UDim2.new(0, 0, 0, 0)
				Tab.Image = "rbxassetid://138946019587089"
				Tab.ImageColor3 = Color3.new(1, 1, 1)
				
				local Process_Data = Process_Tab(Tab)
				
				local function Click_Handle()
					local Process_D = Tab:GetAttribute("Process_Data")
					if(Process_D ~= nil and Process_D ~= "N/A")then
						if(Process_D == "Redeem")then
							--Bulk Action, Grant the Reward!
							--> Tell the Server
							--> If True, Update the Skill Tree Display and all Tab Status
							--> False?, Error Message
							
							local Res, Txt = Sending_RF:WaitForChild("Redeem_Skill_Tree_Reward"):InvokeServer(Key, Tree_Index)
							if(Res)then
								local Is_Crate = (Main_Txt.Text == "Free Crate!")
								Display_Data_E:Fire(Txt, Color3.fromRGB(255, 170, 0))
								
								Owned_Rewards = Skill_Tree_Mod.Compile_Skill_Tree_Data(Plr)
								for i = 1, #Tabs do
									local T = Tabs[i]
									if(T ~= nil)then
										Process_Tab(T)
									end
								end
								
								--if you unlocked a Crate, remove the UI
								if(Is_Crate and Debounce_UI)then
									Remove_UI()
								end
			
							else
								local Txt = " Failed to Redeem! Keep working to Unlock this Reward!"
								Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
							end
							
						elseif(Process_D == "Claimed")then
							local Txt = " You've already Claimed this Reward!"
							Display_Data_E:Fire(Txt, Color3.fromRGB(35, 244, 68))
						elseif(Process_D == "Show")then
							local Txt = " Keep working to Unlock your next Reward!"
							Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
						elseif(Process_D == "Locked") then
							local Txt = " Continue pour dbloquer cette rcompense."
							Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
						end
					end
				end
				
				table.insert(Cons, Selected.MouseEnter:Connect(function()
					if(Debounce_E == false and Tab.Visible == true)then
						Debounce_E = true
						if(Hover_SE ~= nil)then
							Hover_SE:Play()
						end
						Tab:TweenSize(UDim2.new(0.175, 0, 0.3, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
						Tab.ImageColor3 = Color3.fromRGB(35, 244, 68)
						
						Debounce_E = false
					end
				end))
				
				table.insert(Cons, Selected.MouseLeave:Connect(function()
					if(Tab.Visible == true)then
						Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
						Tab.ImageColor3 = Color3.new(1, 1, 1)	
					end
				end))
				
				table.insert(Cons, Selected.MouseButton1Click:Connect(function()
					if(Debounce_C == false and Tab.Visible == true)then
						Debounce_C = true
						if(Click_SE ~= nil)then
							Click_SE:Play()
						end
						TS:Create(Tab, Tween_Click, {Size = UDim2.new(0.09375, 0, 0.1875, 0)}):Play()
						Adjust_Frame_Position(Tab)
						
						Click_Handle()
						
						wait(0.25)
						Debounce_C = false
					end
				end))	
				
				table.insert(Cons, Update_Tabs_E.Event:Connect(function()
					Process_Data = Process_Tab(Tab)
				end))
				
				if(Process_Data ~= nil)then
					Tab.Visible = true
					Tab:TweenSize(UDim2.new(0.125, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
				end
			end
			
			for i = 1, #Tabs do
				local T = Tabs[i]
				if(T ~= nil)then
					Tab_Handle(T)
				end
			end
		end
		
		local Tab_Data_F = Tabs_F:GetChildren()
		for i = 1, #Tab_Data_F do
			local TF = Tab_Data_F[i]
			if(TF ~= nil)then
				Configure_Data_Type(TF)
			end
		end
		
	end
	Tree_Button_Configs()
	
	local function Exit_Button_Handle()
		local Selected = Exit_B:FindFirstChild("Selected")
		local Data_Txt = Exit_B:FindFirstChild("Main_Txt")
		local Console_B = Exit_B:FindFirstChild("Xbox")
		Exit_B.Size = UDim2.new(0.15, 0, 0.0875, 0)
		Exit_B.BackgroundColor3 = Color3.new(1, 1, 1)
		Data_Txt.TextColor3 = Color3.new(1, 1, 1)
		
		table.insert(Cons, Selected.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				if(Hover_SE ~= nil)then
					Hover_SE:Play()
				end
				
				Data_Txt.TextColor3 = Color3.fromRGB(170, 0, 0)
				Exit_B.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
				Exit_B:TweenSize(UDim2.new(0.1725, 0, 0.100625, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.25, true, nil)
				
				Debounce_E = false
			end
		end))
		
		table.insert(Cons, Selected.MouseLeave:Connect(function()
			Exit_B.BackgroundColor3 = Color3.new(1, 1, 1)
			Data_Txt.TextColor3 = Color3.new(1, 1, 1)
			Exit_B:TweenSize(UDim2.new(0.15, 0, 0.0875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.25, true, nil)
		end))	
		
		table.insert(Cons, Selected.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.1125, 0, 0.065625, 0)}):Play()
				
				Remove_UI()
				
				wait(0.25)
				Debounce_C = false
			end
		end))
		
		if(UIS.GamepadEnabled)then
			Console_B.Visible = true
			
			table.insert(Cons, UIS.InputBegan:Connect(function(input, GPE)
				if(input.KeyCode == Enum.KeyCode.ButtonX and Debounce_C == false and 
					Is_Chat_Type:Invoke() == false)then
					
					Debounce_C = true
					if(Click_SE ~= nil)then
						Click_SE:Play()
					end
					TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.1125, 0, 0.065625, 0)}):Play()

					Remove_UI()

					wait(0.25)
					Debounce_C = false
				end
			end))
		else
			Console_B.Visible = false
		end	
	end
	Exit_Button_Handle()
	
	local function Display_UI()
		Main_F.Visible = true
		Main_F:TweenSize(UDim2.new(1, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)

		Debounce_C = false
		Debounce_E = false
		Debounce_UI = true
	end
	Display_UI()
end

Bindable_Events_F:WaitForChild("Open_Skill_Tree").Event:Connect(function()
	if(Debounce_UI == false)then
		Show_Skill_Tree()
	else
		Remove_UI()
	end
end)

function Auto_Open_Handle()
	
	local function Prompt_Open_Handle()
		local function Is_Player_Not_Fighting()
			local Is_Fighting = Char:GetAttribute("Is_Fighting")
			if(Is_Fighting == nil or (Is_Fighting ~= nil and Is_Fighting == false))then
				return true
			end
			return false
		end
		
		repeat wait(1) until Is_Player_Not_Fighting() == true	
		
		if(Debounce_UI == false)then
			Show_Skill_Tree()
		end
	end
	
	for Skill_Key, Requirement_Vals_Arr in next, Skill_Tree_Data do
		local Data_Val = PD:WaitForChild(Skill_Key)
		Data_Val.Changed:Connect(function()
			local V = Data_Val.Value
			if(table.find(Requirement_Vals_Arr, V) ~= nil and Debounce_UI == false)then
				Prompt_Open_Handle()
			end
			Update_Tabs_E:Fire()
		end)
	end
end
Auto_Open_Handle()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX68EC2038E8B94D6082A66E0483A56838">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Main_F</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX8905D38D2C25478DBE2B056AAEDAE33E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Exit_B</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX1FA7B35AC8184FE79DCC249834447636">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Xbox</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXD05FF53895464590AE165568A6AA7665">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">LocalScript.client.lua</string>
									<string name="ScriptGuid">{48158F41-DC6B-485C-BFCE-AAAAD1C8A2B7}</string>
									<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local updateXbox = function()
	local Mapped_Key = uis:GetStringForKeyCode(Enum.KeyCode.ButtonX)
	if(Mapped_Key == "ButtonX")then
		script.Parent.Image = "rbxassetid://115257536194509"
	else
		--PS5
		script.Parent.Image = "rbxassetid://137985933701432"
	end
	
	script.Parent.Visible = uis.GamepadEnabled
end

if uis.GamepadEnabled then
	updateXbox(true)
else
	updateXbox(false)
end
local conn2 = uis.GamepadConnected:Connect(function()
	if uis.GamepadEnabled then
		updateXbox(true)
	else
		updateXbox(false)
	end
end)
local conn2 = uis.GamepadDisconnected:Connect(function()
	if uis.GamepadEnabled then
		updateXbox(true)
	else
		updateXbox(false)
	end
end)]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXC5EB6AE85D444FE7915A4298D9570BAF">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Damage_Effect_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX86D59CF6F2564D7BB62B556E208A19FD">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Damage_Effect_Handle.client.lua</string>
						<string name="ScriptGuid">{05F350D5-38C8-4B2B-8455-70350FBA4B46}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local FD = Plr:WaitForChild("Fight_Data")
local Health_V = FD:WaitForChild("Health")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Cam_Shake_Mod = require(Data_Mods_F:WaitForChild("CameraShaker"))
local Cam = game.Workspace.CurrentCamera

local Main_F = script.Parent.Damage_F
local Knockout_Tab = script.Parent.Result_F

local Tween_Trans = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0.25)
local Tween_Cons = {}
local function Stop_Tweens()
	for i = 1, #Tween_Cons do
		local T = Tween_Cons[i]
		if(T ~= nil)then
			T:Cancel()
		end
	end
	
	table.clear(Tween_Cons)
end

local function Show_Effect()
	local Tabs = Main_F:GetChildren()
	if(#Tween_Cons > 0)then
		Stop_Tweens()
	end
	
	for i = 1, #Tabs do
		local T = Tabs[i]
		if(T ~= nil)then
			T.BackgroundTransparency = 0.575
			local Tab_T = TS:Create(T, Tween_Trans, {BackgroundTransparency = 1})
			table.insert(Tween_Cons, Tab_T)
			Tab_T:Play()
		end
	end
	
end

local Prev_V = Health_V.Value
Health_V.Changed:Connect(function()
	local Current_V = Health_V.Value
	if(Current_V < Prev_V)then
		Show_Effect()
	end
	
	Prev_V = Current_V
end)

local function Cam_Shake()
	local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
		Cam.CFrame = Cam.CFrame * shakeCf
	end)
	return CS
end
local CamShake = Cam_Shake()


local function Display_Knockout_Effects(Was_Knockout)
	while game.Workspace:GetAttribute("FIGHT_INTRO") ~= nil do
		task.wait()
	end
	
	local function Configure_Display()
		local Img = Knockout_Tab:FindFirstChild("Img")
		local Txt = Knockout_Tab:FindFirstChild("Txt")
		
		Knockout_Tab.Visible = false
		Knockout_Tab.Position = UDim2.new(0.5, 0, -0.5, 0)
		
		if(Was_Knockout)then
			Img.ImageColor3 = Color3.new(1, 0, 0)
			Txt.Text = "Knockout!"
			Txt.TextStrokeColor3 = Color3.new(1, 0, 0)
			
			Sound_Effect_Mod.Play_Voice_Over("Knockout")
		else
			Img.ImageColor3 = Color3.fromRGB(0, 170, 255)
			Txt.Text = "Submission KO!"
			Txt.TextStrokeColor3 = Color3.fromRGB(0, 170, 255)
		end
		
		Knockout_Tab.Visible = true
		Knockout_Tab:TweenPosition(UDim2.new(0.5, 0, 0.3, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.375, true, nil)
	end
	Configure_Display()
	
	local function Play_Cash_VFX()
		local Char = Plr.Character
		if(Char ~= nil and Char:FindFirstChild("HumanoidRootPart") ~= nil)then
			local HRP = Char:FindFirstChild("HumanoidRootPart")
			local Cash_VFX = HRP:FindFirstChild("Cash_VFX")
			
			if(Cash_VFX ~= nil)then
				local All_PE = Cash_VFX:GetChildren()
				for i = 1, #All_PE do
					local PE = All_PE[i]
					if(PE ~= nil and PE:IsA("ParticleEmitter"))then
						PE:Emit(10)
					end
				end
			end
			
			--CamShake:Start()
			--CamShake:Shake(Cam_Shake_Mod.Presets.Explosion)
		end
	end
	Play_Cash_VFX()
	
	wait(3)
	--[[
	if(CamShake ~= nil)then
		CamShake:Stop()
	end
	]]--
	Knockout_Tab:TweenPosition(UDim2.new(0.5, 0, -0.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.25, true, nil)
end

Receiving_Events_F:WaitForChild("Round_Result_Win").OnClientEvent:Connect(Display_Knockout_Effects)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX1A21C32A9648434A8B49091695DFB84C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Staminia_Down_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX69F10D1F29E74B219DB1DA13985050A3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Staminia_Effect_Handle.client.lua</string>
						<string name="ScriptGuid">{FC40C6A9-D13D-4EE8-8A7B-829A6859D5DA}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer
local FD = Plr:WaitForChild("Fight_Data")
local Stam_V = FD:WaitForChild("Staminia")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Cam_Shake_Mod = require(Data_Mods_F:WaitForChild("CameraShaker"))
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Cam = game.Workspace.CurrentCamera

local Main_F = script.Parent.Damage_F
local Backdrop_F = Main_F.Backdrop_F
local Stam_Txt = Main_F.Stam_Txt
local Key_Txt = Main_F.Key_Txt

local Is_Being_Shown = false
local Tween_Trans = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Out = TweenInfo.new(0.375, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)

local function Special_Txt(T, C)
	local RGB_Txt = string.format("rgb(%d, %d, %d)", C.R * 255, C.G * 255, C.B * 255)
	return [[<font color="]] .. RGB_Txt .. [[">]] .. T .. [[</font>]]
end

local function Cam_Shake()
	local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
		Cam.CFrame = Cam.CFrame * shakeCf
	end)
	return CS
end
local CamShake = Cam_Shake()

local function Remove_Display()
	local Heartbeat_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Heartbeat_SE")
	if(Heartbeat_SE ~= nil)then
		Heartbeat_SE:Stop()
	end
	
	CamShake:StopSustained(0.375)
	
	local Tabs = Backdrop_F:GetChildren()
	for i = 1, #Tabs do
		local T = Tabs[i]
		if(T ~= nil)then
			TS:Create(T, Tween_Out, {BackgroundTransparency = 1}):Play()
		end
	end

	TS:Create(Stam_Txt, Tween_Out, {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
	TS:Create(Key_Txt, Tween_Out, {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
	Is_Being_Shown = false
end

local function Show_Display()
	local Heartbeat_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Heartbeat_SE")
	Sound_Effect_Mod.Play_Voice_Over("Low_Health")
	
	local function Reset_Handle()
		if(Heartbeat_SE ~= nil)then
			Heartbeat_SE:Stop()
		end
		
		Stam_Txt.TextTransparency = 1
		Stam_Txt.TextStrokeTransparency = 1
		Key_Txt.TextTransparency = 1
		Key_Txt.TextStrokeTransparency = 1
		
		if(UIS.GamepadEnabled)then
			Key_Txt.Text = "Press & Hold " .. Special_Txt("L2", Color3.fromRGB(35, 244, 68)) .. " to Heal!"
		elseif(UIS.TouchEnabled)then
			Key_Txt.Text = "Press & Hold the Button to Heal!"
		else
			Key_Txt.Text = "Press & Hold " .. Special_Txt("Space", Color3.fromRGB(35, 244, 68)) .. " to Heal!"
		end
		CamShake:StopSustained(0)
	end
	Reset_Handle()
	
	local function Show_Backdrop()
		local Tabs = Backdrop_F:GetChildren()
		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil)then
				T.BackgroundTransparency = 1
				TS:Create(T, Tween_Trans, {BackgroundTransparency = 0.375}):Play()
			end
		end
		
		TS:Create(Stam_Txt, Tween_Trans, {TextTransparency = 0, TextStrokeTransparency = 0}):Play()
		TS:Create(Key_Txt, Tween_Trans, {TextTransparency = 0, TextStrokeTransparency = 0}):Play()
		
		if(Heartbeat_SE ~= nil)then
			Heartbeat_SE:Play()
		end
		
		CamShake:Start()
		CamShake:ShakeSustain(Cam_Shake_Mod.Presets.RoughDriving)
		Is_Being_Shown = true
	end
	Show_Backdrop()
end

Stam_V.Changed:Connect(function()
	if(Stam_V.Value < 20 and Is_Being_Shown == false)then
		--Show
		Show_Display()
	elseif(Stam_V.Value >= 20 and Is_Being_Shown)then
		--Remove
		Remove_Display()
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXF0586A941E374E5BA48ED19DD31685F5">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Takedown_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX0E09244B724C440DBF561490EF46BEE3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TakedownHandler.client.lua</string>
						<string name="ScriptGuid">{3164F898-9761-423B-AD33-9E85815F1613}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage:ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputServcie:UserInputService = game:GetService("UserInputService")
local RunService:RunService = game:GetService("RunService")
local Players:Players = game:GetService("Players")
local TS = game:GetService("TweenService")

local Player:Player = Players.LocalPlayer

local Char = Player.Character or Player.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")

local Vendor:Folder = ReplicatedStorage:FindFirstChild("Vendor")
local Trove = require(Vendor:FindFirstChild("Trove"))
local Find = require(Vendor:FindFirstChild("Find"))
local Spr = require(Vendor:FindFirstChild("Spr"))

local Channels_F = ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")

local Bindable_Events_F = Bindable_F:WaitForChild("Events")

local Data_Mods_F = ReplicatedStorage:FindFirstChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:FindFirstChild("Sound_Effect_Mod"))

local Fight_Cages_F:Folder = workspace:WaitForChild("Fight_Cages_F")

local RoundChangeHandler = require(script.RoundChangeHandler)
local BindThumbnail = require(script.BindThumbnail)
local WrapStats = require(script.WrapStats)

local ScreenGui = script:FindFirstAncestorWhichIsA("ScreenGui")
local TakedownFrame = ScreenGui:FindFirstChild("TakedownFrame")
local Main_Txt = TakedownFrame:FindFirstChild("Main_Txt")
local Key_Txt = TakedownFrame:FindFirstChild("Key_Txt")

local TakedownProgressFrame:Frame = ScreenGui:FindFirstChild("Takedown_Progress_Display_F")
local Per_Data_Txt = TakedownProgressFrame.Per_Txt
local Button_F = TakedownProgressFrame.Button_F
local Tabs_F = TakedownProgressFrame.Tabs_F
local Key_F = TakedownProgressFrame.Key_F
local Second_Half = Tabs_F.Second_Half_C
local First_Half = Tabs_F.First_Half_C
local Main_Cover = Tabs_F.Main_Cover

local MainFrame = TakedownFrame:FindFirstChild("Frame")
local LocalUserFrame = MainFrame:FindFirstChild("LocalUser")
local OtherUserFrame = MainFrame:FindFirstChild("OtherUser")

local LocalUserThumbnail = LocalUserFrame:FindFirstChild("Thumbnail",true)
local OtherUserThumbnail = OtherUserFrame:FindFirstChild("Thumbnail",true)

local PlayerStats = WrapStats(LocalUserFrame)
local OtherStats = WrapStats(OtherUserFrame)

BindThumbnail(LocalUserThumbnail,Player)

local Debounce_UI = false
local ActiveTrove = Trove.new()

local function Disconnect_Cons()
	ActiveTrove:Clean()
end

local function Round_Change_Handle(Round_V)
	ActiveTrove:Connect(Round_V.Changed,function()
		if(Round_V.Value > 1)then
			task.delay(0.5,RoundChangeHandler.load,Round_V.Value)
		end
	end)
end

local function Special_Txt(T, C)
	local RGB_Txt = string.format("rgb(%d, %d, %d)", C.R * 255, C.G * 255, C.B * 255)
	return [[<font color="]] .. RGB_Txt .. [[">]] .. T .. [[</font>]]
end

Bindable_Events_F:WaitForChild("New_Round_Display").Event:Connect(RoundChangeHandler.load)

local function Get_Takedown_Tracking_Val()
	local function Is_Fighting_Model(Cage_M)
		local Fight_Data_F = Cage_M:FindFirstChild("Fight_Data_F")
		if(Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild("Fight_Char_1") ~= nil and 
			Fight_Data_F:FindFirstChild("Fight_Char_2") ~= nil and 
			Fight_Data_F:FindFirstChild("Active_Fight") ~= nil and 
			Fight_Data_F:FindFirstChild("Takedown_Track") ~= nil)then

			local Char_V1 = Fight_Data_F:FindFirstChild("Fight_Char_1")
			local Char_V2 = Fight_Data_F:FindFirstChild("Fight_Char_2")
			local Active_Fight_V = Fight_Data_F:FindFirstChild("Active_Fight")

			if(Active_Fight_V.Value == true and (Char_V1.Value == Char or Char_V2.Value == Char))then
				return true
			end
		end

		return false
	end

	local function Get_Takedown_Tracking(Cage_M)
		local Fight_Data_F = Cage_M:FindFirstChild("Fight_Data_F")
		if(Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild("Takedown_Track") ~= nil)then
			return Fight_Data_F:FindFirstChild("Takedown_Track")
		end

		return nil
	end

	local All_Cages_M = Fight_Cages_F:GetChildren()
	for i = 1, #All_Cages_M do
		local Cage_M = All_Cages_M[i] 
		if(Cage_M ~= nil and Is_Fighting_Model(Cage_M))then
			return Get_Takedown_Tracking(Cage_M)
		end
	end

	return nil
end

local function Get_Fight_Data_Vals(C_Name, root)
	local P_Char
	if root == nil then
		P_Char = game.Workspace:FindFirstChild(C_Name)
	else
		P_Char = root:FindFirstChild(C_Name)
	end
	if(P_Char ~= nil)then
		local Plr_Obj = game.Players:GetPlayerFromCharacter(P_Char)
		if(Plr_Obj ~= nil and Plr_Obj:FindFirstChild("Fight_Data") ~= nil)then
			local FD = Plr_Obj:FindFirstChild("Fight_Data")
			return FD:FindFirstChild("Health"), FD:FindFirstChild("Staminia")

		elseif(P_Char:FindFirstChild("Fight_Data") ~= nil)then
			local FD = P_Char:FindFirstChild("Fight_Data")
			return FD:FindFirstChild("Health"), FD:FindFirstChild("Staminia")
		end
	else
		if root == nil then
			return Get_Fight_Data_Vals(C_Name, game.Workspace._BOTS_FOLDER_)
		end
	end

	return nil, nil
end

local function Reset_Display()
	Disconnect_Cons()

	local Click_SE = Sound_Effect_Mod.Get_SE_Object(Player, "Click_SE")
	if(Click_SE ~= nil)then
		Click_SE:Play()
	end

	TakedownFrame.Visible = false
	TakedownProgressFrame.Visible = false
	
	Debounce_UI = false
end


local function Display_Tracking(Tracking_Val)
	local Your_Name, Other_Name = Char.Name, Char.Name

	local function Reset_UI()
		Disconnect_Cons()
		TakedownFrame.Visible = false
		--Main_F.Position = UDim2.new(0.5, 0, -0.5, 0)
		Main_Txt.Text = "Takedown Tracking: " .. Special_Txt("Continue to Inflict Strikes!", Color3.fromRGB(170, 0, 0))

		if(UserInputServcie.GamepadEnabled)then
			Key_Txt.Text = "Y"
		else
			Key_Txt.Text = "R"
		end

		local function Reset_Takedown_Prog_Circle()
			TakedownProgressFrame.Visible = false

			Per_Data_Txt.Text = "0%"
			Per_Data_Txt.TextColor3 = Color3.fromRGB(200, 200, 200)

			First_Half.Rotation = 0
			Second_Half.Rotation = 0
			Main_Cover.Rotation = 0

			if(UserInputServcie.TouchEnabled == true)then
				Button_F.Visible = false
				Key_F.Visible = false
			elseif(UserInputServcie.GamepadEnabled)then
				Button_F.Visible = true
				Key_F.Visible = false
			else
				Button_F.Visible = false
				Key_F.Visible = true
			end
		end
		Reset_Takedown_Prog_Circle()

		Key_Txt.Visible = false

		for Plr_Name, Prog in next, Tracking_Val:GetAttributes() do
			if(Plr_Name ~= Char.Name)then
				BindThumbnail(OtherUserThumbnail,Plr_Name)
				Other_Name = Plr_Name
			end
		end
	end
	Reset_UI()

	TakedownProgressFrame.Visible = true
	local function Set_Up_Connections()
		local function Get_Prog_Total()
			local Total, Your_Val, Other_Val = 0, 0, 0

			for Plr_Name, Prog in next, Tracking_Val:GetAttributes() do
				if(Plr_Name == Char.Name)then
					Your_Val = Prog
				else
					Other_Val = Prog
				end

				Total += Prog
			end


			return Total, Your_Val, Other_Val
		end

		local function Update_Prog_Wheel(alpha)
			--need at least 75% of the total, 850 is minimum
			local Tween_Rot = TweenInfo.new(0.375, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)

			local Dif = math.clamp(alpha, -1, 1)
			local Per_Txt = math.round(Dif * 100)
			Per_Data_Txt.Text = math.clamp(Per_Txt, -100, 100) .. "%"
			
			Per_Txt = math.abs(Per_Txt)

			if(Per_Txt >= 100)then
				if alpha < 0 then
					Per_Data_Txt.TextColor3 = Color3.fromRGB(244, 0, 0)
				else
					Per_Data_Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
				end
			else
				Per_Data_Txt.TextColor3 = Color3.fromRGB(200, 200, 200)
			end
			
			if alpha < 0 then
				First_Half.ImageColor3 = Color3.fromRGB(244, 35, 68)
				Second_Half.ImageColor3 = Color3.fromRGB(244, 35, 68)
			else
				First_Half.ImageColor3 = Color3.fromRGB(35, 244, 68)
				Second_Half.ImageColor3 = Color3.fromRGB(35, 244, 68)
			end

			Dif = math.abs(Dif)
			
			if(Dif < 0.5) then
				--less than Half
				Main_Cover.Visible = true
				local Rot_Dif = (Dif / 0.5) * 180
				TS:Create(Main_Cover, Tween_Rot, {Rotation = Rot_Dif}):Play()
				TS:Create(Second_Half, Tween_Rot, {Rotation = 0}):Play()
			else
				--Over Half
				Main_Cover.Visible = false
				local Rot_Dif = ((Dif - 0.5) / 0.5) * 180
				TS:Create(Second_Half, Tween_Rot, {Rotation = Rot_Dif}):Play()
			end
		end

		local function Update_Prog_Displays()
			local Prog_Total, Your_Val, Other_Val = Get_Prog_Total()
			
			if Prog_Total == 0 then
				Update_Prog_Wheel(0)
			else
				if Your_Val <= 0.1 then
					Update_Prog_Wheel(-Other_Val / 600)
				else
					Update_Prog_Wheel(Your_Val / 600)
				end
			end
		end
		Update_Prog_Displays()

		ActiveTrove:Connect(Tracking_Val.AttributeChanged,function(Attrib_Key)
			Update_Prog_Displays()
		end)

		local RS_Con = nil
		local function Update_Tracking_Displays()
			if(RS_Con ~= nil)then
				RS_Con:Disconnect()
				RS_Con = nil
			end

			if(Tracking_Val.Value == true)then
				local Prog_Total, Your_Val, Other_Val = Get_Prog_Total()

				if(Your_Val > 600) then
					--Your Turn
					--Your_Bar_F.BackgroundColor3 = Color3.fromRGB(35, 244, 68)
					--Other_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)

					--Key_Txt.Visible = true

					Main_Txt.Text = "Takedown Tracking: " .. Special_Txt("Get within Strking Distance!", Color3.fromRGB(35, 244, 68))

					local function Get_Other_HRP()
						for Plr_Name, Prog in next, Tracking_Val:GetAttributes() do
							if(Plr_Name ~= Char.Name and game.Workspace:FindFirstChild(Plr_Name) ~= nil)then
								local Other_Char = game.Workspace:FindFirstChild(Plr_Name)
								local O_HRP = Other_Char:FindFirstChild("HumanoidRootPart")
								if(O_HRP ~= nil)then
									return O_HRP
								end
							end
						end

						return nil
					end
					local O_HRP = Get_Other_HRP()

					local function Is_Within_Striking_Distance()
						--Get the other Character & HRP from the Tracking Data
						--Get the Distance between the 2 HRP's
						--True or False return
						if(HRP ~= nil and O_HRP ~= nil and 
							(HRP.Position - O_HRP.Position).Magnitude <= 10)then

							return true
						end

						return false
					end

					ActiveTrove:Connect(RunService.Stepped,function()
						if(Is_Within_Striking_Distance())then
							Main_Txt.Text = "Takedown Tracking: " .. Special_Txt("Go To the Ground!", Color3.fromRGB(35, 244, 68))
						else
							Main_Txt.Text = "Takedown Tracking: " .. Special_Txt("Get within Strking Distance!", Color3.new(1, 0, 0))
						end
					end)

					Bindable_Events_F:WaitForChild("Mobile_Takedown_Toggle"):Fire(true)
				else
					--Avoid the other Guy
					--Your_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
					--Other_Bar_F.BackgroundColor3 = Color3.fromRGB(35, 244, 68)

					Key_Txt.Visible = false
					--Icon_Img.Visible = true

					Main_Txt.Text = "Takedown Tracking: " .. Special_Txt("Keep your Distance!", Color3.fromRGB(255, 170, 0))

					Bindable_Events_F:WaitForChild("Mobile_Takedown_Toggle"):Fire(false)
				end
			else
				Key_Txt.Visible = false
				--Icon_Img.Visible = true

				--Your_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
				--Other_Bar_F.BackgroundColor3 = Color3.fromRGB(170, 0, 0)

				Main_Txt.Text = "Takedown Tracking: " .. Special_Txt("Continue to Inflict Strikes!", Color3.fromRGB(170, 0, 0))
				Bindable_Events_F:WaitForChild("Mobile_Takedown_Toggle"):Fire(false)	
			end
		end
		Update_Tracking_Displays()

		ActiveTrove:Connect( Tracking_Val.Changed,function()
			Update_Tracking_Displays()
		end)

		--Health and Stam display Tracking

		local function Update_Bar_Prog(Bar_F, Val_Txt, Current_Val)
			local Dif = math.clamp(Current_Val / 100, 0, 1)
			Bar_F:TweenSize(UDim2.new(Dif, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
			Val_Txt.Text = Current_Val .. ""

			if(string.match(Bar_F.Parent.Name, "Health") ~= nil)then
				local function Update_Color(Col)
					local All_C = Bar_F:GetChildren()
					for i = 1, #All_C do
						if(All_C[i] ~= nil and All_C[i]:IsA("Frame"))then
							All_C[i].BackgroundColor3 = Col
						end
					end
				end

				if(Dif <= 0.25)then
					Update_Color(Color3.fromRGB(170, 0, 0))
				elseif(Dif <= 0.6)then
					Update_Color(Color3.new(1, 1, 0))
				else
					Update_Color(Color3.fromRGB(0, 255, 127))
				end
			end
		end

		local Your_Health_V, Your_Stam_V = Get_Fight_Data_Vals(Your_Name)
		if(Your_Health_V ~= nil)then
			PlayerStats.UpdateHealth(Your_Health_V.Value)
			ActiveTrove:Connect(Your_Health_V.Changed,function()
				PlayerStats.UpdateHealth(Your_Health_V.Value)
			end)
		end

		if(Your_Stam_V ~= nil)then
			PlayerStats.UpdateStamina(Your_Stam_V.Value)

			ActiveTrove:Connect(Your_Stam_V.Changed,function()
				PlayerStats.UpdateStamina(Your_Stam_V.Value)
			end)
		end

		local Other_Health_V, Other_Stam_V = Get_Fight_Data_Vals(Other_Name)
		if(Other_Health_V ~= nil)then
			OtherStats.UpdateHealth(Other_Health_V.Value)
			ActiveTrove:Connect( Other_Health_V.Changed,function()
				OtherStats.UpdateHealth(Other_Health_V.Value)
			end)
		end

		if(Other_Stam_V ~= nil)then
			OtherStats.UpdateStamina(Other_Stam_V.Value)
			ActiveTrove:Connect( Other_Stam_V.Changed,function()
				OtherStats.UpdateStamina(Other_Stam_V.Value)
			end)
		end

		if(Tracking_Val.Parent ~= nil and Tracking_Val.Parent:FindFirstChild("Round_Count") ~= nil)then
			local Round_Count_V = Tracking_Val.Parent:FindFirstChild("Round_Count")
			Round_Change_Handle(Round_Count_V)
		end
		
		ActiveTrove:Connect( Bindable_Events_F:WaitForChild("Toggle_Takedown_Prog_Button").Event,function(Should_Show)
			TakedownProgressFrame.Visible = Should_Show
		end)
	end
	Set_Up_Connections()

	local function Display_UI()
		TakedownFrame.Visible = true
		TakedownProgressFrame.Visible = true

		local Click_SE = Sound_Effect_Mod.Get_SE_Object(Player, "Click_SE")
		if(Click_SE ~= nil)then
			Click_SE:Play()
		end
		Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false)

		Debounce_UI = true
	end
	Display_UI()
end


Bindable_Events_F:WaitForChild("Display_Takedown_Tracking").Event:Connect(function(Can_Takedown)
	if(Debounce_UI == false and Can_Takedown)then
		local Tracking_Val = Get_Takedown_Tracking_Val()
		if(Tracking_Val ~= nil)then
			Display_Tracking(Tracking_Val)
		end
	else
		Reset_Display()
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX553783350B0D43048D434D70573B3207">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TakedownHandler</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXDEB09342FB994DB2ABCCB20A53E87B69">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">RoundChangeHandler.lua</string>
							<string name="ScriptGuid">{56411B0A-FA9F-4600-8B20-E0BFF75C4B22}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage:ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players:Players = game:GetService("Players")
local Player:Player = Players.LocalPlayer

local Vendor:Folder = ReplicatedStorage:FindFirstChild("Vendor")
local Trove = require(Vendor:FindFirstChild("Trove"))
local Find = require(Vendor:FindFirstChild("Find"))
local Spr = require(Vendor:FindFirstChild("Spr"))

local Channels_F = ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")

local Bindable_Events_F = Bindable_F:WaitForChild("Events")

local Data_Mods_F = ReplicatedStorage:FindFirstChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:FindFirstChild("Sound_Effect_Mod"))

local Fight_Cages_F:Folder = workspace:WaitForChild("Fight_Cages_F")

local ScreenGui:ScreenGui = script:FindFirstAncestorWhichIsA("ScreenGui")

local Round_Change_F = ScreenGui.Round_Change_F
local Bottom_Move_F = Round_Change_F.Bottom_F
local Round_Main_F = Round_Change_F.Main_F
local Round_Main_Txt = Round_Main_F.Main_Txt

local RoundChangeHandler = {}

function RoundChangeHandler.load(Round_Num)
	local Char:Model? = Player.Character or Player.CharacterAdded:Wait()
	local Ding_SE = Sound_Effect_Mod.Get_SE_Object(Player, "Start_Fight_Bell_SE")
	if(Ding_SE ~= nil)then
		Ding_SE:Play()
	end
	Sound_Effect_Mod.Play_Voice_Over("Round_" .. Round_Num)

	local function Reset_Display()
		local function Get_Max_Rounds()
			local All_Cages_M = Fight_Cages_F:GetChildren()

			local function Is_Main_Cage(Cage_M)
				local FD = Cage_M:FindFirstChild("Fight_Data_F")
				if(FD ~= nil and FD:FindFirstChild("Fight_Char_1") ~= nil and 
					FD:FindFirstChild("Fight_Char_2") ~= nil)then

					local C1_V = FD:FindFirstChild("Fight_Char_1")
					local C2_V = FD:FindFirstChild("Fight_Char_2")
					if(C1_V.Value == Char or C2_V.Value == Char) then
						return true
					end
				end

				return false
			end

			for i = 1, #All_Cages_M do
				local Cage_M = All_Cages_M[i]
				if(Cage_M ~= nil and Is_Main_Cage(Cage_M))then
					local Is_Ranked = Cage_M:GetAttribute("Ranked_Match")
					if(Is_Ranked ~= nil and Is_Ranked == true)then
						return 5
					end
				end
			end

			return 3
		end

		Round_Change_F.Visible = false
		Round_Main_F.Position = UDim2.new(1, 0, 0, 0)
		Bottom_Move_F.Position = UDim2.new(-1, 0, 0, 0)
		Round_Main_Txt.Text = "ROUND " .. Round_Num .. " OF " .. Get_Max_Rounds()
		Round_Main_Txt.Visible = true
		Round_Main_Txt.Position = UDim2.new(0.5, 0, 0.5, 0)
		Bindable_Events_F:WaitForChild("Mobile_Takedown_Toggle"):Fire(false)
	end
	Reset_Display()

	local function Show_Main()
		Round_Change_F.Visible = true
		Bottom_Move_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		Round_Main_F:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		wait(0.25)
	end
	Show_Main()

	local function Slight_Move()
		Bottom_Move_F:TweenPosition(UDim2.new(0.125, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 1, true, nil)
		Round_Main_F:TweenPosition(UDim2.new(-0.125, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 1, true, nil)

		wait(1)
	end
	Slight_Move()

	local function Move_Out()
		Bottom_Move_F:TweenPosition(UDim2.new(1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		Round_Main_F:TweenPosition(UDim2.new(-1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
		wait(0.25)	
	end
	Move_Out()

	Reset_Display()
end

return RoundChangeHandler]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4A23215E90514A0C9D015F890D98379B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">WrapStats.lua</string>
							<string name="ScriptGuid">{E60618C7-1456-459B-95E2-2A9A6703D344}</string>
							<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Spr = require(ReplicatedStorage.Vendor.Spr)

local DEFAULT_SIZE = UDim2.fromScale(1,1)
local DEFAULT_TEXT = "100"

local COLOR_VALUES = {
	ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(135, 255, 154)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(35, 244, 68)),
	}), 
	ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 183, 3)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(251, 133, 0)),
	}), 
	ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 89, 94)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(222, 55, 69)),
	})
}

return function(statsFrame:Frame)
	local healthBar:Frame = statsFrame:FindFirstChild("HealthBar",true)
	local staminaBar:Frame = statsFrame:FindFirstChild("StaminaBar",true)

	local healthBarTxt:TextLabel = healthBar:FindFirstChild("Txt",true)
	local healthBarLoader:ImageLabel = healthBar:FindFirstChild("Loader",true)

	local staminaBarTxt:TextLabel = staminaBar:FindFirstChild("Txt",true)
	local staminaBarLoader:ImageLabel = staminaBar:FindFirstChild("Loader",true)

	local healthGradient = healthBarLoader:FindFirstChildWhichIsA("UIGradient")

	return {
		Reset = function()
			healthBarTxt.Text = DEFAULT_TEXT
			staminaBarTxt.Text = DEFAULT_TEXT
			healthBarLoader.Size = DEFAULT_SIZE
			staminaBarLoader.Size = DEFAULT_SIZE
			if healthGradient then
				healthGradient.Color = COLOR_VALUES[1]
			end
		end,
		UpdateHealth = function(value:number)
			if not (value and type(value) == "number") then
				warn("value param is not valid", value)
				return
			end

			healthBarTxt.Text = tostring(value)
			Spr.target(healthBarLoader, 0.6, 2, {
				Size = UDim2.fromScale(value / 100, 1) 
			})

			if healthGradient then
				if value >= 60 then
					healthGradient.Color = COLOR_VALUES[1]
				elseif value <= 39 then
					healthGradient.Color = COLOR_VALUES[3]
				else
					healthGradient.Color = COLOR_VALUES[2]
				end
			end
		end,

		UpdateStamina = function(value)
			if not (value and type(value) == "number") then
				warn("value param is not valid",value)
				return
			end

			staminaBarTxt.Text = tostring(value)
			Spr.target(staminaBarLoader,0.6,2,{
				Size = UDim2.fromScale(value/100,1)
			})
		end,
	}
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0B0D0BC92A364095B5ED77CF8660B761">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BindThumbnail.lua</string>
							<string name="ScriptGuid">{9D78EA26-DAE9-47D5-8DEB-9BAC4DAAF390}</string>
							<ProtectedString name="Source"><![CDATA[local Players:Players = game:GetService("Players")


local DEFAULT_IMG = "rbxassetid://134663290660847"

local function tryGet(player:Player)
	local success,res =  pcall(function()
		return Players:GetUserThumbnailAsync(player.UserId,Enum.ThumbnailType.HeadShot,Enum.ThumbnailSize.Size150x150)
	end)

	if not success then
		return false
	end

	return true,res
end

return function(label:ImageLabel,player:Player|string)
	if not (label and typeof(label) == "Instance" and label:IsA("ImageLabel")) then
		return
	end

	if typeof(player) ~= "Instance" then
		if typeof(player) ~= "string" then
			label.Image = DEFAULT_IMG
			return
		end
		local foundPlayer = Players:FindFirstChild(player)
		if not foundPlayer then
			label.Image = DEFAULT_IMG
			return
		end
		
		player = foundPlayer
	end

	local success,thumbnail = tryGet(player)
	local tries = 0
	while (not success and tries < 2) do
		tries += 1
		success,thumbnail = tryGet(player)
		task.wait()
	end 

	if not success then
		label.Image = DEFAULT_IMG
		return

	end

	label.Image = thumbnail
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX9BD9468C590945A0BAD49CAA04C0732D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Submission_UI</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA2ED0E41FB22429F96C4547354ABF5BD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Old_Client_Fight_Code.client.lua</string>
							<string name="ScriptGuid">{E6309E17-1CF5-49C7-AD9B-E44FAFE3E1D0}</string>
							<ProtectedString name="Source"><![CDATA[local MPS = game:GetService("MarketplaceService")
local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local Debis = game:GetService("Debris")
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")
local Sword_Swing_UI = PG:WaitForChild("Sword_Swing_UI")
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")
local Head = Char:WaitForChild("Head")
local Cam = game.Workspace.CurrentCamera
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Receiving_F = Channels_F:WaitForChild("Server_Client_F")
local Sending_F = Channels_F:WaitForChild("Client_Server_F")
local Sending_RF = Sending_F:WaitForChild("RF")
local Data_Mod_F = game.ReplicatedStorage:WaitForChild("Data_Modules_F")
local Monetization_Mod = require(Data_Mod_F:WaitForChild("Monetization_Mod"))
local Client_Swing_Events_F = game.ReplicatedStorage:WaitForChild("Client_Click_Events_F")

local SE = script.Parent.SE
local PVP_Leave_B = script.Parent.Leave_PVP_Button
local CD_Txt = script.Parent.CD_Txt
local Auto_Click_B = script.Parent.Auto_Click_B
local Double_Wins_B = script.Parent.Double_Wins_B
local Main_F = script.Parent.Main_Bar_F

local Debounce_C = false
local Debounce_E = false
local Debounce_UI = false
local Is_Auto_Clicking = false

local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Format_Number(V)
	local function Format_Number(n)
		n = tostring(n)
		return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
	end

	if(V < 1000000)then
		return Format_Number(V)
	else
		local function Net_Worth_Convert(V)
			if(V < 1000)then
				return V .. ""
			else
				local FM_Txt = Format_Number(V)
				local FM = string.split(FM_Txt, ",")

				local function Truncate_Txt(Txt)
					local First_P = FM[1]
					local Sec_P = FM[2]

					if(string.len(First_P) == 3)then
						Sec_P = string.sub(Sec_P, 1, 1)
					elseif(string.len(Sec_P) == 3)then
						Sec_P = string.sub(Sec_P, 1, 2)
					end

					if(Sec_P == "00" or Sec_P == "000")then
						Sec_P = "0"
					end

					return First_P .. "." .. Sec_P .. Txt
				end

				if(V < 1000000)then
					--K
					return Truncate_Txt("K")
				elseif(V < 1000000000)then
					--M
					return Truncate_Txt("M")
				elseif(V < 1000000000000)then
					--B
					return Truncate_Txt("B")
				elseif(V < 1000000000000000)then
					--TRILLION
					return Truncate_Txt("T")
				else
					--Bigger than 1 Trillion!
					local Num_String_Mod = require(game.ReplicatedStorage:FindFirstChild("Data_Modules_F"):FindFirstChild("NumToString"))
					return Num_String_Mod.NumToString(V)
				end
			end
		end
		return Net_Worth_Convert(V)
	end
end

local function Get_Player_Val(Plr, Val_Name)
	local PD = Plr:WaitForChild("Player_Data")
	if(PD ~= nil)then
		local Val = PD:WaitForChild(Val_Name)
		if(Val ~= nil)then
			return Val.Value
		end
	end	

	return nil
end

local function Get_Thumbnail_Pic(P)
	local function Async()
		local Data = nil
		local Type = Enum.ThumbnailType.HeadShot
		local Size = Enum.ThumbnailSize.Size420x420
		local success, errormessage = pcall(function()
			Data = game.Players:GetUserThumbnailAsync(P.UserId, Type, Size)
		end)
		
		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end
	
	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end
	return "0000"
end
local Avatar_Pic = Get_Thumbnail_Pic(Plr)

local function Update_Swing_Button(Show)
	local Button = Sword_Swing_UI:WaitForChild("Swing_Button_F")
	if(Show == false and (UIS.GamepadEnabled or UIS.TouchEnabled == false))then
		Button.Visible = false
	else
		Button.Visible = true
	end
end

local function Toggle_NPC_Fight_Prompts(Show)
	local NPC_F = game.Workspace:WaitForChild("NPC_Fights_F"):GetChildren()
	for i = 1, #NPC_F do
		local Prompt = NPC_F[i]:FindFirstChild("Prompt_P"):FindFirstChildWhichIsA("ProximityPrompt")
		if(Prompt ~= nil)then
			Prompt.Enabled = Show
		end
	end
end

local function Show_UI(Fight_Data, Is_Inc)
	local Swing_Event = Client_Swing_Events_F:WaitForChild(Plr.UserId .. "_Event")
	local Fight_M = Fight_Data['Model']
	local Cam_P = Fight_M:FindFirstChild("Cam_P")
	local Damage_Index = Fight_M:FindFirstChild("Damage_Index_" .. Plr.UserId)
	local Swing_BF = Sword_Swing_UI:WaitForChild("Local_Bindables_F")
	local Is_PVP_Fight = (Fight_Data['Player_1'] ~= nil or Fight_Data['Player_2'] ~= nil)
	
	if(Is_PVP_Fight or Damage_Index == nil)then
		--Is PVP Fighting Handle
		Damage_Index = Fight_M:FindFirstChild("Damage_Index")
	end

	local function Auto_Clicking_Handle()
		--Update Text Bar
			--> Send Event to Click Handle
		--> Have special function for this on Server
		local Local_BF = Sword_Swing_UI:WaitForChild("Local_Bindables_F")
		local Swing_Ani = Local_BF:WaitForChild("Play_Single_Swing") 
		
		while Debounce_UI do
			if(Main_F.Click_Txt.Visible == true)then
				Main_F.Click_Txt.Text = "Start Tapping! (20/s)"
				Swing_Ani:Fire(Color3.new(0, 1, 0))
				Swing_Event:FireServer("Auto Click")
				local WT = math.clamp(0.125 - (Plr:GetNetworkPing() * 2000), 0.05, 0.125)
				wait(WT)

				if(Debounce_UI)then
					Swing_Ani:Fire(Color3.new(0, 1, 0))
					wait(0.125)
				end
				
			else
				wait(0.125)
			end
		end
	end

	local function Auto_Fight_Handle()
		local Local_BF = Sword_Swing_UI:WaitForChild("Local_Bindables_F")
		local Swing_Ani = Local_BF:WaitForChild("Play_Single_Swing") 

		while Debounce_UI and Swing_BF:WaitForChild("Is_Auto_On"):Invoke(true) and Is_Auto_Clicking == false do
			
			if(Main_F.Click_Txt.Visible == true)then
				Main_F.Click_Txt.Text = "Start Tapping! (5/s)"
				Swing_Ani:Fire(Color3.new(0, 1, 0))
				Swing_Event:FireServer("Fighting")
				local WT = math.clamp(0.125 - (Plr:GetNetworkPing() * 2000), 0.05, 0.125)
				wait(WT)
			else
				wait(0.125)
			end
		end
	end
	
	local function Reset_UI()
		Disconnect_Cons()
		CD_Txt.Visible = false
		
		PVP_Leave_B.Visible = false
		PVP_Leave_B.Position = UDim2.new(0.5, 0, 1.5, 0)
		
		Main_F.Position = UDim2.new(0.5, 0, 0.95, 0)
		Auto_Click_B.Position = UDim2.new(0.7875, 0, 0.8875, 0)
		Double_Wins_B.Position = UDim2.new(0.2125, 0, 0.8875, 0)
		
		Main_F.Player_Bar_F.Size = UDim2.new(0.5, 0, 1, 0)
		Main_F.Click_Txt.Visible = false
		Main_F.Click_Txt.Text = "Start Tapping! (0%)"
		
		Cam.FieldOfView = 60
		Cam.CameraType = Enum.CameraType.Scriptable
		Cam.CFrame = Cam_P.CFrame
		
		Main_F.Visible = true
		
		Is_Auto_Clicking = false
		
		if(Is_PVP_Fight)then
			Auto_Click_B.Visible = false
			Double_Wins_B.Visible = false
			
			Auto_Click_B.Position = UDim2.new(0.7875, 0, 1.5, 0)
			Double_Wins_B.Position = UDim2.new(0.2125, 0, 1.5, 0)
		else
			Auto_Click_B.Visible = true
			Double_Wins_B.Visible = true
		end
		
		local Destroy_Blur = Instance.new("BlurEffect", game.Lighting)
		Destroy_Blur.Name = "FIGHTINGBLUR"
		Destroy_Blur.Enabled = false
		Debis:AddItem(Destroy_Blur, 0.1)
		
		PG:WaitForChild("Cover_UI").Enabled = true
	end
	Reset_UI()
	
	local function Update_Opponent_Tab()
		local Opp_F = Main_F.Opponent_F
		
		if(Is_PVP_Fight == false)then
			Opp_F.Power_F.Power_Txt.Text = Format_Number(Fight_Data['NPC Power'])
			Opp_F.P_Name.Text = Fight_Data['Name']
			Opp_F.Image = Fight_Data['Icon Img']
		else
			local Opp_Plr = Fight_Data['Player_1']
			if(Opp_Plr == Plr)then
				Opp_Plr = Fight_Data['Player_2']
			end
			
			if(Opp_Plr == nil)then
				return
			end
			
			local Power_V = Get_Player_Val(Opp_Plr, "Power")
			Opp_F.Power_F.Power_Txt.Text = Format_Number(Power_V)
			Opp_F.P_Name.Text = Opp_Plr.Name
			Opp_F.Image = Get_Thumbnail_Pic(Opp_Plr)
		end
	end
	Update_Opponent_Tab()
	
	local function Update_Your_Tab()
		local Plr_F = Main_F.Plr_F
		local Power_V = Get_Player_Val(Plr, "Power")
		Plr_F.Power_F.Power_Txt.Text = Format_Number(Power_V)
		Plr_F.P_Name.Text = Plr.Name
		Plr_F.Image = Avatar_Pic
	end
	Update_Your_Tab()
	
	local function Button_Handle()
		local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
		local B_Def_X, B_Def_Y = 0.1125, 0.0675
		local B_Def_Size = UDim2.new(B_Def_X, 0, B_Def_Y, 0)
		local B_Hover_Size = UDim2.new(0.75, 0, 0.075, 0)
		local B_Click_Size = UDim2.new(B_Def_X * 0.75, 0, B_Def_Y * 0.75, 0)
		
		local function Hover_Effects(B, Default_Size, Hover_Size)
			local Selected = B:FindFirstChild("Selected")
			B.Size = Default_Size

			table.insert(Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false and B.Visible == true)then
					Debounce_E = true
					SE.Hover_SE:Play()
					B:TweenSize(Hover_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
					wait(0.125)
					Debounce_E = false
				end
			end))

			table.insert(Cons, Selected.MouseLeave:Connect(function()
				B:TweenSize(Default_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
			end))
		end
		Hover_Effects(Auto_Click_B, B_Def_Size, B_Hover_Size)
		Hover_Effects(Double_Wins_B, B_Def_Size, B_Hover_Size)
		
		table.insert(Cons, Auto_Click_B.Selected.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				SE.Click_SE:Play()
				TS:Create(Auto_Click_B, Tween_Click, {Size = B_Click_Size}):Play()
				
				local Owned_Keys = Monetization_Mod.Get_Player_Owned_Gamepasses_Keys(Plr)
				if(table.find(Owned_Keys, "B") == nil)then
					MPS:PromptGamePassPurchase(Plr, 262397442)
				elseif(Is_Auto_Clicking == false)then
					Is_Auto_Clicking = true
					Bindable_F:WaitForChild("Events"):WaitForChild("Display_Data"):Fire(" Auto Clicking is On!", Color3.fromRGB(0, 170, 255))
					Auto_Clicking_Handle()
				end
				
				wait(0.25)
				Debounce_C = false
			end
		end))
		
		table.insert(Cons, Double_Wins_B.Selected.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				SE.Click_SE:Play()
				TS:Create(Auto_Click_B, Tween_Click, {Size = B_Click_Size}):Play()

				local Owned_Keys = Monetization_Mod.Get_Player_Owned_Gamepasses_Keys(Plr)
				if(table.find(Owned_Keys, "E") == nil)then
					MPS:PromptGamePassPurchase(Plr, 262398078)
				else
					Bindable_F:WaitForChild("Events"):WaitForChild("Display_Data"):Fire(" You already own Double Wins!", Color3.fromRGB(0, 225, 0))
				end

				wait(0.25)
				Debounce_C = false
			end
		end))
	end
	
	if(Is_PVP_Fight == false)then
		Button_Handle()
	end
	
	Update_Swing_Button(false)
	
	local function Update_Damage_Data()
		--Update the Power Bar, Camera FOV, Update Clicking per Second data
		local function Get_X_Size()
			--> If Closer to 0
				--> Losing, Should be smaller
				--> Winning, should be bigger
			--FLIP IF IS_INC == FALSE
			local Midpoint = math.ceil(Fight_Data['Max Damage'] / 2)
			if(Is_Inc)then
				if(Damage_Index.Value > Midpoint)then
					--Winning
					local Dif = (Fight_Data['Max Damage'] - Damage_Index.Value) / Midpoint
					local Multi = 1 - Dif
					return 0.5 + (0.5 * Multi)
				else
					--Losing
					local Dif = (Midpoint - Damage_Index.Value) / Midpoint
					local Multi = 1 - Dif
					return 0.5 * Multi
				end
			else
				--Winning Closer to 0 == 1
				return (Fight_Data['Max Damage'] - Damage_Index.Value) / Fight_Data['Max Damage']
			end

		end
		local X_Size = math.clamp(Get_X_Size(), 0, 1)
		Main_F.Player_Bar_F:TweenSize(UDim2.new(X_Size, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
		
		local Update_Tween = TweenInfo.new(0.125, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
		local FOV = math.clamp(50 + (40 * X_Size), 50, 90)
		TS:Create(Cam, Update_Tween, {FieldOfView = FOV}):Play()
	end
	
	local function Victory_Or_Loss_Sound(Did_Lose)
		if(Did_Lose)then
			SE.Lost_SE:Play()
		else
			SE.Win_SE:Play()
		end
		
		Toggle_NPC_Fight_Prompts(true)
	end
	
	table.insert(Cons, Damage_Index.AncestryChanged:Connect(function()
		
		if(Damage_Index:IsDescendantOf(game.Workspace) == false)then
			--End
			local Tween_Cam = TweenInfo.new(3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)

			Disconnect_Cons()
			Victory_Or_Loss_Sound(Damage_Index.Value <= 0 and Is_Inc)

			CD_Txt.Visible = false
			Main_F.Click_Txt.Visible = false
			Main_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
			Auto_Click_B:TweenPosition(UDim2.new(0.7875, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
			Double_Wins_B:TweenPosition(UDim2.new(0.2125, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)

			TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
			PG:WaitForChild("Cover_UI").Enabled = false

			wait(3)

			Cam.CameraSubject = Hum
			Cam.CameraType = Enum.CameraType.Custom
			Cam.CFrame = Head.CFrame
			Cam.FieldOfView = 70

			Main_F.Visible = false
			Auto_Click_B.Visible = false
			Double_Wins_B.Visible = false

			Main_F.Position = UDim2.new(0.5, 0, 0.95, 0)
			Auto_Click_B.Position = UDim2.new(0.7875, 0, 0.8875, 0)
			Double_Wins_B.Position = UDim2.new(0.2125, 0, 0.8875, 0)

			Debounce_UI = false
			Debounce_C = false
			Debounce_E = false

			Update_Swing_Button(true)

			--Check if Auto Fighting then, run it!
			wait(0.75)
			if(Swing_BF:WaitForChild("Is_Auto_On"):Invoke(true))then
				local Current_Fight_M = Bindable_F:WaitForChild("RF"):WaitForChild("Get_Current_Auto_Fight"):Invoke()
				if(Current_Fight_M == nil)then
					Bindable_F:WaitForChild("Events"):WaitForChild("Open_Auto_Fight"):Fire()
				else
					local Res = Sending_RF:WaitForChild("Auto_Fight_Handle"):InvokeServer(Current_Fight_M)
					if(Res == false)then
						local Txt = " Someone else is Fighting that Samurai, Select a different Samurai!"
						Bindable_F:WaitForChild("Events"):WaitForChild("Display_Data"):Fire(Txt, Color3.new(1, 0, 0))
						Bindable_F:WaitForChild("Events"):WaitForChild("Open_Auto_Fight"):Fire()
					end
				end
			end
		end
	end))
	
	table.insert(Cons, Damage_Index.Changed:Connect(function()
		--Update the Power Bar, Camera FOV, Update Clicking per Second data
		Update_Damage_Data()
		
		--[[
		if(Damage_Index.Value <= 0 or Damage_Index.Value >= Fight_Data['Max Damage'])then
			--End
			local Tween_Cam = TweenInfo.new(3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
			
			Disconnect_Cons()
			Victory_Or_Loss_Sound(Damage_Index.Value <= 0 and Is_Inc)
			
			CD_Txt.Visible = false
			Main_F.Click_Txt.Visible = false
			Main_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
			Auto_Click_B:TweenPosition(UDim2.new(0.7875, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
			Double_Wins_B:TweenPosition(UDim2.new(0.2125, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
			
			TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
			PG:WaitForChild("Cover_UI").Enabled = false
			
			wait(3)
			
			Cam.CameraSubject = Hum
			Cam.CameraType = Enum.CameraType.Custom
			Cam.CFrame = Head.CFrame
			Cam.FieldOfView = 70
			
			Main_F.Visible = false
			Auto_Click_B.Visible = false
			Double_Wins_B.Visible = false
			
			Main_F.Position = UDim2.new(0.5, 0, 0.95, 0)
			Auto_Click_B.Position = UDim2.new(0.7875, 0, 0.8875, 0)
			Double_Wins_B.Position = UDim2.new(0.2125, 0, 0.8875, 0)
			
			Debounce_UI = false
			Debounce_C = false
			Debounce_E = false
			
			Update_Swing_Button(true)
			
			--Check if Auto Fighting then, run it!
			wait(0.75)
			if(Swing_BF:WaitForChild("Is_Auto_On"):Invoke(true))then
				local Current_Fight_M = Bindable_F:WaitForChild("RF"):WaitForChild("Get_Current_Auto_Fight"):Invoke()
				if(Current_Fight_M == nil)then
					Bindable_F:WaitForChild("Events"):WaitForChild("Open_Auto_Fight"):Fire()
				else
					local Res = Sending_RF:WaitForChild("Auto_Fight_Handle"):InvokeServer(Current_Fight_M)
					if(Res == false)then
						local Txt = " Someone else is Fighting that Samurai, Select a different Samurai!"
						Bindable_F:WaitForChild("Events"):WaitForChild("Display_Data"):Fire(Txt, Color3.new(1, 0, 0))
						Bindable_F:WaitForChild("Events"):WaitForChild("Open_Auto_Fight"):Fire()
					end
				end
			end
		end
		
				
		]]--
	end))
	
	table.insert(Cons, Receiving_F:WaitForChild("Events"):WaitForChild("Fight_Ended").OnClientEvent:Connect(function(Did_Win)
		--End
		local Tween_Cam = TweenInfo.new(3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)

		Disconnect_Cons()
		Victory_Or_Loss_Sound(not Did_Win)

		CD_Txt.Visible = false
		Main_F.Click_Txt.Visible = false
		Main_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
		Auto_Click_B:TweenPosition(UDim2.new(0.7875, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
		Double_Wins_B:TweenPosition(UDim2.new(0.2125, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
		PG:WaitForChild("Cover_UI").Enabled = false

		wait(3)

		Cam.CameraSubject = Hum
		Cam.CameraType = Enum.CameraType.Custom
		Cam.CFrame = Head.CFrame
		Cam.FieldOfView = 70

		Main_F.Visible = false
		Auto_Click_B.Visible = false
		Double_Wins_B.Visible = false

		Main_F.Position = UDim2.new(0.5, 0, 0.95, 0)
		Auto_Click_B.Position = UDim2.new(0.7875, 0, 0.8875, 0)
		Double_Wins_B.Position = UDim2.new(0.2125, 0, 0.8875, 0)

		Debounce_UI = false
		Debounce_C = false
		Debounce_E = false

		Update_Swing_Button(true)

		--Check if Auto Fighting then, run it!
		wait(0.75)
		if(Swing_BF:WaitForChild("Is_Auto_On"):Invoke(true))then
			local Current_Fight_M = Bindable_F:WaitForChild("RF"):WaitForChild("Get_Current_Auto_Fight"):Invoke()
			if(Current_Fight_M == nil)then
				Bindable_F:WaitForChild("Events"):WaitForChild("Open_Auto_Fight"):Fire()
			else
				local Res = Sending_RF:WaitForChild("Auto_Fight_Handle"):InvokeServer(Current_Fight_M)
				if(Res == false)then
					local Txt = " Someone else is Fighting that Samurai, Select a different Samurai!"
					Bindable_F:WaitForChild("Events"):WaitForChild("Display_Data"):Fire(Txt, Color3.new(1, 0, 0))
					Bindable_F:WaitForChild("Events"):WaitForChild("Open_Auto_Fight"):Fire()
				end
			end
		end
	end))
	
	local function CD_Handle()
		Toggle_NPC_Fight_Prompts(false)
		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
		
		local Trans_Tween = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
		
		local function Text_Effects(Txt)
			SE.Count_SE:Play()
			CD_Txt.Visible = false
			CD_Txt.TextTransparency = 1
			CD_Txt.TextStrokeTransparency = 1
			CD_Txt.Size = UDim2.new(0.75, 0, 0.75, 0)
			CD_Txt.Text = Txt
			
			CD_Txt.Visible = true
			TS:Create(CD_Txt, Trans_Tween, {TextTransparency = 0, TextStrokeTransparency = 0}):Play()
			CD_Txt:TweenSize(UDim2.new(0.15, 0, 0.15, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.125, true, nil)
			if Txt == "GO!" then
				local int = Instance.new("IntValue")
				local Tween = TS:Create(int, TweenInfo.new(0.875), {Value = 5})
				Tween:Play()
				Tween.Completed:Connect(function()
					int:Destroy()
					TS:Create(CD_Txt, Trans_Tween, {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
					CD_Txt:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.125, true, nil)
				end)
				wait(.5)
			else
				wait(0.875)
				TS:Create(CD_Txt, Trans_Tween, {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
				CD_Txt:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.125, true, nil)
				wait(0.125)
			end
		end
		--
		
		Text_Effects("3")
		Text_Effects("2")
		Text_Effects("1")

		Main_F.Click_Txt.Visible = true
		Text_Effects("GO!")
		
		Bindable_F:WaitForChild("Events"):WaitForChild("Click_Rate_Reset"):Fire()
		
		if(Is_Auto_Clicking == false and Swing_BF:WaitForChild("Is_Auto_On"):Invoke(true))then
			Auto_Fight_Handle()
		end
	end
	CD_Handle()
end

Receiving_F:WaitForChild("Events"):WaitForChild("Show_Fight_Data").OnClientEvent:Connect(function(Fight_M, Is_Inc, Cf)
	local int = Instance.new("IntValue")
	local tween = TS:Create(int, TweenInfo.new(.25), {Value = 5})
	tween:Play()
	tween.Completed:Connect(function()
		tween = TS:Create(int, TweenInfo.new(.25), {Value = 5})
		tween:Play()
		tween.Completed:Connect(function()
			int:Destroy()
			Plr.Character.PrimaryPart.CFrame = Cf
		end)
		Plr.Character.PrimaryPart.CFrame = Cf
	end)
	Show_UI(Fight_M, Is_Inc)
end)

Bindable_F:WaitForChild("RF"):WaitForChild("Is_Client_Fighting").OnInvoke = function()
	if(Debounce_UI)then
		if(Is_Auto_Clicking)then
			return "Auto"
		else
			return "Yes"
		end
	else
		return "No"
	end
end

Bindable_F:WaitForChild("RF"):WaitForChild("Idling_For_Fight").OnInvoke = function()
	if(Debounce_UI and Main_F.Click_Txt.Visible == false)then
		return true
	end
	
	return false
end

Bindable_F:WaitForChild("Events"):WaitForChild("Click_Rate_Update").Event:Connect(function(Rate)
	Main_F.Click_Txt.Text = "Start Tapping! (" .. Rate .. "/s)"
end)


local function PVP_Leave_Button_Handle()
	local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
	local B_Def_X, B_Def_Y = 0.15, 0.1
	local B_Def_Size = UDim2.new(B_Def_X, 0, B_Def_Y, 0)
	local B_Hover_Size = UDim2.new(0.1625, 0, 0.1125, 0)
	local B_Click_Size = UDim2.new(B_Def_X * 0.75, 0, B_Def_Y * 0.75, 0)

	local function Hover_Effects(B, Default_Size, Hover_Size)
		local Selected = B:FindFirstChild("Selected")
		B.Size = Default_Size

		Selected.MouseEnter:Connect(function()
			if(Debounce_E == false and B.Visible == true)then
				Debounce_E = true
				SE.Hover_SE:Play()
				B:TweenSize(Hover_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
				wait(0.125)
				Debounce_E = false
			end
		end)

		Selected.MouseLeave:Connect(function()
			B:TweenSize(Default_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
		end)
	end
	Hover_Effects(PVP_Leave_B, B_Def_Size, B_Hover_Size)

	PVP_Leave_B.Selected.MouseButton1Click:Connect(function()
		if(Debounce_C == false and PVP_Leave_B.Visible == true and 
			PVP_Leave_B.Position == UDim2.new(0.5, 0, 0.9, 0))then
			
			Debounce_C = true
			SE.Click_SE:Play()
			
			--Reset Camera
			--Move Button down
			--Send Event to Server to get them off Platform & Data, Reset WalkSpeed and Jump, 
			
			Update_Swing_Button(true)
			PVP_Leave_B:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
			Cam.CameraSubject = Hum
			Cam.CameraType = Enum.CameraType.Custom
			Cam.CFrame = Head.CFrame
			Cam.FieldOfView = 70
			
			Sending_F:WaitForChild("Events"):WaitForChild("Remove_From_PVP"):FireServer()
			
			wait(0.75)
			PVP_Leave_B.Visible = false
			PVP_Leave_B.Position = UDim2.new(0.5, 0, 1.5, 0)
			
			Debounce_C = false
		end
	end)
end
PVP_Leave_Button_Handle()

Receiving_F:WaitForChild("Events"):WaitForChild("Show_PVP_Leave").OnClientEvent:Connect(function(Cam_CF)
	SE.Click_SE:Play()
	Update_Swing_Button(false)
	
	PVP_Leave_B.Visible = false
	PVP_Leave_B.Position = UDim2.new(0.5, 0, 1.5, 0)
	PVP_Leave_B.Size = UDim2.new(0.15, 0, 0.1, 0)
	PVP_Leave_B.Visible = true
	PVP_Leave_B:TweenPosition(UDim2.new(0.5, 0, 0.9, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
	
	Cam.FieldOfView = 60
	Cam.CameraType = Enum.CameraType.Scriptable
	Cam.CFrame = Cam_CF
end)

function Init_Camera_Reset()
	if(Cam.CameraType == Enum.CameraType.Scriptable)then
		Cam.CameraSubject = Hum
		Cam.CameraType = Enum.CameraType.Custom
		Cam.CFrame = Head.CFrame
		Cam.FieldOfView = 70
	end
end
Init_Camera_Reset()]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7B0BBEE5B12848B7B38868235EEBBD2F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Click_Rate_System.client.lua</string>
							<string name="ScriptGuid">{3454F352-364F-45E0-ABD5-B8E8A2F8E4D3}</string>
							<ProtectedString name="Source"><![CDATA[--Use to track Client Clicking Speed
	--> On Click Event
		--> Sent Rate Event
	--> Reset Rate Event
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")

local Start_Time, Total_Clicks = os.time(), 0

local function Round_Rate(Raw_Rate)
	local Boosted_Rate = math.ceil(Raw_Rate * 10)
	return Boosted_Rate / 10
end

Bindable_Events_F:WaitForChild("Click_Rate_Reset").Event:Connect(function()
	Start_Time, Total_Clicks = os.time(), 0
end)

Bindable_Events_F:WaitForChild("Click_Rate_Inc").Event:Connect(function()
	local Current_Time = os.time()
	if(Total_Clicks == 0)then
		Start_Time = Current_Time
		Total_Clicks = 1
	else
		Total_Clicks = Total_Clicks + 1
	end
	
	local Rate = Round_Rate(Total_Clicks / (Current_Time - Start_Time))
	Bindable_Events_F:WaitForChild("Click_Rate_Update"):Fire(Rate)
end)]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7672C916FFB740C085024F7082AEF096">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Client_Submission_Handle.client.lua</string>
							<string name="ScriptGuid">{80720FF1-CEBC-424E-8A4D-E3D81B4227FE}</string>
							<ProtectedString name="Source"><![CDATA[local storage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TS = game:GetService("TweenService")

local myPlayer = game.Players.LocalPlayer
local Char = myPlayer.Character or myPlayer.CharacterAdded:Wait()
local Cam = game.Workspace.CurrentCamera

--Remotes
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Show_Flash_E = Bindable_Events_F:WaitForChild("Show_White_Fade")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local startEvent = Receiving_Events_F:WaitForChild("Start_Submission")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Heart_Beat_SE = Sound_Effect_Mod.Get_SE_Object(myPlayer, "Heartbeat_SE")

--UI Elements
local fightingGui = script.Parent
local mainBarFrame = fightingGui:WaitForChild("Main_Bar_F")
local myPlayerBar = mainBarFrame:WaitForChild("Player_Bar_F")
local Click_Txt = mainBarFrame:WaitForChild("Click_Txt")

local opponentThumbnail = mainBarFrame:WaitForChild("Opponent_F")
local playerThumbnail = mainBarFrame:WaitForChild("Plr_F")

local inGame = false
local clickConnection = nil
local progressConnection = nil

local Player_Thumbnail_Data = {

}
local function Get_Player_Thumbnail(ID)
	if(Player_Thumbnail_Data[ID] ~= nil)then
		return Player_Thumbnail_Data[ID]
	else
		local Type = Enum.ThumbnailType.HeadShot
		local Size = Enum.ThumbnailSize.Size420x420

		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				Data = game.Players:GetUserThumbnailAsync(ID, Type, Size)
			end)

			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end

		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				Player_Thumbnail_Data[ID] = D
				return D
			end
		end

		return "rbxassetid://100127687172105"
	end
end

local function StartGame(flip : boolean, clickedEvent, P1, P2)
	local Update_Tween = TweenInfo.new(0.125, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
	TS:Create(Cam, Update_Tween, {FieldOfView = 70}):Play()
	
	clickConnection = UserInputService.InputBegan:Connect(function(input : InputObject, gpe : boolean)
		if gpe then	
			return
		end
		
		if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 or input.KeyCode == Enum.KeyCode.ButtonR2 then
			clickedEvent:FireServer()
			Bindable_Events_F:WaitForChild("Click_Rate_Inc"):Fire()
		end
	end)
	
	progressConnection = clickedEvent.OnClientEvent:Connect(function(informationTable)
		local progress = informationTable.gameProgress / 100
		if flip then
			progress = 1 - progress
		end
		myPlayerBar.Size = UDim2.fromScale(progress, myPlayerBar.Size.Y.Scale)
		
		local FOV = math.clamp(70 - (25 * progress), 45, 70)
		TS:Create(Cam, Update_Tween, {FieldOfView = FOV}):Play()
		
	end)
	inGame = true
	
	local Submission_Char_V = clickedEvent.Parent
	local Is_Attacking = (Submission_Char_V.Value == Char)
	Bindable_Events_F:WaitForChild("On_Submission_Handle"):Fire(Is_Attacking, true)
	
	local function Display_Handle()
		Bindable_Events_F:WaitForChild("Click_Rate_Reset"):Fire()
		
		local function Update_Icon_Images()
			opponentThumbnail.Image = "rbxassetid://100127687172105"
			playerThumbnail.Image = "rbxassetid://100127687172105"
			
			if(P1 ~= nil)then
				local Image = Get_Player_Thumbnail(P1.UserId)
				if(P1 == myPlayer)then
					playerThumbnail.Image = Image
				else
					opponentThumbnail.Image = Image
				end
			end
			
			if(P2 ~= nil)then
				local Image = Get_Player_Thumbnail(P2.UserId)
				if(P2 == myPlayer)then
					playerThumbnail.Image = Image
				else
					opponentThumbnail.Image = Image
				end
			end
		end
		Update_Icon_Images()
		
		mainBarFrame.Visible = false
		mainBarFrame.Position = UDim2.new(0.5, 0, 1.25, 0)
		mainBarFrame:TweenPosition(UDim2.new(0.5, 0, 0.975, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
		mainBarFrame.Visible = true
		
		Bindable_Events_F:WaitForChild("Toggle_Takedown_Prog_Button"):Fire(false)
	end
	
	Display_Handle()
	
	local function Show_Heart_Beat_Effects()
		if(Heart_Beat_SE ~= nil)then
			Heart_Beat_SE:Play()
		end
		
		while inGame do
			for i = 1, 2 do
				if(inGame)then
					Show_Flash_E:Fire(Color3.fromRGB(255, 75, 75))
					wait(0.75)
				end
			end
			wait(1)
		end
		
		if(Heart_Beat_SE ~= nil)then
			Heart_Beat_SE:Stop()
		end
	end
	task.spawn(Show_Heart_Beat_Effects)
end

local function EndGame()
	if clickConnection then
		clickConnection:Disconnect()
	end
	
	if progressConnection then
		progressConnection:Disconnect()
	end
	
	inGame = false
	
	mainBarFrame:TweenPosition(UDim2.new(0.5, 0, 1.25, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.375, true, nil)
	Bindable_Events_F:WaitForChild("On_Submission_Handle"):Fire(false, false)
	Bindable_Events_F:WaitForChild("Toggle_Takedown_Prog_Button"):Fire(true)
end

startEvent.OnClientEvent:Connect(function(command : string, args : {}, clicked_Event)
	if command == "START" then
		if inGame then
			warn("Player in game already")
			return
		end
		--print(args)
		--opponentThumbnail.Image = args.imageIDs[2]
		--playerThumbnail.Image = args.imageIDs[1]
		
		StartGame(args.flip, clicked_Event, args.P1, args.P2)
	elseif command == "STOP" then
		EndGame()
	end
	
end)

Bindable_Events_F:WaitForChild("Click_Rate_Update").Event:Connect(function(Rate)
	Click_Txt.Text = "Start Tapping! (" .. Rate .. "/s)"
end)
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXB1FF5155B95044D3B8B6D9A325C31377">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Main_Bar_F</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX9E606130FBAA4034A31B1431776B3FE5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PlayerBarEffects.client.lua</string>
								<string name="ScriptGuid">{507F28DF-D906-4C2E-BD9D-4CAFFC7200F4}</string>
								<ProtectedString name="Source"><![CDATA[local MainSize = script.Parent.Size
local PlayerBar = script.Parent:WaitForChild("Player_Bar_F")
local Bool = true
local Ts = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer

PlayerBar:GetPropertyChangedSignal("Size"):Connect(function()
	if Bool == true then
		Bool = false
		local Swinging = false
		for i, v in pairs(Plr.Character.Humanoid:GetPlayingAnimationTracks()) do
			if v.Name:split("Swing")[2] then
				Swinging = true
				break
			end
		end
		if Swinging == true then
			local Tween = Ts:Create(script.Parent, TweenInfo.new(0.1, Enum.EasingStyle.Linear), {Size = UDim2.new(MainSize.X.Scale * 1.2,0,MainSize.Y.Scale * 1.075,0)})
			Tween:Play()
			Tween.Completed:Connect(function()
				local Tween2 = Ts:Create(script.Parent, TweenInfo.new(0.1, Enum.EasingStyle.Linear), {Size = MainSize})
				Tween2:Play()
				Tween2.Completed:Connect(function()
					Bool = true
				end)
			end)
		else
			Bool = true
		end
	end
end)

script.Parent:GetPropertyChangedSignal("Position"):Connect(function()
	while script.Parent.Position.Y.Scale ~= 1.5 do
		wait()
		local MainTween = Ts:Create(script.Parent, TweenInfo.new(1, Enum.EasingStyle.Linear), {Rotation = 3.5})
		MainTween:Play()
		MainTween.Completed:Wait()
		MainTween = Ts:Create(script.Parent, TweenInfo.new(1, Enum.EasingStyle.Linear), {Rotation = -3.5})
		MainTween:Play()
		MainTween.Completed:Wait()
	end
end)

]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXF19FBF87D5FA4424B94A8E8153244443">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Gym_Training_Handle</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXEEA932D5DA5748D1A1193551B3E48343">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Training_Handle.client.lua</string>
						<string name="ScriptGuid">{03F49E8A-D386-4A48-A263-E7CF37F7F663}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	* Server tells the Client that they are starting to train
	* Make sure the Player is not currently Fighting, Force them out Fight Mode if they are in it
	* Toggle Away Side Button UI's, add a Blurr to make sure you can't open anything up
]]--

local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Sending_Events_F = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("Events")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Animation_Objs_F = game.ReplicatedStorage:WaitForChild("Animation_Objs_F")

local Exit_B = script.Parent.Exit_B
local Selected = Exit_B.Selected
local Data_Txt = Exit_B.Main_Txt
local Stroke = Exit_B.UIStroke

local Debounce_C = false
local Debounce_E = false

local Destructor = nil

local Animations = {
	["Treadmill"] = {
		ID = 116881737461921,
		Looped = true,
		Speed = 1,
	},
	["SquatRack"] = {
		ID = 139820058119859,
		Looped = true,
		Speed = 0.4,
	},
	["Pusher"] = {
		ID = 123283345540993,
		Looped = true,
		Speed = 0.7,
	},
	["Dumbells"] = {
		ID = 129314989044360,
		Looped = true,
		Speed = 0.4,
	},
	["BenchPress"] = {
		ID = 100020893468451,
		Looped = true,
		Speed = 0.4,
	},
	["BenchPress2"] = {
		ID = 100020893468451,
		Looped = true,
		Speed = 0.4,
	},
	["GymFloorMat"] = {
		ID = 128818857460265,
		Looped = true,
		Speed = 0.4,
	},
	--["SquatRack"] = {
	--	ID = 000,
	--	Looped = true,
	--},
}

local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			if typeof(Cons[i]) == "function" then
				Cons[i]()
				Cons[i] = nil
			else
				Cons[i]:Disconnect()
			end
		end
	end
	table.clear(Cons)
end

local function Reset_Char_Animations(Char)
	local Hum = Char:FindFirstChild("Humanoid")
	if(Hum ~= nil)then
		local animator = Hum:WaitForChild("Animator") :: Animator
		local Ani_Tracks = animator:GetPlayingAnimationTracks()
		for i = 1, #Ani_Tracks do
			if(Ani_Tracks[i] ~= nil and string.match(Ani_Tracks[i].Name, "_Gym") == nil)then
				Ani_Tracks[i]:Stop()
				Ani_Tracks[i]:Destroy()
			end
		end
	end
end

local function Remove_UI()
	Plr.Character:WaitForChild("Humanoid").WalkSpeed = 16
	Plr.Character:WaitForChild("Humanoid").JumpPower = 50
	Plr.Character:WaitForChild("HumanoidRootPart").Anchored = false
	Reset_Char_Animations(Plr.Character)
	Disconnect_Cons()
	Exit_B:TweenPosition(UDim2.new(0.5, 0, 1.15, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.75, true, nil)
	--Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true)
	Bindable_Events_F:WaitForChild("Toggle_Reset"):Fire(true)
	
	if Destructor ~= nil then
		Destructor()
		Destructor = nil
	end
	
	wait(0.75)
	
	local Old_Blur = game.Lighting:FindFirstChild("Gym_Blurr")
	if(Old_Blur ~= nil)then
		Old_Blur:Destroy()
	end
	Exit_B.Position = UDim2.new(0.5, 0, 1.15, 0)
	--Exit_B.Visible = false
	
	Debounce_C = false
	Debounce_E = false
end
Remove_UI()

local function Get_Animation_Track(Name, ID)
	local function Create_Animation_Object()
		local Ani_Obj = Animation_Objs_F:FindFirstChild(Name .. "_Gym")
		if(Ani_Obj == nil)then
			Ani_Obj = Instance.new("Animation", Animation_Objs_F)
			Ani_Obj.Name = Name .. "_Ani"
			Ani_Obj.AnimationId = "rbxassetid://" .. ID
		end
		return Ani_Obj
	end
	local Ani_Obj = Create_Animation_Object()
	return Hum:LoadAnimation(Ani_Obj)
end

local function Preload_Animation_Tracks()
	local Track_Data = {
		
	}
	
	for Anim_Name, Ani_Data in next, Animations do
		local Track = Get_Animation_Track(Anim_Name, Ani_Data['ID'])
		Track.Looped = Ani_Data['Looped']
		Track_Data[Anim_Name] = Track
	end
	
	return Track_Data
end
local Preloaded_Anim_Tracks = Preload_Animation_Tracks()

local function Get_Anim_Track(Ani_Name)
	if(Preloaded_Anim_Tracks[Ani_Name] == nil)then
		local Data = Animations[Ani_Name]
		local Track = Get_Animation_Track(Ani_Name, Data['ID'])
		Track.Looped = Data['Looped']
		Preloaded_Anim_Tracks[Ani_Name] = Track
	end
	
	return Preloaded_Anim_Tracks[Ani_Name]
end

local function Show_UI()
	local function Reset_Handle()
		Disconnect_Cons()
		--Exit_B.Visible = false
		Exit_B.Position = UDim2.new(0.5, 0, 1.15, 0)
		
		local Old_Blur = game.Lighting:FindFirstChild("Gym_Blurr")
		if(Old_Blur ~= nil)then
			Old_Blur:Destroy()
		end
	end
	Reset_Handle()
	
	task.spawn(function()
		Bindable_Events_F:WaitForChild("Disable_Fight_Mode"):Fire(true)
		Bindable_Events_F:WaitForChild("On_Submission_Handle"):Fire(true, true)
		Bindable_Events_F:WaitForChild("Set_Fight_Mode_Lock"):Fire(true)
		Bindable_Events_F:WaitForChild("Toggle_Reset"):Fire(false)
	end)
	
	local function Setup_Training()
		for _, machine in pairs(workspace.Main_World_F.ScriptableObjects.GymObjects:GetChildren()) do
			if (machine ~= nil and machine:FindFirstChild("Stats")) then
				if (machine:FindFirstChild("Stats"):FindFirstChild("Player_Using") ~= nil and machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == Plr.Name) then
					if (Animations[machine.Name]) then
						Reset_Char_Animations(Plr.Character)
						task.wait()
						local Anim_Track = Get_Anim_Track(machine.Name)
						if(Anim_Track ~= nil)then
							Anim_Track.Looped = Animations[machine.Name].Looped
							Anim_Track.Priority = Enum.AnimationPriority.Action
							Anim_Track:Play()
							Anim_Track:AdjustSpeed(Animations[machine.Name].Speed)
						end
						
						Cons[#Cons + 1] = function()
							if (Anim_Track ~= nil) then
								Anim_Track:Stop()
								Anim_Track = nil
							end
						end
						
						if (machine:FindFirstChild("Barbell") ~= nil or machine:FindFirstChild("Dumbells") ~= nil or machine.Name == "GymFloorMat") then
							table.insert(Cons, Anim_Track.DidLoop:Connect(function()
								task.wait()
								Sending_Events_F:WaitForChild("Workout_Rep"):FireServer()
							end))
						end 
						
					end
					
					game:GetService("ProximityPromptService").Enabled = false
					Destructor = function()
						Bindable_Events_F:WaitForChild("On_Submission_Handle"):Fire(false, false)
						Bindable_Events_F:WaitForChild("Set_Fight_Mode_Lock"):Fire(false)
						game:GetService("ProximityPromptService").Enabled = true
					end
					break
				end
			end
		end
	end
	Setup_Training()
	
	local function Display_Button()
		Exit_B.Visible = true
		Exit_B:TweenPosition(UDim2.new(0.5, 0, 0.925, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Gym_Blurr"
		Blur.Size = 0

		Bindable_Events_F:WaitForChild("Disable_Fight_Mode"):Fire()

		Sound_Effect_Mod.Play_Voice_Over("Training")

		Debounce_C = false
		Debounce_E = false

		Plr.Character:WaitForChild("Humanoid").WalkSpeed = 0
		Plr.Character:WaitForChild("Humanoid").JumpPower = 0
		Plr.Character.PrimaryPart.AssemblyLinearVelocity = Vector3.zero
		Plr.Character.PrimaryPart.Anchored = true

		wait(.5)
		Plr.Character:WaitForChild("Humanoid").WalkSpeed = 0
		Plr.Character:WaitForChild("Humanoid").JumpPower = 0
		--Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false)
	end
	Display_Button()
	

	local function Button_Handle()
		local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
		local Hover_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Hover_SE")
		local Click_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Click_SE")

		Exit_B.Size = UDim2.new(0.15, 0, 0.0875, 0)
		Stroke.Color = Color3.fromRGB(35, 244, 68)
		Data_Txt.TextColor3 = Color3.new(1, 1, 1)

		table.insert(Cons, Selected.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				if(Hover_SE ~= nil)then
					Hover_SE:Play()
				end

				Stroke.Color = Color3.new(1, 0, 0)
				Data_Txt.TextColor3 = Color3.new(1, 0, 0)
				Exit_B:TweenSize(UDim2.new(0.1725, 0, 0.100625, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.25, true, nil)

				Debounce_E = false
			end
		end))

		table.insert(Cons, Selected.MouseLeave:Connect(function()
			Exit_B:TweenSize(UDim2.new(0.15, 0, 0.0875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.25, true, nil)
			Stroke.Color = Color3.fromRGB(35, 244, 68)
			Data_Txt.TextColor3 = Color3.new(1, 1, 1)
		end))

		local activated = function()
			if(Debounce_C == false)then
				Debounce_C = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.1125, 0, 0.065625, 0)}):Play()

				task.spawn(function()
					Sending_Events_F:WaitForChild("Exit_Machine"):FireServer()
				end)

				wait(0.25)
				Debounce_C = false
			end
		end

		table.insert(Cons, Selected.Activated:Connect(function()
			activated()
		end))
		table.insert(Cons, game:GetService("UserInputService").InputBegan:Connect(function(inp, bool)
			if bool == true then
				return
			end

			if inp.KeyCode == Enum.KeyCode.ButtonX then
				activated()
			elseif inp.KeyCode == Enum.KeyCode.X then
				activated()
			end
		end))
	end
	Button_Handle()
end


Receiving_Events_F:WaitForChild("Init_Gym_Training").OnClientEvent:Connect(function(bool)
	if(bool == true)then
		Show_UI()
	else
		Remove_UI()
	end
end)

--[[
	I am trying to fix a soft lock bug
	
	If you train and quickly leave then train again, you got soft-locked
	
	Now I added a sort of debounce to the code so that it doesn't happen, however I have an animation bug
	
	Roger--
	
	That's what Debounce_UI is for ~ when a Player clicks the Exit Button, it removes the Button
	Waits 0.75 then toggles the Debounce_UI Bool to false
	
	I'm adding a check on the Server to make sure you can't enter Training while being in Fight Mode which 
	should also fix some issues
	
	
	I handled that already, line 180 I disable fight mode and lock the player so that they can't use the fight tool
	
	Roger--
	
	U can still enter training tho while being in Fight mode unless u just fixed that, let me check
	
	I think I fixed that a WHILE ago tho, it's been like that for a while
	
	Roger--
	
	Okay, I'll let you cook
	
	was if fixed tho?
	
	No I could still start training while using Fight Mode
	
	Yea but it unequips if you do, like it doesn't break,
	 
	True, but maybe that's the cause the Animation bug
	
	I don't think so, I think it's the undeterministic nature of the code base you have
	
	Setting DebouceUI to false 0.75 seconds after is a big no no
	What if another piece of code runs inbetween that 0.75? Hella underrministic
	
	Roger--
	
	We disconnect everything at the very start, or at least that's how it should be. 
	That way that issue never pops up. The time delay is mostly to let the Exit Button tween 
	completely out of view before enabling it again
	
	Yea I saw that but your DebouceUI wasn't a caceling operation. It was just a switch
	If debounceUI == false then -- Menu is Open, we gotta close it
		CloseUI()
	else
		OpenUI()
	end
	
	You know what I mean?
	
	Roger--
	
	Ye but that was exactly the point of it, the only way we should be able to close it is via the Client's input
	
	
	If you make the debouceUI a switch boolean instead of a canceling operation you get some very undefined behavior
	
	Like imagine this, your value is false, you close the menu and only after 0.75 seconds you set it to true.
	IF there are any calls to Open the menu within that 0.75 seconds, if still think the value is false, even tho it will be true
	after 0.75 seconds
	
	Code is very unreliable in this case
	
	Roger--
	
	Yea that's the issue I saw with the Mobile bug video clip you can set the DebounceUI bool before the 0.75 delay and that should fix the issue
	or we add an additional check on the Server but idk how you would reliably ask the server
	
	but go for it, seems like u got something cooking
	
	
	So, the way to make it reliable is this:
		Run events on the server to run the training sequence (RequestTraining:FireServer())
		Run events on the server to stop the trianing sequence (RequestStopTraining:FireServer())
		
		
		IF server validates that you are training, send even to client to open menu
		IF server validates taht you are not trainign, send event to client to close menu
		
		RequestTraining.OnServerEvent:Connect(function())
			if playerCanTrain then
				setupPlayer()
				RequestTraining:FireClient(plr)
			end
		end)
		
		RequestStopTraining.OnServerEvent:Connect(function())
			if playerIsTraining then
				desetupPlayer()
				RequestStopTraining:FireClient(plr)
			end
		end)
		
	
	That's all ngl. Let the server do the checking, you do the special effects and menus on the client
	
	Roger--
]]
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX0D5797D851EA4B1D96FDD38644DF7497">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Exit_B</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXFA45F88EAD4F4F87A676C13EE4E3FBBE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Xbox</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXD3CFD48152564B1DB9E1638C13D98BB5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LocalScript.client.lua</string>
								<string name="ScriptGuid">{33D084B1-1096-4B03-8D87-94534336131B}</string>
								<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local updateXbox = function()
	local Mapped_Key = uis:GetStringForKeyCode(Enum.KeyCode.ButtonX)
	if(Mapped_Key == "ButtonX")then
		script.Parent.Image = "rbxassetid://115257536194509"
	else
		--PS5
		script.Parent.Image = "rbxassetid://137985933701432"
	end
	
	script.Parent.Visible = uis.GamepadEnabled
end

if uis.GamepadEnabled then
	updateXbox(true)
else
	updateXbox(false)
end
local conn2 = uis.GamepadConnected:Connect(function()
	if uis.GamepadEnabled then
		updateXbox(true)
	else
		updateXbox(false)
	end
end)
local conn2 = uis.GamepadDisconnected:Connect(function()
	if uis.GamepadEnabled then
		updateXbox(true)
	else
		updateXbox(false)
	end
end)]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXE17098B8A92B4EA0A05373681C811177">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">PC</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXF555A70BE2164489A18B82F044C29462">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LocalScript.client.lua</string>
								<string name="ScriptGuid">{9ADE2A0F-6648-40CB-BFD1-51EABD644C05}</string>
								<ProtectedString name="Source"><![CDATA[
local uis = game:GetService("UserInputService")

local updatePC = function()
	if uis.KeyboardEnabled == true and uis.GamepadEnabled == false then
		script.Parent.Visible = true
	else
		script.Parent.Visible = false
	end
end

updatePC()
while task.wait(1) do
	updatePC()
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX6C5C03D705CC4735BBA653AC5DFF7553">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Combination_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX0780673E95084D09884D50BDEC734DBB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Inventory_Handle.client.lua</string>
						<string name="ScriptGuid">{6E10DBEF-6AC3-4A73-8FED-C526F749A9F5}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Owned_Strikes_V = PD:WaitForChild("Owned Special Strikes")
local Owned_Submissions_V = PD:WaitForChild("Owned Special Submissions")
local Owned_Gloves_V = PD:WaitForChild("Owned Gloves")
local Owned_Shorts_V = PD:WaitForChild("Owned Shorts")
local Takedown_V = PD:WaitForChild("Takedown Key")
local Submission_V = PD:WaitForChild("Submission Key")
local Cash_V = PD:WaitForChild("Coins")
local Bio_V = PD:WaitForChild("Bio")
local SkinTone_V = PD:WaitForChild("Skin Tone")
local Country_V = PD:WaitForChild("Country")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Sending_RF = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("RF")
local Sending_Events_F = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("Events")
local Display_Data_E = Bindable_Events_F:WaitForChild("Display_Data")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Num_Str_Mod = require(Data_Mods_F:WaitForChild("Num_String_Mod"))
local Country_Mod = require(Data_Mods_F:WaitForChild("Country_Mod"))
local Skin_Tone_Mod = require(Data_Mods_F:WaitForChild("Skin_Tone_Mod"))
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Hover_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Hover_SE")
local Click_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Click_SE")
local Combination_Data = Animation_Mod.Get_Combinations("Combination")
local Submission_Data = Animation_Mod.Get_Combinations("Submission")
local Takedown_Data = Animation_Mod.Get_Combinations("Takedown")
local Shorts_Data = Clothing_Mod.Get_Shorts_Data()
local Gloves_Data = Clothing_Mod.Get_Gloves_Data()
local Country_Data = Country_Mod.Get_Country_Data()


local Cam = game.Workspace.CurrentCamera

local Core_UI = script.Parent.Main_F
local Exit_B = Core_UI.Top_Bar_F.Exit_B
local Top_Bar_F = Core_UI.Top_Bar_F
local Title_Txt = Top_Bar_F.Title_Txt
local Main_Data_F = Core_UI.Main_Data_F

local function MoveElementToInitialPosition()
	Main_Data_F:TweenPosition(UDim2.new(0.376, 0 ,0.543, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
	Top_Bar_F:TweenPosition(UDim2.new(0.376, 0,0.269, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
	-- Exit_B:TweenPosition(UDim2.new(0.41, 0,0.239, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
end

local function InitialPositions()
	Main_Data_F:TweenPosition(UDim2.new(0.5, 0, 0.543, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
	Top_Bar_F:TweenPosition(UDim2.new(0.5, 0, 0.269, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
	-- Exit_B:TweenPosition(UDim2.new(0.556, 0,0.239, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
end

local Top_Change_Buttons_F = Main_Data_F.Top_Change_Buttons_F
local Combination_F = Main_Data_F.Combination_F
local Combination_Select_F = Core_UI.Combination_Select_F
local Equipment_F = Main_Data_F.Equipment_F
local Appearance_F = Main_Data_F.Appearance_F

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Debounce_UI = false
local Debounce_C = false
local Debounce_E = false
local Debounce_T = false
local Debounce_S = false
local Debounce_R = false

local Can_Edit = false
local Toggle_DropDown = false

local Selected_Combo
local Selected_Strike
local Selected_Action

local Default_Strikes = {
	['Strike Combo 1'] = {"C", "A", "B"},
	['Strike Combo 2'] = {"F", "D", "E"},
	['Strike Combo 3'] = {"G", "L", "M"},
	['Strike Combo 4'] = {"F", "J", "H"},
	['Submission Key'] = {"A"},
	['Takedown Key'] = {"A"},
}

local function multiUdim2(ud, scalar)
	return UDim2.new(ud.X.Scale * scalar, ud.X.Offset * scalar, ud.Y.Scale * scalar, ud.Y.Offset * scalar)
end

local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Save_Bio()
	task.spawn(function()
		Sending_Events_F:WaitForChild("Save_Appearance"):FireServer(Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text, Appearance_F.Country_F.Country_Txt.Text, Appearance_F.Skin_Tone_F.Skin_Tone_Txt.Text) -- bio,country,skin (later look-alike aswell)
	end)
	wait(0.25)
end

local function Remove_UI()
	Disconnect_Cons()
	Core_UI:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	Save_Bio()

	Core_UI.Visible = false
	Core_UI.Position = UDim2.new(0.5, 0, 0.675, 0)
	Combination_Select_F.Visible = false

	local Blur = game.Lighting:FindFirstChild("Inventory_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true, true)
	Bindable_Events_F:WaitForChild("Toggle_Tutorial_Display"):Fire(true)

	Debounce_UI = false
end

local function Button_Handle(B, func)
	local orgSize = B.Size

	B.MouseEnter:Connect(function()
		if(Debounce_E == false)then
			Debounce_E = true
			if(Hover_SE ~= nil)then
				Hover_SE:Play()
			end

			B:TweenSize(multiUdim2(orgSize, 1.1), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)


			Debounce_E = false
		end
	end)

	B.MouseLeave:Connect(function()
		B:TweenSize(multiUdim2(orgSize, 1), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	end)

	B.MouseButton1Click:Connect(function()
		if(Debounce_C == false)then
			Debounce_C = true
			if(Click_SE ~= nil)then
				Click_SE:Play()
			end
			TS:Create(B, Tween_Click, {Size = multiUdim2(orgSize, .95)}):Play()
			coroutine.wrap(func)()
			wait(0.25)
			Debounce_C = false
		end
	end)

end

--// Equipment Handler

local function Load_Equipment(equipment_type) -- glove / shorts equipment
	--// Clear Old
	local Tabs_F = Equipment_F.Main_Data_F.Tabs_F:GetChildren()

	if #Tabs_F > 0 then
		for t = 1, #Tabs_F do
			local TMP = Tabs_F[t]
			if(TMP ~= nil and TMP:IsA("Frame"))then
				TMP:Destroy()
			end
		end
		Disconnect_Cons()
	end

	--// Load New
	local X = 0.15 -- 0.3
	local Y = 0.25 -- 0.5
	if (equipment_type == "Gloves") then
		local c = 0
		for index, value in pairs(Gloves_Data) do
			c += 1
			
			local temp = Equipment_F.Main_Data_F.TMP_Tab:Clone()
			temp.Parent = Equipment_F.Main_Data_F.Tabs_F
			temp.LayoutOrder = c
			
			if index == "K" or index == "K1" then -- Mystic Gloves, Gold Gloves
				temp.LayoutOrder = 5
			end
			
			temp.Name = index
			temp = temp.Frame
			temp.Name_F.Name_Txt.Text = value
			--temp.Position = UDim2.new(X,0,Y,0)
			temp.Visible = true

			--// load viewport stuff 
			local Og_Size = temp.Size
			local display = game.ReplicatedStorage.Clothing_F.Gloves_F:FindFirstChild(value):Clone()
			local Viewport_Camera = Instance.new("Camera")

			if (display:FindFirstChild("LeftHand")) then

				for _, part in pairs(display:GetChildren()) do
					if (part:IsA("BasePart") and (part.Name == "LeftHand" or part.Name == "RightHand")) then
						local groupName = part.Name .. "M"
						local group = display:FindFirstChild(groupName) or Instance.new("Model")
						group.Name = groupName
						group.Parent = display
						part.Parent = group
						part.Anchored = true
					end
				end

				if (display:FindFirstChild("LeftHandM") and display:FindFirstChild("RightHandM")) then
					display:PivotTo(CFrame.new(0,0,0))

					display:WaitForChild("RightHandM"):PivotTo(CFrame.new(0.5, 0, 0))
					display:WaitForChild("LeftHandM"):PivotTo(CFrame.new(-0.5, 0, 0))

					for _, modelName in ipairs({"LeftHandM", "RightHandM"}) do
						local model = display[modelName]

						local hitbox = Instance.new("Part")
						hitbox.Name = "Hitbox"
						hitbox.Size = model:GetExtentsSize()
						hitbox.CFrame = model:GetPivot()
						hitbox.Anchored = true
						hitbox.Transparency = 1
						hitbox.CanCollide = false
						hitbox.Parent = model

						model.PrimaryPart = hitbox

						for _, part in ipairs(model:GetChildren()) do
							if (part:IsA("BasePart") and part ~= model.PrimaryPart) then
								local weld = Instance.new("WeldConstraint")
								weld.Part0 = model.PrimaryPart
								weld.Part1 = part
								weld.Parent = model.PrimaryPart
								part.Anchored = false
								--else
								--part.Anchored = true
							end
						end

					end

					display:WaitForChild("RightHandM"):PivotTo(CFrame.new(0.5, 0, 0))
					display:WaitForChild("LeftHandM"):PivotTo(CFrame.new(-0.5, 0, 0))
					
					--local leftLook = display:WaitForChild("LeftHandM").PrimaryPart.CFrame.LookVector
					--local leftSpinDirection = -1
					--if leftLook.Z > 0 then 
					--	leftSpinDirection = 1
					--end

					--local rightLook = display:WaitForChild("RightHandM").PrimaryPart.CFrame.LookVector
					--local rightSpinDirection = -1
					--if rightLook.Z < 0 then 
					--	rightSpinDirection = 1
					--end
					
					if Clothing_Mod.Player_Owns_Gloves_Key(Plr, index) == false then
						temp.Locked_F.Visible = true
					else
						TS:Create(display:WaitForChild("LeftHandM").PrimaryPart, TweenInfo.new(4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true, 0), {CFrame = display:WaitForChild("LeftHandM").PrimaryPart.CFrame * CFrame.Angles(0,math.rad(180),0)}):Play() -- * leftSpinDirection display:WaitForChild("LeftHandM").PrimaryPart.CFrame
						TS:Create(display:WaitForChild("RightHandM").PrimaryPart, TweenInfo.new(4, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true, 0), {CFrame =  display:WaitForChild("RightHandM").PrimaryPart.CFrame * CFrame.Angles(0,math.rad(-180),0)}):Play() -- * rightSpinDirection
					end
					
				end

				temp.VF.CurrentCamera = Viewport_Camera
				display.Parent = temp.VF.WorldModel
				temp.VF.WorldModel:PivotTo(CFrame.new(0,0,0)) -- * CFrame.Angles(math.rad(180),0,0)
				Viewport_Camera.Parent = temp.VF
				Viewport_Camera.CFrame = CFrame.new(0, -0.15, 1.6)
			end

			--// check if owns if not make the locked frame visible

			table.insert(Cons, temp.Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false)then
					Debounce_C = true
					if(Click_SE ~= nil)then
						Click_SE:Play()
					end
					TS:Create(temp, Tween_Click, {Size = multiUdim2(Og_Size, 0.9)}):Play()

					--// check if owns 
					--Owned_Gloves_V = PD:WaitForChild("Owned Gloves")
					if (Clothing_Mod.Player_Owns_Gloves_Key(Plr, index) == true and Clothing_Mod.Get_Player_Current_Gloves(Plr) ~= index) then

						local result = Sending_RF.Avatar_Clothing_Request:InvokeServer(equipment_type, index)

						if result == true then
							Sound_Effect_Mod.Play_Voice_Over("New_Look")

							for s = 1, #Equipment_F.Main_Data_F.Tabs_F:GetChildren() do
								local TMP = Equipment_F.Main_Data_F.Tabs_F:GetChildren()[s]
								if(TMP ~= nil and TMP:IsA("Frame"))then
									TMP.Frame.UIStroke.Color = Color3.fromRGB(35, 244, 68)
								end
							end
							task.wait()
							temp.UIStroke.Color = Color3.fromRGB(244, 134, 0)
						end
					end
					-- if owns fire remote to server to check serverside if owns and process the equip


					task.wait(.2)
					Debounce_C = false
				end
			end))

			X += 0.3
			if X >= 1 then
				X = 0.15
				Y += 0.5
			end
			task.wait()
		end

		local currentequipped = Clothing_Mod.Get_Player_Current_Gloves(Plr)

		if (Equipment_F.Main_Data_F.Tabs_F:FindFirstChild(currentequipped)) then
			Equipment_F.Main_Data_F.Tabs_F:FindFirstChild(currentequipped).Frame.UIStroke.Color = Color3.fromRGB(244, 134, 0)
		end

	elseif (equipment_type == "Shorts") then
		local c = 0
		for index, value in pairs(Shorts_Data) do
			c += 1

			local temp = Equipment_F.Main_Data_F.TMP_Tab:Clone()
			temp.Parent = Equipment_F.Main_Data_F.Tabs_F
			temp.LayoutOrder = c
			temp.Name = index
			temp = temp.Frame
			temp.Name_F.Name_Txt.Text = value
			--temp.Parent = Equipment_F.Main_Data_F.Tabs_F
			--temp.Position = UDim2.new(X,0,Y,0)
			temp.Visible = true

			--// load viewport stuff 
			local Og_Size = temp.Size
			local display = game.ReplicatedStorage.Clothing_F.Shorts_F:FindFirstChild(value):Clone()
			local Viewport_Camera = Instance.new("Camera")
			if (display:FindFirstChild("LowerTorso")) then
				display.PrimaryPart = display:FindFirstChild("LowerTorso")
			end
			display:PivotTo(CFrame.new(0,0,0))
			temp.VF.CurrentCamera = Viewport_Camera
			display.Parent = temp.VF.WorldModel
			temp.VF.WorldModel:PivotTo(CFrame.new(0,0,0)) -- * CFrame.Angles(math.rad(180),0,0)
			Viewport_Camera.Parent = temp.VF
			Viewport_Camera.CFrame = CFrame.new(0,-0.2,2)


			local owns = Clothing_Mod.Player_Owns_Shorts_Key(Plr, index)
			if owns == false then
				temp.Locked_F.Visible = true
			end

			--// check if owns if not make the locked frame visible

			table.insert(Cons, temp.Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false)then
					Debounce_C = true
					if(Click_SE ~= nil)then
						Click_SE:Play()
					end
					TS:Create(temp, Tween_Click, {Size = multiUdim2(Og_Size, 0.9)}):Play()

					--// check if owns 
					--Owned_Gloves_V = PD:WaitForChild("Owned Gloves")
					if (owns == true and Clothing_Mod.Get_Player_Current_Shorts(Plr) ~= index) then

						local result = Sending_RF.Avatar_Clothing_Request:InvokeServer(equipment_type, index)

						if result == true then
							for s = 1, #Equipment_F.Main_Data_F.Tabs_F:GetChildren() do
								local TMP = Equipment_F.Main_Data_F.Tabs_F:GetChildren()[s]
								if(TMP ~= nil and TMP:IsA("Frame"))then
									TMP.Frame.UIStroke.Color = Color3.fromRGB(35, 244, 68)
								end
							end
							task.wait()
							temp.UIStroke.Color = Color3.fromRGB(244, 134, 0)
						end
					end
					-- if owns fire remote to server to check serverside if owns and process the equip


					task.wait(.2)
					Debounce_C = false
				end
			end))

			X += 0.3
			if X >= 1 then
				X = 0.15
				Y += 0.5
			end
			task.wait()
		end

		local currentequipped = Clothing_Mod.Get_Player_Current_Shorts(Plr)

		if (Equipment_F.Main_Data_F.Tabs_F:FindFirstChild(currentequipped)) then
			Equipment_F.Main_Data_F.Tabs_F:FindFirstChild(currentequipped).Frame.UIStroke.Color = Color3.fromRGB(244, 134, 0)
		end
	end


end

--// Combinations Handler

local function Update_Strike_Icon(Img, Is_Punch)
	if(Img ~= nil)then
		local Icon = "rbxassetid://79720394914031"
		if(Is_Punch == false)then
			Icon = "rbxassetid://136568604314712"
		end

		Img.Image = Icon
	end
end

local function Load_Combination()
	--[[
	    * Handles most of the stuff in select frame
		* Loads Combinations on the Combination Select Frame
		* Will check to see if they own move
		* Handle equip and saving 
		* Pressing close will tween the Main_Data_F back to the center and close the select frame
	]]--

	--// Clear Old Combinations
	local Tabs_F = Combination_Select_F.Action_Select_F.Action_Data_F.Tabs_F:GetChildren()
	if #Tabs_F > 0 then
		for t = 1, #Tabs_F do
			local TMP = Tabs_F[t]
			if(TMP ~= nil and TMP:IsA("Frame"))then
				TMP:Destroy()
			end
		end
		--	if (Combination_Select_F.Animation_Preview_F.VF:FindFirstChildOfClass("Camera")) then
		for _, tracks in pairs(Combination_Select_F.Animation_Preview_F.VF.WM.Model.Humanoid:FindFirstChild("Animator"):GetPlayingAnimationTracks()) do
			tracks:Stop() 
			tracks:Destroy()
		end
		--Combination_Select_F.Animation_Preview_F.VF:FindFirstChildOfClass("Camera"):Destroy()
		--Combination_Select_F.Animation_Preview_F.VF.WM:FindFirstChildOfClass("Model"):Destroy()
		--end		
		Disconnect_Cons()
	end

	--// Load New Combinations
	if(Selected_Combo ~= nil)then
		local Y = 0.125 -- 0.25 
		local viewportCamera
		local AnimID
		local track

		local newModelCharacter = Combination_Select_F.Animation_Preview_F.VF.WM.Model
		--newModelCharacter.PrimaryPart = newModelCharacter.HumanoidRootPart
		--newModelCharacter:PivotTo(CFrame.new(0,0,0))

		if (Selected_Combo ~= nil and string.match(Selected_Combo, "Strike_Combo") ~= nil) then
			for key, value in pairs(Combination_Data) do
				if (value)then -- free
					local temp = Combination_Select_F.Action_Select_F.Action_Data_F.Tab_TMP:Clone()
					temp.Name = value["Name"]
					temp.Strike_Name_Txt.Text = value["Name"]
					temp.Parent = Combination_Select_F.Action_Select_F.Action_Data_F.Tabs_F
					temp.Position = UDim2.new(0.5,-2,Y,0)
					temp.Visible = true
					
					table.insert(Cons, temp.Selected.MouseButton1Click:Connect(function()
						--// clear old character viewport
						if Debounce_T == false then
							Debounce_T = true

							if (Animation_Mod.Player_Owns_Strike_Key(Plr, key) == true or value["Price"] == 0) then
								Combination_Select_F.Animation_Preview_F.Locked_F.Visible = false

								if (AnimID ~= nil) then
									for _, tracks in pairs(newModelCharacter.Humanoid:FindFirstChild("Animator"):GetPlayingAnimationTracks()) do
										tracks:Stop() 
										tracks:Destroy()
									end
									AnimID:Destroy()
								end		

								--// play animation
								AnimID = Instance.new("Animation")
								AnimID.AnimationId = "rbxassetid://"..tostring(value["ID"])
								track = newModelCharacter.Humanoid:FindFirstChild("Animator"):LoadAnimation(AnimID)
								track.Looped = true
								track:Play()
								track:AdjustSpeed(0.5)

								Selected_Action = key
								
							elseif (Animation_Mod.Player_Owns_Strike_Key(Plr, key) == false or value["Price"] ~= 0) then

								Combination_Select_F.Animation_Preview_F.Locked_F.Visible = true
								Combination_Select_F.Animation_Preview_F.Locked_F.Combo_Name_Txt.Text = value["Name"]

								if (value["Price"] == -1) then
									local Txt = " This Move is Currently Locked! Unlock it via Achievement!"
									Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
									Combination_Select_F.Animation_Preview_F.Locked_F.Price_F.Visible = false
								elseif (value["Price"] > 0) then
									Combination_Select_F.Animation_Preview_F.Locked_F.Price_F.Visible = true
									Combination_Select_F.Animation_Preview_F.Locked_F.Price_F.Price_Txt = value["Price"]
								end

							end

							task.wait(.5)
							Debounce_T = false
						end


					end))

					Y += 0.25
				end
			end
		elseif (Selected_Combo ~= nil and string.match(Selected_Combo, "Submission_Takedown") ~= nil) then
			if (Selected_Strike ~= nil and string.match(Selected_Strike, "Submission") ~= nil) then
				for key, value in pairs(Submission_Data) do
					if (value) then -- free value["Price"] == 0
						local temp = Combination_Select_F.Action_Select_F.Action_Data_F.Tab_TMP:Clone()
						temp.Name = value["Name"]
						temp.Strike_Name_Txt.Text = value["Name"]
						temp.Parent = Combination_Select_F.Action_Select_F.Action_Data_F.Tabs_F
						temp.Position = UDim2.new(0.5,-2,Y,0)
						temp.Visible = true
						
						table.insert(Cons, temp.Selected.MouseButton1Click:Connect(function()
							--// clear old character viewport
							if Debounce_T == false then
								Debounce_T = true
								
								if (Animation_Mod.Player_Owns_Submission_Key(Plr, key) == true or value["Price"] == 0) then
									Combination_Select_F.Animation_Preview_F.Locked_F.Visible = false

									if (AnimID ~= nil) then
										for _, tracks in pairs(newModelCharacter.Humanoid:FindFirstChild("Animator"):GetPlayingAnimationTracks()) do
											tracks:Stop() 
											tracks:Destroy()
										end
										AnimID:Destroy()
										--viewportCamera:Destroy()
										--Combination_Select_F.Animation_Preview_F.VF.WM:FindFirstChildOfClass("Model"):Destroy()
									end		

									--// play animation
									AnimID = Instance.new("Animation")
									AnimID.AnimationId = "rbxassetid://"..tostring(value["Submission ID"])
									track = newModelCharacter.Humanoid:FindFirstChild("Animator"):LoadAnimation(AnimID)
									track.Looped = true
									track:Play()
									track:AdjustSpeed(0)

									Selected_Action = key
								elseif (Animation_Mod.Player_Owns_Submission_Key(Plr, key) == false or value["Price"] ~= 0) then
									
									Combination_Select_F.Animation_Preview_F.Locked_F.Visible = true
									Combination_Select_F.Animation_Preview_F.Locked_F.Combo_Name_Txt.Text = value["Name"]

									if (value["Price"] == -1) then
										local Txt = " This Move is Currently Locked! Unlock it via Achievement!"
										Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
										Combination_Select_F.Animation_Preview_F.Locked_F.Price_F.Visible = false
									elseif (value["Price"] > 0) then
										Combination_Select_F.Animation_Preview_F.Locked_F.Price_F.Visible = true
										Combination_Select_F.Animation_Preview_F.Locked_F.Price_F.Price_Txt = value["Price"]
									end
									
								end
								
								task.wait(.5)
								Debounce_T = false
							end
	

						end))

						Y += 0.25

					end
				end
			elseif (Selected_Strike ~= nil and string.match(Selected_Strike, "Takedown") ~= nil) then
				for key, value in pairs(Takedown_Data) do
					if (value)then -- free
						
						local temp = Combination_Select_F.Action_Select_F.Action_Data_F.Tab_TMP:Clone()
						temp.Name = value["Name"]
						temp.Strike_Name_Txt.Text = value["Name"]
						temp.Parent = Combination_Select_F.Action_Select_F.Action_Data_F.Tabs_F
						temp.Position = UDim2.new(0.5,-2,Y,0)
						temp.Visible = true


						table.insert(Cons, temp.Selected.MouseButton1Click:Connect(function()
							
							if Debounce_T == false then
								Debounce_T = true

								if (Animation_Mod.Player_Owns_Submission_Key(Plr, key) == true or value["Price"] == 0) then
									Combination_Select_F.Animation_Preview_F.Locked_F.Visible = false

									if (AnimID ~= nil) then
										for _, tracks in pairs(newModelCharacter.Humanoid:FindFirstChild("Animator"):GetPlayingAnimationTracks()) do
											tracks:Stop() 
											tracks:Destroy()
										end
										AnimID:Destroy()
									end		

									--// play animation
									AnimID = Instance.new("Animation")
									AnimID.AnimationId = "rbxassetid://"..tostring(value["Takedown ID"])
									track = newModelCharacter.Humanoid:FindFirstChild("Animator"):LoadAnimation(AnimID)
									track.Looped = true
									track:Play()
									track:AdjustSpeed(0)

									Selected_Action = key
								elseif (Animation_Mod.Player_Owns_Submission_Key(Plr, key) == false or value["Price"] ~= 0) then

									Combination_Select_F.Animation_Preview_F.Locked_F.Visible = true
									Combination_Select_F.Animation_Preview_F.Locked_F.Combo_Name_Txt.Text = value["Name"]

									if (value["Price"] == -1) then
										local Txt = " This Move is Currently Locked! Unlock it via Achievement!"
										Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
										Combination_Select_F.Animation_Preview_F.Locked_F.Price_F.Visible = false
									elseif (value["Price"] > 0) then
										Combination_Select_F.Animation_Preview_F.Locked_F.Price_F.Visible = true
										Combination_Select_F.Animation_Preview_F.Locked_F.Price_F.Price_Txt = value["Price"]
									end

								end

								task.wait(.5)
								Debounce_T = false
							end

						end))


						Y += 0.25

					end
				end
			end
		end


	end

	--// Equip / Close Functions
	table.insert(Cons, Combination_Select_F.Equip_B.MouseButton1Click:Connect(function()
		if(Click_SE ~= nil)then
			Click_SE:Play()
		end

		if (Selected_Action ~= nil) then
			local result = Sending_RF.Combo_Action_Request:InvokeServer(Selected_Combo, Selected_Strike, Selected_Action) -- ("Strike Combo 1", "Strike_1", "F") - ex if return true then player owns it and sucessfully equipped
			if (result == true) then
				if Selected_Strike == "Submission_F" then
					Combination_F[Selected_Combo][Selected_Strike].Action_Name_Txt.Text = Submission_Data[Selected_Action]["Name"]
				elseif Selected_Strike == "Takedown_F" then
					Combination_F[Selected_Combo][Selected_Strike].Action_Name_Txt.Text = Takedown_Data[Selected_Action]["Name"]
				else
					Combination_F[Selected_Combo][Selected_Strike].Action_Name_Txt.Text = Combination_Data[Selected_Action]["Name"]
					
					local Img = Combination_F[Selected_Combo][Selected_Strike].Icon_Img
					local Is_Punch = Combination_Data[Selected_Action]["Punch"]
					Update_Strike_Icon(Img, Is_Punch)
				end
			end
		end

		if (Selected_Combo ~= nil and Selected_Strike ~= nil) then
			Combination_F[Selected_Combo][Selected_Strike].Action_Name_Txt.TextColor3 = Color3.fromRGB(255,255,255)
		end
		Combination_Select_F.Visible = false
		Selected_Combo = nil
		Selected_Strike = nil
		Selected_Action = nil
		InitialPositions()
	end))

	table.insert(Cons, Combination_Select_F.Close_B.MouseButton1Click:Connect(function()
		if(Click_SE ~= nil)then
			Click_SE:Play()
		end

		Combination_Select_F.Visible = false
		if (Selected_Combo ~= nil and Selected_Strike ~= nil) then
			Combination_F[Selected_Combo][Selected_Strike].Action_Name_Txt.TextColor3 = Color3.fromRGB(255,255,255)
		end

		Selected_Combo = nil
		Selected_Strike = nil
		Selected_Action = nil
		InitialPositions()
	end))



end

local function Set_Up_Combinations()
	--[[
		* Setup all the strikes 
		* Loop through all the Combination Slots and will go through every strike setup them up with selected Move
	]]--

	local function Reset_Selected_Strike_Texts()
		local function Set_Action_Txt(F)
			local Action_Name_Txt = F:FindFirstChild("Action_Name_Txt")
			if(Action_Name_Txt ~= nil)then
				Action_Name_Txt.TextColor3 = Color3.new(1, 1, 1)
			end
		end
		
		local function Reset_Frame(Combo_F)
			local All_C = Combo_F:GetChildren()
			for i = 1, #All_C do
				local F = All_C[i]
				if(F ~= nil and string.match(F.Name, "Strike_") ~= nil)then
					Set_Action_Txt(F)
				end
			end
			
		end
		Reset_Frame(Combination_F:FindFirstChild("Strike_Combo_1_F"))
		Reset_Frame(Combination_F:FindFirstChild("Strike_Combo_2_F"))
		Reset_Frame(Combination_F:FindFirstChild("Strike_Combo_3_F"))
		Reset_Frame(Combination_F:FindFirstChild("Strike_Combo_4_F"))
		
		local Sub_Take_F = Combination_F:FindFirstChild("Submission_Takedown_F")
		Set_Action_Txt(Sub_Take_F:FindFirstChild("Submission_F"))
		Set_Action_Txt(Sub_Take_F:FindFirstChild("Takedown_F"))
	end

	local Frames = Combination_F:GetChildren()

	for i = 1, #Frames do
		local Combo = Frames[i]
		if(Combo ~= nil and Combo:IsA("Frame") and string.match(Combo.Name, "Strike_Combo") ~= nil)then
			local Combo_Value = PD:FindFirstChild("Strike Combo "..Combo.Name:match("%d+"))
			local StrikeCombos = Combo_Value.Value:split(",")
			for v = 1, #Combo:GetChildren() do
				local Strike = Combo:GetChildren()[v]
				if(Strike ~= nil and Strike:IsA("ImageLabel") and string.match(Strike.Name, "Strike_") ~= nil) then
					local AnimData = Animation_Mod.Get_Strike_Combo_Data(StrikeCombos[tonumber(Strike.Name:match("%d+"))])
					Strike.Action_Name_Txt.Text = AnimData["Name"]
					Update_Strike_Icon(Strike:FindFirstChild("Icon_Img"), AnimData['Punch'])

					Strike.Selected.MouseButton1Click:Connect(function()
						if (Debounce_S == false) then
							Debounce_S = true
							--if Combination_Select_F.Visible == false then
							MoveElementToInitialPosition()
							task.wait(.7)
							Combination_Select_F.Visible = true
							if (Selected_Strike ~= nil and Selected_Combo ~= nil) then
								Combination_F:FindFirstChild(Selected_Combo):FindFirstChild(Selected_Strike).Action_Name_Txt.TextColor3 = Color3.fromRGB(255,255,255)
							end

							Selected_Strike = Strike.Name
							Selected_Combo = Combo.Name
							Load_Combination()
							Reset_Selected_Strike_Texts()
							TS:Create(Strike.Action_Name_Txt, TweenInfo.new(.1, Enum.EasingStyle.Back, Enum.EasingDirection.InOut), {TextColor3 = Color3.fromRGB(20, 255, 8)}):Play()

							--end
							task.wait(.2)
							Debounce_S = false
						end

					end)
				end
			end

			--// handle reset sequence 
			Button_Handle(Combo.Reset_F.Reset_B, function()
				if (Debounce_R == false) then
					Debounce_R = true
					Combo.Strike_1.Action_Name_Txt.Text = Combination_Data[Default_Strikes["Strike Combo "..Combo.Name:match("%d+")][1]]["Name"]
					Combo.Strike_2.Action_Name_Txt.Text = Combination_Data[Default_Strikes["Strike Combo "..Combo.Name:match("%d+")][2]]["Name"]
					Combo.Strike_3.Action_Name_Txt.Text = Combination_Data[Default_Strikes["Strike Combo "..Combo.Name:match("%d+")][3]]["Name"]
					Channels_F.Client_Server_F.Events.Reset_Sequence:FireServer(Combo.Name, Default_Strikes["Strike Combo "..Combo.Name:match("%d+")])
					task.wait(1)
					Debounce_R = false
				end
			end)

		end
	end

	--// Submission / TakeDown 

	Combination_F.Submission_Takedown_F.Submission_F.Action_Name_Txt.Text = Submission_Data[Submission_V.Value]['Name']
	Combination_F.Submission_Takedown_F.Submission_F.Selected.MouseButton1Click:Connect(function()
		if (Debounce_S == false) then
			Debounce_S = true
			--if Combination_Select_F.Visible == false then
			MoveElementToInitialPosition()
			task.wait(.7)
			Combination_Select_F.Visible = true
			Selected_Strike = "Submission_F"
			Selected_Combo = "Submission_Takedown_F"
			Load_Combination()
			--end
			task.wait(.2)
			Debounce_S = false
		end

	end)

	Combination_F.Submission_Takedown_F.Takedown_F.Action_Name_Txt.Text = Takedown_Data[Takedown_V.Value]['Name']
	Combination_F.Submission_Takedown_F.Takedown_F.Selected.MouseButton1Click:Connect(function()
		if (Debounce_S == false) then
			Debounce_S = true
			--if Combination_Select_F.Visible == false then
			MoveElementToInitialPosition()
			task.wait(.7)
			Combination_Select_F.Visible = true
			Selected_Strike = "Takedown_F"
			Selected_Combo = "Submission_Takedown_F"
			Load_Combination()
			--end
			task.wait(.2)
			Debounce_S = false
		end

	end)

	Button_Handle(Combination_F.Submission_Takedown_F.Reset_F.Reset_B, function()
		if (Debounce_R == false) then
			Debounce_R = true
			Combination_F.Submission_Takedown_F.Submission_F.Action_Name_Txt.Text = Submission_Data["A"]["Name"]
			Combination_F.Submission_Takedown_F.Takedown_F.Action_Name_Txt.Text = Takedown_Data["A"]["Name"]
			Channels_F.Client_Server_F.Events.Reset_Sequence:FireServer("Submission_Takedown")
			task.wait(1)
			Debounce_R = false
		end
	end)

end

--// Appearance Handler

local function Load_Appearance()
	--// load current data if any country flag, bio, skin tone, etc...
	local country, img = Country_Mod.Get_Player_Country_Data(Plr)
	local Skin_Data = Skin_Tone_Mod.Get_Skin_Tone_Data()
	Appearance_F.Country_F.Country_Flag_Img.Image = img
	Appearance_F.Country_F.Country_Txt.Text = country
	Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text = Bio_V.Value or ""

	Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
	Appearance_F.Drop_Down_Data_F.Size = UDim2.new(0.375, 0,0, 0)
	Appearance_F.Drop_Down_Data_F.Visible = false

	if (SkinTone_V.Value) then
		local Str_Data = string.split(SkinTone_V.Value, ",")
		local R,G,B = tonumber(Str_Data[1]), tonumber(Str_Data[2]), tonumber(Str_Data[3])
		for name, color in pairs(Skin_Data) do
			local r,g,b
			r = math.round(color.R * 255)
			g = math.round(color.G * 255)
			b = math.round(color.B * 255)
			if (r == R and g == G and b == B) then
				Appearance_F.Skin_Tone_F.Skin_Tone_Txt.Text = name
				Appearance_F.Skin_Tone_F.BackgroundColor3 = Color3.fromRGB(R,G,B)
				break
			end
		end
	end

	local ogText = Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text
	table.insert(Cons,Appearance_F.Bio_F.Data_F.Data_Box_Txt:GetPropertyChangedSignal("Text"):Connect(function()
		local text = string.len(Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text)
		if (Can_Edit == true) then
			if (text >= 25) then
				Can_Edit = false
				ogText = Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text
				Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text = ogText
				task.wait()
			end
		elseif (Can_Edit == false) then
			if (text < 25) then
				Can_Edit = true
			elseif (text >= 25) then
				Appearance_F.Bio_F.Data_F.Data_Box_Txt.Text = ogText
				task.wait()
			end
		end
	end))

	--// setup dropdown menus

	Button_Handle(Appearance_F.Country_F.Dropdown_B, function()
		if (Toggle_DropDown == false) then
			Toggle_DropDown = true
			Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
			Appearance_F.Drop_Down_Data_F.Position = UDim2.new(1,0,0.225,0)
			Appearance_F.Drop_Down_Data_F.Size = UDim2.new(0.375, 0,0, 0)
			Appearance_F.Drop_Down_Data_F.Visible = true
			--// load all countrys and bind them
			local Y = 0 -- 0.3

			local keys = {}
			for k in pairs(Country_Data) do
				table.insert(keys, k)
			end

			table.sort(keys)

			for _, country_name in pairs(keys) do
				local image = Country_Data[country_name]
				local TMP = Appearance_F.Drop_Down_Data_F.TMP_Tab:Clone()
				TMP.Parent = Equipment_F.Main_Data_F.Tabs_F
				TMP.Name = country_name
				--TMP = TMP.Frame
				TMP.Data_Txt.Text = country_name
				TMP.Country_Flag_Img.Image = image
				TMP.Position = UDim2.new(0,0,Y,0)
				TMP.Parent = Appearance_F.Drop_Down_Data_F.Tabs_F
				TMP.Visible = true
				Y += 0.3

				table.insert(Cons, TMP.Selected.MouseButton1Click:Connect(function()
					Toggle_DropDown = false
					TS:Create(Appearance_F.Country_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Rotation = 0}):Play()
					Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375, 0,0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
					task.wait(.2)
					Appearance_F.Drop_Down_Data_F.Visible = false
					Appearance_F.Country_F.Country_Flag_Img.Image = image
					Appearance_F.Country_F.Country_Txt.Text = country_name
				end))

			end
			Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375, 0,0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
			TS:Create(Appearance_F.Country_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Rotation = 180}):Play()
		elseif (Toggle_DropDown == true and Appearance_F.Country_F.Dropdown_B.Rotation == 180) then
			Toggle_DropDown = false
			TS:Create(Appearance_F.Country_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Rotation = 0}):Play()
			Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375, 0,0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
			task.wait(.2)
			Appearance_F.Drop_Down_Data_F.Visible = false
			Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
		end
	end)

	Button_Handle(Appearance_F.Skin_Tone_F.Dropdown_B, function()
		if (Toggle_DropDown == false) then
			Toggle_DropDown = true
			Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
			Appearance_F.Drop_Down_Data_F.Position = UDim2.new(1,0,0.475,0)
			Appearance_F.Drop_Down_Data_F.Size = UDim2.new(0.375, 0,0, 0)
			Appearance_F.Drop_Down_Data_F.Visible = true
			--// load all countrys and bind them
			local Y = 0 -- 0.3
			for color_name, color in pairs(Skin_Data) do
				local TMP = Appearance_F.Drop_Down_Data_F.TMP_Tab:Clone()
				TMP.Parent = Equipment_F.Main_Data_F.Tabs_F
				--TMP = TMP.Frame
				TMP.Name = color_name
				TMP.Data_Txt.Text = color_name
				TMP.BackgroundColor3 = color
				TMP.Country_Flag_Img.Visible = false
				TMP.Position = UDim2.new(0,0,Y,0)
				TMP.Parent = Appearance_F.Drop_Down_Data_F.Tabs_F
				TMP.Visible = true
				Y += 0.3

				table.insert(Cons, TMP.Selected.MouseButton1Click:Connect(function()
					Toggle_DropDown = false
					TS:Create(Appearance_F.Skin_Tone_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Rotation = 0}):Play()
					Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375, 0,0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
					task.wait(.2)
					Appearance_F.Drop_Down_Data_F.Visible = false
					Appearance_F.Skin_Tone_F.BackgroundColor3 = color
					Appearance_F.Skin_Tone_F.Skin_Tone_Txt.Text = color_name
				end))

			end
			Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375, 0,0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
			TS:Create(Appearance_F.Skin_Tone_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Rotation = 180}):Play()
		elseif (Toggle_DropDown == true and Appearance_F.Skin_Tone_F.Dropdown_B.Rotation == 180) then
			Toggle_DropDown = false
			TS:Create(Appearance_F.Skin_Tone_F.Dropdown_B, TweenInfo.new(.2,Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Rotation = 0}):Play()
			Appearance_F.Drop_Down_Data_F:TweenSize(UDim2.new(0.375, 0,0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, .2, true, nil)
			task.wait(.2)
			Appearance_F.Drop_Down_Data_F.Visible = false
			Appearance_F.Drop_Down_Data_F.Tabs_F:ClearAllChildren()
		end
	end)

end

--// Toggle

local function Set_Up_Equipments()
	
	local UIGridLayout = Instance.new("UIGridLayout")
	UIGridLayout.Parent = Equipment_F.Main_Data_F.Tabs_F
	UIGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIGridLayout.CellSize = UDim2.new(0.318, 0, 0.5, 0)
	UIGridLayout.CellPadding = UDim2.new(0.02, 0, 0.04, 0)

	Load_Equipment("Gloves")

	Button_Handle(Equipment_F["Gloves Tab"], function()
		Load_Equipment("Gloves")
	end)

	Button_Handle(Equipment_F["Shorts Tab"], function()
		Load_Equipment("Shorts")
	end)

	--// Top Bar Buttons

	Button_Handle(Top_Change_Buttons_F["equipment tab"], function()
		Combination_F.Visible = false
		Equipment_F.Visible = true
		Appearance_F.Visible = false
		Combination_Select_F.Visible = false
		InitialPositions()
		Save_Bio()
	end)

	Button_Handle(Top_Change_Buttons_F["combos tab"], function()
		Combination_F.Visible = true
		Appearance_F.Visible = false
		Equipment_F.Visible = false
		Combination_Select_F.Visible = false
		InitialPositions()
		Save_Bio()
	end)

	Button_Handle(Top_Change_Buttons_F["appearance tab"], function()
		Combination_F.Visible = false
		Equipment_F.Visible = false
		Combination_Select_F.Visible = false
		Appearance_F.Visible = true
		InitialPositions()
		Load_Appearance()
	end)

	Button_Handle(Exit_B, function()
		--// request to server to change any info changed
		Remove_UI()
	end)


end

local function Display_UI(open)
	if Core_UI.Visible == false then
		local function Set_Init_Cam_Effects()
			Disconnect_Cons()
			Core_UI.Visible = false
			Core_UI.Position = UDim2.new(0.5, 0, 0.575, 0)

			local Inv_Blurr = game.Lighting:FindFirstChild("Inventory_Blurr")
			if(Inv_Blurr ~= nil)then
				Inv_Blurr:Destroy()
			end
			Cam.FieldOfView = 70

			Core_UI.Visible = true
			Core_UI:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
			TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

			local Blur = Instance.new("BlurEffect", game.Lighting)
			Blur.Name = "Inventory_Blurr"
			Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false, true)
			Bindable_Events_F:WaitForChild("Toggle_Tutorial_Display"):Fire(false)
		end
		Set_Init_Cam_Effects()

		local function Toggle_Frame_Change_Buttons(Is_Visible)
			Top_Change_Buttons_F.Visible = Is_Visible
		end
		Toggle_Frame_Change_Buttons(true)
		Title_Txt.Text = "AVATAR"

		Combination_Select_F.Visible = false
		InitialPositions()

		if (open == "Avatar") then
			Appearance_F.Visible = false
			Combination_F.Visible = false
			Equipment_F.Visible = true
			Load_Equipment("Gloves")
		elseif (open == "Combos") then
			Equipment_F.Visible = false
			Appearance_F.Visible = false
			Combination_F.Visible = true
			
			Toggle_Frame_Change_Buttons(false)
			Title_Txt.Text = "COMBOS"
		elseif (open == "Appearance") then
			Combination_F.Visible = false
			Equipment_F.Visible = false
			Appearance_F.Visible = true
			Load_Appearance()
		end
	else
		Combination_Select_F.Visible = false
		Core_UI.Visible = false
	end
end

--// Startup

Set_Up_Combinations()
Set_Up_Equipments()


Bindable_Events_F:WaitForChild("Open_Combos").Event:Connect(function()
	if(Debounce_UI == false)then
		Display_UI("Combos")
	else
		Remove_UI()
	end
end)

Bindable_Events_F:WaitForChild("Open_Avatar").Event:Connect(function()
	if(Debounce_UI == false)then
		Display_UI("Avatar")
	else
		Remove_UI()
	end
end)

Bindable_Events_F:WaitForChild("Open_Appearance").Event:Connect(function()
	if(Debounce_UI == false)then
		Display_UI("Appearance")
	else
		Remove_UI()
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX268164F4196B4851B2FD704A87CD4810">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Main_F</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX76BBBA780BC04ED8A693860163D65318">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Combination_Select_F</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX51DAE05E82A149AB954AACC97DB05AEE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animation_Preview_F</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXBAE4F06E9A5C4E4C8F8CA101D7FCD15B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">VF</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBXEEE8C2806D394A84A29A42F7E912EA9A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">WM</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBXD44721B220B6427EAFA876A4DB90F083">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Model</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBX56948F753FA34D069A9A6126AD449E64">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Animate.client.lua</string>
												<string name="ScriptGuid">{ECCF3578-2EDC-4C6B-B1C8-BAAFD72FD8DE}</string>
												<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXF8AAF4DB3245413CA8AD79DE83D10C15">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Main_F_old</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX615536AD1ADE41A09C22D269FAE72A90">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Combination_Select_F</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX88EFE32B102B4CA18220A5FC612DC425">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animation_Preview_F</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBXEC4F406C084744A3A035F25A9B1C4FFA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<string name="Name">VF</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="Folder" referent="RBX5A461C1811FB46868C4C99ECC34D0043">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<string name="Name">WM</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="Folder" referent="RBX3D11E1BE461941FEA20B9601A533A5D5">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<string name="Name">Model</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
										<Item class="ModuleScript" referent="RBXA9671D9B2E9A4DAF97D5FCBBFE3D2EB9">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Animate.client.lua</string>
												<string name="ScriptGuid">{96CB464F-ABBF-4FC9-BC9E-9E6F54A8E6E4}</string>
												<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX20B6B7BD34684EFCA779422572ACC25E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Fight_Result_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX1F5CF6036457491EAF380BB6CA0B2A38">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Fight_Result_Handle.client.lua</string>
						<string name="ScriptGuid">{673368E6-5935-4A4E-A460-E63FCC948088}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")
local PD = Plr:WaitForChild("Player_Data")
local Elo_V = PD:WaitForChild("Elo")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Num_Str_Mod = require(Data_Mods_F:WaitForChild("Num_String_Mod"))
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Cam = game.Workspace.CurrentCamera

local Main_F = script.Parent.Main_F
local Top_Data_F = Main_F.Top_Data_F
local Main_Data_F = Main_F.Data_Results_F
local Elo_Progress_F = Main_F.Elo_Progress_F
local Exit_B = Main_F.Exit_B

local Debounce_UI = false
local Debounce_C = false
local Debounce_E = false

local Tween_Cam = TweenInfo.new(0.75, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local Player_Thumbnail_Data = {
	
}
local function Get_Player_Thumbnail(ID)
	if(Player_Thumbnail_Data[ID] ~= nil)then
		return Player_Thumbnail_Data[ID]
	else
		local Type = Enum.ThumbnailType.HeadShot
		local Size = Enum.ThumbnailSize.Size420x420
		
		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				Data = game.Players:GetUserThumbnailAsync(ID, Type, Size)
			end)
			
			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end
		
		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				Player_Thumbnail_Data[ID] = D
				return D
			end
		end
		
		return "rbxassetid://100127687172105"
	end
end

local function Toggle_UI(Show)
	local UIs = {"Fight_Teleport_UI", "Tool_Select_UI", "Side_Button_UI", "Player_List_UI"}
	for i = 1, #UIs do
		local UI = PG:FindFirstChild(UIs[i])
		if(UI ~= nil)then
			UI.Enabled = Show
		end
	end
end

local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.375, true, nil)
	
	wait(0.375)
	
	local Old_Blur = game.Lighting:FindFirstChild("Result_Blurr")
	if(Old_Blur ~= nil)then
		Old_Blur:Destroy()
	end
	
	if(Cam.FieldOfView == 40)then
		TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	end
	
	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true)
	Toggle_UI(true)
	Bindable_Events_F:WaitForChild("Toggle_Reset"):Fire(true)
	
	Debounce_C = false
	Debounce_E = false
	Debounce_UI = false
end

local function Display_UI(Fight_Data)
	local function Reset_Display()
		Disconnect_Cons()
		Cam.FieldOfView = 70
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 1.5, 0)
		
		local Old_Blur = game.Lighting:FindFirstChild("Result_Blurr")
		if(Old_Blur ~= nil)then
			Old_Blur:Destroy()
		end
		
		Toggle_UI(false)
	end
	Reset_Display()
	
	local function Update_Display_Data()
		local function Update_Top_Bar_Info()
			if string.len(Fight_Data['Winner']['DisplayName']) > 30 then
				Fight_Data['Winner']['DisplayName']  = "Bot"
			end
			if string.len(Fight_Data['Winner']['Name']) > 30 then
				Fight_Data['Winner']['Name']  = "Bot"
			end
			Top_Data_F.Winner_Data_F.Player_Name_Txt.Text = Fight_Data['Winner']['DisplayName'] 
			Top_Data_F.Winner_Data_F.Player_Display_Name_Txt.Text = Fight_Data['Winner']['Name'] 
			Top_Data_F.Winner_Data_F.Plr_Img_F.Plr_Img.Image = Get_Player_Thumbnail(Fight_Data['Winner']['ID'])
			
			if string.len(Fight_Data['Loser']['DisplayName']) > 30 then
				Fight_Data['Loser']['DisplayName']  = "Bot"
			end
			if string.len(Fight_Data['Loser']['Name']) > 30 then
				Fight_Data['Loser']['Name']  = "Bot"
			end
			Top_Data_F.Loser_Data_F.Player_Name_Txt.Text = Fight_Data['Loser']['DisplayName'] 
			Top_Data_F.Loser_Data_F.Player_Display_Name_Txt.Text = Fight_Data['Loser']['Name']
			Top_Data_F.Loser_Data_F.Plr_Img_F.Plr_Img.Image = Get_Player_Thumbnail(Fight_Data['Loser']['ID'])
			
			Top_Data_F.Score_Txt.Text = Fight_Data['Winner']['Wins'] .. " - " .. Fight_Data['Loser']['Wins']	
		end
		Update_Top_Bar_Info()
		
		local function Update_Main_Data()
			local function Update_Tab(Tab)
				local Key = string.gsub(Tab.Name, "_F", "")
				Key = string.gsub(Key, "_", " ")
				
				Tab.Winner_Data_Txt.Text = Fight_Data['Winner'][Key] .. "" or "0 / 0"
				Tab.Loser_Data_Txt.Text = Fight_Data['Loser'][Key] .. "" or "0 / 0"
			end 
			
			local Tabs = Main_Data_F:GetChildren()
			for i = 1, #Tabs do
				if(Tabs[i] ~= nil and Tabs[i]:IsA("Frame"))then
					Update_Tab(Tabs[i])
				end
			end
		end
		Update_Main_Data()
	end
	Update_Display_Data()
	
	local function Display_Elo_Data()
		local Current_Elo_Data = Elo_Mod.Get_Player_Rank_Data(Plr)
		local Next_Elo_Data = Elo_Mod.Get_Next_Rank_Data(Current_Elo_Data['Index'])
		local Tween_Prog_Bar = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 1)
		
		Elo_Progress_F.Current_Elo_F.Elo_Txt.Text = Num_Str_Mod.NumToString(Elo_V.Value) .. ""
		Elo_Progress_F.Current_Elo_F.Elo_Img.Image = Current_Elo_Data['Icon']
		Elo_Progress_F.Current_Elo_F.Elo_Img.ImageColor3 = Current_Elo_Data['Color']
		
		Elo_Progress_F.Next_Elo_F.Elo_Txt.Text = Num_Str_Mod.NumToString(Next_Elo_Data['Elo Range'].Min) .. ""
		Elo_Progress_F.Next_Elo_F.Elo_Img.Image = Next_Elo_Data['Icon']
		Elo_Progress_F.Next_Elo_F.Elo_Img.ImageColor3 = Next_Elo_Data['Color']
		
		Elo_Progress_F.Prog_Bar_F.Bar_F.UIGradient.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Next_Elo_Data['Color']),
			ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))
		}
		Elo_Progress_F.Prog_Bar_F.Bar_F.Size = UDim2.new(0, 0, 1, 0)
		
		local Dif = math.clamp(Elo_V.Value / Next_Elo_Data['Elo Range'].Min, 0, 1)
		TS:Create(Elo_Progress_F.Prog_Bar_F.Bar_F, Tween_Prog_Bar, {Size = UDim2.new(Dif, 0, 1, 0)}):Play()
		
	end
	Display_Elo_Data()
	
	local function Exit_Handle()
		local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
		local Hover_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Hover_SE")
		local Click_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Click_SE")
		Exit_B.Size = UDim2.new(0.075, 0, 0.1, 0)
		
		table.insert(Cons, Exit_B.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				if(Hover_SE ~= nil)then
					Hover_SE:Play()
				end
				
				Debounce_E = false
			end
		end))
		
		table.insert(Cons, Exit_B.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.05625, 0, 0.075, 0)}):Play()
				
				Remove_UI()
				
				wait(0.25)
				Debounce_C = false
			end
		end))	
		
		table.insert(Cons, UIS.InputBegan:Connect(function(input, GPE)
			if(Debounce_C == false and input.KeyCode == Enum.KeyCode.Space and 
				Bindable_RF:WaitForChild("Is_Chatbox_Typing"):Invoke() == false)then
				
				Debounce_C = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.05625, 0, 0.075, 0)}):Play()

				Remove_UI()

				wait(0.25)
				Debounce_C = false
			end
		end))	
	end
	Exit_Handle()
	
	local function Display_Main_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.4875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
		
		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Result_Blurr"
		
		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
		Sound_Effect_Mod.Play_Voice_Over("End_Of_Fight")
		
		Debounce_C = false
		Debounce_E = false
		Debounce_UI = true
	end
	Display_Main_UI()
	
	--Auto Remove after 10 Seconds
	for i = 1, 40 do
		wait(0.25)
		if(Debounce_UI == false)then
			return
		end
	end
	
	if(Debounce_UI == true)then
		Remove_UI()
	end
end

Receiving_Events_F:WaitForChild("Fight_Data_Result").OnClientEvent:Connect(function(Fight_Data)
	if not Fight_Data then
		warn("FightData not present")
	end
	
	wait(2)
	if(Debounce_UI == false)then
		Display_UI(Fight_Data)
	end
end)

Bindable_Events_F:WaitForChild("Close_Fight_Result").Event:Connect(function()
	if(Debounce_UI)then
		Remove_UI()
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXF3D47404147D4F418EBA5792E65BC23A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">White_Crate_Fade_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXF6490CBBC4304D628E8D4ADB40613B08">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Crate_White_Fade_Client.client.lua</string>
						<string name="ScriptGuid">{6A4812DB-A12F-469D-B5FC-96D5530CF264}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")

local Main_F = script.Parent.Main_F

local function Reset_UI(T)
	Main_F.Visible = false
	Main_F.Size = UDim2.new(1, 0, 1, 0)
	
	for i = 1, #T do
		if(T[i] ~= nil)then
			T[i].BackgroundTransparency = 1
		end
	end
end

local function Show_UI_Effects()
	local T = Main_F:GetChildren()
	Reset_UI(T)
	Main_F.Visible = true
	
	local function Show_White_Fade()
		local Tween_In = TweenInfo.new(0.075, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
		
		for i = 1, #T do
			if(T[i] ~= nil)then
				TS:Create(T[i], Tween_In, {BackgroundTransparency = 0}):Play()
			end
		end
		
		wait(0.075)
	end
	Show_White_Fade()
	
	local function Remove_Fade()
		local Tween_Remove = TweenInfo.new(0.075, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
		Main_F:TweenSize(UDim2.new(2, 0, 2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.075, true, nil)
		
		for i = 1, #T do
			if(T[i] ~= nil)then
				TS:Create(T[i], Tween_Remove, {BackgroundTransparency = 1}):Play()
			end
		end
		
		wait(0.075)
	end
	Remove_Fade()
	
	Reset_UI(T)
end

local function Set_Frame_Colors(Col)
	local All_T = Main_F:GetChildren()
	for i = 1, #All_T do
		local T = All_T[i]
		if(T ~= nil and T:IsA("Frame"))then
			T.BackgroundColor3 = Col
		end
	end
end

Bindable_Events_F:WaitForChild("Show_White_Fade").Event:Connect(function(Col)
	Set_Frame_Colors(Col)
	Show_UI_Effects()
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX7934744E121F470D81BE35C37A86DA01">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Elo_Limit_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXDCCB223E0C654A95A5E0FE1EE349F9A0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Elo_Cover_Handle.client.lua</string>
						<string name="ScriptGuid">{FA3569AC-FC32-4381-B840-6DFF2ECF0C02}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))

local Main_F = script.Parent.Main_F
local Main_Tab_F = Main_F.Main_Tab_F
local Rank_Data_F = Main_Tab_F.Rank_Data_F
local Your_Elo_F = Rank_Data_F.Your_Elo_F
local Your_Elo_Img = Your_Elo_F.Elo_Img
local Other_Elo_F = Rank_Data_F.Current_Elo_F
local Other_Elo_Img = Other_Elo_F.Elo_Img

local Debounce_UI = false

local Player_Thumbnail_Data = {

}
local function Get_Player_Thumbnail(ID)
	if(Player_Thumbnail_Data[ID] ~= nil)then
		return Player_Thumbnail_Data[ID]
	else
		local Type = Enum.ThumbnailType.HeadShot
		local Size = Enum.ThumbnailSize.Size420x420

		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				Data = game.Players:GetUserThumbnailAsync(ID, Type, Size)
			end)

			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end

		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				Player_Thumbnail_Data[ID] = D
				return D
			end
		end

		return "rbxassetid://100127687172105"
	end
end

local function Special_Txt(T, C)
	local RGB_Txt = string.format("rgb(%d, %d, %d)", C.R * 255, C.G * 255, C.B * 255)
	return [[<font color="]] .. RGB_Txt .. [[">]] .. T .. [[</font>]]
end

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

local function Display_Effects(Other_Plr)
	Debounce_UI = true
	
	local Elo_Error_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Elo_Error_SE")
	if(Elo_Error_SE ~= nil)then
		Elo_Error_SE:Play()
	end
	
	local function Reset_Display()
		Main_F.Visible = false
		Main_F.BackgroundTransparency = 1
		Main_Tab_F.Position = UDim2.new(0.5, 0, -0.25, 0)
		Main_F.Visible = true
	end
	Reset_Display()
	
	if(Other_Plr ~= nil)then
		local function Update_Elo_Difference_Display()
			local Your_Elo_Data, Your_Elo_Val = Elo_Mod.Get_Player_Rank_Data(Plr)
			local Other_Elo_Data, Other_Elo_Val = Elo_Mod.Get_Player_Rank_Data(Other_Plr)
			
			local function Compile_Range_Txt(D)
				local Range_Min, Range_Max = D['Elo Range'].Min, D['Elo Range'].Max
				local Txt = Format_Number(Range_Min) .. " - inf"
				if(D['Index'] <= 5)then
					Txt = Format_Number(Range_Min) .. " - " .. Format_Number(Range_Max)
				end
				
				return Special_Txt(Txt, D['Color'])
			end
			Rank_Data_F:FindFirstChild("Elo_Range_Txt").Text = Compile_Range_Txt(Your_Elo_Data) .. " | " .. Compile_Range_Txt(Other_Elo_Data)
			Rank_Data_F:FindFirstChild("Your_Img").Image = Get_Player_Thumbnail(Plr.UserId)
			Rank_Data_F:FindFirstChild("Other_Img").Image = Get_Player_Thumbnail(Other_Plr.UserId)
			
			Your_Elo_Img.Image = Your_Elo_Data['Icon']
			Your_Elo_Img.ImageColor3 = Your_Elo_Data['Color']
			Your_Elo_F:FindFirstChild("Elo_Txt").Text = Format_Number(Your_Elo_Val) .. ""
			
			Other_Elo_Img.Image = Other_Elo_Data['Icon']
			Other_Elo_Img.Image = Other_Elo_Data['Color']
			Other_Elo_F:FindFirstChild("Elo_Txt").Text = Format_Number(Other_Elo_Val) .. ""
			
			Rank_Data_F.Visible = true
		end
		Update_Elo_Difference_Display()
	else
		Rank_Data_F.Visible = false
	end
	
	local function Show_Effects()
		local Tween_Trans = TweenInfo.new(0.375, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
		TS:Create(Main_F, Tween_Trans, {BackgroundTransparency = 0.5}):Play()
		Main_Tab_F:TweenPosition(UDim2.new(0.5, 0, 0.475, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.5, true, nil)
		wait(0.5)
		Main_Tab_F:TweenPosition(UDim2.new(0.5, 0, 0.5125, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 2.5, true, nil)
		wait(2.5)	
		Main_Tab_F:TweenPosition(UDim2.new(0.5, 0, 1.1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.5, true, nil)
		wait(0.125)
		TS:Create(Main_F, Tween_Trans, {BackgroundTransparency = 1}):Play()
		wait(0.5)
	end
	Show_Effects()

	Reset_Display()
	
	Debounce_UI = false
end


Receiving_Events_F:WaitForChild("Elo_Rank_Dif").OnClientEvent:Connect(function(Other_Plr)
	if(Debounce_UI == false)then
		Display_Effects(Other_Plr)
	end
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXFC705DEF5C984014B4FBBCFC990ECEF0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Codes_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX0A7196B6676B452984693A1F54FC6BD8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Codes_Handle.client.lua</string>
						<string name="ScriptGuid">{A028BA4A-1C1B-42B2-8400-E22B861C2566}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")
local SE_F = PG:WaitForChild("Sound_Effects_F")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Sending_F = Channels_F:WaitForChild("Client_Server_F")
local Sending_RF = Sending_F:WaitForChild("RF")
local Sending_Events_F = Sending_F:WaitForChild("Events")
local Bindable_E = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Display_Data_E = Bindable_E:WaitForChild("Display_Data")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Cam = game.Workspace.CurrentCamera

local Codes_F = script.Parent.Main_F

local HeaderHolder = Codes_F:WaitForChild("HeaderHolder")
local Exit_B = HeaderHolder:WaitForChild("Exit_B")

local Body = Codes_F:WaitForChild("Body")

local Content = Body:WaitForChild("Stroke"):WaitForChild("Content")

local Redeem_B = Content.Send_Code_B
local Data_Txt = Content.Data_Box_F.Data_Txt_Box

local Debounce_E = false
local Debounce_C = false
local Debounce_UI = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Remove_UI()
	Disconnect_Cons()
	Codes_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Codes_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Codes_F.Visible = false
	Codes_F.Position = UDim2.new(0.5, 0, 0.675, 0)
	Data_Txt.Text = ""

	Bindable_E:WaitForChild("Toggle_Side_Buttons"):Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Show_UI()
	local Hover_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Hover_SE")
	local Click_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Click_SE")

	local function Reset_Display()
		Disconnect_Cons()
		Codes_F.Visible = false
		Codes_F.Position = UDim2.new(0.5, 0, 0.575, 0)
		Data_Txt.Text = ""

		local Codes_Blur = game.Lighting:FindFirstChild("Codes_Blurr")
		if(Codes_Blur ~= nil)then
			Codes_Blur:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()

	local function Redeem_Button()
		Redeem_B.Size = UDim2.new(0.28, 0, 0.361, 0)
		
		table.insert(Cons, Redeem_B.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				TS:Create(Redeem_B, Tween_Click, {Size = UDim2.new(0.21, 0, 0.27075, 0)}):Play()

				if(Data_Txt.Text ~= "")then
					local Code = string.upper(Data_Txt.Text)
					
					local Server_Response = Sending_RF:WaitForChild("Redeem_Code"):InvokeServer(Code)
					Display_Data_E:Fire(Server_Response)
				else
					Display_Data_E:Fire(" Enter your Code!", Color3.new(1, 0, 0))
				end

				wait(0.25)
				Debounce_C = false
			end
		end))
	end
	Redeem_Button()

	local function Exit_Button_Handle()
		local Def_Size = UDim2.new(0.128, 0, 0.439, 0)
		Exit_B.Size = Def_Size

		table.insert(Cons, Exit_B.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				if(Hover_SE ~= nil)then
					Hover_SE:Play()
				end
				Exit_B:TweenSize(UDim2.new(0.1408, 0, 0.4829, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
				Debounce_E = false
			end
		end))

		table.insert(Cons, Exit_B.MouseLeave:Connect(function()
			Exit_B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
		end))

		table.insert(Cons, Exit_B.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.096, 0, 0.32925, 0)}):Play()

				Remove_UI()

				wait(0.25)
				Debounce_C = false
			end
		end))
	end
	Exit_Button_Handle()

	local function Display_UI()
		Codes_F.Visible = true
		Codes_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Codes_Blurr"

		Bindable_E:WaitForChild("Toggle_Side_Buttons"):Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

Bindable_E:WaitForChild("Open_Codes").Event:Connect(function()
	if(Debounce_UI == false)then
		Show_UI()
	else
		Remove_UI()
	end
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXB1534FB565D9489DA77B91F6996D44E9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Notification_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX29D3FDA5C535499DAB40801A999F7333">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Main_Code.client.lua</string>
						<string name="ScriptGuid">{3C97124E-EE71-4D30-BC77-A690A1D39C5E}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")
local Channel_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channel_F:WaitForChild("Bindable_F")
local Receiving_F = Channel_F:WaitForChild("Server_Client_F")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Click_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Click_SE")

local Tabs_F = script.Parent.Tabs_F
local TMP = script.Parent.Txt_TMP

local function Move_Tabs_Up()
	local All_T = Tabs_F:GetChildren()
	local Min_Tab, Min_Pos = nil, 1
	for i = 1, #All_T do
		local Tab = All_T[i]
		local Y_Pos = Tab.Position.Y.Scale
		local New_Y = Y_Pos - 0.075
		Tab:TweenPosition(UDim2.new(0.5, 0, New_Y, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.125, true, nil)
		
		if(New_Y <= Min_Pos) then
			Min_Tab = Tab
			Min_Pos = New_Y
		end
	end
	
	if(#All_T >= 5 and Min_Tab ~= nil and Min_Tab.Parent == Tabs_F)then
		Min_Tab:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.125, true, nil)
		Min_Tab.Parent = script.Parent
		Debris:AddItem(Min_Tab, 0.125)
	end
end

local function Create_New_Tab(Txt, Col)
	local Tween_In = TweenInfo.new(0.125, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, true, 0)
	local Ind = #Tabs_F:GetChildren()
	local Tab = TMP:Clone()
	Tab.Name = "Tab_" .. Ind
	Tab.Text = Txt
	
	if(Col == nil)then
		Col = Color3.new(1, 1, 1)
	end
	Tab.TextColor3 = Col

	Move_Tabs_Up()
	Tab.Size = UDim2.new(0.5, 0, 0.075, 0)
	Tab.Position = UDim2.new(0.5, 0, 0.875, 0)
	TS:Create(Tab, Tween_In, {Size = UDim2.new(0.5, 0, 0.1, 0)}):Play()
	Tab.Visible = true
	Tab.Parent = Tabs_F
	if(Click_SE ~= nil)then
		Click_SE:Play()
	end

	wait(5.25)
	if(Tab ~= nil and Tab.Parent == Tabs_F)then
		Tab:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.125, true, nil)
		Tab.Parent = script.Parent
		Debris:AddItem(Tab, 0.125)
	end
end

local Msg_Stack = {}
local Debounce_Msgs = false
local function Process_Msg()
	Debounce_Msgs = true
	
	while #Msg_Stack > 0 do
		local D = Msg_Stack[1]
		local Show_Msg_T = coroutine.create(Create_New_Tab)
		coroutine.resume(Show_Msg_T, D['Text'], D['Color'])
		
		wait(0.125)
		table.remove(Msg_Stack, 1)
	end
	
	Debounce_Msgs = false
end

Bindable_F:WaitForChild("Events"):WaitForChild("Display_Data").Event:Connect(function(Txt, Color)
	local Data = {
		['Text'] = Txt,
		['Color'] = Color
	}
	table.insert(Msg_Stack, Data)
	
	if(Debounce_Msgs == false)then
		Process_Msg()
	end
end)

Receiving_F:WaitForChild("Events"):WaitForChild("Display_Data").OnClientEvent:Connect(function(Txt, Color)
	local Data = {
		['Text'] = Txt,
		['Color'] = Color
	}
	table.insert(Msg_Stack, Data)

	if(Debounce_Msgs == false)then
		Process_Msg()
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXCBAB748EC22845FBA17493ACC4FFC1A0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Player_Stats_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX0DE5E204119D441AA73CF25DF6832A6B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Player_Stats_Handle.client.lua</string>
						<string name="ScriptGuid">{393842D0-5FC8-4A5B-B976-6B6713BE7CC9}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Sound_Effects_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Country_Mod = require(Data_Mods_F:WaitForChild("Country_Mod"))
local Num_Str_Mod = require(Data_Mods_F:WaitForChild("Num_String_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local Cam = game.Workspace.CurrentCamera

local Main_F = script.Parent.Main_F
local Stats_Main_F = Main_F.Stats_Main_F
local Exit_B = Main_F.Header.Exit_B
local Player_Display_F = Stats_Main_F.Player_Display_F
local Edit_Info_B = Player_Display_F.Edit_Info_B
local Player_Img = Player_Display_F.Player_Img
local Bio_Txt = Player_Display_F.Bio_Txt
local Player_Info_F = Player_Display_F.Player_Info_F
local Player_Name_Txt = Player_Info_F.P_Name_Txt
local Player_DisplayName_Txt = Player_Info_F.P_DisplayName_Txt
local Current_Elo_F = Player_Display_F.Current_Elo_F
local Elo_Img = Current_Elo_F.Elo_Img
local Elo_Txt = Current_Elo_F.Elo_Txt
local Main_Stats_F = Stats_Main_F.Main_Stats_F

local Debounce_C = false
local Debounce_E = false
local Debounce_UI = false

local Click_SE = Sound_Effects_Mod.Get_SE_Object(Plr, "Click_SE")
local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end


local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Stats_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Setup_Main(T_Plr)
	if T_Plr.Name == Plr.Name then
		Edit_Info_B.Size = UDim2.new(0.225, 0, 0.15, 0)
		
		table.insert(Cons, Edit_Info_B.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				TS:Create(Edit_Info_B, Tween_Click, {Size = UDim2.new(0.16875, 0, 0.1125, 0)}):Play()
				
				Remove_UI()
				Bindable_Events_F:WaitForChild("Open_Appearance"):Fire()
				
				wait(0.25)
				Debounce_C = false
			end
		end))
		
		Edit_Info_B.Visible = true
	else
		Edit_Info_B.Visible = false
	end
	
	local PD = T_Plr:WaitForChild("Player_Data")
	local data = Stats_Manager_Mod.Create_Fight_Data_Structure(T_Plr.Character)
	local Range, Amount = Elo_Mod.Get_Player_Rank_Data(T_Plr)
	local country, img = Country_Mod.Get_Player_Country_Data(T_Plr)
	
	--// Player Info
	Player_Name_Txt.Text = T_Plr.DisplayName
	Player_DisplayName_Txt.Text = "@"..T_Plr.Name
	Player_Info_F.Image = img
	Elo_Img.ImageColor3 = Range['Color']
	Elo_Img.Image = Range["Icon"]
	Elo_Txt.Text = Format_Number(Amount)
	Player_Img.Image = game.Players:GetUserThumbnailAsync(T_Plr.UserId, Enum.ThumbnailType.AvatarThumbnail, Enum.ThumbnailSize.Size420x420)
	
	--// Main Stats
	Main_Stats_F.Strike_Percentage_F.Data_Val_Txt.Text = tostring(math.floor((data["Strikes Landed"]-1)/(data["Total Strikes"]-1) * 100)).."%"
	Main_Stats_F.Dodged_Strikes_F.Data_Val_Txt.Text = Format_Number(data["Dodged Strikes"])
	Main_Stats_F.Total_Takedowns_F.Data_Val_Txt.Text = Format_Number(data["Takedowns Landed"]).."/"..Format_Number(data["Takedowns Attempted"])
	Main_Stats_F.Total_Submissions_F.Data_Val_Txt.Text = Format_Number(data["Submissions Finished"]).."/"..Format_Number(data["Submissions Attempted"])
	Main_Stats_F.Total_Knockouts_F.Data_Val_Txt.Text = Format_Number(data["Leg Knockout Wins"] + data["Punch Knockout Wins"])
	Main_Stats_F.Total_Wins_F.Data_Val_Txt.Text = Format_Number(PD["Total Wins"].Value).."/"..Format_Number(PD["Total Matches"].Value)
	Main_Stats_F.Total_Ranked_Wins_F.Data_Val_Txt.Text = Format_Number(PD["Ranked Wins"].Value).."/"..Format_Number(PD["Ranked Matches"].Value)
	Main_Stats_F.Win_Streak_F.Data_Val_Txt.Text = Format_Number(PD["Win Streak"].Value)
	
	
	if (T_Plr:WaitForChild("Player_Data"):WaitForChild("Bio").Value ~= "") then
		Bio_Txt.Text = T_Plr:WaitForChild("Player_Data"):WaitForChild("Bio").Value
	else
		Bio_Txt.Text = "No Bio"
	end
	
	
end

local function Show_UI(T_Plr)
	local Hover_SE = Sound_Effects_Mod.Get_SE_Object(Plr, "Hover_SE")

	local function Reset_Display()
		Disconnect_Cons()
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.575, 0)

		local Stats_Blurr = game.Lighting:FindFirstChild("Stats_Blurr")
		if(Stats_Blurr ~= nil)then
			Stats_Blurr:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()
	
	Setup_Main(T_Plr)
	--//setup main stats

	local function Exit_Button_Handle()
		-- local Def_Size = Exit_B.Size
		-- Exit_B.Size = Def_Size

		table.insert(Cons, Exit_B.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				if(Hover_SE ~= nil)then
					Hover_SE:Play()
				end
				-- Exit_B:TweenSize(UDim2.new(0.1020625, 0, 0.186875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
				Debounce_E = false
			end
		end))

		table.insert(Cons, Exit_B.MouseLeave:Connect(function()
			-- Exit_B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
		end))

		table.insert(Cons, Exit_B.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				-- TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(1, 0, 0.044, 0)}):Play()

				Remove_UI()

				wait(0.25)
				Debounce_C = false
			end
		end))
	end
	Exit_Button_Handle()

	local function Display_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Stats_Blurr"

		Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

Bindable_Events_F:WaitForChild("Open_Stats").Event:Connect(function(T_Plr)
	if(Debounce_UI == false)then
		if(T_Plr == nil)then
			T_Plr = Plr
		end
		
		Show_UI(T_Plr)
	else
		Remove_UI()
	end
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX4E437E3829DA4CD0AAFD79B7B8A89A04">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Emotes_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXB90A47D4EE774B0D9990695E624397F9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Emotes_Handle.client.lua</string>
						<string name="ScriptGuid">{A9B68708-B390-4A35-84CE-C7D19A6FBB27}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Selected_Emotes_V = PD:WaitForChild("Current Emotes")
local Owned_Emotes_V = PD:WaitForChild("Owned Emotes")
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effects_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Animations_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Emotes_Data = Animations_Mod.Get_Combinations("Emotes")

local Emotes_F = script.Parent.Main_F
local Backdrop_Effects_F = Emotes_F.Frame_Backdrops_F
local Edit_Emotes_F = Emotes_F.Edit_Emotes_F
local Edit_Emotes_Button = Edit_Emotes_F.Selected
local Emote_Select_F = Emotes_F.Emote_Select_F
local Emote_List_F = Emote_Select_F.Emote_List_F
local Tabs_F = Emote_List_F.Tabs_F
local TMP_Tab = Emote_List_F.TMP_Tab

local Debounce_E = false
local Debounce_C = false
local Debounce_T = false
local Debounce_UI = false

local Edit_Mode = false
local Selected_Slot

local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Remove_UI()
	Disconnect_Cons()
	Emotes_F:TweenPosition(UDim2.new(0.6575, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

	local Is_Fighting = Char:GetAttribute("Is_Fighting")
	if(Is_Fighting ~= nil and Is_Fighting == true)then
		UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
		UIS.MouseIconEnabled = false
	end

	wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Emotes_Blur")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	
	Emotes_F.Edit_Emotes_F:TweenSize(UDim2.new(0.173, 0, 0.297, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, false, nil)
	Emotes_F.Edit_Emotes_F.TextLabel.Text = "Edit Emotes"
	Emotes_F.Edit_Emotes_F.TextLabel.TextColor3 = Color3.fromRGB(255,255,255)
	Emotes_F.Visible = false
	Emotes_F.Position = UDim2.new(0.6575, 0, 0.675, 0)
	Emote_Select_F.Visible = false
	Emote_List_F.CanvasPosition = Vector2.new(0, 0)
	Tabs_F:ClearAllChildren()

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
	Debounce_T = false
	Edit_Mode = false
	Selected_Slot = nil
end
Remove_UI()

local function Show_UI()
	local Hover_SE = Sound_Effects_Mod.Get_SE_Object(Plr, "Hover_SE")
	local Click_SE = Sound_Effects_Mod.Get_SE_Object(Plr, "Click_SE")

	local function Reset_Backdrop_Imgs()
		local All_Backdrop_Tabs = Backdrop_Effects_F:GetChildren()
		for i = 1, #All_Backdrop_Tabs do
			local T = All_Backdrop_Tabs[i]
			if(T ~= nil and T:IsA("ImageLabel"))then
				T.ImageColor3 = Color3.new(1, 1, 1)
			end
		end
	end

	local function Reset_Display()
		Disconnect_Cons()
		Emotes_F.Edit_Emotes_F:TweenSize(UDim2.new(0.173, 0, 0.297, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, false, nil)
		Emotes_F.Edit_Emotes_F.TextLabel.Text = "Edit Emotes"
		Emotes_F.Edit_Emotes_F.TextLabel.TextColor3 = Color3.fromRGB(255,255,255)
		Emotes_F.Visible = false
		Emotes_F.Position = UDim2.new(0.6575, 0, 0.575, 0)
		Emote_Select_F.Visible = false
		Emote_List_F.CanvasPosition = Vector2.new(0, 0)
		Tabs_F:ClearAllChildren()
		Reset_Backdrop_Imgs()

		local Emotes_Blur = game.Lighting:FindFirstChild("Emotes_Blur")
		if(Emotes_Blur ~= nil)then
			Emotes_Blur:Destroy()
		end
	end
	Reset_Display()

	--// load all the emotes they have selected
	--//setup buttons when clicked play emote and close menu
	--// setup edit menu load all the emotes they own, and when clicked assign that emote to that selected slot edit menu >select slot > select emote > save
	local Emote_Slots = Emotes_F:GetChildren()
	local EmotesSelected = Selected_Emotes_V.Value:split(",")

	local function LoadEmotes()
		--// setup all the buttons binds
		--// clear old ones
		Emote_List_F.CanvasPosition = Vector2.new(0, 0)
		Tabs_F:ClearAllChildren()

		local X = 0.25
		local Y = 0.25
		for key, values in pairs(Emotes_Data) do
			if (Animations_Mod.Player_Owns_Emote_Key(Plr, key) == true or values["Price"] <= 0) then
				local tmp = Emote_List_F.TMP_Tab:Clone()
				tmp.Name = key
				tmp.Main_Txt.Text = values["Name"]
				tmp.Emote_Img.Image = values['Icon']
				tmp.Visible = true
				tmp.Position = UDim2.new(X,0,Y,0)
				tmp.Parent = Emote_List_F.Tabs_F
				
				--// setup when pressed change slot to new emote selected and send request to server for confirmation.
				table.insert(Cons, tmp.Selected.MouseButton1Click:Connect(function()
					if (Selected_Slot) then
						local Server_Response = Channels_F.Client_Server_F.RF.Emote_Slot_Request:InvokeServer(Selected_Slot, key)
						if (Server_Response == true) then
							EmotesSelected[tonumber(Selected_Slot:match("%d+"))] = key
							Emotes_F[Selected_Slot].Emote_Name_Txt.Text = values["Name"]
							Emotes_F[Selected_Slot].Emote_Icon.Image = values["Icon"]
							Emote_Select_F.Visible = false
						else
							Emote_Select_F.Visible = false
						end
					end
				end))

				X += 0.48
				if X > 0.74 then
					X = 0.25
					Y += 0.54
				end
			end
		end

		Emote_Select_F.Visible = true
	end

	for i = 1, #Emote_Slots do
		local S = Emote_Slots[i]
		if(S ~= nil and S:IsA("Frame") and string.match(S.Name, "T") ~= nil)then
			--print(EmotesSelected)
			if (EmotesSelected[1] ~= "") then
				local ES_Selected = EmotesSelected[tonumber(S.Name:match("%d+"))]
				if (ES_Selected ~= nil and Emotes_Data[ES_Selected] ~= nil) then


					S.Emote_Name_Txt.Text = Emotes_Data[ES_Selected]["Name"]
					S.Emote_Icon.Image = Emotes_Data[EmotesSelected[tonumber(S.Name:match("%d+"))]]["Icon"]

					table.insert(Cons, S.Selected.MouseButton1Click:Connect(function() --// debounce and play anim 
						if(Debounce_T == false and Edit_Mode == false) then
							Debounce_T = true
							Animations_Mod.Reset_Character_Animations(Char)
							task.wait()
							Animations_Mod.Play_Emote_Track_From_Key(Plr, Hum, EmotesSelected[tonumber(S.Name:match("%d+"))], false)
							task.wait(.1)
							Debounce_T = false
							Reset_Display()
						elseif (Debounce_T == false and Edit_Mode == true) then
							if (Emote_Select_F.Visible == false) then
								Debounce_T = true
								Selected_Slot = S.Name
								LoadEmotes()
								task.wait(.1)
								Debounce_T = false
							elseif (Emote_Select_F.Visible == true) then
								Debounce_T = true
								Selected_Slot = nil
								Emote_Select_F.Visible = false
								task.wait(.1)
								Debounce_T = false
							end

						end	
					end))

				end
			end

		end
	end

	--LoadEmotes()

	table.insert(Cons, Emotes_F.Edit_Emotes_F.Selected.MouseButton1Click:Connect(function()
		if(Edit_Mode == false) then -- starting editing
			Edit_Mode = true
			Emotes_F.Edit_Emotes_F:TweenSize(UDim2.new(0.173, 0, 0.31, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, false, nil)
			Emotes_F.Edit_Emotes_F.TextLabel.Text = "Save"
			TS:Create(Emotes_F.Edit_Emotes_F.TextLabel, TweenInfo.new(.25, Enum.EasingStyle.Linear), {TextColor3 = Color3.fromRGB(52, 255, 29)}):Play()
		elseif (Edit_Mode == true) then -- check if anything was changed and save
			Edit_Mode = false
			Emotes_F.Edit_Emotes_F:TweenSize(UDim2.new(0.173, 0, 0.297, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, false, nil)
			Emotes_F.Edit_Emotes_F.TextLabel.Text = "Edit Emotes"
			TS:Create(Emotes_F.Edit_Emotes_F.TextLabel, TweenInfo.new(.25, Enum.EasingStyle.Linear), {TextColor3 = Color3.fromRGB(255, 255, 255)}):Play()
		end
	end))

	local function Display_UI()
		Emotes_F.Visible = true
		Emotes_F:TweenPosition(UDim2.new(0.6575, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Emotes_Blur"
		Blur.Enabled = false

		local Is_Fighting = Char:GetAttribute("Is_Fighting")
		if(Is_Fighting ~= nil and Is_Fighting == true)then
			UIS.MouseBehavior = Enum.MouseBehavior.Default
			UIS.MouseIconEnabled = true
		end

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

Bindable_Events_F:WaitForChild("Open_Emotes").Event:Connect(function()
	if(Debounce_UI == false)then
		Show_UI()
	else
		Remove_UI()
	end
end)

Receiving_Events_F:WaitForChild('Open_Emotes').OnClientEvent:Connect(function()
	if(Debounce_UI == false)then
		Show_UI()
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX82F1E3CC28CD49369E84FCDB4650DC45">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Shop_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX1F25294C7DD34FEF82E89E8B1A17EB4E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Shop_Handle.client.lua</string>
						<string name="ScriptGuid">{0AA0FFD6-2A07-48EA-822D-5C7099748BB2}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local MPS = game:GetService("MarketplaceService")
local Web = game:GetService("HttpService")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Owned_Passes_V = PD:WaitForChild("Owned Gamepasses")
local Owned_Products_V = PD:WaitForChild("Owned Products")
local Cash_V = PD:WaitForChild("Coins")
local Gems_V = PD:WaitForChild("Gems")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Monetization_Mod = require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Num_Str_Mod = require(Data_Mods_F:WaitForChild("Num_String_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Crate_Mod = require(Data_Mods_F:WaitForChild("Crate_Mod"))
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Sending_RF = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("RF")
local Sending_F = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("Events")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Msg_E = Bindable_Events_F:WaitForChild("Display_Data")
local Cam = game.Workspace.CurrentCamera

local Item_Preview_F = script.Parent.Item_Preview_F
local Item_Data_Main_F = Item_Preview_F.Main_Data_F
local Main_F = script.Parent.Main_F
local Data_Main_F = Main_F.Data_Main_F
local Fade_Bar_F = Data_Main_F.Fade_F
local Bottom_Bar_Buttons_F = Data_Main_F.Bottom_Bar_F
local Cash_Packs_F = Data_Main_F.Cash_Packs_F
local Crate_Data_F = Data_Main_F.Crate_Data_F
local Crates_Display_F = Data_Main_F.Crates_Display_F
local Gamepass_Display_F = Data_Main_F.Gamepass_Display_F
local Gems_Boost_F = Data_Main_F.Gems_Boost_F
local Merch_Display_F = Data_Main_F.Merch_Display_F
local Exit_B = Main_F.Header.Exit_B

local Debounce_C = false
local Debounce_E = false
local Debounce_UI = false
local Debounce_S = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Cons = {}
local Crate_Preview_Cons = {}
local function Disconnect_Cons(C)
	for i = 1, #C do
		if(C[i] ~= nil)then
			C[i]:Disconnect()
		end
	end
	table.clear(C)
end

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

local function multiUdim2(ud, scalar)
	return UDim2.new(ud.X.Scale * scalar, ud.X.Offset * scalar, ud.Y.Scale * scalar, ud.Y.Offset * scalar)
end

--// vfx stuff
local function Color_VFX(vfx_part, color)
	for _, particle in pairs(vfx_part:GetDescendants()) do
		if particle:IsA("ParticleEmitter") then
			particle.Color = ColorSequence.new(color)
		end
	end
end

local function Toggle_VFX(vfx_part, toggle)
	for _, particle in pairs(vfx_part:GetDescendants()) do
		if particle:IsA("ParticleEmitter") then
			particle.Enabled = toggle
		end
	end
end

local function Emit_VFX(vfx_part)
	for _, particle in pairs(vfx_part:GetDescendants()) do
		if particle:IsA("ParticleEmitter") then
			particle:Emit(particle:GetAttribute("EmitCount"))
		end
	end
end
--\\
local function Load_Merch()
	local Merch_Data = Monetization_Mod.Get_All_UGC_Data()

	local X,Y = 0.12, 0.25
	for key, values in pairs(Merch_Data) do
		--if (Merch_Display_F.Tabs_F:FindFirstChild(values["Name"]) and Merch_Display_F.Tabs_F:FindFirstChild(values["Name"]):GetAttribute("Key") ~= key) then
		if (Merch_Display_F.Tabs_F:FindFirstChild(values["Name"]) and Merch_Display_F.Tabs_F:FindFirstChild(values["Name"]):GetAttribute("Key") == key) then return end

		local ugc_info = MPS:GetProductInfo(values["ID"])
		local template = Merch_Display_F.Item_Tab_TMP:Clone()
		template.Name = values["Name"]
		template.Item_Name_F.Item_Name_Txt.Text = string.upper(values["Name"])
		template.Price_F.Robux_F.Data_Txt.Text = Format_Number(ugc_info["PriceInRobux"])
		template.Item_Img.Image = "rbxthumb://type=Asset&Id="..tostring(values["ID"]).."&w=150&h=150"
		template.Position = UDim2.new(X,0,Y,0)
		template.Parent = Merch_Display_F.Tabs_F
		template.Visible = true
		template:SetAttribute("Key", key)

		X += 0.245
		if (X > 0.9) then
			X = 0.12
			Y += 0.5
		end

		--end
	end

end
Load_Merch() -- doing this here since it takes a while to load 

local function Core_Frame_Data_Handles()
	local Frame_Funcs = {}
	local Hover_SE = SE_Mod.Get_SE_Object(Plr, "Hover_SE")
	local Click_SE = SE_Mod.Get_SE_Object(Plr, "Click_SE")

	local function Get_Size_Data(T)
		if(string.match(T.Name, "Mega_Huge"))then
			local Def_S = UDim2.new(0.45, 0, 0.875, 0)
			local Hover_S = UDim2.new(0.4725, 0, 0.91875, 0)
			local Click_S = UDim2.new(0.3375, 0, 0.65625, 0)

			return Def_S, Hover_S, Click_S
		else
			local Def_S = UDim2.new(0.2, 0, 0.425, 0)
			local Hover_S = UDim2.new(0.23, 0, 0.48875, 0)
			local Click_S = UDim2.new(0.15, 0, 0.31875, 0)

			return Def_S, Hover_S, Click_S
		end
	end

	local function Cash_Handle()
		local Cash_Cons = {}
		local Tabs = Cash_Packs_F:GetChildren()

		local function Update_Tab_Cash_Amounts()
			local Cash_Data = Monetization_Mod.Get_Cash_Boost_Amount(Plr)

			local function Update_Tab_Amount(T)
				local Boost_Amount_Txt = T:FindFirstChild("Boost_Amount_Txt")
				local Dev_Key = T:GetAttribute("Key")

				if(Boost_Amount_Txt ~= nil and Dev_Key ~= nil and Cash_Data[Dev_Key] ~= nil)then
					Boost_Amount_Txt.Text = "+ " .. Num_Str_Mod.NumToString(Cash_Data[Dev_Key])
				end
			end

			for i = 1, #Tabs do
				local T = Tabs[i]
				if(T ~= nil and T:IsA("Frame"))then
					Update_Tab_Amount(T)
				end
			end
		end
		Update_Tab_Cash_Amounts()

		table.insert(Cash_Cons, Cash_V.Changed:Connect(function()
			Update_Tab_Cash_Amounts()
		end))

		local function Init_Tab_Click_Handles()
			local function Tab_Handle(T)
				local Selected = T:FindFirstChild("Selected")
				local Key = T:GetAttribute("Key") or "A"
				local Dev_ID = Monetization_Mod.Get_ID_From_Key(false, Key)
				local Def_S, Hover_S, Click_S = Get_Size_Data(T)
				T.Size = Def_S

				table.insert(Cash_Cons, Selected.MouseEnter:Connect(function()
					if(Debounce_E == false and Cash_Packs_F.Visible == true)then
						Debounce_E = true
						if(Hover_SE ~= nil)then
							Hover_SE:Play()
						end

						T:TweenSize(Hover_S, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
						Debounce_E = false
					end
				end))

				table.insert(Cash_Cons, Selected.MouseLeave:Connect(function()
					if(Cash_Packs_F.Visible == true)then
						T:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
					end
				end))

				table.insert(Cash_Cons, Selected.MouseButton1Click:Connect(function()
					if(Debounce_C == false and Cash_Packs_F.Visible == true)then
						Debounce_C = true
						if(Click_SE ~= nil)then
							Click_SE:Play()
						end
						TS:Create(T, Tween_Click, {Size = Click_S}):Play()

						MPS:PromptProductPurchase(Plr, Dev_ID)
						Bindable_Events_F.MTX_Prompted:Fire()

						wait(0.25)
						Debounce_C = false
					end
				end))	
			end

			for i = 1, #Tabs do
				local T = Tabs[i]
				if(T ~= nil and T:IsA("Frame"))then
					Tab_Handle(T)
				end
			end

			Cash_Packs_F.Visible = true
		end
		Init_Tab_Click_Handles()

		table.insert(Cash_Cons, Cash_Packs_F:GetPropertyChangedSignal("Visible"):Connect(function()
			if(Cash_Packs_F.Visible == false)then
				Disconnect_Cons(Cash_Cons)
			end
		end))
	end

	local function Gems_Handle()
		local Gems_Cons = {}
		local Tabs = Gems_Boost_F:GetChildren()

		local function Init_Tab_Click_Handles()
			local function Tab_Handle(T)
				local Selected = T:FindFirstChild("Selected")
				local Key = T:GetAttribute("Key") or "A"
				local Dev_ID = Monetization_Mod.Get_ID_From_Key(false, Key)
				local Def_S, Hover_S, Click_S = Get_Size_Data(T)
				T.Size = Def_S

				table.insert(Gems_Cons, Selected.MouseEnter:Connect(function()
					if(Debounce_E == false and Gems_Boost_F.Visible == true)then
						Debounce_E = true
						if(Hover_SE ~= nil)then
							Hover_SE:Play()
						end

						T:TweenSize(Hover_S, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
						Debounce_E = false
					end
				end))

				table.insert(Gems_Cons, Selected.MouseLeave:Connect(function()
					if(Gems_Boost_F.Visible == true)then
						T:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
					end
				end))

				table.insert(Gems_Cons, Selected.MouseButton1Click:Connect(function()
					if(Debounce_C == false and Gems_Boost_F.Visible == true)then
						Debounce_C = true
						if(Click_SE ~= nil)then
							Click_SE:Play()
						end
						TS:Create(T, Tween_Click, {Size = Click_S}):Play()

						MPS:PromptProductPurchase(Plr, Dev_ID)
						Bindable_Events_F.MTX_Prompted:Fire()

						wait(0.25)
						Debounce_C = false
					end
				end))	
			end

			for i = 1, #Tabs do
				local T = Tabs[i]
				if(T ~= nil and T:IsA("Frame"))then
					Tab_Handle(T)
				end
			end

			Gems_Boost_F.Visible = true
		end
		Init_Tab_Click_Handles()

		table.insert(Gems_Cons, Gems_Boost_F:GetPropertyChangedSignal("Visible"):Connect(function()
			if(Gems_Boost_F.Visible == false)then
				Disconnect_Cons(Gems_Cons)
			end
		end))
	end

	local function Gamepasses_Handle()
		local GP_Cons = {}
		local Tabs = Gamepass_Display_F:GetChildren()

		local function Update_Owned_Gamepass_Tabs()
			local function Update_Tab(T)
				local GP_Key = T:GetAttribute("GP_Key")
				local Action_F = T:FindFirstChild("Action_F")
				local Owned_F = Action_F:FindFirstChild("Owned_F")
				local Buy_F = Action_F:FindFirstChild("Buy_F")

				if(GP_Key ~= nil and Monetization_Mod.Does_Player_Own_Gamepass_Key(Plr, GP_Key))then
					Owned_F.Visible = true
					Buy_F.Visible = false
				else
					Buy_F.Visible = true
					Owned_F.Visible = false
				end
			end

			for i = 1, #Tabs do
				local T = Tabs[i]
				if(T ~= nil and T:IsA("Frame"))then
					Update_Tab(T)
				end
			end
		end
		Update_Owned_Gamepass_Tabs()

		table.insert(GP_Cons, Owned_Passes_V.Changed:Connect(function()
			Update_Owned_Gamepass_Tabs()
		end))

		local function Init_Tab_Click_Handles()
			local function Tab_Handle(T)
				local Selected = T:FindFirstChild("Selected")
				local Key = T:GetAttribute("GP_Key") or "A"
				local GP_ID = Monetization_Mod.Get_ID_From_Key(true, Key)
				local GP_Data = Monetization_Mod.Get_Data_From_Key(true, Key)
				local Stroke = T:FindFirstChild("UIStroke")
				local Gamepass_Img = T:FindFirstChild("Gamepass_Img")
				local GP_Name_Txt = T:FindFirstChild("Gamepass_Name_Txt")
				local Action_F = T:FindFirstChild("Action_F")
				local Owned_F = Action_F:FindFirstChild("Owned_F")
				local Buy_F = Action_F:FindFirstChild("Buy_F")
				local Buy_B = Buy_F:FindFirstChild("Buy_B")
				local Price_Txt = Buy_F:FindFirstChild("Price_F"):FindFirstChild("Data_Txt")
				local Def_S = UDim2.new(0.975, -5, 0.3875, 0)
				local Click_S = UDim2.new(0.73125, -5, 0.290625, 0)

				T.Size = Def_S
				Gamepass_Img.Image = GP_Data['Icon'] .. ""
				Gamepass_Img.ImageColor3 = Color3.new(1, 1, 1)
				GP_Name_Txt.TextColor3 = Color3.new(1, 1, 1)
				Stroke.Color = Color3.new(1, 1, 1)

				table.insert(GP_Cons, Selected.MouseEnter:Connect(function()
					if(Debounce_E == false and Gamepass_Display_F.Visible == true)then
						Debounce_E = true
						if(Hover_SE ~= nil)then
							Hover_SE:Play()
						end

						Gamepass_Img.ImageColor3 = Color3.fromRGB(150, 150, 150)
						GP_Name_Txt.TextColor3 = Color3.fromRGB(150, 150, 150)
						Stroke.Color = Color3.fromRGB(35, 244, 68)

						Debounce_E = false
					end
				end))

				table.insert(GP_Cons, Selected.MouseLeave:Connect(function()
					if(Gamepass_Display_F.Visible == true)then
						Gamepass_Img.ImageColor3 = Color3.new(1, 1, 1)
						GP_Name_Txt.TextColor3 = Color3.new(1, 1, 1)
						Stroke.Color = Color3.new(1, 1, 1)
					end
				end))

				table.insert(GP_Cons, Selected.MouseButton1Click:Connect(function()
					if(Debounce_C == false and Gamepass_Display_F.Visible == true)then
						Debounce_C = true
						if(Click_SE ~= nil)then
							Click_SE:Play()
						end
						TS:Create(T, Tween_Click, {Size = Click_S}):Play()

						if(Owned_F.Visible == false)then
							MPS:PromptGamePassPurchase(Plr, GP_ID)
							Bindable_Events_F.MTX_Prompted:Fire()
						else
							local Txt = " You already own this Gamepass!"
							Msg_E:Fire(Txt, Color3.fromRGB(35, 244, 68))
						end

						wait(0.25)
						Debounce_C = false
					end
				end))	
			end

			for i = 1, #Tabs do
				local T = Tabs[i]
				if(T ~= nil and T:IsA("Frame"))then
					Tab_Handle(T)
				end
			end

			Gamepass_Display_F.CanvasPosition = Vector2.new(0, 0)
			Gamepass_Display_F.Visible = true
		end
		Init_Tab_Click_Handles()

		table.insert(GP_Cons, Gamepass_Display_F:GetPropertyChangedSignal("Visible"):Connect(function()
			if(Gamepass_Display_F.Visible == false)then
				Disconnect_Cons(GP_Cons)
			end
		end))

	end

	--BYTIZ Functions
	local function Merch_Handle()

		--Merch_Display_F.Tabs_F:ClearAllChildren()

		local Merch_Cons = {}

		local Tabs = Merch_Display_F.Tabs_F:GetChildren()
		local function Init_Tab_Click_Handles()
			local function Tab_Handle(T)
				local Selected = T:FindFirstChild("Selected")
				local Key = T:GetAttribute("Key") or "A"
				local Dev_ID = Monetization_Mod.Get_ID_From_Key_UGC(Key)
				local Def_S, Hover_S, Click_S = Get_Size_Data(T)
				T.Size = Def_S

				table.insert(Merch_Cons, Selected.MouseEnter:Connect(function()
					if(Debounce_E == false and Merch_Display_F.Visible == true)then
						Debounce_E = true
						if(Hover_SE ~= nil)then
							Hover_SE:Play()
						end

						T:TweenSize(Hover_S, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
						Debounce_E = false
					end
				end))

				table.insert(Merch_Cons, Selected.MouseLeave:Connect(function()
					if(Merch_Display_F.Visible == true)then
						T:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
					end
				end))

				table.insert(Merch_Cons, Selected.MouseButton1Click:Connect(function()
					if(Debounce_C == false and Merch_Display_F.Visible == true)then
						Debounce_C = true
						if(Click_SE ~= nil)then
							Click_SE:Play()
						end
						TS:Create(T, Tween_Click, {Size = Click_S}):Play()

						MPS:PromptPurchase(Plr, Dev_ID)

						wait(0.25)
						Debounce_C = false
					end
				end))	
			end

			for i = 1, #Tabs do
				local T = Tabs[i]
				if(T ~= nil and T:IsA("Frame"))then
					Tab_Handle(T)
				end
			end

			Merch_Display_F.Visible = true
		end
		Init_Tab_Click_Handles()

		table.insert(Merch_Cons, Merch_Display_F:GetPropertyChangedSignal("Visible"):Connect(function()
			if(Merch_Display_F.Visible == false)then
				Disconnect_Cons(Merch_Cons)
			end
		end))

	end

	local function Crates_Handle()
		local Crate_Cons = {}
		
		local Tabs = Crates_Display_F:GetChildren()
		Crate_Data_F.Visible = false
		Item_Preview_F.Visible = false

		Crates_Display_F.Tabs_F:ClearAllChildren()

		Crates_Display_F.Visible = true

		--// setup the crate frames displaying the items in that crate frame, rarity, etc...
		local Crates = Crate_Mod.Get_Crate_Data_Arr()

		local x,y = 0.165,0.275

		local function Get_Rarity(Item)
			if (Item and Item["Rarity"]) then
				local Color = nil
				local Fraction = nil
				if (Item["Rarity"] == 0.7) then -- bronze
					Color = Color3.fromRGB(255, 203, 112)
					Fraction = "7 in 10"
				elseif (Item["Rarity"] == 0.15) then -- silver
					Color = Color3.fromRGB(217, 217, 217)
					Fraction = "3 in 20"
				elseif (Item["Rarity"] == 0.1) then -- gold
					Color = Color3.fromRGB(255, 170, 0)
					Fraction = "1 in 10"
				elseif (Item["Rarity"] == 0.01) then -- diamond
					Color = Color3.fromRGB(170, 255, 255)
					Fraction = "1 in 100"
				elseif (Item["Rarity"] == 0.0001) then -- platinum
					Color = Color3.fromRGB(255, 170, 255)
					Fraction = "1 in 1,000"
				end
				return Item["Rarity"], Color, Fraction
			end
		end

		local function Open_Crate(Item, Rarity, Color)

			if (game.ReplicatedStorage:WaitForChild("Clothing_F"):FindFirstChild(Item["Name"], true)) then

				--// UI Stuff
				Item_Preview_F:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)

				wait(0.25)

				Disconnect_Cons(Crate_Cons)
				Crate_Data_F.Visible = false
				Bottom_Bar_Buttons_F.Visible = true
				Exit_B.Visible = true
				Crates_Display_F.Visible = false
				Item_Preview_F.Visible = false

				Disconnect_Cons(Cons)
				Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
				TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

				wait(0.25)

				local Blur = game.Lighting:FindFirstChild("Shop_Blurr")
				if(Blur ~= nil)then
					Blur:Destroy()
				end
				Cam.FieldOfView = 70

				Main_F.Visible = false
				Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

				Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true, true)

				Debounce_UI = false
				Debounce_C = false
				Debounce_E = false
				Debounce_S = false

				--// Crate Stuff
				if (game.ReplicatedStorage:WaitForChild("Clothing_F"):FindFirstChild(Item["Name"], true)) then
					Sending_F:WaitForChild("Crate_Display"):FireServer(game.ReplicatedStorage:WaitForChild("Clothing_F"):FindFirstChild(Item["Name"], true), Rarity, Color)
				end

			end	

		end

		local function Tab_Handle(T, crate_values)
			local Selected = T:FindFirstChild("Selected")
			local Def_S = UDim2.new(0.3, 0,0.5, 0)
			T.Size = Def_S

			table.insert(Crate_Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false and Crates_Display_F.Visible == true)then
					Debounce_E = true
					if(Hover_SE ~= nil)then
						Hover_SE:Play()
					end

					T:TweenSize(multiUdim2(T.Size, 1.03), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
					Debounce_E = false
				end
			end))

			table.insert(Crate_Cons, Selected.MouseLeave:Connect(function()
				if(Crates_Display_F.Visible == true)then
					T:TweenSize(Def_S, Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
				end
			end))

			table.insert(Crate_Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false and Crates_Display_F.Visible == true)then
					Debounce_C = true
					if(Click_SE ~= nil)then
						Click_SE:Play()
					end
					TS:Create(T, Tween_Click, {Size = multiUdim2(T.Size, 0.85)}):Play()

					local t_X,t_Y = 0.125,0.25

					Crate_Data_F.Items_F.Tabs_F:ClearAllChildren()

					task.wait()

					Crate_Data_F.Bottom_Bar_F.Cash_B.Data_Txt.Text = Format_Number(crate_values["PriceCoins"])
					Crate_Data_F.Bottom_Bar_F.Gems_B.Data_Txt.Text = Format_Number(crate_values["PriceGems"])
					
					Disconnect_Cons(Crate_Preview_Cons)

					table.insert(Crate_Preview_Cons, Crate_Data_F.Bottom_Bar_F.Cash_B.Selected.MouseButton1Click:Connect(function()
						task.wait()
						if (Debounce_S == false and Cash_V.Value >= crate_values["PriceCoins"]) then
							Debounce_S = true
							local b,c = Sending_RF.Crate_Action_Request:InvokeServer(crate_values, "Coins")

							if b == true then

								local itemm = nil
								for a, v in pairs(crate_values["Items"]) do
									if (v["Name"] == c) then
										itemm = v
										break
									end
								end

								local rarity,color,fraction = Get_Rarity(itemm)

								Open_Crate(itemm, rarity, color)

								local txt = Plr.Name.." unlocked "..c.." ("..fraction.." rarity)"
								Sending_RF.Parent.Events:WaitForChild("Server_Message_Crate"):FireServer(txt, color)
								task.wait()
							end

							task.wait(.25)
							Debounce_S = false

						else
							if Debounce_S == false then
								Msg_E:Fire(" You don't have enough Cash!", Color3.fromRGB(225, 0, 0))
							else
								--Msg_E:Fire(" You have to wait a little!", Color3.fromRGB(225, 0, 0))
							end
						end

					end))

					table.insert(Crate_Preview_Cons, Crate_Data_F.Bottom_Bar_F.Gems_B.Selected.MouseButton1Click:Connect(function()
						task.wait()
						if (Debounce_S == false and Gems_V.Value >= crate_values["PriceGems"]) then
							Debounce_S = true
							local b,c = Sending_RF.Crate_Action_Request:InvokeServer(crate_values, "Gems")

							if b == true then

								local itemm = nil
								for a, v in pairs(crate_values["Items"]) do
									if (v["Name"] == c) then
										itemm = v
										break
									end
								end

								local rarity,color,fraction = Get_Rarity(itemm)

								Open_Crate(itemm, rarity, color)

								local txt = Plr.Name.." unlocked "..c.." ("..fraction.." rarity)"
								Sending_RF.Parent.Events:WaitForChild("Server_Message_Crate"):FireServer(txt, color)
								task.wait()
							end

							task.wait(.25)
							Debounce_S = false

						else
							if Debounce_S == false then
								Msg_E:Fire(" You don't have enough Gems!", Color3.fromRGB(225, 0, 0))
							else
								--Msg_E:Fire(" You have to wait a little!", Color3.fromRGB(225, 0, 0))
							end
						end

					end))

					--// Crate Data Stuff

					local allRarities = {}
					local tempKeys = {}

					for i,v in pairs(crate_values["Items"]) do
						allRarities[i] = v["Rarity"]
					end

					for key, _ in pairs(allRarities) do
						table.insert(tempKeys, key)
					end

					table.sort(tempKeys, function(a, b)
						return allRarities[a] < allRarities[b]
					end)

					local function Crate_Exit_Button_Handle()
						local Def_Size = UDim2.new(0.08875, 0, 0.1625, 0)
						Crate_Data_F.Exit_B.Size = Def_Size

						table.insert(Crate_Preview_Cons, Crate_Data_F.Exit_B.MouseEnter:Connect(function()
							if(Debounce_E == false)then
								Debounce_E = true
								if(Hover_SE ~= nil)then
									Hover_SE:Play()
								end
								Crate_Data_F.Exit_B:TweenSize(UDim2.new(0.1020625, 0, 0.186875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
								Debounce_E = false
							end
						end))

						table.insert(Crate_Preview_Cons, Crate_Data_F.Exit_B.MouseLeave:Connect(function()
							Crate_Data_F.Exit_B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
						end))

						table.insert(Crate_Preview_Cons, Crate_Data_F.Exit_B.MouseButton1Click:Connect(function()
							if(Debounce_C == false)then
								Debounce_C = true
								if(Click_SE ~= nil)then
									Click_SE:Play()
								end
								TS:Create(Crate_Data_F.Exit_B, Tween_Click, {Size = UDim2.new(0.0665625, 0, 0.121875, 0)}):Play()

								Item_Preview_F.Visible = false
								Crate_Data_F.Visible = false
								Crates_Display_F.Visible = true
								Exit_B.Visible = true
								Bottom_Bar_Buttons_F.Visible = true

								wait(0.25)
								Debounce_C = false
							end
						end))
					end

					local function Exit_Button_Handle()
						local Def_Size = UDim2.new(0.08875, 0, 0.1625, 0)
						Item_Preview_F.Main_Data_F.Exit_B.Size = Def_Size

						table.insert(Crate_Preview_Cons, Item_Preview_F.Main_Data_F.Exit_B.MouseEnter:Connect(function()
							if(Debounce_E == false)then
								Debounce_E = true
								if(Hover_SE ~= nil)then
									Hover_SE:Play()
								end
								Item_Preview_F.Main_Data_F.Exit_B:TweenSize(UDim2.new(0.1020625, 0, 0.186875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
								Debounce_E = false
							end
						end))

						table.insert(Crate_Preview_Cons, Item_Preview_F.Main_Data_F.Exit_B.MouseLeave:Connect(function()
							Item_Preview_F.Main_Data_F.Exit_B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
						end))

						table.insert(Crate_Preview_Cons, Item_Preview_F.Main_Data_F.Exit_B.MouseButton1Click:Connect(function()
							if(Debounce_C == false)then
								Debounce_C = true
								if(Click_SE ~= nil)then
									Click_SE:Play()
								end
								TS:Create(Item_Preview_F.Main_Data_F.Exit_B, Tween_Click, {Size = UDim2.new(0.0665625, 0, 0.121875, 0)}):Play()
								Item_Preview_F:TweenSize(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)

								wait(0.25)
								Item_Preview_F.Visible = false
								Debounce_C = false
							end
						end))
					end

					for _, item in ipairs(tempKeys) do --for a, v in pairs(crate_values["Items"]) do
						if (Clothing_Mod.Get_Gloves_Data(crate_values["Items"][item]["Name"]) or Clothing_Mod.Get_Shorts_Data(crate_values["Items"][item]["Name"]) ) then
							--// Load Template
							local Rarity, Color, Fraction = Get_Rarity(crate_values["Items"][item])
							local tmp_Item = Crate_Data_F.Items_F.Item_Tab_TMP:Clone()
							tmp_Item.Name = crate_values["Items"][item]["Name"]
							tmp_Item.Item_Name_F.Item_Name_Txt.Text = string.upper(crate_values["Items"][item]["Name"])
							tmp_Item.Position = UDim2.new(t_X, 0, t_Y, 0)
							tmp_Item.BackgroundColor3 = Color
							tmp_Item.UIStroke.Color = Color
							tmp_Item.Parent = Crate_Data_F.Items_F.Tabs_F
							tmp_Item.Visible = true

							--// VF
							local display = game.ReplicatedStorage.Clothing_F:FindFirstChild(crate_values["Items"][item]["Name"], true):Clone()
							local Viewport_Camera = Instance.new("Camera")
							if (display:FindFirstChild("LeftHand")) then
								for _, hand in pairs(display:GetChildren()) do
									if (hand.Name == "LeftHand") then
										if (display:FindFirstChild("LeftHandM") == nil) then
											local model = Instance.new("Model")
											model.Name = "LeftHandM"
											model.Parent = display
											hand.Parent = model
										elseif (display:FindFirstChild("LeftHandM") ~= nil) then
											hand.Parent = display:FindFirstChild("LeftHandM")
										end
									elseif (hand.Name == "RightHand") then
										if (display:FindFirstChild("RightHandM") == nil) then
											local model = Instance.new("Model")
											model.Name = "RightHandM"
											model.Parent = display
											hand.Parent = model
										elseif (display:FindFirstChild("RightHandM") ~= nil) then
											hand.Parent = display:FindFirstChild("RightHandM")
										end
									end
								end
								display:WaitForChild("RightHandM"):PivotTo(CFrame.new(0.245, 0, -0) * CFrame.Angles(0, math.rad(90), 0))
								display:WaitForChild("LeftHandM"):PivotTo(CFrame.new(-0.645, 0, 0) * CFrame.Angles(0, math.rad(90), 0))
								--display:WaitForChild("LeftHand").Position = Vector3.new(-0.645, 0, 0)
								--display:WaitForChild("RightHand").Position = Vector3.new(0.245, 0, -0)
								--display:WaitForChild("LeftHand").Orientation = Vector3.new(0, 90, 0)
								--display:WaitForChild("RightHand").Orientation = Vector3.new(0, 90, 0)
								display:PivotTo(CFrame.new(0,0,0))
								tmp_Item.VF.CurrentCamera = Viewport_Camera
								display.Parent = tmp_Item.VF.WM
								tmp_Item.VF.WM:PivotTo(CFrame.new(0,0,0)* CFrame.Angles(0,math.rad(90),0)) -- * CFrame.Angles(math.rad(180),0,0)
								Viewport_Camera.Parent = tmp_Item.VF
								Viewport_Camera.CFrame = CFrame.new(0, -0.15, 1.3)
							elseif (display:FindFirstChild("LowerTorso")) then
								display:PivotTo(CFrame.new(0,0,0))
								tmp_Item.VF.CurrentCamera = Viewport_Camera
								display.Parent = tmp_Item.VF.WM
								tmp_Item.VF.WM:PivotTo(CFrame.new(0,0,0)) -- * CFrame.Angles(0,math.rad(90),0)
								Viewport_Camera.Parent = tmp_Item.VF
								Viewport_Camera.CFrame = CFrame.new(0, 0, 2)
							end



							t_X += 0.25

							if t_X >= 0.9 then
								t_X = 0.125
								t_Y += 0.525
							end

							table.insert(Crate_Preview_Cons, tmp_Item.Selected.MouseButton1Click:Connect(function()
								--// setup the item preview thing
								if (Item_Preview_F.Main_Data_F.VF:FindFirstChildOfClass("Camera")) then
									Item_Preview_F.Main_Data_F.VF.WM:ClearAllChildren()
									Item_Preview_F.Main_Data_F.VF:FindFirstChildOfClass("Camera"):Destroy()	
								end

								Exit_Button_Handle()

								local display2 = game.ReplicatedStorage.Clothing_F:FindFirstChild(crate_values["Items"][item]["Name"], true):Clone()
								local Viewport_Camera2 = Instance.new("Camera")
								if (display2:FindFirstChild("LeftHand")) then

									for _, part in pairs(display2:GetChildren()) do
										if (part:IsA("BasePart") and (part.Name == "LeftHand" or part.Name == "RightHand")) then
											local groupName = part.Name .. "M"
											local group = display2:FindFirstChild(groupName) or Instance.new("Model")
											group.Name = groupName
											group.Parent = display2
											part.Parent = group
											part.Anchored = true
										end
									end

									if (display2:FindFirstChild("LeftHandM") and display2:FindFirstChild("RightHandM")) then
										display2:PivotTo(CFrame.new(0,0,0))

										display2:WaitForChild("RightHandM"):PivotTo(CFrame.new(0.5, 0, 0))
										display2:WaitForChild("LeftHandM"):PivotTo(CFrame.new(-0.5, 0, 0))

										for _, modelName in ipairs({"LeftHandM", "RightHandM"}) do
											local model = display2[modelName]

											local hitbox = Instance.new("Part")
											hitbox.Name = "Hitbox"
											hitbox.Size = model:GetExtentsSize()
											hitbox.CFrame = model:GetPivot()
											hitbox.Anchored = true
											hitbox.Transparency = 1
											hitbox.CanCollide = false
											hitbox.Parent = model

											model.PrimaryPart = hitbox

											for _, part in ipairs(model:GetChildren()) do
												if (part:IsA("BasePart") and part ~= model.PrimaryPart) then
													local weld = Instance.new("WeldConstraint")
													weld.Part0 = model.PrimaryPart
													weld.Part1 = part
													weld.Parent = model.PrimaryPart
													part.Anchored = false
													--else
													--part.Anchored = true
												end
											end

										end

										display2:WaitForChild("RightHandM"):PivotTo(CFrame.new(0.5, 0, 0))
										display2:WaitForChild("LeftHandM"):PivotTo(CFrame.new(-0.5, 0, 0))



										TS:Create(display2:WaitForChild("LeftHandM").PrimaryPart, TweenInfo.new(3, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut, -1, true, 0), {CFrame = display2:WaitForChild("LeftHandM").PrimaryPart.CFrame * CFrame.Angles(0,math.rad(180),0)}):Play() --display2:WaitForChild("LeftHandM").PrimaryPart.CFrame
										TS:Create(display2:WaitForChild("RightHandM").PrimaryPart, TweenInfo.new(3, Enum.EasingStyle.Circular, Enum.EasingDirection.InOut, -1, true, 0), {CFrame =  display2:WaitForChild("RightHandM").PrimaryPart.CFrame * CFrame.Angles(0,math.rad(-180),0)}):Play()

									end

									--* CFrame.Angles(0,math.rad(90),0)
									--display2:WaitForChild("LeftHand").Position = Vector3.new(-0.645, 0, 0)
									--display2:WaitForChild("RightHand").Position = Vector3.new(0.245, 0, -0)
									--display2:WaitForChild("LeftHand").Orientation = Vector3.new(0, 0, 0)
									--display2:WaitForChild("RightHand").Orientation = Vector3.new(0, 0, 0)

									Item_Preview_F.Main_Data_F.VF.CurrentCamera = Viewport_Camera2
									display2.Parent = Item_Preview_F.Main_Data_F.VF.WM
									Item_Preview_F.Main_Data_F.VF.WM:PivotTo(CFrame.new(0,0,0)) -- * CFrame.Angles(0,math.rad(90),0)
									Viewport_Camera2.Parent = Item_Preview_F.Main_Data_F.VF
									Viewport_Camera2.CFrame = CFrame.new(0, -0.15, 1.3)
								elseif (display2:FindFirstChild("LowerTorso")) then
									display2.PrimaryPart.PivotOffset = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
									display2:PivotTo(CFrame.new(0,0,0))
									Item_Preview_F.Main_Data_F.VF.CurrentCamera = Viewport_Camera2
									display2.Parent = Item_Preview_F.Main_Data_F.VF.WM
									Item_Preview_F.Main_Data_F.VF.WM:PivotTo(CFrame.new(0,0,0)) -- * CFrame.Angles(0,math.rad(90),0)
									Viewport_Camera2.Parent = Item_Preview_F.Main_Data_F.VF
									Viewport_Camera2.CFrame = CFrame.new(0, -0.5, 2)
								end

								Item_Preview_F.Main_Data_F.Item_Name_Txt.Text = crate_values["Items"][item]["Name"]
								Item_Preview_F.Main_Data_F.Rare_F.Rare_Data_Txt.Text = Fraction
								Item_Preview_F.Main_Data_F.Rare_F.Rare_Data_Txt.TextColor3 = Color

								Item_Preview_F.Visible = true

								Item_Preview_F:TweenSize(UDim2.new(1, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)



							end))

						end

					end

					Crate_Data_F.Visible = true
					Bottom_Bar_Buttons_F.Visible = false
					Exit_B.Visible = false
					Crates_Display_F.Visible = false
					Item_Preview_F.Visible = false

					Crate_Exit_Button_Handle()


					wait(0.25)
					Debounce_C = false
				end
			end))

		end
		
		for i = 1, #Crates do
			--// setup crate
			local Crates_Info = Crates[i]
			if(Crates_Display_F.Crate_Tab_TMP:FindFirstChild(Crates_Info["Name"]) == nil) then

				--// Crate Tabs
				local tmp = Crates_Display_F.Crate_Tab_TMP:Clone()
				tmp.Name = Crates_Info["Name"]
				tmp.Crate_Name_F.Crate_Name_Txt.Text = string.upper(Crates_Info["Name"])
				tmp.Price_F.Cash_F.Data_Txt.Text = Format_Number(Crates_Info["PriceCoins"])
				tmp.Price_F.Gems_F.Data_Txt.Text = Format_Number(Crates_Info["PriceGems"])
				tmp.BackgroundColor3 = Crates_Info["Color_BG"]
				tmp.UIStroke.Color = Crates_Info["Color_BG"]
				tmp.Position = UDim2.new(x,0,y,0)
				tmp.Parent = Crates_Display_F.Tabs_F
				tmp.Visible = true
				x += 0.315
				if x >= 0.8 then
					x = 0.165
					y += 0.535
				end

				--// Crate Functions Clicking etc..
				Tab_Handle(tmp, Crates_Info)

			end
		end

		table.insert(Crate_Cons, Crates_Display_F:GetPropertyChangedSignal("Visible"):Connect(function()
			if(Crates_Display_F.Visible == false and Crate_Data_F.Visible == false)then
				Disconnect_Cons(Crate_Cons)
				Crate_Data_F.Visible = false
				Item_Preview_F.Visible = false
			end
		end))


	end

	return {
		['Cash'] = { 
			['Handle'] = Cash_Handle,
			['Main Frame'] = Cash_Packs_F
		},

		['Gems'] = { 
			['Handle'] = Gems_Handle,
			['Main Frame'] = Gems_Boost_F
		},

		['Passes'] = { 
			['Handle'] = Gamepasses_Handle,
			['Main Frame'] = Gamepass_Display_F
		},

		['Merch'] = { 
			['Handle'] = Merch_Handle,
			['Main Frame'] = Merch_Display_F
		},

		['Crates'] = { 
			['Handle'] = Crates_Handle,
			['Main Frame'] = Crates_Display_F
		},
	}
end
local Core_Frame_Data = Core_Frame_Data_Handles()

local function Change_Frames(Key)
	for Data_Type, Frame_Data in next, Core_Frame_Data do
		local F = Frame_Data['Main Frame']
		if(F ~= nil and (F:IsA("Frame") or F:IsA("ScrollingFrame")))then
			F.Visible = false
		end
	end

	if(Key ~= nil and Core_Frame_Data[Key] ~= nil and Core_Frame_Data[Key]['Handle'] ~= nil)then
		Core_Frame_Data[Key]['Handle']()
	end
end

local function Remove_UI()
	Disconnect_Cons(Cons)
	Disconnect_Cons(Crate_Preview_Cons)
	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	wait(0.25)

	Change_Frames(nil)
	local Blur = game.Lighting:FindFirstChild("Shop_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
	Debounce_S = false
end

local function Display_UI(Default_Display_Type, Free_Crate)	
	local Hover_SE = SE_Mod.Get_SE_Object(Plr, "Hover_SE")
	local Click_SE = SE_Mod.Get_SE_Object(Plr, "Click_SE")
	local Cash_SE = SE_Mod.Get_SE_Object(Plr, "Cash_SE")
	local Gems_SE = SE_Mod.Get_SE_Object(Plr, "Gems_SE")

	local function Reset_Display()
		Disconnect_Cons(Cons)
		Change_Frames(nil)

		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)
		Item_Preview_F.Visible = false
		Item_Preview_F.Size = UDim2.new(0, 0, 0, 0)

		Cam.FieldOfView = 70
		local Blur = game.Lighting:FindFirstChild("Shop_Blurr")
		if(Blur ~= nil)then
			Blur:Destroy()
		end

	end
	Reset_Display()

	local function Bottom_Bar_Handle()
		local All_B = Bottom_Bar_Buttons_F:GetChildren()

		local function Reset_Button_Colors(New_Selected)
			local function Update_Button_Text_Color(B)
				local Data_Txt = B:FindFirstChildWhichIsA("TextLabel")
				if(Data_Txt ~= nil) then
					if(New_Selected ~= nil and New_Selected == B)then
						Data_Txt.TextColor3 = Color3.fromRGB(255, 170, 0)
					else
						Data_Txt.TextColor3 = Color3.new(1, 1, 1)
					end
				end
			end

			for i = 1, #All_B do
				local B = All_B[i]
				if(B ~= nil and B:IsA("Frame"))then
					Update_Button_Text_Color(B)
				end
			end
		end

		local function Button_Handle(B)
			local Data_Type = string.gsub(B.Name, "_B", "")
			local Selected = B:FindFirstChild("Selected")
			local Icon = B:FindFirstChildWhichIsA("ImageLabel")
			local Data_Txt = B:FindFirstChildWhichIsA("TextLabel")

			-- B.Size = UDim2.new(0.175, 0, 0.75, 0)
			Icon.ImageColor3 = Color3.new(1, 1, 1)
			Data_Txt.TextColor3 = Color3.new(1, 1, 1)
			--Data_Txt.Position = UDim2.new(0.5, 0, 0.5, 0)

			table.insert(Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false)then
					Debounce_E = true
					if(Hover_SE ~= nil) then
						Hover_SE:Play()
					end
					Icon.ImageColor3 = Color3.fromRGB(150, 150, 150)

					Debounce_E = false
				end
			end))

			table.insert(Cons, Selected.MouseLeave:Connect(function()
				Icon.ImageColor3 = Color3.new(1, 1, 1)
			end))	

			table.insert(Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false and Bottom_Bar_Buttons_F.Visible == true and 
					Data_Txt.TextColor3 == Color3.new(1, 1, 1))then

					Debounce_C = true
					if(Click_SE ~= nil)then
						Click_SE:Play()
					end
					TS:Create(B, Tween_Click, {Size = UDim2.new(0.13125, 0, 0.5625, 0)}):Play()

					Reset_Button_Colors(B)
					Change_Frames(Data_Type)

					wait(0.25)
					Debounce_C = false
				end
			end))

			--On Init
			if(Data_Type == Default_Display_Type)then
				Reset_Button_Colors(B)
				Change_Frames(Data_Type)

				if(Default_Display_Type == "Crates" and Free_Crate ~= nil)then

				end
			end
		end

		for i = 1, #All_B do
			local B = All_B[i]
			if(B ~= nil and B:IsA("Frame"))then
				Button_Handle(B)
			end
		end		

		local function Track_Player_Cash_Gems()
			local Cash_B = Bottom_Bar_Buttons_F:FindFirstChild("Cash_B")
			local Gems_B = Bottom_Bar_Buttons_F:FindFirstChild("Gems_B")

			local function Update_Button_Val(B, Amount_V)
				local Data_Txt = B:FindFirstChildWhichIsA("TextLabel")
				if(Data_Txt ~= nil)then
					Data_Txt.Text = Num_Str_Mod.NumToString(Amount_V) .. ""

					if(Bottom_Bar_Buttons_F.Visible == true)then
						local Tween_Bounce = TweenInfo.new(0.125, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, true, 0)
						Data_Txt.Position = UDim2.new(0.975, 0, 0.5, 0)
						TS:Create(Data_Txt, Tween_Bounce, {Position = UDim2.new(0.975, 0, 0, 0)}):Play()
					end
				end
			end

			table.insert(Cons, Cash_V.Changed:Connect(function()
				Update_Button_Val(Cash_B, Cash_V.Value)
			end))
			Update_Button_Val(Cash_B, Cash_V.Value)

			table.insert(Cons, Gems_V.Changed:Connect(function()
				Update_Button_Val(Gems_B, Gems_V.Value)
			end))
			Update_Button_Val(Gems_B, Gems_V.Value)
		end
		Track_Player_Cash_Gems()

	end
	Bottom_Bar_Handle()

	local function Exit_Button_Handle()
		local Def_Size = Exit_B.Size
		local Zoom_Ratio = 1.1
		local Zoom_Size = UDim2.new(Def_Size.X.Scale * Zoom_Ratio, 0, Def_Size.Y.Scale * Zoom_Ratio, 0)

		table.insert(Cons, Exit_B.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				if(Hover_SE ~= nil)then
					Hover_SE:Play()
				end
				Exit_B:TweenSize(Zoom_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
				Debounce_E = false
			end
		end))

		table.insert(Cons, Exit_B.MouseLeave:Connect(function()
			Exit_B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
		end))

		table.insert(Cons, Exit_B.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				TS:Create(Exit_B, Tween_Click, {Size = Def_Size}):Play()

				Remove_UI()

				wait(0.25)
				Debounce_C = false
			end
		end))
	end
	Exit_Button_Handle()

	local function Display_Handle()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Shop_Blurr"

		Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_Handle()


end

Bindable_Events_F:WaitForChild("Open_Shop").Event:Connect(function(Type)
	if(Debounce_UI == false)then
		if(Type == nil)then
			Type = "Crates"
		end
		Display_UI(Type)
	else
		Remove_UI()
	end	
end)

Receiving_Events_F:WaitForChild("Open_Shop").OnClientEvent:Connect(function(Type)
	if(Debounce_UI == false)then
		if(Type == nil)then
			Type = "Crates"
		end
		Display_UI(Type)
	end	
end)

local tweenInfo = TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)

Receiving_Events_F:WaitForChild("Show_Crate_Effects").OnClientEvent:Connect(function(crateModel, gloveModel, color)

	local Crate_Owner = workspace:WaitForChild(crateModel.Name) 

	if (Crate_Owner ~= nil) then

		local VFXParts = crateModel:WaitForChild("VFX_Parts_F")
		local effect_cons = {}
		Emit_VFX(VFXParts.emit6)
		task.wait(1)
		Emit_VFX(VFXParts.emit1)
		Emit_VFX(VFXParts.emit2)
		Emit_VFX(VFXParts.emit3)
		task.wait(3)
		Emit_VFX(VFXParts.emit7)
		task.wait(1)

		local glove_Owner
		for _, glove in pairs(workspace.Crates:GetChildren()) do
			if (glove and glove:GetAttribute("Owner") == crateModel.Name) then
				glove_Owner = glove
			end
		end

		if (glove_Owner ~= nil) then
			local rootPart = Crate_Owner:WaitForChild("HumanoidRootPart")
			local startCFrame = glove_Owner:GetPivot()
			local endCFrame = startCFrame + Vector3.new(0, 6, 0) 
			endCFrame = endCFrame * CFrame.Angles(0, math.rad(180), 0) 
			local cfValue = Instance.new("CFrameValue")
			cfValue.Value = startCFrame

			table.insert(effect_cons,cfValue:GetPropertyChangedSignal("Value"):Connect(function()
				glove_Owner:PivotTo(cfValue.Value)
			end))

			local tween = TS:Create(cfValue, tweenInfo, { Value = endCFrame })
			--// crate opened
			Color_VFX(VFXParts.vfxpart3, color)
			Color_VFX(VFXParts.emit7, color)
			Toggle_VFX(VFXParts.vfxpart3, true)
			Toggle_VFX(VFXParts.emit7, true)
			tween:Play()
			task.wait(6)

			local fadeTweens = {}
			for _, part in pairs(glove_Owner:GetDescendants()) do
				if part:IsA("BasePart") then
					local fadeTween = TS:Create(part, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.In), { Transparency = 1 })
					table.insert(fadeTweens, fadeTween)
				end
			end

			startCFrame = glove_Owner:GetPivot()
			endCFrame = rootPart.CFrame * CFrame.new(0, 2, 0)
			endCFrame = endCFrame * CFrame.Angles(0, math.rad(180), 0) 

			cfValue.Value = startCFrame

			local moveTween = TS:Create(cfValue, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.In), { Value = endCFrame })

			moveTween:Play()

			for _, t in pairs(fadeTweens) do
				t:Play()
			end

			task.wait(.8)

			Toggle_VFX(VFXParts.vfxpart3, false)
			Toggle_VFX(VFXParts.emit7, false)
			Disconnect_Cons(effect_cons)
			cfValue:Destroy()
			table.clear(fadeTweens)
		end
	end

end)

local function Open_Up_Free_Crate(crate_values)
	local function Get_Rarity(Item)
		if (Item and Item["Rarity"]) then
			local Color = nil
			local Fraction = nil
			if (Item["Rarity"] == 0.7) then -- bronze
				Color = Color3.fromRGB(255, 203, 112)
				Fraction = "7 in 10"
			elseif (Item["Rarity"] == 0.15) then -- silver
				Color = Color3.fromRGB(217, 217, 217)
				Fraction = "3 in 20"
			elseif (Item["Rarity"] == 0.1) then -- gold
				Color = Color3.fromRGB(255, 170, 0)
				Fraction = "1 in 10"
			elseif (Item["Rarity"] == 0.01) then -- diamond
				Color = Color3.fromRGB(170, 255, 255)
				Fraction = "1 in 100"
			elseif (Item["Rarity"] == 0.0001) then -- platinum
				Color = Color3.fromRGB(255, 170, 255)
				Fraction = "1 in 1,000"
			end
			return Item["Rarity"], Color, Fraction
		end
	end

	local function Open_Crate(Item, Rarity, Color)
		if (game.ReplicatedStorage:WaitForChild("Clothing_F"):FindFirstChild(Item["Name"], true)) then

			--// Crate Stuff
			Sending_F:WaitForChild("Crate_Display"):FireServer(game.ReplicatedStorage:WaitForChild("Clothing_F"):FindFirstChild(Item["Name"], true), Rarity, Color)

		end	

	end

	if(Cash_V.Value >= crate_values["PriceCoins"]) then
		Debounce_S = true
		local b,c = Sending_RF.Crate_Action_Request:InvokeServer(crate_values, "Coins")

		if b == true then

			local itemm = nil
			for a, v in pairs(crate_values["Items"]) do
				if (v["Name"] == c) then
					itemm = v
					break
				end
			end

			local rarity,color,fraction = Get_Rarity(itemm)

			Open_Crate(itemm, rarity, color)

			local txt = Plr.Name.." unlocked "..c.." ("..fraction.." rarity)"
			Sending_RF.Parent.Events:WaitForChild("Server_Message_Crate"):FireServer(txt, color)
			task.wait()
		end

		task.wait(.25)
		Debounce_S = false

	end
end

Receiving_Events_F:WaitForChild("Grant_Free_Crate").OnClientEvent:Connect(function(Crate_Data)
	Open_Up_Free_Crate(Crate_Data)
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXB6CF56CCC88E4C688803BFE9901F919C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Servers_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXAE53345C6A5E4E339F95235C89D99271">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Servers_Handle.client.lua</string>
						<string name="ScriptGuid">{8945B683-76A0-4016-B6FC-B0BA6F812A42}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Teleport_Service = game:GetService("TeleportService")
local Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Sending_RF = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("RF")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Msg_E = Bindable_Events_F:WaitForChild("Display_Data")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Cam = game.Workspace.CurrentCamera

local Main_F = script.Parent.Main_F
local Main_Data_F = Main_F.Main_Data_F
local Rank_B = Main_Data_F.Buttons_F.Rank_B
local Ranked_Wins_B = Main_Data_F.Buttons_F.Ranked_Wins_B
local Wins_B = Main_Data_F.Buttons_F.Wins_B
local Server_Size_B = Main_Data_F.Buttons_F.Server_Size_B
local Exit_B = Main_F.Header.Exit_B 
local Data_F = Main_Data_F.Data_F
local Tabs_F = Data_F.Tabs_F
local TMP_Tab = Data_F.Server_TMP

local Debounce_C = false
local Debounce_E = false
local Debounce_UI = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if Cons[i] ~= nil then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local Core_Servers_Data = {}
task.spawn(function()
	Core_Servers_Data = Sending_RF:WaitForChild("Get_All_Server_Data"):InvokeServer()
end)

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

-- Transform dictionary into sorted array
local function Sort_Data_Handle(Data, Key)
	local Key_Vals = {
		['Rank'] = "Average Elo",
		['Ranked Wins'] = "Average Ranked Wins",
		['Wins'] = "Average Wins",
		['Server Size'] = "Server Size"
	}

	local Main_Key = Key_Vals[Key]
	if not Main_Key then
		return {}
	end

	local sorted = {}
	for _, v in pairs(Data) do
		table.insert(sorted, v)
	end

	table.sort(sorted, function(A, B)
		local A_Val = A[Main_Key] or 0
		local B_Val = B[Main_Key] or 0
		if Main_Key == "Server Size" then
			A_Val = #A[Main_Key]
			B_Val = #B[Main_Key]
		end
		return A_Val > B_Val
	end)

	return sorted
end

local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	wait(0.25)

	Tabs_F:ClearAllChildren()
	Data_F.CanvasPosition = Vector2.new(0, 0)

	local Blur = game.Lighting:FindFirstChild("Servers_Blurr")
	if Blur ~= nil then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Display_UI()
	local Hover_SE = SE_Mod.Get_SE_Object(Plr, "Hover_SE")
	local Click_SE = SE_Mod.Get_SE_Object(Plr, "Click_SE")

	local function Reset_UI()
		Disconnect_Cons()
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)
		Tabs_F:ClearAllChildren()
		Data_F.CanvasPosition = Vector2.new(0, 0)
		Cam.FieldOfView = 70
		local Blur = game.Lighting:FindFirstChild("Servers_Blurr")
		if Blur ~= nil then
			Blur:Destroy()
		end
	end
	Reset_UI()

	local function Teleport_Player_To_Server(S_ID)
		local Place_ID = 117620200631077
		local TP_Data = Instance.new("TeleportOptions")
		TP_Data.ReservedServerAccessCode = ""
		TP_Data.ServerInstanceId = S_ID .. ""
		TP_Data.ShouldReserveServer = false

		local function Async()
			local success = pcall(function()
				Teleport_Service:TeleportAsync(Place_ID, {Plr}, TP_Data)
			end)
			return success
		end

		for i = 1, 3 do 
			local D = Async()
			if D then return end
		end

		local Error_Msg = "? Failed to Teleport! Try another Server!"
		Msg_E:Fire(Error_Msg, Color3.fromRGB(225, 0, 0))
	end

	local function Populate_Data_Tabs(Sort_Type)
		local Tween_Scroll = TweenInfo.new(0.375, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
		local X_Pos, Y_Pos = 0.165, 0.225

		Tabs_F:ClearAllChildren()

		local uiGrid = Instance.new("UIGridLayout")
		uiGrid.CellPadding = UDim2.new(0.005, 0, 0.05, 0)
		uiGrid.CellSize = UDim2.new(0.32, 0, 0.35, 0)
		uiGrid.Parent = Tabs_F

		local function Create_Server_Tab(Data)
			local Avg_Elo = Data['Average Elo'] or 0
			local Server_ID = Data['Server ID'] or -1
			local Ranked_Wins_V = Data['Average Ranked Wins'] or 0
			local Wins_V = Data['Average Wins'] or 0
			local Player_List = Data['Server Size'] or {}
			local Elo, Elo_Data = Elo_Mod.Get_Elo_Data_From_Val(Avg_Elo)

			local Tab = TMP_Tab:Clone()
			local Join_B = Tab:WaitForChild("Join_B")
			local Join_Txt = Join_B:FindFirstChildWhichIsA("TextLabel")
			local Elo_Txt = Tab:WaitForChild("Elo_F"):WaitForChild("Elo_Num_Txt")
			local Elo_Img = Tab:WaitForChild("Elo_Img")
			local Server_Size_Txt = Tab:WaitForChild("Server_Size_Txt")

			Tab.Parent = Tabs_F
			Tab.Name = "Server_" .. Server_ID

			Elo_Txt.Text = Format_Number(Avg_Elo)
			Elo_Txt.TextColor3 = Elo_Data['Color']
			Elo_Img.Image = Elo_Data['Icon']
			Elo_Img.ImageColor3 = Elo_Data['Color']

			Tab:WaitForChild("Ranked_Wins_Txt").Text = Format_Number(Ranked_Wins_V)
			Tab:WaitForChild("Wins_Txt").Text = Format_Number(Wins_V)

			Server_Size_Txt.Text = #Player_List .. " / 25"
			if (#Player_List >= 25 or #Player_List == 0 or table.find(Player_List, Plr.UserId) ~= nil) then
				Server_Size_Txt.TextColor3 = Color3.new(1, 0, 0)
			else
				Server_Size_Txt.TextColor3 = Color3.new(1, 1, 1)
			end

			-- Join button handlers
			table.insert(Cons, Join_B.MouseEnter:Connect(function()
				if not Debounce_E then
					Debounce_E = true
					if Hover_SE then Hover_SE:Play() end
					Join_B.ImageColor3 = Color3.fromRGB(150, 150, 150)
					Join_Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					Debounce_E = false
				end
			end))

			table.insert(Cons, Join_B.MouseLeave:Connect(function()
				Join_B.ImageColor3 = Color3.new(1, 1, 1)
				Join_Txt.TextColor3 = Color3.new(1, 1, 1)
			end))

			table.insert(Cons, Join_B.MouseButton1Click:Connect(function()
				if not Debounce_C then
					Debounce_C = true
					if Click_SE then Click_SE:Play() end
					TS:Create(Join_B, Tween_Click, {Size = UDim2.new(0.35625, 0, 0.225, 0)}):Play()

					if Server_Size_Txt.TextColor3 == Color3.new(1, 0, 0) then
						Msg_E:Fire("? This Server is unavailable right now! Try Again later!", Color3.fromRGB(225, 0, 0))
					else
						local Did_Teleport = Sending_RF:WaitForChild("Teleport_To_Server"):InvokeServer(Server_ID)
						if Did_Teleport == false then
							Msg_E:Fire("? Failed to Teleport! Try another Server!", Color3.fromRGB(225, 0, 0))
						end
					end

					wait(0.25)
					Debounce_C = false
				end
			end))

			Tab.Position = UDim2.new(X_Pos, 0, Y_Pos, 0)
			Tab.Visible = true
			X_Pos += 0.33
			if X_Pos >= 1 then
				X_Pos = 0.165
				Y_Pos += 0.4125
			end
		end

		local sorted_data = Sort_Data_Handle(Core_Servers_Data, Sort_Type)
		for _, S_Data in pairs(sorted_data) do
			if S_Data and S_Data['Server Size'] then
				--print("DEBUG create tab for", S_Data["Server ID"], "players:", #S_Data["Server Size"])
				Create_Server_Tab(S_Data)
			else
				--print("DEBUG skipping entry", S_Data)
			end
		end

		TS:Create(Data_F, Tween_Scroll, {CanvasPosition = Vector2.new(0, 0)}):Play()
	end

	Populate_Data_Tabs("Rank")

	local function Rank_Button_Handle()
		local Sort_Buttons = {Rank_B, Ranked_Wins_B, Server_Size_B, Wins_B}

		local function Button_Handle(B)
			local Key = string.gsub(B.Name, "_B", "")
			local Txt = B:FindFirstChildWhichIsA("TextLabel")
			Key = string.gsub(Key, "_", " ")

			Txt.TextColor3 = Color3.new(1, 1, 1)
			B.ImageColor3 = Color3.new(1, 1, 1)
			B.Size = UDim2.new(0.086, 0, 0.066, 0)

			table.insert(Cons, B.MouseEnter:Connect(function()
				if not Debounce_E then
					Debounce_E = true
					if Hover_SE then Hover_SE:Play() end
					Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					B.ImageColor3 = Color3.fromRGB(150, 150, 150)
					Debounce_E = false
				end
			end))

			table.insert(Cons, B.MouseLeave:Connect(function()
				Txt.TextColor3 = Color3.new(1, 1, 1)
				B.ImageColor3 = Color3.new(1, 1, 1)
			end))

			table.insert(Cons, B.MouseButton1Click:Connect(function()
				if not Debounce_C then
					Debounce_C = true
					if Click_SE then Click_SE:Play() end
					TS:Create(B, Tween_Click, {Size = UDim2.new(0.0645, 0, 0.0495, 0)}):Play()
					Populate_Data_Tabs(Key)
					wait(0.25)
					Debounce_C = false
				end
			end))
		end

		for _, B in ipairs(Sort_Buttons) do
			if B and B:IsA("ImageButton") then
				Button_Handle(B)
			end
		end
	end
	Rank_Button_Handle()

	local function Exit_Handle()
		table.insert(Cons, Exit_B.MouseEnter:Connect(function()
			if not Debounce_E then
				Debounce_E = true
				if Hover_SE then Hover_SE:Play() end
				Debounce_E = false
			end
		end))

		table.insert(Cons, Exit_B.MouseButton1Click:Connect(function()
			if not Debounce_C then
				Debounce_C = true
				if Click_SE then Click_SE:Play() end
				Remove_UI()
				wait(0.25)
				Debounce_C = false
			end
		end))
	end
	Exit_Handle()

	local function Display_Main_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Servers_Blurr"
		Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false, true)
		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_Main_UI()
end

Bindable_Events_F:WaitForChild("Open_Servers").Event:Connect(function()
	if not Debounce_UI then
		Display_UI()
	else
		Remove_UI()
	end
end)

Receiving_Events_F:WaitForChild("Update_All_Server_Data").OnClientEvent:Connect(function(New_Data)
	Core_Servers_Data = New_Data
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXA311BDFAB0B84BF391C72A6DBCC03602">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Player_List_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXFB7B0BA097FB4972B5F4DEF93C0FFEA1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Player_List_UI.client.lua</string>
						<string name="ScriptGuid">{10FF244B-3592-439A-A336-BD8FB830C6BB}</string>
						<ProtectedString name="Source"><![CDATA[local UIS = game:GetService("UserInputService")
local L_Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Is_Chat_Typing = Bindable_RF:WaitForChild("Is_Chatbox_Typing")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Main_F = script.Parent.Main_F
local List_F = Main_F.Data_F
local Tabs_F = List_F.Tabs_F
local TMP_Tab = List_F.TMP_Tab

local Debounce_E = false
local Debounce_C = false
local Debounce_UI = false

local function Core_List_Handle()
	local Hover_SE = SE_Mod.Get_SE_Object(L_Plr, "Hover_SE")
	local Click_SE = SE_Mod.Get_SE_Object(L_Plr, "Click_SE")
	
	local function Format_Number(n)
		n = tostring(n)
		return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
	end
	
	local function Get_Player_Data_Vals(Plr)
		local PD = Plr:WaitForChild("Player_Data")
		if(PD ~= nil)then
			return PD:WaitForChild("Elo"), PD:WaitForChild("Win Streak"), 
				PD:WaitForChild("Punch Knockout Wins"), PD:WaitForChild("Leg Knockout Wins")
		end
		
		return nil, nil, nil, nil
	end
	
	local function Update_Win_Streak_Crown()
		local All_T = Tabs_F:GetChildren()
		table.sort(All_T, function(A, B)
			local A_Streak = A:GetAttribute("Win_Streak") or 0
			local B_Streak = B:GetAttribute("Win_Streak") or 0
			return A_Streak > B_Streak
		end)
		
		for i = 1, #All_T do
			local T = All_T[i]
			if(T ~= nil and T:IsA("Frame") and T:FindFirstChild("Streak_F") ~= nil)then
				local Streak_F = T:FindFirstChild("Streak_F")
				local Crown_Icon = Streak_F:FindFirstChild("Crown_Img")
				if(Crown_Icon ~= nil)then
					Crown_Icon.Visible = (i == 1)
				end
			end
		end
	end
	
	local function Update_Elo_Order()
		local Y_Pos = 0
		local All_T = Tabs_F:GetChildren()
		table.sort(All_T, function(A, B)
			local A_Elo = A:GetAttribute("Elo") or 0
			local B_Elo = B:GetAttribute("Elo") or 0
			return A_Elo > B_Elo
		end)
		
		for i = 1, #All_T do
			local T = All_T[i]
			if(T ~= nil and T:IsA("Frame"))then
				T.Position = UDim2.new(0, 0, Y_Pos, 0)
				Y_Pos += 0.15
			end
		end
	end
	
	local function Create_Player_Tab(Plr)
		local Elo_V, Win_Streak_V, Punch_KO_V, Kick_KO_V = Get_Player_Data_Vals(Plr)
		if(Elo_V ~= nil and Win_Streak_V ~= nil and Punch_KO_V ~= nil and Kick_KO_V ~= nil)then
			local Tab = TMP_Tab:Clone()
			Tab.Parent = Tabs_F
			Tab.Name = "Tab_" .. Plr.UserId
			Tab.Position = UDim2.new(1, 0, 0, 0)
			Tab:SetAttribute("Elo", Elo_V.Value or 400)
			Tab:SetAttribute("Win_Streak", Win_Streak_V.Value or 0)
			
			local Elo_Key, Elo_Data = Elo_Mod.Get_Elo_Data_From_Val(Elo_V.Value)
			local Selected = Tab:WaitForChild("Selected")
			local Elo_Txt = Tab:WaitForChild("Elo_F"):WaitForChild("Elo_Txt")
			local Name_F = Tab:WaitForChild("Plr_Name_F")
			local Elo_Icon = Name_F:WaitForChild("Elo_Img")
			local Name_Txt = Name_F:WaitForChild("Plr_Name_Txt")
			local Streak_F = Tab:WaitForChild("Streak_F")
			local Crown_Icon = Streak_F:WaitForChild("Crown_Img")
			local Streak_Txt = Streak_F:WaitForChild("Streak_Txt")
			local KO_Txt = Tab:WaitForChild("KO_F"):WaitForChild("KO_Txt")
			
			Name_Txt.Text = Plr.DisplayName .. ""
			Name_Txt.TextColor3 = Color3.new(1, 1, 1)
			Crown_Icon.Visible = false
			Streak_Txt.Text = Format_Number(Win_Streak_V.Value) .. ""
			KO_Txt.Text = Format_Number(Punch_KO_V.Value + Kick_KO_V.Value) .. ""
			Elo_Icon.Image = Elo_Data['Icon']
			Elo_Icon.ImageColor3 = Elo_Data['Color']
			Elo_Txt.Text = Format_Number(Elo_V.Value) .. ""
			Elo_Txt.TextColor3 = Elo_Data['Color']
			Tab.BackgroundColor3 = Elo_Data['Color']
			
			Punch_KO_V.Changed:Connect(function()
				KO_Txt.Text = Format_Number(Punch_KO_V.Value + Kick_KO_V.Value) .. ""
			end)
			
			Kick_KO_V.Changed:Connect(function()
				KO_Txt.Text = Format_Number(Punch_KO_V.Value + Kick_KO_V.Value) .. ""
			end)
			
			Win_Streak_V.Changed:Connect(function()
				local New_V = Win_Streak_V.Value or 0
				Tab:SetAttribute("Win_Streak", New_V)
				Streak_Txt.Text = Format_Number(New_V) .. ""
				Update_Win_Streak_Crown()
			end)
			
			Elo_V.Changed:Connect(function()
				local New_V = Elo_V.Value or 400
				local Elo_Key, Elo_Data = Elo_Mod.Get_Elo_Data_From_Val(New_V)
				Tab:SetAttribute("Elo", New_V)
				Elo_Icon.Image = Elo_Data['Icon']
				Elo_Icon.ImageColor3 = Elo_Data['Color']
				Elo_Txt.Text = Format_Number(New_V) .. ""
				Elo_Txt.TextColor3 = Elo_Data['Color']
				Tab.BackgroundColor3 = Elo_Data['Color']
				Update_Elo_Order()
			end)
			
			Selected.MouseEnter:Connect(function()
				if(Debounce_E == false)then
					Debounce_E = true
					if(Hover_SE ~= nil)then
						Hover_SE:Play()
					end
					Name_Txt.TextColor3 = Color3.fromRGB(34, 244, 68)
					Name_Txt:TweenPosition(UDim2.new(0.25, 0, 0.25, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
					
					Debounce_E = false
				end
			end)
			
			Selected.MouseLeave:Connect(function()
				Name_Txt.TextColor3 = Color3.new(1, 1, 1)
				Name_Txt:TweenPosition(UDim2.new(0.25, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
			end)
			
			Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false)then
					Debounce_C = true
					if(Click_SE ~= nil) then
						Click_SE:Play()
					end
					
					Bindable_Events_F:WaitForChild("Open_Stats"):Fire(Plr)
					
					wait(0.25)
					Debounce_C = false
				end
			end)
			
			Tab.Visible = true
		end
	end
	
	local function Remove_Tab(Plr)
		local Tab = Tabs_F:FindFirstChild("Tab_" .. Plr.UserId)
		if(Tab ~= nil)then
			Tab:Destroy()
		end
		
		Update_Elo_Order()
		Update_Win_Streak_Crown()
	end
	
	local function On_Init()
		local All_P = game.Players:GetPlayers()
		for i = 1, #All_P do
			local Plr = All_P[i]
			if(Plr ~= nil and Tabs_F:FindFirstChild("Tab_" .. Plr.UserId) == nil)then
				Create_Player_Tab(Plr)
			end
		end
		
		Update_Win_Streak_Crown()
		Update_Elo_Order()
		
		game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
		Debounce_UI = true
	end
	On_Init()
	
	Receiving_Events_F:WaitForChild("Update_Player_List").OnClientEvent:Connect(function(Plr, Did_Join)
		if(Did_Join == true and Tabs_F:FindFirstChild("Tab_" .. Plr.UserId) == nil)then
			Create_Player_Tab(Plr)
		elseif(Did_Join == false)then
			Remove_Tab(Plr)
		end
	end)
end
Core_List_Handle()

local function Toggle_Player_List_Handle()
	local function Toggle_Display()
		if(Debounce_UI == false)then
			Main_F:TweenPosition(UDim2.new(1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.75, true, nil)
			Debounce_UI = true
		else
			Main_F:TweenPosition(UDim2.new(1, 275, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.75, true, nil)
			Debounce_UI = false
		end
	end
	
	UIS.InputBegan:Connect(function(input, GPE)
		if((input.KeyCode == Enum.KeyCode.Tab or input.KeyCode == Enum.KeyCode.ButtonR3) and 
			Is_Chat_Typing:Invoke() == false)then
			
			Toggle_Display()
		end
	end)
	
	Bindable_Events_F:WaitForChild("Toggle_Player_List").Event:Connect(function()
		Toggle_Display()
	end)

	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons").Event:Connect(function(Should_Show)		
		Main_F.Parent.Enabled = Should_Show
	end)
end
Toggle_Player_List_Handle()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX582624CE65544F76B8BA295230A9C419">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Settings_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXE965D509EF524ECFA696796E402FAB17">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Settings_Handle.client.lua</string>
						<string name="ScriptGuid">{47D0AC25-87FF-4F8A-885F-3B908CD1FEA1}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Display_Data_E = Bindable_Events_F:WaitForChild("Display_Data")
local Close_Settings_E = Bindable_Events_F:WaitForChild("Close_Settings")
local Sending_Events_F = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("Events")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Cam = game.Workspace.CurrentCamera

local Main_F = script.Parent.Main_F
local Data_F = Main_F.Data_F
local Exit_B = Data_F.Exit_B
local Main_Data_F = Data_F.Main_Data_F

local Debounce_C = false
local Debounce_E = false
local Debounce_UI = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Get_Server_Settings_Data()
	local Tabs = Main_Data_F:GetChildren()
	local Data = {}

	local function Get_Data_From_Key(Key)
		local V = PD:FindFirstChild(Key)
		if(V ~= nil)then
			return V.Value
		end
		return false
	end

	for i = 1, #Tabs do
		local T = Tabs[i]
		if(T ~= nil)then
			local Key = T.Name
			Data[Key] = Get_Data_From_Key(Key)
		end
	end

	return Data
end

local function Get_Client_Settings_Data()
	local Tabs = Main_Data_F:GetChildren()
	local Data = {}

	local function Get_Data_From_Tab(T)
		local Toggle_F = T:FindFirstChild("Toggle_F")
		if(Toggle_F ~= nil and Toggle_F.BackgroundColor3 == Color3.fromRGB(35, 244, 68))then
			return true
		end
		return false
	end

	for i = 1, #Tabs do
		local T = Tabs[i]
		if(T ~= nil)then
			Data[T.Name] = Get_Data_From_Tab(T)
		end
	end

	return Data
end

local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	Main_Data_F.CanvasPosition = Vector2.new(0, 0)

	task.spawn(function()
		Sending_Events_F:WaitForChild("Save_Settings"):FireServer(Get_Client_Settings_Data())
	end)

	wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Settings_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true, true)

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
end

local function Display_UI()
	local Hover_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Hover_SE")
	local Click_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Click_SE")

	local function Reset_Display()
		Disconnect_Cons()
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.575, 0)
		Main_Data_F.CanvasPosition = Vector2.new(0, 0)

		local Stats_Blurr = game.Lighting:FindFirstChild("Settings_Blurr")
		if(Stats_Blurr ~= nil)then
			Stats_Blurr:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()

	local function Set_Up_Data_Tabs()
		local Tabs = Main_Data_F:GetChildren()
		local Settings_Data = Get_Server_Settings_Data()

		local function Tab_Handle(T)
			local Key = T.Name
			local Key_Txt = T:FindFirstChild("Settings_Key_Txt")
			local Toggle_F = T:FindFirstChild("Toggle_F")
			local Bar_F = Toggle_F:FindFirstChild("Bar_F")
			local Selected = Toggle_F:FindFirstChild("Selected")

			local function Update_Toggle_Display(Is_Enabled)
				if(Is_Enabled)then
					Toggle_F.BackgroundColor3 = Color3.fromRGB(35, 244, 68)
					Bar_F:TweenPosition(UDim2.new(0.775, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
				else
					Toggle_F.BackgroundColor3 = Color3.new(1, 0, 0)
					Bar_F:TweenPosition(UDim2.new(0.225, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
				end
			end
			Update_Toggle_Display(Settings_Data[Key])
			Key_Txt.TextColor3 = Color3.new(1, 1, 1)

			table.insert(Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false)then
					Debounce_E = true
					if(Hover_SE ~= nil)then
						Hover_SE:Play()
					end

					Key_Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
					Debounce_E = false
				end
			end))

			table.insert(Cons, Selected.MouseLeave:Connect(function()
				Key_Txt.TextColor3 = Color3.new(1, 1, 1)
			end))	

			table.insert(Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false)then
					Debounce_C = true
					if(Click_SE ~= nil)then
						Click_SE:Play()
					end

					local Current_V = (Toggle_F.BackgroundColor3 == Color3.fromRGB(35, 244, 68))
					Update_Toggle_Display(not Current_V)

					Sending_Events_F:WaitForChild("Save_Settings"):FireServer(Get_Client_Settings_Data())

					wait(0.375)
					Debounce_C = false
				end
			end))
		end

		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil)then
				Tab_Handle(T)
			end
		end
	end
	Set_Up_Data_Tabs()

	local function Exit_Button_Handle()
		local Def_Size = UDim2.new(0.118, 0, 0.139, 0)
		Exit_B.Size = Def_Size

		table.insert(Cons, Exit_B.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				if(Hover_SE ~= nil)then
					Hover_SE:Play()
				end
				Exit_B:TweenSize(UDim2.new(0.1357, 0, 0.15985, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
				Debounce_E = false
			end
		end))

		table.insert(Cons, Exit_B.MouseLeave:Connect(function()
			Exit_B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
		end))

		table.insert(Cons, Exit_B.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.0885, 0, 0.10425, 0)}):Play()

				--  Correction : bloquer le reopen immdiat
				Debounce_UI = true
				Remove_UI()
				Close_Settings_E:Fire()

				wait(0.25)
				Debounce_C = false
			end
		end))
	end
	Exit_Button_Handle()

	local function Display_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Settings_Blurr"

		Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

Bindable_Events_F:WaitForChild("Open_Settings").Event:Connect(function(value)
	if(Debounce_UI == false and value == true)then
		Display_UI()
	elseif ( Debounce_UI == true and value == false) then
		Remove_UI()
	end
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX4D60C4662A0840678439005C8CA008F1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Daily_Rewards_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX2803ED9B4D36485F805FFEBFBDBBB1FF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Daily_Reward_Handle.client.lua</string>
						<string name="ScriptGuid">{29747FF1-B6CF-4F29-B0C9-648DC6E90810}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Daily_Streak_V = PD:WaitForChild("Retention Streak")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Display_Data_E = Bindable_Events_F:WaitForChild("Display_Data")
local Sending_RF = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("RF")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Rewards_Mod = require(Data_Mods_F:WaitForChild("Rewards_Mod"))
local Cam = game.Workspace.CurrentCamera

local Main_F = script.Parent.Main_F
local Exit_B = Main_F.Exit_B
local Data_F = Main_F.Data_F
local Main_Data_F = Data_F.Main_Data_F
local D7_Tab = Data_F.Day_7

local Debounce_C = false
local Debounce_E = false
local Debounce_UI = false

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Remove_UI()
	Disconnect_Cons()
	Main_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	Main_Data_F.CanvasPosition = Vector2.new(0, 0)

	wait(0.25)
	
	Sound_Effect_Mod.Play_Voice_Over("Game_Intro")

	local Blur = game.Lighting:FindFirstChild("Daily_Rewards_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_F.Visible = false
	Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true, true)
	
	Bindable_Events_F:WaitForChild("Close_DailyRewards"):Fire()

	Debounce_UI = false
	Debounce_C = false
	Debounce_E = false
	
	wait(3)
	
	local Is_First_Time = Plr:GetAttribute("First_Time_Player")
	if(Is_First_Time == nil or Is_First_Time == true)then
		Bindable_Events_F:WaitForChild("Show_Tutorial"):Fire()
	end
end

local function Display_UI()
	local Hover_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Hover_SE")
	local Click_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Click_SE")
	local Sold_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Sold_SE")

	local function Reset_Display()
		Disconnect_Cons()
		Main_F.Visible = false
		Main_F.Position = UDim2.new(0.5, 0, 0.675, 0)
		Main_Data_F.CanvasPosition = Vector2.new(0, 0)

		local Stats_Blurr = game.Lighting:FindFirstChild("Daily_Rewards_Blurr")
		if(Stats_Blurr ~= nil)then
			Stats_Blurr:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()

	local Claimed_Keys = Rewards_Mod.Get_Claimed_Daily_Player_Rewards(Plr)
	local Claim_Streak = Rewards_Mod.Get_Player_Retention_Streak(Plr)

	local function Claim_Reward_Handle(T, Key)
		local Reward_Data = Rewards_Mod.Get_Specific_Daily_Reward(Key)
		local PB = T:FindFirstChild("Claim_B")
		local Status_Txt = PB:FindFirstChildWhichIsA("TextLabel")
		local Reward_Img = T:FindFirstChild("Reward_Img")
		local Claimed_Img = T:FindFirstChild("Claimed_Img")
		local Claimed_Indicator = T:FindFirstChild("ClaimedIndicator")

		local Did_Claim = Sending_RF:WaitForChild("Claim_Daily_Reward"):InvokeServer(Key)
		if(Did_Claim)then
			if(Sold_SE ~= nil)then
				Sold_SE:Play()
			end
			Display_Data_E:Fire(" Successfully Claimed & Earned " .. Reward_Data['Name'], Color3.fromRGB(170, 255, 0))
			Claimed_Keys = Rewards_Mod.Get_Claimed_Daily_Player_Rewards(Plr)

			Status_Txt.Text = "Claimed!"
			Reward_Img.ImageColor3 = Color3.fromRGB(100, 100, 100)
			Claimed_Img.Visible = true
			Claimed_Indicator.Visible = true
			PB.Visible = false
		else
			Display_Data_E:Fire(" Failed to Claim this Reward!", Color3.new(1, 0, 0))
		end
	end

	local function Init_Tab_Update()
		local function Update_Tab(T)
			local PB = T:FindFirstChild("Claim_B")
			local Status_Txt = PB:FindFirstChildWhichIsA("TextLabel")
			local Selected = T:FindFirstChild("Selected")
			local Reward_Img = T:FindFirstChild("Reward_Img")
			local Claimed_Img = T:FindFirstChild("Claimed_Img")
			local Day_Txt = T:FindFirstChild("Day_Txt")
			local Claimed_Indicator = T:FindFirstChild("ClaimedIndicator")
			local Key = string.gsub(T.Name, "Day_", "")
			Key = tonumber(Key)
			Day_Txt.Text = "Day " .. Key

			if(table.find(Claimed_Keys, Key .. "") ~= nil)then
				Status_Txt.Text = "Claimed!"
				Reward_Img.ImageColor3 = Color3.fromRGB(100, 100, 100)
				Claimed_Img.Visible = true
				Claimed_Indicator.Visible = true
				PB.Visible = false
			else
				Reward_Img.ImageColor3 = Color3.new(1, 1, 1)
				Claimed_Img.Visible = false
				Claimed_Indicator.Visible = false
				PB.Visible = true
				if(Claim_Streak >= Key)then
					Status_Txt.Text = "CLAIM!"
				else
					Status_Txt.Text = "Soon" --"Day " .. Key
				end
			end

			table.insert(Cons, Selected.MouseEnter:Connect(function()
				if(Debounce_E == false)then
					Debounce_E = true
					if(Hover_SE ~= nil)then
						Hover_SE:Play()
					end
					PB.ImageColor3 = Color3.fromRGB(150, 150, 150)
					
					Debounce_E = false
				end
			end))
			
			table.insert(Cons, Selected.MouseLeave:Connect(function()
				PB.ImageColor3 = Color3.new(1, 1, 1)
			end))	
			
			
			local function Get_Click_Size()
				if(T.Parent == Main_Data_F)then
					return UDim2.new(0.178125, 0, 0.46875, 0)
				else
					return UDim2.new(0.136875, 0, 0.46875, 0)
				end
			end
			
			table.insert(Cons, Selected.MouseButton1Click:Connect(function()
				if(Debounce_C == false)then
					Debounce_C = true
					if(Click_SE ~= nil)then
						Click_SE:Play()
					end
					
					TS:Create(T, Tween_Click, {Size = Get_Click_Size()}):Play()
					
					if(Status_Txt.Text == "Claimed!")then
						Display_Data_E:Fire(" You've already Claimed this Reward!", Color3.fromRGB(0, 225, 0))
					elseif(Status_Txt.Text ~= "CLAIM!")then
						Display_Data_E:Fire(" You can't Claim this Reward yet!", Color3.new(1, 0, 0))
					else
						Claim_Reward_Handle(T, Key)
					end
					
					wait(0.25)
					Debounce_C = false
				end
			end))	
		end

		local Tabs = Main_Data_F:GetChildren()
		for i, v in pairs(Tabs) do
			if v.ClassName == "ImageLabel" then
				Update_Tab(v)
			end
		end
		--Update Day 7 Reward Tab
		Update_Tab(D7_Tab)
	end
	Init_Tab_Update()

	local function Exit_Button_Handle()
		local Def_Size = UDim2.new(0.1, 0, 0.175, 0)
		Exit_B.Size = Def_Size

		table.insert(Cons, Exit_B.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				if(Hover_SE ~= nil)then
					Hover_SE:Play()
				end
				Exit_B:TweenSize(UDim2.new(0.115, 0, 0.20125, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
				Debounce_E = false
			end
		end))

		table.insert(Cons, Exit_B.MouseLeave:Connect(function()
			Exit_B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
		end))

		table.insert(Cons, Exit_B.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.075, 0, 0.13125, 0)}):Play()

				Remove_UI()

				wait(0.25)
				Debounce_C = false
			end
		end))
	end
	Exit_Button_Handle()

	local function Display_UI()
		Main_F.Visible = true
		Main_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Daily_Rewards_Blurr"

		Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false, true)

		Debounce_UI = true
		Debounce_C = false
		Debounce_E = false
	end
	Display_UI()
end

Bindable_Events_F.Open_Daily_Rewards.Event:Connect(function()
	Display_UI()
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX434F960AF48C4DFDBEF88AD6F24FBC26">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Session_Rewards_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX154E60DD883349EA864EA2A4A02F4557">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Session_Rewards_Handle.client.lua</string>
						<string name="ScriptGuid">{0329D371-1E19-4788-8BFE-6593DEC696DC}</string>
						<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local pg = player:WaitForChild("PlayerGui")

local rewardsGui = pg:WaitForChild("Session_Rewards_UI")
local frame = rewardsGui:WaitForChild("Session_Rewards_F")
rewardsGui.Enabled = false

local holder = frame:WaitForChild("Body"):WaitForChild("Stroke"):WaitForChild("Content"):WaitForChild("Holder")

-- Rows dynamiques
local rows = {}
for i = 1, 4 do 
	local r = holder:FindFirstChild("Row"..i)
	if r then
		rows[i] = {
			container = r,
			label = r:FindFirstChild("Label") or r:FindFirstChild("TextLabel"),
			btn   = r:FindFirstChild("Button") or r:FindFirstChildWhichIsA("TextButton"),
		}
	end
end

local Channels = RS:WaitForChild("Channels_F")
local SC_Events = Channels.Server_Client_F.Events
local CS_RF = Channels.Client_Server_F.RF

local ProgressRE = SC_Events:WaitForChild("Session_Reward_Progress")
local ClaimResRE = SC_Events:WaitForChild("Session_Reward_Claim_Result")
local ClaimRF    = CS_RF:WaitForChild("Claim_Session_Reward")
local GetProgressRF = CS_RF:WaitForChild("Get_Session_Progress") 

-- State
local thresholds = {}
local elapsed = 0
local claimsDone = 0
local maxClaimsToday = 0
local claimed = {}

-- Lissage local
local lastServerElapsed = 0
local lastUpdateTime = 0

local function fmt(sec:number):string
	sec = math.floor(tonumber(sec) or 0)
	if sec < 60 then
		return "<1 min"
	end
	local m = math.floor(sec / 60)
	return string.format("%d min", m)
end

local function render()
	for i, th in ipairs(thresholds) do
		local row = rows[i]
		if not row then break end

		local unlocked = elapsed >= th.t
		local remaining = math.max(0, th.t - elapsed)

		if row.label then
			local base = (th.reward and th.reward.label) or (tostring(th.t).."s")
			row.label.Text = base
		end

		if row.btn then
			if maxClaimsToday > 0 and claimsDone >= maxClaimsToday then
				row.btn.Text = "Claimed"
				row.btn.Active = false
				row.btn.AutoButtonColor = false
				row.btn.BackgroundColor3 = Color3.fromRGB(9,56,14)--(255,255,255)
			elseif claimed[th.t] then
				row.btn.Text = "Claimed"
				row.btn.Active = false
				row.btn.AutoButtonColor = false
				row.btn.BackgroundColor3 = Color3.fromRGB(9,56,14)--(255,255,255)
			elseif not unlocked then
				row.btn.Text = "Locked ("..fmt(remaining)..")"
				row.btn.Active = false
				row.btn.AutoButtonColor = false
				row.btn.BackgroundColor3 = Color3.fromRGB(9,56,14)--(200,200,200)
			else
				row.btn.Text = "CLAIM!"
				row.btn.Active = true
				row.btn.AutoButtonColor = true
				row.btn.BackgroundColor3 = Color3.fromRGB(35, 244, 68)
			end
		end
	end
end

-- Hook claim buttons
for i, row in ipairs(rows) do
	if row and row.btn then
		row.btn.MouseButton1Click:Connect(function()
			local th = thresholds[i]
			if not th then return end
			if claimed[th.t] then return end
			if maxClaimsToday > 0 and claimsDone >= maxClaimsToday then return end
			if elapsed < th.t then return end

			local res = ClaimRF:InvokeServer(th.t)
			if res and res.ok then
				claimed[th.t] = true
				claimsDone += 1
				render()
			end
		end)
	end
end

-- Receive server progress
ProgressRE.OnClientEvent:Connect(function(payload)
	thresholds        = payload.thresholds or thresholds
	lastServerElapsed = payload.elapsed or 0
	lastUpdateTime    = os.clock()
	elapsed           = lastServerElapsed

	claimsDone     = payload.count or 0
	maxClaimsToday = payload.maxClaims or 0

	claimed = {}
	if typeof(payload.claimedTimes) == "string" and payload.claimedTimes ~= "" then
		for _, s in ipairs(string.split(payload.claimedTimes, ",")) do
			local n = tonumber(s)
			if n then claimed[n] = true end
		end
	end

	render()
end)

RunService.RenderStepped:Connect(function()
	if lastServerElapsed > 0 then
		local now = os.clock()
		elapsed = lastServerElapsed + (now - lastUpdateTime)
		render()
	end
end)

--------------------------------------------------------------------
-- Open/Close UI
--------------------------------------------------------------------
local Events = RS:WaitForChild("Channels_F"):WaitForChild("Bindable_F"):WaitForChild("Events")
local OpenEvt = Events:WaitForChild("Open_Session_Rewards")

local Cam = workspace.CurrentCamera
local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local Debounce_UI = false

local function Remove_UI()
	frame:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TweenService:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	task.wait(0.25)
	local Blur = game.Lighting:FindFirstChild("Rewards_Blurr")
	if Blur then Blur:Destroy() end
	Cam.FieldOfView = 70
	rewardsGui.Enabled = false
	frame.Position = UDim2.new(0.5, 0, 0.675, 0)
	Events:WaitForChild("Toggle_Side_Buttons"):Fire(true, true)
	Debounce_UI = false
end

local function Display_UI()
	rewardsGui.Enabled = true
	frame.Position = UDim2.new(0.5, 0, 0.675, 0)
	frame.Visible = true
	frame:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TweenService:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
	local Blur = Instance.new("BlurEffect")
	Blur.Name = "Rewards_Blurr"
	Blur.Parent = game.Lighting
	Events:WaitForChild("Toggle_Side_Buttons"):Fire(false, true)
	Debounce_UI = true

	--  demander tat frais au serveur
	local payload = GetProgressRF:InvokeServer()
	if payload then
		thresholds        = payload.thresholds or thresholds
		lastServerElapsed = payload.elapsed or 0
		lastUpdateTime    = os.clock()
		elapsed           = lastServerElapsed
		claimsDone        = payload.count or 0
		maxClaimsToday    = payload.maxClaims or 0

		claimed = {}
		if typeof(payload.claimedTimes) == "string" and payload.claimedTimes ~= "" then
			for _, s in ipairs(string.split(payload.claimedTimes, ",")) do
				local n = tonumber(s)
				if n then claimed[n] = true end
			end
		end
	end

	render()
end

local closeBtn = frame:FindFirstChild("Close")
if closeBtn then
	closeBtn.MouseButton1Click:Connect(function()
		Remove_UI()
	end)
end

OpenEvt.Event:Connect(function()
	if not Debounce_UI then
		Display_UI()
	else
		Remove_UI()
	end
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXDE305AE0571545BFA0E0408BB5D31580">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">CreatorCode</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX94B4DE73DA6A47F0AD74AB6E11B96BEE">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CreatorCodeHandle.client.lua</string>
						<string name="ScriptGuid">{645CF118-8689-43A0-8B0F-593AE8B1BB05}</string>
						<ProtectedString name="Source"><![CDATA[

local MarketPlaceService = game:GetService("MarketplaceService")
local TweenService = game:GetService("TweenService")

local CreatorCodes = require(game.ReplicatedStorage.CreatorCodes)

local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")

MarketPlaceService.PromptProductPurchaseFinished:Connect(function()
	Bindable_Events_F.MTX_Finished:Fire()
end)
MarketPlaceService.PromptGamePassPurchaseFinished:Connect(function()
	Bindable_Events_F.MTX_Finished:Fire()
end)

local InnerFrame = script.Parent.InnerFrame
local CreatorCodeFrame = InnerFrame.CreatorCodeFrame
local TextBox = CreatorCodeFrame.CodeField.TextBox


local animating = false

CreatorCodeFrame.Submit.Activated:Connect(function()
	local event = Channels_F.Client_Server_F.Events.Set_Creator_Reward_Code
	if animating == true then
		return
	end
	
	local code = TextBox.Text
	local lastTextColor = TextBox.TextColor3
	
	local codeIndex = nil
	local found = false
	for i, v in pairs(CreatorCodes) do
		if string.lower(v.Name) == string.lower(code) then
			code = v.Name
			codeIndex = i
			
			found = true
			break
		end
	end
	
	TextBox.TextEditable = false
	animating = true
	if found == true then
		event:FireServer(codeIndex)
		
		TextBox.TextColor3 = Color3.fromRGB(0, 255, 0)
		TextBox.Text = "Code ok!"
		
		task.wait(1.5)
		
		TextBox.Text = code
		TextBox.TextColor3 = lastTextColor
	else
		event:FireServer(nil)
		
		TextBox.TextColor3 = Color3.fromRGB(255, 0, 0)
		TextBox.Text = "Code not ok!"

		task.wait(1.5)

		TextBox.Text = ""
		TextBox.TextColor3 = lastTextColor
	end
	animating = false
	TextBox.TextEditable = true
end)


local showMenu = function(t: number?)
	t = t or 1
	TweenService:Create(
		InnerFrame, 
		TweenInfo.new(t, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0),
		{
			Position = UDim2.new(0.5, 0, 0.5, 0), 
			AnchorPoint = Vector2.new(0.5, 0.5)
		}
	):Play()
end

local hideMenu = function(t: number?)
	t = t or 0.25
	TweenService:Create(
		InnerFrame, 
		TweenInfo.new(t, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0),
		{
			Position = UDim2.new(0.5, 0, 1.1, 0), 
			AnchorPoint = Vector2.new(0.5, 0)
		}
	):Play()
end
hideMenu(0)

Bindable_Events_F.MTX_Prompted.Event:Connect(function()
	showMenu()
end)
Bindable_Events_F.MTX_Finished.Event:Connect(function()
	hideMenu()
end)

local cam = game.Workspace.CurrentCamera
cam:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	local vpSize = cam.ViewportSize
	
	local posMin = CreatorCodeFrame.AbsolutePosition
	local posMax = posMin + Vector2.new(CreatorCodeFrame.Size.X.Scale * InnerFrame.AbsoluteSize.X, 0) + Vector2.new(5, 0)
	
	local delta = 0
	if posMax.X >= vpSize.X then
		delta = posMax.X - vpSize.X
	end
	
	CreatorCodeFrame.Size = UDim2.new(CreatorCodeFrame.Size.X.Scale, -delta, CreatorCodeFrame.Size.Y.Scale, 0)
end)



local plrData = game.Players.LocalPlayer:WaitForChild("Player_Data")
plrData:WaitForChild("Creator Code")

local data = CreatorCodes[plrData["Creator Code"].Value]
if data ~= nil then
	TextBox.Text = data.Name
end

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXF47D6C29B07247419E4A285CAE7D11BB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Starter_Pack_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXC62B9A4C9DD14C84B397A31938438B31">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Starter_Pack_Handle.client.lua</string>
						<string name="ScriptGuid">{E942417A-87F3-4D1E-ADC9-61024FF4D053}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local MPS = game:GetService("MarketplaceService")
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")
local SE_F = PG:WaitForChild("Sound_Effects_F")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Sending_F = Channels_F:WaitForChild("Client_Server_F")
local Sending_RF = Sending_F:WaitForChild("RF")
local Sending_Events_F = Sending_F:WaitForChild("Events")
local Bindable_E = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Display_Data_E = Bindable_E:WaitForChild("Display_Data")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Cam = game.Workspace.CurrentCamera

local Starter_Pack_F = script.Parent.Starter_Pack_F
local Button_F = script.Parent.Button_F
local Purchase_B = Starter_Pack_F.Claim_B
local Exit_B = Starter_Pack_F.Exit_B

local Debounce = false
local Debounce_E = false
local Debounce_UI = false
local LockAllUI = true

local FirstOpen = true

local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Remove_UI()
	Disconnect_Cons()
	Starter_Pack_F:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Starter_Pack_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Starter_Pack_F.Visible = false
	Starter_Pack_F.Position = UDim2.new(0.5, 0, 0.675, 0)

	Bindable_E:WaitForChild("Toggle_Side_Buttons"):Fire(true, true)

	Debounce = false
	Debounce_E = false
	Debounce_UI = false

	if FirstOpen == true then
		FirstOpen = false

		Bindable_E:WaitForChild("Open_Daily_Rewards"):Fire()
	end
end

local function Show_UI()
	local Hover_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Hover_SE")
	local Click_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Click_SE")

	local function Reset_Display()
		Disconnect_Cons()
		Starter_Pack_F.Visible = false
		Starter_Pack_F.Position = UDim2.new(0.5, 0, 0.575, 0)

		local Starter_Pack_Blur = game.Lighting:FindFirstChild("Starter_Pack_Blurr")
		if(Starter_Pack_Blur ~= nil)then
			Starter_Pack_Blur:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()

	local function Purchase_Button()
		table.insert(Cons, Purchase_B.MouseButton1Click:Connect(function()
			if(Debounce == true)then
				return
			end
			
			Debounce = true
			if(Click_SE ~= nil)then
				Click_SE:Play()
			end
			TS:Create(Purchase_B, Tween_Click, {Size = UDim2.new(0.21, 0, 0.27075, 0)}):Play()

			MPS:PromptProductPurchase(Plr, 3393273546)
			Bindable_Events_F.MTX_Prompted:Fire()

			wait(0.25)
			Debounce = false
		end))
	end
	Purchase_Button()

	local function Exit_Button_Handle()
		local Def_Size = UDim2.new(0.118, 0,0.2, 0)
		Exit_B.Size = Def_Size

		table.insert(Cons, Exit_B.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				if(Hover_SE ~= nil)then
					Hover_SE:Play()
				end
				Exit_B:TweenSize(UDim2.new(0.09, 0, 0.2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
				Debounce_E = false
			end
		end))

		table.insert(Cons, Exit_B.MouseLeave:Connect(function()
			Exit_B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
		end))

		table.insert(Cons, Exit_B.MouseButton1Click:Connect(function()
			if(Debounce == false)then
				Debounce = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.09, 0, 0.2, 0)}):Play()

				Remove_UI()

				wait(0.25)
				Debounce = false
			end
		end))
	end
	Exit_Button_Handle()

	local function Display_UI()
		Starter_Pack_F.Visible = true
		Starter_Pack_F:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)

		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()

		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Starter_Pack_Blurr"

		Bindable_E:WaitForChild("Toggle_Side_Buttons"):Fire(false, true)

		Debounce_UI = true
		Debounce = false
		Debounce_E = false
	end
	Display_UI()
end

Bindable_E:WaitForChild("Open_Starter_Pack").Event:Connect(function()
	if(Debounce_UI == false)then
		Show_UI()
	else
		Remove_UI()
	end
end)

Button_F.TextButton.Activated:Connect(function()
	Bindable_E:WaitForChild("Open_Starter_Pack"):Fire()
end)

Bindable_E:WaitForChild("Toggle_Side_Buttons").Event:Connect(function(bool)
	if Clothing_Mod.Player_Owns_Gloves_Key(game.Players.LocalPlayer, "G2") == true then
		Button_F.Visible = false
	else
		Button_F.Visible = bool
	end
end)


while game.Workspace:GetAttribute("Remaining_Special_Gloves") == nil or game.Workspace:GetAttribute("Total_Special_Gloves") == nil do
	task.wait()
end

local total = game.Workspace:GetAttribute("Total_Special_Gloves")
local remaining = game.Workspace:GetAttribute("Remaining_Special_Gloves")

task.spawn(function()
	while true do
		remaining = total - game.Workspace:GetAttribute("Remaining_Special_Gloves")
		
		Starter_Pack_F.Remaining.Text = `{remaining} gloves left`
		Starter_Pack_F.Remaining.CanvasGroup.Bar.Position = UDim2.new(-0.9 + 0.9 * (remaining / total), 0, 0, 0)
		
		task.wait(1)
	end
end)

task.delay(3, function()
	if remaining == total or Clothing_Mod.Player_Owns_Gloves_Key(game.Players.LocalPlayer, "G2") == true then
		FirstOpen = false

		Bindable_E:WaitForChild("Open_Daily_Rewards"):Fire()
	else
		Show_UI()
	end
end)

if Clothing_Mod.Player_Owns_Gloves_Key(game.Players.LocalPlayer, "G2") == true then
	Button_F.Visible = false
end

Channels_F.Server_Client_F.Events.Hide_Special_Gloves_Frame.OnClientEvent:Connect(function()
	Remove_UI()
	if Clothing_Mod.Player_Owns_Gloves_Key(game.Players.LocalPlayer, "G2") == true then
		Button_F.Visible = false
	end
end)

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX0A652EEE2ADF4CE69BEC673A3722F871">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Tutorial_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX8FEF9FC63A904984A35D68C9C1360488">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Tutorial_UI_Handler.client.lua</string>
						<string name="ScriptGuid">{3BEA7CD8-B9DB-4918-83FB-D869B8591CAE}</string>
						<ProtectedString name="Source"><![CDATA[
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Frame = script.Parent.Tuto_Frame
local Message = script.Parent.Tuto_Message
local OK_Button = Message:FindFirstChild("Tuto_OK",true)
local Commands_Panel = script.Parent.Commands_Frame

Bindable_Events_F.End_Tutorial.Event:Connect(function()
	Frame.Visible = false
	Message.Visible = false
end)

Bindable_Events_F.Display_Tuto_Message.Event:Connect(function(title, message)
	Frame.Visible = true
	Message:FindFirstChild("Tuto_Title",true).Text = title
	Message:FindFirstChild("Tuto_Message",true).Text = message
	Message.Visible = true
end)

OK_Button.MouseButton1Click:Connect(function()
	Message.Visible = false
	Bindable_Events_F:WaitForChild("Next_Tutorial_Step"):Fire()
end)

Bindable_Events_F:WaitForChild("Toggle_Tutorial_Display").Event:Connect(function(Should_Show)	
	OK_Button.Visible = Should_Show
end)

Bindable_Events_F:WaitForChild("Toggle_Commands_Panel").Event:Connect(function(Should_Show)
	if Should_Show == nil then
		Should_Show = not Commands_Panel.Visible
	end
	
	Commands_Panel.Visible = Should_Show
	Message.Visible = not Should_Show
end)

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX0A1BA61F8076441BB0131C3F2CF4A0D9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Changelog_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXD669BE980FD440ED8A7D007DFE28866B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Changelog_Handle.client.lua</string>
						<string name="ScriptGuid">{4B353C97-E652-450E-8ABA-32F317ADA0A5}</string>
						<ProtectedString name="Source"><![CDATA[local RS = game:GetService("ReplicatedStorage")
local gui = script.Parent
local frame = gui:WaitForChild("Main_F")
local TweenService = game:GetService("TweenService")

--------------------------------------------------------------------
-- Open/Close UI
--------------------------------------------------------------------
local Events = RS:WaitForChild("Channels_F"):WaitForChild("Bindable_F"):WaitForChild("Events")
local OpenEvt = Events:WaitForChild("Open_Changelog")
local CloseEvt = Events:WaitForChild("Close_Changelog")

local Cam = workspace.CurrentCamera
local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
local Debounce_UI = false

-- sound mod like in Daily Reward
local Plr = game.Players.LocalPlayer
local Data_Mods_F = RS:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))

local Hover_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Hover_SE")
local Click_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Click_SE")
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)

--------------------------------------------------------------------
-- Changelog Carousel
--------------------------------------------------------------------
local bodyFrame = frame:WaitForChild("Body")
local dataFrame = bodyFrame:WaitForChild("Data_F") 
local leftBtn = frame:WaitForChild("Left_B")
local rightBtn = frame:WaitForChild("Right_B")
local versionLabel = frame:WaitForChild("HeaderHolder"):WaitForChild("Header"):WaitForChild("HeaderContent"):WaitForChild("Title")

local changelogData = require(RS:WaitForChild("Data_Mods_F"):WaitForChild("Changelog_Mod")) 

-- limiter  3 versions max
local versions = {}
for i = 1, math.min(3, #changelogData) do
	table.insert(versions, changelogData[i])
end

local currentIndex = 1
local maxItems = 8

local function displayVersion(index)
	local data = versions[index]
	if not data then return end

	-- maj du label version
	versionLabel.Text = data.version

	-- vider les anciens enfants
	for _, child in ipairs(dataFrame:GetChildren()) do
		if child:IsA("TextLabel") then
			child:Destroy()
		end
	end

	-- crer jusqu 8 items
	for i, change in ipairs(data.changes) do
		if i > maxItems then break end
		local item = Instance.new("TextLabel")
		item.Size = UDim2.new(1, 0, 0.8, 0)
		item.BackgroundTransparency = 1
		item.TextXAlignment = Enum.TextXAlignment.Left
		item.Font = Enum.Font.Nunito
		item.TextSize = 44
		item.TextScaled = true
		item.TextColor3 = Color3.new(255, 255, 255)
		item.Text = change
		item.Parent = dataFrame
	end

	-- gestion visibilit boutons
	if #versions <= 1 then
		leftBtn.Visible = false
		rightBtn.Visible = false
	else
		leftBtn.Visible = index > 1
		rightBtn.Visible = index < #versions
	end
end


local function goLeft()
	if Click_SE then Click_SE:Play() end
	currentIndex = currentIndex - 1
	if currentIndex < 1 then currentIndex = #versions end
	displayVersion(currentIndex)
end

local function goRight()
	if Click_SE then Click_SE:Play() end
	currentIndex = currentIndex + 1
	if currentIndex > #versions then currentIndex = 1 end
	displayVersion(currentIndex)
end

leftBtn.MouseButton1Click:Connect(goLeft)
rightBtn.MouseButton1Click:Connect(goRight)

--------------------------------------------------------------------
-- UI Animations
--------------------------------------------------------------------
local function Remove_UI()
	frame:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TweenService:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
	task.wait(0.25)
	local Blur = game.Lighting:FindFirstChild("Rewards_Blurr")
	if Blur then Blur:Destroy() end
	Cam.FieldOfView = 70
	gui.Enabled = false
	frame.Position = UDim2.new(0.5, 0, 0.675, 0)
	Events:WaitForChild("Toggle_Side_Buttons"):Fire(true, true)
	Debounce_UI = false

	-- warn topmenu
	local EndChangelog = Events:FindFirstChild("End_Changelog")
	if EndChangelog then
		EndChangelog:Fire()
	end
end

local function Display_UI()
	gui.Enabled = true
	frame.Position = UDim2.new(0.5, 0, 0.675, 0)
	frame.Visible = true
	frame:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TweenService:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
	local Blur = Instance.new("BlurEffect")
	Blur.Name = "Rewards_Blurr"
	Blur.Parent = game.Lighting
	Events:WaitForChild("Toggle_Side_Buttons"):Fire(false, true)
	Debounce_UI = true

	-- afficher premire version au lancement
	currentIndex = 1
	displayVersion(currentIndex)
end

-- close button avec hover + click feedback
local closeBtn = frame:FindFirstChild("Close")
if closeBtn then
	local Def_Size = closeBtn.Size

	closeBtn.MouseEnter:Connect(function()
		if Hover_SE then Hover_SE:Play() end
		closeBtn:TweenSize(
			UDim2.new(Def_Size.X.Scale * 1.15, 0, Def_Size.Y.Scale * 1.15, 0),
			Enum.EasingDirection.Out,
			Enum.EasingStyle.Sine,
			0.125,
			true
		)
	end)

	closeBtn.MouseLeave:Connect(function()
		closeBtn:TweenSize(
			Def_Size,
			Enum.EasingDirection.Out,
			Enum.EasingStyle.Sine,
			0.125,
			true
		)
	end)

	closeBtn.MouseButton1Click:Connect(function()
		if Click_SE then Click_SE:Play() end
		TweenService:Create(closeBtn, Tween_Click, {
			Size = UDim2.new(Def_Size.X.Scale * 0.75, 0, Def_Size.Y.Scale * 0.75, 0)
		}):Play()
		Remove_UI()
	end)
end

OpenEvt.Event:Connect(function()
	if not Debounce_UI then
		Display_UI()
	end
end)

CloseEvt.Event:Connect(function()
	if Debounce_UI then
		Remove_UI()
	end
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXE2BD9C5B31C746C0A47A44795075DBEF">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Offer_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX2F93B3EF232A4843B0C9DFBB161EA972">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Offer_Handle.client.lua</string>
						<string name="ScriptGuid">{75AA421A-E621-43DF-B5A5-1F255533F5C4}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")
local SE_F = PG:WaitForChild("Sound_Effects_F")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")

local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Sending_F = Channels_F:WaitForChild("Client_Server_F")
local Sending_RF = Sending_F:WaitForChild("RF")
local Sending_Events_F = Sending_F:WaitForChild("Events")
local Bindable_E = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Display_Data_E = Bindable_E:WaitForChild("Display_Data")

local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Offers = game.ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Offers")

local GetActiveOffers = Offers:WaitForChild("GetActiveOffers")
local RequestPurchase = Offers:WaitForChild("RequestPurchase")
local SendOfferToClint = Offers:FindFirstChild("SendOfferToClint")

local Cam = game.Workspace.CurrentCamera

local Main_Frame = script.Parent:WaitForChild("Main_F")

local HeaderHolder = Main_Frame:WaitForChild("HeaderHolder")
local Exit_B = HeaderHolder:WaitForChild("Exit_B")

local Body = Main_Frame:WaitForChild("Body")

local Content = Body:WaitForChild("Stroke"):WaitForChild("Content")
local Purchase_B = Content:WaitForChild("Claim_B")

local oldPriceTxt = Content:WaitForChild("OldPrice")
local newPriceTxt = Content:WaitForChild("NewPrice")
local ramingTimeTxt = Content:WaitForChild("TextLabel"):WaitForChild("TimeRaming")
local amountTxt = Content:WaitForChild("Amount")
local DiscountTxt = Content:WaitForChild("Discount")

local GetNowTxt = Purchase_B:WaitForChild("Get"):WaitForChild("txt")

local HeaderHolder = Main_Frame:WaitForChild("HeaderHolder")
local Header = HeaderHolder:WaitForChild("Header")
local HeaderContent = Header:WaitForChild("HeaderContent")
local Title = HeaderContent:WaitForChild("Title")

local ItemIcon = Content:WaitForChild("TextLabel"):WaitForChild("Icon")

local ItemVPIconFrame = Content:WaitForChild("TextLabel"):WaitForChild("ViewportFrame")
local ItemVPIconWM = ItemVPIconFrame:WaitForChild("WorldModel")


local Debounce = false
local Debounce_E = false
local Debounce_UI = false
local LockAllUI = true

local FirstOpen = true

local currentOffer -- table with productKey, endsAt, etc.
local countdownConn
local pulseTween
local isSeverCall=false
local Tween_Cam = TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Remove_UI()
	Disconnect_Cons()
	Main_Frame:TweenPosition(UDim2.new(0.5, 0, 0.675, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
	TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()

	wait(0.25)

	local Blur = game.Lighting:FindFirstChild("Starter_Pack_Blurr")
	if(Blur ~= nil)then
		Blur:Destroy()
	end
	Cam.FieldOfView = 70

	Main_Frame.Visible = false
	Main_Frame.Position = UDim2.new(0.5, 0, 0.675, 0)

	Bindable_E:WaitForChild("Toggle_Side_Buttons"):Fire(true, true)

	Debounce = false
	Debounce_E = false
	Debounce_UI = false

	if FirstOpen == true then
		FirstOpen = false
		Bindable_E:WaitForChild("Open_Daily_Rewards"):Fire()
	end
end

local countdownThread

local function stopCountdown()
	if countdownThread then
		task.cancel(countdownThread)
		countdownThread = nil
	end
end

local function formatDHMS(rem)
	rem = math.max(0, rem)
	local d = math.floor(rem / 86400)
	local h = math.floor((rem % 86400) / 3600)
	local m = math.floor((rem % 3600) / 60)
	local s = rem % 60
	if d > 0 then
		return string.format("LIMITED TIME OFFER %dd %dh %dm", d, h, m)
	elseif h > 0 then
		return string.format("LIMITED TIME OFFER %dh %dm %ds", h, m, s)
	else
		return string.format("LIMITED TIME OFFER %dm %ds", m, s)
	end
end

local function startCountdown()
	stopCountdown()
	local endsAt = currentOffer and currentOffer.EndsAt
	if typeof(endsAt) ~= "number" or endsAt <= 0 then
		ramingTimeTxt.Text = ""
		return
	end

	countdownThread = task.spawn(function()
		while true do
			local now = os.time()
			local rem = math.max(0, math.floor(endsAt - now))

			if rem <= 0 then
				ramingTimeTxt.Text = "Offer ended"
				stopCountdown()
				return
			end

			ramingTimeTxt.Text = formatDHMS(rem)
			if not script.Parent then
				stopCountdown()
				return
			end
			task.wait(1)
		end
	end)
end




local function SetUpViewPortIcon(offer)
	local function SetPosition(ObjectMesh,pos)
		local rotOnly = ObjectMesh.CFrame - ObjectMesh.CFrame.Position
		ObjectMesh.CFrame = CFrame.new(pos) * rotOnly
	end
	local function AnchoredModel(model)
		for _, descendant in ipairs(model:GetDescendants()) do
			if descendant:IsA("BasePart") then
				descendant.Anchored = true
			end
		end
	end
	
	ItemVPIconWM:ClearAllChildren()
	local oldCam = ItemVPIconFrame:FindFirstChildOfClass("Camera")
	if oldCam then
		oldCam:Destroy()
	end
	
	
	
	local LeftHandPos= Vector3.new(-0.741, 0, -1.972)
	local RightHandPos= Vector3.new(0.061, -0, -1.972)

	local ShortsModelPostion= Vector3.new(0, 0.8, -2)
	
	local ClothsFolder=game.ReplicatedStorage.Clothing_F
	local ClothItemsParent
	if offer.Kind == "Shorts" then
		ClothItemsParent = ClothsFolder:WaitForChild("Shorts_F")
	else
		ClothItemsParent = ClothsFolder:WaitForChild("Gloves_F")
	end
	local showableItem = ClothItemsParent:FindFirstChild(offer.Title)
	if showableItem then
		local showableItemModel = showableItem:Clone()
		showableItemModel.Parent=ItemVPIconWM
		AnchoredModel(showableItemModel)
		
		local camera = Instance.new("Camera")
		ItemVPIconFrame.CurrentCamera = camera
		camera.Parent = ItemVPIconFrame

		-- Position camera
		 -- reset model at origin
		--local modelCFrame, size = showableItemModel:GetBoundingBox()
		--camera.CFrame = CFrame.new(modelCFrame.Position + Vector3.new(0, size.Y, size.Z*2), modelCFrame.Position)
		camera.CFrame=CFrame.new(0,0,0)
		--showableItemModel:PivotTo(CFrame.new(0,0,0) * CFrame.Angles(0, math.rad(25), 0))

		if offer.Kind == "Shorts" then
			
			showableItemModel:PivotTo(CFrame.new(ShortsModelPostion) *  CFrame.Angles(math.rad(-90), 0, 0) * CFrame.Angles(0, math.rad(180), math.rad(180)))
		else
			showableItemModel:PivotTo(CFrame.new(0,0,0))
			SetPosition(showableItemModel:FindFirstChild("LeftHand"),LeftHandPos)
			SetPosition(showableItemModel:FindFirstChild("RightHand"),RightHandPos)

		end
	end
end

local function fillUIFromOffer(offer)
	
	if  offer.Kind=="Gloves" or  offer.Kind=="Shorts" then
		ItemVPIconFrame.Visible=true
		ItemIcon.Visible=false
		SetUpViewPortIcon(offer)
	else
		ItemVPIconFrame.Visible=false
		ItemIcon.Visible=true
		ItemIcon.Image   = offer.ItemIcon or ""
	end
	
	if offer.Amount == nil or offer.Amount == "" then
		amountTxt.Visible = false
	else
		amountTxt.Visible = true
		amountTxt.Text   = tostring(offer.Amount or 0)
	end

	--if offer.Kind=="Shorts" or offer.Kind=="Gloves" then
		newPriceTxt.IngameCU.Visible=true
		oldPriceTxt.IngameCU.Visible=true
		newPriceTxt.RobloxCU.Visible=false
		oldPriceTxt.RobloxCU.Visible=false
	--else
	--	newPriceTxt.RobloxCU.Visible=true
	--	oldPriceTxt.RobloxCU.Visible=true
	--	newPriceTxt.IngameCU.Visible=false
	--	oldPriceTxt.IngameCU.Visible=false
	--end
	Title.Text = string.upper(tostring(offer.Title or "Special Offer"))
	newPriceTxt.Text = tostring(offer.NewPrice or "")
	oldPriceTxt.Text = tostring(offer.OldPrice or "")
	DiscountTxt.Text = tostring(math.floor(((offer.OldPrice - offer.NewPrice) / (offer.OldPrice))*100)or 0).."%"
	startCountdown(offer.EndsAt or 0)
end

SendOfferToClint.OnClientEvent:Connect(function(offer)
	isSeverCall=true
	currentOffer = offer
	fillUIFromOffer(currentOffer)
	Bindable_E:WaitForChild("Open_Starter_Pack"):Fire()
end)

local function GetOfferPanel()
	local offers = GetActiveOffers:InvokeServer()
	if not offers or #offers == 0 then
		return false
	end
	currentOffer = offers[1]
	fillUIFromOffer(currentOffer)
	return true
end

local function ensureUIScale(guiObject)
	local s = guiObject:FindFirstChildOfClass("UIScale")
	if not s then
		s = Instance.new("UIScale")
		s.Scale = 1
		s.Parent = guiObject
	end
	return s
end

local function startPulse()
	if pulseTween and pulseTween.PlaybackState == Enum.PlaybackState.Playing then return end
	local s = ensureUIScale(GetNowTxt)
	local ti = TweenInfo.new(0.7, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, math.huge, true, 0)
	pulseTween = TS:Create(s, ti, { Scale = 1.05 })
	pulseTween:Play()
end

local function stopPulse()
	if pulseTween then
		pulseTween:Cancel()
		pulseTween = nil
	end
	local s = GetNowTxt:FindFirstChildOfClass("UIScale")
	if s then s.Scale = 1 end
end

local function Show_UI()
	if not isSeverCall then
		if not GetOfferPanel() then return end
	end

	startPulse()
	local Hover_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Hover_SE")
	local Click_SE = Sound_Effect_Mod.Get_SE_Object(Plr, "Click_SE")

	local function Reset_Display()
		Disconnect_Cons()
		Main_Frame.Visible = false
		Main_Frame.Position = UDim2.new(0.5, 0, 0.675, 0)
		local Starter_Pack_Blur = game.Lighting:FindFirstChild("Starter_Pack_Blurr")
		if(Starter_Pack_Blur ~= nil)then
			Starter_Pack_Blur:Destroy()
			Cam.FieldOfView = 70
		end
	end
	Reset_Display()

	local function Purchase_Button()
		table.insert(Cons, Purchase_B.MouseButton1Click:Connect(function()
			if Debounce == true then return end
			Debounce = true
			if Click_SE then Click_SE:Play() end
			TS:Create(Purchase_B, Tween_Click, {Size = UDim2.new(0.21, 0, 0.27075, 0)}):Play()
			if currentOffer and currentOffer.ProductKey then
				if os.time() > (currentOffer.EndsAt or 0) then
					Display_Data_E:Fire("? Offer is Expired!", Color3.new(1, 0, 0))
					return
				end
				RequestPurchase:FireServer(currentOffer.Kind, currentOffer.ProductKey)
			else
				Display_Data_E:Fire("? Offer is not available!", Color3.new(1, 0, 0))
			end
			task.wait(0.25)
			Debounce = false
			Bindable_E:WaitForChild("Open_Starter_Pack"):Fire()
		end))
	end
	Purchase_Button()

	local function Exit_Button_Handle()
		local Def_Size = UDim2.new(0.118, 0,0.2, 0)
		Exit_B.Size = Def_Size
		table.insert(Cons, Exit_B.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				if(Hover_SE ~= nil)then
					Hover_SE:Play()
				end
				Exit_B:TweenSize(UDim2.new(0.09, 0, 0.2, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
				Debounce_E = false
			end
		end))
		table.insert(Cons, Exit_B.MouseLeave:Connect(function()
			Exit_B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.125, true, nil)
		end))
		table.insert(Cons, Exit_B.MouseButton1Click:Connect(function()
			if(Debounce == false)then
				Debounce = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				TS:Create(Exit_B, Tween_Click, {Size = UDim2.new(0.09, 0, 0.2, 0)}):Play()
				Remove_UI()
				stopPulse()
				stopCountdown()
				wait(0.25)
				Debounce = false
			end
		end))
	end
	Exit_Button_Handle()

	local function Display_UI()
		Main_Frame.Visible = true
		Main_Frame:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
		TS:Create(Cam, Tween_Cam, {FieldOfView = 40}):Play()
		local Blur = Instance.new("BlurEffect", game.Lighting)
		Blur.Name = "Starter_Pack_Blurr"
		Bindable_E:WaitForChild("Toggle_Side_Buttons"):Fire(false, true)
		Debounce_UI = true
		Debounce = false
		Debounce_E = false
	end
	Display_UI()
end

Bindable_E:WaitForChild("Open_Starter_Pack").Event:Connect(function()
	if(Debounce_UI == false)then
		Show_UI()
	else
		Remove_UI()
	end
end)

if game.Players.LocalPlayer.Character then 
	task.delay(3, function()
		Bindable_E:WaitForChild("Open_Starter_Pack"):Fire()
	end)
end

game.Players.LocalPlayer.CharacterAdded:Connect(function()
	Bindable_E:WaitForChild("Open_Starter_Pack"):Fire()
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX6BA73AEC4945459EBBDF44538E2FCD22">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ReplicatedStorage</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXD56665F5AC1D4B76A2D6C1F7BA22FDA8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CreatorCodes.lua</string>
					<string name="ScriptGuid">{795104F2-558E-46BC-A927-78ED8E4046A3}</string>
					<ProtectedString name="Source"><![CDATA[--[[
bye
SLUSH
AEBID
NM
SkiluaOnYTB
Akamuro
JkChimera
Kayzarox
Unchained
]]

return {
	Creator_1 = {
		Name = "bye",
	},
	Creator_2 = {
		Name = "AEBID",
	},
	Creator_3 = {
		Name = "NM",
	},
	Creator_4 = {
		Name = "SkiluaOnYTB",
	},
	Creator_5 = {
		Name = "Akamuro",
	},
	Creator_6 = {
		Name = "JkChimera",
	},
	Creator_7 = {
		Name = "Kayzarox",
	},
	Creator_8 = {
		Name = "Unchained",
	},
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXBE2F1189CA0F4573B2679293D4734204">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GameAnalytics.lua</string>
					<string name="ScriptGuid">{5D568694-0D62-4521-828D-84CDEC96DC91}</string>
					<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

--[[
	This script determines if we should load gameanalytics server or client.
]]

local isServer = RunService:IsServer()

if isServer then
	return require(script.GameAnalytics)
else
	return require(script.GameAnalyticsClient)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX65B404055DF74A94B51C2EC8432F8935">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">GameAnalytics</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX6FD7195E52AC4E6387954D184E107785">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GameAnalytics.lua</string>
						<string name="ScriptGuid">{0980C9D4-3C79-4EAB-BFB2-C97F4075780D}</string>
						<ProtectedString name="Source"><![CDATA[local GAResourceFlowType = require(script.GAResourceFlowType)
local GAProgressionStatus = require(script.GAProgressionStatus)
local GAErrorSeverity = require(script.GAErrorSeverity)

local ga = {
	EGAResourceFlowType = GAResourceFlowType,
	EGAProgressionStatus = GAProgressionStatus,
	EGAErrorSeverity = GAErrorSeverity,
}

local types = require(script.Types)
local logger = require(script.Logger)
local threading = require(script.Threading)
local state = require(script.State)
local validation = require(script.Validation)
local store = require(script.Store)
local events = require(script.Events)
local utilities = require(script.Utilities)
local Players = game:GetService("Players")
local MKT = game:GetService("MarketplaceService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalizationService = game:GetService("LocalizationService")
local ScriptContext = game:GetService("ScriptContext")
local Postie = require(script.Postie)
local OnPlayerReadyEvent
local ProductCache = {}
local ONE_HOUR_IN_SECONDS = 3600
local MaxErrorsPerHour = 10
local ErrorDS = {}
local errorCountCache = {}
local errorCountCacheKeys = {}

local InitializationQueue = {}
local InitializationQueueByUserId = {}

type BusinessEventOptions = types.BusinessEventOptions
type ResourceEventOptions = types.ResourceEventOptions
type ProgressionEventOptions = types.ProgressionEventOptions
type DesignEventOptions = types.DesignEventOptions
type ErrorEventOptions = types.ErrorEventOptions
type CustomDimension = types.CustomDimension
type ProductInfo = types.ProductInfo
type ProcessReceiptInfo = types.ProcessReceiptInfo
type TeleportData = types.TeleportData
type RemoteConfigs = types.RemoteConfigs
type GameAnalyticsOptions = types.GameAnalyticsOptions

local function addToInitializationQueue(func, ...)
	if InitializationQueue ~= nil then
		table.insert(InitializationQueue, {
			Func = func,
			Args = { ... },
		})

		logger:i("Added event to initialization queue")
	else
		--This should never happen
		logger:w("Initialization queue already cleared.")
	end
end

local function addToInitializationQueueByUserId(userId, func, ...)
	if not ga:isPlayerReady(userId) then
		if InitializationQueueByUserId[userId] == nil then
			InitializationQueueByUserId[userId] = {}
		end

		table.insert(InitializationQueueByUserId[userId], {
			Func = func,
			Args = { ... },
		})

		logger:i("Added event to player initialization queue")
	else
		--This should never happen
		logger:w("Player initialization queue already cleared.")
	end
end

-- local functions
local function isSdkReady(options)
	local playerId = options["playerId"] or nil
	local needsInitialized = options["needsInitialized"] or true
	local shouldWarn = options["shouldWarn"] or false
	local message = options["message"] or ""

	-- Is SDK initialized
	if needsInitialized and not state.Initialized then
		if shouldWarn then
			logger:w(message .. " SDK is not initialized")
		end

		return false
	end

	-- Is SDK enabled
	if needsInitialized and playerId and not state:isEnabled(playerId) then
		if shouldWarn then
			logger:w(message .. " SDK is disabled")
		end

		return false
	end

	-- Is session started
	if needsInitialized and playerId and not state:sessionIsStarted(playerId) then
		if shouldWarn then
			logger:w(message .. " Session has not started yet")
		end

		return false
	end

	return true
end

function ga:configureAvailableCustomDimensions01(customDimensions: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available custom dimensions must be set before SDK is initialized")
		return
	end

	state:setAvailableCustomDimensions01(customDimensions)
end

function ga:configureAvailableCustomDimensions02(customDimensions: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available custom dimensions must be set before SDK is initialized")
		return
	end

	state:setAvailableCustomDimensions02(customDimensions)
end

function ga:configureAvailableCustomDimensions03(customDimensions: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available custom dimensions must be set before SDK is initialized")
		return
	end

	state:setAvailableCustomDimensions03(customDimensions)
end

function ga:configureAvailableResourceCurrencies(resourceCurrencies: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available resource currencies must be set before SDK is initialized")
		return
	end

	events:setAvailableResourceCurrencies(resourceCurrencies)
end

function ga:configureAvailableResourceItemTypes(resourceItemTypes: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available resource item types must be set before SDK is initialized")
		return
	end

	events:setAvailableResourceItemTypes(resourceItemTypes)
end

function ga:configureBuild(build: string)
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Build version must be set before SDK is initialized.")
		return
	end

	events:setBuild(build)
end

function ga:configureAvailableGamepasses(availableGamepasses: { string })
	if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
		logger:w("Available gamepasses must be set before SDK is initialized.")
		return
	end

	state:setAvailableGamepasses(availableGamepasses)
end

function ga:startNewSession(player: Player, gaData)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end

		if not state.Initialized then
			logger:w("Cannot start new session. SDK is not initialized yet.")
			return
		end

		state:startNewSession(player, gaData)
	end)
end

function ga:endSession(playerId: number)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		state:endSession(playerId)
	end)
end

function ga:filterForBusinessEvent(text: string)
	return string.gsub(text, "[^A-Za-z0-9%s%-_%.%(%)!%?]", "")
end

function ga:addBusinessEvent(playerId: number | BusinessEventOptions, options: BusinessEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add business event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addBusinessEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addBusinessEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local amount = options["amount"] or 0
		local itemType = options["itemType"] or ""
		local itemId = options["itemId"] or ""
		local cartType = options["cartType"] or ""
		local USDSpent = math.floor((amount * 0.7) * 0.35)
		local gamepassId = options["gamepassId"] or nil
		local customFields = options["customFields"]

		events:addBusinessEvent(playerId, "USD", USDSpent, itemType, itemId, cartType, customFields)

		if itemType == "Gamepass" and cartType ~= "Website" then
			local player = Players:GetPlayerByUserId(playerId)
			local playerData = store:GetPlayerDataFromCache(playerId)
			if not playerData.OwnedGamepasses then
				playerData.OwnedGamepasses = {}
			end
			table.insert(playerData.OwnedGamepasses, gamepassId)
			store.PlayerCache[playerId] = playerData
			store:SavePlayerData(player)
		end
	end)
end

function ga:addResourceEvent(playerId: number | ResourceEventOptions, options: ResourceEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add resource event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addResourceEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addResourceEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local flowType = options["flowType"] or 0
		local currency = options["currency"] or ""
		local amount = options["amount"] or 0
		local itemType = options["itemType"] or ""
		local itemId = options["itemId"] or ""
		local customFields = options["customFields"]

		events:addResourceEvent(playerId, flowType, currency, amount, itemType, itemId, customFields)
	end)
end

function ga:addProgressionEvent(playerId: number | ProgressionEventOptions, options: ProgressionEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add progression event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addProgressionEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addProgressionEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local progressionStatus = options["progressionStatus"] or 0
		local progression01 = options["progression01"] or ""
		local progression02 = options["progression02"] or nil
		local progression03 = options["progression03"] or nil
		local score = options["score"] or nil
		local customFields = options["customFields"]

		events:addProgressionEvent(
			playerId,
			progressionStatus,
			progression01,
			progression02,
			progression03,
			score,
			customFields
		)
	end)
end

function ga:addDesignEvent(playerId: number | DesignEventOptions, options: DesignEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add design event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addDesignEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addDesignEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local eventId = options["eventId"] or ""
		local value = options["value"] or nil
		local customFields = options["customFields"]

		events:addDesignEvent(playerId, eventId, value, customFields)
	end)
end

function ga:addErrorEvent(playerId: number | ErrorEventOptions, options: ErrorEventOptions?)
	threading:performTaskOnGAThread(function()
		if not state:isEventSubmissionEnabled() then
			return
		end
		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = false,
				message = "Could not add error event",
			})
		then
			if playerId then
				addToInitializationQueueByUserId(playerId, ga.addErrorEvent, ga, playerId, options)
			else
				addToInitializationQueue(ga.addErrorEvent, ga, playerId, options)
			end
			return
		end

		if not options then
			return
		end

		-- Send to events
		local severity = options["severity"] or 0
		local message = options["message"] or ""
		local customFields = options["customFields"]

		events:addErrorEvent(playerId, severity, message, customFields)
	end)
end

function ga:setEnabledDebugLog(flag: boolean)
	if RunService:IsStudio() then
		if flag then
			logger:setDebugLog(flag)
			logger:i("Debug logging enabled")
		else
			logger:i("Debug logging disabled")
			logger:setDebugLog(flag)
		end
	else
		logger:i("setEnabledDebugLog can only be used in studio")
	end
end

function ga:setEnabledInfoLog(flag: boolean)
	if flag then
		logger:setInfoLog(flag)
		logger:i("Info logging enabled")
	else
		logger:i("Info logging disabled")
		logger:setInfoLog(flag)
	end
end

function ga:setEnabledVerboseLog(flag: boolean)
	if flag then
		logger:setVerboseLog(flag)
		logger:ii("Verbose logging enabled")
	else
		logger:ii("Verbose logging disabled")
		logger:setVerboseLog(flag)
	end
end

function ga:setEnabledEventSubmission(flag: boolean)
	threading:performTaskOnGAThread(function()
		if flag then
			state:setEventSubmission(flag)
			logger:i("Event submission enabled")
		else
			logger:i("Event submission disabled")
			state:setEventSubmission(flag)
		end
	end)
end

function ga:setCustomDimension01(playerId: number | CustomDimension, dimension: CustomDimension?)
	threading:performTaskOnGAThread(function()
		if not validation:validateDimension(state._availableCustomDimensions01, dimension) then
			logger:w(
				"Could not set custom01 dimension value to '"
					.. (dimension or "")
					.. "'. Value not found in available custom01 dimension values"
			)
			return
		end

		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = true,
				message = "Could not set custom01 dimension",
			})
		then
			return
		end

		state:setCustomDimension01(playerId, dimension)
	end)
end

function ga:setCustomDimension02(playerId: number | CustomDimension, dimension: CustomDimension?)
	threading:performTaskOnGAThread(function()
		if not validation:validateDimension(state._availableCustomDimensions02, dimension) then
			logger:w(
				"Could not set custom02 dimension value to '"
					.. (dimension or "")
					.. "'. Value not found in available custom02 dimension values"
			)
			return
		end

		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = true,
				message = "Could not set custom02 dimension",
			})
		then
			return
		end

		state:setCustomDimension02(playerId, dimension)
	end)
end

function ga:setCustomDimension03(playerId: number | CustomDimension, dimension: CustomDimension?)
	threading:performTaskOnGAThread(function()
		if not validation:validateDimension(state._availableCustomDimensions03, dimension) then
			logger:w(
				"Could not set custom03 dimension value to '"
					.. (dimension or "")
					.. "'. Value not found in available custom03 dimension values"
			)
			return
		end

		if
			not isSdkReady({
				playerId = playerId,
				needsInitialized = true,
				shouldWarn = true,
				message = "Could not set custom03 dimension",
			})
		then
			return
		end

		state:setCustomDimension03(playerId, dimension)
	end)
end

function ga:setEnabledReportErrors(flag: boolean)
	threading:performTaskOnGAThread(function()
		state.ReportErrors = flag
	end)
end

function ga:setEnabledCustomUserId(flag: boolean)
	threading:performTaskOnGAThread(function()
		state.UseCustomUserId = flag
	end)
end

function ga:setEnabledAutomaticSendBusinessEvents(flag: boolean)
	threading:performTaskOnGAThread(function()
		state.AutomaticSendBusinessEvents = flag
	end)
end

function ga:addGameAnalyticsTeleportData(playerIds: { number }, teleportData: TeleportData)
	local gameAnalyticsTeleportData = {}
	for _, playerId in ipairs(playerIds) do
		local PlayerData = store:GetPlayerDataFromCache(playerId)
		PlayerData.PlayerTeleporting = true
		local data = {
			["SessionID"] = PlayerData.SessionID,
			["Sessions"] = PlayerData.Sessions,
			["SessionStart"] = PlayerData.SessionStart,
		}

		gameAnalyticsTeleportData[tostring(playerId)] = data
	end

	teleportData["gameanalyticsData"] = gameAnalyticsTeleportData

	return teleportData
end

function ga:getRemoteConfigsValueAsString(playerId: number | RemoteConfigs, options: RemoteConfigs)
	local key = options["key"] or ""
	local defaultValue = options["defaultValue"] or nil
	return state:getRemoteConfigsStringValue(playerId, key, defaultValue)
end

function ga:isRemoteConfigsReady(playerId: number)
	return state:isRemoteConfigsReady(playerId)
end

function ga:getRemoteConfigsContentAsString(playerId: number)
	return state:getRemoteConfigsContentAsString(playerId)
end

function ga:PlayerJoined(Player: Player)
	local joinData = Player:GetJoinData()
	local teleportData = joinData.TeleportData
	local gaData = nil

	--Variables
	local PlayerData = store:GetPlayerData(Player)

	if teleportData and typeof(teleportData) == "table" then
		gaData = teleportData.gameanalyticsData and teleportData.gameanalyticsData[tostring(Player.UserId)]
	end

	local pd = store:GetPlayerDataFromCache(Player.UserId)
	if pd then
		if gaData then
			pd.SessionID = gaData.SessionID
			pd.SessionStart = gaData.SessionStart
		end
		pd.PlayerTeleporting = false
		return
	end

	local PlayerPlatform = "unknown"
	local isGetPlatformSuccessful, platform = Postie.invokeClient("getPlatform", Player, 5)
	if isGetPlatformSuccessful then
		PlayerPlatform = platform
	end

	--Fill Data
	for key, value in pairs(store.BasePlayerData) do
		if PlayerData[key] then
			continue
		end

		if typeof(value) == "table" then
			PlayerData[key] = utilities:copyTable(value)
		else
			PlayerData[key] = value
		end
	end

	local countryCodeResult, countryCode = pcall(function()
		return LocalizationService:GetCountryRegionForPlayerAsync(Player)
	end)

	if countryCodeResult then
		PlayerData.CountryCode = countryCode
	end

	store.PlayerCache[Player.UserId] = PlayerData

	PlayerData.Platform = (PlayerPlatform == "Console" and "uwp_console")
		or (PlayerPlatform == "Mobile" and "uwp_mobile")
		or (PlayerPlatform == "Desktop" and "uwp_desktop")
		or "uwp_desktop"
	PlayerData.OS = PlayerData.Platform .. " 0.0.0"

	if not countryCodeResult then
		events:addSdkErrorEvent(
			Player.UserId,
			"event_validation",
			"player_joined",
			"string_empty_or_null",
			"country_code",
			""
		)
	end

	local PlayerCustomUserId = ""
	if state.UseCustomUserId then
		local isGetCustomUserIdSuccessful, customUserId = Postie.invokeClient("getCustomUserId", Player, 5)
		if isGetCustomUserIdSuccessful then
			PlayerCustomUserId = customUserId
		end
	end

	if not utilities:isStringNullOrEmpty(PlayerCustomUserId) then
		logger:i("Using custom id: " .. PlayerCustomUserId)
		PlayerData.CustomUserId = PlayerCustomUserId
	end

	ga:startNewSession(Player, gaData)

	OnPlayerReadyEvent = OnPlayerReadyEvent or ReplicatedStorage:WaitForChild("OnPlayerReadyEvent")
	OnPlayerReadyEvent:Fire(Player)

	--Validate
	if state.AutomaticSendBusinessEvents then
		--Website gamepasses
		if PlayerData.OwnedGamepasses == nil then --player is new (or is playing after SDK update)
			PlayerData.OwnedGamepasses = {}
			for _, id in ipairs(state._availableGamepasses) do
				if MKT:UserOwnsGamePassAsync(Player.UserId, id) then
					table.insert(PlayerData.OwnedGamepasses, id)
				end
			end
			--Player's data is now up to date. gamepass purchases on website can now be tracked in future visits
			store.PlayerCache[Player.UserId] = PlayerData
			store:SavePlayerData(Player)
		else
			--build a list of the game passes a user owns
			local currentlyOwned = {}
			for _, id in ipairs(state._availableGamepasses) do
				if MKT:UserOwnsGamePassAsync(Player.UserId, id) then
					table.insert(currentlyOwned, id)
				end
			end

			--make a table so it's easier to compare to stored game passes
			local storedGamepassesTable = {}
			for _, id in ipairs(PlayerData.OwnedGamepasses) do
				storedGamepassesTable[id] = true
			end

			--compare stored game passes to currently owned game passses
			for _, id in ipairs(currentlyOwned) do
				if not storedGamepassesTable[id] then
					table.insert(PlayerData.OwnedGamepasses, id)

					local gamepassInfo = ProductCache[id]

					--Cache
					if not gamepassInfo then
						--Get
						gamepassInfo = MKT:GetProductInfo(id, Enum.InfoType.GamePass)
						ProductCache[id] = gamepassInfo
					end

					ga:addBusinessEvent(Player.UserId, {
						amount = gamepassInfo.PriceInRobux,
						itemType = "Gamepass",
						itemId = ga:filterForBusinessEvent(gamepassInfo.Name),
						cartType = "Website",
					})
				end
			end

			store.PlayerCache[Player.UserId] = PlayerData

			store:SavePlayerData(Player)
		end
	end

	local playerEventQueue = InitializationQueueByUserId[Player.UserId]
	if playerEventQueue then
		InitializationQueueByUserId[Player.UserId] = nil
		for _, queuedFunction in ipairs(playerEventQueue) do
			queuedFunction.Func(unpack(queuedFunction.Args))
		end

		logger:i("Player initialization queue called #" .. #playerEventQueue .. " events")
	end
end

function ga:PlayerRemoved(Player: Player)
	--Save
	store:SavePlayerData(Player)

	local PlayerData = store:GetPlayerDataFromCache(Player.UserId)
	if PlayerData then
		if not PlayerData.PlayerTeleporting then
			ga:endSession(Player.UserId)
		else
			store.PlayerCache[Player.UserId] = nil
			store.DataStoreQueue.RemoveKey(Player.UserId)
		end
	end
end

function ga:isPlayerReady(playerId: number)
	if store:GetPlayerDataFromCache(playerId) then
		return true
	else
		return false
	end
end

function ga:ProcessReceiptCallback(Info: ProcessReceiptInfo)
	--Variables
	local ProductInfo = ProductCache[Info.ProductId] :: ProductInfo?

	--Cache
	if not ProductInfo then
		pcall(function()
			ProductInfo = MKT:GetProductInfo(Info.ProductId, Enum.InfoType.Product)
			ProductCache[Info.ProductId] = ProductInfo
		end)
	end

	if ProductInfo then
		ga:addBusinessEvent(Info.PlayerId, {
			amount = Info.CurrencySpent,
			itemType = "DeveloperProduct",
			itemId = ga:filterForBusinessEvent(ProductInfo.Name),
		})
	end
end

--customGamepassInfo argument to optinaly provide our own name or price
function ga:GamepassPurchased(player: Player, id: number, customGamepassInfo: ProductInfo?)
	local gamepassInfo = ProductCache[id]

	--Cache
	if not gamepassInfo then
		--Get
		gamepassInfo = MKT:GetProductInfo(id, Enum.InfoType.GamePass)
		ProductCache[id] = gamepassInfo
	end

	local amount = 0
	local itemId = "GamePass"
	if customGamepassInfo then
		amount = customGamepassInfo.PriceInRobux
		itemId = customGamepassInfo.Name
	elseif gamepassInfo then
		amount = gamepassInfo.PriceInRobux
		itemId = gamepassInfo.Name
	end

	ga:addBusinessEvent(player.UserId, {
		amount = amount or 0,
		itemType = "Gamepass",
		itemId = ga:filterForBusinessEvent(itemId),
		gamepassId = id,
	})
end

local requiredInitializationOptions = { "gameKey", "secretKey" }

function ga:initServer(gameKey: string, secretKey: string)
	ga:initialize({
		gameKey = gameKey,
		secretKey = secretKey,
	})
end

function ga:initialize(options: GameAnalyticsOptions)
	threading:performTaskOnGAThread(function()
		for _, option in ipairs(requiredInitializationOptions) do
			if options[option] == nil then
				logger:e("Initialize '" .. option .. "' option missing")
				return
			end
		end
		if options.enableInfoLog ~= nil and options.enableInfoLog then
			ga:setEnabledInfoLog(options.enableInfoLog)
		end
		if options.enableVerboseLog ~= nil and options.enableVerboseLog then
			ga:setEnabledVerboseLog(options.enableVerboseLog)
		end
		if options.availableCustomDimensions01 ~= nil and #options.availableCustomDimensions01 > 0 then
			ga:configureAvailableCustomDimensions01(options.availableCustomDimensions01)
		end
		if options.availableCustomDimensions02 ~= nil and #options.availableCustomDimensions02 > 0 then
			ga:configureAvailableCustomDimensions02(options.availableCustomDimensions02)
		end
		if options.availableCustomDimensions03 ~= nil and #options.availableCustomDimensions03 > 0 then
			ga:configureAvailableCustomDimensions03(options.availableCustomDimensions03)
		end
		if options.availableResourceCurrencies ~= nil and #options.availableResourceCurrencies > 0 then
			ga:configureAvailableResourceCurrencies(options.availableResourceCurrencies)
		end
		if options.availableResourceItemTypes ~= nil and #options.availableResourceItemTypes > 0 then
			ga:configureAvailableResourceItemTypes(options.availableResourceItemTypes)
		end
		if options.build ~= nil and #options.build > 0 then
			ga:configureBuild(options.build)
		end
		if options.availableGamepasses ~= nil and #options.availableGamepasses > 0 then
			ga:configureAvailableGamepasses(options.availableGamepasses)
		end
		if options.enableDebugLog ~= nil then
			ga:setEnabledDebugLog(options.enableDebugLog)
		end

		if options.automaticSendBusinessEvents ~= nil then
			ga:setEnabledAutomaticSendBusinessEvents(options.automaticSendBusinessEvents)
		end
		if options.reportErrors ~= nil then
			ga:setEnabledReportErrors(options.reportErrors)
		end

		if options.useCustomUserId ~= nil then
			ga:setEnabledCustomUserId(options.useCustomUserId)
		end

		if isSdkReady({ needsInitialized = true, shouldWarn = false }) then
			logger:w("SDK already initialized. Can only be called once.")
			return
		end

		local gameKey = options["gameKey"]
		local secretKey = options["secretKey"]

		if not validation:validateKeys(gameKey, secretKey) then
			logger:w(
				"SDK failed initialize. Game key or secret key is invalid. Can only contain characters A-z 0-9, gameKey is 32 length, secretKey is 40 length. Failed keys - gameKey: "
					.. gameKey
					.. ", secretKey: "
					.. secretKey
			)
			return
		end

		events.GameKey = gameKey
		events.SecretKey = secretKey

		state.Initialized = true

		-- New Players
		Players.PlayerAdded:Connect(function(Player)
			ga:PlayerJoined(Player)
		end)

		-- Players leaving
		Players.PlayerRemoving:Connect(function(Player)
			ga:PlayerRemoved(Player)
		end)

		-- Fire for players already in game
		for _, Player in ipairs(Players:GetPlayers()) do
			coroutine.wrap(ga.PlayerJoined)(ga, Player)
		end

		for _, queuedFunction in ipairs(InitializationQueue) do
			task.spawn(queuedFunction.Func, unpack(queuedFunction.Args))
		end
		logger:i("Server initialization queue called #" .. #InitializationQueue .. " events")
		InitializationQueue = {}

		events:processEventQueue()
	end)
end

if not ReplicatedStorage:FindFirstChild("GameAnalyticsRemoteConfigs") then
	--Create
	local f = Instance.new("RemoteEvent")
	f.Name = "GameAnalyticsRemoteConfigs"
	f.Parent = ReplicatedStorage
end

if not ReplicatedStorage:FindFirstChild("OnPlayerReadyEvent") then
	--Create
	local f = Instance.new("BindableEvent")
	f.Name = "OnPlayerReadyEvent"
	f.Parent = ReplicatedStorage
end

task.spawn(function()
	local currentHour = math.floor(os.time() / 3600)
	ErrorDS = store:GetErrorDataStore(currentHour)

	while task.wait(ONE_HOUR_IN_SECONDS) do
		currentHour = math.floor(os.time() / 3600)
		ErrorDS = store:GetErrorDataStore(currentHour)
		errorCountCache = {}
		errorCountCacheKeys = {}
	end
end)

task.spawn(function()
	while task.wait(store.AutoSaveData) do
		for _, key in pairs(errorCountCacheKeys) do
			local errorCount = errorCountCache[key]
			local step = errorCount.currentCount - errorCount.countInDS
			errorCountCache[key].countInDS = store:IncrementErrorCount(ErrorDS, key, step)
			errorCountCache[key].currentCount = errorCountCache[key].countInDS
		end
	end
end)

local function ErrorHandler(message, trace, scriptName, player)
	local scriptNameTmp = "(null)"
	if scriptName ~= nil then
		scriptNameTmp = scriptName
	end
	local messageTmp = "(null)"
	if message ~= nil then
		messageTmp = message
	end
	local traceTmp = "(null)"
	if trace ~= nil then
		traceTmp = trace
	end
	local m = scriptNameTmp .. ": message=" .. messageTmp .. ", trace=" .. traceTmp
	if #m > 8192 then
		m = string.sub(m, 1, 8192)
	end

	local userId = nil
	if player then
		userId = player.UserId
		m = m:gsub(player.Name, "[LocalPlayer]") -- so we don't flood the same errors with different player names
	end

	local key = m
	if #key > 50 then
		key = string.sub(key, 1, 50)
	end

	if errorCountCache[key] == nil then
		errorCountCacheKeys[#errorCountCacheKeys + 1] = key
		errorCountCache[key] = {}
		errorCountCache[key].countInDS = 0
		errorCountCache[key].currentCount = 0
	end

	-- don't report error if limit has been exceeded
	if errorCountCache[key].currentCount > MaxErrorsPerHour then
		return
	end

	ga:addErrorEvent(userId, {
		severity = ga.EGAErrorSeverity.error,
		message = m,
	})

	-- increment error count
	errorCountCache[key].currentCount = errorCountCache[key].currentCount + 1
end

local function ErrorHandlerFromServer(message, trace, Script)
	--Validate
	if not state.ReportErrors then
		return
	end

	if not Script then -- don't remember if this check is necessary but must have added it for a reason
		return
	end

	local scriptName = nil
	local ok, _ = pcall(function()
		scriptName = Script:GetFullName() -- CoreGui.RobloxGui.Modules.PlayerList error, can't get name because of security permission
	end)
	if not ok then
		return
	end

	return ErrorHandler(message, trace, scriptName)
end

local function ErrorHandlerFromClient(message, trace, scriptName, player)
	--Validate
	if not state.ReportErrors then
		return
	end

	return ErrorHandler(message, trace, scriptName, player)
end

--Error Logging
ScriptContext.Error:Connect(ErrorHandlerFromServer)
if not ReplicatedStorage:FindFirstChild("GameAnalyticsError") then
	--Create
	local f = Instance.new("RemoteEvent")
	f.Name = "GameAnalyticsError"
	f.Parent = ReplicatedStorage
end

ReplicatedStorage.GameAnalyticsError.OnServerEvent:Connect(function(player, message, trace, scriptName)
	ErrorHandlerFromClient(message, trace, scriptName, player)
end)

--Record Gamepasses.
MKT.PromptGamePassPurchaseFinished:Connect(function(Player, ID, Purchased)
	--Validate
	if not state.AutomaticSendBusinessEvents or not Purchased then
		return
	end

	ga:GamepassPurchased(Player, ID)
end)

return ga]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXDB2DD7D87AE34463A424E41A355254C2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GameAnalytics</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX4E81C5E025884902BA6648D309D1D6AC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Events.lua</string>
							<string name="ScriptGuid">{1419DDB9-86A7-4682-8152-6F7DF8CE3A35}</string>
							<ProtectedString name="Source"><![CDATA[local events = {
	ProcessEventsInterval = 8,
	GameKey = "",
	SecretKey = "",
	Build = "",
	_availableResourceCurrencies = {},
	_availableResourceItemTypes = {},
}

local store = require(script.Parent.Store)
local logger = require(script.Parent.Logger)
local version = require(script.Parent.Version)
local validation = require(script.Parent.Validation)
local threading = require(script.Parent.Threading)
local http_api = require(script.Parent.HttpApi)
local utilities = require(script.Parent.Utilities)
local GAResourceFlowType = require(script.Parent.GAResourceFlowType)
local GAProgressionStatus = require(script.Parent.GAProgressionStatus)
local GAErrorSeverity = require(script.Parent.GAErrorSeverity)
local HTTP = game:GetService("HttpService")

local CategorySessionStart = "user"
local CategorySessionEnd = "session_end"
local CategoryBusiness = "business"
local CategoryResource = "resource"
local CategoryProgression = "progression"
local CategoryDesign = "design"
local CategoryError = "error"
local CategorySdkError = "sdk_error"
local MAX_EVENTS_TO_SEND_IN_ONE_BATCH = 500
local MAX_AGGREGATED_EVENTS = 2000

local function addCustomFieldsToEvent(eventData, customFields)
	if not (eventData and customFields) then
		return
	end

	local fields = {}

	for key, value in pairs(customFields) do
		local v = tostring(value)
		if #v > 256 then
			logger:w("Custom field value is too long. Max length is 256 characters. Field: " .. key)
			v = string.sub(v, 1, 256)
		end

		fields[key] = v
	end

	if fields and next(fields) then
		eventData["custom_fields"] = fields
	end
end

local function addDimensionsToEvent(playerId, eventData)
	if not eventData or not playerId then
		return
	end

	local PlayerData = store:GetPlayerDataFromCache(playerId)

	-- add to dict (if not nil)
	if PlayerData and PlayerData.CurrentCustomDimension01 and #PlayerData.CurrentCustomDimension01 > 0 then
		eventData["custom_01"] = PlayerData.CurrentCustomDimension01
	end

	if PlayerData and PlayerData.CurrentCustomDimension02 and #PlayerData.CurrentCustomDimension02 > 0 then
		eventData["custom_02"] = PlayerData.CurrentCustomDimension02
	end

	if PlayerData and PlayerData.CurrentCustomDimension03 and #PlayerData.CurrentCustomDimension03 > 0 then
		eventData["custom_03"] = PlayerData.CurrentCustomDimension03
	end
end

local function getClientTsAdjusted(playerId)
	if not playerId then
		return os.time()
	end

	local PlayerData = store:GetPlayerDataFromCache(playerId)
	local clientTs = os.time()
	local clientTsAdjustedInteger = clientTs + PlayerData.ClientServerTimeOffset
	if validation:validateClientTs(clientTsAdjustedInteger) then
		return clientTsAdjustedInteger
	else
		return clientTs
	end
end

local DUMMY_SESSION_ID = HTTP:GenerateGUID(false):lower()

local function Length(Table)
	local counter = 0
	for _, _ in pairs(Table) do
		counter += 1
	end
	return counter
end

local function getEventAnnotations(playerId)
	local PlayerData
	local id

	if playerId then
		id = playerId
		PlayerData = store:GetPlayerDataFromCache(playerId)
	else
		id = "DummyId"
		PlayerData = {
			OS = "uwp_desktop 0.0.0",
			Platform = "uwp_desktop",
			SessionID = DUMMY_SESSION_ID,
			Sessions = 1,
			CustomUserId = "Server",
		}
	end

	local annotations = {
		-- ---- REQUIRED ----
		-- collector event API version
		["v"] = 2,
		-- User identifier
		["user_id"] = tostring(id) .. PlayerData.CustomUserId,
		-- Client Timestamp (the adjusted timestamp)
		["client_ts"] = getClientTsAdjusted(playerId),
		-- SDK version
		["sdk_version"] = "roblox " .. version.SdkVersion,
		-- Operation system version
		["os_version"] = PlayerData.OS,
		-- Device make (hardcoded to apple)
		["manufacturer"] = "unknown",
		-- Device version
		["device"] = "unknown",
		-- Platform (operating system)
		["platform"] = PlayerData.Platform,
		-- Session identifier
		["session_id"] = PlayerData.SessionID,
		-- Session number
		["session_num"] = PlayerData.Sessions,
	}

	if not utilities:isStringNullOrEmpty(PlayerData.CountryCode) then
		annotations["country_code"] = PlayerData.CountryCode
	else
		annotations["country_code"] = "unknown"
	end

	if validation:validateBuild(events.Build) then
		annotations["build"] = events.Build
	end

	if PlayerData.Configurations and Length(PlayerData.Configurations) > 0 then
		annotations["configurations"] = PlayerData.Configurations
	end

	if not utilities:isStringNullOrEmpty(PlayerData.AbId) then
		annotations["ab_id"] = PlayerData.AbId
	end

	if not utilities:isStringNullOrEmpty(PlayerData.AbVariantId) then
		annotations["ab_variant_id"] = PlayerData.AbVariantId
	end

	return annotations
end

local function addEventToStore(playerId, eventData)
	-- Get default annotations
	local ev = getEventAnnotations(playerId)

	-- Merge with eventData
	for k in pairs(eventData) do
		ev[k] = eventData[k]
	end

	-- Create json string representation
	local json = HTTP:JSONEncode(ev)

	-- output if VERBOSE LOG enabled
	logger:ii("Event added to queue: " .. json)

	-- Add to store
	store.EventsQueue[#store.EventsQueue + 1] = ev
end

local function dequeueMaxEvents()
	if #store.EventsQueue <= MAX_EVENTS_TO_SEND_IN_ONE_BATCH then
		local eventsQueue = store.EventsQueue
		store.EventsQueue = {}
		return eventsQueue
	else
		logger:w(
			("More than %d events queued! Sending %d."):format(
				MAX_EVENTS_TO_SEND_IN_ONE_BATCH,
				MAX_EVENTS_TO_SEND_IN_ONE_BATCH
			)
		)

		if #store.EventsQueue > MAX_AGGREGATED_EVENTS then
			logger:w(("DROPPING EVENTS: More than %d events queued!"):format(MAX_AGGREGATED_EVENTS))
		end

		-- Expensive operation to get ordered events cleared out (O(n))
		local eventsQueue = table.create(MAX_EVENTS_TO_SEND_IN_ONE_BATCH)
		for i = 1, MAX_EVENTS_TO_SEND_IN_ONE_BATCH do
			eventsQueue[i] = store.EventsQueue[i]
		end

		-- Shift everything down and overwrite old events
		local eventCount = #store.EventsQueue
		for i = 1, math.min(MAX_AGGREGATED_EVENTS, eventCount) do
			store.EventsQueue[i] = store.EventsQueue[i + MAX_EVENTS_TO_SEND_IN_ONE_BATCH]
		end

		-- Clear additional events
		for i = MAX_AGGREGATED_EVENTS + 1, eventCount do
			store.EventsQueue[i] = nil
		end

		return eventsQueue
	end
end

local function processEvents()
	local queue = dequeueMaxEvents()

	if #queue == 0 then
		logger:i("Event queue: No events to send")
		return
	end

	-- Log
	logger:i("Event queue: Sending " .. tostring(#queue) .. " events.")

	local eventsResult = http_api:sendEventsInArray(events.GameKey, events.SecretKey, queue)
	local statusCode = eventsResult.statusCode
	local responseBody = eventsResult.body

	if statusCode == http_api.EGAHTTPApiResponse.Ok and responseBody then
		logger:i("Event queue: " .. tostring(#queue) .. " events sent.")
	else
		if statusCode == http_api.EGAHTTPApiResponse.NoResponse then
			logger:w("Event queue: Failed to send events to collector - Retrying next time")
			for _, e in pairs(queue) do
				if #store.EventsQueue < MAX_AGGREGATED_EVENTS then
					store.EventsQueue[#store.EventsQueue + 1] = e
				else
					break
				end
			end
		else
			if statusCode == http_api.EGAHTTPApiResponse.BadRequest and responseBody then
				logger:w(
					"Event queue: "
						.. tostring(#queue)
						.. " events sent. "
						.. tostring(#responseBody)
						.. " events failed GA server validation."
				)
			else
				logger:w("Event queue: Failed to send events.")
			end
		end
	end
end

function events:processEventQueue()
	processEvents()
	threading:scheduleTimer(events.ProcessEventsInterval, function()
		events:processEventQueue()
	end)
end

function events:setBuild(build)
	if not validation:validateBuild(build) then
		logger:w("Validation fail - configure build: Cannot be null, empty or above 32 length. String: " .. build)
		return
	end

	self.Build = build
	logger:i("Set build version: " .. build)
end

function events:setAvailableResourceCurrencies(availableResourceCurrencies)
	if not validation:validateResourceCurrencies(availableResourceCurrencies) then
		return
	end

	self._availableResourceCurrencies = availableResourceCurrencies
	logger:i("Set available resource currencies: (" .. table.concat(availableResourceCurrencies, ", ") .. ")")
end

function events:setAvailableResourceItemTypes(availableResourceItemTypes)
	if not validation:validateResourceCurrencies(availableResourceItemTypes) then
		return
	end

	self._availableResourceItemTypes = availableResourceItemTypes
	logger:i("Set available resource item types: (" .. table.concat(availableResourceItemTypes, ", ") .. ")")
end

function events:addSessionStartEvent(playerId, teleportData, customFields)
	local PlayerData = store:GetPlayerDataFromCache(playerId)

	if teleportData then
		PlayerData.Sessions = teleportData.Sessions
	else
		local eventDict = {}

		-- Event specific data
		eventDict["category"] = CategorySessionStart

		-- Increment session number  and persist
		PlayerData.Sessions = PlayerData.Sessions + 1

		--  Add custom dimensions
		addDimensionsToEvent(playerId, eventDict)

		-- Add to store
		addEventToStore(playerId, eventDict)
		addCustomFieldsToEvent(eventDict, customFields)

		logger:i("Add SESSION START event")

		processEvents()
	end
end

function events:addSessionEndEvent(playerId, customFields)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	local session_start_ts = PlayerData.SessionStart
	local client_ts_adjusted = getClientTsAdjusted(playerId)
	local sessionLength = 0

	if client_ts_adjusted ~= nil and session_start_ts ~= nil then
		sessionLength = client_ts_adjusted - session_start_ts
	end

	if sessionLength < 0 then
		-- Should never happen.
		-- Could be because of edge cases regarding time altering on device.
		logger:w("Session length was calculated to be less then 0. Should not be possible. Resetting to 0.")
		sessionLength = 0
	end

	-- Event specific data
	local eventDict = {}
	eventDict["category"] = CategorySessionEnd
	eventDict["length"] = sessionLength

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventDict)
	addCustomFieldsToEvent(eventDict, customFields)

	-- Add to store
	addEventToStore(playerId, eventDict)
	PlayerData.SessionStart = 0

	logger:i("Add SESSION END event.")

	processEvents()
end

function events:addBusinessEvent(playerId, currency, amount, itemType, itemId, cartType, customFields)
	-- Validate event params
	if not validation:validateBusinessEvent(currency, amount, cartType, itemType, itemId) then
		-- TODO: add sdk error event
		return
	end

	-- Create empty eventData
	local eventDict = {}

	-- Increment transaction number and persist
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	PlayerData.Transactions = PlayerData.Transactions + 1

	-- Required
	eventDict["event_id"] = itemType .. ":" .. itemId
	eventDict["category"] = CategoryBusiness
	eventDict["currency"] = currency
	eventDict["amount"] = amount
	eventDict["transaction_num"] = PlayerData.Transactions

	-- Optional
	if not utilities:isStringNullOrEmpty(cartType) then
		eventDict["cart_type"] = cartType
	end

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventDict)
	addCustomFieldsToEvent(eventDict, customFields)

	logger:i(
		"Add BUSINESS event: {currency:"
			.. currency
			.. ", amount:"
			.. tostring(amount)
			.. ", itemType:"
			.. itemType
			.. ", itemId:"
			.. itemId
			.. ", cartType:"
			.. cartType
			.. "}"
	)

	-- Send to store
	addEventToStore(playerId, eventDict)
end

function events:addResourceEvent(playerId, flowType, currency, amount, itemType, itemId, customFields)
	-- Validate event params
	if
		not validation:validateResourceEvent(
			GAResourceFlowType,
			flowType,
			currency,
			amount,
			itemType,
			itemId,
			self._availableResourceCurrencies,
			self._availableResourceItemTypes
		)
	then
		-- TODO: add sdk error event
		return
	end

	-- If flow type is sink reverse amount
	if flowType == GAResourceFlowType.Sink then
		amount = (-1 * amount)
	end

	-- Create empty eventData
	local eventDict = {}

	-- insert event specific values
	local flowTypeString = GAResourceFlowType[flowType]
	eventDict["event_id"] = flowTypeString .. ":" .. currency .. ":" .. itemType .. ":" .. itemId
	eventDict["category"] = CategoryResource
	eventDict["amount"] = amount

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventDict)
	addCustomFieldsToEvent(eventDict, customFields)

	logger:i(
		"Add RESOURCE event: {currency:"
			.. currency
			.. ", amount:"
			.. tostring(amount)
			.. ", itemType:"
			.. itemType
			.. ", itemId:"
			.. itemId
			.. "}"
	)

	-- Send to store
	addEventToStore(playerId, eventDict)
end

function events:addProgressionEvent(
	playerId,
	progressionStatus,
	progression01,
	progression02,
	progression03,
	score,
	customFields
)
	-- Validate event params
	if
		not validation:validateProgressionEvent(
			GAProgressionStatus,
			progressionStatus,
			progression01,
			progression02,
			progression03
		)
	then
		-- TODO: add sdk error event
		return
	end

	-- Create empty eventData
	local eventDict = {}

	-- Progression identifier
	local progressionIdentifier
	if utilities:isStringNullOrEmpty(progression02) then
		progressionIdentifier = progression01
	elseif utilities:isStringNullOrEmpty(progression03) then
		progressionIdentifier = progression01 .. ":" .. progression02
	else
		progressionIdentifier = progression01 .. ":" .. progression02 .. ":" .. progression03
	end

	local statusString = GAProgressionStatus[progressionStatus]

	-- Append event specifics
	eventDict["category"] = CategoryProgression
	eventDict["event_id"] = statusString .. ":" .. progressionIdentifier

	-- Attempt
	local attempt_num = 0

	-- Add score if specified and status is not start
	if score ~= nil and progressionStatus ~= GAProgressionStatus.Start then
		eventDict["score"] = score
	end

	local PlayerData = store:GetPlayerDataFromCache(playerId)

	-- Count attempts on each progression fail and persist
	if progressionStatus == GAProgressionStatus.Fail then
		-- Increment attempt number
		local progressionTries = PlayerData.ProgressionTries[progressionIdentifier] or 0
		PlayerData.ProgressionTries[progressionIdentifier] = progressionTries + 1
	end

	-- increment and add attempt_num on complete and delete persisted
	if progressionStatus == GAProgressionStatus.Complete then
		-- Increment attempt number
		local progressionTries = PlayerData.ProgressionTries[progressionIdentifier] or 0
		PlayerData.ProgressionTries[progressionIdentifier] = progressionTries + 1

		-- Add to event
		attempt_num = PlayerData.ProgressionTries[progressionIdentifier]
		eventDict["attempt_num"] = attempt_num

		-- Clear
		PlayerData.ProgressionTries[progressionIdentifier] = 0
	end

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventDict)
	addCustomFieldsToEvent(eventDict, customFields)

	local progression02String = ""
	if not utilities:isStringNullOrEmpty(progression02) then
		progression02String = progression02
	end

	local progression03String = ""
	if not utilities:isStringNullOrEmpty(progression03) then
		progression03String = progression03
	end

	logger:i(
		"Add PROGRESSION event: {status:"
			.. statusString
			.. ", progression01:"
			.. progression01
			.. ", progression02:"
			.. progression02String
			.. ", progression03:"
			.. progression03String
			.. ", score:"
			.. tostring(score)
			.. ", attempt:"
			.. tostring(attempt_num)
			.. "}"
	)

	-- Send to store
	addEventToStore(playerId, eventDict)
end

function events:addDesignEvent(playerId, eventId, value, customFields)
	-- Validate
	if not validation:validateDesignEvent(eventId) then
		-- TODO: add sdk error event
		return
	end

	-- Create empty eventData
	local eventData = {}

	-- Append event specifics
	eventData["category"] = CategoryDesign
	eventData["event_id"] = eventId

	if value ~= nil then
		eventData["value"] = value
	end

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventData)
	addCustomFieldsToEvent(eventData, customFields)

	logger:i("Add DESIGN event: {eventId:" .. eventId .. ", value:" .. tostring(value) .. "}")

	-- Send to store
	addEventToStore(playerId, eventData)
end

function events:addErrorEvent(playerId, severity, message, customFields)
	-- Validate
	if not validation:validateErrorEvent(GAErrorSeverity, severity, message) then
		-- TODO: add sdk error event
		return
	end

	-- Create empty eventData
	local eventData = {}

	local severityString = GAErrorSeverity[severity]

	eventData["category"] = CategoryError
	eventData["severity"] = severityString
	eventData["message"] = message

	-- Add custom dimensions
	addDimensionsToEvent(playerId, eventData)
	addCustomFieldsToEvent(eventData, customFields)

	local messageString = ""
	if not utilities:isStringNullOrEmpty(message) then
		messageString = message
	end

	logger:i("Add ERROR event: {severity:" .. severityString .. ", message:" .. messageString .. "}")

	-- Send to store
	addEventToStore(playerId, eventData)
end

function events:addSdkErrorEvent(playerId, category, area, action, parameter, reason)
	-- Create empty eventData
	local eventData = {}

	eventData["category"] = CategorySdkError
	eventData["error_category"] = category
	eventData["error_area"] = area
	eventData["error_action"] = action

	if not utilities:isStringNullOrEmpty(parameter) then
		eventData["error_parameter"] = parameter
	end

	if not utilities:isStringNullOrEmpty(reason) then
		eventData["reason"] = reason
	end

	logger:i(
		"Add SDK ERROR event: {error_category:"
			.. category
			.. ", error_area:"
			.. area
			.. ", error_action:"
			.. action
			.. "}"
	)

	-- Send to store
	addEventToStore(playerId, eventData)
end

return events]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF99D78DD13B64F5FAB8F46930FEF2158">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">GAErrorSeverity.lua</string>
							<string name="ScriptGuid">{0F45C2FD-9A3D-4255-B832-4D4CE0842D16}</string>
							<ProtectedString name="Source"><![CDATA[local function readonlytable(table)
	return setmetatable({}, {
		__index = table,
		__metatable = false,
		__newindex = function(t, k, v)
			error("Attempt to modify read-only table: " .. t .. ", key=" .. k .. ", value=" .. v)
		end,
	})
end

return readonlytable({
	debug = "debug",
	info = "info",
	warning = "warning",
	error = "error",
	critical = "critical",
})]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD7C6EE6CCF8143AF8533D8F35445F30F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">GAProgressionStatus.lua</string>
							<string name="ScriptGuid">{89CFC752-0692-48B6-86FB-0E0561760CA0}</string>
							<ProtectedString name="Source"><![CDATA[local function readonlytable(table)
	return setmetatable({}, {
		__index = table,
		__metatable = false,
		__newindex = function(t, k, v)
			error("Attempt to modify read-only table: " .. t .. ", key=" .. k .. ", value=" .. v)
		end,
	})
end

return readonlytable({
	Start = "Start",
	Complete = "Complete",
	Fail = "Fail",
})]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX244D56DE815345EE962C3C8F9B26C868">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">GAResourceFlowType.lua</string>
							<string name="ScriptGuid">{77B74FB6-5EAE-4069-BE05-C0ABC6A4C431}</string>
							<ProtectedString name="Source"><![CDATA[local function readonlytable(table)
	return setmetatable({}, {
		__index = table,
		__metatable = false,
		__newindex = function(t, k, v)
			error("Attempt to modify read-only table: " .. t .. ", key=" .. k .. ", value=" .. v)
		end,
	})
end

return readonlytable({
	Source = "Source",
	Sink = "Sink",
})]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD0CF759CE1C9478389E620AB9F6B6008">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">HttpApi.lua</string>
							<string name="ScriptGuid">{17B6D70E-50B8-46E4-B6EC-3B10FBAA6452}</string>
							<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local validation = require(script.Parent.Validation)
local version = require(script.Parent.Version)

local HashLib = require(script.HashLib)

local http_api = {
	protocol = "https",
	hostName = "api.gameanalytics.com",
	version = "v2",
	remoteConfigsVersion = "v1",
	initializeUrlPath = "init",
	eventsUrlPath = "events",
	EGAHTTPApiResponse = {
		NoResponse = 0,
		BadResponse = 1,
		RequestTimeout = 2,
		JsonEncodeFailed = 3,
		JsonDecodeFailed = 4,
		InternalServerError = 5,
		BadRequest = 6,
		Unauthorized = 7,
		UnknownResponseCode = 8,
		Ok = 9,
		Created = 10,
	},
}

local HTTP = game:GetService("HttpService")
local logger = require(script.Parent.Logger)
local baseUrl = (RunService:IsStudio() and "https" or http_api.protocol)
	.. "://"
	.. (RunService:IsStudio() and "sandbox-" or "")
	.. http_api.hostName
	.. "/"
	.. http_api.version
local remoteConfigsBaseUrl = (RunService:IsStudio() and "https" or http_api.protocol)
	.. "://"
	.. (RunService:IsStudio() and "sandbox-" or "")
	.. http_api.hostName
	.. "/remote_configs/"
	.. http_api.remoteConfigsVersion

local function getInitAnnotations(build, playerData, playerId)
	local initAnnotations = {
		["user_id"] = tostring(playerId) .. playerData.CustomUserId,
		["sdk_version"] = "roblox " .. version.SdkVersion,
		["os_version"] = playerData.OS,
		["platform"] = playerData.Platform,
		["build"] = build,
		["session_num"] = playerData.Sessions,
		["random_salt"] = playerData.Sessions,
	}

	return initAnnotations
end

local function encode(payload, secretKey)
	--Validate
	if not secretKey then
		logger:w("Error encoding, invalid SecretKey")
		return
	end

	--Encode
	local payloadHmac = HashLib.hmac(
		HashLib.sha256,
		RunService:IsStudio() and "16813a12f718bc5c620f56944e1abc3ea13ccbac" or secretKey,
		payload,
		true
	)

	return HashLib.base64_encode(payloadHmac)
end

local function processRequestResponse(response, requestId)
	local statusCode = response.StatusCode
	local body = response.Body

	if not body or #body == 0 then
		logger:d(requestId .. " request. failed. Might be no connection. Status code: " .. tostring(statusCode))
		return http_api.EGAHTTPApiResponse.NoResponse
	end

	if statusCode == 200 then
		return http_api.EGAHTTPApiResponse.Ok
	elseif statusCode == 201 then
		return http_api.EGAHTTPApiResponse.Created
	elseif statusCode == 0 or statusCode == 401 then
		logger:d(requestId .. " request. 401 - Unauthorized.")
		return http_api.EGAHTTPApiResponse.Unauthorized
	elseif statusCode == 400 then
		logger:d(requestId .. " request. 400 - Bad Request.")
		return http_api.EGAHTTPApiResponse.BadRequest
	elseif statusCode == 500 then
		logger:d(requestId .. " request. 500 - Internal Server Error.")
		return http_api.EGAHTTPApiResponse.InternalServerError
	else
		return http_api.EGAHTTPApiResponse.UnknownResponseCode
	end
end

function http_api:initRequest(gameKey, secretKey, build, playerData, playerId)
	local url = remoteConfigsBaseUrl
		.. "/"
		.. http_api.initializeUrlPath
		.. "?game_key="
		.. gameKey
		.. "&interval_seconds=0&configs_hash="
		.. (playerData.ConfigsHash or "")
	if RunService:IsStudio() then
		url = baseUrl .. "/5c6bcb5402204249437fb5a7a80a4959/" .. self.initializeUrlPath
	end

	logger:d("Sending 'init' URL: " .. url)

	local payload = HTTP:JSONEncode(getInitAnnotations(build, playerData, playerId))
	payload = payload:gsub('"country_code":"unknown"', '"country_code":null')
	local authorization = encode(payload, secretKey)

	logger:d("init payload: " .. payload)

	local res
	local success, err = pcall(function()
		res = HTTP:RequestAsync({
			Url = url,
			Method = "POST",
			Headers = {
				["Authorization"] = authorization,
				["Content-Type"] = "application/json",
			},
			Body = payload,
		})
	end)

	if not success then
		logger:d("Failed Init Call. error: " .. err)
		return {
			statusCode = http_api.EGAHTTPApiResponse.UnknownResponseCode,
			body = nil,
		}
	end
	logger:d("init request content: " .. res.Body)

	local requestResponseEnum = processRequestResponse(res, "Init")

	-- if not 200 result
	if
		requestResponseEnum ~= http_api.EGAHTTPApiResponse.Ok
		and requestResponseEnum ~= http_api.EGAHTTPApiResponse.Created
		and requestResponseEnum ~= http_api.EGAHTTPApiResponse.BadRequest
	then
		logger:d(
			"Failed Init Call. URL: " .. url .. ", JSONString: " .. payload .. ", Authorization: " .. authorization
		)
		return {
			statusCode = requestResponseEnum,
			body = nil,
		}
	end

	--Response
	local responseBody
	success = pcall(function()
		responseBody = HTTP:JSONDecode(res.Body)
	end)

	if not success then
		logger:d("Failed Init Call. Json decoding failed: " .. err)
		return {
			statusCode = http_api.EGAHTTPApiResponse.JsonDecodeFailed,
			body = nil,
		}
	end

	-- print reason if bad request
	if requestResponseEnum == http_api.EGAHTTPApiResponse.BadRequest then
		logger:d("Failed Init Call. Bad request. Response: " .. res.Body)
		return {
			statusCode = requestResponseEnum,
			body = nil,
		}
	end

	-- validate Init call values
	local validatedInitValues = validation:validateAndCleanInitRequestResponse(
		responseBody,
		requestResponseEnum == http_api.EGAHTTPApiResponse.Created
	)

	if not validatedInitValues then
		return {
			statusCode = http_api.EGAHTTPApiResponse.BadResponse,
			body = nil,
		}
	end

	-- all ok
	return {
		statusCode = requestResponseEnum,
		body = responseBody,
	}
end

function http_api:sendEventsInArray(gameKey, secretKey, eventArray)
	if not eventArray or #eventArray == 0 then
		logger:d("sendEventsInArray called with missing eventArray")
		return
	end

	-- Generate URL
	local url = baseUrl .. "/" .. gameKey .. "/" .. self.eventsUrlPath
	if RunService:IsStudio() then
		url = baseUrl .. "/5c6bcb5402204249437fb5a7a80a4959/" .. self.eventsUrlPath
	end

	logger:d("Sending 'events' URL: " .. url)

	-- make JSON string from data
	local payload = HTTP:JSONEncode(eventArray)
	payload = payload:gsub('"country_code":"unknown"', '"country_code":null')
	local authorization = encode(payload, secretKey)

	local res
	local success, err = pcall(function()
		res = HTTP:RequestAsync({
			Url = url,
			Method = "POST",
			Headers = {
				["Authorization"] = authorization,
				["Content-Type"] = "application/json",
			},
			Body = payload,
		})
	end)

	if not success then
		logger:d("Failed Events Call. error: " .. err)
		return {
			statusCode = http_api.EGAHTTPApiResponse.UnknownResponseCode,
			body = nil,
		}
	end

	logger:d("body: " .. res.Body)
	local requestResponseEnum = processRequestResponse(res, "Events")

	-- if not 200 result
	if
		requestResponseEnum ~= http_api.EGAHTTPApiResponse.Ok
		and requestResponseEnum ~= http_api.EGAHTTPApiResponse.Created
		and requestResponseEnum ~= http_api.EGAHTTPApiResponse.BadRequest
	then
		logger:d(
			"Failed Events Call. URL: " .. url .. ", JSONString: " .. payload .. ", Authorization: " .. authorization
		)
		return {
			statusCode = requestResponseEnum,
			body = nil,
		}
	end

	local responseBody
	pcall(function()
		responseBody = HTTP:JSONDecode(res.Body)
	end)

	if not responseBody then
		logger:d("Failed Events Call. Json decoding failed")
		return {
			statusCode = http_api.EGAHTTPApiResponse.JsonDecodeFailed,
			body = nil,
		}
	end

	-- print reason if bad request
	if requestResponseEnum == http_api.EGAHTTPApiResponse.BadRequest then
		logger:d("Failed Events Call. Bad request. Response: " .. res.Body)
		return {
			statusCode = requestResponseEnum,
			body = nil,
		}
	end

	-- all ok
	return {
		statusCode = http_api.EGAHTTPApiResponse.Ok,
		body = responseBody,
	}
end

return http_api]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX54B8BB58C66B4AEEAA833C0A2D8CE441">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">HttpApi</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX93B66AD0E1B74B0AB7E371B8B82BE1A0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">HashLib.lua</string>
								<string name="ScriptGuid">{0FC750C7-77D0-45ED-93ED-D80567C993BB}</string>
								<ProtectedString name="Source"><![CDATA[--[=[------------------------------------------------------------------------------------------------------------------------
-- HashLib by Egor Skriptunoff, boatbomber, and howmanysmall

Documentation here: https://devforum.roblox.com/t/open-source-hashlib/416732/1

--------------------------------------------------------------------------------------------------------------------------

Module was originally written by Egor Skriptunoff and distributed under an MIT license.
It can be found here: https://github.com/Egor-Skriptunoff/pure_lua_SHA/blob/master/sha2.lua

That version was around 3000 lines long, and supported Lua versions 5.1, 5.2, 5.3, and 5.4, and LuaJIT.
Although that is super cool, Roblox only uses Lua 5.1, so that was extreme overkill.

I, boatbomber, worked (with howmanysmall's guidance) to port it to Roblox in a way that
doesn't overcomplicate it with support of unreachable cases. Then, howmanysmall did some final optimizations
that really squeeze out all the performance possible.

After quite a bit of work and benchmarking, this is what we were left with.
Enjoy!

--------------------------------------------------------------------------------------------------------------------------

DESCRIPTION:
	This module contains functions to calculate SHA digest:
		MD5, SHA-1,
		SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,
		SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,
		HMAC
	Additionally, it has a few extra utility functions:
		hex_to_bin
		base64_to_bin
		bin_to_base64
	Written in pure Lua.
USAGE:
	Input data should be a string
	Result (SHA digest) is returned in hexadecimal representation as a string of lowercase hex digits.
	Simplest usage example:
		local HashLib = require(script.HashLib)
		local your_hash = HashLib.sha256("your string")
API:
		HashLib.md5
		HashLib.sha1
	SHA2 hash functions:
		HashLib.sha224
		HashLib.sha256
		HashLib.sha512_224
		HashLib.sha512_256
		HashLib.sha384
		HashLib.sha512
	SHA3 hash functions:
		HashLib.sha3_224
		HashLib.sha3_256
		HashLib.sha3_384
		HashLib.sha3_512
		HashLib.shake128
		HashLib.shake256
	Misc utilities:
		HashLib.hmac (Applicable to any hash function from this module except SHAKE*)
		HashLib.hex_to_bin
		HashLib.base64_to_bin
		HashLib.bin_to_base64

--]=]
---------------------------------------------------------------------------

local Base64 = require(script.Base64)

--------------------------------------------------------------------------------
-- LOCALIZATION FOR VM OPTIMIZATIONS
--------------------------------------------------------------------------------

local ipairs = ipairs

--------------------------------------------------------------------------------
-- 32-BIT BITWISE FUNCTIONS
--------------------------------------------------------------------------------
-- Only low 32 bits of function arguments matter, high bits are ignored
-- The result of all functions (except HEX) is an integer inside "correct range":
-- for "bit" library:    (-TWO_POW_31)..(TWO_POW_31-1)
-- for "bit32" library:        0..(TWO_POW_32-1)
local bit32_band = bit32.band -- 2 arguments
local bit32_bor = bit32.bor -- 2 arguments
local bit32_bxor = bit32.bxor -- 2..5 arguments
local bit32_lshift = bit32.lshift -- second argument is integer 0..31
local bit32_rshift = bit32.rshift -- second argument is integer 0..31
local bit32_lrotate = bit32.lrotate -- second argument is integer 0..31
local bit32_rrotate = bit32.rrotate -- second argument is integer 0..31

--------------------------------------------------------------------------------
-- CREATING OPTIMIZED INNER LOOP
--------------------------------------------------------------------------------
-- Arrays of SHA2 "magic numbers" (in "INT64" and "FFI" branches "*_lo" arrays contain 64-bit values)
local sha2_K_lo, sha2_K_hi, sha2_H_lo, sha2_H_hi, sha3_RC_lo, sha3_RC_hi = {}, {}, {}, {}, {}, {}
local sha2_H_ext256 = {
	[224] = {},
	[256] = sha2_H_hi,
}

local sha2_H_ext512_lo, sha2_H_ext512_hi = {
	[384] = {},
	[512] = sha2_H_lo,
}, {
	[384] = {},
	[512] = sha2_H_hi,
}

local md5_K, md5_sha1_H = {}, { 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0 }
local md5_next_shift =
	{ 0, 0, 0, 0, 0, 0, 0, 0, 28, 25, 26, 27, 0, 0, 10, 9, 11, 12, 0, 15, 16, 17, 18, 0, 20, 22, 23, 21 }
local HEX64, XOR64A5, lanes_index_base -- defined only for branches that internally use 64-bit integers: "INT64" and "FFI"
local common_W = {} -- temporary table shared between all calculations (to avoid creating new temporary table every time)
local K_lo_modulo, hi_factor, hi_factor_keccak = 4294967296, 0, 0

local TWO_POW_NEG_56 = 2 ^ -56
local TWO_POW_NEG_17 = 2 ^ -17

local TWO_POW_2 = 2 ^ 2
local TWO_POW_3 = 2 ^ 3
local TWO_POW_4 = 2 ^ 4
local TWO_POW_5 = 2 ^ 5
local TWO_POW_6 = 2 ^ 6
local TWO_POW_7 = 2 ^ 7
local TWO_POW_8 = 2 ^ 8
local TWO_POW_9 = 2 ^ 9
local TWO_POW_10 = 2 ^ 10
local TWO_POW_11 = 2 ^ 11
local TWO_POW_12 = 2 ^ 12
local TWO_POW_13 = 2 ^ 13
local TWO_POW_14 = 2 ^ 14
local TWO_POW_15 = 2 ^ 15
local TWO_POW_16 = 2 ^ 16
local TWO_POW_17 = 2 ^ 17
local TWO_POW_18 = 2 ^ 18
local TWO_POW_19 = 2 ^ 19
local TWO_POW_20 = 2 ^ 20
local TWO_POW_21 = 2 ^ 21
local TWO_POW_22 = 2 ^ 22
local TWO_POW_23 = 2 ^ 23
local TWO_POW_24 = 2 ^ 24
local TWO_POW_25 = 2 ^ 25
local TWO_POW_26 = 2 ^ 26
local TWO_POW_27 = 2 ^ 27
local TWO_POW_28 = 2 ^ 28
local TWO_POW_29 = 2 ^ 29
local TWO_POW_30 = 2 ^ 30
local TWO_POW_31 = 2 ^ 31
local TWO_POW_32 = 2 ^ 32
local TWO_POW_40 = 2 ^ 40

local TWO56_POW_7 = 256 ^ 7

-- Implementation for Lua 5.1/5.2 (with or without bitwise library available)
local function sha256_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K = common_W, sha2_K_hi
	local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 64 do
			local a, b = W[j - 15], W[j - 2]
			W[j] = bit32_bxor(bit32_rrotate(a, 7), bit32_lrotate(a, 14), bit32_rshift(a, 3))
				+ bit32_bxor(bit32_lrotate(b, 15), bit32_lrotate(b, 13), bit32_rshift(b, 10))
				+ W[j - 7]
				+ W[j - 16]
		end

		local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8
		for j = 1, 64 do
			local z = bit32_bxor(bit32_rrotate(e, 6), bit32_rrotate(e, 11), bit32_lrotate(e, 7))
				+ bit32_band(e, f)
				+ bit32_band(-1 - e, g)
				+ h
				+ K[j]
				+ W[j]
			h = g
			g = f
			f = e
			e = z + d
			d = c
			c = b
			b = a
			a = z
				+ bit32_band(d, c)
				+ bit32_band(a, bit32_bxor(d, c))
				+ bit32_bxor(bit32_rrotate(a, 2), bit32_rrotate(a, 13), bit32_lrotate(a, 10))
		end

		h1, h2, h3, h4 = (a + h1) % 4294967296, (b + h2) % 4294967296, (c + h3) % 4294967296, (d + h4) % 4294967296
		h5, h6, h7, h8 = (e + h5) % 4294967296, (f + h6) % 4294967296, (g + h7) % 4294967296, (h + h8) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8
end

local function sha512_feed_128(H_lo, H_hi, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 128
	-- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]
	local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi
	local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo =
		H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]
	local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi =
		H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]
	for pos = offs, offs + size - 1, 128 do
		for j = 1, 16 * 2 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for jj = 17 * 2, 80 * 2, 2 do
			local a_lo, a_hi, b_lo, b_hi = W[jj - 30], W[jj - 31], W[jj - 4], W[jj - 5]
			local tmp1 = bit32_bxor(
				bit32_rshift(a_lo, 1) + bit32_lshift(a_hi, 31),
				bit32_rshift(a_lo, 8) + bit32_lshift(a_hi, 24),
				bit32_rshift(a_lo, 7) + bit32_lshift(a_hi, 25)
			) % 4294967296 + bit32_bxor(
				bit32_rshift(b_lo, 19) + bit32_lshift(b_hi, 13),
				bit32_lshift(b_lo, 3) + bit32_rshift(b_hi, 29),
				bit32_rshift(b_lo, 6) + bit32_lshift(b_hi, 26)
			) % 4294967296 + W[jj - 14] + W[jj - 32]

			local tmp2 = tmp1 % 4294967296
			W[jj - 1] = bit32_bxor(
				bit32_rshift(a_hi, 1) + bit32_lshift(a_lo, 31),
				bit32_rshift(a_hi, 8) + bit32_lshift(a_lo, 24),
				bit32_rshift(a_hi, 7)
			) + bit32_bxor(
				bit32_rshift(b_hi, 19) + bit32_lshift(b_lo, 13),
				bit32_lshift(b_hi, 3) + bit32_rshift(b_lo, 29),
				bit32_rshift(b_hi, 6)
			) + W[jj - 15] + W[jj - 33] + (tmp1 - tmp2) / 4294967296

			W[jj] = tmp2
		end

		local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
		local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
		for j = 1, 80 do
			local jj = 2 * j
			local tmp1 = bit32_bxor(
				bit32_rshift(e_lo, 14) + bit32_lshift(e_hi, 18),
				bit32_rshift(e_lo, 18) + bit32_lshift(e_hi, 14),
				bit32_lshift(e_lo, 23) + bit32_rshift(e_hi, 9)
			) % 4294967296 + (bit32_band(e_lo, f_lo) + bit32_band(-1 - e_lo, g_lo)) % 4294967296 + h_lo + K_lo[j] + W[jj]

			local z_lo = tmp1 % 4294967296
			local z_hi = bit32_bxor(
				bit32_rshift(e_hi, 14) + bit32_lshift(e_lo, 18),
				bit32_rshift(e_hi, 18) + bit32_lshift(e_lo, 14),
				bit32_lshift(e_hi, 23) + bit32_rshift(e_lo, 9)
			) + bit32_band(e_hi, f_hi) + bit32_band(-1 - e_hi, g_hi) + h_hi + K_hi[j] + W[jj - 1] + (tmp1 - z_lo) / 4294967296

			h_lo = g_lo
			h_hi = g_hi
			g_lo = f_lo
			g_hi = f_hi
			f_lo = e_lo
			f_hi = e_hi
			tmp1 = z_lo + d_lo
			e_lo = tmp1 % 4294967296
			e_hi = z_hi + d_hi + (tmp1 - e_lo) / 4294967296
			d_lo = c_lo
			d_hi = c_hi
			c_lo = b_lo
			c_hi = b_hi
			b_lo = a_lo
			b_hi = a_hi
			tmp1 = z_lo
				+ (bit32_band(d_lo, c_lo) + bit32_band(b_lo, bit32_bxor(d_lo, c_lo))) % 4294967296
				+ bit32_bxor(
						bit32_rshift(b_lo, 28) + bit32_lshift(b_hi, 4),
						bit32_lshift(b_lo, 30) + bit32_rshift(b_hi, 2),
						bit32_lshift(b_lo, 25) + bit32_rshift(b_hi, 7)
					)
					% 4294967296
			a_lo = tmp1 % 4294967296
			a_hi = z_hi
				+ (bit32_band(d_hi, c_hi) + bit32_band(b_hi, bit32_bxor(d_hi, c_hi)))
				+ bit32_bxor(
					bit32_rshift(b_hi, 28) + bit32_lshift(b_lo, 4),
					bit32_lshift(b_hi, 30) + bit32_rshift(b_lo, 2),
					bit32_lshift(b_hi, 25) + bit32_rshift(b_lo, 7)
				)
				+ (tmp1 - a_lo) / 4294967296
		end

		a_lo = h1_lo + a_lo
		h1_lo = a_lo % 4294967296
		h1_hi = (h1_hi + a_hi + (a_lo - h1_lo) / 4294967296) % 4294967296
		a_lo = h2_lo + b_lo
		h2_lo = a_lo % 4294967296
		h2_hi = (h2_hi + b_hi + (a_lo - h2_lo) / 4294967296) % 4294967296
		a_lo = h3_lo + c_lo
		h3_lo = a_lo % 4294967296
		h3_hi = (h3_hi + c_hi + (a_lo - h3_lo) / 4294967296) % 4294967296
		a_lo = h4_lo + d_lo
		h4_lo = a_lo % 4294967296
		h4_hi = (h4_hi + d_hi + (a_lo - h4_lo) / 4294967296) % 4294967296
		a_lo = h5_lo + e_lo
		h5_lo = a_lo % 4294967296
		h5_hi = (h5_hi + e_hi + (a_lo - h5_lo) / 4294967296) % 4294967296
		a_lo = h6_lo + f_lo
		h6_lo = a_lo % 4294967296
		h6_hi = (h6_hi + f_hi + (a_lo - h6_lo) / 4294967296) % 4294967296
		a_lo = h7_lo + g_lo
		h7_lo = a_lo % 4294967296
		h7_hi = (h7_hi + g_hi + (a_lo - h7_lo) / 4294967296) % 4294967296
		a_lo = h8_lo + h_lo
		h8_lo = a_lo % 4294967296
		h8_hi = (h8_hi + h_hi + (a_lo - h8_lo) / 4294967296) % 4294967296
	end

	H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] =
		h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
	H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] =
		h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
end

local function md5_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K, md5_next_shift = common_W, md5_K, md5_next_shift
	local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((d * 256 + c) * 256 + b) * 256 + a
		end

		local a, b, c, d = h1, h2, h3, h4
		local s = 32 - 7
		for j = 1, 16 do
			local F = bit32_rrotate(bit32_band(b, c) + bit32_band(-1 - b, d) + a + K[j] + W[j], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 32 - 5
		for j = 17, 32 do
			local F = bit32_rrotate(bit32_band(d, b) + bit32_band(-1 - d, c) + a + K[j] + W[(5 * j - 4) % 16 + 1], s)
				+ b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 32 - 4
		for j = 33, 48 do
			local F = bit32_rrotate(bit32_bxor(bit32_bxor(b, c), d) + a + K[j] + W[(3 * j + 2) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 32 - 6
		for j = 49, 64 do
			local F = bit32_rrotate(bit32_bxor(c, bit32_bor(b, -1 - d)) + a + K[j] + W[(j * 7 - 7) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
	end

	H[1], H[2], H[3], H[4] = h1, h2, h3, h4
end

local function sha1_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W = common_W
	local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 80 do
			W[j] = bit32_lrotate(bit32_bxor(W[j - 3], W[j - 8], W[j - 14], W[j - 16]), 1)
		end

		local a, b, c, d, e = h1, h2, h3, h4, h5
		for j = 1, 20 do
			local z = bit32_lrotate(a, 5) + bit32_band(b, c) + bit32_band(-1 - b, d) + 0x5A827999 + W[j] + e -- constant = math.floor(TWO_POW_30 * sqrt(2))
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 21, 40 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0x6ED9EBA1 + W[j] + e -- TWO_POW_30 * sqrt(3)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 41, 60 do
			local z = bit32_lrotate(a, 5) + bit32_band(d, c) + bit32_band(b, bit32_bxor(d, c)) + 0x8F1BBCDC + W[j] + e -- TWO_POW_30 * sqrt(5)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 61, 80 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0xCA62C1D6 + W[j] + e -- TWO_POW_30 * sqrt(10)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
		h5 = (e + h5) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5
end

local function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)
	-- This is an example of a Lua function having 79 local variables :-)
	-- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8
	local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi
	local qwords_qty = block_size_in_bytes / 8
	for pos = offs, offs + size - 1, block_size_in_bytes do
		for j = 1, qwords_qty do
			local a, b, c, d = string.byte(str, pos + 1, pos + 4)
			lanes_lo[j] = bit32_bxor(lanes_lo[j], ((d * 256 + c) * 256 + b) * 256 + a)
			pos = pos + 8
			a, b, c, d = string.byte(str, pos - 3, pos)
			lanes_hi[j] = bit32_bxor(lanes_hi[j], ((d * 256 + c) * 256 + b) * 256 + a)
		end

		local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi, L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi, L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi =
			lanes_lo[1],
			lanes_hi[1],
			lanes_lo[2],
			lanes_hi[2],
			lanes_lo[3],
			lanes_hi[3],
			lanes_lo[4],
			lanes_hi[4],
			lanes_lo[5],
			lanes_hi[5],
			lanes_lo[6],
			lanes_hi[6],
			lanes_lo[7],
			lanes_hi[7],
			lanes_lo[8],
			lanes_hi[8],
			lanes_lo[9],
			lanes_hi[9],
			lanes_lo[10],
			lanes_hi[10],
			lanes_lo[11],
			lanes_hi[11],
			lanes_lo[12],
			lanes_hi[12],
			lanes_lo[13],
			lanes_hi[13],
			lanes_lo[14],
			lanes_hi[14],
			lanes_lo[15],
			lanes_hi[15],
			lanes_lo[16],
			lanes_hi[16],
			lanes_lo[17],
			lanes_hi[17],
			lanes_lo[18],
			lanes_hi[18],
			lanes_lo[19],
			lanes_hi[19],
			lanes_lo[20],
			lanes_hi[20],
			lanes_lo[21],
			lanes_hi[21],
			lanes_lo[22],
			lanes_hi[22],
			lanes_lo[23],
			lanes_hi[23],
			lanes_lo[24],
			lanes_hi[24],
			lanes_lo[25],
			lanes_hi[25]

		for round_idx = 1, 24 do
			local C1_lo = bit32_bxor(L01_lo, L06_lo, L11_lo, L16_lo, L21_lo)
			local C1_hi = bit32_bxor(L01_hi, L06_hi, L11_hi, L16_hi, L21_hi)
			local C2_lo = bit32_bxor(L02_lo, L07_lo, L12_lo, L17_lo, L22_lo)
			local C2_hi = bit32_bxor(L02_hi, L07_hi, L12_hi, L17_hi, L22_hi)
			local C3_lo = bit32_bxor(L03_lo, L08_lo, L13_lo, L18_lo, L23_lo)
			local C3_hi = bit32_bxor(L03_hi, L08_hi, L13_hi, L18_hi, L23_hi)
			local C4_lo = bit32_bxor(L04_lo, L09_lo, L14_lo, L19_lo, L24_lo)
			local C4_hi = bit32_bxor(L04_hi, L09_hi, L14_hi, L19_hi, L24_hi)
			local C5_lo = bit32_bxor(L05_lo, L10_lo, L15_lo, L20_lo, L25_lo)
			local C5_hi = bit32_bxor(L05_hi, L10_hi, L15_hi, L20_hi, L25_hi)

			local D_lo = bit32_bxor(C1_lo, C3_lo * 2 + (C3_hi % TWO_POW_32 - C3_hi % TWO_POW_31) / TWO_POW_31)
			local D_hi = bit32_bxor(C1_hi, C3_hi * 2 + (C3_lo % TWO_POW_32 - C3_lo % TWO_POW_31) / TWO_POW_31)

			local T0_lo = bit32_bxor(D_lo, L02_lo)
			local T0_hi = bit32_bxor(D_hi, L02_hi)
			local T1_lo = bit32_bxor(D_lo, L07_lo)
			local T1_hi = bit32_bxor(D_hi, L07_hi)
			local T2_lo = bit32_bxor(D_lo, L12_lo)
			local T2_hi = bit32_bxor(D_hi, L12_hi)
			local T3_lo = bit32_bxor(D_lo, L17_lo)
			local T3_hi = bit32_bxor(D_hi, L17_hi)
			local T4_lo = bit32_bxor(D_lo, L22_lo)
			local T4_hi = bit32_bxor(D_hi, L22_hi)

			L02_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_20) / TWO_POW_20 + T1_hi * TWO_POW_12
			L02_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_20) / TWO_POW_20 + T1_lo * TWO_POW_12
			L07_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_19) / TWO_POW_19 + T3_hi * TWO_POW_13
			L07_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_19) / TWO_POW_19 + T3_lo * TWO_POW_13
			L12_lo = T0_lo * 2 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_31) / TWO_POW_31
			L12_hi = T0_hi * 2 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_31) / TWO_POW_31
			L17_lo = T2_lo * TWO_POW_10 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_22) / TWO_POW_22
			L17_hi = T2_hi * TWO_POW_10 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_22) / TWO_POW_22
			L22_lo = T4_lo * TWO_POW_2 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_30) / TWO_POW_30
			L22_hi = T4_hi * TWO_POW_2 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_30) / TWO_POW_30

			D_lo = bit32_bxor(C2_lo, C4_lo * 2 + (C4_hi % TWO_POW_32 - C4_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C2_hi, C4_hi * 2 + (C4_lo % TWO_POW_32 - C4_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L03_lo)
			T0_hi = bit32_bxor(D_hi, L03_hi)
			T1_lo = bit32_bxor(D_lo, L08_lo)
			T1_hi = bit32_bxor(D_hi, L08_hi)
			T2_lo = bit32_bxor(D_lo, L13_lo)
			T2_hi = bit32_bxor(D_hi, L13_hi)
			T3_lo = bit32_bxor(D_lo, L18_lo)
			T3_hi = bit32_bxor(D_hi, L18_hi)
			T4_lo = bit32_bxor(D_lo, L23_lo)
			T4_hi = bit32_bxor(D_hi, L23_hi)

			L03_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_21) / TWO_POW_21 + T2_hi * TWO_POW_11
			L03_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_21) / TWO_POW_21 + T2_lo * TWO_POW_11
			L08_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_3) / TWO_POW_3 + T4_hi * TWO_POW_29 % TWO_POW_32
			L08_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_3) / TWO_POW_3 + T4_lo * TWO_POW_29 % TWO_POW_32
			L13_lo = T1_lo * TWO_POW_6 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_26) / TWO_POW_26
			L13_hi = T1_hi * TWO_POW_6 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_26) / TWO_POW_26
			L18_lo = T3_lo * TWO_POW_15 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_17) / TWO_POW_17
			L18_hi = T3_hi * TWO_POW_15 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_17) / TWO_POW_17
			L23_lo = (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_2) / TWO_POW_2 + T0_hi * TWO_POW_30 % TWO_POW_32
			L23_hi = (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_2) / TWO_POW_2 + T0_lo * TWO_POW_30 % TWO_POW_32

			D_lo = bit32_bxor(C3_lo, C5_lo * 2 + (C5_hi % TWO_POW_32 - C5_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C3_hi, C5_hi * 2 + (C5_lo % TWO_POW_32 - C5_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L04_lo)
			T0_hi = bit32_bxor(D_hi, L04_hi)
			T1_lo = bit32_bxor(D_lo, L09_lo)
			T1_hi = bit32_bxor(D_hi, L09_hi)
			T2_lo = bit32_bxor(D_lo, L14_lo)
			T2_hi = bit32_bxor(D_hi, L14_hi)
			T3_lo = bit32_bxor(D_lo, L19_lo)
			T3_hi = bit32_bxor(D_hi, L19_hi)
			T4_lo = bit32_bxor(D_lo, L24_lo)
			T4_hi = bit32_bxor(D_hi, L24_hi)

			L04_lo = T3_lo * TWO_POW_21 % TWO_POW_32 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_11) / TWO_POW_11
			L04_hi = T3_hi * TWO_POW_21 % TWO_POW_32 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_11) / TWO_POW_11
			L09_lo = T0_lo * TWO_POW_28 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_4) / TWO_POW_4
			L09_hi = T0_hi * TWO_POW_28 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_4) / TWO_POW_4
			L14_lo = T2_lo * TWO_POW_25 % TWO_POW_32 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_7) / TWO_POW_7
			L14_hi = T2_hi * TWO_POW_25 % TWO_POW_32 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_7) / TWO_POW_7
			L19_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_8) / TWO_POW_8 + T4_hi * TWO_POW_24 % TWO_POW_32
			L19_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_8) / TWO_POW_8 + T4_lo * TWO_POW_24 % TWO_POW_32
			L24_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_9) / TWO_POW_9 + T1_hi * TWO_POW_23 % TWO_POW_32
			L24_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_9) / TWO_POW_9 + T1_lo * TWO_POW_23 % TWO_POW_32

			D_lo = bit32_bxor(C4_lo, C1_lo * 2 + (C1_hi % TWO_POW_32 - C1_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C4_hi, C1_hi * 2 + (C1_lo % TWO_POW_32 - C1_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L05_lo)
			T0_hi = bit32_bxor(D_hi, L05_hi)
			T1_lo = bit32_bxor(D_lo, L10_lo)
			T1_hi = bit32_bxor(D_hi, L10_hi)
			T2_lo = bit32_bxor(D_lo, L15_lo)
			T2_hi = bit32_bxor(D_hi, L15_hi)
			T3_lo = bit32_bxor(D_lo, L20_lo)
			T3_hi = bit32_bxor(D_hi, L20_hi)
			T4_lo = bit32_bxor(D_lo, L25_lo)
			T4_hi = bit32_bxor(D_hi, L25_hi)

			L05_lo = T4_lo * TWO_POW_14 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_18) / TWO_POW_18
			L05_hi = T4_hi * TWO_POW_14 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_18) / TWO_POW_18
			L10_lo = T1_lo * TWO_POW_20 % TWO_POW_32 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_12) / TWO_POW_12
			L10_hi = T1_hi * TWO_POW_20 % TWO_POW_32 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_12) / TWO_POW_12
			L15_lo = T3_lo * TWO_POW_8 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_24) / TWO_POW_24
			L15_hi = T3_hi * TWO_POW_8 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_24) / TWO_POW_24
			L20_lo = T0_lo * TWO_POW_27 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_5) / TWO_POW_5
			L20_hi = T0_hi * TWO_POW_27 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_5) / TWO_POW_5
			L25_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_25) / TWO_POW_25 + T2_hi * TWO_POW_7
			L25_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_25) / TWO_POW_25 + T2_lo * TWO_POW_7

			D_lo = bit32_bxor(C5_lo, C2_lo * 2 + (C2_hi % TWO_POW_32 - C2_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C5_hi, C2_hi * 2 + (C2_lo % TWO_POW_32 - C2_lo % TWO_POW_31) / TWO_POW_31)

			T1_lo = bit32_bxor(D_lo, L06_lo)
			T1_hi = bit32_bxor(D_hi, L06_hi)
			T2_lo = bit32_bxor(D_lo, L11_lo)
			T2_hi = bit32_bxor(D_hi, L11_hi)
			T3_lo = bit32_bxor(D_lo, L16_lo)
			T3_hi = bit32_bxor(D_hi, L16_hi)
			T4_lo = bit32_bxor(D_lo, L21_lo)
			T4_hi = bit32_bxor(D_hi, L21_hi)

			L06_lo = T2_lo * TWO_POW_3 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_29) / TWO_POW_29
			L06_hi = T2_hi * TWO_POW_3 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_29) / TWO_POW_29
			L11_lo = T4_lo * TWO_POW_18 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_14) / TWO_POW_14
			L11_hi = T4_hi * TWO_POW_18 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_14) / TWO_POW_14
			L16_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_28) / TWO_POW_28 + T1_hi * TWO_POW_4
			L16_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_28) / TWO_POW_28 + T1_lo * TWO_POW_4
			L21_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_23) / TWO_POW_23 + T3_hi * TWO_POW_9
			L21_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_23) / TWO_POW_23 + T3_lo * TWO_POW_9

			L01_lo = bit32_bxor(D_lo, L01_lo)
			L01_hi = bit32_bxor(D_hi, L01_hi)
			L01_lo, L02_lo, L03_lo, L04_lo, L05_lo =
				bit32_bxor(L01_lo, bit32_band(-1 - L02_lo, L03_lo)),
				bit32_bxor(L02_lo, bit32_band(-1 - L03_lo, L04_lo)),
				bit32_bxor(L03_lo, bit32_band(-1 - L04_lo, L05_lo)),
				bit32_bxor(L04_lo, bit32_band(-1 - L05_lo, L01_lo)),
				bit32_bxor(L05_lo, bit32_band(-1 - L01_lo, L02_lo))
			L01_hi, L02_hi, L03_hi, L04_hi, L05_hi =
				bit32_bxor(L01_hi, bit32_band(-1 - L02_hi, L03_hi)),
				bit32_bxor(L02_hi, bit32_band(-1 - L03_hi, L04_hi)),
				bit32_bxor(L03_hi, bit32_band(-1 - L04_hi, L05_hi)),
				bit32_bxor(L04_hi, bit32_band(-1 - L05_hi, L01_hi)),
				bit32_bxor(L05_hi, bit32_band(-1 - L01_hi, L02_hi))
			L06_lo, L07_lo, L08_lo, L09_lo, L10_lo =
				bit32_bxor(L09_lo, bit32_band(-1 - L10_lo, L06_lo)),
				bit32_bxor(L10_lo, bit32_band(-1 - L06_lo, L07_lo)),
				bit32_bxor(L06_lo, bit32_band(-1 - L07_lo, L08_lo)),
				bit32_bxor(L07_lo, bit32_band(-1 - L08_lo, L09_lo)),
				bit32_bxor(L08_lo, bit32_band(-1 - L09_lo, L10_lo))
			L06_hi, L07_hi, L08_hi, L09_hi, L10_hi =
				bit32_bxor(L09_hi, bit32_band(-1 - L10_hi, L06_hi)),
				bit32_bxor(L10_hi, bit32_band(-1 - L06_hi, L07_hi)),
				bit32_bxor(L06_hi, bit32_band(-1 - L07_hi, L08_hi)),
				bit32_bxor(L07_hi, bit32_band(-1 - L08_hi, L09_hi)),
				bit32_bxor(L08_hi, bit32_band(-1 - L09_hi, L10_hi))
			L11_lo, L12_lo, L13_lo, L14_lo, L15_lo =
				bit32_bxor(L12_lo, bit32_band(-1 - L13_lo, L14_lo)),
				bit32_bxor(L13_lo, bit32_band(-1 - L14_lo, L15_lo)),
				bit32_bxor(L14_lo, bit32_band(-1 - L15_lo, L11_lo)),
				bit32_bxor(L15_lo, bit32_band(-1 - L11_lo, L12_lo)),
				bit32_bxor(L11_lo, bit32_band(-1 - L12_lo, L13_lo))
			L11_hi, L12_hi, L13_hi, L14_hi, L15_hi =
				bit32_bxor(L12_hi, bit32_band(-1 - L13_hi, L14_hi)),
				bit32_bxor(L13_hi, bit32_band(-1 - L14_hi, L15_hi)),
				bit32_bxor(L14_hi, bit32_band(-1 - L15_hi, L11_hi)),
				bit32_bxor(L15_hi, bit32_band(-1 - L11_hi, L12_hi)),
				bit32_bxor(L11_hi, bit32_band(-1 - L12_hi, L13_hi))
			L16_lo, L17_lo, L18_lo, L19_lo, L20_lo =
				bit32_bxor(L20_lo, bit32_band(-1 - L16_lo, L17_lo)),
				bit32_bxor(L16_lo, bit32_band(-1 - L17_lo, L18_lo)),
				bit32_bxor(L17_lo, bit32_band(-1 - L18_lo, L19_lo)),
				bit32_bxor(L18_lo, bit32_band(-1 - L19_lo, L20_lo)),
				bit32_bxor(L19_lo, bit32_band(-1 - L20_lo, L16_lo))
			L16_hi, L17_hi, L18_hi, L19_hi, L20_hi =
				bit32_bxor(L20_hi, bit32_band(-1 - L16_hi, L17_hi)),
				bit32_bxor(L16_hi, bit32_band(-1 - L17_hi, L18_hi)),
				bit32_bxor(L17_hi, bit32_band(-1 - L18_hi, L19_hi)),
				bit32_bxor(L18_hi, bit32_band(-1 - L19_hi, L20_hi)),
				bit32_bxor(L19_hi, bit32_band(-1 - L20_hi, L16_hi))
			L21_lo, L22_lo, L23_lo, L24_lo, L25_lo =
				bit32_bxor(L23_lo, bit32_band(-1 - L24_lo, L25_lo)),
				bit32_bxor(L24_lo, bit32_band(-1 - L25_lo, L21_lo)),
				bit32_bxor(L25_lo, bit32_band(-1 - L21_lo, L22_lo)),
				bit32_bxor(L21_lo, bit32_band(-1 - L22_lo, L23_lo)),
				bit32_bxor(L22_lo, bit32_band(-1 - L23_lo, L24_lo))
			L21_hi, L22_hi, L23_hi, L24_hi, L25_hi =
				bit32_bxor(L23_hi, bit32_band(-1 - L24_hi, L25_hi)),
				bit32_bxor(L24_hi, bit32_band(-1 - L25_hi, L21_hi)),
				bit32_bxor(L25_hi, bit32_band(-1 - L21_hi, L22_hi)),
				bit32_bxor(L21_hi, bit32_band(-1 - L22_hi, L23_hi)),
				bit32_bxor(L22_hi, bit32_band(-1 - L23_hi, L24_hi))
			L01_lo = bit32_bxor(L01_lo, RC_lo[round_idx])
			L01_hi = L01_hi + RC_hi[round_idx] -- RC_hi[] is either 0 or 0x80000000, so we could use fast addition instead of slow XOR
		end

		lanes_lo[1] = L01_lo
		lanes_hi[1] = L01_hi
		lanes_lo[2] = L02_lo
		lanes_hi[2] = L02_hi
		lanes_lo[3] = L03_lo
		lanes_hi[3] = L03_hi
		lanes_lo[4] = L04_lo
		lanes_hi[4] = L04_hi
		lanes_lo[5] = L05_lo
		lanes_hi[5] = L05_hi
		lanes_lo[6] = L06_lo
		lanes_hi[6] = L06_hi
		lanes_lo[7] = L07_lo
		lanes_hi[7] = L07_hi
		lanes_lo[8] = L08_lo
		lanes_hi[8] = L08_hi
		lanes_lo[9] = L09_lo
		lanes_hi[9] = L09_hi
		lanes_lo[10] = L10_lo
		lanes_hi[10] = L10_hi
		lanes_lo[11] = L11_lo
		lanes_hi[11] = L11_hi
		lanes_lo[12] = L12_lo
		lanes_hi[12] = L12_hi
		lanes_lo[13] = L13_lo
		lanes_hi[13] = L13_hi
		lanes_lo[14] = L14_lo
		lanes_hi[14] = L14_hi
		lanes_lo[15] = L15_lo
		lanes_hi[15] = L15_hi
		lanes_lo[16] = L16_lo
		lanes_hi[16] = L16_hi
		lanes_lo[17] = L17_lo
		lanes_hi[17] = L17_hi
		lanes_lo[18] = L18_lo
		lanes_hi[18] = L18_hi
		lanes_lo[19] = L19_lo
		lanes_hi[19] = L19_hi
		lanes_lo[20] = L20_lo
		lanes_hi[20] = L20_hi
		lanes_lo[21] = L21_lo
		lanes_hi[21] = L21_hi
		lanes_lo[22] = L22_lo
		lanes_hi[22] = L22_hi
		lanes_lo[23] = L23_lo
		lanes_hi[23] = L23_hi
		lanes_lo[24] = L24_lo
		lanes_hi[24] = L24_hi
		lanes_lo[25] = L25_lo
		lanes_hi[25] = L25_hi
	end
end

--------------------------------------------------------------------------------
-- MAGIC NUMBERS CALCULATOR
--------------------------------------------------------------------------------
-- Q:
--    Is 53-bit "double" math enough to calculate square roots and cube roots of primes with 64 correct bits after decimal point?
-- A:
--    Yes, 53-bit "double" arithmetic is enough.
--    We could obtain first 40 bits by direct calculation of p^(1/3) and next 40 bits by one step of Newton's method.
do
	local function mul(src1, src2, factor, result_length)
		-- src1, src2 - long integers (arrays of digits in base TWO_POW_24)
		-- factor - small integer
		-- returns long integer result (src1 * src2 * factor) and its floating point approximation
		local result, carry, value, weight = table.create(result_length), 0.0, 0.0, 1.0
		for j = 1, result_length do
			for k = math.max(1, j + 1 - #src2), math.min(j, #src1) do
				carry = carry + factor * src1[k] * src2[j + 1 - k] -- "int32" is not enough for multiplication result, that's why "factor" must be of type "double"
			end

			local digit = carry % TWO_POW_24
			result[j] = math.floor(digit)
			carry = (carry - digit) / TWO_POW_24
			value = value + digit * weight
			weight = weight * TWO_POW_24
		end

		return result, value
	end

	local idx, step, p, one, sqrt_hi, sqrt_lo = 0, { 4, 1, 2, -2, 2 }, 4, { 1 }, sha2_H_hi, sha2_H_lo
	repeat
		p = p + step[p % 6]
		local d = 1
		repeat
			d = d + step[d % 6]
			if d * d > p then
				-- next prime number is found
				local root = p ^ (1 / 3)
				local R = root * TWO_POW_40
				R = mul(table.create(1, math.floor(R)), one, 1.0, 2)
				local _, delta = mul(R, mul(R, R, 1.0, 4), -1.0, 4)
				local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
				local lo = R[1] % 256 * 16777216 + math.floor(delta * (TWO_POW_NEG_56 / 3) * root / p)

				if idx < 16 then
					root = math.sqrt(p)
					R = root * TWO_POW_40
					R = mul(table.create(1, math.floor(R)), one, 1.0, 2)
					_, delta = mul(R, R, -1.0, 2)

					local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
					local lo = R[1] % 256 * 16777216 + math.floor(delta * TWO_POW_NEG_17 / root)
					local idx = idx % 8 + 1
					sha2_H_ext256[224][idx] = lo
					sqrt_hi[idx], sqrt_lo[idx] = hi, lo + hi * hi_factor

					if idx > 7 then
						sqrt_hi, sqrt_lo = sha2_H_ext512_hi[384], sha2_H_ext512_lo[384]
					end
				end

				idx = idx + 1
				sha2_K_hi[idx], sha2_K_lo[idx] = hi, lo % K_lo_modulo + hi * hi_factor
				break
			end
		until p % d == 0
	until idx > 79
end

-- Calculating IVs for SHA512/224 and SHA512/256
for width = 224, 256, 32 do
	local H_lo, H_hi = {}, nil
	if XOR64A5 then
		for j = 1, 8 do
			H_lo[j] = XOR64A5(sha2_H_lo[j])
		end
	else
		H_hi = {}
		for j = 1, 8 do
			H_lo[j] = bit32_bxor(sha2_H_lo[j], 0xA5A5A5A5) % 4294967296
			H_hi[j] = bit32_bxor(sha2_H_hi[j], 0xA5A5A5A5) % 4294967296
		end
	end

	sha512_feed_128(H_lo, H_hi, "SHA-512/" .. tostring(width) .. "\128" .. string.rep("\0", 115) .. "\88", 0, 128)
	sha2_H_ext512_lo[width] = H_lo
	sha2_H_ext512_hi[width] = H_hi
end

-- Constants for MD5
do
	for idx = 1, 64 do
		-- we can't use formula math.floor(abs(sin(idx))*TWO_POW_32) because its result may be beyond integer range on Lua built with 32-bit integers
		local hi, lo = math.modf(math.abs(math.sin(idx)) * TWO_POW_16)
		md5_K[idx] = hi * 65536 + math.floor(lo * TWO_POW_16)
	end
end

-- Constants for SHA3
do
	local sh_reg = 29
	local function next_bit()
		local r = sh_reg % 2
		sh_reg = bit32_bxor((sh_reg - r) / 2, 142 * r)
		return r
	end

	for idx = 1, 24 do
		local lo, m = 0, nil
		for _ = 1, 6 do
			m = m and m * m * 2 or 1
			lo = lo + next_bit() * m
		end

		local hi = next_bit() * m
		sha3_RC_hi[idx], sha3_RC_lo[idx] = hi, lo + hi * hi_factor_keccak
	end
end

--------------------------------------------------------------------------------
-- MAIN FUNCTIONS
--------------------------------------------------------------------------------
local function sha256ext(width, message)
	-- Create an instance (private objects for current calculation)
	local Array256 = sha2_H_ext256[width] -- # == 8
	local length, tail = 0.0, ""
	local H = table.create(8)
	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] =
		Array256[1], Array256[2], Array256[3], Array256[4], Array256[5], Array256[6], Array256[7], Array256[8]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					sha256_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha256_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- Anyway, it looks very unrealistic that someone would spend more than a year of calculations to process TWO_POW_53 bytes of data by using this Lua script :-)
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha256_feed_64(H, final_blocks, 0, #final_blocks)
				local max_reg = width / 32
				for j = 1, max_reg do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H, "", 1, max_reg)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA256 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA256 digest by invoking this function without an argument
		return partial
	end
end

local function sha512ext(width, message)
	-- Create an instance (private objects for current calculation)
	local length, tail, H_lo, H_hi =
		0.0,
		"",
		table.pack(table.unpack(sha2_H_ext512_lo[width])),
		not HEX64 and table.pack(table.unpack(sha2_H_ext512_hi[width]))

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 128 then
					offs = 128 - #tail
					sha512_feed_128(H_lo, H_hi, tail .. string.sub(message_part, 1, offs), 0, 128)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 128
				sha512_feed_128(H_lo, H_hi, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-17-length) % 128 + 9)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-17 - length) % 128 + 9)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-17 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move floating point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha512_feed_128(H_lo, H_hi, final_blocks, 0, #final_blocks)
				local max_reg = math.ceil(width / 64)

				if HEX64 then
					for j = 1, max_reg do
						H_lo[j] = HEX64(H_lo[j])
					end
				else
					for j = 1, max_reg do
						H_lo[j] = string.format("%08x", H_hi[j] % 4294967296)
							.. string.format("%08x", H_lo[j] % 4294967296)
					end

					H_hi = nil
				end

				H_lo = string.sub(table.concat(H_lo, "", 1, max_reg), 1, width / 4)
			end

			return H_lo
		end
	end

	if message then
		-- Actually perform calculations and return the SHA512 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA512 digest by invoking this function without an argument
		return partial
	end
end

local function md5(message)
	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.create(4), 0.0, ""
	H[1], H[2], H[3], H[4] = md5_sha1_H[1], md5_sha1_H[2], md5_sha1_H[3], md5_sha1_H[4]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					md5_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				md5_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(11) --{tail, "\128", string.rep("\0", (-9 - length) % 64)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64)

				tail = nil
				length = length * 8 -- convert "byte-counter" to "bit-counter"
				for j = 4, 11 do
					local low_byte = length % 256
					final_blocks[j] = string.char(low_byte)
					length = (length - low_byte) / 256
				end

				final_blocks = table.concat(final_blocks)
				md5_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 4 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = string.gsub(table.concat(H), "(..)(..)(..)(..)", "%4%3%2%1")
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the MD5 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get MD5 digest by invoking this function without an argument
		return partial
	end
end

local function sha1(message)
	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.pack(table.unpack(md5_sha1_H)), 0.0, ""

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					sha1_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha1_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha1_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 5 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA-1 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA-1 digest by invoking this function without an argument
		return partial
	end
end

local function keccak(block_size_in_bytes, digest_size_in_bytes, is_SHAKE, message)
	-- "block_size_in_bytes" is multiple of 8
	if type(digest_size_in_bytes) ~= "number" then
		-- arguments in SHAKE are swapped:
		--    NIST FIPS 202 defines SHAKE(message,num_bits)
		--    this module   defines SHAKE(num_bytes,message)
		-- it's easy to forget about this swap, hence the check
		error("Argument 'digest_size_in_bytes' must be a number", 2)
	end

	-- Create an instance (private objects for current calculation)
	local tail, lanes_lo, lanes_hi = "", table.create(25, 0), hi_factor_keccak == 0 and table.create(25, 0)
	local result

	--~     pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)/r is integer),
	--~     break P into n consecutive r-bit pieces P0, ..., Pn-1 (last is zero-padded)
	--~     initialize the state S to a string of b 0 bits.
	--~     absorb the input into the state: For each block Pi,
	--~         extend Pi at the end by a string of c 0 bits, yielding one of length b,
	--~         XOR that with S and
	--~         apply the block permutation f to the result, yielding a new state S
	--~     initialize Z to be the empty string
	--~     while the length of Z is less than d:
	--~         append the first r bits of S to Z
	--~         if Z is still less than d bits long, apply f to S, yielding a new state S.
	--~     truncate Z to d bits
	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				local offs = 0
				if tail ~= "" and #tail + partLength >= block_size_in_bytes then
					offs = block_size_in_bytes - #tail
					keccak_feed(
						lanes_lo,
						lanes_hi,
						tail .. string.sub(message_part, 1, offs),
						0,
						block_size_in_bytes,
						block_size_in_bytes
					)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % block_size_in_bytes
				keccak_feed(lanes_lo, lanes_hi, message_part, offs, size - size_tail, block_size_in_bytes)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				-- append the following bits to the message: for usual SHA3: 011(0*)1, for SHAKE: 11111(0*)1
				local gap_start = is_SHAKE and 31 or 6
				tail = tail
					.. (
						#tail + 1 == block_size_in_bytes and string.char(gap_start + 128)
						or string.char(gap_start) .. string.rep("\0", (-2 - #tail) % block_size_in_bytes) .. "\128"
					)
				keccak_feed(lanes_lo, lanes_hi, tail, 0, #tail, block_size_in_bytes)
				tail = nil

				local lanes_used = 0
				local total_lanes = math.floor(block_size_in_bytes / 8)
				local qwords = {}

				local function get_next_qwords_of_digest(qwords_qty)
					-- returns not more than 'qwords_qty' qwords ('qwords_qty' might be non-integer)
					-- doesn't go across keccak-buffer boundary
					-- block_size_in_bytes is a multiple of 8, so, keccak-buffer contains integer number of qwords
					if lanes_used >= total_lanes then
						keccak_feed(lanes_lo, lanes_hi, "\0\0\0\0\0\0\0\0", 0, 8, 8)
						lanes_used = 0
					end

					qwords_qty = math.floor(math.min(qwords_qty, total_lanes - lanes_used))
					if hi_factor_keccak ~= 0 then
						for j = 1, qwords_qty do
							qwords[j] = HEX64(lanes_lo[lanes_used + j - 1 + lanes_index_base])
						end
					else
						for j = 1, qwords_qty do
							qwords[j] = string.format("%08x", lanes_hi[lanes_used + j] % 4294967296)
								.. string.format("%08x", lanes_lo[lanes_used + j] % 4294967296)
						end
					end

					lanes_used = lanes_used + qwords_qty
					return string.gsub(
						table.concat(qwords, "", 1, qwords_qty),
						"(..)(..)(..)(..)(..)(..)(..)(..)",
						"%8%7%6%5%4%3%2%1"
					),
						qwords_qty * 8
				end

				local parts = {} -- digest parts
				local last_part, last_part_size = "", 0

				local function get_next_part_of_digest(bytes_needed)
					-- returns 'bytes_needed' bytes, for arbitrary integer 'bytes_needed'
					bytes_needed = bytes_needed or 1
					if bytes_needed <= last_part_size then
						last_part_size = last_part_size - bytes_needed
						local part_size_in_nibbles = bytes_needed * 2
						local result = string.sub(last_part, 1, part_size_in_nibbles)
						last_part = string.sub(last_part, part_size_in_nibbles + 1)
						return result
					end

					local parts_qty = 0
					if last_part_size > 0 then
						parts_qty = 1
						parts[parts_qty] = last_part
						bytes_needed = bytes_needed - last_part_size
					end

					-- repeats until the length is enough
					while bytes_needed >= 8 do
						local next_part, next_part_size = get_next_qwords_of_digest(bytes_needed / 8)
						parts_qty = parts_qty + 1
						parts[parts_qty] = next_part
						bytes_needed = bytes_needed - next_part_size
					end

					if bytes_needed > 0 then
						last_part, last_part_size = get_next_qwords_of_digest(1)
						parts_qty = parts_qty + 1
						parts[parts_qty] = get_next_part_of_digest(bytes_needed)
					else
						last_part, last_part_size = "", 0
					end

					return table.concat(parts, "", 1, parts_qty)
				end

				if digest_size_in_bytes < 0 then
					result = get_next_part_of_digest
				else
					result = get_next_part_of_digest(digest_size_in_bytes)
				end
			end

			return result
		end
	end

	if message then
		-- Actually perform calculations and return the SHA3 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA3 digest by invoking this function without an argument
		return partial
	end
end

local function HexToBinFunction(hh)
	return string.char(tonumber(hh, 16))
end

local function hex2bin(hex_string)
	return (string.gsub(hex_string, "%x%x", HexToBinFunction))
end

local base64_symbols = {
	["+"] = 62,
	["-"] = 62,
	[62] = "+",
	["/"] = 63,
	["_"] = 63,
	[63] = "/",
	["="] = -1,
	["."] = -1,
	[-1] = "=",
}

local symbol_index = 0
for j, pair in ipairs({ "AZ", "az", "09" }) do
	for ascii = string.byte(pair), string.byte(pair, 2) do
		local ch = string.char(ascii)
		base64_symbols[ch] = symbol_index
		base64_symbols[symbol_index] = ch
		symbol_index = symbol_index + 1
	end
end

local function bin2base64(binary_string)
	local result = table.create(math.ceil(#binary_string / 3))
	local length = 0

	for pos = 1, #binary_string, 3 do
		local c1, c2, c3, c4 = string.byte(string.sub(binary_string, pos, pos + 2) .. "\0", 1, -1)
		length = length + 1
		result[length] = base64_symbols[math.floor(c1 / 4)]
			.. base64_symbols[c1 % 4 * 16 + math.floor(c2 / 16)]
			.. base64_symbols[c3 and c2 % 16 * 4 + math.floor(c3 / 64) or -1]
			.. base64_symbols[c4 and c3 % 64 or -1]
	end

	return table.concat(result)
end

local function base642bin(base64_string)
	local result, chars_qty = {}, 3
	for pos, ch in string.gmatch(string.gsub(base64_string, "%s+", ""), "()(.)") do
		local code = base64_symbols[ch]
		if code < 0 then
			chars_qty = chars_qty - 1
			code = 0
		end

		local idx = pos % 4
		if idx > 0 then
			result[-idx] = code
		else
			local c1 = result[-1] * 4 + math.floor(result[-2] / 16)
			local c2 = (result[-2] % 16) * 16 + math.floor(result[-3] / 4)
			local c3 = (result[-3] % 4) * 64 + code
			result[#result + 1] = string.sub(string.char(c1, c2, c3), 1, chars_qty)
		end
	end

	return table.concat(result)
end

local block_size_for_HMAC -- this table will be initialized at the end of the module
local function pad_and_xor(str, result_length, byte_for_xor)
	return string.gsub(str, ".", function(c)
		return string.char(bit32_bxor(string.byte(c), byte_for_xor))
	end) .. string.rep(string.char(byte_for_xor), result_length - #str)
end

-- For the sake of speed of converting hexes to strings, there's a map of the conversions here
local BinaryStringMap = {}
for Index = 0, 255 do
	BinaryStringMap[string.format("%02x", Index)] = string.char(Index)
end

-- Update 02.14.20 - added AsBinary for easy GameAnalytics replacement.
local function hmac(hash_func, key, message, AsBinary)
	-- Create an instance (private objects for current calculation)
	local block_size = block_size_for_HMAC[hash_func]
	if not block_size then
		error("Unknown hash function", 2)
	end

	if #key > block_size then
		key = string.gsub(hash_func(key), "%x%x", HexToBinFunction)
		--key = hex2bin(hash_func(key))
	end

	local append = hash_func()(pad_and_xor(key, block_size, 0x36))
	local result

	local function partial(message_part)
		if not message_part then
			result = result
				or hash_func(pad_and_xor(key, block_size, 0x5C) .. (string.gsub(append(), "%x%x", HexToBinFunction)))
			return result
		elseif result then
			error("Adding more chunks is not allowed after receiving the result", 2)
		else
			append(message_part)
			return partial
		end
	end

	if message then
		-- Actually perform calculations and return the HMAC of a message
		local FinalMessage = partial(message)()
		return AsBinary and (string.gsub(FinalMessage, "%x%x", BinaryStringMap)) or FinalMessage
	else
		-- Return function for chunk-by-chunk loading of a message
		-- User should feed every chunk of the message as single argument to this function and finally get HMAC by invoking this function without an argument
		return partial
	end
end

local sha = {
	md5 = md5,
	sha1 = sha1,
	-- SHA2 hash functions:
	sha224 = function(message)
		return sha256ext(224, message)
	end,

	sha256 = function(message)
		return sha256ext(256, message)
	end,

	sha512_224 = function(message)
		return sha512ext(224, message)
	end,

	sha512_256 = function(message)
		return sha512ext(256, message)
	end,

	sha384 = function(message)
		return sha512ext(384, message)
	end,

	sha512 = function(message)
		return sha512ext(512, message)
	end,

	-- SHA3 hash functions:
	sha3_224 = function(message)
		return keccak((1600 - 2 * 224) / 8, 224 / 8, false, message)
	end,

	sha3_256 = function(message)
		return keccak((1600 - 2 * 256) / 8, 256 / 8, false, message)
	end,

	sha3_384 = function(message)
		return keccak((1600 - 2 * 384) / 8, 384 / 8, false, message)
	end,

	sha3_512 = function(message)
		return keccak((1600 - 2 * 512) / 8, 512 / 8, false, message)
	end,

	shake128 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 128) / 8, digest_size_in_bytes, true, message)
	end,

	shake256 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 256) / 8, digest_size_in_bytes, true, message)
	end,

	-- misc utilities:
	hmac = hmac, -- HMAC(hash_func, key, message) is applicable to any hash function from this module except SHAKE*
	hex_to_bin = hex2bin, -- converts hexadecimal representation to binary string
	base64_to_bin = base642bin, -- converts base64 representation to binary string
	bin_to_base64 = bin2base64,
	base64_encode = Base64.Encode,
	base64_decode = Base64.Decode,
	-- converts binary string to base64 representation
}

block_size_for_HMAC = {
	[sha.md5] = 64,
	[sha.sha1] = 64,
	[sha.sha224] = 64,
	[sha.sha256] = 64,
	[sha.sha512_224] = 128,
	[sha.sha512_256] = 128,
	[sha.sha384] = 128,
	[sha.sha512] = 128,
	[sha.sha3_224] = (1600 - 2 * 224) / 8,
	[sha.sha3_256] = (1600 - 2 * 256) / 8,
	[sha.sha3_384] = (1600 - 2 * 384) / 8,
	[sha.sha3_512] = (1600 - 2 * 512) / 8,
}

return sha]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXBA48412150E14629A16DF01FE7141DB6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">HashLib</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXA8FC1E69078B4C6F9A66395E40F064E6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Base64.lua</string>
									<string name="ScriptGuid">{F0AB4242-39B9-4A6F-B978-0C4F00CCEAE5}</string>
									<ProtectedString name="Source"><![CDATA[-- @original: https://gist.github.com/Reselim/40d62b17d138cc74335a1b0709e19ce2
local Alphabet = {}
local Indexes = {}

-- A-Z
for Index = 65, 90 do
	table.insert(Alphabet, Index)
end

-- a-z
for Index = 97, 122 do
	table.insert(Alphabet, Index)
end

-- 0-9
for Index = 48, 57 do
	table.insert(Alphabet, Index)
end

table.insert(Alphabet, 43) -- +
table.insert(Alphabet, 47) -- /

for Index, Character in ipairs(Alphabet) do
	Indexes[Character] = Index
end

local Base64 = {}

local bit32_rshift = bit32.rshift
local bit32_lshift = bit32.lshift
local bit32_band = bit32.band

--[[**
	Encodes a string in Base64.
	@param [t:string] Input The input string to encode.
	@returns [t:string] The string encoded in Base64.
**--]]
function Base64.Encode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 3 do
		local C1, C2, C3 = string.byte(Input, Index, Index + 2)

		local A = bit32_rshift(C1, 2)
		local B = bit32_lshift(bit32_band(C1, 3), 4) + bit32_rshift(C2 or 0, 4)
		local C = bit32_lshift(bit32_band(C2 or 0, 15), 2) + bit32_rshift(C3 or 0, 6)
		local D = bit32_band(C3 or 0, 63)

		Length = Length + 1
		Output[Length] = Alphabet[A + 1]

		Length = Length + 1
		Output[Length] = Alphabet[B + 1]

		Length = Length + 1
		Output[Length] = C2 and Alphabet[C + 1] or 61

		Length = Length + 1
		Output[Length] = C3 and Alphabet[D + 1] or 61
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] =
			string.char(table.unpack(Output, Index, IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1))
	end

	return table.concat(NewOutput)
end

--[[**
	Decodes a string from Base64.
	@param [t:string] Input The input string to decode.
	@returns [t:string] The newly decoded string.
**--]]
function Base64.Decode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 4 do
		local C1, C2, C3, C4 = string.byte(Input, Index, Index + 3)

		local I1 = Indexes[C1] - 1
		local I2 = Indexes[C2] - 1
		local I3 = (Indexes[C3] or 1) - 1
		local I4 = (Indexes[C4] or 1) - 1

		local A = bit32_lshift(I1, 2) + bit32_rshift(I2, 4)
		local B = bit32_lshift(bit32_band(I2, 15), 4) + bit32_rshift(I3, 2)
		local C = bit32_lshift(bit32_band(I3, 3), 6) + I4

		Length = Length + 1
		Output[Length] = A

		if C3 ~= 61 then
			Length = Length + 1
			Output[Length] = B
		end

		if C4 ~= 61 then
			Length = Length + 1
			Output[Length] = C
		end
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] =
			string.char(table.unpack(Output, Index, IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1))
	end

	return table.concat(NewOutput)
end

return Base64]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX02C189AA08FE4CE084FDFB0638F13226">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Logger.lua</string>
							<string name="ScriptGuid">{6691F6B1-8083-440F-AE5C-C29502A41C2E}</string>
							<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
--local GameAnalyticsSendMessage

local logger = {
	_infoLogEnabled = false,
	_infoLogAdvancedEnabled = false,
	_debugEnabled = false --RunService:IsStudio(),
}

function logger:setDebugLog(enabled)
	self._debugEnabled = enabled
end

function logger:setInfoLog(enabled)
	self._infoLogEnabled = enabled
end

function logger:setVerboseLog(enabled)
	self._infoLogAdvancedEnabled = enabled
end

function logger:i(format)
	if not self._infoLogEnabled then
		return
	end

	local m = "Info/GameAnalytics: " .. format
	print(m)
	--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
	--    GameAnalyticsSendMessage:FireAllClients({
	--        Text = m,
	--        Font = Enum.Font.Arial,
	--        Color = Color3.new(255, 255, 255),
	--        FontSize = Enum.FontSize.Size96
	--    })
end

function logger:w(format)
	local m = "Warning/GameAnalytics: " .. format
	warn(m)
	--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
	--    GameAnalyticsSendMessage:FireAllClients({
	--        Text = m,
	--        Font = Enum.Font.Arial,
	--        Color = Color3.new(255, 255, 0),
	--        FontSize = Enum.FontSize.Size96
	--    })
end

function logger:e(format)
	task.spawn(function()
		local m = "Error/GameAnalytics: " .. format
		error(m, 0)
		--        GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
		--        GameAnalyticsSendMessage:FireAllClients({
		--            Text = m,
		--            Font = Enum.Font.Arial,
		--            Color = Color3.new(255, 0, 0),
		--            FontSize = Enum.FontSize.Size96
		--        })
	end)
end

function logger:d(format)
	if not self._debugEnabled then
		return
	end

	local m = "Debug/GameAnalytics: " .. format
	print(m)
	--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
	--    GameAnalyticsSendMessage:FireAllClients({
	--        Text = m,
	--        Font = Enum.Font.Arial,
	--        Color = Color3.new(255, 255, 255),
	--        FontSize = Enum.FontSize.Size96
	--    })
end

function logger:ii(format)
	if not self._infoLogAdvancedEnabled then
		return
	end

	local m = "Verbose/GameAnalytics: " .. format
	print(m)
	--    GameAnalyticsSendMessage = GameAnalyticsSendMessage or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsSendMessage")
	--    GameAnalyticsSendMessage:FireAllClients({
	--        Text = m,
	--        Font = Enum.Font.Arial,
	--        Color = Color3.new(255, 255, 255),
	--        FontSize = Enum.FontSize.Size96
	--    })
end

return logger]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8A58331B383F4945A35C6327F2E0A06A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Postie.lua</string>
							<string name="ScriptGuid">{442000B3-4258-42B3-A1CD-40510D4FBE51}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	Postie 1.1.0 by BenSBk
	Depends on:
	- The Roblox API
	- A RemoteEvent named Sent
	- A RemoteEvent named Received

	Postie is a safe alternative to RemoteFunctions with a time-out.

	Postie.invokeClient( // yields, server-side
		player: Player,
		id: string,
		timeOut: number,
		...data: any
	) => didRespond: boolean, ...response: any

		Invoke player with sent data. Invocation identified by id. Yield until
		timeOut (given in seconds) is reached and return false, or a response is
		received back from the client and return true plus the data returned
		from the client. If the invocation reaches the client, but the client
		doesn't have a corresponding callback, return before timeOut regardless
		but return false.

	Postie.invokeServer( // yields, client-side
		id: string,
		timeOut: number,
		...data: any
	) => didRespond: boolean, ...response: any

		Invoke the server with sent data. Invocation identified by id. Yield
		until timeOut (given in seconds) is reached and return false, or a
		response is received back from the server and return true plus the data
		returned from the server. If the invocation reaches the server, but the
		server doesn't have a corresponding callback, return before timeOut
		regardless but return false.

	Postie.setCallback(
		id: string,
		callback?: (...data: any) -> ...response: any
	)

		Set the callback that is invoked when an invocation identified by id is
		sent. Data sent with the invocation are passed to the callback. If on
		the server, the player who invoked is implicitly received as the first
		argument.

	Postie.getCallback(
		id: string
	) => callback?: (...data: any) -> ...response: any

		Return the callback corresponding with id.
]]

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local replicatedStorage = game:GetService("ReplicatedStorage")

if not replicatedStorage:FindFirstChild("PostieSent") then
	--Create
	local f = Instance.new("RemoteEvent")
	f.Name = "PostieSent"
	f.Parent = replicatedStorage
end

if not replicatedStorage:FindFirstChild("PostieReceived") then
	--Create
	local f = Instance.new("RemoteEvent")
	f.Name = "PostieReceived"
	f.Parent = replicatedStorage
end

local sent = replicatedStorage.PostieSent -- RemoteEvent
local received = replicatedStorage.PostieReceived -- RemoteEvent

local isServer = RunService:IsServer()
local callbackById = {}
local listenerByUuid = {}

local Postie = {}

function Postie.invokeClient(id: string, player: Player, timeOut: number, ...: any): (boolean, ...any)
	assert(isServer, "Postie.invokeClient can only be called from the server")

	local thread = coroutine.running()
	local isResumed = false
	local uuid = HttpService:GenerateGUID(false)

	-- We await a signal from the client.
	listenerByUuid[uuid] = function(playerWhoFired, didInvokeCallback, ...)
		if playerWhoFired ~= player then
			-- The client lied about the UUID.
			return
		end
		isResumed = true
		listenerByUuid[uuid] = nil
		if didInvokeCallback then
			task.spawn(thread, true, ...)
		else
			task.spawn(thread, false)
		end
	end

	-- We await the time-out.
	task.delay(timeOut, function()
		if isResumed then
			return
		end
		listenerByUuid[uuid] = nil
		task.spawn(thread, false)
	end)

	-- Finally, we send the signal to the client and await either the client's
	-- response or the time-out.
	sent:FireClient(player, id, uuid, ...)
	return coroutine.yield()
end

function Postie.invokeServer(id: string, timeOut: number, ...: any): (boolean, ...any)
	assert(not isServer, "Postie.invokeServer can only be called from the client")

	local thread = coroutine.running()
	local isResumed = false
	local uuid = HttpService:GenerateGUID(false)

	-- We await a signal from the client.
	listenerByUuid[uuid] = function(didInvokeCallback, ...)
		isResumed = true
		listenerByUuid[uuid] = nil
		if didInvokeCallback then
			task.spawn(thread, true, ...)
		else
			task.spawn(thread, false)
		end
	end

	-- We await the time-out.
	task.delay(timeOut, function()
		if isResumed then
			return
		end
		listenerByUuid[uuid] = nil
		task.spawn(thread, false)
	end)

	-- Finally, we send the signal to the client and await either the client's
	-- response or the time-out.
	sent:FireServer(id, uuid, ...)
	return coroutine.yield()
end

function Postie.setCallback(id: string, callback: ((...any) -> ...any)?)
	callbackById[id] = callback
end

function Postie.getCallback(id: string): ((...any) -> ...any)?
	return callbackById[id]
end

if isServer then
	-- We handle responses received from the client.
	received.OnServerEvent:Connect(function(player, uuid, didInvokeCallback, ...)
		local listener = listenerByUuid[uuid]
		if not listener then
			return
		end
		listener(player, didInvokeCallback, ...)
	end)

	-- We handle requests sent by the client.
	sent.OnServerEvent:Connect(function(player, id, uuid, ...)
		local callback = callbackById[id]
		if callback then
			received:FireClient(player, uuid, true, callback(player, ...))
		else
			received:FireClient(player, uuid, false)
		end
	end)
else
	-- We handle responses received from the server.
	received.OnClientEvent:Connect(function(uuid, didInvokeCallback, ...)
		local listener = listenerByUuid[uuid]
		if not listener then
			return
		end
		listener(didInvokeCallback, ...)
	end)

	-- We handle requests sent by the server.
	sent.OnClientEvent:Connect(function(id, uuid, ...)
		local callback = callbackById[id]
		if callback then
			received:FireServer(uuid, true, callback(...))
		else
			received:FireServer(uuid, false)
		end
	end)
end

return Postie]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX828B4EB8497A4269AAAEC863C511907A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">State.lua</string>
							<string name="ScriptGuid">{064E8D46-2F96-42E9-B5C7-BECD2EE4858E}</string>
							<ProtectedString name="Source"><![CDATA[local validation = require(script.Parent.Validation)
local logger = require(script.Parent.Logger)
local http_api = require(script.Parent.HttpApi)
local store = require(script.Parent.Store)
local events = require(script.Parent.Events)
local HTTP = game:GetService("HttpService")

local state = {
	_availableCustomDimensions01 = {},
	_availableCustomDimensions02 = {},
	_availableCustomDimensions03 = {},
	_availableGamepasses = {},
	_enableEventSubmission = true,
	Initialized = false,
	ReportErrors = true,
	UseCustomUserId = false,
	AutomaticSendBusinessEvents = true,
	ConfigsHash = "",
}

local GameAnalyticsRemoteConfigs

local function getClientTsAdjusted(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	if not PlayerData then
		return os.time()
	end

	local clientTs = os.time()
	local clientTsAdjustedInteger = clientTs + PlayerData.ClientServerTimeOffset
	if validation:validateClientTs(clientTsAdjustedInteger) then
		return clientTsAdjustedInteger
	else
		return clientTs
	end
end

local function populateConfigurations(player)
	local PlayerData = store:GetPlayerDataFromCache(player.UserId)
	local sdkConfig = PlayerData.SdkConfig

	if sdkConfig["configs"] then
		local configurations = sdkConfig["configs"]

		for _, configuration in pairs(configurations) do
			if configuration then
				local key = configuration["key"] or ""
				local start_ts = configuration["start_ts"] or 0
				local end_ts = configuration["end_ts"] or math.huge
				local client_ts_adjusted = getClientTsAdjusted(player.UserId)

				if
					#key > 0
					and configuration["value"]
					and client_ts_adjusted > start_ts
					and client_ts_adjusted < end_ts
				then
					PlayerData.Configurations[key] = configuration["value"]
					logger:d(
						"configuration added: key=" .. configuration["key"] .. ", value=" .. configuration["value"]
					)
				end
			end
		end
	end

	logger:i("Remote configs populated")

	PlayerData.RemoteConfigsIsReady = true
	GameAnalyticsRemoteConfigs = GameAnalyticsRemoteConfigs
		or game:GetService("ReplicatedStorage"):WaitForChild("GameAnalyticsRemoteConfigs")
	GameAnalyticsRemoteConfigs:FireClient(player, PlayerData.Configurations)
end

function state:sessionIsStarted(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	if not PlayerData then
		return false
	end

	return PlayerData.SessionStart ~= 0
end

function state:isEnabled(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	if not PlayerData then
		return false
	elseif not PlayerData.InitAuthorized then
		return false
	else
		return true
	end
end

function state:validateAndFixCurrentDimensions(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)

	-- validate that there are no current dimension01 not in list
	if not validation:validateDimension(self._availableCustomDimensions01, PlayerData.CurrentCustomDimension01) then
		logger:d(
			"Invalid dimension01 found in variable. Setting to nil. Invalid dimension: "
				.. PlayerData.CurrentCustomDimension01
		)
	end

	-- validate that there are no current dimension02 not in list
	if not validation:validateDimension(self._availableCustomDimensions02, PlayerData.CurrentCustomDimension02) then
		logger:d(
			"Invalid dimension02 found in variable. Setting to nil. Invalid dimension: "
				.. PlayerData.CurrentCustomDimension02
		)
	end

	-- validate that there are no current dimension03 not in list
	if not validation:validateDimension(self._availableCustomDimensions03, PlayerData.CurrentCustomDimension03) then
		logger:d(
			"Invalid dimension03 found in variable. Setting to nil. Invalid dimension: "
				.. PlayerData.CurrentCustomDimension03
		)
	end
end

function state:setAvailableCustomDimensions01(availableCustomDimensions)
	if not validation:validateCustomDimensions(availableCustomDimensions) then
		return
	end

	self._availableCustomDimensions01 = availableCustomDimensions
	logger:i("Set available custom01 dimension values: (" .. table.concat(availableCustomDimensions, ", ") .. ")")
end

function state:setAvailableCustomDimensions02(availableCustomDimensions)
	if not validation:validateCustomDimensions(availableCustomDimensions) then
		return
	end

	self._availableCustomDimensions02 = availableCustomDimensions
	logger:i("Set available custom02 dimension values: (" .. table.concat(availableCustomDimensions, ", ") .. ")")
end

function state:setAvailableCustomDimensions03(availableCustomDimensions)
	if not validation:validateCustomDimensions(availableCustomDimensions) then
		return
	end

	self._availableCustomDimensions03 = availableCustomDimensions
	logger:i("Set available custom03 dimension values: (" .. table.concat(availableCustomDimensions, ", ") .. ")")
end

function state:setAvailableGamepasses(availableGamepasses)
	self._availableGamepasses = availableGamepasses
	logger:i("Set available game passes: (" .. table.concat(availableGamepasses, ", ") .. ")")
end

function state:setEventSubmission(flag)
	self._enableEventSubmission = flag
end

function state:isEventSubmissionEnabled()
	return self._enableEventSubmission
end

function state:setCustomDimension01(playerId, dimension)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	PlayerData.CurrentCustomDimension01 = dimension
end

function state:setCustomDimension02(playerId, dimension)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	PlayerData.CurrentCustomDimension02 = dimension
end

function state:setCustomDimension03(playerId, dimension)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	PlayerData.CurrentCustomDimension03 = dimension
end

function state:startNewSession(player, teleportData, customFields)
	if state:isEventSubmissionEnabled() and teleportData == nil then
		logger:i("Starting a new session.")
	end

	local PlayerData = store:GetPlayerDataFromCache(player.UserId)

	-- make sure the current custom dimensions are valid
	state:validateAndFixCurrentDimensions(player.UserId)

	local initResult = http_api:initRequest(events.GameKey, events.SecretKey, events.Build, PlayerData, player.UserId)
	local statusCode = initResult.statusCode
	local responseBody = initResult.body

	if
		(statusCode == http_api.EGAHTTPApiResponse.Ok or statusCode == http_api.EGAHTTPApiResponse.Created)
		and responseBody
	then
		-- set the time offset - how many seconds the local time is different from servertime
		local timeOffsetSeconds = 0
		local serverTs = responseBody["server_ts"] or -1
		if serverTs > 0 then
			local clientTs = os.time()
			timeOffsetSeconds = serverTs - clientTs
		end

		responseBody["time_offset"] = timeOffsetSeconds

		if not (statusCode == http_api.EGAHTTPApiResponse.Created) then
			local sdkConfig = PlayerData.SdkConfig

			if sdkConfig["configs"] then
				responseBody["configs"] = sdkConfig["configs"]
			end

			if sdkConfig["ab_id"] then
				responseBody["ab_id"] = sdkConfig["ab_id"]
			end

			if sdkConfig["ab_variant_id"] then
				responseBody["ab_variant_id"] = sdkConfig["ab_variant_id"]
			end
		end

		PlayerData.SdkConfig = responseBody
		PlayerData.InitAuthorized = true
	elseif statusCode == http_api.EGAHTTPApiResponse.Unauthorized then
		logger:w("Initialize SDK failed - Unauthorized")
		PlayerData.InitAuthorized = false
	else
		-- log the status if no connection
		if
			statusCode == http_api.EGAHTTPApiResponse.NoResponse
			or statusCode == http_api.EGAHTTPApiResponse.RequestTimeout
		then
			logger:i("Init call (session start) failed - no response. Could be offline or timeout.")
		elseif
			statusCode == http_api.EGAHTTPApiResponse.BadResponse
			or statusCode == http_api.EGAHTTPApiResponse.JsonEncodeFailed
			or statusCode == http_api.EGAHTTPApiResponse.JsonDecodeFailed
		then
			logger:i("Init call (session start) failed - bad response. Could be bad response from proxy or GA servers.")
		elseif
			statusCode == http_api.EGAHTTPApiResponse.BadRequest
			or statusCode == http_api.EGAHTTPApiResponse.UnknownResponseCode
		then
			logger:i("Init call (session start) failed - bad request or unknown response.")
		end

		PlayerData.InitAuthorized = true
	end

	-- set offset in state (memory) from current config (config could be from cache etc.)
	PlayerData.ClientServerTimeOffset = PlayerData.SdkConfig["time_offset"] or 0
	PlayerData.ConfigsHash = PlayerData.SdkConfig["configs_hash"] or ""
	PlayerData.AbId = PlayerData.SdkConfig["ab_id"] or ""
	PlayerData.AbVariantId = PlayerData.SdkConfig["ab_variant_id"] or ""

	-- populate configurations
	populateConfigurations(player)

	if not state:isEnabled(player.UserId) then
		logger:w("Could not start session: SDK is disabled.")
		return
	end

	if teleportData then
		PlayerData.SessionID = teleportData.SessionID
		PlayerData.SessionStart = teleportData.SessionStart
	else
		PlayerData.SessionID = string.lower(HTTP:GenerateGUID(false))
		PlayerData.SessionStart = getClientTsAdjusted(player.UserId)
	end

	if state:isEventSubmissionEnabled() then
		events:addSessionStartEvent(player.UserId, teleportData, customFields)
	end
end

function state:endSession(playerId, customFields)
	if state.Initialized and state:isEventSubmissionEnabled() then
		logger:i("Ending session.")
		if state:isEnabled(playerId) and state:sessionIsStarted(playerId) then
			events:addSessionEndEvent(playerId, customFields)
			store.PlayerCache[playerId] = nil
		end
	end
end

function state:getRemoteConfigsStringValue(playerId, key, defaultValue)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	return PlayerData.Configurations[key] or defaultValue
end

function state:isRemoteConfigsReady(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	return PlayerData.RemoteConfigsIsReady
end

function state:getRemoteConfigsContentAsString(playerId)
	local PlayerData = store:GetPlayerDataFromCache(playerId)
	return HTTP:JSONEncode(PlayerData.Configurations)
end

return state]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX08726669EE8944D7AF6C9F7F1E5F37BD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Store.lua</string>
							<string name="ScriptGuid">{3A2A68EE-98F2-4E65-BA77-0D0E6CED53D9}</string>
							<ProtectedString name="Source"><![CDATA[local DS = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")
local DSQ = require(script.DataStoreQueue)

local store = {
	PlayerDS = RunService:IsStudio() and {} or DS:GetDataStore("GA_PlayerDS_1.0.0"),
	AutoSaveData = 180, --Set to 0 to disable
	BasePlayerData = {
		Sessions = 0,
		Transactions = 0,
		ProgressionTries = {},
		CurrentCustomDimension01 = "",
		CurrentCustomDimension02 = "",
		CurrentCustomDimension03 = "",
		ConfigsHash = "",
		AbId = "",
		AbVariantId = "",
		InitAuthorized = false,
		SdkConfig = {},
		ClientServerTimeOffset = 0,
		Configurations = {},
		RemoteConfigsIsReady = false,
		PlayerTeleporting = false,
		OwnedGamepasses = nil, --nil means a completely new player. {} means player with no game passes
		CountryCode = "",
		CustomUserId = "",
	},

	DataToSave = {
		"Sessions",
		"Transactions",
		"ProgressionTries",
		"CurrentCustomDimension01",
		"CurrentCustomDimension02",
		"CurrentCustomDimension03",
		"OwnedGamepasses",
	},

	--Cache
	PlayerCache = {},
	EventsQueue = {},
	DataStoreQueue = DSQ,
}

function store:GetPlayerData(Player)
	local key = Player.UserId
	local success, PlayerData = DSQ.AddRequest(key, function()
		return RunService:IsStudio() and {} or (store.PlayerDS:GetAsync(key) or {})
	end, 7) -- Add to a queue with 7s delay between each request

	if not success then
		PlayerData = {}
	end
	return PlayerData
end

function store:GetPlayerDataFromCache(userId)
	local playerData = store.PlayerCache[tonumber(userId)]
	if playerData then
		return playerData
	end
	playerData = store.PlayerCache[tostring(userId)]
	return playerData
end

function store:GetErrorDataStore(scope)
	local ErrorDS
	local success = pcall(function()
		ErrorDS = RunService:IsStudio() and {} or DS:GetDataStore("GA_ErrorDS_1.0.0", scope)
	end)

	if not success then
		ErrorDS = {}
	end

	return ErrorDS
end

function store:SavePlayerData(Player)
	--Variables
	local PlayerData = store:GetPlayerDataFromCache(Player.UserId)
	local SavePlayerData = {}

	if not PlayerData then
		return
	end

	--Fill
	for _, key in pairs(store.DataToSave) do
		SavePlayerData[key] = PlayerData[key]
	end

	--Save
	local key = Player.UserId
	if not RunService:IsStudio() then
		DSQ.AddRequest(key, function()
			return store.PlayerDS:SetAsync(key, SavePlayerData)
		end, 7)
	end
end

function store:IncrementErrorCount(ErrorDS, ErrorKey, step)
	if not ErrorKey then
		return
	end

	local count = 0
	--Increment count
	if not RunService:IsStudio() then
		--Increment count
		_, count = DSQ.AddRequest(ErrorKey, function()
			return ErrorDS:IncrementAsync(ErrorKey, step)
		end, 7)
	end
	return count
end
return store]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXC68CAD5EFEBE4A7193AB858C97179788">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Store</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXCB97A85334C241FEBCC64981A64F9E6F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">DataStoreQueue.lua</string>
								<string name="ScriptGuid">{F99FA8EC-782E-4C74-8307-7AC4071B63DB}</string>
								<ProtectedString name="Source"><![CDATA[local DataStoreManager = {}
DataStoreManager.QR = true
DataStoreManager.Queue = {}
DataStoreManager.Process = 0
local LastRequest = {}

task.spawn(function()
	while DataStoreManager.QR do
		task.wait()
		if #DataStoreManager.Queue > 0 then
			local Request = DataStoreManager.Queue[1]
			table.remove(DataStoreManager.Queue, 1)
			if not LastRequest[Request.Key] then
				LastRequest[Request.Key] = 0
			end

			DataStoreManager.Process += 1
			local remain = (Request.Delay + LastRequest[Request.Key]) - DateTime.now().UnixTimestamp
			if remain <= 0 then
				remain = 0
			end
			task.delay(remain, function()
				local Success, Error, ds
				repeat
					LastRequest[Request.Key] = DateTime.now().UnixTimestamp
					Success, Error, ds = pcall(Request.Func)

					if not Success then
						warn(Error)
					end
					if Success and Error then
						break
					end
					if not Request.Delay then
						break
					end
					task.wait(Request.Delay)
				until Success and Error
				Request.Event:Fire(Success, Error, ds)
				DataStoreManager.Process -= 1
				LastRequest[Request.Key] = DateTime.now().UnixTimestamp
			end)
		end
	end
end)

function DataStoreManager.AddRequest(Key, Request, Delay)
	local FinishedEvent = Instance.new("BindableEvent")
	table.insert(DataStoreManager.Queue, {
		Key = Key,
		Delay = Delay,
		Func = Request,
		Event = FinishedEvent,
	})
	local Success, ValOrErr, ds = FinishedEvent.Event:Wait()
	return Success, ValOrErr, ds
end

function DataStoreManager.RemoveKey(Key)
	LastRequest[Key] = nil
end
return DataStoreManager]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXAD7EB83BC1DD4F249342C63404259068">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Threading.lua</string>
							<string name="ScriptGuid">{EE9C0A16-9080-49B7-BAA9-EC6A61EAE0AD}</string>
							<ProtectedString name="Source"><![CDATA[local threading = {
	_canSafelyClose = true,
	_endThread = false,
	_isRunning = false,
	_blocks = {},
	_scheduledBlock = nil,
	_hasScheduledBlockRun = true,
}

local logger = require(script.Parent.Logger)
local RunService = game:GetService("RunService")

local function getScheduledBlock()
	local now = tick()

	if
		not threading._hasScheduledBlockRun
		and threading._scheduledBlock ~= nil
		and threading._scheduledBlock.deadline <= now
	then
		threading._hasScheduledBlockRun = true
		return threading._scheduledBlock
	else
		return nil
	end
end

local function run()
	task.spawn(function()
		logger:d("Starting GA thread")

		while not threading._endThread do
			threading._canSafelyClose = false

			if #threading._blocks ~= 0 then
				for _, b in pairs(threading._blocks) do
					local s, e = pcall(b.block)
					if not s then
						logger:e(e)
					end
				end

				threading._blocks = {}
			end

			local timedBlock = getScheduledBlock()
			if timedBlock ~= nil then
				local s, e = pcall(timedBlock.block)
				if not s then
					logger:e(e)
				end
			end

			threading._canSafelyClose = true
			task.wait(1)
		end

		logger:d("GA thread stopped")
	end)

	--Safely Close
	game:BindToClose(function()
		-- waiting bug fix to work inside studio
		if RunService:IsStudio() then
			return
		end

		--Give game.Players.PlayerRemoving time to to its thang
		task.wait(1)

		--Delay
		if not threading._canSafelyClose then
			repeat
				task.wait()
			until threading._canSafelyClose
		end

		task.wait(3)
	end)
end

function threading:scheduleTimer(interval, callback)
	if self._endThread then
		return
	end

	if not self._isRunning then
		self._isRunning = true
		run()
	end

	local timedBlock = {
		block = callback,
		deadline = tick() + interval,
	}

	if self._hasScheduledBlockRun then
		self._scheduledBlock = timedBlock
		self._hasScheduledBlockRun = false
	end
end

function threading:performTaskOnGAThread(callback)
	if self._endThread then
		return
	end

	if not self._isRunning then
		self._isRunning = true
		run()
	end

	local timedBlock = {
		block = callback,
	}

	self._blocks[#self._blocks + 1] = timedBlock
end

function threading:stopThread()
	self._endThread = true
end

return threading]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXCB90F37360C341EDABD71685555338FE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Types.lua</string>
							<string name="ScriptGuid">{5E141004-4DA3-49E1-A2AA-A0A0A1050565}</string>
							<ProtectedString name="Source"><![CDATA[type EventOptions = {
	customFields: { [string]: string }?,
}

export type BusinessEventOptions = EventOptions & {
	amount: number,
	itemType: string,
	itemId: string,
	cartType: string?,
}

export type ResourceEventOptions = EventOptions & {
	flowType: number,
	currency: string,
	amount: number,
	itemType: string,
	itemId: string,
}

export type ProgressionEventOptions = EventOptions & {
	progressionStatus: number,
	progression01: string,
	progression02: string?,
	progression03: string?,
	score: number?,
}

export type DesignEventOptions = EventOptions & {
	eventId: string,
	value: number?,
}

export type ErrorEventOptions = EventOptions & {
	message: string,
	severity: number,
}

export type CustomDimension = string

export type ProductInfo = {
	Name: string,
	PriceInRobux: number,
}

export type ProcessReceiptInfo = {
	ProductId: number,
	PlayerId: number,
	CurrencySpent: number,
}

export type TeleportData = { [string]: any }
export type RemoteConfigs = { [string]: any }

export type GameAnalyticsOptions = {
	enableInfoLog: boolean?,
	enableVerboseLog: boolean?,
	availableCustomDimensions01: { CustomDimension }?,
	availableCustomDimensions02: { CustomDimension }?,
	availableCustomDimensions03: { CustomDimension }?,
	availableResourceCurrencies: { string }?,
	availableResourceItemTypes: { string }?,
	build: string?,
	availableGamepasses: { string }?,
	enableDebugLog: boolean?,
	automaticSendBusinessEvents: boolean?,
	reportErrors: boolean?,
	useCustomUserId: boolean?,
	gameKey: string?,
	secretKey: string?,
}

return {}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE6C543BF384C4D78A3F410F2F1C9DF9A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Utilities.lua</string>
							<string name="ScriptGuid">{319C2957-6B8B-45DB-9C1D-242A78D6A3DF}</string>
							<ProtectedString name="Source"><![CDATA[local utilities = {}

function utilities:isStringNullOrEmpty(s)
	return (not s) or #s == 0
end

function utilities:stringArrayContainsString(array, search)
	if #array == 0 then
		return false
	end

	for _, s in ipairs(array) do
		if s == search then
			return true
		end
	end

	return false
end

function utilities:copyTable(t)
	local copy = {}
	for k, v in pairs(t) do
		if typeof(v) == "table" then
			copy[k] = self:copyTable(v)
		else
			copy[k] = v
		end
	end
	return copy
end

return utilities]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF8EAF514823C4272BC32E88B287855F8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Validation.lua</string>
							<string name="ScriptGuid">{664BAF05-2099-42C4-B917-346EE44D9AF7}</string>
							<ProtectedString name="Source"><![CDATA[local validation = {}

local logger = require(script.Parent.Logger)
local utilities = require(script.Parent.Utilities)

function validation:validateCustomDimensions(customDimensions)
	return validation:validateArrayOfStrings(20, 32, false, "custom dimensions", customDimensions)
end

function validation:validateDimension(dimensions, dimension)
	-- allow nil
	if utilities:isStringNullOrEmpty(dimension) then
		return true
	end

	if not utilities:stringArrayContainsString(dimensions, dimension) then
		return false
	end

	return true
end

function validation:validateResourceCurrencies(resourceCurrencies)
	if not validation:validateArrayOfStrings(20, 64, false, "resource currencies", resourceCurrencies) then
		return false
	end

	-- validate each string for regex
	for _, resourceCurrency in pairs(resourceCurrencies) do
		if not string.find(resourceCurrency, "^[A-Za-z]+$") then
			logger:w(
				"resource currencies validation failed: a resource currency can only be A-Z, a-z. String was: "
					.. resourceCurrency
			)
			return false
		end
	end

	return true
end

function validation:validateResourceItemTypes(resourceItemTypes)
	if not validation:validateArrayOfStrings(20, 32, false, "resource item types", resourceItemTypes) then
		return false
	end

	-- validate each string for regex
	for _, resourceItemType in pairs(resourceItemTypes) do
		if not validation:validateEventPartCharacters(resourceItemType) then
			logger:w(
				"resource item types validation failed: a resource item type cannot contain other characters than A-z, 0-9, -_., ()!?. String was: "
					.. resourceItemType
			)
			return false
		end
	end

	return true
end

function validation:validateEventPartCharacters(eventPart)
	if not string.find(eventPart, "^[A-Za-z0-9%s%-_%.%(%)!%?]+$") then
		return false
	end

	return true
end

function validation:validateArrayOfStrings(maxCount, maxStringLength, allowNoValues, logTag, arrayOfStrings)
	local arrayTag = logTag

	if not arrayTag then
		arrayTag = "Array"
	end

	-- use arrayTag to annotate warning log
	if not arrayOfStrings then
		logger:w(arrayTag .. " validation failed: array cannot be nil.")
		return false
	end

	-- check if empty
	if not allowNoValues and #arrayOfStrings == 0 then
		logger:w(arrayTag .. " validation failed: array cannot be empty.")
		return false
	end

	-- check if exceeding max count
	if maxCount > 0 and #arrayOfStrings > maxCount then
		logger:w(
			arrayTag
				.. " validation failed: array cannot exceed "
				.. tostring(maxCount)
				.. " values. It has "
				.. #arrayOfStrings
				.. " values."
		)
		return false
	end

	-- validate each string
	for _, arrayString in ipairs(arrayOfStrings) do
		local stringLength = 0
		if arrayString then
			stringLength = #arrayString
		end

		-- check if empty (not allowed)
		if stringLength == 0 then
			logger:w(arrayTag .. " validation failed: contained an empty string.")
			return false
		end

		-- check if exceeding max length
		if maxStringLength > 0 and stringLength > maxStringLength then
			logger:w(
				arrayTag
					.. " validation failed: a string exceeded max allowed length (which is: "
					.. tostring(maxStringLength)
					.. "). String was: "
					.. arrayString
			)
			return false
		end
	end

	return true
end

function validation:validateBuild(build)
	if not validation:validateShortString(build, false) then
		return false
	end

	return true
end

function validation:validateShortString(shortString, canBeEmpty)
	-- String is allowed to be empty or nil
	if canBeEmpty and utilities:isStringNullOrEmpty(shortString) then
		return true
	end

	if utilities:isStringNullOrEmpty(shortString) or #shortString > 32 then
		return false
	end

	return true
end

function validation:validateKeys(gameKey, secretKey)
	if string.find(gameKey, "^[A-Za-z0-9]+$") and #gameKey == 32 then
		if string.find(secretKey, "^[A-Za-z0-9]+$") and #secretKey == 40 then
			return true
		end
	end

	return false
end

function validation:validateAndCleanInitRequestResponse(initResponse, configsCreated)
	-- make sure we have a valid dict
	if not initResponse then
		logger:w("validateInitRequestResponse failed - no response dictionary.")
		return nil
	end

	local validatedDict = {}

	-- validate server_ts
	local serverTsNumber = initResponse["server_ts"] or -1
	if serverTsNumber > 0 then
		validatedDict["server_ts"] = serverTsNumber
	end

	if configsCreated then
		validatedDict["configs"] = initResponse["configs"] or {}
		validatedDict["ab_id"] = initResponse["ab_id"] or ""
		validatedDict["ab_variant_id"] = initResponse["ab_variant_id"] or ""
	end

	return validatedDict
end

function validation:validateClientTs(clientTs)
	if clientTs < 1000000000 or clientTs > 9999999999 then
		return false
	end

	return true
end

function validation:validateCurrency(currency)
	if utilities:isStringNullOrEmpty(currency) then
		return false
	end

	if string.find(currency, "^[A-Z]+$") and #currency == 3 then
		return true
	end

	return false
end

function validation:validateEventPartLength(eventPart, allowNull)
	if allowNull and utilities:isStringNullOrEmpty(eventPart) then
		return true
	end

	if utilities:isStringNullOrEmpty(eventPart) then
		return false
	end

	if #eventPart == 0 or #eventPart > 64 then
		return false
	end
	return true
end

function validation:validateBusinessEvent(currency, amount, cartType, itemType, itemId)
	-- validate currency
	if not validation:validateCurrency(currency) then
		logger:w(
			"Validation fail - business event - currency: Cannot be (null) and need to be A-Z, 3 characters and in the standard at openexchangerates.org. Failed currency: "
				.. currency
		)
		return false
	end

	if amount < 0 then
		logger:w("Validation fail - business event - amount: Cannot be less then 0. Failed amount: " .. amount)
		return false
	end

	-- validate cartType
	if not validation:validateShortString(cartType, true) then
		logger:w("Validation fail - business event - cartType. Cannot be above 32 length. String: " .. cartType)
		return false
	end

	-- validate itemType length
	if not validation:validateEventPartLength(itemType, false) then
		logger:w(
			"Validation fail - business event - itemType: Cannot be (null), empty or above 64 characters. String: "
				.. itemType
		)
		return false
	end

	-- validate itemType chars
	if not validation:validateEventPartCharacters(itemType) then
		logger:w(
			"Validation fail - business event - itemType: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. itemType
		)
		return false
	end

	-- validate itemId
	if not validation:validateEventPartLength(itemId, false) then
		logger:w(
			"Validation fail - business event - itemId. Cannot be (null), empty or above 64 characters. String: "
				.. itemId
		)
		return false
	end

	if not validation:validateEventPartCharacters(itemId) then
		logger:w(
			"Validation fail - business event - itemId: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. itemId
		)
		return false
	end

	return true
end

function validation:validateResourceEvent(
	flowTypeValues,
	flowType,
	currency,
	amount,
	itemType,
	itemId,
	currencies,
	itemTypes
)
	if flowType ~= flowTypeValues.Source and flowType ~= flowTypeValues.Sink then
		logger:w("Validation fail - resource event - flowType: Invalid flow type " .. tostring(flowType))
		return false
	end

	if utilities:isStringNullOrEmpty(currency) then
		logger:w("Validation fail - resource event - currency: Cannot be (null)")
		return false
	end

	if not utilities:stringArrayContainsString(currencies, currency) then
		logger:w(
			"Validation fail - resource event - currency: Not found in list of pre-defined available resource currencies. String: "
				.. currency
		)
		return false
	end

	if not (amount > 0) then
		logger:w(
			"Validation fail - resource event - amount: Float amount cannot be 0 or negative. Value: "
				.. tostring(amount)
		)
		return false
	end

	if utilities:isStringNullOrEmpty(itemType) then
		logger:w("Validation fail - resource event - itemType: Cannot be (null)")
		return false
	end

	if not validation:validateEventPartLength(itemType, false) then
		logger:w(
			"Validation fail - resource event - itemType: Cannot be (null), empty or above 64 characters. String: "
				.. itemType
		)
		return false
	end

	if not validation:validateEventPartCharacters(itemType) then
		logger:w(
			"Validation fail - resource event - itemType: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. itemType
		)
		return false
	end

	if not utilities:stringArrayContainsString(itemTypes, itemType) then
		logger:w(
			"Validation fail - resource event - itemType: Not found in list of pre-defined available resource itemTypes. String: "
				.. itemType
		)
		return false
	end

	if not validation:validateEventPartLength(itemId, false) then
		logger:w(
			"Validation fail - resource event - itemId: Cannot be (null), empty or above 64 characters. String: "
				.. itemId
		)
		return false
	end

	if not validation:validateEventPartCharacters(itemId) then
		logger:w(
			"Validation fail - resource event - itemId: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. itemId
		)
		return false
	end

	return true
end

function validation:validateProgressionEvent(
	progressionStatusValues,
	progressionStatus,
	progression01,
	progression02,
	progression03
)
	if
		progressionStatus ~= progressionStatusValues.Start
		and progressionStatus ~= progressionStatusValues.Complete
		and progressionStatus ~= progressionStatusValues.Fail
	then
		logger:w("Validation fail - progression event: Invalid progression status " .. tostring(progressionStatus))
		return false
	end

	-- Make sure progressions are defined as either 01, 01+02 or 01+02+03
	if
		not utilities:isStringNullOrEmpty(progression03)
		and not (not utilities:isStringNullOrEmpty(progression02) or utilities:isStringNullOrEmpty(progression01))
	then
		logger:w(
			"Validation fail - progression event: 03 found but 01+02 are invalid. Progression must be set as either 01, 01+02 or 01+02+03."
		)
		return false
	elseif not utilities:isStringNullOrEmpty(progression02) and utilities:isStringNullOrEmpty(progression01) then
		logger:w(
			"Validation fail - progression event: 02 found but not 01. Progression must be set as either 01, 01+02 or 01+02+03"
		)
		return false
	elseif utilities:isStringNullOrEmpty(progression01) then
		logger:w(
			"Validation fail - progression event: progression01 not valid. Progressions must be set as either 01, 01+02 or 01+02+03"
		)
		return false
	end

	-- progression01 (required)
	if not validation:validateEventPartLength(progression01, false) then
		logger:w(
			"Validation fail - progression event - progression01: Cannot be (null), empty or above 64 characters. String: "
				.. progression01
		)
		return false
	end

	if not validation:validateEventPartCharacters(progression01) then
		logger:w(
			"Validation fail - progression event - progression01: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
				.. progression01
		)
		return false
	end

	-- progression02
	if not utilities:isStringNullOrEmpty(progression02) then
		if not validation:validateEventPartLength(progression02, false) then
			logger:w(
				"Validation fail - progression event - progression02: Cannot be empty or above 64 characters. String: "
					.. progression02
			)
			return false
		end

		if not validation:validateEventPartCharacters(progression02) then
			logger:w(
				"Validation fail - progression event - progression02: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
					.. progression02
			)
			return false
		end
	end

	-- progression03
	if not utilities:isStringNullOrEmpty(progression03) then
		if not validation:validateEventPartLength(progression03, false) then
			logger:w(
				"Validation fail - progression event - progression03: Cannot be empty or above 64 characters. String: "
					.. progression03
			)
			return false
		end

		if not validation:validateEventPartCharacters(progression03) then
			logger:w(
				"Validation fail - progression event - progression03: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: "
					.. progression03
			)
			return false
		end
	end

	return true
end

function validation:validateEventIdLength(eventId)
	if utilities:isStringNullOrEmpty(eventId) then
		return false
	end

	local count = 0
	for s in string.gmatch(eventId, "([^:]+)") do
		count = count + 1
		if count > 5 or #s > 64 then
			return false
		end
	end

	return true
end

function validation:validateEventIdCharacters(eventId)
	if utilities:isStringNullOrEmpty(eventId) then
		return false
	end

	local count = 0
	for s in string.gmatch(eventId, "([^:]+)") do
		count = count + 1
		if count > 5 or not string.find(s, "^[A-Za-z0-9%s%-_%.%(%)!%?]+$") then
			return false
		end
	end

	return true
end

function validation:validateDesignEvent(eventId)
	if not validation:validateEventIdLength(eventId) then
		logger:w(
			"Validation fail - design event - eventId: Cannot be (null) or empty. Only 5 event parts allowed seperated by :. Each part need to be 32 characters or less. String: "
				.. eventId
		)
		return false
	end

	if not validation:validateEventIdCharacters(eventId) then
		logger:w(
			"Validation fail - design event - eventId: Non valid characters. Only allowed A-z, 0-9, -_., ()!?. String: "
				.. eventId
		)
		return false
	end

	-- value: allow 0, negative and nil (not required)
	return true
end

function validation:validateLongString(longString, canBeEmpty)
	-- String is allowed to be empty
	if canBeEmpty and utilities:isStringNullOrEmpty(longString) then
		return true
	end

	if utilities:isStringNullOrEmpty(longString) or #longString > 8192 then
		return false
	end

	return true
end

function validation:validateErrorEvent(severityValues, severity, message)
	if
		severity ~= severityValues.debug
		and severity ~= severityValues.info
		and severity ~= severityValues.warning
		and severity ~= severityValues.error
		and severity ~= severityValues.critical
	then
		logger:w("Validation fail - error event - severity: Severity was unsupported value " .. tostring(severity))
		return false
	end

	if not validation:validateLongString(message, true) then
		logger:w("Validation fail - error event - message: Message cannot be above 8192 characters.")
		return false
	end

	return true
end

return validation]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFD43F078974C4605A2FE37383307D5BB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Version.lua</string>
							<string name="ScriptGuid">{748F77D6-D79F-4A8F-806C-DCADFAF616F1}</string>
							<ProtectedString name="Source"><![CDATA[local version = {
	SdkVersion = "2.2.6"
}

return version]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX3F4D7AB9AB41483EA354FD6E15D9C776">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GameAnalyticsClient.lua</string>
						<string name="ScriptGuid">{ECBFD3B7-C7FD-4271-89F3-58BF7AE214CD}</string>
						<ProtectedString name="Source"><![CDATA[local module = {}

local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ScriptContext = game:GetService("ScriptContext")

--[[
    The modules are required inside each function because we wouldn't
    want to load the GameAnalytics library if we're just requiring this
    ModuleScript on the client side, and we don't need to hard code
    a require to Postie on the server side because the networking implementation could change.
]]

function module.initClient()
	local Postie = require(script.Parent.GameAnalytics.Postie)

	ScriptContext.Error:Connect(function(message, stackTrace, scriptInst)
		if not scriptInst then
			return
		end

		local scriptName = nil
		local ok, _ = pcall(function()
			scriptName = scriptInst:GetFullName() -- Can't get name of some scripts because of security permission
		end)
		if not ok then
			return
		end

		ReplicatedStorage.GameAnalyticsError:FireServer(message, stackTrace, scriptName)
	end)

	--Functions
	local function getPlatform()
		if GuiService:IsTenFootInterface() then
			return "Console"
		elseif UserInputService.TouchEnabled and not UserInputService.MouseEnabled then
			return "Mobile"
		else
			return "Desktop"
		end
	end

	--Filtering
	Postie.setCallback("getPlatform", getPlatform)
end

return module]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXDCF0ECB7BDDA4E1C85C2B7E27081A5BF">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Data_Mods_F</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXD5B3F7DEDB8E43D4A8D1F745AA5590F8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Monetization_Mod.lua</string>
						<string name="ScriptGuid">{E8AFA414-92E8-4D6F-9308-EB94827507AC}</string>
						<ProtectedString name="Source"><![CDATA[local MPS = game:GetService("MarketplaceService")
local funcs = {}

local GP_Data = {
	['A'] = {
		['Name'] = "VIP!",
		['ID'] = 1258867472,
		['Icon'] = "rbxassetid://116997996978018",
		['Price'] = 49,
	},

	['B'] = {
		['Name'] = "x2 ELO!",
		['ID'] = 1259176869,
		['Icon'] = "rbxassetid://140028327825184",
		['Price'] = 349,
	},

	['C'] = {
		['Name'] = "x2 Cash!",
		['ID'] = 1258959116,
		['Icon'] = "rbxassetid://111390267501817",
		['Price'] = 199,
	},

	['D'] = {
		['Name'] = "Exclusive Emotes!",
		['ID'] = 1259220957,
		['Icon'] = "rbxassetid://140138999956473",
		['Price'] = 249,
	},

	['E'] = {
		['Name'] = "x3 Luck!",
		['ID'] = 1259133027,
		['Icon'] = "rbxassetid://111648715389151",
		['Price'] = 149,
	},

	['F'] = {
		['Name'] = "x2 Luck!",
		['ID'] = 1259086900,
		['Icon'] = "rbxassetid://113302080319391",
		['Price'] = 99,
	},

}

local Dev_Data = {
	['A'] = {
		['Name'] = "Tiny Cash Pack!",
		['ID'] = 3306903850,
		['Type'] = "Cash"
	},

	['B'] = {
		['Name'] = "Small Cash Pack!",
		['ID'] = 3306904087,
		['Type'] = "Cash"
	},

	['C'] = {
		['Name'] = "Large Cash Pack!",
		['ID'] = 3306907044,
		['Type'] = "Cash"
	},

	['D'] = {
		['Name'] = "Huge Cash Pack!",
		['ID'] = 3306907389,
		['Type'] = "Cash"
	},

	['E'] = {
		['Name'] = "Mega Huge Cash Pack!",
		['ID'] = 3306908329,
		['Type'] = "Cash"
	},

	['F'] = {
		['Name'] = "Tiny Gems Pack!",
		['ID'] = 3306909205,
		['Type'] = "Gems",
		['Amount'] = 25,
	},

	['G'] = {
		['Name'] = "Small Gems Pack!",
		['ID'] = 3306909447,
		['Type'] = "Gems",
		['Amount'] = 65,
	},

	['H'] = {
		['Name'] = "Large Gems Pack!",
		['ID'] = 3306909752,
		['Type'] = "Gems",
		['Amount'] = 180,
	},

	['I'] = {
		['Name'] = "Huge Gems Pack!",
		['ID'] = 3306910019,
		['Type'] = "Gems",
		['Amount'] = 500,
	},

	['J'] = {
		['Name'] = "Mega Huge Gems Pack!",
		['ID'] = 3306910278,
		['Type'] = "Gems",
		['Amount'] = 5000,
	},

	['K'] = {
		['Name'] = "Starter Pack!",
		['ID'] = 3324331165,
		['Type'] = "StarterPack",
	},
	
	['L'] = {
		['Name'] = "Special Gloves",
		['ID'] = 3393273546,
		['Type'] = "Special Gloves",
	},
}

local UGC_Data = {
	--// Dreads
	['A'] = {
		['Name'] = "Colorful Dreads Breads",
		['ID'] = 83795788626582,
	},
	['B'] = {
		['Name'] = "Dreads Breads",
		['ID'] = 113738030334375,
	},
	['C'] = {
		['Name'] = "Colorful Dreads Breads",
		['ID'] = 98302594802885,
	},
	['D'] = {
		['Name'] = "Dreads Breads",
		['ID'] = 101251472607139,
	},

	--// Cowboy Hats
	['E'] = {
		['Name'] = "Cowboy Hat",
		['ID'] = 101474119058173,
	},
	['F'] = {
		['Name'] = "Cowboy Hat",
		['ID'] = 75995119815868,
	},
	['G'] = {
		['Name'] = "Cowboy Hat",
		['ID'] = 75114177921975,
	},
	['H'] = {
		['Name'] = "Cowboy Hat",
		['ID'] = 101562313582313,
	},
	--// Muay Thai
	['I'] = {
		['Name'] = "Fighter Crown - Black Green",
		['ID'] = 113747837981544,
	},
	['J'] = {
		['Name'] = "Fighter Crown - White Green",
		['ID'] = 76373498147951,
	},
	['K'] = {
		['Name'] = "Fighter Crown - Red White",
		['ID'] = 114656167427986,
	},
	['L'] = {
		['Name'] = "Fighter Crown - Black White",
		['ID'] = 82139183698439,
	},
	--// Helmets
	['M'] = {
		['Name'] = "Motorcycle Helmet - White Red",
		['ID'] = 100504804713142,
	},
	['N'] = {
		['Name'] = "Motorcycle Helmet - Black Red",
		['ID'] = 97647774814364,
	},
	['O'] = {
		['Name'] = "Motorcycle Helmet - Black",
		['ID'] = 96818536482215,
	},
	['P'] = {
		['Name'] = "Motorcycle Helmet",
		['ID'] = 82603511834308,
	},
	--// Protein Shakers
	['Q'] = {
		['Name'] = "Protein Shaker - White",
		['ID'] = 122071796353410,
	},
	['R'] = {
		['Name'] = "Protein Shaker - Red",
		['ID'] = 98181442625165,
	},
	['S'] = {
		['Name'] = "Protein Shaker - Black",
		['ID'] = 87085165668528,
	},
	['T'] = {
		['Name'] = "Protein Shaker - Yellow",
		['ID'] = 102642333841802,
	},
	--// Face Bandages
	['U'] = {
		['Name'] = "Face Bandages",
		['ID'] = 120067224049421,
	},
	['V'] = {
		['Name'] = "Face Bandages",
		['ID'] = 119243634001553,
	},
	['W'] = {
		['Name'] = "Face Bandages",
		['ID'] = 112600507634369,
	},
	['X'] = {
		['Name'] = "Face Bandages",
		['ID'] = 91774845227721,
	},
	--// Eye Bandage
	['Y'] = {
		['Name'] = "Eye Bandage",
		['ID'] = 84887382195802,
	},
	['Z'] = {
		['Name'] = "Eye Bandage",
		['ID'] = 138705825312307,
	},

	--// Nerd Glasses
	['A1'] = {
		['Name'] = "Nerd Glasses",
		['ID'] = 114623808048803,
	},
	['B1'] = {
		['Name'] = "Nerd Glasses - Red",
		['ID'] = 74735903599213,
	},
	['C1'] = {
		['Name'] = "Nerd Glasses - Green",
		['ID'] = 77949725271695,
	},
	['D1'] = {
		['Name'] = "Nerd Glasses - Black",
		['ID'] = 85169596622861,
	},
	--// Training Helmet
	['E1'] = {
		['Name'] = "Training Helmet",
		['ID'] = 100104438861007,
	},
	['F1'] = {
		['Name'] = "Training Helmet",
		['ID'] = 99713943487010,
	},
	['G1'] = {
		['Name'] = "Training Helmet",
		['ID'] = 81877496476783,
	},
	['H1'] = {
		['Name'] = "Training Helmet",
		['ID'] = 107974793938990,
	},
	--// Snake Glasses
	['I1'] = {
		['Name'] = "Snake Glasses Y2K - Purple",
		['ID'] = 130235233159644,
	},
	['J1'] = {
		['Name'] = "Snake Glasses Y2K - Pink",
		['ID'] = 130898687489564,
	},
	['K1'] = {
		['Name'] = "Snake Glasses Y2K - Yellow",
		['ID'] = 85537731341001,
	},
	['L1'] = {
		['Name'] = "Snake Glasses Y2K - Red",
		['ID'] = 138002585775905,
	},
	['M1'] = {
		['Name'] = "Snake Glasses Y2K - Black",
		['ID'] = 70454931418771,
	},
	['N1'] = {
		['Name'] = "Snake Glasses Y2K - Gray",
		['ID'] = 81653947431590,
	},
	['O1'] = {
		['Name'] = "Snake Glasses Y2K - Orange",
		['ID'] = 79643861023078,
	},
	['P1'] = {
		['Name'] = "Snake Glasses Y2K - Light Blue",
		['ID'] = 91544116053373,
	},
	['Q1'] = {
		['Name'] = "Snake Glasses Y2K - Blue",
		['ID'] = 108225068022205,
	},
	['R1'] = {
		['Name'] = "Snake Glasses Y2K - Green",
		['ID'] = 95997013721520,
	},
	
	['S1'] = {
		['Name'] = "Black Gold VVS Chain Diamonds",
		['ID'] = 138617591743408,
	},
	['T1'] = {
		['Name'] = "Big Metal Chain",
		['ID'] = 114922634621014,
	},
}


local function Get_Player_Data(Plr, Key)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		return PD:FindFirstChild(Key).Value
	end

	return nil
end

local function Get_Data(Is_GP)
	if(Is_GP)then
		return GP_Data
	end
	return Dev_Data
end

local function Get_ID_From_Name(Is_GP, Name)
	local Data = Get_Data(Is_GP)

	for Key, Item_Data in next, Data do
		if(Item_Data ~= nil and Item_Data['Name'] ~= nil and Item_Data['Name'] == Name 
			and Item_Data['ID'] ~= nil)then

			return Item_Data['ID']
		end
	end

	return nil
end

local function Get_Key_From_Name(Is_GP, Name)
	local Data = Get_Data(Is_GP)

	for Key, Item_Data in next, Data do
		if(Item_Data ~= nil and Item_Data['Name'] ~= nil and Item_Data['Name'] == Name)then
			return Key
		end
	end

	return nil
end

local function Get_Player_Owned_Gamepasses_Keys(Plr)
	local Owned_GP_Keys = Get_Player_Data(Plr, "Owned Gamepasses") or ""
	return string.split(Owned_GP_Keys, ",")
end

local function Player_Owns_Gamepass(Plr, Key)
	local Owned_Keys = Get_Player_Owned_Gamepasses_Keys(Plr)
	if(Owned_Keys ~= nil and #Owned_Keys > 0 and table.find(Owned_Keys, Key) ~= nil)then
		return true
	end

	return false
end


function funcs.Get_Player_Owned_Gamepasses_Keys(Plr)
	return Get_Player_Owned_Gamepasses_Keys(Plr)
end

function funcs.Get_All_Gamepass_Data()
	return GP_Data
end

function funcs.Get_All_Dev_Product_Data()
	return Dev_Data
end

function funcs.Get_All_UGC_Data()
	return UGC_Data
end

function funcs.Get_ID_From_Name(Is_GP, Name)
	return Get_ID_From_Name(Is_GP, Name)
end

function funcs.Get_ID_From_Key(Is_GP, Key)
	if(Is_GP)then
		local Data_V = GP_Data[Key]
		if(Data_V ~= nil and Data_V['ID'] ~= nil)then
			return Data_V['ID']
		end
	else
		local Data_V = Dev_Data[Key]
		if(Data_V ~= nil and Data_V['ID'] ~= nil)then
			return Data_V['ID']
		end
	end

	return -1
end


function funcs.Get_Key_From_Name(Is_GP, Name)
	return Get_Key_From_Name(Is_GP, Name)
end

function funcs.Get_Key_From_ID(Is_GP, ID)
	local Data = Get_Data(Is_GP)

	for Key, Item_Data in next, Data do
		if(Item_Data ~= nil and Item_Data['ID'] ~= nil and Item_Data['ID'] == ID)then
			return Key
		end
	end

	return nil
end

function funcs.Get_Data_From_Key(Is_GP, Key)
	if(Is_GP)then
		return GP_Data[Key]
	end
	return Dev_Data[Key]
end

function funcs.Does_Player_Own_Gamepass(Plr, Name)
	local GP_Key = Get_Key_From_Name(true, Name)
	return Player_Owns_Gamepass(Plr, GP_Key)
end

function funcs.Does_Player_Own_Gamepass_Key(Plr, Key)
	return Player_Owns_Gamepass(Plr, Key)
end

function funcs.Hard_Gamepass_Check(Plr, GP_ID)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = MPS:UserOwnsGamePassAsync(Plr.UserId, GP_ID)
		end)

		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end

	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end

	return false
end

local function Compile_Cash_Boost_Amounts(Plr)
	local Current_Cash = Get_Player_Data(Plr, "Coins") or 0
	local Vals = {
		['A'] = 400,
		['B'] = 800,
		['C'] = 2_500,
		['D'] = 6_000,
		['E'] = 60_000
	}

	--if(Current_Cash < 10000)then
	--	Current_Cash = 10000
	--elseif(Current_Cash > 10000000)then
	--	Current_Cash = 10000000
	--end

	--for Key, Multi in Vals do
	--	Vals[Key] = math.ceil(Current_Cash * Multi)
	--end

	return Vals
end

function funcs.Get_Cash_Boost_Amount(Plr)
	return Compile_Cash_Boost_Amounts(Plr)
end

function funcs.Prompt_Suggested_Cash_Boost(Plr, Needed_Amount)
	local Boost_Data = Compile_Cash_Boost_Amounts(Plr)
	local Boost_Key = "A"
	local Current_Dif, Current_Max = math.huge, -1

	for Key, Amount in next, Boost_Data do
		local Dif = math.abs(Amount - Needed_Amount)
		if((Amount >= Needed_Amount or Amount >= Current_Max) and Dif < Current_Dif)then
			Boost_Key = Key
			Current_Dif = Dif
			Current_Max = Amount
		end
	end

	return Dev_Data[Boost_Key]
end

function funcs.Get_Gems_Pack_Amount(Key)
	local Gems_Data = Dev_Data[Key]
	if(Gems_Data ~= nil and Gems_Data['Amount'] ~= nil)then
		return Gems_Data['Amount']
	end
	return 0
end


function funcs.Get_Cash_Multi(Plr)
	local Multi = 1

	local Owned_x2_Cash = Player_Owns_Gamepass(Plr, "C") or (Plr.Player_Data.Cash2x.Value == true)
	if(Owned_x2_Cash)then
		Multi += 1
	end

	local Owned_VIP = Player_Owns_Gamepass(Plr, "A") or (Plr.Player_Data.Vip.Value == true)
	if(Owned_VIP)then
		Multi += 0.1
	end

	return Multi
end

function funcs.Get_Elo_Multi(Plr)
	local Multi = 1

	local Owned_x2_Elo = Player_Owns_Gamepass(Plr, "B")
	if(Owned_x2_Elo)then
		Multi += 1
	end

	return Multi
end

function funcs.Get_Luck_Multi(Plr)
	local Multi = 1

	local Owned_x2_Luck = Player_Owns_Gamepass(Plr, "F")
	if(Owned_x2_Luck)then
		Multi += 1
	end

	local Owned_x3_Luck = Player_Owns_Gamepass(Plr, "E")
	if(Owned_x3_Luck)then
		Multi += 2
	end

	local Friends_Count = Plr:GetAttribute("Friends_Count") or 0
	Multi += Friends_Count * 0.1

	return Multi
end

function funcs.Get_ID_From_Key_UGC( Key)------------By Adnan
	local Data_V = UGC_Data[Key]
	if(Data_V ~= nil and Data_V['ID'] ~= nil)then
		return Data_V['ID']
	end
	return -1
end

function funcs.Get_UGC_Key_From_ID_UGC(ID)----------By Adnan
	for key, item in pairs(UGC_Data) do
		if item.ID == ID then
			return key
		end
	end
	return nil
end

return funcs
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0613D77DAB6641808C62D4F2AB0B3C87">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CameraShaker.lua</string>
						<string name="ScriptGuid">{1F3BF975-CB3A-4DB6-B46E-A2E5B7AE8091}</string>
						<ProtectedString name="Source"><![CDATA[-- Camera Shaker
-- Stephen Leitnick
-- February 26, 2018

--[[
	
	CameraShaker.CameraShakeInstance
	
	cameraShaker = CameraShaker.new(renderPriority, callbackFunction)
	
	CameraShaker:Start()
	CameraShaker:Stop()
	CameraShaker:StopSustained([fadeOutTime])
	CameraShaker:Shake(shakeInstance)
	CameraShaker:ShakeSustain(shakeInstance)
	CameraShaker:ShakeOnce(magnitude, roughness [, fadeInTime, fadeOutTime, posInfluence, rotInfluence])
	CameraShaker:StartShake(magnitude, roughness [, fadeInTime, posInfluence, rotInfluence])
	
	
	
	EXAMPLE:
	
		local camShake = CameraShaker.new(Enum.RenderPriority.Camera.Value, function(shakeCFrame)
			camera.CFrame = playerCFrame * shakeCFrame
		end)
		
		camShake:Start()
		
		-- Explosion shake:
		camShake:Shake(CameraShaker.Presets.Explosion)
		
		wait(1)
		
		-- Custom shake:
		camShake:ShakeOnce(3, 1, 0.2, 1.5)

		-- Sustained shake:
		camShake:ShakeSustain(CameraShaker.Presets.Earthquake)

		-- Stop all sustained shakes:
		camShake:StopSustained(1) -- Argument is the fadeout time (defaults to the same as fadein time if not supplied)

		-- Stop only one sustained shake:
		shakeInstance = camShake:ShakeSustain(CameraShaker.Presets.Earthquake)
		wait(2)
		shakeInstance:StartFadeOut(1) -- Argument is the fadeout time
	
	
	NOTE:
	
		This was based entirely on the EZ Camera Shake asset for Unity3D. I was given written
		permission by the developer, Road Turtle Games, to port this to Roblox.
		
		Original asset link: https://assetstore.unity.com/packages/tools/camera/ez-camera-shake-33148

		GitHub repository: https://github.com/Sleitnick/RbxCameraShaker
	
	
--]]



local CameraShaker = {}
CameraShaker.__index = CameraShaker

local profileBegin = debug.profilebegin
local profileEnd = debug.profileend
local profileTag = "CameraShakerUpdate"

local V3 = Vector3.new
local CF = CFrame.new
local ANG = CFrame.Angles
local RAD = math.rad
local v3Zero = V3()

local CameraShakeInstance = require(script.CameraShakeInstance)
local CameraShakeState = CameraShakeInstance.CameraShakeState

local defaultPosInfluence = V3(0.15, 0.15, 0.15)
local defaultRotInfluence = V3(1, 1, 1)


CameraShaker.CameraShakeInstance = CameraShakeInstance
CameraShaker.Presets = require(script.CameraShakePresets)


function CameraShaker.new(renderPriority, callback)
	
	assert(type(renderPriority) == "number", "RenderPriority must be a number (e.g.: Enum.RenderPriority.Camera.Value)")
	assert(type(callback) == "function", "Callback must be a function")
	
	local self = setmetatable({
		_running = false;
		_renderName = "CameraShaker";
		_renderPriority = renderPriority;
		_posAddShake = v3Zero;
		_rotAddShake = v3Zero;
		_camShakeInstances = {};
		_removeInstances = {};
		_callback = callback;
	}, CameraShaker)
	
	return self
	
end


function CameraShaker:Start()
	if (self._running) then return end
	self._running = true
	local callback = self._callback
	game:GetService("RunService"):BindToRenderStep(self._renderName, self._renderPriority, function(dt)
		profileBegin(profileTag)
		local cf = self:Update(dt)
		profileEnd()
		callback(cf)
	end)
end


function CameraShaker:Stop()
	if (not self._running) then return end
	game:GetService("RunService"):UnbindFromRenderStep(self._renderName)
	self._running = false
end


function CameraShaker:StopSustained(duration)
	for _,c in pairs(self._camShakeInstances) do
		if (c.fadeOutDuration == 0) then
			c:StartFadeOut(duration or c.fadeInDuration)
		end
	end
end


function CameraShaker:Update(dt)
	
	local posAddShake = v3Zero
	local rotAddShake = v3Zero
	
	local instances = self._camShakeInstances
	
	-- Update all instances:
	for i = 1,#instances do
		
		local c = instances[i]
		local state = c:GetState()
		
		if (state == CameraShakeState.Inactive and c.DeleteOnInactive) then
			self._removeInstances[#self._removeInstances + 1] = i
		elseif (state ~= CameraShakeState.Inactive) then
			local shake = c:UpdateShake(dt)
			posAddShake = posAddShake + (shake * c.PositionInfluence)
			rotAddShake = rotAddShake + (shake * c.RotationInfluence)
		end
		
	end
	
	-- Remove dead instances:
	for i = #self._removeInstances,1,-1 do
		local instIndex = self._removeInstances[i]
		table.remove(instances, instIndex)
		self._removeInstances[i] = nil
	end
	
	return CF(posAddShake) *
			ANG(0, RAD(rotAddShake.Y), 0) *
			ANG(RAD(rotAddShake.X), 0, RAD(rotAddShake.Z))
	
end


function CameraShaker:Shake(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance, "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:ShakeSustain(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance, "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	shakeInstance:StartFadeIn(shakeInstance.fadeInDuration)
	return shakeInstance
end


function CameraShaker:ShakeOnce(magnitude, roughness, fadeInTime, fadeOutTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:StartShake(magnitude, roughness, fadeInTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	shakeInstance:StartFadeIn(fadeInTime)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


return CameraShaker]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX3043D03979894427A4E0E804309F2D21">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">CameraShaker</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX93CAE5FA0AB7463A866D2645520F247D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CameraShakeInstance.lua</string>
							<string name="ScriptGuid">{4CEDB7FC-148E-4EAD-9553-4240340585CA}</string>
							<ProtectedString name="Source"><![CDATA[-- Camera Shake Instance
-- Stephen Leitnick
-- February 26, 2018

--[[
	
	cameraShakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	
--]]



local CameraShakeInstance = {}
CameraShakeInstance.__index = CameraShakeInstance

local V3 = Vector3.new
local NOISE = math.noise


CameraShakeInstance.CameraShakeState = {
	FadingIn = 0;
	FadingOut = 1;
	Sustained = 2;
	Inactive = 3;
}


function CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	
	if (fadeInTime == nil) then fadeInTime = 0 end
	if (fadeOutTime == nil) then fadeOutTime = 0 end
	
	assert(type(magnitude) == "number", "Magnitude must be a number")
	assert(type(roughness) == "number", "Roughness must be a number")
	assert(type(fadeInTime) == "number", "FadeInTime must be a number")
	assert(type(fadeOutTime) == "number", "FadeOutTime must be a number")
	
	local self = setmetatable({
		Magnitude = magnitude;
		Roughness = roughness;
		PositionInfluence = V3();
		RotationInfluence = V3();
		DeleteOnInactive = true;
		roughMod = 1;
		magnMod = 1;
		fadeOutDuration = fadeOutTime;
		fadeInDuration = fadeInTime;
		sustain = (fadeInTime > 0);
		currentFadeTime = (fadeInTime > 0 and 0 or 1);
		tick = Random.new():NextNumber(-100, 100);
		_camShakeInstance = true;
	}, CameraShakeInstance)
	
	return self
	
end


function CameraShakeInstance:UpdateShake(dt)
	
	local _tick = self.tick
	local currentFadeTime = self.currentFadeTime
	
	local offset = V3(
		NOISE(_tick, 0) * 0.5,
		NOISE(0, _tick) * 0.5,
		NOISE(_tick, _tick) * 0.5
	)
	
	if (self.fadeInDuration > 0 and self.sustain) then
		if (currentFadeTime < 1) then
			currentFadeTime = currentFadeTime + (dt / self.fadeInDuration)
		elseif (self.fadeOutDuration > 0) then
			self.sustain = false
		end
	end
	
	if (not self.sustain) then
		currentFadeTime = currentFadeTime - (dt / self.fadeOutDuration)
	end
	
	if (self.sustain) then
		self.tick = _tick + (dt * self.Roughness * self.roughMod)
	else
		self.tick = _tick + (dt * self.Roughness * self.roughMod * currentFadeTime)
	end
	
	self.currentFadeTime = currentFadeTime
	
	return offset * self.Magnitude * self.magnMod * currentFadeTime
	
end


function CameraShakeInstance:StartFadeOut(fadeOutTime)
	if (fadeOutTime == 0) then
		self.currentFadeTime = 0
	end
	self.fadeOutDuration = fadeOutTime
	self.fadeInDuration = 0
	self.sustain = false
end


function CameraShakeInstance:StartFadeIn(fadeInTime)
	if (fadeInTime == 0) then
		self.currentFadeTime = 1
	end
	self.fadeInDuration = fadeInTime or self.fadeInDuration
	self.fadeOutDuration = 0
	self.sustain = true
end


function CameraShakeInstance:GetScaleRoughness()
	return self.roughMod
end


function CameraShakeInstance:SetScaleRoughness(v)
	self.roughMod = v
end


function CameraShakeInstance:GetScaleMagnitude()
	return self.magnMod
end


function CameraShakeInstance:SetScaleMagnitude(v)
	self.magnMod = v
end


function CameraShakeInstance:GetNormalizedFadeTime()
	return self.currentFadeTime
end


function CameraShakeInstance:IsShaking()
	return (self.currentFadeTime > 0 or self.sustain)
end


function CameraShakeInstance:IsFadingOut()
	return ((not self.sustain) and self.currentFadeTime > 0)
end


function CameraShakeInstance:IsFadingIn()
	return (self.currentFadeTime < 1 and self.sustain and self.fadeInDuration > 0)
end


function CameraShakeInstance:GetState()
	if (self:IsFadingIn()) then
		return CameraShakeInstance.CameraShakeState.FadingIn
	elseif (self:IsFadingOut()) then
		return CameraShakeInstance.CameraShakeState.FadingOut
	elseif (self:IsShaking()) then
		return CameraShakeInstance.CameraShakeState.Sustained
	else
		return CameraShakeInstance.CameraShakeState.Inactive
	end
end


return CameraShakeInstance]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC3A2A7AAFAAB4543B97506D35B5CC039">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CameraShakePresets.lua</string>
							<string name="ScriptGuid">{8BCFF561-78E2-4BE0-AC0D-A6A0C2037F84}</string>
							<ProtectedString name="Source"><![CDATA[-- Camera Shake Presets
-- Stephen Leitnick
-- February 26, 2018

--[[
	
	CameraShakePresets.Bump
	CameraShakePresets.Explosion
	CameraShakePresets.Earthquake
	CameraShakePresets.BadTrip
	CameraShakePresets.HandheldCamera
	CameraShakePresets.Vibration
	CameraShakePresets.RoughDriving
	
--]]



local CameraShakeInstance = require(script.Parent.CameraShakeInstance)

local CameraShakePresets = {
	
	
	-- A high-magnitude, short, yet smooth shake.
	-- Should happen once.
	Bump = function()
		local c = CameraShakeInstance.new(2.5, 4, 0.1, 0.75)
		c.PositionInfluence = Vector3.new(0.15, 0.15, 0.15)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;
	
	
	-- An intense and rough shake.
	-- Should happen once.
	Explosion = function()
		local c = CameraShakeInstance.new(5, 10, 0, 1.5)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(4, 1, 1)
		return c
	end;
	
	
	-- A continuous, rough shake
	-- Sustained.
	Earthquake = function()
		local c = CameraShakeInstance.new(0.6, 3.5, 2, 10)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(1, 1, 4)
		return c
	end;
	
	
	-- A bizarre shake with a very high magnitude and low roughness.
	-- Sustained.
	BadTrip = function()
		local c = CameraShakeInstance.new(10, 0.15, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0.15)
		c.RotationInfluence = Vector3.new(2, 1, 4)
		return c
	end;
	
	
	-- A subtle, slow shake.
	-- Sustained.
	HandheldCamera = function()
		local c = CameraShakeInstance.new(1, 0.25, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 0.5, 0.5)
		return c
	end;
	
	
	-- A very rough, yet low magnitude shake.
	-- Sustained.
	Vibration = function()
		local c = CameraShakeInstance.new(0.4, 20, 2, 2)
		c.PositionInfluence = Vector3.new(0, 0.15, 0)
		c.RotationInfluence = Vector3.new(1.25, 0, 4)
		return c
	end;
	
	
	-- A slightly rough, medium magnitude shake.
	-- Sustained.
	RoughDriving = function()
		local c = CameraShakeInstance.new(1, 2, 1, 1)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;
	
	
}


return setmetatable({}, {
	__index = function(t, i)
		local f = CameraShakePresets[i]
		if (type(f) == "function") then
			return f()
		end
		error("No preset found with index \"" .. i .. "\"")
	end;
})]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXA579876E1B4F4DCDB1A5E9E34C76A78E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Num_String_Mod.lua</string>
						<string name="ScriptGuid">{325BFA89-5692-4523-A2F3-C7DA89FB006F}</string>
						<ProtectedString name="Source"><![CDATA[local funcs = {}

function funcs.NumToString(Num)
	
	local function ToRomanNums(Num)
		local RomanNums1 = {
			"I", "II", "III", "IV", "V", "VI", "VII", "IIX", "IX", "X"
		}
		local RomanNums2 = {
			"I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"
		}
		local RomanNums3 = {
			"X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "C",
			"CX", "CXX", "CXXX", "CXL", "CL", "CLX", "CLXX", "CLXXX", "CXC", "CC"
		}
		local RomanNum = ""
		local Tens = math.floor(Num/10)
		local Ones = Num - (Tens * 10)
		if Tens > 0 then
			RomanNum = RomanNum .. RomanNums3[Tens]
			if Ones > 0 then
				RomanNum = RomanNum .. RomanNums2[Ones]
			end
		else
			if Ones > 0 then
				RomanNum = RomanNums1[Ones]
			end
		end
		return RomanNum
	end
	
	local Nums = {"K","M","B","T","Qa","Qi","Sx","Sp","Oc","N","Dc","U","Dd","Td","Qt","Qd","Sd","St","Ot","Nv","V","C"}
	Num = tonumber(Num)
	if Num >= 1000 then
		local Div
		local Char
		if tostring(Num):split('e+')[2] then
			Div = math.floor(tonumber(tostring(Num):split('e+')[2])/3)
			local Rest = tonumber(tostring(Num):split('e+')[2])%3
			Char = Nums[Div]
			if not Char then
				if math.floor(Div/#Nums) <= 209 then
					Char = Nums[Div%#Nums + 1] .. ToRomanNums(math.floor(Div/#Nums))
					local NewNum = tostring(tonumber(tostring(Num):split('e')[1]) * 10^Rest)
					local AfterFasila = ''
					if NewNum:split('.')[2] then
						for i = 1, string.len(NewNum:split('.')[2]) do
							if i > 2 then
								break
							elseif tonumber(NewNum:split('.')[2]:split('')[i]) == 0 then
								break
							else
								AfterFasila = AfterFasila .. tonumber(NewNum:split('.')[2]:split('')[i])
							end
						end
						NewNum = NewNum:split('.')[1] .. "." .. AfterFasila
					end
					Num = NewNum .. Char
				else
					Num = "Inf"
				end 
			else
				local NewNum = tostring(tonumber(tostring(Num):split('e')[1]) * 10^Rest)
				local AfterFasila = ''
				if NewNum:split('.')[2] then
					for i = 1, string.len(NewNum:split('.')[2]) do
						if i > 2 then
							break
						elseif tonumber(NewNum:split('.')[2]:split('')[i]) == 0 then
							break
						else
							AfterFasila = AfterFasila .. tonumber(NewNum:split('.')[2]:split('')[i])
						end
					end
					NewNum = NewNum:split('.')[1] .. "." .. AfterFasila
				end
				Num = NewNum .. Char
			end
		elseif tostring(Num) == "inf" then
			Num = "Inf"
		else
			Num = tostring(math.floor(Num))
			local Div = math.floor((string.len(Num)-1)/3)
			local Char = Nums[Div]
			local Rest = string.len(Num) - 3*Div
			local NewNum = ""
			for i = 1, Rest do
				NewNum = NewNum .. Num:split('')[i]
			end
			if Num:split('')[Rest + 1] ~= "0" then
				NewNum = NewNum .. "." 
			end
			local DotNumbers = 2
			for i = 1, 2 do
				if Num:split('')[Rest + i] == "0" then
					break
				else
					NewNum = NewNum .. Num:split('')[Rest + i]
				end
			end
			NewNum = NewNum .. Char
			Num = NewNum
		end
	elseif Num <= 1000 then
		Num = tostring(Num)
		if Num:split('.')[2] then
			Num = Num:split('.')[1] .. "." .. Num:split('.')[2]:split('')[1]
		end
	end
	return Num
end

return funcs]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0B41AF67B2544FB1AC37341460C1F97C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Elo_Mod.lua</string>
						<string name="ScriptGuid">{DC67BFA8-EF5B-4D1F-B062-A657873F45B4}</string>
						<ProtectedString name="Source"><![CDATA[local funcs = {}

local Rank_Data = {
	['Bronze'] = {
		['Index'] = 1,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(0, 550),
		['Color'] = Color3.fromRGB(170, 170, 127)
	},
	
	['Silver'] = {
		['Index'] = 2,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(550, 800),
		['Color'] = Color3.new(1, 1, 1)
	},
	
	['Gold'] = {
		['Index'] = 3,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(800, 1150),
		['Color'] = Color3.fromRGB(255, 170, 0)
	},
	
	['Emerald'] = {
		['Index'] = 4,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(1150, 1600),
		['Color'] = Color3.fromRGB(170, 255, 0)
	},
	
	['Diamond'] = {
		['Index'] = 5, 
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(1600, 2150),
		['Color'] = Color3.new(0, 1, 1)
	},
	
	['Platinum'] = {
		['Index'] = 6,
		['Icon'] = "rbxassetid://89194867048049",
		['Elo Range'] = NumberRange.new(2150, math.huge),
		['Color'] = Color3.fromRGB(170, 85, 255)
	},
}

local function Get_Player_Val(Plr, Key)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		return PD:FindFirstChild(Key)
	end
	
	return nil
end

function funcs.Get_Player_Rank_Data(Plr)
	if(Plr ~= nil)then
		local Elo_Val = Get_Player_Val(Plr, "Elo")
		local Ret_Data = Rank_Data['Bronze']
		Ret_Data['Key'] = "Bronze"

		if(Elo_Val ~= nil)then
			local Elo_Amount = Elo_Val.Value
			for Key, Data in next, Rank_Data do
				local Range = Data['Elo Range']
				if(Range.Min <= Elo_Amount and Range.Max > Elo_Amount)then
					Data['Key'] = Key
					return Data, Elo_Amount
				end
			end
		end
	end
	
	local Ret_Data = Rank_Data['Bronze']
	Ret_Data['Key'] = "Bronze"
	return Ret_Data, 400
end

function funcs.Get_Next_Rank_Data(Current_Index)
	for Key, Data in next, Rank_Data do
		if(Current_Index + 1 == Data['Index'])then
			return Data
		end
	end
	
	return Rank_Data['Platinum']
end

function funcs.Get_Elo_Data_From_Val(Val)
	for Key, Data in next, Rank_Data do
		local Range = Data['Elo Range']
		local Min, Max = Range.Min, Range.Max
		
		if(Val >= Min and Val <= Max)then
			return Key, Data
		end
	end
	
	return "Bronze", Rank_Data['Bronze']
end

return funcs
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX54186F90E35448BAA9B747AE20F65231">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Sound_Effect_Mod.lua</string>
						<string name="ScriptGuid">{EA71B042-0264-425D-950A-243C816F32DD}</string>
						<ProtectedString name="Source"><![CDATA[local funcs = {}
local Debris = game:GetService("Debris")

function funcs.Get_SE_Object(Plr, SE_Name)
	local PG = Plr:WaitForChild("PlayerGui")
	local SE_F = PG:WaitForChild("Sound_Effects_F") :: Instance
	
	local start = os.clock()
	while true do
		local sound = SE_F:FindFirstChild(SE_Name, true)
		if sound == nil then
			task.wait()
			
			if start ~= nil then
				if os.clock() - start >= 1 then
					warn(`Infinite yield possible for sound {SE_Name}. Typo?`)
					start = nil
				end
			end
		else
			return sound
		end
	end
end

function funcs.Play_Sound_Effect(Obj, SE_Name)
	if(game.Players.LocalPlayer == nil and Obj ~= nil and game.ServerStorage:FindFirstChild("Global_Sounds_F") ~= nil)then
		local Global_F = game.ServerStorage:FindFirstChild("Global_Sounds_F")
		local Main_SE = Global_F:FindFirstChild(SE_Name)
		if(Main_SE ~= nil)then
			local function Get_SE_TMP()
				if(Main_SE:IsA("Folder"))then
					local All_C = Main_SE:GetChildren()
					return All_C[math.random(1, #All_C)]
				end
				return Main_SE
			end
			local SE_TMP = Get_SE_TMP()
			
			local SE = SE_TMP:Clone()
			SE.Parent = Obj
			SE:Play()
			Debris:AddItem(SE, SE_TMP.TimeLength + 1)
		end
	end
end

--[[
	- Make sure a Local Function Call
	- Check if we have the Setting Disabled or not
	- Track Chance based on Frequency via Attribute
	- Randomly select Sound Effect and Play it
]]--

local function Get_Audio_Clips_F(Plr, Action_Key)
	local PG = Plr:FindFirstChild("PlayerGui")
	if(PG ~= nil and PG:FindFirstChild("Sound_Effects_F") ~= nil)then
		local SE_F = PG:FindFirstChild("Sound_Effects_F")
		local Voice_Over_F = SE_F:FindFirstChild("Voice_Over_F")
		if(Voice_Over_F ~= nil and Voice_Over_F:FindFirstChild(Action_Key) ~= nil)then
			return Voice_Over_F:FindFirstChild(Action_Key)
		end
	end
	return nil
end

local function Will_Play_Voice_Over(Audio_F)
	local Chance = Audio_F:GetAttribute("Chance") or 100
	local Did_Play = Audio_F:GetAttribute("Did_Play")
	
	if(Did_Play ~= nil and Did_Play == true)then
		local Pick = math.random(1, 100)
		if(Pick < Chance)then
			return true
		else
			return false
		end
	end
	
	Audio_F:SetAttribute("Did_Play", true)
	return true
end

local function Voice_Over_Enabled(Plr)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild("Voice Over") ~= nil)then
		return PD:FindFirstChild("Voice Over").Value
	end
	return false
end

function funcs.Play_Voice_Over(Action_Key)
	local Plr = game.Players.LocalPlayer
	if(Plr ~= nil and Voice_Over_Enabled(Plr) == true)then
		local Audio_Clips_F = Get_Audio_Clips_F(Plr, Action_Key)
		if(Audio_Clips_F ~= nil and #Audio_Clips_F:GetChildren() > 0 and Will_Play_Voice_Over(Audio_Clips_F))then
			local SE_Clips = Audio_Clips_F:GetChildren()
			local Selected_SE = SE_Clips[math.random(1, #SE_Clips)]
			
			if(Selected_SE ~= nil and Selected_SE:IsA("Sound"))then
				Selected_SE:Play()
			end
		end
	end
end

return funcs
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX254FE98B628F4094BE871E5322574DB4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Animation_Mod.lua</string>
						<string name="ScriptGuid">{F14C5A83-0404-4D89-B534-A5BBF0D21888}</string>
						<ProtectedString name="Source"><![CDATA[local funcs = {}
local Animation_Objs_F = game.ReplicatedStorage:WaitForChild("Animation_Objs_F")

local Movement_Animations = {
	['Idle'] = 108077631566601,
	['Shuffle Side'] = 79375297609893,
	['Shuffle Forward'] = 136948432130840,
	
	--['Shuffle Forward'] = 109207253924129,
	
	--['Shuffle Side'] = 89602830994683,
	--['Shuffle Forward'] = 139861313294402,
}

local Striking_Data = {
	['Taking Hit'] = {
		['ID'] = 87073445720365,
		['Reverses'] = false
	},
	
	['Body Block Left'] = {
		['ID'] = 104895699142546,
		['Reverses'] = true
	},
	
	['Body Block Right'] = {
		['ID'] = 99944482960873,
		['Reverses'] = true
	},
	
	['Slip Left'] = {
		['ID'] = 136849218895282,
		['Reverses'] = true
	},

	['Slip Right'] = {
		['ID'] = 122220718204244,
		['Reverses'] = true
	},
	
	['Dodge Back'] = {
		['ID'] = 94177011723049,
		['Reverses'] = false
	},
	
	['Headblock Left'] = {
		['ID'] = 110779732594817,
		['Reverses'] = true
	},

	['Headblock Right'] = {
		['ID'] = 121662213274181,
		['Reverses'] = true
	},
	
	['Main Block'] = {
		['ID'] = 94238142478294,
		['Reverses'] = true
	},
	
}

local Combination_Move_Data = {
	['A'] = {
		['Name'] = "Cross Punch",
		['Punch'] = true,
		['ID'] = 100227999129843,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.1,
		--Purchase Data
		['Price'] = 0
	},
	
	['B'] = {
		['Name'] = "Hook Punch",
		['ID'] = 81561131125346,
		['Punch'] = true,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.1,
		--Purchase Data
		['Price'] = 0
	},
	
	['C'] = {
		['Name'] = "Jab",
		['ID'] = 105445140410756,
		['Punch'] = true,
		['Reverses'] = false,
		--Fight Data
		['Power Multi'] = 0,
		--Purchase Data
		['Price'] = 0
	},
	
	['D'] = {
		['Name'] = "Body Kick",
		['ID'] = 125520199895947,
		['Punch'] = false,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.175,
		--Purchase Data
		['Price'] = 0
	},
	
	['E'] = {
		['Name'] = "Head Kick",
		['ID'] = 126568677089282,
		['Punch'] = false,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.2,
		--Purchase Data
		['Price'] = 0
	},
	
	['F'] = {
		['Name'] = "Leg Kick",
		['ID'] = 110461738059355,
		['Punch'] = false,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.05,
		--Purchase Data
		['Price'] = 0
	},
	
	['G'] = {
		['Name'] = "Overhand Punch",
		['ID'] = 131610958973209,
		['Punch'] = true,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.2,
		--Purchase Data
		['Price'] = 0
	},
	
	['H'] = {
		['Name'] = "Push Kick",
		['ID'] = 77338767921527,
		['Punch'] = false,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.1,
		--Purchase Data
		['Price'] = 0
	},
	
	['I'] = {
		['Name'] = "Roundhouse Body Kick",
		['ID'] = 81721721853423,
		['Punch'] = false,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.2125,
		--Purchase Data
		['Price'] = 0
	},
	
	['J'] = {
		['Name'] = "Roundhouse Head Kick",
		['ID'] = 79766698080686,
		['Punch'] = false,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.25,
		--Purchase Data
		['Price'] = 0
	},
	
	['K'] = {
		['Name'] = "Roundhouse Leg Kick",
		['ID'] = 138214621139428,
		['Punch'] = false,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.1125,
		--Purchase Data
		['Price'] = 0
	},
	
	['L'] = {
		['Name'] = "Spinning Backfist",
		['ID'] = 96399865414625,
		['Punch'] = true,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.125,
		--Purchase Data
		['Price'] = 0
	},
	
	['M'] = {
		['Name'] = "Uppercut Punch",
		['ID'] = 71389736066050,
		['Punch'] = true,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.25,
		--Purchase Data
		['Price'] = 0
	},
	
	['N'] = {
		['Name'] = "Elbow Strike",
		['ID'] = 132635065254903,
		['Punch'] = true,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.2,
		--Purchase Data
		['Price'] = 0
	},
	
	['O'] = {
		['Name'] = "Spinning Elbow Strike",
		['ID'] = 111369637414564,
		['Punch'] = true,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.25,
		--Purchase Data
		['Price'] = 0
	},
	
	['P'] = {
		['Name'] = "Flying Knee Strike",
		['ID'] = 130784737248262,
		['Punch'] = false,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.25,
		--Purchase Data
		['Price'] = 0
	},
	
	['Q'] = {
		['Name'] = "Knee Clinch",
		['ID'] = 81137097576975,
		['Punch'] = false,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.125,
		--Purchase Data
		['Price'] = 0
	},
	
	['R'] = {
		['Name'] = "Knee Strike",
		['ID'] = 108737295565365,
		['Punch'] = false,
		['Reverses'] = true,
		--Fight Data
		['Power Multi'] = 0.15,
		--Purchase Data
		['Price'] = 0
	},
}

local Takedown_Move_Data = {
	['A'] = {
		['Name'] = "Takedown",
		['Takedown ID'] = 90000582035319,
		['Receiving ID'] = 137215852579263,
		['CF Offset'] = CFrame.new(Vector3.new(0.4881000518798828, 0.00011396408081054688, -3.292452335357666)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Time Length'] = 1.02,
		['Price'] = 0
	},
	
	['B'] = {
		['Name'] = "Suplex",
		['Takedown ID'] = 96292674087311,
		['Receiving ID'] = 124116836479443,
		['CF Offset'] = CFrame.new(Vector3.new(0.4881000518798828, 0.00011396408081054688, -3.292452335357666)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Time Length'] = 2.07,
		['Price'] = -1
	},
}

local Submission_Hold_Data = {
	['A'] = {
		['Name'] = "Armbar",
		['Submission ID'] = 77995795549949,
		['Submission Loop ID'] = 131555693143885,
		['Receiving ID'] = 135512944211258,
		['Receiving Loop ID'] = 114826200035426,
		['CF Offset'] = CFrame.new(Vector3.new(-0.2868995666503906, 0.00011396408081054688, -3.292452335357666)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = 0
	},
	
	['B'] = {
		['Name'] = "Bow + Arrow Choke",
		['Submission ID'] = 75355863213565,
		['Submission Loop ID'] = 85715488163612,
		['Receiving ID'] = 82374638588189,
		['Receiving Loop ID'] = 123114250253699,
		['CF Offset'] = CFrame.new(Vector3.new(-0.116668701171875, 0.25331592559814453, 1.6584720611572266)) * CFrame.Angles(-0, 0, -0),
		['Price'] = 0
	},
	
	['C'] = {
		['Name'] = "Rear Choke",
		['Submission ID'] = 132773296535203,
		['Submission Loop ID'] = 125823752907571,
		['Receiving ID'] = 124306025776879,
		['Receiving Loop ID'] = 77790217013197,
		['CF Offset'] = CFrame.new(Vector3.new(-0.0677032470703125, 0.16611409187316895, 0.8032341003417969)) * CFrame.Angles(-0, 0, -0),
		['Price'] = -1
	},
	
	['D'] = {
		['Name'] = "D'Acre Choke",
		['Submission ID'] = 119311130373519,
		['Submission Loop ID'] = 125304925445976,
		['Receiving ID'] = 80700787386082,
		['Receiving Loop ID'] = 120536455540110,
		['CF Offset'] = CFrame.new(Vector3.new(0.3773040771484375, 0.00011396408081054688, -7.310765266418457)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},

	['E'] = {
		['Name'] = "Peruvian Necktie",
		['Submission ID'] = 80067783627585,
		['Submission Loop ID'] = 122521525908433,
		['Receiving ID'] = 92103429555208,
		['Receiving Loop ID'] = 83941364350231,
		['CF Offset'] = CFrame.new(Vector3.new(-1.8148994445800781, 0.00011396408081054688, -5.270452499389648)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
	
	['F'] = {
		['Name'] = "Crucifix Choke",
		['Submission ID'] = 136852003392692,
		['Submission Loop ID'] = 138253407435423,
		['Receiving ID'] = 84266203794329,
		['Receiving Loop ID'] = 133824539813558,
		['CF Offset'] = CFrame.new(Vector3.new(-2.4148998260498047, 0.00011396408081054688, -0.8284523487091064)) * CFrame.Angles(-0, math.rad(-90), 0),
		['Price'] = -1
	},
	
	['G'] = {
		['Name'] = "Ezekiel Choke",
		['Submission ID'] = 138151382939604,
		['Submission Loop ID'] = 87342228644616,
		['Receiving ID'] = 130331156841132,
		['Receiving Loop ID'] = 130320679529339,
		['CF Offset'] = CFrame.new(Vector3.new(-0.009899139404296875, 0.00011396408081054688, 2.3495476245880127)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
	
	['H'] = {
		['Name'] = "North-South Choke",
		['Submission ID'] = 120276704304047,
		['Submission Loop ID'] = 101002039631767,
		['Receiving ID'] = 93330579903894,
		['Receiving Loop ID'] = 139785195887722,
		['CF Offset'] = CFrame.new(Vector3.new(4.597099304199219, 0.00011396408081054688, 4.539547920227051)) * CFrame.Angles(0, math.rad(90), 0),
		['Price'] = -1
	},
	
	['I'] = {
		['Name'] = "Anaconda Choke",
		['Submission ID'] = 139254908975474,
		['Submission Loop ID'] = 123395024978060,
		['Receiving ID'] = 107198374601193,
		['Receiving Loop ID'] = 108362674273214,
		['CF Offset'] = CFrame.new(Vector3.new(0.1930999755859375, 0.00011396408081054688, -4.3244524002075195)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
	
	['J'] = {
		['Name'] = "Guillotine Choke",
		['Submission ID'] = 125216184549242,
		['Submission Loop ID'] = 140031549975052,
		['Receiving ID'] = 122205044713456,
		['Receiving Loop ID'] = 135121330657191,
		['CF Offset'] = CFrame.new(Vector3.new(-0.189697265625, 0.00011396408081054688, 0.0002346038818359375)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
	
	['K'] = {
		['Name'] = "Triangle Choke",
		['Submission ID'] = 89703608283013,
		['Submission Loop ID'] = 124327589301499,
		['Receiving ID'] = 73462023202758,
		['Receiving Loop ID'] = 94751838108470,
		['CF Offset'] = CFrame.new(Vector3.new(-0.5547027587890625, 0.00011396408081054688, -0.09476470947265625)) * CFrame.Angles(math.rad(180), -0, math.rad(180)),
		['Price'] = -1
	},
}

local Cage_Clinch_Data = {
	['A'] = {
		['Name'] = "Clinch Init",
		['ID'] = 80784815674908,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = true,
		['Link Key'] = "F",
	},
	
	['B'] = {
		['Name'] = "Clinch Loop",
		['ID'] = 87962198986708,
		['Reverses'] = false,
		['Looped'] = true,
		['Attacking'] = true,
		['Link Key'] = "G",
	},
	
	['C'] = {
		['Name'] = "High Knee",
		['ID'] = 132795144177389,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = true,
		['Link Key'] = "H",
	},
	
	['D'] = {
		['Name'] = "Low Knee",
		['ID'] = 93673806124998,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = true,
		['Link Key'] = "I",
	},
	
	['E'] = {
		['Name'] = "Uppercut",
		['ID'] = 99286997711377,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = true,
		['Link Key'] = "J",
	},


	['F'] = {
		['Name'] = "Clinch Init Target",
		['ID'] = 139067262581330,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = false,
		['Link Key'] = "A",
	},

	['G'] = {
		['Name'] = "Clinch Loop Target",
		['ID'] = 99857009954124,
		['Reverses'] = false,
		['Looped'] = true,
		['Attacking'] = false,
		['Link Key'] = "B",
	},

	['H'] = {
		['Name'] = "High Knee Target",
		['ID'] = 136345233529547,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = false,
		['Link Key'] = "C",
	},

	['I'] = {
		['Name'] = "Low Knee Target",
		['ID'] = 126512754019218,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = false,
		['Link Key'] = "D",
	},

	['J'] = {
		['Name'] = "Uppercut Target",
		['ID'] = 71592715011713,
		['Reverses'] = false,
		['Looped'] = false,
		['Attacking'] = false,
		['Link Key'] = "E",
	},
}

local Emote_Data = {
	['A'] = {
		['Name'] = "Flexing",
		['ID'] = 10713990381,
		['Icon'] = "rbxassetid://129785468776058",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['B'] = {
		['Name'] = "Dolphin Dance",
		['ID'] = 10714068222,
		['Icon'] = "rbxassetid://110318046103048",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['C'] = {
		['Name'] = "1-2 Combo",
		['ID'] = 10717116749,
		['Icon'] = "rbxassetid://129775502633259",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['D'] = {
		['Name'] = "Flossing",
		['ID'] = 10714340543,
		['Icon'] = "rbxassetid://117551617182244",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['E'] = {
		['Name'] = "Break Dance",
		['ID'] = 18526288497,
		['Icon'] = "rbxassetid://109576668333205",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['F'] = {
		['Name'] = "Backflip",
		['ID'] = 15693621070,
		['Icon'] = "rbxassetid://113129464009404",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['G'] = {
		['Name'] = "Monkey",
		['ID'] = 10714388352,
		['Icon'] = "rbxassetid://140702511165691",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['H'] = {
		['Name'] = "Frosty Flair",
		['ID'] = 10214311282,
		['Icon'] = "rbxassetid://111762236681762",
		['Price'] = 0,
		['Reverses'] = false
	},
	
	['I'] = {
		['Name'] = "Wild Stuff",
		['ID'] = 18665811005,
		['Icon'] = "rbxassetid://76044186658278",
		['Price'] = 10,
		['Reverses'] = false
	},
	
	['J'] = {
		['Name'] = "Zab",
		['ID'] = 129470135909814,
		['Icon'] = "rbxassetid://116534530149694",
		['Price'] = 10,
		['Reverses'] = false
	},
	
	['K'] = {
		['Name'] = "Robot",
		['ID'] = 10714392151,
		['Icon'] = "rbxassetid://108233046384117",
		['Price'] = 10,
		['Reverses'] = false
	},
}

local function Get_Player_Val(Plr, Key, Get_Object)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		local V = PD:FindFirstChild(Key)
		if(Get_Object)then
			return V
		else
			return V.Value
		end
		
	end
	
	return nil
end

local function Get_Animation_Track(Hum, Name, ID)
	local function Create_Animation_Object()
		local Ani_Obj = Animation_Objs_F:FindFirstChild(Name .. "_Ani")
		if(Ani_Obj == nil)then
			Ani_Obj = Instance.new("Animation", Animation_Objs_F)
			Ani_Obj.Name = Name .. "_Ani"
			Ani_Obj.AnimationId = "rbxassetid://" .. ID
		end
		return Ani_Obj
	end
	local Ani_Obj = Create_Animation_Object()
	return Hum:LoadAnimation(Ani_Obj)
end

function funcs.Get_Movement_Animation_Tracks(Hum)
	local Anim_Tack_Data = {
		
	}
	
	for Key, ID in next, Movement_Animations do
		Anim_Tack_Data[Key] = Get_Animation_Track(Hum, Key, ID)
	end
	
	return Anim_Tack_Data
end

function funcs.Get_Striking_Animation_Tracks(Hum)
	local Anim_Tack_Data = {

	}

	for Key, Anim_Data in next, Striking_Data do
		local Anim_T = Get_Animation_Track(Hum, Key, Anim_Data['ID'])
		local Is_Reversing = Anim_Data['Reverses'] or false
		Anim_T:SetAttribute("Reverses", Is_Reversing)
		
		Anim_Tack_Data[Key] = Anim_T
	end

	return Anim_Tack_Data
end

function funcs.Get_Strike_Combo_Data(Strike_Key)
	if(Combination_Move_Data[Strike_Key] ~= nil)then
		return Combination_Move_Data[Strike_Key]
	end
	return Combination_Move_Data['A']
end

local function Player_Owns_Strike_Key_Check(Plr, Strike_Key)
	local Strike_Data = Combination_Move_Data[Strike_Key]
	if(Strike_Data ~= nil and Strike_Data['Price'] ~= nil and Strike_Data['Price'] > 0)then
		local Owned_Strikes_V = Get_Player_Val(Plr, "Owned Special Strikes", false) or ""
		local Owned_Strikes_Keys = string.split(Owned_Strikes_V, ",")

		if(Owned_Strikes_Keys ~= nil and table.find(Owned_Strikes_Keys, Strike_Key) == nil)then
			return false
		end
	end

	return true
end

function funcs.Player_Owns_Strike_Key(Plr, Strike_Key)
	return Player_Owns_Strike_Key_Check(Plr, Strike_Key)
end

function funcs.Get_Striking_Combination_Tracks(Plr, Hum)
	local Ani_Tracks = {}
	local Total_Combos, Strikes_Per_Combo = 4, 3
	local Owned_Strikes_V = Get_Player_Val(Plr, "Owned Special Strikes", false) or ""
	local Owned_Strikes_Keys = string.split(Owned_Strikes_V, ",")
	
	local function Create_Combo_Tracks(Combo_Str)
		local Str_Split = string.split(Combo_Str, ",")
		
		local function Player_Owns_Combo(C_Data, Key)
			if(C_Data['Price'] ~= nil and C_Data['Price'] > 0 and 
				table.find(Owned_Strikes_Keys, Key) == nil)then
				
				return false
			end
			
			return true
		end
		
		for i = 1, #Str_Split do
			local Ani_Key = Str_Split[i]
			if(Combination_Move_Data[Ani_Key] ~= nil)then
				local C_Data = Combination_Move_Data[Ani_Key]
				local Ani_Name, Ani_ID = C_Data['Name'], C_Data['ID']
				
				if(Ani_Name ~= nil and Ani_ID ~= nil and Player_Owns_Combo(C_Data, Ani_Key))then
					local Ani_T = Get_Animation_Track(Hum, Ani_Name, Ani_ID)
					local Is_Reversing = C_Data['Reverses']
					Ani_T:SetAttribute("Reverses", Is_Reversing)
					Ani_T:SetAttribute("Strike_Key", Ani_Key)
					
					table.insert(Ani_Tracks, Ani_T)
				end
			end
		end
	end
	
	for i = 1, Total_Combos do 
		local Combo_Key = "Strike Combo " .. i
		local Combo_Str = Get_Player_Val(Plr, Combo_Key, false)
		if(Combo_Str ~= nil)then
			Create_Combo_Tracks(string.gsub(Combo_Str, " ", ""))
		end
	end
	
	return Ani_Tracks
end

function funcs.Get_Combinations(Tble)
	if Tble == "Combination" then
		return Combination_Move_Data
	elseif Tble == "Submission" then
		return Submission_Hold_Data
	elseif Tble == "Takedown" then
		return Takedown_Move_Data
	elseif Tble == "Emotes" then
		return Emote_Data
	end
	return nil
end

function funcs.Get_Takedown_Submission_Tracks(Hum, Takedown_ID, Submission_ID, Submission_Loop_ID)
	local function Create_Track_To_Return(ID)
		local Track = Get_Animation_Track(Hum, ID, ID)
		if(Track ~= nil)then
			Track:SetAttribute("Reverses", false)
			return Track
		end
		return nil
	end
	local Takedown_Track = Create_Track_To_Return(Takedown_ID)
	local Submission_Track = Create_Track_To_Return(Submission_ID)
	
	local Submission_Loop_Track = Create_Track_To_Return(Submission_Loop_ID)
	if(Submission_Loop_Track ~= nil)then
		Submission_Loop_Track.Looped = true
	end
	
	return Takedown_Track, Submission_Track, Submission_Loop_Track
end

local function Player_Owns_Submission_Key_Check(Plr, Strike_Key)
	local Submission_Data = Submission_Hold_Data[Strike_Key]
	
	if (Submission_Data ~= nil and Submission_Data['Price'] and Submission_Data['Price'] == 0) then 
		return true 
	end
	
	if(Submission_Data ~= nil and Submission_Data['Price'] ~= nil and Submission_Data['Price'] ~= 0)then
		local Owned_Submission_V = Get_Player_Val(Plr, "Owned Special Submissions", false) or ""
		local Owned_Submission_Keys = string.split(Owned_Submission_V, ",")
		
		if (Owned_Submission_Keys == nil) then return false end

		if(Owned_Submission_Keys ~= nil and table.find(Owned_Submission_Keys, Strike_Key) == nil) then
			return false
		end
		
	end

	return true
end

local function Player_Owns_Takedown_Key_Check(Plr, Strike_Key)
	local Takedown_Data = Takedown_Move_Data[Strike_Key]

	if (Takedown_Data ~= nil and Takedown_Data['Price'] and Takedown_Data['Price'] == 0) then 
		return true 
	end

	if(Takedown_Data ~= nil and Takedown_Data['Price'] ~= nil and Takedown_Data['Price'] ~= 0)then
		local Owned_Submission_V = Get_Player_Val(Plr, "Owned Special Takedowns", false) or ""
		local Owned_Submission_Keys = string.split(Owned_Submission_V, ",")

		if (Owned_Submission_Keys == nil) then return false end

		if(Owned_Submission_Keys ~= nil and table.find(Owned_Submission_Keys, Strike_Key) == nil) then
			return false
		end

	end

	return true
end

function funcs.Player_Owns_Submission_Key(Plr, Strike_Key)
	return Player_Owns_Submission_Key_Check(Plr, Strike_Key)
end

function funcs.Get_Unlockable_Submission_Keys(Plr)
	local Keys = {}
	if(Plr ~= nil)then
		--Takedowns
		for T_Keys, T_Data in next, Takedown_Move_Data do
			if(Player_Owns_Submission_Key_Check(Plr, T_Keys) == false)then
				table.insert(Keys, T_Keys)
			end
		end
		
		--Submissions
		for S_Keys, S_Data in next, Submission_Hold_Data do
			if(Player_Owns_Submission_Key_Check(Plr, S_Keys) == false)then
				table.insert(Keys, S_Keys)
			end
		end
	end
	
	return Keys
end

function funcs.Get_Unlockable_Strike_Keys(Plr)
	local Keys = {}
	if(Plr ~= nil)then
		for S_Key, S_Data in next, Combination_Move_Data do
			if(Player_Owns_Strike_Key_Check(Plr, S_Key) == false)then
				table.insert(Keys, S_Key)
			end
		end
	end
	
	return Keys
end

function funcs.Get_Special_Submission_Data(Key)
	--Either Takedown or Submission
	if(Takedown_Move_Data[Key] ~= nil and Takedown_Move_Data[Key]['Price'] ~= nil 
		and Takedown_Move_Data[Key]['Price'] ~= 0)then
		
		return Takedown_Move_Data[Key]
		
	elseif(Submission_Hold_Data[Key] ~= nil and Submission_Hold_Data[Key]['Price'] ~= nil
		and Submission_Hold_Data[Key]['Price'] ~= 0)then
		
		return Submission_Hold_Data[Key]
	end
	
	return nil
end

local function Player_Owns_Emote(Plr, Key)
	local Owned_Keys = Get_Player_Val(Plr, "Owned Emotes", false)
	if(Owned_Keys ~= nil)then
		local Keys = string.split(Owned_Keys, ",")
		if(Emote_Data[Key]["Price"] <= 0) then
			return true
		elseif(Keys ~= nil and #Keys > 0 and table.find(Keys, Key) ~= nil)then
			return true
		end
	end
	
	return false -- replace to False after Demo Testing
end

function funcs.Player_Owns_Emote_Key(Plr, Key)
	return Player_Owns_Emote(Plr,Key)
end

function funcs.Get_Unlockable_Emotes(Plr)
	local Keys = {}
	if(Plr ~= nil)then
		local Ignore_Keys_Due_To_Gamepass = {"I", "J", "K"}
		for E_Key, E_Data in next, Emote_Data do
			if(table.find(Ignore_Keys_Due_To_Gamepass, E_Key) == nil and 
				Player_Owns_Emote(Plr, E_Key) == false)then
				
				table.insert(Keys, E_Key)
			end
		end
	end
	
	return Keys
end

function funcs.Get_Emote_Data_From_Key(Key)
	return Emote_Data[Key]
end

function funcs.Play_Emote_Track_From_Key(Plr, Hum, Key, Is_Looped)
	if(Plr ~= nil and Hum ~= nil and Emote_Data[Key] ~= nil and Emote_Data[Key]['ID'] ~= nil and 
		Emote_Data[Key]['Name'] ~= nil and Player_Owns_Emote(Plr, Key))then
		
		local E_Data = Emote_Data[Key]
		local Track = Get_Animation_Track(Hum, E_Data['Name'], E_Data['ID'])
		if(Track ~= nil)then
			Track.Looped = Is_Looped
			Track.Priority = Enum.AnimationPriority.Action
			Track:Play()
		end
		
	end
end

function funcs.Force_Play_Emote_Track_From_Key(Hum, Key, Is_Looped)
	local E_Data = Emote_Data[Key]
	local Track = Get_Animation_Track(Hum, E_Data['Name'], E_Data['ID'])
	if(Track ~= nil)then
		Track.Looped = Is_Looped
		Track.Priority = Enum.AnimationPriority.Action
		Track:Play()
	end
end

local function Get_Takedown_Submission_Keys(Attacking_Char)
	if(Attacking_Char ~= nil and game.Players:GetPlayerFromCharacter(Attacking_Char) ~= nil)then
		local A_Plr = game.Players:GetPlayerFromCharacter(Attacking_Char)
		local Takedown_Key = Get_Player_Val(A_Plr, "Takedown Key", false)
		local Submission_Key = Get_Player_Val(A_Plr, "Submission Key", false)

		if(Takedown_Key ~= nil and Submission_Key ~= nil)then
			return Takedown_Key, Submission_Key
		end
	end

	return "A", "A"
end

function funcs.Get_Takedown_Submission_Data(Attacking_Char)
	local Takedown_Key, Submission_Key = Get_Takedown_Submission_Keys(Attacking_Char)
	return Takedown_Move_Data[Takedown_Key], Submission_Hold_Data[Submission_Key]
end

function funcs.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
	local function Get_Specific_Clinch_Track(Key)
		local Data = Cage_Clinch_Data[Key]
		if(Data ~= nil and Data['ID'] ~= nil and Data['Name'] ~= nil)then
			if(Is_Attacking == false and Data['Link Key'] ~= nil)then
				local New_Data_Key = Data['Link Key']
				local New_Data = Cage_Clinch_Data[New_Data_Key]
				if(New_Data ~= nil and New_Data['ID'] ~= nil and New_Data['Name'] ~= nil)then
					Data = New_Data
				end
			end
			
			return Get_Animation_Track(Hum, Data['Name'], Data['ID'])
		end
		
		return nil
	end
	
	return {
		['Init_Clinch'] = Get_Specific_Clinch_Track("A"),
		['Loop_Clinch'] = Get_Specific_Clinch_Track("B"),
		
		['C'] = Get_Specific_Clinch_Track("C"),
		['D'] = Get_Specific_Clinch_Track("D"),
		['E'] = Get_Specific_Clinch_Track("E")
	}
end

function funcs.Generate_Clinch_Attack_Keys()
	local Can_Use_Keys = {"C", "D", "E"}
	local Key_Data = {}
	
	for i = 1, 5 do
		local Picked_Key = Can_Use_Keys[math.random(1, #Can_Use_Keys)]
		table.insert(Key_Data, Picked_Key)
	end
	
	return Key_Data
end

function funcs.Stop_Animation_Tracks(Anim_Tracks, Ignore_List)
	for i = 1, #Anim_Tracks do
		local Ani_T = Anim_Tracks[i]
		if(Ani_T ~= nil and Ani_T.IsPlaying == true and table.find(Ignore_List, Ani_T) == nil)then
			Ani_T:Stop()
		end
	end
end

function funcs.Play_Animation_Track(Anim_Track, Should_Pause)
	local Is_Reverse = Anim_Track:GetAttribute("Reverses")
	Anim_Track:Play()
	Anim_Track:AdjustSpeed(1)
	
	if(Is_Reverse ~= nil and Is_Reverse == true)then
		wait(Anim_Track.Length * 0.99)

		Anim_Track:Play(0.100000001, 1, -1)
		Anim_Track:AdjustSpeed(-1)
	end
	
	if(Should_Pause ~= nil and Should_Pause)then
		wait(Anim_Track.Length * 0.95)
		Anim_Track:AdjustSpeed(0)
	else
		wait(Anim_Track.Length)
	end
	
end

function funcs.Play_Blocking_Track(Anim_Track)
	Anim_Track:Play()
	Anim_Track:AdjustSpeed(1)
	wait(Anim_Track.Length * 0.99)
	Anim_Track:AdjustSpeed(0)
end

local function Reset_Char_Animations(Char)
	local Hum = Char:FindFirstChild("Humanoid")
	if(Hum ~= nil)then
		local Ani_Tracks = Hum:GetPlayingAnimationTracks()
		for i = 1, #Ani_Tracks do
			if(Ani_Tracks[i] ~= nil and string.match(Ani_Tracks[i].Name, "Anim") == nil)then
				Ani_Tracks[i]:Stop()
				Ani_Tracks[i]:Destroy()
			end
		end
	end
end

function funcs.Reset_Character_Animations(Char)
	Reset_Char_Animations(Char)
end


return funcs
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX40958DD791904229A73BD9B194DAD1E5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Stats_Manager_Mod.lua</string>
						<string name="ScriptGuid">{D4E59608-5234-4B8A-85C4-F37174EF3F74}</string>
						<ProtectedString name="Source"><![CDATA[local funcs = {}

local function Get_Player_Val(Plr, Key)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		
		return PD:FindFirstChild(Key)
	end
	return nil
end

local function Add_To_Player_Data(Plr, Key, Inc)
	local Val = Get_Player_Val(Plr, Key)
	if(Val ~= nil)then
		Val.Value += Inc
		
		if(Val.Value < 0)then
			Val.Value = 0
		end
	end
end

function funcs.Add_To_Player_Stats_Data(Plr, Key, Inc)
	if(game.Players.LocalPlayer == nil and Plr ~= nil)then
		task.spawn(Add_To_Player_Data, Plr, Key, Inc)
	end
end


local function Set_To_Player_Data(Plr, Key, V)
	local Val = Get_Player_Val(Plr, Key)
	if(Val ~= nil)then
		Val.Value = V
	end
end

function funcs.Set_Player_Stats_Data(Plr, Key, Val)
	if(game.Players.LocalPlayer == nil and Plr ~= nil)then
		task.spawn(Set_To_Player_Data, Plr, Key, Val)
	end
end

function funcs.Create_Fight_Data_Structure(Char)
	if not Char then
		warn("Char param required")
	end
	local charName:string = if Char then Char.Name else "Player"
	
	local Data = {
		['ID'] = -1,
		['Name'] = `{charName}`,
		['DisplayName'] =`{charName}`,
		['Total Strikes'] = 0,
		['Strikes Landed'] = 0,
		['Dodged Strikes'] = 0,
		['Takedowns Landed'] = 0,
		['Takedowns Attempted'] = 0,
		['Submissions Finished'] = 0,
		['Submissions Attempted'] = 0,
		['Punch Knockout Wins'] = 0,
		['Leg Knockout Wins'] = 0
	}
	
	if(Char ~= nil and game.Players:GetPlayerFromCharacter(Char) ~= nil)then
		local Plr = game.Players:GetPlayerFromCharacter(Char)
		for Key, Init_V in Data do
			local P_Val = Get_Player_Val(Plr, Key)
			if not P_Val then
				continue
			end
			
			if(P_Val ~= nil)then
				Data[Key] = P_Val.Value
			end
		end
		
		Data['Name'] = "@" .. Plr.Name
		Data['DisplayName'] = Plr.DisplayName
		Data['ID'] = Plr.UserId
	end
	
	return Data
end


local function Compile_Fight_Recap_Data(Init_Data, Final_Data, Win_Data)	
	local function Get_Difference(Key)
		local F_Val = Final_Data[Key] or 0
		local I_Val = Init_Data[Key] or 0
		local Dif = F_Val - I_Val
		
		if(Dif < 0)then
			Dif = 0
		end
		
		return Dif
	end
	
	local function Count_Wins()
		local fighterName:string = Init_Data['Name']:gsub("@","")
		if(Win_Data ~= nil and #Win_Data > 0)then
			local Count = 0
			
			for _,thisName in Win_Data do
				if thisName == fighterName then
					Count += 1
				end
			end
			
			return Count
		end
		
		return 0
	end
	
	return {
		['ID'] = Init_Data['ID'],
		['Name'] = Init_Data['Name'],
		['DisplayName'] = Init_Data['DisplayName'],
		['Wins'] = Count_Wins(),
		['Total Strikes'] = Get_Difference("Strikes Landed") .. " / " .. Get_Difference("Total Strikes"),
		['Total Dodges'] = Get_Difference("Dodged Strikes"),
		['Knockouts'] = Get_Difference("Punch Knockout Wins") + Get_Difference("Leg Knockout Wins"),
		['Takedowns'] = Get_Difference("Takedowns Landed") .. " / " .. Get_Difference("Takedowns Attempted"),
		['Submissions'] = Get_Difference("Submissions Finished") .. " / " .. Get_Difference("Submissions Attempted"),
	}
end

function funcs.Create_Fight_Result_Data(Init_C1, Init_C2, Final_C1, Final_C2, Round_Result_Arr, C1_Won)
	if(C1_Won)then
		return {
			['Winner'] = Compile_Fight_Recap_Data(Init_C1, Final_C1, Round_Result_Arr),
			['Loser'] = Compile_Fight_Recap_Data(Init_C2, Final_C2, Round_Result_Arr)
		}
	else
		return {
			['Loser'] = Compile_Fight_Recap_Data(Init_C1, Final_C1, Round_Result_Arr),
			['Winner'] = Compile_Fight_Recap_Data(Init_C2, Final_C2, Round_Result_Arr)
		}
	end
end

return funcs
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXACDB2930594A435CA504695B366C31A1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Clothing_Mod.lua</string>
						<string name="ScriptGuid">{7E92577F-DC51-43F1-8B54-EEB3F4DD36ED}</string>
						<ProtectedString name="Source"><![CDATA[local funcs = {}
local Clothing_F = game.ReplicatedStorage:WaitForChild("Clothing_F")
local Shorts_F = Clothing_F:WaitForChild("Shorts_F")
local Gloves_F = Clothing_F:WaitForChild("Gloves_F")

local Gloves_Data = {
	--// Default
	['A'] = "MMA Gloves",
	--// Tape Crate
	['B'] = "Black Tape",
	['C'] = "Blue Tape",
	['D'] = "Green Tape",
	['E'] = "Red Tape",
	['F'] = "Tan Tape",
	['G'] = "White Tape",
	['H'] = "Purple Tape",
	
	--// Gloves Crate 
	['I'] = "Blue Gloves",
	['J'] = "Green Gloves",
	['K'] = "Mystic Gloves",
	['L'] = "Purple Gloves",
	
	--// Country Crate #1
	['M'] = "Argentinian Gloves",
	['N'] = "Australian Gloves",
	['O'] = "Brazilian Gloves",
	['P'] = "Canadian Gloves",
	['Q'] = "Chilean Gloves",
	['R'] = "Chinese Gloves",
	['S'] = "English Gloves",
	--// Country Crate #2
	['T'] = "French Gloves",
	['U'] = "Georgian Gloves",
	['V'] = "Italian Gloves",
	['W'] = "Jamacian Gloves",
	['X'] = "Japanese Gloves",
	['Y'] = "Mexican Gloves",
	['Z'] = "Moldovan Gloves",

	--// Country Crate #3
	['A1'] = "Nigerian Gloves",
	['B1'] = "Polish Gloves",
	['C1'] = "New Zealand Gloves",
	['D1'] = "Russian Gloves",
	['E1'] = "Spanish Gloves",
	['F1'] = "USA Gloves",
	
	['G1'] = "Orange Gloves",
	['H1'] = "White Gloves",
	
	-- Urban Gloves
	['I1'] = "Graffiti Gloves",
	['J1'] = "Iron Gloves",
	['K1'] = "Gold Gloves",
	['L1'] = "Corrupted Purple Gloves",
	['M1'] = "Corrupted Green Gloves",
	['N1'] = "Corrupted Black Gloves",
	
	-- Fury Crate 1
	['O1'] = "Plastic Green Tape",
	['P1'] = "Plastic Blue Tape",
	['Q1'] = "Plastic Pink Tape",
	['R1'] = "Frozen Chain Tape",
	['S1'] = "Molten Chain Tape",
	['T1'] = "Carbon Chain Tape",

	-- Underground Crate 1
	['U1'] = "Plastic Green Gloves",
	['V1'] = "Plastic Blue Gloves",
	['W1'] = "Plastic Pink Gloves",
	['X1'] = "Blue Flame Gloves",
	['Y1'] = "Lava Gloves",
	['Z1'] = "Carbon Gloves",
	

	['A2'] = "Chromatic Green Gloves",
	['B2'] = "Chromatic Blue Gloves",
	['C2'] = "Chromatic Pink Gloves",
	
	['D2'] = "Chromatic Green Tape",
	['E2'] = "Chromatic Blue Tape",
	['F2'] = "Chromatic Pink Tape",

	['G2'] = "Fury Gloves",
}

local function Get_Data_Keys()
	local Keys = {}
	for K, Name in next, Gloves_Data do
		table.insert(Keys, K)
	end
	
	return table.concat(Keys, ",")
end

--print(Get_Data_Keys())


local Shorts_Data = {
	['A'] = "MMA Shorts",
	['B'] = "Karate Shorts",
	['C'] = "Denim",
	['D'] = "Dragon Gold",
	['E'] = "Black Champs",
	--// Country Crate #1
	['F'] = "Argentinian Shorts",
	['G'] = "Australian Shorts",
	['H'] = "Brazilian Shorts",
	['I'] = "Canadian Shorts",
	['J'] = "Chilean Shorts",
	['K'] = "Chinese Shorts",
	['L'] = "England Shorts",
	--// Country Crate #2
	['M'] = "French Shorts",
	['N'] = "Georgian Shorts",
	['O'] = "Italian Shorts",
	['P'] = "Jamaican Shorts",
	['Q'] = "Japanese Shorts",
	['R'] = "Mexican Shorts",
	['S'] = "Moldovan Shorts",
	--// Country Crate #3
	['T'] = "Mystic Shorts",
	['U'] = "New Zealand Shorts",
	['V'] = "Nigerian Shorts",
	['W'] = "Polish Shorts",
	['X'] = "Russian Shorts",
	['Y'] = "Spanish Shorts",
	['Z'] = "USA Shorts",
}

function funcs.Get_All_Gloves_Data()
	return Gloves_Data
end
function funcs.Get_All_Shorts_Data()
	return Shorts_Data
end

local function Get_Player_Val(Plr, Key)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		return PD:FindFirstChild(Key)
	end
	return nil
end

function funcs.Get_Gloves_Data(Key)
	if(Key == nil or Gloves_Data[Key] == nil)then
		return Gloves_Data
	else
		return Gloves_Data[Key]
	end
end

function funcs.Get_Shorts_Data(Key)
	if(Key == nil or Shorts_Data[Key] == nil)then
		return Shorts_Data
	else
		return Shorts_Data[Key]
	end
end

function funcs.Player_Owns_Gloves_Key(Plr, Key)
	local Owned_Gloves_V = Get_Player_Val(Plr, "Owned Gloves")
	if(Owned_Gloves_V ~= nil)then
		local Owned_Gloves_Keys = string.split(Owned_Gloves_V.Value, ",")
		if(Owned_Gloves_Keys ~= nil and table.find(Owned_Gloves_Keys, Key) ~= nil)then
			return true
		end
	end

	return false
end

function funcs.Player_Owns_Shorts_Key(Plr, Key)
	local Owned_Shorts_V = Get_Player_Val(Plr, "Owned Shorts")
	if(Owned_Shorts_V ~= nil)then
		local Owned_Shorts_Keys = string.split(Owned_Shorts_V.Value, ",")
		if(Owned_Shorts_Keys ~= nil and table.find(Owned_Shorts_Keys, Key) ~= nil)then
			return true
		end
	end

	return false
end

function funcs.Give_Player_Gloves(Plr, Key)
	if Gloves_Data[Key] == nil then
		return false
	end
	if funcs.Player_Owns_Gloves_Key(Plr, Key) == true then
		return false
	end
	
	local Owned_Gloves_V = Get_Player_Val(Plr, "Owned Gloves")
	if(Owned_Gloves_V ~= nil)then
		local Keys = string.split(Owned_Gloves_V.Value, ",")
		Keys[#Keys + 1] = Key
		Owned_Gloves_V.Value = table.concat(Keys, ",")
	end
end

function funcs.Give_Player_Shorts(Plr, Key)
	if Shorts_Data[Key] == nil then
		return false
	end
	if funcs.Player_Owns_Shorts_Key(Plr, Key) == true then
		return false
	end

	local Owned_Shorts_V = Get_Player_Val(Plr, "Owned Shorts")
	if(Owned_Shorts_V ~= nil)then
		local Keys = string.split(Owned_Shorts_V.Value, ",")
		Keys[#Keys + 1] = Key
		Owned_Shorts_V.Value = table.concat(Keys, ",")
	end
end

function funcs.Get_Player_Current_Shorts(Plr)
	local Current_Shorts_V = Get_Player_Val(Plr, "Current Shorts")
	if(Current_Shorts_V ~= nil)then
		local Key = Current_Shorts_V.Value
		if(Key ~= nil and Shorts_Data[Key] ~= nil and Shorts_F:FindFirstChild(Shorts_Data[Key]) ~= nil)then
			return Key, Shorts_F:FindFirstChild(Shorts_Data[Key])
		end
	end
	
	return "A", Shorts_F:FindFirstChild(Shorts_Data['A'])
end

function funcs.Get_Player_Current_Gloves(Plr)
	local Current_Gloves_V = Get_Player_Val(Plr, "Current Gloves")
	if(Current_Gloves_V ~= nil)then
		local Key = Current_Gloves_V.Value
		if(Key ~= nil and Gloves_Data[Key] ~= nil and Gloves_F:FindFirstChild(Gloves_Data[Key]) ~= nil)then
			return Key, Gloves_F:FindFirstChild(Gloves_Data[Key])
		end
	end

	return "A", Gloves_F:FindFirstChild(Gloves_Data['A'])
end

return funcs
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD6128884138A4F42B9EF4211C1B49A3C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Country_Mod.lua</string>
						<string name="ScriptGuid">{F6A973CC-CB3A-47D4-850F-6DBDB42E787C}</string>
						<ProtectedString name="Source"><![CDATA[local funcs = {}

local Country_Data = {
	--['USA'] = "rbxassetid://14010864446",
	--['Canada'] = "rbxassetid://12503880000",
	--['Mexico'] = "rbxassetid://116338470092166",
	--['France'] = "rbxassetid://12690378646",
	--['Brazil'] = "rbxassetid://17220320205",
	--['Japan'] = "rbxassetid://17041741932",
	--['Poland'] = "rbxassetid://7412759429",
	--['New Zealand'] = "rbxassetid://17357309517",
	--['Moldova'] = "rbxassetid://12895193469",
	--['Georgia'] = "rbxassetid://128636032248868",
	--['Russia'] = "rbxassetid://6514161028",
	--['China'] = "rbxassetid://9110900644",
	--['UK'] = "rbxassetid://119841021475023",
	--['Australia'] = "rbxassetid://18386599365",
	--['Nigeria'] = "rbxassetid://11858119964",
	--['Jamaica'] = "rbxassetid://128621555589394",
	--['Italy'] = "rbxassetid://10333104535",
	--['Spain'] = "rbxassetid://6600099878",
	--['Argentina'] = "rbxassetid://119836429792081",
	--['Chile'] = "rbxassetid://17366784440",
	--['Portugal'] = "rbxassetid://13721042005",
	--['Ireland'] = "rbxassetid://12511955654"
}
local Country_Number_Map = {}
for i, v in pairs(script.Flags:GetChildren()) do
	Country_Data[v.Name] = v.Texture
	Country_Number_Map[v.Name] = tonumber(v:GetAttribute("Map_Index"))
	if v:GetAttribute("Map_Index") == nil then
		error("No Map_Index property assigned")
	end
end

local function Get_Flag_ID(Country_Key)
	local Img = Country_Data[Country_Key]
	if(Img ~= nil)then
		return Img
	end
	
	return Country_Data['United States']
end

local function Get_Player_Val(Plr, Key)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		return PD:FindFirstChild(Key)
	end
	
	return nil
end

function funcs.Get_Player_Country_Data(Plr)
	local Flag_Key = Get_Player_Val(Plr, "Country")
	if(Flag_Key ~= nil and Country_Data[Flag_Key.Value] ~= nil)then
		local Key = Flag_Key.Value
		return Key, Country_Data[Key]
	end
	
	return "United States", Country_Data['United States']
end

function funcs.Get_Flag_ID(Country_Key)
	if(Country_Data[Country_Key] ~= nil) then
		return Country_Data[Country_Key]
	end
	return Country_Data['United States']
end

function funcs.Get_Country_Data()
	return Country_Data
end

function funcs.Get_Country_Number_From_Index(index)
	return Country_Number_Map[index]
end

function funcs.Get_Country_Index_From_Number(number)
	for i, v in pairs(Country_Number_Map) do
		if v == number then
			return i
		end
	end
end

return funcs
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1F85315BDFB44BE5B81C91C9CCD8945D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Crate_Mod.lua</string>
						<string name="ScriptGuid">{C281D538-9BF3-42B2-806C-C450E2A589E2}</string>
						<ProtectedString name="Source"><![CDATA[local funcs = {}



local Crate_Data = {
	--// rarity: Bronze = 7/10, Silver = 3/20, Gold = 1/10, Diamond = 1/100, Platinum = 1,1000
	['Crate 6'] = { --// Crates Index
		['Name'] = "Tape Crate", --// Crates Name
		['RewardType'] = "Gloves",
		
		['PriceCoins'] = 400, -- Price in cash
		['PriceGems'] = 20, -- Price in gems
		["Color_BG"] = Color3.fromRGB(255,255,255), -- background color for the crate display UI 
		['Items'] = { --// Only 8 items Per Crate Max
			["A"] = {
				["Name"] = "Black Tape", --// Item name same as listed in Clothing_Mod
				["Rarity"] = 7/10, --// Item Rarity
				
				["ItemKey"] = "B"
			},
			["B"] = {
				["Name"] = "Blue Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "C"
			},
			["C"] = {
				["Name"] = "Green Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "D"
			},
			["D"] = {
				["Name"] = "Red Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "E"
			},
			["E"] = {
				["Name"] = "Tan Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "F"
			},
			["F"] = {
				["Name"] = "White Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "G"
			},
			["G"] = {
				["Name"] = "Purple Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "H"
			},
		}
	},
	
	['Crate 1'] = {
		['Name'] = "Basic Gloves Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 400, 
		['PriceGems'] = 20,
		["Color_BG"] = Color3.fromRGB(255,255,255), 
		['Items'] = {
			["A"] = {
				["Name"] = "Blue Gloves", 
				["Rarity"] = 7/10,

				["ItemKey"] = "I"
			},
			["B"] = {
				["Name"] = "Green Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "J"
			},
			["C"] = {
				["Name"] = "White Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "H1"
			},
			["D"] = {
				["Name"] = "Purple Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "L"
			},
			["E"] = {
				["Name"] = "Orange Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "G1"
			},
			["F"] = {
				["Name"] = "Chromatic Green Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "A2"
			},
			["G"] = {
				["Name"] = "Chromatic Blue Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "B2"
			},
			["H"] = {
				["Name"] = "Chromatic Pink Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "C2"
			},
		}
	},
	
	['Crate 2'] = {
		['Name'] = "Basic Shorts Crate",
		['RewardType'] = "Shorts",

		['PriceCoins'] = 400, 
		['PriceGems'] = 20,
		["Color_BG"] = Color3.fromRGB(255,255,255), 
		['Items'] = {
			["A"] = {
				["Name"] = "Karate Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "B"
			},
			["B"] = {
				["Name"] = "Denim",
				["Rarity"] = 0.15,

				["ItemKey"] = "C"
			},
			["C"] = {
				["Name"] = "Dragon Gold",
				["Rarity"] = 1/100,

				["ItemKey"] = "D"
			},
			["D"] = {
				["Name"] = "Black Champs",
				["Rarity"] = 7/10,

				["ItemKey"] = "E"
			},
			["E"] = {
				["Name"] = "Mystic Shorts",
				["Rarity"] = 1/10,

				["ItemKey"] = "T"
			},
		}
	},
	
	['Crate 7'] = { -- // COUNTRY GLOVES #1
		['Name'] = "Country Gloves 1",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 400, 
		['PriceGems'] = 20,
		["Color_BG"] = Color3.fromRGB(255, 255, 255), 
		['Items'] = {
			["A"] = {
				["Name"] = "Argentinian Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "M"
			},
			["B"] = {
				["Name"] = "Australian Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "N"
			},
			["C"] = {
				["Name"] = "Brazilian Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "O"
			},
			["D"] = {
				["Name"] = "Canadian Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "P"
			},
			["E"] = {
				["Name"] = "Chilean Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "Q"
			},
			["F"] = {
				["Name"] = "Chinese Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "R"
			},
			["G"] = {
				["Name"] = "English Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "S"
			},
		}
	},
	
	['Crate 8'] = { -- // COUNTRY GLOVES #2
		['Name'] = "Country Gloves 2",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 400, 
		['PriceGems'] = 20,
		["Color_BG"] = Color3.fromRGB(255, 255, 255), 
		['Items'] = {
			["A"] = {
				["Name"] = "French Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "T"
			},
			["B"] = {
				["Name"] = "Georgian Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "U"
			},
			["C"] = {
				["Name"] = "Italian Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "V"
			},
			["D"] = {
				["Name"] = "Jamacian Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "W"
			},
			["E"] = {
				["Name"] = "Japanese Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "X"
			},
			["F"] = {
				["Name"] = "Mexican Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "Y"
			},
			["G"] = {
				["Name"] = "Moldovan Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "Z"
			},
		}
	},
	
	['Crate 9'] = { -- // COUNTRY GLOVES #3
		['Name'] = "Country Gloves 3",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 400, 
		['PriceGems'] = 20,
		["Color_BG"] = Color3.fromRGB(255, 255, 255), 
		['Items'] = {
			["A"] = {
				["Name"] = "Nigerian Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "A1"
			},
			["B"] = {
				["Name"] = "Polish Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "B1"
			},
			["C"] = {
				["Name"] = "New Zealand Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "C1"
			},
			["D"] = {
				["Name"] = "Russian Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "D1"
			},
			["E"] = {
				["Name"] = "Spanish Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "E1"
			},
			["F"] = {
				["Name"] = "USA Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "F1"
			},
		}
	},

	['Crate 4'] = {
		['Name'] = "Urban Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 800, 
		['PriceGems'] = 40,
		["Color_BG"] = Color3.fromRGB(255, 255, 255), 
		['Items'] = {
			["A"] = {
				["Name"] = "Graffiti Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "I1"
			},
			["B"] = {
				["Name"] = "Iron Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "J1"
			},
			["C"] = {
				["Name"] = "Gold Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "K1"
			},
			["D"] = {
				["Name"] = "Corrupted Purple Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "L1"
			},
			["E"] = {
				["Name"] = "Corrupted Green Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "M1"
			},
			["F"] = {
				["Name"] = "Corrupted Black Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "N1"
			},
		}
	},

	['Crate 5'] = {
		['Name'] = "Fury Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 800, 
		['PriceGems'] = 40,
		["Color_BG"] = Color3.fromRGB(255, 255, 255), 
		['Items'] = {
			["A"] = {
				["Name"] = "Plastic Green Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "O1"
			},
			["B"] = {
				["Name"] = "Plastic Blue Tape",
				["Rarity"] = 7/10,

				["ItemKey"] = "P1"
			},
			["C"] = {
				["Name"] = "Plastic Pink Tape",
				["Rarity"] = 1/10,

				["ItemKey"] = "Q1"
			},
			["D"] = {
				["Name"] = "Frozen Chain Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "R1"
			},
			["E"] = {
				["Name"] = "Molten Chain Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "S1"
			},
			["F"] = {
				["Name"] = "Carbon Chain Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "T1"
			},
			["H"] = {
				["Name"] = "Chromatic Pink Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "F2"
			},
		}
	},

	['Crate 3'] = {
		['Name'] = "Underground Crate",
		['RewardType'] = "Gloves",

		['PriceCoins'] = 1000, 
		['PriceGems'] = 60,
		["Color_BG"] = Color3.fromRGB(255, 255, 255), 
		['Items'] = {
			["A"] = {
				["Name"] = "Plastic Green Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "U1"
			},
			["B"] = {
				["Name"] = "Plastic Blue Gloves",
				["Rarity"] = 7/10,

				["ItemKey"] = "V1"
			},
			["C"] = {
				["Name"] = "Plastic Pink Gloves",
				["Rarity"] = 1/10,

				["ItemKey"] = "W1"
			},
			["D"] = {
				["Name"] = "Blue Flame Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "X1"
			},
			["E"] = {
				["Name"] = "Lava Gloves",
				["Rarity"] = 1/100,

				["ItemKey"] = "Y1"
			},
			["F"] = {
				["Name"] = "Carbon Gloves",
				["Rarity"] = 1/10000,

				["ItemKey"] = "Z1"
			},
			["G"] = {
				["Name"] = "Chromatic Green Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "A2"
			},
			["H"] = {
				["Name"] = "Chromatic Blue Tape",
				["Rarity"] = 1/100,

				["ItemKey"] = "B2"
			},
		}
	},
	
	['Crate 10'] = { -- // COUNTRY SHORTS #1
		['Name'] = "Country Shorts 1",
		['RewardType'] = "Shorts",

		['PriceCoins'] = 400, 
		['PriceGems'] = 20,
		["Color_BG"] = Color3.fromRGB(255,255,255), 
		['Items'] = {
			["A"] = {
				["Name"] = "Argentinian Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "F"
			},
			["B"] = {
				["Name"] = "Australian Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "G"
			},
			["C"] = {
				["Name"] = "Brazilian Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "H"
			},
			["D"] = {
				["Name"] = "Canadian Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "I"
			},
			["E"] = {
				["Name"] = "Chilean Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "J"
			},
			["F"] = {
				["Name"] = "Chinese Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "K"
			},
			["G"] = {
				["Name"] = "England Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "L"
			},
		}
	},
	['Crate 11'] = { -- // COUNTRY SHORTS #2
		['Name'] = "Country Shorts 2",
		['RewardType'] = "Shorts",

		['PriceCoins'] = 400, 
		['PriceGems'] = 20,
		["Color_BG"] = Color3.fromRGB(255,255,255), 
		['Items'] = {
			["A"] = {
				["Name"] = "French Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "M"
			},
			["B"] = {
				["Name"] = "Georgian Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "N"
			},
			["C"] = {
				["Name"] = "Italian Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "O"
			},
			["D"] = {
				["Name"] = "Jamaican Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "P"
			},
			["E"] = {
				["Name"] = "Japanese Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "Q"
			},
			["F"] = {
				["Name"] = "Mexican Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "R"
			},
			["G"] = {
				["Name"] = "Moldovan Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "S"
			},
		}
	},
	['Crate 12'] = { -- // COUNTRY SHORTS #3
		['Name'] = "Country Shorts 3",
		['RewardType'] = "Shorts",

		['PriceCoins'] = 400, 
		['PriceGems'] = 20,
		["Color_BG"] = Color3.fromRGB(255,255,255), 
		['Items'] = {
			["A"] = {
				["Name"] = "New Zealand Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "U"
			},
			["B"] = {
				["Name"] = "Nigerian Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "V"
			},
			["C"] = {
				["Name"] = "Polish Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "W"
			},
			["D"] = {
				["Name"] = "Russian Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "X"
			},
			["E"] = {
				["Name"] = "Spanish Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "Y"
			},
			["F"] = {
				["Name"] = "USA Shorts",
				["Rarity"] = 7/10,

				["ItemKey"] = "Z"
			},
		}
	},

}

local function Get_Player_Val(Plr, Key, Get_Object)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		local V = PD:FindFirstChild(Key)
		if(Get_Object)then
			return V
		else
			return V.Value
		end
		
	end
	
	return nil
end

function funcs.GetCrates()
	return Crate_Data
end

function funcs.Get_Crate_Data_Arr()
	local Arr = {}
	
	for Crate_Key, Data in next, Crate_Data do
		local D = Data
		local Index_Str = string.gsub(Crate_Key, "Crate ", "")
		D['Index'] = tonumber(Index_Str)
		
		table.insert(Arr, D)
	end
	
	table.sort(Arr, function(A, B)
		return A['Index'] < B['Index']
	end)
	
	return Arr
end

return funcs
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8E0C2CE417EE4D279EA777B0D9704E7F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Rewards_Mod.lua</string>
						<string name="ScriptGuid">{BABD8B6D-57EE-4D8D-A467-3A518EB3CECC}</string>
						<ProtectedString name="Source"><![CDATA[local funcs = {}

local Daily_Rewards_Data = {
	[1] = {
		['Name'] = "+100 Cash!",
		['Type'] = "Cash",
		['Amount'] = 100
	},
	
	[2] = {
		['Name'] = "+10 Gems!",
		['Type'] = "Gems",
		['Amount'] = 10
	},
	
	[3] = {
		['Name'] = "FREE Crate!",
		['Type'] = "Crate",
		['Amount'] = "Crate 1"
	},
	
	[4] = {
		['Name'] = "+300 Cash!",
		['Type'] = "Cash",
		['Amount'] = 300
	},
	
	[5] = {
		['Name'] = "+25 Gems!",
		['Type'] = "Gems",
		['Amount'] = 25
	},
	
	[6] = {
		['Name'] = "+450 Cash!",
		['Type'] = "Cash",
		['Amount'] = 450
	},
	
	[7] = {
		['Name'] = "VIP!",
		['Type'] = "Gamepass",
		['Amount'] = "A"
	},
	
	
	
}

local function Get_Player_Val(Plr, Val_Name)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil)then
		local Val = PD:FindFirstChild(Val_Name)
		if(Val ~= nil)then
			return Val.Value
		end
	end	

	return nil
end

function funcs.Get_Specific_Daily_Reward(Key)
	return Daily_Rewards_Data[Key]
end

function funcs.Get_Player_Retention_Streak(Plr)
	local Streak = Get_Player_Val(Plr, "Retention Streak")
	if(Streak ~= nil)then
		return Streak
	end
	return 0
end

function funcs.Get_Claimed_Daily_Player_Rewards(Plr)
	local Keys_Str = Get_Player_Val(Plr, "Redeemed Rewards")
	if(Keys_Str ~= nil)then
		return string.split(Keys_Str, ",")
	end
	return {}
end

function funcs.Get_Total_Reward_Amount()
	local Data_Arr = {}
	for Key, Reward_Data in next, Daily_Rewards_Data do
		table.insert(Data_Arr, Reward_Data)
	end
	
	return #Data_Arr
end

return funcs
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX54F04A557CA64ACCBA9F0242DCA0ACD3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Skin_Tone_Mod.lua</string>
						<string name="ScriptGuid">{4D021108-6610-4934-A492-CC783A6C29CC}</string>
						<ProtectedString name="Source"><![CDATA[local funcs = {}

local Skin_Tone_Data = {
	['Dark taupe'] = Color3.fromRGB(90, 76, 66),
	['Brown'] = Color3.fromRGB(124, 92, 70),
	['Linen'] = Color3.fromRGB(175, 148, 131),
	['Nougat'] = Color3.fromRGB(204, 142, 105),
	['Light orange'] = Color3.fromRGB(234, 184, 146),
	['Medium brown'] = Color3.fromRGB(86, 66, 54),
	['Reddish brown'] = Color3.fromRGB(105, 64, 40),
	['Cork'] = Color3.fromRGB(188, 155, 93),
	['Burlap'] = Color3.fromRGB(199, 172, 120),
	['Brick yellow'] = Color3.fromRGB(215, 197, 154),
}

function funcs.Get_Skin_Tone_Data()
	return Skin_Tone_Data
end

function funcs.Configure_Skin_Tone(Col)
	local R, G, B = Col.R, Col.G, Col.B
	R = math.clamp(R, 0, 255)
	G = math.clamp(G, 0, 255)
	B = math.clamp(B, 0, 255)
	
	return R .. "," .. G .. "," .. B
end

function funcs.Configure_To_Color(Col_Str)
	local Str_Data = string.split(Col_Str, ",")
	if(Str_Data ~= nil and #Str_Data >= 3)then
		local R = tonumber(Str_Data[1])
		local G = tonumber(Str_Data[2])
		local B = tonumber(Str_Data[3])
		
		R = math.clamp(R, 0, 255)
		G = math.clamp(G, 0, 255)
		B = math.clamp(B, 0, 255)
		
		return Color3.fromRGB(R, G, B)
	end
	
	return Color3.fromRGB(255, 255, 255)
end

return funcs
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXACEC2C641A074E6989FB9FB2CAB6C9C6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Skill_Tree_Mod.lua</string>
						<string name="ScriptGuid">{F9705138-2724-40F4-B2AF-7EDA7B80D252}</string>
						<ProtectedString name="Source"><![CDATA[local funcs = {}

--[[
	- Cash, Gems, Cash, Gems, Cash Pack, Gems Pack, Crate, Cash Pack, Crate, Gems Pack
	- Gems, Cash, Crate, Cash Pack, Ranked Move, Gems Pack, Ranked Move, Crate 
	
	* General Wins
	- 1 Win | 5 Wins | 10 Wins | 25 Wins | 50 Wins | 100 Wins | 250 Wins | 500 Wins | 1,000 Wins | 2,500 Wins
	
	* Ranked Wins
	- 1 Win | 3 Wins | 5 Wins | 10 Wins | 15 Wins | 25 Wins | 35 Wins | 50 Wins | 75 Wins | 100 Wins
	
	* Punch Knockouts
	- 5 KO's | 10 KO's | 15 KO's | 25 KO's | 50 KO's | 75 KO's | 125 KO's | 250 KO's 
	
	* Leg Knockouts
	- 5 KO's | 10 KO's | 15 KO's | 25 KO's | 50 KO's | 75 KO's | 125 KO's | 250 KO's 
	
	* Submission KOs
	- 1 KO's | 3 KO's | 5 KO's | 10 KO's | 15 KO's | 25 KO's | 50 KO's | 100 KO's
]]--

local Key_Index = {"Total Wins", "Ranked Wins", "Punch Knockout Wins", "Leg Knockout Wins", "Submissions Wins", "Total Playtime"}
local Rewards_Data = {
	['Wins'] = {
		{
			['Reward'] = "Cash",
			['Amount'] = 25,
			['Text'] = " Successfully Earned +25 Cash!"
		},

		{
			['Reward'] = "Gems",
			['Amount'] = 10,
			['Text'] = " Successfully Earned +10 Gems!"
		},

		{
			['Reward'] = "Cash",
			['Amount'] = 100,
			['Text'] = " Successfully Earned +100 Cash!"
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "I",
			['Text'] = " Successfully Earned an Exclusive Takedown & Submission Combo!" -- Replace with Strike
		},

		{
			['Reward'] = "Cash Pack",
			['Amount'] = "A",
			['Text'] = " Successfully Earned a Tiny Cash Pack!"
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "",
			['Text'] = " Successfully Earned an Exclusive Takedown & Submission Combo!" -- Replace with Submission
		},

		{
			['Reward'] = "Crate",
			['Amount'] = "Crate 1",
			['Text'] = " Successfully Earned a FREE Crate!"
		},

		{
			['Reward'] = "Cash Pack",
			['Amount'] = "C",
			['Text'] = " Successfully Earned a Large Cash Pack!"
		},

		{
			['Reward'] = "Crate",
			['Amount'] = "Crate 2",
			['Text'] = " Successfully Earned a FREE Crate!" 
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "J",
			['Text'] = " Successfully Earned an Exclusive Takedown & Submission Combo!" -- Replace with Strike
		},
	},

	['Knockouts'] = {
		{
			['Reward'] = "Gems",
			['Amount'] = 5,
			['Text'] = " Successfully Earned +5 Gems!"
		},

		{
			['Reward'] = "Cash",
			['Amount'] = 25,
			['Text'] = " Successfully Earned +25 Cash!"
		},

		{
			['Reward'] = "Crate",
			['Amount'] = "Crate 1",
			['Text'] = " Successfully Earned a FREE Crate!"
		},

		{
			['Reward'] = "Cash Pack",
			['Amount'] = "B",
			['Text'] = " Successfully Earned a Small Cash Pack!"
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "E",
			['Text'] = " Successfully Earned an Exclusive Takedown & Submission Combo!"
		},

		{
			['Reward'] = "Gems",
			['Amount'] = 50,
			['Text'] = " Successfully Earned +50 Gems!"
		},

		{
			['Reward'] = "Ranked Move",
			['Amount'] = "D",
			['Text'] = " Successfully Earned an Exclusive Takedown & Submission Combo!"
		},

		{
			['Reward'] = "Crate",
			['Amount'] = "Crate 2",
			['Text'] = " Successfully Earned a FREE Crate!"
		},
	}
}

local Skill_Tree_Data = {
	['Total Wins'] = {1, 5, 10, 25, 50, 100, 250, 500, 1000, 2500},
	['Ranked Wins'] = {1, 3, 5, 10, 15, 25, 35, 50, 75, 100},
	['Punch Knockout Wins'] = {5, 10, 15, 25, 50, 75, 125, 250},
	['Leg Knockout Wins'] = {5, 10, 15, 25, 50, 75, 125, 250},
	['Submissions Wins'] = {1, 3, 5, 10, 15, 25, 50, 100},
	['Total Playtime'] = {3600, 7200, 18000, 36000, 180000, 360000, 1800000, 3600000}
}


local function Get_Player_Val(Plr, Key)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		return PD:FindFirstChild(Key)
	end

	return nil
end

local function Compile_Skill_Tree_Plr_Data(Plr)
	local Skill_Tree_V = Get_Player_Val(Plr, "Redeemed Skill Tree")
	local Owned_Keys = {
		['Total Wins'] = {},
		['Ranked Wins'] = {},
		['Punch Knockout Wins'] = {},
		['Leg Knockout Wins'] = {},
		['Submissions Wins'] = {},
		['Total Playtime'] = {}
	}

	if(Skill_Tree_V ~= nil)then
		local Data_Str = string.split(Skill_Tree_V.Value, ",")

		local function Process_String_Data(Str)
			local Core_Data = string.split(Str, "|")
			if(Core_Data ~= nil and #Core_Data >= 2)then
				local K_Index = tonumber(Core_Data[1])
				local Key = Key_Index[K_Index]
				local Index = tonumber(Core_Data[2])

				table.insert(Owned_Keys[Key], Index)
			end
		end

		for i = 1, #Data_Str do
			local Data = Data_Str[i]
			if(Data ~= nil)then
				Process_String_Data(Data)
			end
		end
	end

	return Owned_Keys
end


function funcs.Get_All_Skill_Tree_Data()
	return Skill_Tree_Data, Rewards_Data
end

function funcs.Compile_Skill_Tree_Data(Plr)
	return Compile_Skill_Tree_Plr_Data(Plr)
end

function funcs.Get_Reward_Data_Arr(Tree_Key)
	if(Skill_Tree_Data[Tree_Key] ~= nil and #Skill_Tree_Data[Tree_Key] == 8)then
		return Rewards_Data['Knockouts']
	else
		return Rewards_Data['Wins']
	end
end

function funcs.Verify_Tree_Index(Key, Tree_Index)
	if(Skill_Tree_Data[Key] ~= nil and Skill_Tree_Data[Key][Tree_Index] ~= nil)then
		return true
	end
	return false
end

function funcs.Has_Player_Can_Redeemed_Reward(Plr, Key, Tree_Index)
	local Owned_Rewards_Data = Compile_Skill_Tree_Plr_Data(Plr)
	if(Plr ~= nil and Owned_Rewards_Data ~= nil and 
		(#Owned_Rewards_Data <= 0 or table.find(Owned_Rewards_Data, Tree_Index) == nil))then

		return true
	end
	return false
end

function funcs.Player_Has_Met_Requirement(Plr, Key, Tree_Index)
	local Data_Val = Get_Player_Val(Plr, Key)
	if(Plr ~= nil and Data_Val ~= nil and Skill_Tree_Data[Key] ~= nil and Skill_Tree_Data[Key][Tree_Index] ~= nil)then
		local Max_Val = tonumber(Skill_Tree_Data[Key][Tree_Index])
		if(Data_Val.Value >= Max_Val)then
			return true
		end
	end

	return false
end

function funcs.Get_Redeem_Data_Entry(Key, Tree_Index)
	local Key_Index_Val = table.find(Key_Index, Key) or 1
	return Key_Index_Val .. "|" .. Tree_Index
end

function funcs.Get_Reward_Data(Key, Tree_Index)
	if(Key == "Total Wins" or Key == "Ranked Wins")then
		return Rewards_Data["Wins"][Tree_Index]
	else
		return Rewards_Data["Knockouts"][Tree_Index]
	end
end

return funcs
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX13D410CA423044FBA2F8684A67901A15">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Session_Reward_Mod.lua</string>
						<string name="ScriptGuid">{6B562004-B6B6-4EAC-8A55-CE105DBA1785}</string>
						<ProtectedString name="Source"><![CDATA[-- TODO merge with Rewards_Mod

local UNIT = 60 -- 1min

local M = {}

M.SeasonId = 1
M.Thresholds = {
	-- TEST ONLY REMOVE FOR  PRODUCTION
	--{ t = 30, reward = { type="Coins", amount=1000, label="TEST after 30 seconds: +1000 Cash" } },
	--{ t = 60, reward = { type="Gems", amount=1000, label="TEST after 60 seconds: +1000 Gems" } },
	{ t = 10*UNIT, reward = { type="Coins", amount=200, label="Stay 10 minutes and earn +200 " } },
	{ t = 15*UNIT, reward = { type="Coins", amount=350, label="Stay 15 minutes and earn +350 " } },
	{ t = 21*UNIT, reward = { type="Gems", amount=20, label="Stay 21 minutes and earn +20 " } },
	{ t = 30*UNIT, reward = { type="Gems", amount=40, label="Stay 30 minutes and earn +40 " } },
}

function M.GetMaxClaims()
	return #M.Thresholds
end

function M.GetReward(index)
	if index >= 1 and index <= #M.Thresholds then
		return M.Thresholds[index].reward
	end
	return nil
end

return M

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6E5959E1D1054D16A70F9C1224B389F5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Offers_Config.lua</string>
						<string name="ScriptGuid">{C8945F6A-08D3-4934-B0F4-1A54CC7A7B4E}</string>
						<ProtectedString name="Source"><![CDATA[local RS = game:GetService("ReplicatedStorage")
local Data_Mods_F      = RS:WaitForChild("Data_Mods_F")
local Monetization_Mod = require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Item_Price_Icon = require(script:WaitForChild("GetPrice_Icon"))
local UGCOffers_Config = require(script.UGCItemHelper)
local MPS = game:GetService("MarketplaceService")
local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))

local DSS = game:GetService("DataStoreService")
local OfferStore = DSS:GetDataStore("PlayerOfferState")

local Offers_Config = {}
local cointLimit=5000                          -- Not valide now
-- one schema for all offers
Offers_Config.UGCItemsConfig=UGCOffers_Config.UGCItemsConfig


Offers_Config.Offers = {
	-- DevProduct: 6k Cash (consumable  always eligible)
	{
		Key        = "D",                      -- Monetization_Mod.Dev_Data key
		Kind       = "DevProduct",
		Title      = "Special Cash Bundle",
		Icon       = "rbxassetid://15365698744",
		Amount     = "6000",
		OldPrice   = 799,
		NewPrice   = 399,
		IsOfferActive=false,
		EndsAt     = os.time({year=2025, month=9, day=17, hour=23, min=59, sec=59}),
		Priority   = 100,                      -- higher = more likely to be chosen
		-- Consumable = true,                  -- optional override; inferred if omitted
	},

	-- Gamepass: VIP (non-consumable; hide if owned)
	{
		Key        = "A",                      -- Monetization_Mod.GP_Data key
		Kind       = "Gamepass",
		Title      = "VIP Access",
		Icon       = "rbxassetid://116997996978018",
		OldPrice   = 99,
		NewPrice   = 49,
		IsOfferActive=true,
		EndsAt     = os.time({year=2025, month=9, day=28, hour=23, min=59, sec=59}),
		Priority   = 100,
		HideIfOwned = true,                    -- shorthand for Ownership.Kind="Gamepass"
	},
	-- x2 ELO!
	{
		Key         = "B",   -- Monetization_Mod.Gamepass_Data key
		Kind        = "Gamepass",
		Title       = "x2 ELO!",
		Icon        = "rbxassetid://140028327825184",
		OldPrice    = 500,
		NewPrice    = 249, -- discounted
		IsOfferActive = true,
		EndsAt      = os.time({year=2025, month=9, day=30, hour=23, min=59, sec=59}),
		Priority    = 98,
		HideIfOwned = true,
	},

	-- x2 Cash!
	{
		Key         = "C",
		Kind        = "Gamepass",
		Title       = "x2 Cash!",
		Icon        = "rbxassetid://111390267501817",
		OldPrice    = 250,
		NewPrice    = 149,
		IsOfferActive = true,
		EndsAt      = os.time({year=2025, month=9, day=30, hour=23, min=59, sec=59}),
		Priority    = 97,
		HideIfOwned = true,
	},

	-- Exclusive Emotes!
	{
		Key         = "D",
		Kind        = "Gamepass",
		Title       = "Exclusive Emotes!",
		Icon        = "rbxassetid://140138999956473",
		OldPrice    = 300,
		NewPrice    = 199,
		IsOfferActive = true,
		EndsAt      = os.time({year=2025, month=9, day=30, hour=23, min=59, sec=59}),
		Priority    = 96,
		HideIfOwned = true,
	},

	-- x3 Luck!
	{
		Key         = "E",
		Kind        = "Gamepass",
		Title       = "x3 Luck!",
		Icon        = "rbxassetid://111648715389151",
		OldPrice    = 200,
		NewPrice    = 119,
		IsOfferActive = true,
		EndsAt      = os.time({year=2025, month=9, day=30, hour=23, min=59, sec=59}),
		Priority    = 99,
		HideIfOwned = true,
	},

	-- x2 Luck!
	{
		Key         = "F",
		Kind        = "Gamepass",
		Title       = "x2 Luck!",
		Icon        = "rbxassetid://113302080319391",
		OldPrice    = 99,
		NewPrice    = 75,
		IsOfferActive = true,
		EndsAt      = os.time({year=2025, month=9, day=30, hour=23, min=59, sec=59}),
		Priority    = 94,
		HideIfOwned = true,
	},
}

function Offers_Config.loadOfferState(plr,Prekey)
	local key = Prekey.. plr.UserId
	local ok, err = pcall(function()
		return OfferStore:GetAsync(key)
	end)
	return err
end
function Offers_Config.InsertOffer(Offer)
	table.insert(Offers_Config.Offers,Offer)
end
	

function Offers_Config.GetAndCreateClothOffer(plr)
	local FOUR_DAYS = 4 * 24 * 60 * 60
	local number = math.random(1, 50)
	local itemKind="Gloves"
	local itemIndex
	local ItemData
	local ItemKey
	local keys = {}
	local price=math.random(500, 1500)
	local OldPrice=math.random(price, (price*2))
	local PP = Offers_Config.loadOfferState(plr,"ClothOffer_")
	task.wait()
	local expiredSet = {}
	if PP and PP.expiredItems then
		for _, v in ipairs(PP.expiredItems) do
			if type(v) == "string" then
				expiredSet[v] = true
			elseif type(v) == "table" then
				local k = v.Key or v.RefName
				if type(k) == "string" then
					expiredSet[k] = true
				end
			end
		end
	end
	if number % 2 == 0 then
		itemKind="Shorts"

		local List=Clothing_Mod.Get_All_Shorts_Data()
		for k in pairs(List) do
			table.insert(keys, k)
		end
		table.sort(keys) 
		--CurrentKey = itemKey.."_"..itemKind,
		local isOwned=true
		local attempts=0
		local maxAttempts = 14
		while isOwned and attempts < maxAttempts do
			attempts += 1
			itemIndex = math.random(1, 15)
			ItemKey=keys[itemIndex]
			isOwned=Clothing_Mod.Player_Owns_Shorts_Key(plr,ItemKey)
			if expiredSet[ItemKey.."_"..itemKind] then
				isOwned=true
			end
		end
		ItemData=List[ItemKey]
	else
		
		local List=Clothing_Mod.Get_All_Gloves_Data()
		for k in pairs(List) do
			table.insert(keys, k)
		end
		table.sort(keys) 
		local isOwned=true
		
		local attempts=0
		local maxAttempts = 29
		while isOwned and attempts < maxAttempts do
			attempts += 1

			itemIndex = math.random(1, 30)
			ItemKey=keys[itemIndex]
			isOwned=Clothing_Mod.Player_Owns_Gloves_Key(plr,ItemKey)
			if expiredSet[ItemKey.."_"..itemKind] then
				isOwned=true
			end
		end
		ItemData=List[ItemKey]
	end
	local offer={
		
		Key         = ItemKey,
		Kind        = itemKind,
		Title       = ItemData,
		Icon        = "rbxassetid://71311860566568", --  replace with your denim shorts icon asset id
		OldPrice    = OldPrice,
		NewPrice    = price,
		EndsAt      = os.time()+FOUR_DAYS,
		Priority    = 1,
		Consumable  = false,
		HideIfOwned = true,
		IsOfferActive = true,
		Ownership   = { Kind = itemKind.."Key", Key = ItemKey }
	}
	Offers_Config.InsertOffer(offer)
	return offer
end


-- --- helpers ---


function Offers_Config.GetUGCItemNew(plr)
	local profile = Offers_Config.loadOfferState(plr, "offer_1_")

	-- Build a fast lookup set for expired items; support both shapes:
	--   {"KeyName1","KeyName2"} OR {{Key="KeyName1"}, {Key="KeyName2"}}
	local expiredSet = {}
	if profile and profile.expiredItems then
		for _, v in ipairs(profile.expiredItems) do
			if type(v) == "string" then
				expiredSet[v] = true
			elseif type(v) == "table" then
				local k = v.Key or v.RefName
				if type(k) == "string" then
					expiredSet[k] = true
				end
			end
		end
	end

	local function isActive(item)
		-- Treat missing flags as active by default
		if item.IsOfferActive == false then
			return false
		end

		-- Resolve the canonical key well use everywhere
		local key= item.RefName
		if type(key) ~= "string" or key == "" then
			return false
		end

		-- Per-player expired history
		if expiredSet[key] then
			return false
		end

		-- Optional: per-item absolute end time in the catalog (if provided)
		local ends = tonumber(item.EndsAt)
		if ends and ends > 0 and os.time() > ends then
			return false
		end
		return true
	end

	local list = UGCOffers_Config.UGCItemsConfig or {}
	local best = nil
	local now = os.time()
	local ownsCache = {}  -- avoid duplicate Marketplace calls

	for _, item in ipairs(list) do
		local key = item.Key or item.RefName
		if type(key) == "string" and key ~= "" then
			if isActive(item) and not Player_Owns_Item_UGC_ServerCheck(plr, key) then
				-- Higher Priority first; stable tie-break on Title (ASC)
				local pri    = tonumber(item.Priority) or 0
				local title  = tostring(item.Title or "")
				if not best
					or pri > (tonumber(best.Priority) or 0)
					or (pri == (tonumber(best.Priority) or 0) and title < tostring(best.Title or "")) then
					best = item
				end
			end
		end
	end

	return best  -- may be nil if everything is owned/inactive/expired
end


local function Get_Player_Val(Plr, Val)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Val) ~= nil) then
		return PD:FindFirstChild(Val)
	end

	return nil
end
local function IsGamepass_Owned(Plr, Key)
	local Owned_Gamepass_Val = Get_Player_Val(Plr, "Owned Gamepasses")
	if(Owned_Gamepass_Val ~= nil) then
		local Owned_Keys = string.split(Owned_Gamepass_Val.Value, ",")
		if(table.find(Owned_Keys, Key) == nil)then
			return false
		end
		return true
	end
end
local function getPlayerCoins(plr)
	local PD = plr:FindFirstChild("Player_Data")
	local v = PD and PD:FindFirstChild("Coins")
	return (v and tonumber(v.Value)) or 0
end


local function getDevType(key)
	local t = Monetization_Mod.Get_All_Dev_Product_Data()[key]
	return t and t.Type or nil
end

-- default consumable inference from Dev Type
local TypeConsumableDefault = {
	Cash = true,
	Gems = true,
	["StarterPack"] = false,
	["Special Gloves"] = false,
	Bundle = false,
}

local function isConsumable(def)
	if def.Consumable ~= nil then return def.Consumable end
	if def.Kind == "Gamepass" then return false end
	-- DevProduct: infer from type
	local t = getDevType(def.Key)
	if not t then return false end
	local v = TypeConsumableDefault[t]
	if v == nil then
		-- unknown types treated as non-consumable by default (safer)
		return false
	end
	return v
end
function Player_Owns_Item_UGC(Plr, Key)
	local ID = Monetization_Mod.Get_All_UGC_Data()[Key].ID
	return Player_Owns_Item_UGC_ServerCheck(Plr,ID)
end
function Player_Owns_Item_UGC_ServerCheck(Plr, ID)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = MPS:PlayerOwnsAsset(Plr, ID)
		end)

		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end

	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end

	return false
end
local function playerDataBool(plr, name)
	local PD = plr:FindFirstChild("Player_Data")
	local v = PD and PD:FindFirstChild(name)
	return v and (v.Value == true) or false
end


local function discountText(oldP, newP)
	oldP, newP = tonumber(oldP), tonumber(newP)
	if not oldP or not newP or oldP <= 0 or newP <= 0 then return "" end
	local pct = math.floor(((oldP - newP) / oldP) * 100)
	if pct < 0 then pct = 0 end
	return pct > 0 and ("-" .. pct .. "%") or ""
end

local function ownsByDescriptor(plr, def)
	local kind = def.Ownership and def.Ownership.Kind
	if not kind then
		-- fallback shorthand for gamepasses
		if def.Kind == "Gamepass" and def.HideIfOwned then
		--	local gp = Monetization_Mod.Get_All_Gamepass_Data()[def.Key]
			return IsGamepass_Owned(plr, def.Key) or false
		end
		return false
	end

	if kind == "Gamepass" then
		--local gp = Monetization_Mod.Get_All_Gamepass_Data()[def.Key]
		return IsGamepass_Owned(plr, def.Key) or false

	elseif kind == "GlovesKey" then
		local k = def.Ownership.Key
		if type(Clothing_Mod.Player_Owns_Gloves_Key) == "function" then
			return Clothing_Mod.Player_Owns_Gloves_Key(plr, k) == true
		end
		return false

	elseif kind == "ShortsKey" then
		local k = def.Ownership.Key
		if type(Clothing_Mod.Player_Owns_Shorts_Key) == "function" then
			return Clothing_Mod.Player_Owns_Shorts_Key(plr, k) == true
		end
		return false

	elseif kind == "AccessoryKey" then
		local k = def.Ownership.Key
		if type(Clothing_Mod.Player_Owns_Accessory) == "function" then
			return Clothing_Mod.Player_Owns_Accessory(plr, k) == true
		end
		-- fallback string list
		local PD = plr:FindFirstChild("Player_Data")
		local ownedV = PD and PD:FindFirstChild("Owned Accessories")
		if ownedV then
			local arr = string.split(ownedV.Value, ",")
			return table.find(arr, k) ~= nil
		end
		return false

	elseif kind == "UGCKey" then
		local k = def.Ownership.Key -- FIX: use Ownership.Key, not def.Key
		return Player_Owns_Item_UGC(plr, k)

	elseif kind == "PlayerDataFlag" then
		return playerDataBool(plr, def.Ownership.Flag) == (def.Ownership.Value ~= false)
	end

	return false
end


-- one row  UI payload (preformatted)
function Offers_Config.rowForClient(plr, def)
	-- Guard: offer inactive
	if not def.IsOfferActive then
		return nil
	end

	-- Expiry check
	local endsAt = tonumber(def.EndsAt) or 0
	if endsAt > 0 and os.time() > endsAt then
		return nil
	end

	-- Resolve catalog entry
	local entry, data
	if def.Kind == "DevProduct" then
		entry = Monetization_Mod.Get_All_Dev_Product_Data()[def.Key]
		if not entry then return nil end
		data = Item_Price_Icon.getPriceInfo(def.Kind, entry.ID)

	elseif def.Kind == "UGC" then
		entry = Monetization_Mod.Get_All_UGC_Data()[def.Key]
		if not entry then return nil end
		data = Item_Price_Icon.getPriceInfo(def.Kind, entry.ID)

	elseif def.Kind == "Gamepass" then
		entry = Monetization_Mod.Get_All_Gamepass_Data()[def.Key]
		if not entry then return nil end
		data = Item_Price_Icon.getPriceInfo(def.Kind, entry.ID)

	elseif def.Kind == "Gloves" or def.Kind == "Shorts" then
		-- These arent Roblox catalog items, only internal Clothing_Mod keys
		entry = {
			Name = def.Title,
			Icon = def.Icon,
			ID   = def.Key,
		}
		data = { price = def.NewPrice } -- manual, no Marketplace lookup

	else
		return nil -- unsupported type
	end

	-- Ownership check (skip if already owned and non-consumable)
	local consumable = isConsumable(def)
	if not consumable then
		if ownsByDescriptor(plr, def) then
			return nil
		end
	end

	-- Final payload for client UI
	return {
		ProductKey   = def.Key,
		Kind         = def.Kind,                               -- "DevProduct" | "Gamepass" | "UGC" | "Gloves" | "Shorts"
		Title        = def.Title or (entry and entry.Name) or "Offer",
		ItemIcon     = def.Icon or (entry and entry.Icon) or "",
		Amount       = def.Amount or "",
		OldPrice     = def.OldPrice,
		NewPrice     = data and data.price or def.NewPrice,
		DiscountText = discountText(def.OldPrice, def.NewPrice),
		EndsAt       = endsAt,
		ShowAfter    = tonumber(def.ShowAfter) or 0,
		_Priority    = tonumber(def.Priority) or 0,            -- internal sort key
		Ownership    = def.Ownership or nil
	}
end



function Offers_Config.getOfferDataByKey(Kind,key)
	for _, def in ipairs(Offers_Config.Offers) do
		if def.Key == key and def.Kind==Kind then
			return def
		end
	end
	return nil
end


function Offers_Config.IsItemOwned(plr,Kind, Key)
	local def = Offers_Config.getOfferDataByKey(Kind,Key)
	if not def then return true end
	return ownsByDescriptor(plr, def)
end

function Offers_Config.getOfferByKey(plr,Kind, key)
	local def = Offers_Config.getOfferDataByKey(Kind,key)
	if not def then return nil end
	return Offers_Config.rowForClient(plr, def)
end

-- Build ALL eligible rows
function Offers_Config.buildPayload(plr)
	local out = {}
	for _, def in ipairs(Offers_Config.Offers) do
		local row = Offers_Config.rowForClient(plr, def)
		if row then
			table.insert(out, row)
		end
	end
	return out
end
-- Dynamic eligibility rules at pick time (after rows are built)
function Offers_Config.isRowEligibleNow(plr, row)
	-- Guard: expired rows shouldnt be picked
	if row.EndsAt and row.EndsAt > 0 and os.time() > row.EndsAt and row.IsOfferActive then
		return false
	end

	-- Rule A: If player has >1000 Coins, skip Cash DevProduct offers
	if row.Kind == "DevProduct" then
		local dev = Monetization_Mod.Get_All_Dev_Product_Data()[row.ProductKey]
		if dev and dev.Type == "Cash" then
			if getPlayerCoins(plr) > cointLimit then --- limt can be changed
				return false
			end
		end
	end

	-- Rule B: If its a gamepass and the player already owns it, skip
	if row.Kind == "Gamepass" then
		
		return (not IsGamepass_Owned(plr, row.ProductKey)) or true
		
	end

	return true
end


function Offers_Config.pickTopOffer(plr)
	local rows = Offers_Config.buildPayload(plr)

	-- Filter by dynamic eligibility
	local eligible = {}
	for _, r in ipairs(rows) do
		if Offers_Config.isRowEligibleNow(plr, r) then
			table.insert(eligible, r)
		end
	end

	-- Nothing left? return nil so server sends no offer
	if #eligible == 0 then
		return nil
	end

	-- Sort by Priority (desc), then EndsAt (earliest first)
	table.sort(eligible, function(a, b)
		local ap = tonumber(a._Priority) or 0
		local bp = tonumber(b._Priority) or 0
		if ap ~= bp then
			return ap > bp
		end
		local ae = tonumber(a.EndsAt) or math.huge
		local be = tonumber(b.EndsAt) or math.huge
		return ae < be
	end)

	return eligible[1]
end
return Offers_Config
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX6B27519BF75F4D87BC71B1B482C48BE0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Offers_Config</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXB5FA1847C41E4C1386D397C7E720DC63">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">GetPrice_Icon.lua</string>
							<string name="ScriptGuid">{55EEE992-C477-45C6-9146-AC62AE3EE1EF}</string>
							<ProtectedString name="Source"><![CDATA[local MPS = game:GetService("MarketplaceService")
local AES = game:GetService("AvatarEditorService")

local GetPrice_Icon = {}

GetPrice_Icon.CACHE = {}    -- [cacheKey] = { t = os.clock(), data = ... }
GetPrice_Icon.TTL   = 5

function GetPrice_Icon.thumbUrl(kind: string, id: number, w: number, h: number): string?
	if kind == "Gamepass" then
		return string.format("rbxassetid://"..id)
	elseif kind == "UGC" then
		return string.format("rbxassetid://"..id)
	end
	return nil -- DevProduct: supply custom icon
end

function GetPrice_Icon.getPriceInfo(kind: string, idIn: number | string)
	kind = string.lower(kind)
	local id = tonumber(idIn)
	if not id then return nil end

	local cacheKey = kind .. ":" .. id
	local now = os.clock()
	local c = GetPrice_Icon.CACHE[cacheKey]
	if c and (now - c.t) < GetPrice_Icon.TTL then
		return c.data
	end

	local data = { price = nil, isForSale = nil, name = nil, iconImage = nil }

	if kind == "gamepass" then
		local ok, info = pcall(MPS.GetProductInfo, MPS, id, Enum.InfoType.GamePass)
		if ok and info then
			data.price = info.PriceInRobux
			data.isForSale = info.IsForSale
			data.name = info.Name
			data.iconImage = GetPrice_Icon.thumbUrl("Gamepass", id, 150, 150)
		end

	elseif kind == "ugc" or kind == "asset" then
		-- Primary: AES for accurate current pricing (incl. limiteds/resales)
		local ok1, details = pcall(AES.GetItemDetails, AES, id, Enum.AvatarItemType.Asset)
		if ok1 and details then
			data.price = details.Price or details.LowestResalePrice
			data.isForSale = details.IsForSale
			data.name = details.Name or details.ItemName
			data.iconImage = GetPrice_Icon.thumbUrl("UGC", id, 150, 150)
		else
			-- Fallback: MPS
			local ok2, info = pcall(MPS.GetProductInfo, MPS, id, Enum.InfoType.Asset)
			if ok2 and info then
				data.price = info.PriceInRobux
				data.isForSale = info.IsForSale
				data.name = info.Name
				data.iconImage = GetPrice_Icon.thumbUrl("UGC", id, 150, 150)
			end
		end

	elseif kind == "devproduct" or kind == "product" then
		local ok, info = pcall(MPS.GetProductInfo, MPS, id, Enum.InfoType.Product)
		if ok and info then
			data.price = info.PriceInRobux
			data.isForSale = true -- purchasable via prompt
			data.name = info.Name
			-- DevProduct: no official icon
		end
	end

	-- Only cache if we actually got something meaningful
	if data.name or data.price or data.isForSale ~= nil then
		GetPrice_Icon.CACHE[cacheKey] = { t = now, data = data }
	end
	return data
end

return GetPrice_Icon
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX333797B52C0E4413A435AD438FC91190">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">UGCItemHelper.lua</string>
							<string name="ScriptGuid">{65F161EF-1462-4939-9E81-292BAA0833D1}</string>
							<ProtectedString name="Source"><![CDATA[-- ReplicatedStorage/Data_Mods_F/Offers_Config/UGCItemHelper.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UGC_FOLDER = ReplicatedStorage:WaitForChild("OfferItems"):WaitForChild("UGCItems")

local M = {}
M.UGCItemsConfig = {}

-- parse "Priority/Key/Title"
local function parseName(name)
	local prio, key, title = string.match(name, "^(%d+)%s*/%s*(%d+)%s*/%s*(.+)$")
	if not prio then return end
	return tonumber(prio), tostring(key), title
end

local function rebuild()
	local items = {}
	for _, inst in ipairs(UGC_FOLDER:GetChildren()) do
		local prio, key, title = parseName(inst.Name)
		if prio then
			table.insert(items, {
				Key = key,
				Kind = "UGC",
				Title = title,
				RefName=inst.Name,
				Priority = prio,
				EndsAt =  0,           -- 0 = no end
				IsOfferActive = true, -- default true
				_ref = inst,
			})
		else
			warn("[UGCItemHelper] Bad item name (expected 'Priority/Key/Title'):", inst:GetFullName())
		end
	end
	table.sort(items, function(a,b)
		if a.Priority ~= b.Priority then return a.Priority > b.Priority end
		return a.Title < b.Title
	end)
	M.UGCItemsConfig = items
	--print(("[UGCItemHelper] Refreshed. Items: %d"):format(#items))
end

-- hook signals on a single child to catch rename/attribute edits
local function hookChild(inst)
	inst:GetPropertyChangedSignal("Name"):Connect(rebuild)
	inst.AttributeChanged:Connect(rebuild)
end

-- initial build + hooks
rebuild()
for _, c in ipairs(UGC_FOLDER:GetChildren()) do
	hookChild(c)
end

-- folder-level add/remove hooks
UGC_FOLDER.ChildAdded:Connect(function(c)
	hookChild(c)
	rebuild()
end)

UGC_FOLDER.ChildRemoved:Connect(function()
	rebuild()
end)

return M
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX8DB9208E2E984B41824048CC73F0F2FB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Changelog_Mod.lua</string>
						<string name="ScriptGuid">{FD23AF70-63AC-40DD-B5FB-1835103748AF}</string>
						<ProtectedString name="Source"><![CDATA[return {
	{
		version = "CHANGELOG V2025-09-26.BETA",
		changes = {
			" Bug fixes",
			" Podium UGCs are now renewed",
			" Brand new UI and menus completed",
			" New Changelog UI with version history",
			" Special chat tag for Top 3 players"
		}
	},
	{
		version = "CHANGELOG V2025-09-22",
		changes = {
			" New tutorial use ? top menu button",
			" New daily rewards system ",
			" Limited time offers at startup",
			" New UGCs to customize your avatar",
			" Brand new UI and menus",
			" Enhanced loading time",
			" Fight mode only in Gym now",
			" Voice chat is now available"
			
		}
	}
}

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX4928A10AC0E1409AB09B28220C2DAECA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Vendor</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXEDF5504AC8514159AB9DF4B8BBA9621A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Spr.lua</string>
						<string name="ScriptGuid">{D400A39B-F4C5-4B3C-A29A-5E73EEA167C5}</string>
						<ProtectedString name="Source"><![CDATA[--!strict
--!native
---------------------------------------------------------------------
-- spr - Spring-driven motion library
--
-- Copyright (c) 2024 Fractality. All rights reserved.
-- Released under the MIT license.
--
-- Docs & license can be found at https://github.com/Fraktality/spr
--
-- API Summary:
--
-- spr.target(
--    Instance obj,
--    number dampingRatio,
--    number undampedFrequency,
--    dict<string, Variant> targetProperties)
--
--    Animates the given properties towardes the target values,
--    given damping ratio and undamped frequency.
--
--
-- spr.stop(
--    Instance obj[,
--    string property])
--
--    Stops the specified property on an Instance from animating.
--    If no property is specified, all properties of the Instance
--    will stop animating.
--
-- Visualizer: https://www.desmos.com/calculator/rzvw27ljh9
---------------------------------------------------------------------

local STRICT_RUNTIME_TYPES = true -- assert on parameter and property type mismatch
local SLEEP_OFFSET_SQ_LIMIT = (1/3840)^2 -- square of the offset sleep limit
local SLEEP_VELOCITY_SQ_LIMIT = 1e-2^2 -- square of the velocity sleep limit
local SLEEP_ROTATION_DIFF = math.rad(0.01) -- rad
local SLEEP_ROTATION_VELOCITY = math.rad(0.1) -- rad/s
local EPS = 1e-5 -- epsilon for stability checks around pathological frequency/damping values

local RunService: RunService = game:GetService("RunService")

local pi = math.pi
local exp = math.exp
local sin = math.sin
local cos = math.cos
local min = math.min
local max = math.max
local sqrt = math.sqrt
local atan2 = math.atan2
local round = math.round

local function magnitudeSq(vec: {number})
	local out = 0
	for _, v in vec do
		out += v^2
	end
	return out
end

local function distanceSq(vec0: {number}, vec1: {number})
	local out = 0
	for i0, v0 in vec0 do
		out += (vec1[i0] - v0)^2
	end
	return out
end

type TypeMetadata<T> = {
	springType: (dampingRatio: number, frequency: number, pos: number, typedat: TypeMetadata<T>, rawTarget: T) -> LinearSpring<T>,
	toIntermediate: (T) -> {number},
	fromIntermediate: ({number}) -> T,
}

-- Spring for an array of linear values
local LinearSpring = {}

type LinearSpring<T> = typeof(setmetatable({} :: {
	d: number,
	f: number,
	g: {number},
	p: {number},
	v: {number},
	typedat: TypeMetadata<T>,
	rawTarget: T,
}, LinearSpring))

do
	LinearSpring.__index = LinearSpring

	function LinearSpring.new<T>(dampingRatio: number, frequency: number, pos: T, rawGoal: T, typedat)
		local linearPos = typedat.toIntermediate(pos)
		return setmetatable(
			{
				d = dampingRatio,
				f = frequency,
				g = linearPos,
				p = linearPos,
				v = table.create(#linearPos, 0),
				typedat = typedat,
				rawGoal = rawGoal
			},
			LinearSpring
		)
	end

	function LinearSpring.setGoal<T>(self, goal: T)
		self.rawGoal = goal
		self.g = self.typedat.toIntermediate(goal)
	end

	function LinearSpring.setDampingRatio<T>(self: LinearSpring<T>, dampingRatio: number)
		self.d = dampingRatio
	end

	function LinearSpring.setFrequency<T>(self: LinearSpring<T>, frequency: number)
		self.f = frequency
	end

	function LinearSpring.canSleep<T>(self)
		if magnitudeSq(self.v) > SLEEP_VELOCITY_SQ_LIMIT then
			return false
		end

		if distanceSq(self.p, self.g) > SLEEP_OFFSET_SQ_LIMIT then
			return false
		end

		return true
	end

	function LinearSpring.step<T>(self: LinearSpring<T>, dt: number)
		-- Advance the spring simulation by dt seconds.
		-- Take the damped harmonic oscillator ODE:
		--    f^2*(X[t] - g) + 2*d*f*X'[t] + X''[t] = 0
		-- Where X[t] is position at time t, g is target position,
		-- f is undamped angular frequency, and d is damping ratio.
		-- Apply constant initial conditions:
		--    X[0] = p0
		--    X'[0] = v0
		-- Solve the IVP to get analytic expressions for X[t] and X'[t].
		-- The solution takes one of three forms for 0<=d<1, d=1, and d>1

		local d = self.d
		local f = self.f*(2*pi) -- Hz -> Rad/s
		local g = self.g
		local p = self.p
		local v = self.v

		if d == 1 then -- critically damped
			local q = exp(-f*dt)
			local w = dt*q

			local c0 = q + w*f
			local c2 = q - w*f
			local c3 = w*f*f

			for idx = 1, #p do
				local o = p[idx] - g[idx]
				p[idx] = o*c0 + v[idx]*w + g[idx]
				v[idx] = v[idx]*c2 - o*c3
			end

		elseif d < 1 then -- underdamped
			local q = exp(-d*f*dt)
			local c = sqrt(1 - d*d)

			local i = cos(dt*f*c)
			local j = sin(dt*f*c)

			-- Damping ratios approaching 1 can cause division by very small numbers.
			-- To mitigate that, group terms around z=j/c and find an approximation for z.
			-- Start with the definition of z:
			--    z = sin(dt*f*c)/c
			-- Substitute a=dt*f:
			--    z = sin(a*c)/c
			-- Take the Maclaurin expansion of z with respect to c:
			--    z = a - (a^3*c^2)/6 + (a^5*c^4)/120 + O(c^6)
			--    z  a - (a^3*c^2)/6 + (a^5*c^4)/120
			-- Rewrite in Horner form:
			--    z  a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6

			local z
			if c > EPS then
				z = j/c
			else
				local a = dt*f
				z = a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6
			end

			-- Frequencies approaching 0 present a similar problem.
			-- We want an approximation for y as f approaches 0, where:
			--    y = sin(dt*f*c)/(f*c)
			-- Substitute b=dt*c:
			--    y = sin(b*c)/b
			-- Now reapply the process from z.

			local y
			if f*c > EPS then
				y = j/(f*c)
			else
				local b = f*c
				y = dt + ((dt*dt)*(b*b)*(b*b)/20 - b*b)*(dt*dt*dt)/6
			end

			for idx = 1, #p do
				local o = p[idx] - g[idx]
				p[idx] = (o*(i + z*d) + v[idx]*y)*q + g[idx]
				v[idx] = (v[idx]*(i - z*d) - o*(z*f))*q
			end

		else -- overdamped
			local c = sqrt(d*d - 1)

			local r1 = -f*(d + c)
			local r2 = -f*(d - c)

			local ec1 = exp(r1*dt)
			local ec2 = exp(r2*dt)

			for idx = 1, #p do
				local o = p[idx] - g[idx]
				local co2 = (v[idx] - o*r1)/(2*f*c)
				local co1 = ec1*(o - co2)

				p[idx] = co1 + co2*ec2 + g[idx]
				v[idx] = co1*r1 + co2*ec2*r2
			end
		end

		return self.typedat.fromIntermediate(self.p)
	end
end

local RotationSpring = {} 

type RotationSpring = typeof(setmetatable({} :: {
	d: number,
	f: number,
	g: CFrame,
	p: CFrame,
	v: Vector3,
}, RotationSpring))

do
	RotationSpring.__index = RotationSpring

	function RotationSpring.new(d: number, f: number, p: CFrame, g: CFrame)
		return setmetatable(
			{
				d = d,
				f = f,
				g = g:Orthonormalize(),
				p = p:Orthonormalize(),
				v = Vector3.zero
			},
			RotationSpring
		)
	end

	function RotationSpring.setGoal(self: RotationSpring, value: CFrame)
		self.g = value:Orthonormalize()
	end

	function RotationSpring.setDampingRatio(self: RotationSpring, dampingRatio: number)
		self.d = dampingRatio
	end

	function RotationSpring.setFrequency(self: RotationSpring, frequency: number)
		self.f = frequency
	end

	-- evaluate dot products in high precision
	local function dot(v0: Vector3, v1: Vector3)
		return v0.X*v1.X + v0.Y*v1.Y + v0.Z*v1.Z
	end

	local function areRotationsClose(c0: CFrame, c1: CFrame)
		local rx = dot(c0.XVector, c1.XVector)
		local ry = dot(c0.YVector, c1.YVector)
		local rz = dot(c0.ZVector, c1.ZVector)
		local trace = rx + ry + rz
		return trace > 1 + 2*cos(SLEEP_ROTATION_DIFF)
	end

	local function angleDiff(c0: CFrame, c1: CFrame)
		local x = dot(c0.XVector, c1.XVector)
		local y = dot(c0.YVector, c1.YVector)
		local z = dot(c0.ZVector, c1.ZVector)
		local w = x + y + z - 1
		return atan2(sqrt(max(0, 1 - w*w*0.25)), w*0.5)
	end

	-- gives approx. 21% accuracy improvement over CFrame.fromAxisAngle near poles
	local function fromAxisAngle(axis: Vector3, angle: number)
		local c = cos(angle)
		local s = sin(angle)
		local x, y, z = axis.X, axis.Y, axis.Z

		local mxy = x*y*(1 - c)
		local myz = y*z*(1 - c)
		local mzx = z*x*(1 - c)

		local rx = Vector3.new(x*x*(1 - c) + c, mxy + z*s, mzx - y*s)
		local ry = Vector3.new(mxy - z*s, y*y*(1 - c) + c, myz + x*s)
		local rz = Vector3.new(mzx + y*s, myz - x*s, z*z*(1 - c) + c)

		return CFrame.fromMatrix(Vector3.zero, rx, ry, rz):Orthonormalize()
	end

	local function rotateAxis(r0: Vector3, c1: CFrame)
		local c0 = CFrame.identity
		local mag = r0.Magnitude
		if mag > 1e-6 then
			c0 = fromAxisAngle(r0.Unit, mag)
		end
		return c0 * c1
	end

	-- axis*angle difference between two cframes
	local function axisAngleDiff(c0: CFrame, c1: CFrame)
		-- use native axis (stable enough)
		local axis = (c0*c1:Inverse()):ToAxisAngle()

		-- use full-precision angle calculation to minimize truncation
		local angle = angleDiff(c0, c1)
		return axis.Unit*angle
	end

	function RotationSpring.canSleep(self: RotationSpring)
		local sleepP = areRotationsClose(self.p, self.g)
		local sleepV = self.v.Magnitude < SLEEP_ROTATION_VELOCITY
		return sleepP and sleepV
	end

	function RotationSpring.step(self: RotationSpring, dt: number): CFrame
		local d = self.d
		local f = self.f*(2*pi)
		local g = self.g
		local p0 = self.p
		local v0 = self.v

		local offset = axisAngleDiff(p0, g)
		local decay = exp(-d*f*dt)

		local pt: CFrame
		local vt: Vector3

		if d == 1 then -- critically damped
			pt = rotateAxis((offset*(1 + f*dt) + v0*dt)*decay, g)
			vt = (v0*(1 - dt*f) - offset*(dt*f*f))*decay

		elseif d < 1 then -- underdamped
			local c = sqrt(1 - d*d)

			local i = cos(dt*f*c)
			local j = sin(dt*f*c)

			local y = j/(f*c)
			local z = j/c

			pt = rotateAxis((offset*(i + z*d) + v0*y)*decay, g)
			vt = (v0*(i - z*d) - offset*(z*f))*decay

		else -- overdamped
			local c = sqrt(d*d - 1)

			local r1 = -f*(d + c)
			local r2 = -f*(d - c)

			local co2 = (v0 - offset*r1)/(2*f*c)
			local co1 = offset - co2

			local e1 = co1*exp(r1*dt)
			local e2 = co2*exp(r2*dt)

			pt = rotateAxis(e1 + e2, g)
			vt = e1*r1 + e2*r2
		end

		self.p = pt
		self.v = vt

		return pt
	end
end

-- Defined early to be used by CFrameSpring
local typeMetadata_Vector3 = {
	springType = LinearSpring.new,

	toIntermediate = function(value)
		return {value.X, value.Y, value.Z}
	end,

	fromIntermediate = function(value: {number})
		return Vector3.new(value[1], value[2], value[3])
	end,
}

-- Encapsulates a CFrame - Separates translation from rotation
local CFrameSpring = {}
do
	CFrameSpring.__index = CFrameSpring

	function CFrameSpring.new(
		dampingRatio: number,
		frequency: number,
		valueCurrent: CFrame,
		valueGoal: CFrame,
		_: any
	)
		return setmetatable(
			{
				rawGoal = valueGoal,
				_position = LinearSpring.new(dampingRatio, frequency, valueCurrent.Position, valueGoal.Position, typeMetadata_Vector3),
				_rotation = RotationSpring.new(dampingRatio, frequency, valueCurrent.Rotation, valueGoal.Rotation)
			},
			CFrameSpring
		)
	end

	function CFrameSpring:setGoal(value: CFrame)
		self.rawGoal = value
		self._position:setGoal(value.Position)
		self._rotation:setGoal(value.Rotation)
	end

	function CFrameSpring:setDampingRatio(value: number)
		self._position.d = value
		self._rotation.d = value
	end

	function CFrameSpring:setFrequency(value: number)
		self._position.f = value
		self._rotation.f = value
	end

	function CFrameSpring:canSleep()
		return self._position:canSleep() and self._rotation:canSleep()
	end

	function CFrameSpring:step(dt): CFrame
		local p: Vector3 = self._position:step(dt)
		local r: CFrame = self._rotation:step(dt)
		return r + p
	end
end

-- Color conversions
local rgbToLuv
local luvToRgb
do
	local function inverseGammaCorrectD65(c)
		return c < 0.0404482362771076 and c/12.92 or 0.87941546140213*(c + 0.055)^2.4
	end

	local function gammaCorrectD65(c)
		return c < 3.1306684425e-3 and 12.92*c or 1.055*c^(1/2.4) - 0.055
	end

	function rgbToLuv(value: Color3): {number}
		-- convert RGB to a variant of cieluv space
		local r, g, b = value.R, value.G, value.B

		-- D65 sRGB inverse gamma correction
		r = inverseGammaCorrectD65(r)
		g = inverseGammaCorrectD65(g)
		b = inverseGammaCorrectD65(b)

		-- sRGB -> xyz
		local x = 0.9257063972951867*r - 0.8333736323779866*g - 0.09209820666085898*b
		local y = 0.2125862307855956*r + 0.71517030370341085*g + 0.0722004986433362*b
		local z = 3.6590806972265883*r + 11.4426895800574232*g + 4.1149915024264843*b

		-- xyz -> scaled cieluv
		local l = y > 0.008856451679035631 and 116*y^(1/3) - 16 or 903.296296296296*y

		local u, v
		if z > 1e-14 then
			u = l*x/z
			v = l*(9*y/z - 0.46832)
		else
			u = -0.19783*l
			v = -0.46832*l
		end

		return {l, u, v}
	end

	function luvToRgb(value: {number}): Color3
		-- convert back from modified cieluv to rgb space
		local l = value[1]
		if l < 0.0197955 then
			return Color3.new(0, 0, 0)
		end
		local u = value[2]/l + 0.19783
		local v = value[3]/l + 0.46832

		-- cieluv -> xyz
		local y = (l + 16)/116
		y = y > 0.206896551724137931 and y*y*y or 0.12841854934601665*y - 0.01771290335807126
		local x = y*u/v
		local z = y*((3 - 0.75*u)/v - 5)

		-- xyz -> D65 sRGB
		local r =  7.2914074*x - 1.5372080*y - 0.4986286*z
		local g = -2.1800940*x + 1.8757561*y + 0.0415175*z
		local b =  0.1253477*x - 0.2040211*y + 1.0569959*z

		-- clamp minimum sRGB component
		if r < 0 and r < g and r < b then
			r, g, b = 0, g - r, b - r
		elseif g < 0 and g < b then
			r, g, b = r - g, 0, b - g
		elseif b < 0 then
			r, g, b = r - b, g - b, 0
		end

		-- gamma correction from D65
		-- clamp to avoid undesirable overflow wrapping behavior on certain properties (e.g. BasePart.Color)
		return Color3.new(
			min(gammaCorrectD65(r), 1),
			min(gammaCorrectD65(g), 1),
			min(gammaCorrectD65(b), 1)
		)
	end
end

-- Type definitions
-- Transforms Roblox types into intermediate types, converting
-- between spaces as necessary to preserve perceptual linearity
local typeMetadata = {
	boolean = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value and 1 or 0}
		end,

		fromIntermediate = function(value)
			return value[1] >= 0.5
		end,
	},

	number = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value}
		end,

		fromIntermediate = function(value)
			return value[1]
		end,
	},

	NumberRange = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value.Min, value.Max}
		end,

		fromIntermediate = function(value)
			return NumberRange.new(value[1], value[2])
		end,
	},

	UDim = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value.Scale, value.Offset}
		end,

		fromIntermediate = function(value: {number})
			return UDim.new(value[1], round(value[2]))
		end,
	},

	UDim2 = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			local x = value.X
			local y = value.Y
			return {x.Scale, x.Offset, y.Scale, y.Offset}
		end,

		fromIntermediate = function(value: {number})
			return UDim2.new(value[1], round(value[2]), value[3], round(value[4]))
		end,
	},

	Vector2 = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			return {value.X, value.Y}
		end,

		fromIntermediate = function(value: {number})
			return Vector2.new(value[1], value[2])
		end,
	},

	Vector3 = typeMetadata_Vector3,

	Color3 = {
		springType = LinearSpring.new,
		toIntermediate = rgbToLuv,
		fromIntermediate = luvToRgb,
	},

	-- Only interpolates start and end keypoints
	ColorSequence = {
		springType = LinearSpring.new,

		toIntermediate = function(value)
			local keypoints = value.Keypoints

			local luv0 = rgbToLuv(keypoints[1].Value)
			local luv1 = rgbToLuv(keypoints[#keypoints].Value)

			return {
				luv0[1], luv0[2], luv0[3],
				luv1[1], luv1[2], luv1[3],
			}
		end,

		fromIntermediate = function(value: {})
			return ColorSequence.new(
				luvToRgb{value[1], value[2], value[3]},
				luvToRgb{value[4], value[5], value[6]}
			)
		end,
	},

	CFrame = {
		springType = CFrameSpring.new,
		toIntermediate = error, -- custom (CFrameSpring)
		fromIntermediate = error, -- custom (CFrameSpring)
	}
}

type PropertyOverride = {
	[string]: {
		class: string,
		get: (any)->(),
		set: (any, any)->(),
	}
}

local PSEUDO_PROPERTIES: PropertyOverride = {
	Pivot = {
		class = "PVInstance",
		get = function(inst: PVInstance)
			return inst:GetPivot()
		end,
		set = function(inst: PVInstance, value: CFrame)
			inst:PivotTo(value)
		end
	},
	Scale = {
		class = "Model",
		get = function(inst: Model)
			return inst:GetScale()
		end,
		set = function(inst: Model, value: number)
			local FLOAT_MANTISSA_MIN = 1.402e-45
			local FLOAT_MANTISSA_MAX = 2^24
			value = math.clamp(value, FLOAT_MANTISSA_MIN, FLOAT_MANTISSA_MAX)
			inst:ScaleTo(value)
		end
	}
}

local function getProperty(instance: Instance, property: string): any
	local override = PSEUDO_PROPERTIES[property]
	if override and instance:IsA(override.class) then
		return override.get(instance)
	else
		return (instance :: any)[property]
	end
end

local function setProperty(instance: Instance, property: string, value: unknown)
	local override = PSEUDO_PROPERTIES[property]
	if override and instance:IsA(override.class) then
		override.set(instance, value)
	else
		(instance :: any)[property] = value
	end
end

-- Frame loop
local springStates_other: {[Instance]: {[string]: any}} = {} -- {[instance] = {[property] = spring}
local springStates_render: {[Instance]: {[string]: any}} = {} -- {[instance] = {[property] = spring}
local completedCallbacks: {[Instance]: {()->()}} = {}

local function processSprings(springStates: typeof(springStates_other), dt: number)
	for instance, state in springStates do
		for propName, spring in state do
			if spring:canSleep() then
				state[propName] = nil
				setProperty(instance, propName, spring.rawGoal)
			else
				setProperty(instance, propName, spring:step(dt))
			end
		end

		if not next(state) then
			springStates[instance] = nil

			-- trigger completed callbacks when all properties finish animating
			local callbackList = completedCallbacks[instance]
			if callbackList then
				-- flush callback list before we run any callbacks in case
				-- one of the callbacks recursively adds another callback
				completedCallbacks[instance] = nil

				for _, callback in callbackList do
					task.spawn(callback)
				end
			end
		end
	end
end

RunService.PreSimulation:Connect(function(dt)
	processSprings(springStates_other, dt)
end)

RunService.PostSimulation:Connect(function(dt)
	processSprings(springStates_render, dt)
end)

local function assertType(argNum: number, fnName: string, expectedType: string, value: unknown)
	if not expectedType:find(typeof(value)) then
		error(`bad argument #{argNum} to {fnName} ({expectedType} expected, got {typeof(value)})`, 3)
	end
end

-- API
local spr = {}

function spr.target(instance: Instance, dampingRatio: number, frequency: number, properties: {[string]: any})
	if STRICT_RUNTIME_TYPES then
		assertType(1, "spr.target", "Instance", instance)
		assertType(2, "spr.target", "number", dampingRatio)
		assertType(3, "spr.target", "number", frequency)
		assertType(4, "spr.target", "table", properties)
	end

	if dampingRatio ~= dampingRatio or dampingRatio < 0 then
		error(("expected damping ratio >= 0; got %.2f"):format(dampingRatio), 2)
	end

	if frequency ~= frequency or frequency < 0 then
		error(("expected undamped frequency >= 0; got %.2f"):format(frequency), 2)
	end

	local targetRecord = (if instance:IsA("Camera") then springStates_render else springStates_other) :: {[Instance]: {[string]: any}}

	local state = targetRecord[instance]
	if not state then
		state = {}
		targetRecord[instance] = state
	end

	for propName, propTarget in properties do
		local propValue = getProperty(instance, propName)

		if STRICT_RUNTIME_TYPES and typeof(propTarget) ~= typeof(propValue) then
			error(`bad property {propName} to spr.target ({typeof(propValue)} expected, got {typeof(propTarget)})`, 2)
		end

		-- Special case infinite frequency for an instantaneous change
		if frequency == math.huge then
			setProperty(instance, propName, propTarget)
			state[propName] = nil
			continue
		end

		local spring = state[propName]
		if not spring then
			local md = typeMetadata[typeof(propTarget)]
			if not md then
				error("unsupported type: " .. typeof(propTarget), 2)
			end

			spring = md.springType(dampingRatio, frequency, propValue, propTarget, md)
			state[propName] = spring
		end

		spring:setGoal(propTarget)
		spring:setDampingRatio(dampingRatio)
		spring:setFrequency(frequency)
	end

	if not next(state) then
		targetRecord[instance] = nil
	end
end

function spr.stop(instance: Instance, property: string?)
	if STRICT_RUNTIME_TYPES then
		assertType(1, "spr.stop", "Instance", instance)
		assertType(2, "spr.stop", "string|nil", property)
	end

	if property then
		local state = springStates_other[instance] or springStates_render[instance]
		if state then
			state[property] = nil
		end
	else
		springStates_other[instance] = nil
		springStates_render[instance] = nil
	end
end

function spr.completed(instance: Instance, callback: ()->())
	if STRICT_RUNTIME_TYPES then
		assertType(1, "spr.completed", "Instance", instance)
		assertType(2, "spr.completed", "function", callback)
	end

	local callbackList = completedCallbacks[instance]
	if callbackList then
		table.insert(callbackList, callback)
	else
		completedCallbacks[instance] = {callback}
	end
end

return table.freeze(spr)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX48A7E3ED10CC4200ADF096D49E35DADB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Find.lua</string>
						<string name="ScriptGuid">{967077E3-5CFE-441B-9FBF-1522527281ED}</string>
						<ProtectedString name="Source"><![CDATA[return function(root:Instance,ref:string,callback)
	local result = root:FindFirstChild(ref,true)
	if result then
		callback(result)
	end

	local conn:RBXScriptConnection
	conn = root.DescendantAdded:Connect(function(newObj:Instance)
		if newObj.Name == ref then
			conn:Disconnect()
			callback(newObj)
		end
	end)

end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6D1266699CA14471AB95B5E0DE0531F5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Trove.lua</string>
						<string name="ScriptGuid">{CDF7EF36-93E9-4D69-95F1-1CD7B225FEDF}</string>
						<ProtectedString name="Source"><![CDATA[--!strict

local RunService = game:GetService("RunService")

export type Trove = {
	Extend: (self: Trove) -> Trove,
	Clone: <T>(self: Trove, instance: T & Instance) -> T,
	Construct: <T, A...>(self: Trove, class: Constructable<T, A...>, A...) -> T,
	Connect: (self: Trove, signal: SignalLike | RBXScriptSignal, fn: (...any) -> ...any) -> ConnectionLike,
	BindToRenderStep: (self: Trove, name: string, priority: number, fn: (dt: number) -> ()) -> (),
	AddPromise: <T>(self: Trove, promise: T & PromiseLike) -> T,
	Add: <T>(self: Trove, object: T & Trackable, cleanupMethod: string?) -> T,
	Remove: <T>(self: Trove, object: T & Trackable) -> boolean,
	Clean: (self: Trove) -> (),
	AttachToInstance: (self: Trove, instance: Instance) -> RBXScriptConnection,
	Destroy: (self: Trove) -> (),
}

type TroveInternal = Trove & {
	_objects: { any },
	_cleaning: boolean,
	_findAndRemoveFromObjects: (self: TroveInternal, object: any, cleanup: boolean) -> boolean,
	_cleanupObject: (self: TroveInternal, object: any, cleanupMethod: string?) -> (),
}

--[=[
	@within Trove
	@type Trackable Instance | RBXScriptConnection | ConnectionLike | PromiseLike | thread | ((...any) -> ...any) | Destroyable | DestroyableLowercase | Disconnectable | DisconnectableLowercase
	Represents all trackable objects by Trove.
]=]
export type Trackable =
	Instance
| RBXScriptConnection
| ConnectionLike
| PromiseLike
| thread
| ((...any) -> ...any)
| Destroyable
| DestroyableLowercase
| Disconnectable
| DisconnectableLowercase

--[=[
	@within Trove
	@interface ConnectionLike
	.Connected boolean
	.Disconnect (self) -> ()
]=]
type ConnectionLike = {
	Connected: boolean,
	Disconnect: (self: ConnectionLike) -> (),
}

--[=[
	@within Trove
	@interface SignalLike
	.Connect (self, callback: (...any) -> ...any) -> ConnectionLike
	.Once (self, callback: (...any) -> ...any) -> ConnectionLike
]=]
type SignalLike = {
	Connect: (self: SignalLike, callback: (...any) -> ...any) -> ConnectionLike,
	Once: (self: SignalLike, callback: (...any) -> ...any) -> ConnectionLike,
}

--[=[
	@within Trove
	@interface PromiseLike
	.getStatus (self) -> string
	.finally (self, callback: (...any) -> ...any) -> PromiseLike
	.cancel (self) -> ()
]=]
type PromiseLike = {
	getStatus: (self: PromiseLike) -> string,
	finally: (self: PromiseLike, callback: (...any) -> ...any) -> PromiseLike,
	cancel: (self: PromiseLike) -> (),
}

--[=[
	@within Trove
	@type Constructable { new: (A...) -> T } | (A...) -> T
]=]
type Constructable<T, A...> = { new: (A...) -> T } | (A...) -> T

--[=[
	@within Trove
	@interface Destroyable
	.disconnect (self) -> ()
]=]
type Destroyable = {
	Destroy: (self: Destroyable) -> (),
}

--[=[
	@within Trove
	@interface DestroyableLowercase
	.disconnect (self) -> ()
]=]
type DestroyableLowercase = {
	destroy: (self: DestroyableLowercase) -> (),
}

--[=[
	@within Trove
	@interface Disconnectable
	.disconnect (self) -> ()
]=]
type Disconnectable = {
	Disconnect: (self: Disconnectable) -> (),
}

--[=[
	@within Trove
	@interface DisconnectableLowercase
	.disconnect (self) -> ()
]=]
type DisconnectableLowercase = {
	disconnect: (self: DisconnectableLowercase) -> (),
}

local FN_MARKER = newproxy()
local THREAD_MARKER = newproxy()
local GENERIC_OBJECT_CLEANUP_METHODS = table.freeze({ "Destroy", "Disconnect", "destroy", "disconnect" })

local function GetObjectCleanupFunction(object: any, cleanupMethod: string?)
	local t = typeof(object)

	if t == "function" then
		return FN_MARKER
	elseif t == "thread" then
		return THREAD_MARKER
	end

	if cleanupMethod then
		return cleanupMethod
	end

	if t == "Instance" then
		return "Destroy"
	elseif t == "RBXScriptConnection" then
		return "Disconnect"
	elseif t == "table" then
		for _, genericCleanupMethod in GENERIC_OBJECT_CLEANUP_METHODS do
			if typeof(object[genericCleanupMethod]) == "function" then
				return genericCleanupMethod
			end
		end
	end

	error(`failed to get cleanup function for object {t}: {object}`, 3)
end

local function AssertPromiseLike(object: any)
	if
		typeof(object) ~= "table"
		or typeof(object.getStatus) ~= "function"
		or typeof(object.finally) ~= "function"
		or typeof(object.cancel) ~= "function"
	then
		error("did not receive a promise as an argument", 3)
	end
end

--[=[
	@class Trove
	A Trove is helpful for tracking any sort of object during
	runtime that needs to get cleaned up at some point.
]=]
local Trove = {}
Trove.__index = Trove

--[=[
	@return Trove
	Constructs a Trove object.

	```lua
	local trove = Trove.new()
	```
]=]
function Trove.new(): Trove
	local self = setmetatable({}, Trove)

	self._objects = {}
	self._cleaning = false

	return (self :: any) :: Trove
end

--[=[
	@method Add
	@within Trove
	@param object any -- Object to track
	@param cleanupMethod string? -- Optional cleanup name override
	@return object: any
	Adds an object to the trove. Once the trove is cleaned or
	destroyed, the object will also be cleaned up.

	The following types are accepted (e.g. `typeof(object)`):

	| Type | Cleanup |
	| ---- | ------- |
	| `Instance` | `object:Destroy()` |
	| `RBXScriptConnection` | `object:Disconnect()` |
	| `function` | `object()` |
	| `thread` | `task.cancel(object)` |
	| `table` | `object:Destroy()` _or_ `object:Disconnect()` _or_ `object:destroy()` _or_ `object:disconnect()` |
	| `table` with `cleanupMethod` | `object:<cleanupMethod>()` |

	Returns the object added.

	```lua
	-- Add a part to the trove, then destroy the trove,
	-- which will also destroy the part:
	local part = Instance.new("Part")
	trove:Add(part)
	trove:Destroy()

	-- Add a function to the trove:
	trove:Add(function()
		print("Cleanup!")
	end)
	trove:Destroy()

	-- Standard cleanup from table:
	local tbl = {}
	function tbl:Destroy()
		print("Cleanup")
	end
	trove:Add(tbl)

	-- Custom cleanup from table:
	local tbl = {}
	function tbl:DoSomething()
		print("Do something on cleanup")
	end
	trove:Add(tbl, "DoSomething")
	```
]=]
function Trove.Add(self: TroveInternal, object: Trackable, cleanupMethod: string?): any
	if self._cleaning then
		error("cannot call trove:Add() while cleaning", 2)
	end

	local cleanup = GetObjectCleanupFunction(object, cleanupMethod)
	table.insert(self._objects, { object, cleanup })

	return object
end

--[=[
	@method Clone
	@within Trove
	@return Instance
	Clones the given instance and adds it to the trove. Shorthand for
	`trove:Add(instance:Clone())`.

	```lua
	local clonedPart = trove:Clone(somePart)
	```
]=]
function Trove.Clone(self: TroveInternal, instance: Instance): Instance
	if self._cleaning then
		error("cannot call trove:Clone() while cleaning", 2)
	end

	return self:Add(instance:Clone())
end

--[=[
	@method Construct
	@within Trove
	@param class { new(Args...) -> T } | (Args...) -> T
	@param ... Args...
	@return T
	Constructs a new object from either the
	table or function given.

	If a table is given, the table's `new`
	function will be called with the given
	arguments.

	If a function is given, the function will
	be called with the given arguments.
	
	The result from either of the two options
	will be added to the trove.

	This is shorthand for `trove:Add(SomeClass.new(...))`
	and `trove:Add(SomeFunction(...))`.

	```lua
	local Signal = require(somewhere.Signal)

	-- All of these are identical:
	local s = trove:Construct(Signal)
	local s = trove:Construct(Signal.new)
	local s = trove:Construct(function() return Signal.new() end)
	local s = trove:Add(Signal.new())

	-- Even Roblox instances can be created:
	local part = trove:Construct(Instance, "Part")
	```
]=]
function Trove.Construct<T, A...>(self: TroveInternal, class: Constructable<T, A...>, ...: A...)
	if self._cleaning then
		error("Cannot call trove:Construct() while cleaning", 2)
	end

	local object = nil
	local t = type(class)
	if t == "table" then
		object = (class :: any).new(...)
	elseif t == "function" then
		object = (class :: any)(...)
	end

	return self:Add(object)
end

--[=[
	@method Connect
	@within Trove
	@param signal RBXScriptSignal
	@param fn (...: any) -> ()
	@return RBXScriptConnection
	Connects the function to the signal, adds the connection
	to the trove, and then returns the connection.

	This is shorthand for `trove:Add(signal:Connect(fn))`.

	```lua
	trove:Connect(workspace.ChildAdded, function(instance)
		print(instance.Name .. " added to workspace")
	end)
	```
]=]
function Trove.Connect(self: TroveInternal, signal: SignalLike, fn: (...any) -> ...any)
	if self._cleaning then
		error("Cannot call trove:Connect() while cleaning", 2)
	end

	return self:Add(signal:Connect(fn))
end

--[=[
	@method BindToRenderStep
	@within Trove
	@param name string
	@param priority number
	@param fn (dt: number) -> ()
	Calls `RunService:BindToRenderStep` and registers a function in the
	trove that will call `RunService:UnbindFromRenderStep` on cleanup.

	```lua
	trove:BindToRenderStep("Test", Enum.RenderPriority.Last.Value, function(dt)
		-- Do something
	end)
	```
]=]
function Trove.BindToRenderStep(self: TroveInternal, name: string, priority: number, fn: (dt: number) -> ())
	if self._cleaning then
		error("cannot call trove:BindToRenderStep() while cleaning", 2)
	end

	RunService:BindToRenderStep(name, priority, fn)

	self:Add(function()
		RunService:UnbindFromRenderStep(name)
	end)
end

--[=[
	@method AddPromise
	@within Trove
	@param promise Promise
	@return Promise
	Gives the promise to the trove, which will cancel the promise if the trove is cleaned up or if the promise
	is removed. The exact promise is returned, thus allowing chaining.

	```lua
	trove:AddPromise(doSomethingThatReturnsAPromise())
		:andThen(function()
			print("Done")
		end)
	-- Will cancel the above promise (assuming it didn't resolve immediately)
	trove:Clean()

	local p = trove:AddPromise(doSomethingThatReturnsAPromise())
	-- Will also cancel the promise
	trove:Remove(p)
	```

	:::caution Promise v4 Only
	This is only compatible with the [roblox-lua-promise](https://eryn.io/roblox-lua-promise/) library, version 4.
	:::
]=]
function Trove.AddPromise(self: TroveInternal, promise: PromiseLike)
	if self._cleaning then
		error("cannot call trove:AddPromise() while cleaning", 2)
	end
	AssertPromiseLike(promise)

	if promise:getStatus() == "Started" then
		promise:finally(function()
			if self._cleaning then
				return
			end
			self:_findAndRemoveFromObjects(promise, false)
		end)

		self:Add(promise, "cancel")
	end

	return promise
end

--[=[
	@method Remove
	@within Trove
	@param object any
	Removes the object from the Trove and cleans it up.

	```lua
	local part = Instance.new("Part")
	trove:Add(part)
	trove:Remove(part)
	```
]=]
function Trove.Remove(self: TroveInternal, object: Trackable): boolean
	if self._cleaning then
		error("cannot call trove:Remove() while cleaning", 2)
	end

	return self:_findAndRemoveFromObjects(object, true)
end

--[=[
	@method Extend
	@within Trove
	@return Trove
	Creates and adds another trove to itself. This is just shorthand
	for `trove:Construct(Trove)`. This is useful for contexts where
	the trove object is present, but the class itself isn't.

	:::note
	This does _not_ clone the trove. In other words, the objects in the
	trove are not given to the new constructed trove. This is simply to
	construct a new Trove and add it as an object to track.
	:::

	```lua
	local trove = Trove.new()
	local subTrove = trove:Extend()

	trove:Clean() -- Cleans up the subTrove too
	```
]=]
function Trove.Extend(self: TroveInternal)
	if self._cleaning then
		error("cannot call trove:Extend() while cleaning", 2)
	end

	return self:Construct(Trove)
end

--[=[
	@method Clean
	@within Trove
	Cleans up all objects in the trove. This is
	similar to calling `Remove` on each object
	within the trove. The ordering of the objects
	removed is _not_ guaranteed.

	```lua
	trove:Clean()
	```
]=]
function Trove.Clean(self: TroveInternal)
	if self._cleaning then
		return
	end

	self._cleaning = true

	for _, obj in self._objects do
		self:_cleanupObject(obj[1], obj[2])
	end

	table.clear(self._objects)
	self._cleaning = false
end

--[=[
	@method WrapClean
	@within Trove
	Returns a function that wraps the trove's `Clean()`
	method. Calling the returned function will clean up
	the trove.

	This is often useful in contexts where functions
	are the primary mode for cleaning up an environment,
	such as in many "observer" patterns.

	```lua
	local cleanup = trove:WrapClean()

	-- Sometime later...
	cleanup()
	```

	```lua
	-- Common observer pattern example:
	someObserver(function()
		local trove = Trove.new()
		-- Foo
		return trove:WrapClean()
	end)
	```
]=]
function Trove.WrapClean(self: TroveInternal)
	return function()
		self:Clean()
	end
end

function Trove._findAndRemoveFromObjects(self: TroveInternal, object: any, cleanup: boolean): boolean
	local objects = self._objects

	for i, obj in objects do
		if obj[1] == object then
			local n = #objects
			objects[i] = objects[n]
			objects[n] = nil

			if cleanup then
				self:_cleanupObject(obj[1], obj[2])
			end

			return true
		end
	end

	return false
end

function Trove._cleanupObject(_self: TroveInternal, object: any, cleanupMethod: string?)
	if cleanupMethod == FN_MARKER then
		task.spawn(object)
	elseif cleanupMethod == THREAD_MARKER then
		pcall(task.cancel, object)
	else
		object[cleanupMethod](object)
	end
end

--[=[
	@method AttachToInstance
	@within Trove
	@param instance Instance
	@return RBXScriptConnection
	Attaches the trove to a Roblox instance. Once this
	instance is removed from the game (parent or ancestor's
	parent set to `nil`), the trove will automatically
	clean up.

	This inverses the ownership of the Trove object, and should
	only be used when necessary. In other words, the attached
	instance dictates when the trove is cleaned up, rather than
	the trove dictating the cleanup of the instance.

	:::caution
	Will throw an error if `instance` is not a descendant
	of the game hierarchy.
	:::

	```lua
	trove:AttachToInstance(somePart)
	trove:Add(function()
		print("Cleaned")
	end)

	-- Destroying the part will cause the trove to clean up, thus "Cleaned" printed:
	somePart:Destroy()
	```
]=]
function Trove.AttachToInstance(self: TroveInternal, instance: Instance)
	if self._cleaning then
		error("cannot call trove:AttachToInstance() while cleaning", 2)
	elseif not instance:IsDescendantOf(game) then
		error("instance is not a descendant of the game hierarchy", 2)
	end

	return self:Connect(instance.Destroying, function()
		self:Destroy()
	end)
end

--[=[
	@method Destroy
	@within Trove
	Alias for `trove:Clean()`.

	```lua
	trove:Destroy()
	```
]=]
function Trove.Destroy(self: TroveInternal)
	self:Clean()
end

return {
	new = Trove.new,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFD0A815B506944BAB1D911D3D5CA244B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TopbarPlus.lua</string>
						<string name="ScriptGuid">{1ADFD9E8-8F02-4D4B-B8DA-E9C36354F420}</string>
						<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	
	The majority of this code is an interface designed to make it easy for you to
	work with TopbarPlus (most methods for instance reference :modifyTheme()).
	The processing overhead mainly consists of applying themes and calculating 
	appearance (such as size and width of labels) which is handled in about
	200 lines of code here and the Widget UI module. This has been achieved
	in v3 by outsourcing a majority of previous calculations to inbuilt Roblox
	features like UIListLayouts.


	v3 provides inbuilt support for controllers (simply press DPadUp),
	touch devices (phones, tablets , etc), localization (automatic resizing
	of widgets, autolocalize for relevant labels), backwards compatability
	with the old topbar, and more.


	My primary goals for the v3 re-write have been to:
		
	1. Improve code readability and organisation (reduced lines of code within
	   Icon+IconController from 3200 to ~950, separated UI elements, etc)
		
	2. Improve ease-of-use (themes now actually make sense and can account
	   for any modifications you want, converted to a package for
	   quick installation and easy-comparisons of new updates, etc)
	
	3. Provide support for all key features of the new Roblox topbar
	   while improving performance of the module (deferring and collecting
	   changes then calling as a singular, utilizing inbuilt Roblox features
	   such as UILIstLayouts, etc)

--]]



-- SERVICES
local UserInputService = game:GetService("UserInputService")
local ContentProvider = game:GetService("ContentProvider")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local Types = require(script.Types)



-- TYPES
export type Icon = Types.Icon



-- REFERENCE HANDLER
-- Multiple Icons packages may exist at runtime (for instance if the developer additionally uses HD Admin)
-- therefore this ensures that the first required package becomes the dominant and only functioning module
local iconModule = script
local Reference = require(iconModule.Reference)
local referenceObject = Reference.getObject()
local leadPackage = referenceObject and referenceObject.Value
if leadPackage and leadPackage ~= iconModule then
	return require(leadPackage) :: Types.StaticIcon
end
if not referenceObject then
	Reference.addToReplicatedStorage()
end



-- MODULES
local Signal = require(iconModule.Packages.GoodSignal)
local Janitor = require(iconModule.Packages.Janitor)
local Utility = require(iconModule.Utility)
local Themes = require(iconModule.Features.Themes)
local Gamepad = require(iconModule.Features.Gamepad)
local Overflow = require(iconModule.Features.Overflow)
local Icon = {}
Icon.__index = Icon



--- LOCAL
local localPlayer = Players.LocalPlayer
local themes = iconModule.Features.Themes
local iconsDict = {}
local anyIconSelected = Signal.new()
local elements = iconModule.Elements
local totalCreatedIcons = 0



-- PUBLIC VARIABLES
Icon.baseDisplayOrderChanged = Signal.new()
Icon.baseDisplayOrder = 10
Icon.baseTheme = require(themes.Default)
Icon.isOldTopbar = false -- Logic has been moved to Container
Icon.iconsDictionary = iconsDict
Icon.insetHeightChanged = Signal.new()
Icon.container = require(elements.Container)(Icon)
Icon.topbarEnabled = true
Icon.iconAdded = Signal.new()
Icon.iconRemoved = Signal.new()
Icon.iconChanged = Signal.new()



-- PUBLIC FUNCTIONS
function Icon.getIcons()
	return Icon.iconsDictionary
end

function Icon.getIconByUID(UID)
	local match = Icon.iconsDictionary[UID]
	if match then
		return match
	end
	return nil
end

function Icon.getIcon(nameOrUID)
	local match = Icon.getIconByUID(nameOrUID)
	if match then
		return match
	end
	for _, icon in pairs(iconsDict) do
		if icon.name == nameOrUID then
			return icon
		end
	end
	return nil
end

function Icon.setTopbarEnabled(bool, isInternal)
	if typeof(bool) ~= "boolean" then
		bool = Icon.topbarEnabled
	end
	if not isInternal then
		Icon.topbarEnabled = bool
	end
	for _, screenGui in pairs(Icon.container) do
		screenGui.Enabled = bool
	end
end

function Icon.modifyBaseTheme(modifications)
	modifications = Themes.getModifications(modifications)
	for _, modification in pairs(modifications) do
		for _, detail in pairs(Icon.baseTheme) do
			Themes.merge(detail, modification)
		end
	end
	for _, icon in pairs(iconsDict) do
		icon:setTheme(Icon.baseTheme)
	end
end

function Icon.setDisplayOrder(int)
	Icon.baseDisplayOrder = int
	Icon.baseDisplayOrderChanged:Fire(int)
end



-- SETUP
task.defer(Gamepad.start, Icon)
task.defer(Overflow.start, Icon)
task.defer(function()
	local playerGui = localPlayer:WaitForChild("PlayerGui")
	for _, screenGui in pairs(Icon.container) do
		screenGui.Parent = playerGui
	end
	require(iconModule.Attribute)
end)



-- CONSTRUCTOR
function Icon.new()
	local self = {}
	setmetatable(self, Icon)

	--- Janitors (for cleanup)
	local janitor = Janitor.new()
	self.janitor = janitor
	self.themesJanitor = janitor:add(Janitor.new())
	self.singleClickJanitor = janitor:add(Janitor.new())
	self.captionJanitor = janitor:add(Janitor.new())
	self.joinJanitor = janitor:add(Janitor.new())
	self.menuJanitor = janitor:add(Janitor.new())
	self.dropdownJanitor = janitor:add(Janitor.new())

	-- Register
	local iconUID = Utility.generateUID()
	iconsDict[iconUID] = self
	janitor:add(function()
		iconsDict[iconUID] = nil
	end)

	-- Signals (events)
	self.selected = janitor:add(Signal.new())
	self.deselected = janitor:add(Signal.new())
	self.toggled = janitor:add(Signal.new())
	self.viewingStarted = janitor:add(Signal.new())
	self.viewingEnded = janitor:add(Signal.new())
	self.stateChanged = janitor:add(Signal.new())
	self.notified = janitor:add(Signal.new())
	self.noticeStarted = janitor:add(Signal.new())
	self.noticeChanged = janitor:add(Signal.new())
	self.endNotices = janitor:add(Signal.new())
	self.toggleKeyAdded = janitor:add(Signal.new())
	self.fakeToggleKeyChanged = janitor:add(Signal.new())
	self.alignmentChanged = janitor:add(Signal.new())
	self.updateSize = janitor:add(Signal.new())
	self.resizingComplete = janitor:add(Signal.new())
	self.joinedParent = janitor:add(Signal.new())
	self.menuSet = janitor:add(Signal.new())
	self.dropdownSet = janitor:add(Signal.new())
	self.updateMenu = janitor:add(Signal.new())
	self.startMenuUpdate = janitor:add(Signal.new())
	self.childThemeModified = janitor:add(Signal.new())
	self.indicatorSet = janitor:add(Signal.new())
	self.dropdownChildAdded = janitor:add(Signal.new())
	self.menuChildAdded = janitor:add(Signal.new())

	-- Properties
	self.iconModule = iconModule
	self.UID = iconUID
	self.isEnabled = true
	self.enabled = self.isEnabled -- Backwards compatability
	self.isSelected = false
	self.isViewing = false
	self.joinedFrame = false
	self.parentIconUID = false
	self.deselectWhenOtherIconSelected = true
	self.totalNotices = 0
	self.activeState = "Deselected"
	self.alignment = ""
	self.originalAlignment = ""
	self.appliedTheme = {}
	self.appearance = {}
	self.cachedInstances = {}
	self.cachedNamesToInstances = {}
	self.cachedCollectives = {}
	self.bindedToggleKeys = {}
	self.customBehaviours = {}
	self.toggleItems = {}
	self.bindedEvents = {}
	self.notices = {}
	self.menuIcons = {}
	self.dropdownIcons = {}
	self.childIconsDict = {}
	self.creationTime = os.clock()

	-- Widget is the new name for an icon
	local widget = janitor:add(require(elements.Widget)(self, Icon))
	self.widget = widget
	self:setAlignment()
	
	-- It's important we set an order otherwise icons will not align
	-- correctly within menus
	totalCreatedIcons += 1
	local ourOrder = 1+(totalCreatedIcons*0.01)
	self:setOrder(ourOrder, "deselected")
	self:setOrder(ourOrder, "selected")

	-- This applies the default them
	self:setTheme(Icon.baseTheme)

	-- Button Clicked (for states "Selected" and "Deselected")
	local clickRegion = self:getInstance("ClickRegion")
	local function handleToggle()
		if self.locked then
			return
		end
		if self.isSelected then
			self:deselect("User", self)
		else
			self:select("User", self)
		end
	end
	local isTouchTapping = false
	local isClicking = false
	clickRegion.MouseButton1Click:Connect(function()
		if isTouchTapping then
			return
		end
		isClicking = true
		task.delay(0.01, function()
			isClicking = false
		end)
		handleToggle()
	end)
	clickRegion.TouchTap:Connect(function()
		-- This resolves the bug report by @28Pixels:
		-- https://devforum.roblox.com/t/topbarplus/1017485/1104
		if isClicking then
			return
		end
		isTouchTapping = true
		task.delay(0.01, function()
			isTouchTapping = false
		end)
		handleToggle()
	end)

	-- Keys can be bound to toggle between Selected and Deselected
	janitor:add(UserInputService.InputBegan:Connect(function(input, touchingAnObject)
		if self.locked then
			return
		end
		if self.bindedToggleKeys[input.KeyCode] and not touchingAnObject then
			handleToggle()
		end
	end))

	-- Button Hovering (for state "Viewing")
	-- Hovering is a state only for devices with keyboards
	-- and controllers (not touchpads)
	local function viewingStarted(dontSetState)
		if self.locked then
			return
		end
		self.isViewing = true
		self.viewingStarted:Fire(true)
		if not dontSetState then
			self:setState("Viewing", "User", self)
		end
	end
	local function viewingEnded()
		if self.locked then
			return
		end
		self.isViewing = false
		self.viewingEnded:Fire(true)
		self:setState(nil, "User", self)
	end
	self.joinedParent:Connect(function()
		if self.isViewing then
			viewingEnded()
		end
	end)
	clickRegion.MouseEnter:Connect(function()
		local dontSetState = not UserInputService.KeyboardEnabled
		viewingStarted(dontSetState)
	end)
	local touchCount = 0
	janitor:add(UserInputService.TouchEnded:Connect(viewingEnded))
	clickRegion.MouseLeave:Connect(viewingEnded)
	clickRegion.SelectionGained:Connect(viewingStarted)
	clickRegion.SelectionLost:Connect(viewingEnded)
	clickRegion.MouseButton1Down:Connect(function()
		if not self.locked and UserInputService.TouchEnabled then
			touchCount += 1
			local myTouchCount = touchCount
			task.delay(0.2, function()
				if myTouchCount == touchCount then
					viewingStarted()
				end
			end)
		end
	end)
	clickRegion.MouseButton1Up:Connect(function()
		touchCount += 1
	end)

	-- Handle overlay on viewing
	local iconOverlay = self:getInstance("IconOverlay")
	self.viewingStarted:Connect(function()
		iconOverlay.Visible = not self.overlayDisabled
	end)
	self.viewingEnded:Connect(function()
		iconOverlay.Visible = false
	end)

	-- Deselect when another icon is selected
	janitor:add(anyIconSelected:Connect(function(incomingIcon)
		if incomingIcon ~= self and self.deselectWhenOtherIconSelected and incomingIcon.deselectWhenOtherIconSelected then
			self:deselect("AutoDeselect", incomingIcon)
		end
	end))

	-- This checks if the script calling this module is a descendant of a ScreenGui
	-- with 'ResetOnSpawn' set to true. If it is, then we destroy the icon the
	-- client respawns. This solves one of the most asked about questions on the post
	-- The only caveat this may not work if the player doesn't uniquely name their ScreenGui and the frames
	-- the LocalScript rests within
	local source =  debug.info(2, "s")
	local sourcePath = string.split(source, ".")
	local origin = game
	local originsScreenGui
	for i, sourceName in pairs(sourcePath) do
		origin = origin:FindFirstChild(sourceName)
		if not origin then
			break
		end
		if origin:IsA("ScreenGui") then
			originsScreenGui = origin
		end
	end
	if origin and originsScreenGui and originsScreenGui.ResetOnSpawn == true then
		self.originsScreenGui = originsScreenGui
		Utility.localPlayerRespawned(function()
			self:destroy()
		end)
	end

	-- Additional children behaviour when toggled (mostly notices)
	self.toggled:Connect(function(isSelected)
		self.noticeChanged:Fire(self.totalNotices)
		for childIconUID, _ in pairs(self.childIconsDict) do
			local childIcon = Icon.getIconByUID(childIconUID)
			childIcon.noticeChanged:Fire(childIcon.totalNotices)
			if not isSelected and childIcon.isSelected then
				-- If an icon within a menu or dropdown is also
				-- a dropdown or menu, then close it
				for _, _ in pairs(childIcon.childIconsDict) do
					childIcon:deselect("HideParentFeature", self)
				end
			end
		end
	end)
	
	-- This closes/reopens the chat or playerlist if the icon is a dropdown
	-- In the future I'd prefer to use the position+size of the chat
	-- to determine whether to close dropdown (instead of non-right-set)
	-- but for reasons mentioned here it's unreliable at the time of
	-- writing this: https://devforum.roblox.com/t/here/2794915
	-- I could also make this better by accounting for multiple
	-- dropdowns being open (not just this one) but this will work
	-- fine for almost every use case for now.
	self.selected:Connect(function()
		local isDropdown = #self.dropdownIcons > 0
		if isDropdown then
			if StarterGui:GetCore("ChatActive") and self.alignment ~= "Right" then
				self.chatWasPreviouslyActive = true
				StarterGui:SetCore("ChatActive", false)
			end
			if StarterGui:GetCoreGuiEnabled("PlayerList") and self.alignment ~= "Left" then
				self.playerlistWasPreviouslyActive = true
				StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
			end
		end
	end)
	self.deselected:Connect(function()
		if self.chatWasPreviouslyActive then
			self.chatWasPreviouslyActive = nil
			StarterGui:SetCore("ChatActive", true)
		end
		if self.playerlistWasPreviouslyActive then
			self.playerlistWasPreviouslyActive = nil
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
		end
	end)
	
	-- There's a rare occassion where the appearance is not
	-- fully set to deselected so this ensures the icons
	-- appearance is fully as it should be
	task.delay(0.1, function()
		if self.activeState == "Deselected" then
			self.stateChanged:Fire("Deselected")
			self:refresh()
		end
	end)
	
	-- Call icon added
	Icon.iconAdded:Fire(self)

	return self
end



-- METHODS
function Icon:setName(name)
	self.widget.Name = name
	self.name = name
	return self
end

function Icon:setState(incomingStateName, fromSource, sourceIcon)
	-- This is responsible for acknowleding a change in stage (such as from "Deselected" to "Viewing" when
	-- a users mouse enters the widget), then informing other systems of this state change to then act upon
	-- (such as the theme handler applying the theme which corresponds to that state).
	if not incomingStateName then
		incomingStateName = (self.isSelected and "Selected") or "Deselected"
	end
	local stateName = Utility.formatStateName(incomingStateName)
	local previousStateName = self.activeState
	if previousStateName == stateName then
		return
	end
	local currentIsSelected = self.isSelected
	self.activeState = stateName
	if stateName == "Deselected" then
		self.isSelected = false
		if currentIsSelected then
			self.toggled:Fire(false, fromSource, sourceIcon)
			self.deselected:Fire(fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(false, fromSource, sourceIcon)
	elseif stateName == "Selected" then
		self.isSelected = true
		if not currentIsSelected then
			self.toggled:Fire(true, fromSource, sourceIcon)
			self.selected:Fire(fromSource, sourceIcon)
			anyIconSelected:Fire(self, fromSource, sourceIcon)
		end
		self:_setToggleItemsVisible(true, fromSource, sourceIcon)
	end
	self.stateChanged:Fire(stateName, fromSource, sourceIcon)
end

function Icon:getInstance(name)
	-- This enables us to easily retrieve instances located within the icon simply by passing its name.
	-- Every important/significant instance is named uniquely therefore this is no worry of overlap.
	-- We cache the result for more performant retrieval in the future.
	local instance = self.cachedNamesToInstances[name]
	if instance then
		return instance
	end
	local function cacheInstance(childName, child)
		local currentCache = self.cachedInstances[child]
		if not currentCache then
			local collectiveName = child:GetAttribute("Collective")
			local cachedCollective = collectiveName and self.cachedCollectives[collectiveName]
			if cachedCollective then
				table.insert(cachedCollective, child)
			end
			self.cachedNamesToInstances[childName] = child
			self.cachedInstances[child] = true
			child.Destroying:Once(function()
				self.cachedNamesToInstances[childName] = nil
				self.cachedInstances[child] = nil
			end)
		end
	end
	local widget = self.widget
	cacheInstance("Widget", widget)
	if name == "Widget" then
		return widget
	end

	local returnChild
	local function scanChildren(parentInstance)
		for _, child in pairs(parentInstance:GetChildren()) do
			local widgetUID = child:GetAttribute("WidgetUID")
			if widgetUID and widgetUID ~= self.UID then
				-- This prevents instances within other icons from being recorded
				-- (for instance when other icons are added to this icons menu)
				continue
			end
			-- If the child is a fake placeholder instance (such as dropdowns, notices, etc)
			-- then its important we scan the real original instance instead of this clone
			local realChild = Themes.getRealInstance(child)
			if realChild then
				child = realChild
			end
			-- Finally scan its children
			scanChildren(child)
			if child:IsA("GuiBase") or child:IsA("UIBase") or child:IsA("ValueBase") then
				local childName = child.Name
				cacheInstance(childName, child)
				if childName == name then
					returnChild = child
				end
			end
		end
	end
	scanChildren(widget)
	return returnChild
end

function Icon:getCollective(name)
	-- A collective is an array of instances within the Widget that have been
	-- grouped together based on a given name. This just makes it easy
	-- to act on multiple instances at once which share similar behaviours.
	-- For instance, if we want to change the icons corner size, all corner instances
	-- with the attribute "Collective" and value "WidgetCorner" could be updated
	-- instantly by doing Themes.apply(icon, "WidgetCorner", newSize)
	local collective = self.cachedCollectives[name]
	if collective then
		return collective
	end
	collective = {}
	for instance, _ in pairs(self.cachedInstances) do
		if instance:GetAttribute("Collective") == name then
			table.insert(collective, instance)
		end
	end
	self.cachedCollectives[name] = collective
	return collective
end

function Icon:getInstanceOrCollective(collectiveOrInstanceName)
	-- Similar to :getInstance but also accounts for 'Collectives', such as UICorners and returns
	-- an array of instances instead of a single instance
	local instances = {}
	local instance = self:getInstance(collectiveOrInstanceName)
	if instance then
		table.insert(instances, instance)
	end
	if #instances == 0 then
		instances = self:getCollective(collectiveOrInstanceName)
	end
	return instances
end

function Icon:getStateGroup(iconState)
	local chosenState = iconState or self.activeState
	local stateGroup = self.appearance[chosenState]
	if not stateGroup then
		stateGroup = {}
		self.appearance[chosenState] = stateGroup
	end
	return stateGroup
end

function Icon:refreshAppearance(instance, specificProperty)
	Themes.refresh(self, instance, specificProperty)
	return self
end

function Icon:refresh()
	self:refreshAppearance(self.widget)
	self.updateSize:Fire()
	return self
end

function Icon:updateParent()
	local parentIcon = Icon.getIconByUID(self.parentIconUID)
	if parentIcon then
		parentIcon.updateSize:Fire()
	end
end

function Icon:setBehaviour(collectiveOrInstanceName, property, callback, refreshAppearance)
	-- You can specify your own custom callback to handle custom logic just before
	-- an instances property is changed by using :setBehaviour()
	local key = collectiveOrInstanceName.."-"..property
	self.customBehaviours[key] = callback
	if refreshAppearance then
		local instances = self:getInstanceOrCollective(collectiveOrInstanceName)
		for _, instance in pairs(instances) do
			self:refreshAppearance(instance, property)
		end
	end
end

function Icon:modifyTheme(modifications, customModificationUID)
	local modificationUID = Themes.modify(self, modifications, customModificationUID)
	return self, modificationUID
end

function Icon:modifyChildTheme(modifications, modificationUID)
	-- Same as modifyTheme except for its children (i.e. icons
	-- within its dropdown or menu)
	self.childModifications = modifications
	self.childModificationsUID = modificationUID
	for childIconUID, _ in pairs(self.childIconsDict) do
		local childIcon = Icon.getIconByUID(childIconUID)
		childIcon:modifyTheme(modifications, modificationUID)
	end
	self.childThemeModified:Fire()
	return self
end

function Icon:removeModification(modificationUID)
	Themes.remove(self, modificationUID)
	return self
end

function Icon:removeModificationWith(instanceName, property, state)
	Themes.removeWith(self, instanceName, property, state)
	return self
end

function Icon:setTheme(theme)
	Themes.set(self, theme)
	return self
end

function Icon:setEnabled(bool)
	self.isEnabled = bool
	self.enabled = self.isEnabled
	self.widget.Visible = bool
	self:updateParent()
	return self
end

function Icon:select(fromSource, sourceIcon)
	self:setState("Selected", fromSource, sourceIcon)
	return self
end

function Icon:deselect(fromSource, sourceIcon)
	self:setState("Deselected", fromSource, sourceIcon)
	return self
end

function Icon:notify(customClearSignal, noticeId)
	-- Generates a notification which appears in the top right of the icon. Useful for example for prompting
	-- users of changes/updates within your UI such as a Catalog
	-- 'customClearSignal' is a signal object (e.g. icon.deselected) or
	-- Roblox event (e.g. Instance.new("BindableEvent").Event)
	local notice = self.notice
	if not notice then
		notice = require(elements.Notice)(self, Icon)
		self.notice = notice
	end
	self.noticeStarted:Fire(customClearSignal, noticeId)
	return self
end

function Icon:clearNotices()
	self.endNotices:Fire()
	return self
end

function Icon:disableOverlay(bool)
	self.overlayDisabled = bool
	return self
end
Icon.disableStateOverlay = Icon.disableOverlay

function Icon:setImage(imageId, iconState)
	self:modifyTheme({"IconImage", "Image", imageId, iconState})
	
	-- This code ensures icon images are preloaded if they haven't been fetched yet
	task.spawn(function()
		local newIdContent = if tonumber(imageId) then `rbxassetid://{imageId}` else imageId
		local initialAssetFetchStatus = ContentProvider:GetAssetFetchStatus(newIdContent)
	
		if initialAssetFetchStatus ~= Enum.AssetFetchStatus.Success then
			pcall(ContentProvider.PreloadAsync, ContentProvider, { newIdContent })
		end
	end)
		
	return self
end

function Icon:setLabel(text, iconState)
	self:modifyTheme({"IconLabel", "Text", text, iconState})
	return self
end

function Icon:setOrder(int, iconState)
	-- We multiply by 100 to allow for custom increments inbetween
	-- (.01, .02, etc) as LayoutOrders only support integers
	local newInt = int*100
	self:modifyTheme({"IconSpot", "LayoutOrder", newInt, iconState})
	self:modifyTheme({"Widget", "LayoutOrder", newInt, iconState})
	return self
end

function Icon:setCornerRadius(udim, iconState)
	self:modifyTheme({"IconCorners", "CornerRadius", udim, iconState})
	return self
end

function Icon:align(leftCenterOrRight, isFromParentIcon)
	-- Determines the side of the screen the icon will be ordered
	local direction = tostring(leftCenterOrRight):lower()
	if direction == "mid" or direction == "centre" then
		direction = "center"
	end
	if direction ~= "left" and direction ~= "center" and direction ~= "right" then
		direction = "left"
	end
	local screenGui = (direction == "center" and Icon.container.TopbarCentered) or Icon.container.TopbarStandard
	local holders = screenGui.Holders
	local finalDirection = string.upper(string.sub(direction, 1, 1))..string.sub(direction, 2)
	if not isFromParentIcon then
		self.originalAlignment = finalDirection
	end
	local joinedFrame = self.joinedFrame
	local alignmentHolder = holders[finalDirection]
	self.screenGui = screenGui
	self.alignmentHolder = alignmentHolder
	if not self.isDestroyed then
		self.widget.Parent = joinedFrame or alignmentHolder
	end
	self.alignment = finalDirection
	self.alignmentChanged:Fire(finalDirection)
	Icon.iconChanged:Fire(self)
	return self
end
Icon.setAlignment = Icon.align

function Icon:setLeft()
	self:setAlignment("Left")
	return self
end

function Icon:setMid()
	self:setAlignment("Center")
	return self
end

function Icon:setRight()
	self:setAlignment("Right")
	return self
end

function Icon:setWidth(offsetMinimum, iconState)
	-- This sets a minimum X offset size for the widget, useful
	-- for example if you're constantly changing the label
	-- but don't want the icon to resize every time
	self:modifyTheme({"Widget", "DesiredWidth", offsetMinimum, iconState})
	return self
end

function Icon:setImageScale(number, iconState)
	self:modifyTheme({"IconImageScale", "Value", number, iconState})
	return self
end

function Icon:setImageRatio(number, iconState)
	self:modifyTheme({"IconImageRatio", "AspectRatio", number, iconState})
	return self
end

function Icon:setTextSize(number, iconState)
	self:modifyTheme({"IconLabel", "TextSize", number, iconState})
	return self
end

function Icon:setTextFont(font, fontWeight, fontStyle, iconState)
	fontWeight = fontWeight or Enum.FontWeight.Regular
	fontStyle = fontStyle or Enum.FontStyle.Normal
	local fontFace
	local fontType = typeof(font)
	if fontType == "number" then
		fontFace = Font.fromId(font, fontWeight, fontStyle)
	elseif fontType == "EnumItem" then
		fontFace = Font.fromEnum(font)
	elseif fontType == "string" then
		if not font:match("rbxasset") then
			fontFace = Font.fromName(font, fontWeight, fontStyle)
		end
	end
	if not fontFace then
		fontFace = Font.new(font, fontWeight, fontStyle)
	end
	self:modifyTheme({"IconLabel", "FontFace", fontFace, iconState})
	return self
end

function Icon:bindToggleItem(guiObjectOrLayerCollector)
	if not guiObjectOrLayerCollector:IsA("GuiObject") and not guiObjectOrLayerCollector:IsA("LayerCollector") then
		error("Toggle item must be a GuiObject or LayerCollector!")
	end
	self.toggleItems[guiObjectOrLayerCollector] = true
	self:_updateSelectionInstances()
	return self
end

function Icon:unbindToggleItem(guiObjectOrLayerCollector)
	self.toggleItems[guiObjectOrLayerCollector] = nil
	self:_updateSelectionInstances()
	return self
end

function Icon:_updateSelectionInstances()
	-- This is to assist with controller navigation and selection
	-- It converts the value true to an array
	for guiObjectOrLayerCollector, _ in pairs(self.toggleItems) do
		local buttonInstancesArray = {}
		for _, instance in pairs(guiObjectOrLayerCollector:GetDescendants()) do
			if (instance:IsA("TextButton") or instance:IsA("ImageButton")) and instance.Active then
				table.insert(buttonInstancesArray, instance)
			end
		end
		self.toggleItems[guiObjectOrLayerCollector] = buttonInstancesArray
	end
end

function Icon:_setToggleItemsVisible(bool, fromSource, sourceIcon)
	for toggleItem, _ in pairs(self.toggleItems) do
		if not sourceIcon or sourceIcon == self or sourceIcon.toggleItems[toggleItem] == nil then
			local property = "Visible"
			if toggleItem:IsA("LayerCollector") then
				property = "Enabled"
			end
			toggleItem[property] = bool
		end
	end
end

function Icon:bindEvent(iconEventName, eventFunction)
	local event = self[iconEventName]
	assert(event and typeof(event) == "table" and event.Connect, "argument[1] must be a valid topbarplus icon event name!")
	assert(typeof(eventFunction) == "function", "argument[2] must be a function!")
	self.bindedEvents[iconEventName] = event:Connect(function(...)
		eventFunction(self, ...)
	end)
	return self
end

function Icon:unbindEvent(iconEventName)
	local eventConnection = self.bindedEvents[iconEventName]
	if eventConnection then
		eventConnection:Disconnect()
		self.bindedEvents[iconEventName] = nil
	end
	return self
end

function Icon:bindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = true
	self.toggleKeyAdded:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:unbindToggleKey(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.bindedToggleKeys[keyCodeEnum] = nil
	return self
end

function Icon:call(callback, ...)
	local packedArgs = table.pack(...)
	task.spawn(function()
		callback(self, table.unpack(packedArgs))
	end)
	return self
end

function Icon:addToJanitor(callback, methodName, index)
	self.janitor:add(callback, methodName, index)
	return self
end

function Icon:lock()
	-- This disables all user inputs related to the icon (such as clicking buttons, pressing keys, etc)
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = false
	self.locked = true
	return self
end

function Icon:unlock()
	local clickRegion = self:getInstance("ClickRegion")
	clickRegion.Visible = true
	self.locked = false
	return self
end

function Icon:debounce(seconds)
	self:lock()
	task.wait(seconds)
	self:unlock()
	return self
end

function Icon:autoDeselect(bool)
	-- When set to true the icon will deselect itself automatically whenever
	-- another icon is selected
	if bool == nil then
		bool = true
	end
	self.deselectWhenOtherIconSelected = bool
	return self
end

function Icon:oneClick(bool)
	-- When set to true the icon will automatically deselect when selected, this creates
	-- the effect of a single click button
	local singleClickJanitor = self.singleClickJanitor
	singleClickJanitor:clean()
	if bool or bool == nil then
		singleClickJanitor:add(self.selected:Connect(function()
			self:deselect("OneClick", self)
		end))
	end
	self.oneClickEnabled = true
	return self
end

function Icon:setCaption(text)
	if text == "_hotkey_" and (self.captionText) then
		return self
	end
	local captionJanitor = self.captionJanitor
	self.captionJanitor:clean()
	if not text or text == "" then
		self.caption = nil
		self.captionText = nil
		return self
	end
	local caption = captionJanitor:add(require(elements.Caption)(self))
	caption:SetAttribute("CaptionText", text)
	self.caption = caption
	self.captionText = text
	return self
end

function Icon:setCaptionHint(keyCodeEnum)
	assert(typeof(keyCodeEnum) == "EnumItem", "argument[1] must be a KeyCode EnumItem!")
	self.fakeToggleKey = keyCodeEnum
	self.fakeToggleKeyChanged:Fire(keyCodeEnum)
	self:setCaption("_hotkey_")
	return self
end

function Icon:leave()
	local joinJanitor = self.joinJanitor
	joinJanitor:clean()
	return self
end

function Icon:joinMenu(parentIcon)
	Utility.joinFeature(self, parentIcon, parentIcon.menuIcons, parentIcon:getInstance("Menu"))
	parentIcon.menuChildAdded:Fire(self)
	return self
end

function Icon:setMenu(arrayOfIcons)
	self.menuSet:Fire(arrayOfIcons)
	return self
end

function Icon:setFrozenMenu(arrayOfIcons)
	self:freezeMenu(arrayOfIcons)
	self:setMenu(arrayOfIcons)
end

function Icon:freezeMenu()
	-- A frozen menu is a menu which is permanently locked in the
	-- the selected state (with its toggle hidden)
	self:select("FrozenMenu", self)
	self:bindEvent("deselected", function(icon)
		icon:select("FrozenMenu", self)
	end)
	self:modifyTheme({"IconSpot", "Visible", false})
end

function Icon:joinDropdown(parentIcon)
	parentIcon:getDropdown()
	Utility.joinFeature(self, parentIcon, parentIcon.dropdownIcons, parentIcon:getInstance("DropdownScroller"))
	parentIcon.dropdownChildAdded:Fire(self)
	return self
end

function Icon:getDropdown()
	local dropdown = self.dropdown
	if not dropdown then
		dropdown = require(elements.Dropdown)(self)
		self.dropdown = dropdown
		self:clipOutside(dropdown)
	end
	return dropdown
end

function Icon:setDropdown(arrayOfIcons)
	self:getDropdown()
	self.dropdownSet:Fire(arrayOfIcons)
	return self
end

function Icon:clipOutside(instance)
	-- This is essential for items such as notices and dropdowns which will exceed the bounds of the widget. This is an issue
	-- because the widget must have ClipsDescendents enabled to hide items for instance when the menu is closing or opening.
	-- This creates an invisible frame which matches the size and position of the instance, then the instance is parented outside of
	-- the widget and tracks the clone to match its size and position. In order for themes, etc to work the applying system checks
	-- to see if an instance is a clone, then if it is, it applies it to the original instance instead of the clone.
	local instanceClone = Utility.clipOutside(self, instance)
	self:refreshAppearance(instance)
	return self, instanceClone
end

function Icon:setIndicator(keyCode)
	-- An indicator is a direction button prompt with an image of the given keycode. This is useful for instance
	-- with controllers to show the user what button to press to highlight the topbar. You don't need
	-- to set an indicator for controllers as this is handled internally within the Gamepad module
	local indicator = self.indicator
	if not indicator then
		indicator = self.janitor:add(require(elements.Indicator)(self, Icon))
		self.indicator = indicator
	end
	self.indicatorSet:Fire(keyCode)
end

function Icon:convertLabelToNumberSpinner(numberSpinner, callback)
	task.defer(function()
		
		local label = self:getInstance("IconLabel")
		label.Transparency = 1
		numberSpinner.Parent = label.Parent
		numberSpinner.Size = UDim2.fromScale(1, 1)
		numberSpinner.AnchorPoint = Vector2.new(0.5, 0.5)
		numberSpinner.Position = UDim2.new(0.5, 0, 0.5, 0)
		numberSpinner.TextXAlignment = Enum.TextXAlignment.Center
		numberSpinner.ClipsDescendants = false

		local propertiesToChangeLabel = {
			"FontFace",
			"BorderSizePixel",
			"BorderColor3",
			"Rotation",
			"TextStrokeTransparency",
			"TextStrokeColor3",
			"TextStrokeTransparency",
			"TextColor3",
		}
		for _, property in ipairs(propertiesToChangeLabel) do
			numberSpinner[property] = label[property]
			self:addToJanitor(label:GetPropertyChangedSignal(property):Connect(function()
				numberSpinner[property] = label[property]
			end))
		end

		local minDigits = 0
		local maxDigits = 8
		local function getSpinnerSizeAndDigitCount()
			local TotalSize = 0
			local numOfDigits = 0
			for i, child in numberSpinner.Frame:GetChildren() do
				local name = string.lower(child.Name)
				if name == "digit" then
					TotalSize += child.AbsoluteSize.X
					numOfDigits += 1
				elseif name == "prefix" or name == "suffix" or name == "comma" then
					if child.Text ~= "" then
						TotalSize += child.AbsoluteSize.X
						numOfDigits += 1
					end
				end
			end
			return TotalSize, numOfDigits
		end
		
		local function getLabelParentContainerXSize()
			local firstParent = label.Parent
			local nextParent = firstParent and firstParent.Parent
			if nextParent == nil then
				return 0
			end
			if nextParent.IconImage.Visible == true then
				return numberSpinner.Frame.AbsoluteSize.X + label.Parent.Parent.IconImage.AbsoluteSize.X
			else
				return nextParent.AbsoluteSize.X
			end
		end
		local function getNumberSpinnerXSize()
			return numberSpinner.Frame.AbsoluteSize.X
		end

		local function adjustSize()
			local totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			if numOfDigits < 18 then
				self:setLabel(numberSpinner.Value)
			end

			local NumberSpinnerXSize = getNumberSpinnerXSize()

			while totalDigitXSize < NumberSpinnerXSize and self.isDestroyed ~= true do
				task.wait(0.05)
				if numOfDigits > minDigits and numOfDigits < maxDigits then
					numberSpinner.TextSize = label.TextSize
					break
				else
					numberSpinner.TextSize += 1
				end

				NumberSpinnerXSize = getNumberSpinnerXSize()
				totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			end

			local labelParentContainerXSize = getLabelParentContainerXSize()
			while totalDigitXSize > labelParentContainerXSize and self.isDestroyed ~= true do
				task.wait(0.05)
				if numOfDigits < maxDigits and numOfDigits > minDigits then
					numberSpinner.TextSize = label.TextSize
					break
				else
					numberSpinner.TextSize -= 1
				end

				labelParentContainerXSize = getLabelParentContainerXSize()
				totalDigitXSize, numOfDigits = getSpinnerSizeAndDigitCount()
			end
		end

		self:addToJanitor(numberSpinner.Frame.ChildAdded:Connect(adjustSize))
		self:addToJanitor(numberSpinner.Frame.ChildRemoved:Connect(adjustSize))
		self:addToJanitor(self.iconAdded:Connect(function()
			task.wait(1)
			adjustSize()
		end))

		self:updateParent()

		-- This corrects text to the size of a normal label
		numberSpinner.Name = "LabelSpinner"
		numberSpinner.Prefix = "$"
		numberSpinner.Commas = true
		numberSpinner.Decimals = 0
		numberSpinner.Duration = 0.25
		numberSpinner.Value = 10
		task.wait(0.2)
		
		if typeof(callback) == "function" then
			callback()
		end
		
	end)
	return self
end



-- DESTROY/CLEANUP
function Icon:destroy()
	if self.isDestroyed then
		return
	end
	self:clearNotices()
	if self.parentIconUID then
		self:leave()
	end
	self.isDestroyed = true
	self.janitor:clean()
	Icon.iconRemoved:Fire(self)
end
Icon.Destroy = Icon.destroy

return Icon :: Types.StaticIcon]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX31694C4EB3BD428CBB6C2254435A1AE7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">TopbarPlus</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX7411B4454A0745F5A463A386CE5465ED">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Attribute.lua</string>
							<string name="ScriptGuid">{8DDD530B-CDD3-471F-82D9-F986F3A8AF51}</string>
							<ProtectedString name="Source"><![CDATA[--[[

	TopbarPlus was developed by ForeverHD and is possible thanks to HD Admin.

	By using TopbarPlus in your experience or application, you agree to either:
		1. Keep Attribute unchanged, or
		2. If an experience, to credit TopbarPlus in your description, or in a
		   devforum post linked from your experience's description.

	v3 has involved over 350 hours of work to develop, so please consider supporting
	its development by reporting any issues or feedback you have at its repository:
	https://github.com/1ForeverHD/TopbarPlus

	You can get in touch with me on Discord via the social link here:
	https://create.roblox.com/store/asset/92368439343389/TopbarPlus

	Many thanks! ~Ben, June 10th 2025
	
]]

task.defer(function()
	local RunService = game:GetService("RunService")
	local VERSION = require(script.Parent.VERSION)
	local appVersion = VERSION.getAppVersion()
	local latestVersion = VERSION.getLatestVersion()
	local isOutdated = not VERSION.isUpToDate()
	if not RunService:IsStudio() then
		print(` Running TopbarPlus {appVersion} by @ForeverHD & HD Admin`)
	end
	if isOutdated then
		warn(`A new version of TopbarPlus ({latestVersion}) is available: https://devforum.roblox.com/t/topbarplus/1017485`)
	end
end)

return {}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXCBB84FFF52D147EBAB5BD844B88B2183">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Reference.lua</string>
							<string name="ScriptGuid">{871FC705-D725-447E-985A-6308F8C47529}</string>
							<ProtectedString name="Source"><![CDATA[-- This module enables you to place Icon wherever you like within the data model while
-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
-- This is necessary to prevent two TopbarPlus applications initiating at runtime which would
-- cause icons to overlap with each other

local replicatedStorage = game:GetService("ReplicatedStorage")
local Reference = {}
Reference.objectName = "TopbarPlusReference"

function Reference.addToReplicatedStorage()
	local existingItem = replicatedStorage:FindFirstChild(Reference.objectName)
    if existingItem then
        return false
    end
    local objectValue = Instance.new("ObjectValue")
	objectValue.Name = Reference.objectName
    objectValue.Value = script.Parent
    objectValue.Parent = replicatedStorage
    return objectValue
end

function Reference.getObject()
	local objectValue = replicatedStorage:FindFirstChild(Reference.objectName)
    if objectValue then
        return objectValue
    end
    return false
end

return Reference]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA3A5747E0F604FE79D6977CE8C9DFFB9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Types.lua</string>
							<string name="ScriptGuid">{F43B736A-E065-4339-9505-9BEE80C8599D}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

-- GoodSignal Types (...but simpler!)

--- Connection

type Connection<Variant... = ...any> = {
	Disconnect: (self: Connection<Variant...>) -> (),
}

--- Signal

type Signal<Variant... = ...any> = {
	Connect: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
    Once: (self: Signal<Variant...>, func: (Variant...) -> ()) -> Connection<Variant...>,
	Wait: (self: Signal<Variant...>) -> Variant...,
}

----------------------

export type IconState = "Deselected" | "Selected" | "Viewing"
export type Events = "selected" | "deselected" | "toggled" | "viewingStarted" | "viewingEnded" | "notified"
export type Alignment = "Left" | "Center" | "Right"
export type EventSource = "User" | "OneClick" | "AutoDeselect" | "HideParentFeature" | "Overflow"
export type Modification = { any }


type StaticFunctions = {
	getIcons: typeof(
		--[[
			Returns a dictionary of icons where the key is the icon's UID and value the icon.
		]]
		function(): { Icon }
			return (nil :: any) :: { Icon }
		end
	),
	getIcon: typeof(
		--[[
			Returns an icon of the given name or UID.
		]]
		function(nameOrUID: string): Icon?
			return nil :: any
		end
	),
	setTopbarEnabled: typeof(
		--[[
			When set to <code>false</code> all TopbarPlus ScreenGuis are hidden.
			This does not impact Roblox's Topbar.
		]]
		function(enabled: boolean)

		end
	),
	modifyBaseTheme: typeof(
		--[[
			Updates the appearance of all icons.
		]]
		function(modifications: { Modification })

		end
	),
	setDisplayOrder: typeof(
		--[[
			Sets the base DisplayOrder of all TopbarPlus ScreenGuis.
		]]
		function(order: number)

		end
	),
}

local MT = {} :: Methods
type Methods = {
	__index: typeof(MT),
	
	-- CLASS FUNCTIONS
	setName: typeof(
		--[[
			Sets the name of the Widget instance. This can be used in conjunction with <code>Icon.getIcon(name)</code>
		]]
		function(self: Icon, name: string): Icon
			return nil :: any
		end
	),
	getInstance: typeof(
		--[[
			Returns the first descendant found within the widget of name <code>instanceName</code>.
		]]
		function(self: Icon, instanceName: string): Instance?
			return (nil :: any) :: Instance?
		end
	),
	modifyTheme: typeof(
		--[[
			Updates the appearance of the icon.
		]]
		function(self: Icon, modifications: {Modification} | Modification): Icon
			return nil :: any
		end
	),
	modifyChildTheme: typeof(
		--[[
			Updates the appearance of all icons that are parented to this icon (for example when a menu or dropdown).
		]]
		function(self: Icon, modifications: { Modification }): Icon
			return nil :: any
		end
	),
	setEnabled: typeof(
		--[[
			When set to <code>false</code> the icon will be disabled and hidden.
		]]
		function(self: Icon, enabled: boolean): Icon
			return nil :: any
		end
	),
	select: typeof(
		--[[
			Selects the icon (as if it were clicked once).
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	deselect: typeof(
		--[[
			Deselects the icon (as if it were clicked, then clicked again).
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	notify: typeof(
		--[[
			Prompts a notice bubble which accumulates the further it is prompted.
			If the icon belongs to a dropdown or menu, then the notice will appear on the parent icon when the parent icon is deselected.
		]]
		function(self: Icon, clearNoticeEvent: Signal?): Icon
			return nil :: any
		end
	),
	clearNotices: typeof(
		--[[
			
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	disableOverlay: typeof(
		--[[
			When set to <code>true</code>, disables the shade effect which appears when the icon is pressed and released.
		]]
		function(self: Icon, disabled: boolean): Icon
			return nil :: any
		end
	),
	setImage: typeof(
		--[[
			Applies an image to the icon based on the given <code>imageId</code>. <code>imageId</code> can be an assetId or a complete asset string.
		]]
		function(self: Icon, imageId: string | number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setLabel: typeof(
		--[[
			
		]]
		function(self: Icon, text: string, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setOrder: typeof(
		--[[
			
		]]
		function(self: Icon, order: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setCornerRadius: typeof(
		--[[
			
		]]
		function(self: Icon, udim: UDim2, iconState: IconState?): Icon
			return nil :: any
		end
	),
	align: typeof(
		--[[
			This enables you to set the icon to the <code>"Left"</code> (default), <code>"Center"</code> or <code>"Right"</code> side of the screen.
		]]
		function(self: Icon, alignment: Alignment?): Icon
			return nil :: any
		end
	),
	setWidth: typeof(
		--[[
			This sets the minimum width the icon can be (it can be larger for instance when setting a long label). The default width is <code>44</code>.
		]]
		function(self: Icon, minimumSize: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setImageScale: typeof(
		--[[
			How large the image is relative to the icon. The default value is <code>0.5</code>.
		]]
		function(self: Icon, scale: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setImageRatio: typeof(
		--[[
			How stretched the image will appear. The default value is <code>1</code> (a perfect square).
		]]
		function(self: Icon, ratio: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextSize: typeof(
		--[[
			The size of the icon labels' text. The default value is <code>16</code>.
		]]
		function(self: Icon, textSize: number, iconState: IconState?): Icon
			return nil :: any
		end
	),
	setTextFont: typeof(
		--[[
			Sets the labels FontFace.
			<code>font</code> can be a font family name (such as <code>"Creepster"</code>),
			a font enum (such as <code>Enum.Font.Bangers</code>),
			a font ID (such as <code>12187370928</code>),
			or font family link (such as <code>"rbxasset://fonts/families/Sarpanch.json"</code>).
		]]
		function(self: Icon, font: string | Enum.Font, fontWeight: Enum.FontWeight?, fontStyle: Enum.FontSize?, iconState: IconState?): Icon
			return nil :: any
		end
	),
	bindToggleItem: typeof(
		--[[
			Binds a GuiObject or LayerCollector to appear and disappeared when the icon is toggled.
		]]
		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
			return nil :: any
		end
	),
	unbindToggleItem: typeof(
		--[[
			Unbinds the given GuiObject or LayerCollector from the toggle.
		]]
		function(self: Icon, guiObjectOrLayerCollector: GuiObject | LayerCollector): Icon
			return nil :: any
		end
	),
	bindEvent: typeof(
		--[[
			Connects to an icon event with <code>iconEventName</code>.
			It's important to remember all event names are in <code>camelCase</code>.
			<code>callback</code> is called with arguments <code>(self, ...)</code> when the event is triggered.
		]]
		function(self: Icon, event: Events, callback: (...any) -> ()): Icon
			return nil :: any
		end
	),
	unbindEvent: typeof(
		--[[
			Unbinds the connection of the associated <code>iconEventName</code>.
		]]
		function(self: Icon, event: Events): Icon
			return nil :: any
		end
	),
	bindToggleKey: typeof(
		--[[
			Binds a keycode which toggles the icon when pressed.
		]]
		function(self: Icon, keycode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	unbindToggleKey: typeof(
		--[[
			Unbinds the given keycode.
		]]
		function(self: Icon, keycode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	call: typeof(
		--[[
			Calls the function immediately via <code>task.spawn</code>.
			The first argument passed is the icon itself.
			This is useful when needing to extend the behaviour of an icon while remaining in the chain.
		]]
		function(self: Icon, func: (self: Icon) -> (...any), ...: any): Icon
			return nil :: any
		end
	),
	addToJanitor: typeof(
		--[[
			Passes the given userdata to the icons janitor to be destroyed/disconnected on the icons destruction.
			If a function is passed, it will be called when the icon is destroyed.
		]]
		function(self: Icon, userdata: unknown): Icon
			return nil :: any
		end
	),
	lock: typeof(
		--[[
			Prevents the icon being toggled by user-input (such as clicking), however, the icon can still be toggled via localscript using methods such as <code>icon:select()</code>.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	unlock: typeof(
		--[[
			Re-enables user-input to toggle the icon again.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	debounce: typeof(
		--[[
			Locks the icon, yields for the given time, then unlocks the icon, effectively shorthand for <code>icon:lock() task.wait(seconds) icon:unlock()</code>.
			This is useful for applying cooldowns (to prevent an icon from being pressed again) after an icon has been selected or deselected.
		]]
		function(self: Icon, seconds: number): Icon
			return nil :: any
		end
	),
	autoDeselect: typeof(
		--[[
			When set to <code>true</code> (the default) the icon is deselected when another icon (with autoDeselect enabled) is pressed.
			Set to <code>false</code> to prevent the icon being deselected when another icon is selected (a useful behaviour in dropdowns).
		]]
		function(self: Icon, enabled: boolean?): Icon
			return nil :: any
		end
	),
	oneClick: typeof(
		--[[
			When set to true the icon will automatically deselect when selected.
			This creates the effect of a single click button.
		]]
		function(self: Icon, enabled: boolean?): Icon
			return nil :: any
		end
	),
	setCaption: typeof(
		--[[
			Sets a caption. To remove, pass <code>nil</code> as <code>text</code>.
		]]
		function(self: Icon, text: string?): Icon
			return nil :: any
		end
	),
	setCaptionHint: typeof(
		--[[
			This customizes the appearance of the caption's hint without having to use <code>icon:bindToggleKey</code>.
		]]
		function(self: Icon, keyCode: Enum.KeyCode): Icon
			return nil :: any
		end
	),
	setDropdown: typeof(
		--[[
			Creates a vertical dropdown based upon the given table array of icons.
			Pass an empty table <code>{}</code> to remove the dropdown.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	joinDropdown: typeof(
		--[[
			Joins the dropdown of <code>parentIcon</code>.
			This is what <code>icon:setDropdown</code> calls internally on the icons within its array.
		]]
		function(self: Icon, parent: Icon): Icon
			return nil :: any
		end
	),
	setMenu: typeof(
		--[[
			Creates a horizontal menu based upon the given array of icons.
			Pass an empty table <code>{}</code> to remove the menu.
		]]
		function(self: Icon, icons: { Icon }): Icon
			return nil :: any
		end
	),
	joinMenu: typeof(
		--[[
			Joins the menu of <code>parentIcon</code>.
			This is what <code>icon:setMenu</code> calls internally on the icons within its array.
		]]
		function(self: Icon, parentIcon: Icon): Icon
			return nil :: any
		end
	),
	leave: typeof(
		--[[
			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
	convertLabelToNumberSpinner: typeof(
		--[[
			Unparents an icon from a parentIcon if it belongs to a dropdown or menu.
		]]
		function(self: Icon, numberSpinner: any, func: (...any) -> (...any), ...: any): Icon
			return nil :: any
		end
	),
	destroy: typeof(
		--[[
			Clears all connections and destroys all instances associated with the icon.
		]]
		function(self: Icon): Icon
			return nil :: any
		end
	),
} & StaticFunctions

type Fields = {
	-- CLASS PROPERTIES
	name: string,
	isSelected: boolean,
	isEnabled: boolean,
	totalNotices: number,
	locked: boolean,

	-- CLASS EVENTS
	selected: Signal<EventSource>,
	deselected: Signal<EventSource>,
	toggled: Signal<boolean, EventSource>,
	viewingStarted: Signal,
	viewingEnded: Signal,
	notified: Signal,
}

export type Icon = typeof(setmetatable({} :: Fields, MT))

export type StaticIcon = {
	new: typeof(
		--[[
			Constructs an empty <code>32x32</code> icon on the topbar.
		]]
		function(): Icon
			return nil :: any
		end
	),
} & StaticFunctions

return {}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA319975CE629495DB39EF0B5B4F7F5E4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Utility.lua</string>
							<string name="ScriptGuid">{89EEBA50-AD8B-4029-B84A-1397039CDDD0}</string>
							<ProtectedString name="Source"><![CDATA[-- Just generic utility functions which I use and repeat across all my projects



-- LOCAL
local Utility = {}
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer



-- FUNCTIONS
function Utility.createStagger(delayTime, callback, delayInitially)
	-- This creates and returns a function which when called
	-- acts identically to callback, however will only be called
	-- for a maximum of once per delayTime. If the returned function
	-- is called more than once during the delayTime, then it will
	-- wait until the expiryTime then perform another recall.
	-- This is useful for visual interfaces and effects which may be
	-- triggered multiple times within a frame or short period, but which
	-- we don't necessary need to (for performance reasons).
	local staggerActive = false
	local multipleCalls = false
	if not delayTime or delayTime == 0 then
		-- We make 0.01 instead of 0 because devices can now run at
		-- different frame rates
		delayTime = 0.01
	end
	local function staggeredCallback(...)
		if staggerActive then
			multipleCalls = true
			return
		end
		local packedArgs = table.pack(...)
		staggerActive = true
		multipleCalls = false
		task.spawn(function()
			if delayInitially then
				task.wait(delayTime)
			end
			callback(table.unpack(packedArgs))
		end)
		task.delay(delayTime, function()
			staggerActive = false
			if multipleCalls then
				-- This means it has been called at least once during
				-- the stagger period, so call again
				staggeredCallback(table.unpack(packedArgs))
			end
		end)
	end
	return staggeredCallback
end

function Utility.round(n)
	-- Credit to Darkmist101 for this
	return math.floor(n + 0.5)
end

function Utility.reverseTable(t)
	for i = 1, math.floor(#t/2) do
		local j = #t - i + 1
		t[i], t[j] = t[j], t[i]
	end
end

function Utility.copyTable(t)
	-- Credit to Stephen Leitnick (September 13, 2017) for this function from TableUtil
	assert(type(t) == "table", "First argument must be a table")
	local tCopy = table.create(#t)
	for k,v in pairs(t) do
		if (type(v) == "table") then
			tCopy[k] = Utility.copyTable(v)
		else
			tCopy[k] = v
		end
	end
	return tCopy
end

local validCharacters = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9","0","<",">","?","@","{","}","[","]","!","(",")","=","+","~","#"}
function Utility.generateUID(length)
	length = length or 8
	local UID = ""
	local list = validCharacters
	local total = #list
	for i = 1, length do
		local randomCharacter = list[math.random(1, total)]
		UID = UID..randomCharacter
	end
	return UID
end

local instanceTrackers = {}
function Utility.setVisible(instance, bool, sourceUID)
	-- This effectively works like a buff object but
	-- incredibly simplified. It stacks false values
	-- so that if there is more than more than, the 
	-- instance remains hidden even if set visible true
	local tracker = instanceTrackers[instance]
	if not tracker then
		tracker = {}
		instanceTrackers[instance] = tracker
		instance.Destroying:Once(function()
			instanceTrackers[instance] = nil
		end)
	end
	if not bool then
		tracker[sourceUID] = true
	else
		tracker[sourceUID] = nil
	end
	local isVisible = bool
	if bool then
		for sourceUID, _ in pairs(tracker) do
			isVisible = false
			break
		end
	end
	instance.Visible = isVisible
end

function Utility.formatStateName(incomingStateName)
	return string.upper(string.sub(incomingStateName, 1, 1))..string.lower(string.sub(incomingStateName, 2))
end

function Utility.localPlayerRespawned(callback)
	-- The client localscript may be located under a ScreenGui with ResetOnSpawn set to true
	-- In these scenarios, traditional methods like CharacterAdded won't be called by the
	-- time the localscript has been destroyed, therefore we listen for removing instead
	-- If humanoid and health == 0, then reset/died normally, else was
	-- forcefully reset via a method such as LoadCharacter
	-- We wrap this behaviour in case any additional quirks need to be accounted for
	localPlayer.CharacterRemoving:Connect(callback)
end

function Utility.getClippedContainer(screenGui)
	-- We always want clipped items to display in front hence
	-- why we have this
	local clippedContainer = screenGui:FindFirstChild("ClippedContainer")
	if not clippedContainer then
		clippedContainer = Instance.new("Folder")
		clippedContainer.Name = "ClippedContainer"
		clippedContainer.Parent = screenGui
	end
	return clippedContainer
end

local Janitor = require(script.Parent.Packages.Janitor)
local GuiService = game:GetService("GuiService")
function Utility.clipOutside(icon, instance)
	local cloneJanitor = icon.janitor:add(Janitor.new())
	instance.Destroying:Once(function()
		cloneJanitor:Destroy()
	end)
	icon.janitor:add(instance)

	local originalParent = instance.Parent
	local clone = cloneJanitor:add(Instance.new("Frame"))
	clone:SetAttribute("IsAClippedClone", true)
	clone.Name = instance.Name
	clone.AnchorPoint = instance.AnchorPoint
	clone.Size = instance.Size
	clone.Position = instance.Position
	clone.BackgroundTransparency = 1
	clone.LayoutOrder = instance.LayoutOrder
	clone.Parent = originalParent

	local valueInstance = Instance.new("ObjectValue")
	valueInstance.Name = "OriginalInstance"
	valueInstance.Value = instance
	valueInstance.Parent = clone

	local valueInstanceCopy = valueInstance:Clone()
	instance:SetAttribute("HasAClippedClone", true)
	valueInstanceCopy.Name = "ClippedClone"
	valueInstanceCopy.Value = clone
	valueInstanceCopy.Parent = instance

	local screenGui
	local Icon = require(icon.iconModule)
	local container = Icon.container
	local function updateScreenGui()
		local originalScreenGui = originalParent:FindFirstAncestorWhichIsA("ScreenGui")
		screenGui = if string.match(originalScreenGui.Name, "Clipped") then originalScreenGui else container[originalScreenGui.Name.."Clipped"]
		instance.AnchorPoint = Vector2.new(0, 0)
		instance.Parent = Utility.getClippedContainer(screenGui)
	end
	cloneJanitor:add(icon.alignmentChanged:Connect(updateScreenGui))
	updateScreenGui()

	-- Lets copy over children that modify size
	for _, child in pairs(instance:GetChildren()) do
		if child:IsA("UIAspectRatioConstraint") then
			child:Clone().Parent = clone
		end
	end

	-- If the icon is hidden, its important we are too (as
	-- setting a parent to visible = false no longer makes
	-- this hidden)
	local widget = icon.widget
	local isOutsideParent = false
	local ignoreVisibilityUpdater = instance:GetAttribute("IgnoreVisibilityUpdater")
	local function updateVisibility()
		if ignoreVisibilityUpdater then
			return
		end
		local isVisible = widget.Visible
		if isOutsideParent then
			isVisible = false
		end
		Utility.setVisible(instance, isVisible, "ClipHandler")
	end
	cloneJanitor:add(widget:GetPropertyChangedSignal("Visible"):Connect(updateVisibility))

	local previousScroller
	local function checkIfOutsideParentXBounds()
		-- Defer so that roblox's properties reflect their true values
		task.defer(function()
			-- If the instance is within a parent item (such as a dropdown or menu)
			-- then we hide it if it exceeds the bounds of that parent
			local parentInstance
			local ourUID = icon.UID
			local nextIconUID = ourUID
			local shouldClipToParent = instance:GetAttribute("ClipToJoinedParent")
			if shouldClipToParent then
				for i = 1, 10 do -- This is safer than while true do and should never be > 4 parents
					local nextIcon = Icon.getIconByUID(nextIconUID)
					if not nextIcon then
						break
					end
					local nextParentInstance = nextIcon.joinedFrame
					nextIconUID = nextIcon.parentIconUID
					if not nextParentInstance then
						break
					end
					parentInstance = nextParentInstance
					if parentInstance and parentInstance.Name == "DropdownScroller" then
						break
					end
				end
			end
			if not parentInstance then
				isOutsideParent = false
				updateVisibility()
				return
			end
			local pos = instance.AbsolutePosition
			local halfSize = instance.AbsoluteSize/2
			local parentPos = parentInstance.AbsolutePosition
			local parentSize = parentInstance.AbsoluteSize
			local posHalf = (pos + halfSize)
			local exceededLeft = posHalf.X < parentPos.X
			local exceededRight = posHalf.X > (parentPos.X + parentSize.X)
			local exceededTop = posHalf.Y < parentPos.Y
			local exceededBottom = posHalf.Y > (parentPos.Y + parentSize.Y)
			local hasExceeded = exceededLeft or exceededRight or exceededTop or exceededBottom
			if hasExceeded ~= isOutsideParent then
				isOutsideParent = hasExceeded
				updateVisibility()
			end
			if parentInstance:IsA("ScrollingFrame") and previousScroller ~= parentInstance then
				previousScroller = parentInstance
				local connection = parentInstance:GetPropertyChangedSignal("AbsoluteWindowSize"):Connect(function()
					checkIfOutsideParentXBounds()
				end)
				cloneJanitor:add(connection, "Disconnect", "TrackUtilityScroller-"..ourUID)
			end
		end)
	end

	local camera = workspace.CurrentCamera
	local additionalOffsetX = instance:GetAttribute("AdditionalOffsetX") or 0
	local function trackProperty(property)
		local absoluteProperty = "Absolute"..property
		local function updateProperty()
			local cloneValue = clone[absoluteProperty]
			local absoluteValue = UDim2.fromOffset(cloneValue.X, cloneValue.Y)
			if property == "Position" then

				-- This binds the instances within the bounds of the screen
				local SIDE_PADDING = 4
				local limitX = camera.ViewportSize.X - instance.AbsoluteSize.X - SIDE_PADDING
				local inputX = absoluteValue.X.Offset
				if inputX < SIDE_PADDING then
					inputX = SIDE_PADDING
				elseif inputX > limitX then
					inputX = limitX
				end
				absoluteValue = UDim2.fromOffset(inputX, absoluteValue.Y.Offset)

				-- AbsolutePosition does not perfectly match with TopbarInsets enabled
				-- This corrects this
				local topbarInset = GuiService.TopbarInset
				local viewportWidth = workspace.CurrentCamera.ViewportSize.X
				local guiWidth = screenGui.AbsoluteSize.X
				local guiOffset = screenGui.AbsolutePosition.X
				--local widthDifference = guiOffset - topbarInset.Min.X
				local oldTopbarCenterOffset = 0--widthDifference/30
				local offsetX = if Icon.isOldTopbar then guiOffset else viewportWidth - guiWidth - oldTopbarCenterOffset
				
				-- Also add additionalOffset
				offsetX -= additionalOffsetX
				absoluteValue += UDim2.fromOffset(-offsetX, topbarInset.Height)

				-- Finally check if within its direct parents bounds
				checkIfOutsideParentXBounds()

			end
			instance[property] = absoluteValue
		end
		
		-- This defer is essential as the listener may be in a different screenGui to the actor
		local updatePropertyStaggered = Utility.createStagger(0.01, updateProperty)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyStaggered))
		cloneJanitor:add(clone:GetAttributeChangedSignal("ForceUpdate"):Connect(function()
			updatePropertyStaggered()
		end))

		-- This is to patch a weirddddd bug with ScreenGuis with SreenInsets set to
		-- 'TopbarSafeInsets'. For some reason the absolute position of gui instances
		-- within this type of screenGui DO NOT accurately update to match their new
		-- real world position; instead they jump around almost randomly for a few frames.
		-- I have spent way too many hours trying to solve this bug, I think the only way
		-- for the time being is to not use ScreenGuis with TopbarSafeInsets, but I don't
		-- have time to redesign the entire system around that at the moment.
		-- Here's a GIF of this bug: https://i.imgur.com/VitHdC1.gif
		local updatePropertyPatch = Utility.createStagger(0.5, updateProperty, true)
		cloneJanitor:add(clone:GetPropertyChangedSignal(absoluteProperty):Connect(updatePropertyPatch))
		
		-- When the screenGui is resized (such as when chat is hidden/shown), we need
		-- to update the position of the clone. Ths especially fixes the following:
		-- https://devforum.roblox.com/t/bug/1017485/1732
		if property == "Position" then
			cloneJanitor:add(screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				updatePropertyStaggered()
			end))
		end

	end
	task.delay(0.1, checkIfOutsideParentXBounds)
	checkIfOutsideParentXBounds()
	updateVisibility()
	trackProperty("Position")
	
	-- Track visiblity changes
	cloneJanitor:add(instance:GetPropertyChangedSignal("Visible"):Connect(function()
		--print("Visiblity changed:", instance, clone, instance.Visible)
		--clone.Visible = instance.Visible
	end))

	-- To ensure accurate positioning, it's important the clone also remains the same size as the instance
	local shouldTrackCloneSize = instance:GetAttribute("TrackCloneSize")
	if shouldTrackCloneSize then
		trackProperty("Size")
	else
		cloneJanitor:add(instance:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			local absolute = instance.AbsoluteSize
			clone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end))
	end

	return clone
end

function Utility.joinFeature(originalIcon, parentIcon, iconsArray, scrollingFrameOrFrame)

	-- This is resonsible for moving the icon under a feature like a dropdown
	local joinJanitor = originalIcon.joinJanitor
	joinJanitor:clean()
	if not scrollingFrameOrFrame then
		originalIcon:leave()
		return
	end
	originalIcon.parentIconUID = parentIcon.UID
	originalIcon.joinedFrame = scrollingFrameOrFrame
	local function updateAlignent()
		local parentAlignment = parentIcon.alignment
		if parentAlignment == "Center" then
			parentAlignment = "Left"
		end
		originalIcon:setAlignment(parentAlignment, true)
	end
	joinJanitor:add(parentIcon.alignmentChanged:Connect(updateAlignent))
	updateAlignent()
	originalIcon:modifyTheme({"IconButton", "BackgroundTransparency", 1}, "JoinModification")
	originalIcon:modifyTheme({"ClickRegion", "Active", false}, "JoinModification")
	if parentIcon.childModifications then
		-- We defer so that the default values (such as dropdown
		-- minimum width can be applied before any custom
		-- child modifications from the user)
		task.defer(function()
			originalIcon:modifyTheme(parentIcon.childModifications, parentIcon.childModificationsUID)
		end)
	end
	--
	local clickRegion = originalIcon:getInstance("ClickRegion")
	local function makeSelectable()
		clickRegion.Selectable = parentIcon.isSelected
	end
	joinJanitor:add(parentIcon.toggled:Connect(makeSelectable))
	task.defer(makeSelectable)
	joinJanitor:add(function()
		clickRegion.Selectable = true
	end)
	--

	-- We track icons in arrays and dictionaries using their UID instead of the icon
	-- itself to prevent heavy cyclical tables when printing the icons
	local originalIconUID = originalIcon.UID
	table.insert(iconsArray, originalIconUID)
	parentIcon:autoDeselect(false)
	parentIcon.childIconsDict[originalIconUID] = true
	if not parentIcon.isEnabled then
		parentIcon:setEnabled(true)
	end
	originalIcon.joinedParent:Fire(parentIcon)

	-- This is responsible for removing it from that feature and updating
	-- their parent icon so its informed of the icon leaving it
	joinJanitor:add(function()
		local joinedFrame = originalIcon.joinedFrame
		if not joinedFrame then
			return
		end
		for i, iconUID in pairs(iconsArray) do
			if iconUID == originalIconUID then
				table.remove(iconsArray, i)
				break
			end
		end
		local Icon = require(originalIcon.iconModule)
		local parentIcon = Icon.getIconByUID(originalIcon.parentIconUID)
		if not parentIcon then
			return
		end
		originalIcon:setAlignment(originalIcon.originalAlignment)
		originalIcon.parentIconUID = false
		originalIcon.joinedFrame = false
		--originalIcon:setBehaviour("IconButton", "BackgroundTransparency", nil, true)
		originalIcon:removeModification("JoinModification")
		
		local parentHasNoChildren = true
		local parentChildIcons = parentIcon.childIconsDict
		parentChildIcons[originalIconUID] = nil
		for childIconUID, _ in pairs(parentChildIcons) do
			parentHasNoChildren = false
			break
		end
		if parentHasNoChildren and not parentIcon.isAnOverflow then
			parentIcon:setEnabled(false)
		end
		updateAlignent()

	end)

end



return Utility]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3814E201AEDA4016B2EBE8F17B859733">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VERSION.lua</string>
							<string name="ScriptGuid">{4C25B3AF-5461-4120-A2C8-ADF10EB3888D}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
-- LOCAL
local VERSION = {}



-- SHARED
VERSION.appVersion = "v3.3.1"
VERSION.latestVersion = nil :: string?



-- FUNCTIONS
function VERSION.getLatestVersion(): string?
	local DEVELOPMENT_PLACE_ID = 117501901079852
	local latestVersion = VERSION.latestVersion
	if latestVersion then
		return latestVersion
	end
	local placeName = ""
	while true do
		local success, hdDevelopmentDetails = pcall(function()
			return game:GetService("MarketplaceService"):GetProductInfo(DEVELOPMENT_PLACE_ID)
		end)
		if success and hdDevelopmentDetails then
			placeName = hdDevelopmentDetails.Name
			break
		end
		task.wait(1)
	end
	latestVersion = string.match(placeName, "^TopbarPlus (.*)$")
	if latestVersion then
		latestVersion = latestVersion:gsub("%s+", "") -- Remove all whitespace (spaces, tabs, newlines)
	end
	VERSION.latestVersion = latestVersion
	return latestVersion
end

function VERSION.getAppVersion()
	return VERSION.appVersion
end

function VERSION.isUpToDate()
	local latestVersion = VERSION.getLatestVersion()
	local appVersion = VERSION.getAppVersion()
	return latestVersion ~= nil and latestVersion == appVersion
end



return VERSION]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXE9FB0431F4CE4F97A3D7AF8D907085D9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Elements</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXB5529587E2374779806CA8875201423E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Caption.lua</string>
								<string name="ScriptGuid">{08910E6F-4BC2-4B3C-ACD9-66AA53CDD3B0}</string>
								<ProtectedString name="Source"><![CDATA[local CAPTION_COLOR = Color3.fromRGB(39, 41, 48)
local TEXT_SIZE = 15
return function(icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local clickRegion = icon:getInstance("ClickRegion")
	local caption = Instance.new("CanvasGroup")
	caption.Name = "Caption"
	caption.AnchorPoint = Vector2.new(0.5, 0)
	caption.BackgroundTransparency = 1
	caption.BorderSizePixel = 0
	caption.GroupTransparency = 1
	caption.Position = UDim2.fromOffset(0, 0)
	caption.Visible = true
	caption.ZIndex = 30
	caption.Parent = clickRegion

	local box = Instance.new("Frame")
	box.Name = "Box"
	box.AutomaticSize = Enum.AutomaticSize.XY
	box.BackgroundColor3 = CAPTION_COLOR
	box.Position = UDim2.fromOffset(4, 7)
	box.ZIndex = 12
	box.Parent = caption

	local header = Instance.new("TextLabel")
	header.Name = "Header"
	header.FontFace = Font.new(
		"rbxasset://fonts/families/BuilderSans.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	header.Text = "Caption"
	header.TextColor3 = Color3.fromRGB(255, 255, 255)
	header.TextSize = TEXT_SIZE
	header.TextTruncate = Enum.TextTruncate.None
	header.TextWrapped = false
	header.TextXAlignment = Enum.TextXAlignment.Left
	header.AutomaticSize = Enum.AutomaticSize.X
	header.BackgroundTransparency = 1
	header.LayoutOrder = 1
	header.Size = UDim2.fromOffset(0, 16)
	header.ZIndex = 18
	header.Parent = box

	local layout = Instance.new("UIListLayout")
	layout.Name = "Layout"
	layout.Padding = UDim.new(0, 8)
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Parent = box

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "CaptionCorner"
	UICorner.Parent = box

	local padding = Instance.new("UIPadding")
	padding.Name = "Padding"
	padding.PaddingBottom = UDim.new(0, 12)
	padding.PaddingLeft = UDim.new(0, 12)
	padding.PaddingRight = UDim.new(0, 12)
	padding.PaddingTop = UDim.new(0, 12)
	padding.Parent = box

	local hotkeys = Instance.new("Frame")
	hotkeys.Name = "Hotkeys"
	hotkeys.AutomaticSize = Enum.AutomaticSize.Y
	hotkeys.BackgroundTransparency = 1
	hotkeys.LayoutOrder = 3
	hotkeys.Size = UDim2.fromScale(1, 0)
	hotkeys.Visible = false
	hotkeys.Parent = box

	local layout1 = Instance.new("UIListLayout")
	layout1.Name = "Layout1"
	layout1.Padding = UDim.new(0, 6)
	layout1.FillDirection = Enum.FillDirection.Vertical
	layout1.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout1.HorizontalFlex = Enum.UIFlexAlignment.None
	layout1.ItemLineAlignment = Enum.ItemLineAlignment.Automatic
	layout1.VerticalFlex = Enum.UIFlexAlignment.None
	layout1.SortOrder = Enum.SortOrder.LayoutOrder
	layout1.Parent = hotkeys

	local keyTag1 = Instance.new("ImageLabel")
	keyTag1.Name = "Key1"
	keyTag1.Image = "rbxasset://textures/ui/Controls/key_single.png"
	keyTag1.ImageTransparency = 0.7
	keyTag1.ScaleType = Enum.ScaleType.Slice
	keyTag1.SliceCenter = Rect.new(5, 5, 23, 24)
	keyTag1.AutomaticSize = Enum.AutomaticSize.X
	keyTag1.BackgroundTransparency = 1
	keyTag1.LayoutOrder = 1
	keyTag1.Size = UDim2.fromOffset(0, 30)
	keyTag1.ZIndex = 15
	keyTag1.Parent = hotkeys

	local inset = Instance.new("UIPadding")
	inset.Name = "Inset"
	inset.PaddingLeft = UDim.new(0, 8)
	inset.PaddingRight = UDim.new(0, 8)
	inset.Parent = keyTag1

	local labelContent = Instance.new("TextLabel")
	labelContent.AutoLocalize = false
	labelContent.Name = "LabelContent"
	labelContent.FontFace = Font.new(
		"rbxasset://fonts/families/GothamSSm.json",
		Enum.FontWeight.Medium,
		Enum.FontStyle.Normal
	)
	labelContent.Text = ""
	labelContent.TextColor3 = Color3.fromRGB(189, 190, 190)
	labelContent.TextSize = TEXT_SIZE
	labelContent.AutomaticSize = Enum.AutomaticSize.X
	labelContent.BackgroundTransparency = 1
	labelContent.Position = UDim2.fromOffset(0, -1)
	labelContent.Size = UDim2.fromScale(1, 1)
	labelContent.ZIndex = 16
	labelContent.Parent = keyTag1
	
	local caret = Instance.new("ImageLabel")
	caret.Name = "Caret"
	caret.Image = "rbxassetid://101906294438076"
	caret.ImageColor3 = CAPTION_COLOR
	caret.AnchorPoint = Vector2.new(0, 0.5)
	caret.BackgroundTransparency = 1
	caret.Position = UDim2.new(0, 0, 0, 4)
	caret.Size = UDim2.fromOffset(16, 8)
	caret.ZIndex = 12
	caret.Parent = caption

	local dropShadow = Instance.new("ImageLabel")
	dropShadow.Visible = true
	dropShadow.Name = "DropShadow"
	dropShadow.Image = "rbxassetid://124920646932671"
	dropShadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
	dropShadow.ImageTransparency = 0.45
	dropShadow.ScaleType = Enum.ScaleType.Slice
	dropShadow.SliceCenter = Rect.new(12, 12, 13, 13)
	dropShadow.BackgroundTransparency = 1
	dropShadow.Position = UDim2.fromOffset(0, 5)
	dropShadow.Size = UDim2.new(1, 0, 0, 48)
	dropShadow.Parent = caption
	box:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		dropShadow.Size = UDim2.new(1, 0, 0, box.AbsoluteSize.Y + 8)
	end)
	
	-- It's important we match the sizes as this is not
	-- handles within clipOutside (as it assumes the sizes
	-- are already the same)
	local captionJanitor = icon.captionJanitor
	local _, captionClone = icon:clipOutside(caption)
	captionClone.AutomaticSize = Enum.AutomaticSize.None
	local function matchSize()
		local absolute = caption.AbsoluteSize
		captionClone.Size = UDim2.fromOffset(absolute.X, absolute.Y)
	end
	captionJanitor:add(caption:GetPropertyChangedSignal("AbsoluteSize"):Connect(matchSize))
	matchSize()
	
	
	
	-- This handles the appearing/disappearing/positioning of the caption
	local isCompletelyEnabled = false
	local captionHeader = caption.Box.Header
	local UserInputService = game:GetService("UserInputService")
	local function updateHotkey(keyCodeEnum)
		local hasKeyboard = UserInputService.KeyboardEnabled
		local text = caption:GetAttribute("CaptionText") or ""
		local hideHeader = text == "_hotkey_"
		if not hasKeyboard and hideHeader then
			icon:setCaption()
			return
		end
		captionHeader.Text = text
		captionHeader.Visible = not hideHeader
		if keyCodeEnum then
			labelContent.Text = keyCodeEnum.Name
			hotkeys.Visible = true
		end
		if not hasKeyboard then
			hotkeys.Visible = false
		end
	end
	caption:GetAttributeChangedSignal("CaptionText"):Connect(updateHotkey)

	local EASING_STYLE = Enum.EasingStyle.Quad
	local TWEEN_SPEED = 0.2
	local TWEEN_INFO_IN = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.In)
	local TWEEN_INFO_OUT = TweenInfo.new(TWEEN_SPEED, EASING_STYLE, Enum.EasingDirection.Out)
	local TweenService = game:GetService("TweenService")
	local RunService = game:GetService("RunService")
	local function getCaptionPosition(customEnabled)
		local enabled = if customEnabled ~= nil then customEnabled else isCompletelyEnabled
		local yOut = 2
		local yIn = yOut + 8
		local yOffset = if enabled then yIn else yOut
		return UDim2.new(0.5, 0, 1, yOffset)
	end
	local function updatePosition(forcedEnabled)
		
		-- Ignore changes if not enabled to reduce redundant calls
		if not isCompletelyEnabled then
			return
		end
		
		-- Currently the one thing which isn't accounted for are the bounds of the screen
		-- This would be an issue if someone sets a long caption text for the left or
		-- right most icon
		local enabled = if forcedEnabled ~= nil then forcedEnabled else isCompletelyEnabled
		local startPosition = getCaptionPosition(not enabled)
		local endPosition = getCaptionPosition(enabled)
		
		-- It's essential we reset the carets position to prevent the x sizing bounds
		-- of the caption from infinitely scaling up
		if enabled then
			local caretY = caret.Position.Y.Offset
			caret.Position = UDim2.fromOffset(0, caretY)
			caption.AutomaticSize = Enum.AutomaticSize.XY
			caption.Size = UDim2.fromOffset(32, 53)
		else
			local absolute = caption.AbsoluteSize
			caption.AutomaticSize = Enum.AutomaticSize.Y
			caption.Size = UDim2.fromOffset(absolute.X, absolute.Y)
		end
		
		-- We initially default to the opposite state
		local previousCaretX
		local function updateCaret()
			local caretX = clickRegion.AbsolutePosition.X - caption.AbsolutePosition.X + clickRegion.AbsoluteSize.X/2 - caret.AbsoluteSize.X/2
			local caretY = caret.Position.Y.Offset
			local newCaretPosition = UDim2.fromOffset(caretX, caretY)
			if previousCaretX ~= caretX then
				-- Again, it's essential we reset the caret if
				-- a difference in X position is detected otherwise
				-- a slight quirk with AutomaticCanvas can cause
				-- the caption to infinitely scale
				previousCaretX = caretX
				caret.Position = UDim2.fromOffset(0, caretY)
				task.wait()
			end
			caret.Position = newCaretPosition
		end
		captionClone.Position = startPosition
		updateCaret()
		
		-- Now we tween into the new state
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tween = TweenService:Create(captionClone, tweenInfo, {Position = endPosition})
		local updateCaretConnection = RunService.Heartbeat:Connect(updateCaret)
		tween:Play()
		tween.Completed:Once(function()
			updateCaretConnection:Disconnect()
		end)
		
	end
	captionJanitor:add(clickRegion:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updatePosition()
	end))
	updatePosition(false)
	
	captionJanitor:add(icon.toggleKeyAdded:Connect(updateHotkey))
	for keyCodeEnum, _ in pairs(icon.bindedToggleKeys) do
		updateHotkey(keyCodeEnum)
		break
	end
	captionJanitor:add(icon.fakeToggleKeyChanged:Connect(updateHotkey))
	local fakeToggleKey = icon.fakeToggleKey
	if fakeToggleKey then
		updateHotkey(fakeToggleKey)
	end

	local function setCaptionEnabled(enabled)
		if isCompletelyEnabled == enabled then
			return
		end
		local joinedFrame = icon.joinedFrame
		if joinedFrame and string.match(joinedFrame.Name, "Dropdown") then
			enabled = false
		end
		isCompletelyEnabled = enabled
		local newTransparency = (enabled and 0) or 1
		local tweenInfo = (enabled and TWEEN_INFO_IN) or TWEEN_INFO_OUT
		local tweenTransparency = TweenService:Create(caption, tweenInfo, {
			GroupTransparency = newTransparency
		})
		tweenTransparency:Play()
		if enabled then
			captionClone:SetAttribute("ForceUpdate", true)
		end
		updatePosition()
		updateHotkey()
	end
	
	local WAIT_DURATION = 0.5
	local RECOVER_PERIOD = 0.3
	local Icon = require(icon.iconModule)
	captionJanitor:add(icon.stateChanged:Connect(function(stateName)
		if stateName == "Viewing" then
			local lastClock = Icon.captionLastClosedClock
			local clockDifference = (lastClock and os.clock() - lastClock) or 999
			local waitDuration = (clockDifference < RECOVER_PERIOD and 0) or WAIT_DURATION
			task.delay(waitDuration, function()
				if icon.activeState == "Viewing" then
					setCaptionEnabled(true)
				end
			end)
		else
			Icon.captionLastClosedClock = os.clock()
			setCaptionEnabled(false)
		end
	end))
	
	return caption
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE2F4C295499C415196AC479E6BD454F8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Container.lua</string>
								<string name="ScriptGuid">{5F980BB7-4E04-4A98-8118-E56597FC3EF4}</string>
								<ProtectedString name="Source"><![CDATA[local hasBecomeOldTheme = false
local previousInsetHeight = 0
return function(Icon)
	
	-- Has to be included for the time being due to this bug mentioned here:
	-- https://devforum.roblox.com/t/bug/2973508/7
	local GuiService = game:GetService("GuiService")
	local Players =  game:GetService("Players")
	local container = {}
	local Signal = require(script.Parent.Parent.Packages.GoodSignal)
	local insetChanged = Signal.new()
	local guiInset = GuiService:GetGuiInset()
	local startInset = 0
	local yDownOffset = 0
	local ySizeOffset = 0
	local checkCount = 0
	local function checkInset(status)
		local currentHeight = GuiService.TopbarInset.Height
		local isOldTopbar = currentHeight <= 36
		local isConsoleScreen = GuiService:IsTenFootInterface()

		-- These additional checks are needed to ensure *it is actually* the old topbar
		-- and not a client which takes a really long time to load
		-- There's unfortunately no APIs to do this a prettier way
		Icon.isOldTopbar = isOldTopbar
		checkCount += 1
		if currentHeight == 0 and status == nil then
			task.defer(function()
				task.wait(8)
				checkInset("ForceConvertToOld")
			end)
		elseif checkCount == 1 then
			task.delay(5, function()
				local localPlayer = Players.LocalPlayer
				localPlayer:WaitForChild("PlayerGui")
				if checkCount == 1 then
					checkInset()
				end
			end)
		end

		-- Conver to old theme if verified
		if Icon.isOldTopbar and not isConsoleScreen and hasBecomeOldTheme == false and (currentHeight ~= 0 or status == "ForceConvertToOld") then
			hasBecomeOldTheme = true
			task.defer(function()
				-- If oldtopbar, apply the Classic theme
				local themes = script.Parent.Parent.Features.Themes
				local Classic = require(themes.Classic)
				Icon.modifyBaseTheme(Classic)

				-- Also configure the oldtopbar correctly
				local function decideToHideTopbar()
					if GuiService.MenuIsOpen then
						Icon.setTopbarEnabled(false, true)
					else
						Icon.setTopbarEnabled()
					end
				end
				GuiService:GetPropertyChangedSignal("MenuIsOpen"):Connect(decideToHideTopbar)
				decideToHideTopbar()
			end)
		end

		-- Modify the offsets slightly depending on device type
		guiInset = GuiService:GetGuiInset()
		startInset = if isOldTopbar then 12 else guiInset.Y - 50
		yDownOffset = if isOldTopbar then 2 else 0 --if isOldTopbar then 2 else 0 
		ySizeOffset = -2
		if isConsoleScreen then
			startInset = 10
			yDownOffset = -9
		end
		if GuiService.TopbarInset.Height == 0 and not hasBecomeOldTheme then
			yDownOffset += 13
			ySizeOffset = 50
		end

		-- Now inform other areas of the change
		insetChanged:Fire(guiInset)
		local insetHeight = guiInset.Y
		if insetHeight ~= previousInsetHeight then
			previousInsetHeight = insetHeight
			task.defer(function()
				Icon.insetHeightChanged:Fire(insetHeight)
			end)
		end
		
	end
	GuiService:GetPropertyChangedSignal("TopbarInset"):Connect(checkInset)
	checkInset("FirstTime")

	local screenGui = Instance.new("ScreenGui")
	insetChanged:Connect(function()
		screenGui:SetAttribute("StartInset", startInset)
	end)
	screenGui.Name = "TopbarStandard"
	screenGui.Enabled = true
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.IgnoreGuiInset = true
	screenGui.ResetOnSpawn = false
	screenGui.ScreenInsets = Enum.ScreenInsets.TopbarSafeInsets
	container[screenGui.Name] = screenGui
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGui.DisplayOrder = Icon.baseDisplayOrder
	end)

	local holders = Instance.new("Frame")
	holders.Name = "Holders"
	holders.BackgroundTransparency = 1
	insetChanged:Connect(function()
		holders.Position = UDim2.new(0, 0, 0, yDownOffset)
		holders.Size = UDim2.new(1, 0, 1, ySizeOffset)
	end)
	holders.Visible = true
	holders.ZIndex = 1
	holders.Parent = screenGui
	
	local screenGuiCenter = screenGui:Clone()
	local holdersCenter = screenGuiCenter.Holders
	local function updateCenteredHoldersHeight()
		holdersCenter.Size = UDim2.new(1, 0, 0, GuiService.TopbarInset.Height+ySizeOffset)
	end
	screenGuiCenter.Name = "TopbarCentered"
	screenGuiCenter.ScreenInsets = Enum.ScreenInsets.None
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenter.DisplayOrder = Icon.baseDisplayOrder
	end)
	container[screenGuiCenter.Name] = screenGuiCenter
	
	insetChanged:Connect(updateCenteredHoldersHeight)
	updateCenteredHoldersHeight()
	
	local screenGuiClipped = screenGui:Clone()
	screenGuiClipped.Name = screenGuiClipped.Name.."Clipped"
	screenGuiClipped.DisplayOrder += 1
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiClipped.DisplayOrder = Icon.baseDisplayOrder + 1
	end)
	container[screenGuiClipped.Name] = screenGuiClipped
	
	local screenGuiCenterClipped = screenGuiCenter:Clone()
	screenGuiCenterClipped.Name = screenGuiCenterClipped.Name.."Clipped"
	screenGuiCenterClipped.DisplayOrder += 1
	Icon.baseDisplayOrderChanged:Connect(function()
		screenGuiCenterClipped.DisplayOrder = Icon.baseDisplayOrder + 1
	end)
	container[screenGuiCenterClipped.Name] = screenGuiCenterClipped
	
	local holderReduction = -24
	local left = Instance.new("ScrollingFrame")
	left:SetAttribute("IsAHolder", true)
	left.Name = "Left"
	insetChanged:Connect(function()
		left.Position = UDim2.fromOffset(startInset, 0)
	end)
	left.Size = UDim2.new(1, holderReduction, 1, 0)
	left.BackgroundTransparency = 1
	left.Visible = true
	left.ZIndex = 1
	left.Active = false
	left.ClipsDescendants = true
	left.HorizontalScrollBarInset = Enum.ScrollBarInset.None
	left.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	left.AutomaticCanvasSize = Enum.AutomaticSize.X
	left.ScrollingDirection = Enum.ScrollingDirection.X
	left.ScrollBarThickness = 0
	left.BorderSizePixel = 0
	left.Selectable = false
	left.ScrollingEnabled = false--true
	left.ElasticBehavior = Enum.ElasticBehavior.Never
	left.Parent = holders
	
	local UIListLayout = Instance.new("UIListLayout")
	insetChanged:Connect(function()
		UIListLayout.Padding = UDim.new(0, startInset)
	end)
	UIListLayout.FillDirection = Enum.FillDirection.Horizontal
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
	UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	UIListLayout.Parent = left
	
	local center = left:Clone()
	insetChanged:Connect(function()
		center.UIListLayout.Padding = UDim.new(0, startInset)
	end)
	center.ScrollingEnabled = false
	center.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	center.Name = "Center"
	center.Parent = holdersCenter
	
	local right = left:Clone()
	insetChanged:Connect(function()
		right.UIListLayout.Padding = UDim.new(0, startInset)
	end)
	right.UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
	right.Name = "Right"
	right.AnchorPoint = Vector2.new(1, 0)
	right.Position = UDim2.new(1, -12, 0, 0)
	right.Parent = holders

	-- This is important so that all elements update instantly
	insetChanged:Fire(guiInset)

	return container
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC323F63D76874D88AE2039A5BFD9D1FC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Dropdown.lua</string>
								<string name="ScriptGuid">{225D1D62-ADEC-4712-AAE5-CB5EEB085EA9}</string>
								<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Themes = require(script.Parent.Parent.Features.Themes)
local PADDING = 0 -- used to be 8
return function(icon)
	
	local dropdown = Instance.new("Frame") -- Instance.new("CanvasGroup")
	dropdown.Name = "Dropdown"
	dropdown.AutomaticSize = Enum.AutomaticSize.X
	dropdown.BackgroundTransparency = 1
	dropdown.BorderSizePixel = 0
	dropdown.AnchorPoint = Vector2.new(0.5, 0)
	dropdown.Position = UDim2.new(0.5, 0, 1, 10)
	dropdown.ZIndex = -2
	dropdown.ClipsDescendants = true
	dropdown.Parent = icon.widget

	-- Account for PreferredTransparency which can be set by every player
	local GuiService = game:GetService("GuiService")
	icon:setBehaviour("Dropdown", "BackgroundTransparency", function(value)
		local preference = GuiService.PreferredTransparency
		local newValue = value * preference
		if value == 1 then
			return value
		end
		return newValue
	end)
	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
		icon:refreshAppearance(dropdown, "BackgroundTransparency")
	end))

	local UICorner = Instance.new("UICorner")
	UICorner.Name = "DropdownCorner"
	UICorner.CornerRadius = UDim.new(0, 10)
	UICorner.Parent = dropdown

	local dropdownScroller = Instance.new("ScrollingFrame")
	dropdownScroller.Name = "DropdownScroller"
	dropdownScroller.AutomaticSize = Enum.AutomaticSize.X
	dropdownScroller.BackgroundTransparency = 1
	dropdownScroller.BorderSizePixel = 0
	dropdownScroller.AnchorPoint = Vector2.new(0, 0)
	dropdownScroller.Position = UDim2.new(0, 0, 0, 0)
	dropdownScroller.ZIndex = -1
	dropdownScroller.ClipsDescendants = true
	dropdownScroller.Visible = true
	dropdownScroller.VerticalScrollBarInset = Enum.ScrollBarInset.None --ScrollBar
	dropdownScroller.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
	dropdownScroller.Active = false
	dropdownScroller.ScrollingEnabled = true
	dropdownScroller.AutomaticCanvasSize = Enum.AutomaticSize.Y
	dropdownScroller.ScrollBarThickness = 5
	dropdownScroller.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	dropdownScroller.ScrollBarImageTransparency = 0.8
	dropdownScroller.CanvasSize = UDim2.new(0, 0, 0, 0)
	dropdownScroller.Selectable = false
	dropdownScroller.Active = true
	dropdownScroller.Parent = dropdown

	local TweenDuration = Instance.new("NumberValue") -- this helps to change the speed to open / close in modifyTheme()
	TweenDuration.Name = "DropdownSpeed"
	TweenDuration.Value = 0.07
	TweenDuration.Parent = dropdown

	local dropdownPadding = Instance.new("UIPadding")
	dropdownPadding.Name = "DropdownPadding"
	dropdownPadding.PaddingTop = UDim.new(0, PADDING)
	dropdownPadding.PaddingBottom = UDim.new(0, PADDING)
	dropdownPadding.Parent = dropdownScroller

	local dropdownList = Instance.new("UIListLayout")
	dropdownList.Name = "DropdownList"
	dropdownList.FillDirection = Enum.FillDirection.Vertical
	dropdownList.SortOrder = Enum.SortOrder.LayoutOrder
	dropdownList.HorizontalAlignment = Enum.HorizontalAlignment.Center
	dropdownList.HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly
	dropdownList.Parent = dropdownScroller

	local dropdownJanitor = icon.dropdownJanitor
	local Icon = require(icon.iconModule)
	icon.dropdownChildAdded:Connect(function(childIcon)
		local _, modificationUID = childIcon:modifyTheme({
			{"Widget", "BorderSize", 0},
			{"IconCorners", "CornerRadius", UDim.new(0, 10)},
			{"Widget", "MinimumWidth", 190},
			{"Widget", "MinimumHeight", 58},
			{"IconLabel", "TextSize", 20},
			{"IconOverlay", "Size", UDim2.new(1, 0, 1, 0)},
			{"PaddingLeft", "Size", UDim2.fromOffset(25, 0)},
			{"Notice", "Position", UDim2.new(1, -24, 0, 5)},
			{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Left},
			{"Selection", "Size", UDim2.new(1, -PADDING, 1, -PADDING)},
			{"Selection", "Position", UDim2.new(0, PADDING/2, 0, PADDING/2)},
		})
		task.defer(function()
			childIcon.joinJanitor:add(function()
				childIcon:removeModification(modificationUID)
			end)
		end)
	end)
	icon.dropdownSet:Connect(function(arrayOfIcons)
		for i, otherIconUID in pairs(icon.dropdownIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinDropdown(icon)
			end
		end
	end)

	local function updateMaxIcons()
		--icon:modifyTheme({"Dropdown", "Visible", icon.isSelected})
		local maxIcons = dropdown:GetAttribute("MaxIcons")
		if not maxIcons then return 0 end
		local children = {}
		for _, child in pairs(dropdownScroller:GetChildren()) do
			if child:IsA("GuiObject") and child.Visible then
				table.insert(children, child)
			end
		end

		table.sort(children, function(a, b) return a.AbsolutePosition.Y < b.AbsolutePosition.Y end)
		local totalHeight = 0
		local maxIconsRoundedUp = math.ceil(maxIcons)
		for i = 1, maxIconsRoundedUp do
			local child = children[i]
			if not child then break end
			local height = child.AbsoluteSize.Y
			local isReduced = i == maxIconsRoundedUp and maxIconsRoundedUp ~= maxIcons
			if isReduced then
				height *= (maxIcons - maxIconsRoundedUp + 1)
			end
			totalHeight += height
		end
		totalHeight += dropdownPadding.PaddingTop.Offset + dropdownPadding.PaddingBottom.Offset
		return totalHeight
	end
	
	local openTween = nil
	local closeTween = nil
	local currentSpeedMultiplier = nil
	local currentTweenInfo = nil
	local function getTweenInfo()
		local speedMultiplier = Themes.getInstanceValue(dropdown, "MaxIcons") or 1
		if currentSpeedMultiplier and currentSpeedMultiplier == speedMultiplier and currentTweenInfo then
			return currentTweenInfo
		end
		local newTweenInfo = TweenInfo.new(
			TweenDuration.Value * speedMultiplier,
			Enum.EasingStyle.Exponential,
			Enum.EasingDirection.Out
		)
		currentTweenInfo = newTweenInfo
		currentSpeedMultiplier = speedMultiplier
		return newTweenInfo
	end
	local function updateVisibility()
		-- Update visibiliy of dropdown using tween transition
		local tweenInfo = getTweenInfo()
		
		if openTween then
			openTween:Cancel()
			openTween = nil
		end
		if closeTween then
			closeTween:Cancel()
			closeTween = nil
		end

		if icon.isSelected then
			local height = updateMaxIcons()
			dropdown.Visible = true
			dropdown.BackgroundTransparency = 0 -- no transparency so it looks solid
			dropdown.Size = UDim2.new(0, dropdown.Size.X.Offset, 0, 0) -- reset height to 0 before tween

			openTween = TweenService:Create(dropdown, tweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, height)})
			openTween:Play()
			openTween.Completed:Connect(function()
				openTween = nil
			end)
		else
			local closeTweenInfo = TweenInfo.new(0)
			closeTween = TweenService:Create(dropdown, closeTweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, 0)})
			closeTween:Play()
			closeTween.Completed:Connect(function()
				closeTween = nil
			end)
		end
	end

	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))
	updateVisibility()
	--task.delay(0.2, updateVisibility)

	local function updateChildSize()
		local tweenInfo = getTweenInfo()
		if not icon.isSelected then return end
		if openTween then
			openTween:Cancel()
			openTween = nil
		end
		if closeTween then
			closeTween:Cancel()
			closeTween = nil
		end
		
		RunService.Heartbeat:Wait()
		
		local height = updateMaxIcons()

		openTween = TweenService:Create(dropdown, tweenInfo, {Size = UDim2.new(0, dropdown.Size.X.Offset, 0, height)})
		openTween:Play()
		openTween.Completed:Connect(function()	
			openTween = nil
		end)
	end

	dropdownJanitor:add(icon.toggled:Connect(updateVisibility))

	-- Ensures canvas and size stay synced (original updateMaxIcons logic)
	local updateCount = 0
	local isUpdating = false

	-- This updates the scrolling frame to only display a scroll
	-- length equal to the distance produced by its MaxIcons
	local function updateMaxIconsListener()
		updateCount += 1
		if isUpdating then return end
		local myUpdateCount = updateCount
		isUpdating = true
		task.defer(function()
			isUpdating = false
			if updateCount ~= myUpdateCount then
				updateMaxIconsListener()
			end
		end)
		local maxIcons = dropdown:GetAttribute("MaxIcons")
		if not maxIcons then return end

		local orderedInstances = {}
		for _, child in pairs(dropdownScroller:GetChildren()) do
			if child:IsA("GuiObject") and child.Visible then
				table.insert(orderedInstances, {child, child.AbsolutePosition.Y})
			end
		end
		table.sort(orderedInstances, function(a, b) return a[2] < b[2] end)

		local totalHeight = 0
		local hasSetNextSelection = false
		local maxIconsRoundedUp = math.ceil(maxIcons)
		for i = 1, maxIconsRoundedUp do
			local group = orderedInstances[i]
			if not group then break end
			local child = group[1]
			local height = child.AbsoluteSize.Y
			local isReduced = i == maxIconsRoundedUp and maxIconsRoundedUp ~= maxIcons
			if isReduced then
				height = height * (maxIcons - maxIconsRoundedUp + 1)
			end
			totalHeight += height
			if isReduced then
				continue
			end
			local iconUID = child:GetAttribute("WidgetUID")
			local childIcon = iconUID and Icon.getIconByUID(iconUID)
			if childIcon then
				local nextSelection = nil
				if not hasSetNextSelection then
					hasSetNextSelection = true
					nextSelection = icon:getInstance("ClickRegion")
				end
				childIcon:getInstance("ClickRegion").NextSelectionUp = nextSelection
			end
		end
		totalHeight += dropdownPadding.PaddingTop.Offset + dropdownPadding.PaddingBottom.Offset

		dropdownScroller.Size = UDim2.fromOffset(0, totalHeight)

	end

	dropdownJanitor:add(dropdownScroller:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdownScroller.ChildAdded:Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateChildSize)) -- rezise the dropdown when icon delects or adds
	dropdownJanitor:add(dropdownScroller.ChildRemoved:Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateMaxIconsListener))
	dropdownJanitor:add(dropdown:GetAttributeChangedSignal("MaxIcons"):Connect(updateChildSize))
	dropdownJanitor:add(icon.childThemeModified:Connect(updateMaxIconsListener))
	updateMaxIconsListener()

	-- Ensures each child listens to visibility changes
	local function connectVisibilityListeners(child)
		if child:IsA("GuiObject") then
			child:GetPropertyChangedSignal("Visible"):Connect(updateChildSize)
		end
	end
	
	-- For existing children
	for _, child in pairs(dropdownScroller:GetChildren()) do
		connectVisibilityListeners(child)
	end
	-- For new children
	dropdownScroller.ChildAdded:Connect(function(child)
		RunService.Heartbeat:Wait()
		connectVisibilityListeners(child)
		updateChildSize()
	end)

	-- On start, hide dropdown (prevent it showing as opened)
	dropdown.Visible = false

	return dropdown
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX7D30F1474D904ED5BBDFC5C162B0BBDB">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Indicator.lua</string>
								<string name="ScriptGuid">{E796DE57-7735-46CE-9CB1-B267C329D8CD}</string>
								<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local widget = icon.widget
	local contents = icon:getInstance("Contents")
	local indicator = Instance.new("Frame")
	indicator.Name = "Indicator"
	indicator.LayoutOrder = 9999999
	indicator.ZIndex = 6
	indicator.Size = UDim2.new(0, 42, 0, 42)
	indicator.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicator.BackgroundTransparency = 1
	indicator.Position = UDim2.new(1, 0, 0.5, 0)
	indicator.BorderSizePixel = 0
	indicator.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicator.Parent = contents

	local indicatorButton = Instance.new("Frame")
	indicatorButton.Name = "IndicatorButton"
	indicatorButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.AnchorPoint = Vector2.new(0.5, 0.5)
	indicatorButton.BorderSizePixel = 0
	indicatorButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	indicatorButton.Parent = indicator
	
	local GuiService = game:GetService("GuiService")
	local GamepadService = game:GetService("GamepadService")
	local ourClickRegion = icon:getInstance("ClickRegion")
	local function selectionChanged()
		local selectedClickRegion = GuiService.SelectedObject
		if selectedClickRegion == ourClickRegion then
			indicatorButton.BackgroundTransparency = 1
			indicatorButton.Position = UDim2.new(0.5, -2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1.2, 1.2)
		else
			indicatorButton.BackgroundTransparency = 0.75
			indicatorButton.Position = UDim2.new(0.5, 2, 0.5, 0)
			indicatorButton.Size = UDim2.fromScale(1, 1)
		end
	end
	icon.janitor:add(GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(selectionChanged))
	selectionChanged()

	local imageLabel = Instance.new("ImageLabel")
	imageLabel.LayoutOrder = 2
	imageLabel.ZIndex = 15
	imageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	imageLabel.Size = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.BackgroundTransparency = 1
	imageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
	imageLabel.Image = "rbxasset://textures/ui/Controls/XboxController/DPadUp@2x.png"
	imageLabel.Parent = indicatorButton

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = indicatorButton

	local UserInputService = game:GetService("UserInputService")
	local function setIndicatorVisible(visibility)
		if visibility == nil then
			visibility = indicator.Visible
		end
		if GamepadService.GamepadCursorEnabled then
			visibility = false
		end
		if visibility then
			icon:modifyTheme({"PaddingRight", "Size", UDim2.new(0, 0, 1, 0)}, "IndicatorPadding")
		elseif indicator.Visible then
			icon:removeModification("IndicatorPadding")
		end
		icon:modifyTheme({"Indicator", "Visible", visibility})
		icon.updateSize:Fire()
	end
	icon.janitor:add(GamepadService:GetPropertyChangedSignal("GamepadCursorEnabled"):Connect(setIndicatorVisible))
	icon.indicatorSet:Connect(function(keyCode)
		local visibility = false
		if keyCode then
			imageLabel.Image = UserInputService:GetImageForKeyCode(keyCode)
			visibility = true
		end
		setIndicatorVisible(visibility)
	end)

	local function updateSize()
		local ySize = widget.AbsoluteSize.Y*0.96
		indicator.Size = UDim2.new(0, ySize, 0, ySize)
	end
	widget:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateSize)
	updateSize()

	return indicator
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX09455020217C48E3B870C91D7F830F82">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Menu.lua</string>
								<string name="ScriptGuid">{C4BB1940-1D28-4818-A736-A4B8F0E2AFCB}</string>
								<ProtectedString name="Source"><![CDATA[return function(icon)

	local menu = Instance.new("ScrollingFrame")
	menu.Name = "Menu"
	menu.BackgroundTransparency = 1
	menu.Visible = true
	menu.ZIndex = 1
	menu.Size = UDim2.fromScale(1, 1)
	menu.ClipsDescendants = true
	menu.TopImage = ""
	menu.BottomImage = ""
	menu.HorizontalScrollBarInset = Enum.ScrollBarInset.Always
	menu.CanvasSize = UDim2.new(0, 0, 1, -1) -- This -1 prevents a dropdown scrolling appearance bug
	menu.ScrollingEnabled = true
	menu.ScrollingDirection = Enum.ScrollingDirection.X
	menu.ZIndex = 20
	menu.ScrollBarThickness = 3
	menu.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
	menu.ScrollBarImageTransparency = 0.8
	menu.BorderSizePixel = 0
	menu.Selectable = false
	
	local Icon = require(icon.iconModule)
	local menuUIListLayout = Icon.container.TopbarStandard:FindFirstChild("UIListLayout", true):Clone()
	menuUIListLayout.Name = "MenuUIListLayout"
	menuUIListLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	menuUIListLayout.Parent = menu

	local menuGap = Instance.new("Frame")
	menuGap.Name = "MenuGap"
	menuGap.BackgroundTransparency = 1
	menuGap.Visible = false
	menuGap.AnchorPoint = Vector2.new(0, 0.5)
	menuGap.ZIndex = 5
	menuGap.Parent = menu
	
	local hasStartedMenu = false
	local Themes = require(script.Parent.Parent.Features.Themes)
	local function totalChildrenChanged()
		
		local menuJanitor = icon.menuJanitor
		local totalIcons = #icon.menuIcons
		if hasStartedMenu then
			if totalIcons <= 0 then
				menuJanitor:clean()
				hasStartedMenu = false
			end
			return
		end
		hasStartedMenu = true
		
		-- Listen for changes
		menuJanitor:add(icon.toggled:Connect(function()
			if #icon.menuIcons > 0 then
				icon.updateSize:Fire()
			end
		end))
		
		-- Modify appearance of menu icon when joined
		local _, modificationUID = icon:modifyTheme({
			{"Menu", "Active", true},
		})
		task.defer(function()
			menuJanitor:add(function()
				icon:removeModification(modificationUID)
			end)
		end)
		
		-- For right-aligned icons, this ensures their menus
		-- close button appear instantly when selected (instead
		-- of partially hidden from view)
		local previousCanvasX = menu.AbsoluteCanvasSize.X
		local function rightAlignCanvas()
			if icon.alignment == "Right" then
				local newCanvasX = menu.AbsoluteCanvasSize.X
				local difference = previousCanvasX - newCanvasX
				previousCanvasX = newCanvasX
				menu.CanvasPosition = Vector2.new(menu.CanvasPosition.X - difference, 0)
			end
		end
		menuJanitor:add(icon.selected:Connect(rightAlignCanvas))
		menuJanitor:add(menu:GetPropertyChangedSignal("AbsoluteCanvasSize"):Connect(rightAlignCanvas))
		
		-- Apply a close selected image if the user hasn't applied thier own
		local stateGroup = icon:getStateGroup()
		local imageDeselected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Deselected")
		local imageSelected = Themes.getThemeValue(stateGroup, "IconImage", "Image", "Selected")
		if imageDeselected == imageSelected then
			local fontLink = "rbxasset://fonts/families/FredokaOne.json"
			local fontFace = Font.new(fontLink, Enum.FontWeight.Light, Enum.FontStyle.Normal)
			icon:removeModificationWith("IconLabel", "Text", "Viewing")
			icon:removeModificationWith("IconLabel", "Image", "Viewing")
			icon:modifyTheme({
				{"IconLabel", "FontFace", fontFace, "Selected"},
				{"IconLabel", "Text", "X", "Selected"},
				{"IconLabel", "TextSize", 20, "Selected"},
				{"IconLabel", "TextStrokeTransparency", 0.8, "Selected"},
				{"IconImage", "Image", "", "Selected"},
			})
		end

		-- Change order of spot when alignment changes
		local menuGap = icon:getInstance("MenuGap")
		local function updateAlignent()
			local alignment = icon.alignment
			local spotIndex = -99999
			local gapIndex = -99998
			if alignment == "Right" then
				spotIndex = 99999
				gapIndex = 99998
			end
			icon:modifyTheme({"IconSpot", "LayoutOrder", spotIndex})
			menuGap.LayoutOrder = gapIndex
		end
		menuJanitor:add(icon.alignmentChanged:Connect(updateAlignent))
		updateAlignent()
		
		-- This updates the scrolling frame to only display a scroll
		-- length equal to the distance produced by its MaxIcons
		menu:GetAttributeChangedSignal("MenuCanvasWidth"):Connect(function()
			local canvasWidth = menu:GetAttribute("MenuCanvasWidth")
			local canvasY = menu.CanvasSize.Y
			menu.CanvasSize = UDim2.new(0, canvasWidth, canvasY.Scale, canvasY.Offset)
		end)
		menuJanitor:add(icon.updateMenu:Connect(function()
			local maxIcons = menu:GetAttribute("MaxIcons")
			if not maxIcons then
				return
			end
			local orderedInstances = {}
			for _, child in pairs(menu:GetChildren()) do
				local widgetUID = child:GetAttribute("WidgetUID")
				if widgetUID and child.Visible then
					table.insert(orderedInstances, {child, child.AbsolutePosition.X})
				end
			end
			table.sort(orderedInstances, function(groupA, groupB)
				return groupA[2] < groupB[2]
			end)
			local totalWidth = 0
			for i = 1, maxIcons do
				local group = orderedInstances[i]
				if not group then
					break
				end
				local child = group[1]
				local width = child.AbsoluteSize.X + menuUIListLayout.Padding.Offset
				totalWidth += width
			end
			menu:SetAttribute("MenuWidth", totalWidth)
		end))
		local function startMenuUpdate()
			task.delay(0.1, function()
				icon.startMenuUpdate:Fire()
			end)
		end
		menuJanitor:add(menu.ChildAdded:Connect(startMenuUpdate))
		menuJanitor:add(menu.ChildRemoved:Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxIcons"):Connect(startMenuUpdate))
		menuJanitor:add(menu:GetAttributeChangedSignal("MaxWidth"):Connect(startMenuUpdate))
		startMenuUpdate()
	end
	
	icon.menuChildAdded:Connect(totalChildrenChanged)
	icon.menuSet:Connect(function(arrayOfIcons)
		-- Reset any previous icons
		for i, otherIconUID in pairs(icon.menuIcons) do
			local otherIcon = Icon.getIconByUID(otherIconUID)
			otherIcon:destroy()
		end
		-- Apply new icons
		if type(arrayOfIcons) == "table" then
			for i, otherIcon in pairs(arrayOfIcons) do
				otherIcon:joinMenu(icon)
			end
		end
	end)
	
	return menu
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2F6D8EF30424454C9889E9A7C4471CDA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Notice.lua</string>
								<string name="ScriptGuid">{45B7487E-F54D-4D99-B1C0-DAE5AEFC7092}</string>
								<ProtectedString name="Source"><![CDATA[return function(icon, Icon)

	local notice = Instance.new("Frame")
	notice.Name = "Notice"
	notice.ZIndex = 25
	notice.AutomaticSize = Enum.AutomaticSize.X
	notice.BorderColor3 = Color3.fromRGB(0, 0, 0)
	notice.BorderSizePixel = 0
	notice.BackgroundTransparency = 0.1
	notice.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	notice.Visible = false
	notice.Parent = icon.widget

	local UICorner = Instance.new("UICorner")
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = notice

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Parent = notice

	local noticeLabel = Instance.new("TextLabel")
	noticeLabel.Name = "NoticeLabel"
	noticeLabel.ZIndex = 26
	noticeLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	noticeLabel.AutomaticSize = Enum.AutomaticSize.X
	noticeLabel.Size = UDim2.new(1, 0, 1, 0)
	noticeLabel.BackgroundTransparency = 1
	noticeLabel.Position = UDim2.new(0.5, 0, 0.515, 0)
	noticeLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.FontSize = Enum.FontSize.Size14
	noticeLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
	noticeLabel.Text = "1"
	noticeLabel.TextWrapped = true
	noticeLabel.TextWrap = true
	noticeLabel.Font = Enum.Font.Arial
	noticeLabel.Parent = notice
	
	local iconModule = script.Parent.Parent
	local packages = iconModule.Packages
	local Janitor = require(packages.Janitor)
	local Signal = require(packages.GoodSignal)
	local Utility = require(iconModule.Utility)
	icon.noticeChanged:Connect(function(totalNotices)

		-- Notice amount
		if not totalNotices then
			return
		end
		local exceeded99 = totalNotices > 99
		local noticeDisplay = (exceeded99 and "99+") or totalNotices
		noticeLabel.Text = noticeDisplay
		if exceeded99 then
			noticeLabel.TextSize = 11
		end

		-- Should enable
		local enabled = true
		if totalNotices < 1 then
			enabled = false
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		local dropdownOrMenuActive = #icon.dropdownIcons > 0 or #icon.menuIcons > 0
		if icon.isSelected and dropdownOrMenuActive then
			enabled = false
		elseif parentIcon and not parentIcon.isSelected then
			enabled = false
		end
		Utility.setVisible(notice, enabled, "NoticeHandler")

	end)
	icon.noticeStarted:Connect(function(customClearSignal, noticeId)
	
		if not customClearSignal then
			customClearSignal = icon.deselected
		end
		local parentIcon = Icon.getIconByUID(icon.parentIconUID)
		if parentIcon then
			parentIcon:notify(customClearSignal)
		end
		
		local noticeJanitor = icon.janitor:add(Janitor.new())
		local noticeComplete = noticeJanitor:add(Signal.new())
		noticeJanitor:add(icon.endNotices:Connect(function()
			noticeComplete:Fire()
		end))
		noticeJanitor:add(customClearSignal:Connect(function()
			noticeComplete:Fire()
		end))
		noticeId = noticeId or Utility.generateUID()
		icon.notices[noticeId] = {
			completeSignal = noticeComplete,
			clearNoticeEvent = customClearSignal,
		}
		local function updateNotice()
			icon.noticeChanged:Fire(icon.totalNotices)
		end
		icon.notified:Fire(noticeId)
		icon.totalNotices += 1
		updateNotice()
		noticeComplete:Once(function()
			noticeJanitor:destroy()
			icon.totalNotices -= 1
			icon.notices[noticeId] = nil
			updateNotice()
		end)
	end)
	
	-- Establish the notice
	notice:SetAttribute("ClipToJoinedParent", true)
	icon:clipOutside(notice)
	
	return notice
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX690529DB02EC4389B175CF54ACE8A261">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Selection.lua</string>
								<string name="ScriptGuid">{0EC415BC-C433-4F31-BA16-A68C0E32652D}</string>
								<ProtectedString name="Source"><![CDATA[return function(Icon)

	-- Credit to lolmansReturn and Canary Software for
	-- retrieving these values
	local selectionContainer = Instance.new("Frame")
	selectionContainer.Name = "SelectionContainer"
	selectionContainer.Visible = false
	
	local selection = Instance.new("Frame")
	selection.Name = "Selection"
	selection.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	selection.BackgroundTransparency = 1
	selection.BorderColor3 = Color3.fromRGB(0, 0, 0)
	selection.BorderSizePixel = 0
	selection.Parent = selectionContainer

	local UIStroke = Instance.new("UIStroke")
	UIStroke.Name = "UIStroke"
	UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	UIStroke.Color = Color3.fromRGB(255, 255, 255)
	UIStroke.Thickness = 3
	UIStroke.Parent = selection

	local selectionGradient = Instance.new("UIGradient")
	selectionGradient.Name = "SelectionGradient"
	selectionGradient.Parent = UIStroke

	local UICorner = Instance.new("UICorner")
	UICorner:SetAttribute("Collective", "IconCorners")
	UICorner.Name = "UICorner"
	UICorner.CornerRadius = UDim.new(1, 0)
	UICorner.Parent = selection
	
	local RunService = game:GetService("RunService")
	local GuiService = game:GetService("GuiService")
	local rotationSpeed = 1
	selection:GetAttributeChangedSignal("RotationSpeed"):Connect(function()
		rotationSpeed = selection:GetAttribute("RotationSpeed")
	end)
	RunService.Heartbeat:Connect(function()
		if not GuiService.SelectedObject then
			return
		end
		selectionGradient.Rotation = (os.clock() * rotationSpeed * 100) % 360
	end)

	return selectionContainer
	
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXDBA711C8CFCE475FBE4862958198D2DB">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Widget.lua</string>
								<string name="ScriptGuid">{310084DB-655F-4925-9653-BB9566A54E00}</string>
								<ProtectedString name="Source"><![CDATA[-- I named this 'Widget' instead of 'Icon' to make a clear difference between the icon *object* and
-- the icon (aka Widget) instance.
-- This contains the core components of the icon such as the button, image, label and notice. It's
-- also responsible for handling the automatic resizing of the widget (based upon image visibility and text length)

return function(icon, Icon)

	local widget = Instance.new("Frame")
	widget:SetAttribute("WidgetUID", icon.UID)
	widget.Name = "Widget"
	widget.BackgroundTransparency = 1
	widget.Visible = true
	widget.ZIndex = 20
	widget.Active = false
	widget.ClipsDescendants = true

	local button = Instance.new("Frame")
	button.Name = "IconButton"
	button.Visible = true
	button.ZIndex = 2
	button.BorderSizePixel = 0
	button.Parent = widget
	button.ClipsDescendants = true
	button.Active = false -- This is essential for mobile scrollers to work when dragging
	icon.deselected:Connect(function()
		button.ClipsDescendants = true
		task.delay(0.2, function()
			if icon.isSelected then
				button.ClipsDescendants = false
			end
		end)
	end)

	-- Account for PreferredTransparency which can be set by every player
	local GuiService = game:GetService("GuiService")
	icon:setBehaviour("IconButton", "BackgroundTransparency", function(value)
		local preference = GuiService.PreferredTransparency
		local newValue = value * preference
		if value == 1 then
			return value
		end
		return newValue
	end)
	icon.janitor:add(GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
		icon:refreshAppearance(button, "BackgroundTransparency")
	end))

	local iconCorner = Instance.new("UICorner")
	iconCorner:SetAttribute("Collective", "IconCorners")
	iconCorner.Name = "UICorner"
	iconCorner.Parent = button

	local menu = require(script.Parent.Menu)(icon)
	local menuUIListLayout = menu.MenuUIListLayout
	local menuGap = menu.MenuGap
	menu.Parent = button

	local iconSpot = Instance.new("Frame")
	iconSpot.Name = "IconSpot"
	iconSpot.BackgroundColor3 = Color3.fromRGB(225, 225, 225)
	iconSpot.BackgroundTransparency = 0.9
	iconSpot.Visible = true
	iconSpot.AnchorPoint = Vector2.new(0, 0.5)
	iconSpot.ZIndex = 5
	iconSpot.Parent = menu

	local iconSpotCorner = iconCorner:Clone()
	iconSpotCorner.Parent = iconSpot

	local overlay = iconSpot:Clone()
	overlay.UICorner.Name = "OverlayUICorner"
	overlay.Name = "IconOverlay"
	overlay.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	overlay.ZIndex = iconSpot.ZIndex + 1
	overlay.Size = UDim2.new(1, 0, 1, 0)
	overlay.Position = UDim2.new(0, 0, 0, 0)
	overlay.AnchorPoint = Vector2.new(0, 0)
	overlay.Visible = false
	overlay.Parent = iconSpot

	local clickRegion = Instance.new("TextButton")
	clickRegion:SetAttribute("CorrespondingIconUID", icon.UID)
	clickRegion.Name = "ClickRegion"
	clickRegion.BackgroundTransparency = 1
	clickRegion.Visible = true
	clickRegion.Text = ""
	clickRegion.ZIndex = 20
	clickRegion.Selectable = true
	clickRegion.SelectionGroup = true
	clickRegion.Parent = iconSpot
	
	local Gamepad = require(script.Parent.Parent.Features.Gamepad)
	Gamepad.registerButton(clickRegion)

	local clickRegionCorner = iconCorner:Clone()
	clickRegionCorner.Parent = clickRegion

	local contents = Instance.new("Frame")
	contents.Name = "Contents"
	contents.BackgroundTransparency = 1
	contents.Size = UDim2.fromScale(1, 1)
	contents.Parent = iconSpot

	local contentsList = Instance.new("UIListLayout")
	contentsList.Name = "ContentsList"
	contentsList.FillDirection = Enum.FillDirection.Horizontal
	contentsList.VerticalAlignment = Enum.VerticalAlignment.Center
	contentsList.SortOrder = Enum.SortOrder.LayoutOrder
	contentsList.VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly
	contentsList.Padding = UDim.new(0, 3)
	contentsList.Parent = contents

	local paddingLeft = Instance.new("Frame")
	paddingLeft.Name = "PaddingLeft"
	paddingLeft.LayoutOrder = 1
	paddingLeft.ZIndex = 5
	paddingLeft.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingLeft.BackgroundTransparency = 1
	paddingLeft.BorderSizePixel = 0
	paddingLeft.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingLeft.Parent = contents

	local paddingCenter = Instance.new("Frame")
	paddingCenter.Name = "PaddingCenter"
	paddingCenter.LayoutOrder = 3
	paddingCenter.ZIndex = 5
	paddingCenter.Size = UDim2.new(0, 0, 1, 0)
	paddingCenter.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingCenter.BackgroundTransparency = 1
	paddingCenter.BorderSizePixel = 0
	paddingCenter.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingCenter.Parent = contents

	local paddingRight = Instance.new("Frame")
	paddingRight.Name = "PaddingRight"
	paddingRight.LayoutOrder = 5
	paddingRight.ZIndex = 5
	paddingRight.BorderColor3 = Color3.fromRGB(0, 0, 0)
	paddingRight.BackgroundTransparency = 1
	paddingRight.BorderSizePixel = 0
	paddingRight.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	paddingRight.Parent = contents

	local iconLabelContainer = Instance.new("Frame")
	iconLabelContainer.Name = "IconLabelContainer"
	iconLabelContainer.LayoutOrder = 4
	iconLabelContainer.ZIndex = 3
	iconLabelContainer.AnchorPoint = Vector2.new(0, 0.5)
	iconLabelContainer.Size = UDim2.new(0, 0, 0.5, 0)
	iconLabelContainer.BackgroundTransparency = 1
	iconLabelContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
	iconLabelContainer.Parent = contents

	local iconLabel = Instance.new("TextLabel")
	local viewportX = workspace.CurrentCamera.ViewportSize.X+200
	iconLabel.Name = "IconLabel"
	iconLabel.LayoutOrder = 4
	iconLabel.ZIndex = 15
	iconLabel.AnchorPoint = Vector2.new(0, 0)
	iconLabel.Size = UDim2.new(0, viewportX, 1, 0)
	iconLabel.ClipsDescendants = false
	iconLabel.BackgroundTransparency = 1
	iconLabel.Position = UDim2.fromScale(0, 0)
	iconLabel.RichText = true
	iconLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
	iconLabel.Text = ""
	iconLabel.TextWrapped = true
	iconLabel.TextWrap = true
	iconLabel.TextScaled = false
	iconLabel.Active = false
	iconLabel.AutoLocalize = true
	iconLabel.Parent = iconLabelContainer

	local iconImage = Instance.new("ImageLabel")
	iconImage.Name = "IconImage"
	iconImage.LayoutOrder = 2
	iconImage.ZIndex = 15
	iconImage.AnchorPoint = Vector2.new(0, 0.5)
	iconImage.Size = UDim2.new(0, 0, 0.5, 0)
	iconImage.BackgroundTransparency = 1
	iconImage.Position = UDim2.new(0, 11, 0.5, 0)
	iconImage.ScaleType = Enum.ScaleType.Stretch
	iconImage.Active = false
	iconImage.Parent = contents

	local iconImageCorner = iconCorner:Clone()
	iconImageCorner:SetAttribute("Collective", nil)
	iconImageCorner.CornerRadius = UDim.new(0, 0)
	iconImageCorner.Name = "IconImageCorner"
	iconImageCorner.Parent = iconImage

	local TweenService = game:GetService("TweenService")
	local resizingCount = 0
	local function handleLabelAndImageChangesUnstaggered(forceUpdateString)

		-- We defer changes by a frame to eliminate all but 1 requests which
		-- could otherwise stack up to 20+ requests in a single frame
		-- We then repeat again once to account for any final changes
		-- Deferring is also essential because properties are set immediately
		-- afterwards (therefore calculations will use the correct values)
		task.defer(function()
			local indicator = icon.indicator
			local usingIndicator = indicator and indicator.Visible
			local usingText = usingIndicator or iconLabel.Text ~= ""
			local usingImage = iconImage.Image ~= "" and iconImage.Image ~= nil
			local _alignment = Enum.HorizontalAlignment.Center
			local NORMAL_BUTTON_SIZE = UDim2.fromScale(1, 1)
			local buttonSize = NORMAL_BUTTON_SIZE
			if usingImage and not usingText then
				iconLabelContainer.Visible = false
				iconImage.Visible = true
				paddingLeft.Visible = false
				paddingCenter.Visible = false
				paddingRight.Visible = false
			elseif not usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = false
				paddingLeft.Visible = true
				paddingCenter.Visible = false
				paddingRight.Visible = true
			elseif usingImage and usingText then
				iconLabelContainer.Visible = true
				iconImage.Visible = true
				paddingLeft.Visible = true
				paddingCenter.Visible = not usingIndicator
				paddingRight.Visible = not usingIndicator
				_alignment = Enum.HorizontalAlignment.Left
			end
			button.Size = buttonSize

			local function getItemWidth(item)
				local targetWidth = item:GetAttribute("TargetWidth") or item.AbsoluteSize.X
				return targetWidth
			end
			local contentsPadding = contentsList.Padding.Offset
			local initialWidgetWidth = contentsPadding --0
			local textWidth = iconLabel.TextBounds.X
			iconLabelContainer.Size = UDim2.new(0, textWidth, iconLabel.Size.Y.Scale, 0)
			for _, child in pairs(contents:GetChildren()) do
				if child:IsA("GuiObject") and child.Visible == true then
					local itemWidth = getItemWidth(child)
					initialWidgetWidth += itemWidth + contentsPadding
				end
			end
			local widgetMinimumWidth = widget:GetAttribute("MinimumWidth")
			local widgetMinimumHeight = widget:GetAttribute("MinimumHeight")
			local widgetBorderSize = widget:GetAttribute("BorderSize")
			local widgetWidth = math.clamp(initialWidgetWidth, widgetMinimumWidth, viewportX)
			local menuIcons = icon.menuIcons
			local additionalWidth = 0
			local hasMenu = #menuIcons > 0
			local showMenu = hasMenu and icon.isSelected
			if showMenu then
				for _, frame in pairs(menu:GetChildren()) do
					if frame ~= iconSpot and frame:IsA("GuiObject") and frame.Visible then
						additionalWidth += getItemWidth(frame) + menuUIListLayout.Padding.Offset
					end
				end
				if not iconSpot.Visible then
					widgetWidth -= (getItemWidth(iconSpot) + menuUIListLayout.Padding.Offset*2 + widgetBorderSize)
				end
				additionalWidth -= (widgetBorderSize*0.5)
				widgetWidth += additionalWidth - (widgetBorderSize*0.75)
			end
			menuGap.Visible = showMenu and iconSpot.Visible
			local desiredWidth = widget:GetAttribute("DesiredWidth")
			if desiredWidth and widgetWidth < desiredWidth then
				widgetWidth = desiredWidth
			end

			icon.updateMenu:Fire()
			local preWidth = math.max(widgetWidth-additionalWidth, widgetMinimumWidth)
			local spotWidth = preWidth-(widgetBorderSize*2)
			local menuWidth = menu:GetAttribute("MenuWidth")
			local totalMenuWidth = menuWidth and menuWidth + spotWidth + menuUIListLayout.Padding.Offset + 10
			if totalMenuWidth then
				local maxWidth = menu:GetAttribute("MaxWidth")
				if maxWidth then
					totalMenuWidth = math.max(maxWidth, widgetMinimumWidth)
				end
				menu:SetAttribute("MenuCanvasWidth", widgetWidth)
				if totalMenuWidth < widgetWidth then
					widgetWidth = totalMenuWidth
				end
			end

			local style = Enum.EasingStyle.Quint
			local direction = Enum.EasingDirection.Out
			local spotWidthMax = math.max(spotWidth, getItemWidth(iconSpot), iconSpot.AbsoluteSize.X)
			local widgetWidthMax = math.max(widgetWidth, getItemWidth(widget), widget.AbsoluteSize.X)
			local SPEED = 750
			local spotTweenInfo = TweenInfo.new(spotWidthMax/SPEED, style, direction)
			local widgetTweenInfo = TweenInfo.new(widgetWidthMax/SPEED, style, direction)
			TweenService:Create(iconSpot, spotTweenInfo, {
				Position = UDim2.new(0, widgetBorderSize, 0.5, 0),
				Size = UDim2.new(0, spotWidth, 1, -widgetBorderSize*2),
			}):Play()
			TweenService:Create(clickRegion, spotTweenInfo, {
				Size = UDim2.new(0, spotWidth, 1, 0),
			}):Play()
			local newWidgetSize = UDim2.fromOffset(widgetWidth, widgetMinimumHeight)
			local updateInstantly = widget.Size.Y.Offset ~= widgetMinimumHeight
			if updateInstantly then
				widget.Size = newWidgetSize
			end
			widget:SetAttribute("TargetWidth", newWidgetSize.X.Offset)
			local movingTween = TweenService:Create(widget, widgetTweenInfo, {
				Size = newWidgetSize,
			})
			movingTween:Play()
			resizingCount += 1
			for i = 1, widgetTweenInfo.Time * 100 do
				task.delay(i/100, function()
					Icon.iconChanged:Fire(icon)
				end)
			end
			task.delay(widgetTweenInfo.Time-0.2, function()
				resizingCount -= 1
				task.defer(function()
					if resizingCount == 0 then
						icon.resizingComplete:Fire()
					end
				end)
			end)
			icon:updateParent()
		end)
	end
	local Utility = require(script.Parent.Parent.Utility)
	local handleLabelAndImageChanges = Utility.createStagger(0.01, handleLabelAndImageChangesUnstaggered)
	local firstTimeSettingFontFace = true
	icon:setBehaviour("IconLabel", "Text", handleLabelAndImageChanges)
	icon:setBehaviour("IconLabel", "FontFace", function(value)
		local previousFontFace = iconLabel.FontFace
		if previousFontFace == value then
			return
		end
		task.spawn(function()
			--[[
			local fontLink = value.Family
			if string.match(fontLink, "rbxassetid://") then
				local ContentProvider = game:GetService("ContentProvider")
				local assets = {fontLink}
				ContentProvider:PreloadAsync(assets)
			end--]]

			-- Afaik there's no way to determine when a Font Family has
			-- loaded (even with ContentProvider), so we just have to try
			-- a few times and hope it loads within the refresh period
			handleLabelAndImageChanges()
			if firstTimeSettingFontFace then
				firstTimeSettingFontFace = false
				for i = 1, 10 do
					task.wait(1)
					handleLabelAndImageChanges()
				end
			end
		end)
	end)
	local function updateBorderSize()
		task.defer(function()
			local borderOffset = widget:GetAttribute("BorderSize")
			local alignment = icon.alignment
			local alignmentOffset = (iconSpot.Visible == false and 0) or (alignment == "Right" and -borderOffset) or borderOffset
			menu.Position = UDim2.new(0, alignmentOffset, 0, 0)
			menuGap.Size = UDim2.fromOffset(borderOffset, 0)
			menuUIListLayout.Padding = UDim.new(0, 0)
			handleLabelAndImageChanges()
		end)
	end
	icon:setBehaviour("Widget", "BorderSize", updateBorderSize)
	icon:setBehaviour("IconSpot", "Visible", updateBorderSize)
	icon.startMenuUpdate:Connect(handleLabelAndImageChanges)
	icon.updateSize:Connect(handleLabelAndImageChanges)
	icon:setBehaviour("ContentsList", "HorizontalAlignment", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "DesiredWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumWidth", handleLabelAndImageChanges)
	icon:setBehaviour("Widget", "MinimumHeight", handleLabelAndImageChanges)
	icon:setBehaviour("Indicator", "Visible", handleLabelAndImageChanges)
	icon:setBehaviour("IconImageRatio", "AspectRatio", handleLabelAndImageChanges)
	icon:setBehaviour("IconImage", "Image", function(value)
		local textureId = (tonumber(value) and "http://www.roblox.com/asset/?id="..value) or value or ""
		if iconImage.Image ~= textureId then
			handleLabelAndImageChanges()
		end
		return textureId
	end)
	icon.alignmentChanged:Connect(function(newAlignment)
		if newAlignment == "Center" then
			newAlignment = "Left"
		end
		menuUIListLayout.HorizontalAlignment = Enum.HorizontalAlignment[newAlignment]
		updateBorderSize()
	end)

	-- Localization support (refresh icon size whenever player changes language changes in-game)
	local Players = game:GetService("Players")
	local localPlayer = Players.LocalPlayer
	local lastLocaleId = localPlayer.LocaleId
	icon.janitor:add(localPlayer:GetPropertyChangedSignal("LocaleId"):Connect(function()
		task.delay(0.2, function()
			local newLocaleId = localPlayer.LocaleId
			if newLocaleId ~= lastLocaleId then
				lastLocaleId = newLocaleId
				icon:refresh()
				task.wait(0.5)
				icon:refresh()
			end
		end)
	end))
	
	local iconImageScale = Instance.new("NumberValue")
	iconImageScale.Name = "IconImageScale"
	iconImageScale.Parent = iconImage
	iconImageScale:GetPropertyChangedSignal("Value"):Connect(function()
		iconImage.Size = UDim2.new(iconImageScale.Value, 0, iconImageScale.Value, 0)
	end)

	local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
	UIAspectRatioConstraint.Name = "IconImageRatio"
	UIAspectRatioConstraint.AspectType = Enum.AspectType.FitWithinMaxSize
	UIAspectRatioConstraint.DominantAxis = Enum.DominantAxis.Height
	UIAspectRatioConstraint.Parent = iconImage

	local iconGradient = Instance.new("UIGradient")
	iconGradient.Name = "IconGradient"
	iconGradient.Enabled = true
	iconGradient.Parent = button

	local iconSpotGradient = Instance.new("UIGradient")
	iconSpotGradient.Name = "IconSpotGradient"
	iconSpotGradient.Enabled = true
	iconSpotGradient.Parent = iconSpot

	return widget
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXCA48F7858042463EA0818F3F06D14FB9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Features</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX35F2122C99754A40BF286F9A2A2611A8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Gamepad.lua</string>
								<string name="ScriptGuid">{F60D34C8-55DD-496A-B9F5-643F68F905F5}</string>
								<ProtectedString name="Source"><![CDATA[-- As the name suggests, this handles everything related to gamepads
-- (i.e. Xbox or Playstation controllers) and their navigation
-- I created a separate module for gamepads (and not touchpads or
-- keyboards) because gamepads are greatly more unqiue and require
-- additional tailored programming



-- SERVICES
local GamepadService = game:GetService("GamepadService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")



-- LOCAL
local DEFAULT_HIGHLIGHT_KEY = Enum.KeyCode.DPadUp -- The default key to highlight the topbar icon
local GAMEPAD_INPUT = Enum.PreferredInput.Gamepad
local Gamepad = {}
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Gamepad.start(incomingIcon)
	
	-- Public variables
	Icon = incomingIcon
	Icon.highlightKey = if Icon.highlightKey ~= nil then Icon.highlightKey else DEFAULT_HIGHLIGHT_KEY -- What controller key to highlight the topbar (or set to false to disable)
	Icon.highlightIcon = false -- Change to a specific icon if you'd like to highlight a specific icon instead of the left-most
	
	-- We defer so the developer can make changes before the
	-- gamepad controls are initialized
	task.delay(1, function()
		-- Some local utility
		local iconsDict = Icon.iconsDictionary
		local function getIconFromSelectedObject()
			local clickRegion = GuiService.SelectedObject
			local iconUID = clickRegion and clickRegion:GetAttribute("CorrespondingIconUID")
			local icon = iconUID and iconsDict[iconUID]
			return icon
		end
		
		-- This enables users to instantly open up their last selected icon
		local previousHighlightedIcon
		local usedIndicatorOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
		local usedBOnce = DEFAULT_HIGHLIGHT_KEY ~= Icon.highlightKey
		local Selection = require(script.Parent.Parent.Elements.Selection)
		local function updateSelectedObject()
			local icon = getIconFromSelectedObject()
			local isUsingGamepad = UserInputService.PreferredInput == GAMEPAD_INPUT
			if icon then
				if isUsingGamepad then
					local clickRegion = icon:getInstance("ClickRegion")
					local selection = icon.selection
					if not selection then
						selection = icon.janitor:add(Selection(Icon))
						selection:SetAttribute("IgnoreVisibilityUpdater", true)
						selection.Parent = icon.widget
						icon.selection = selection
						icon:refreshAppearance(selection) --icon:clipOutside(selection)
					end
					clickRegion.SelectionImageObject = selection.Selection
				end
				if previousHighlightedIcon and previousHighlightedIcon ~= icon then
					previousHighlightedIcon:setIndicator()
				end
				local newIndicator = if isUsingGamepad and not usedBOnce and not icon.parentIconUID then Enum.KeyCode.ButtonB else nil
				previousHighlightedIcon = icon
				Icon.lastHighlightedIcon = icon
				icon:setIndicator(newIndicator)
			else
				local newIndicator = if isUsingGamepad and not usedIndicatorOnce then Icon.highlightKey else nil
				if not previousHighlightedIcon then
					previousHighlightedIcon = Gamepad.getIconToHighlight()
				end
				if newIndicator == Icon.highlightKey then
					-- We only display the highlightKey once to show
					-- the user how to highlight the topbar icon
					usedIndicatorOnce = true
				else
					--usedBOnce = true
				end
				if previousHighlightedIcon then
					previousHighlightedIcon:setIndicator(newIndicator)
				end
			end
		end
		GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(updateSelectedObject)

		-- This listens for a gamepad being present/added/removed
		local function preferredInputChanged()
			local preferredInput = UserInputService.PreferredInput
			local isUsingGamepad = preferredInput == GAMEPAD_INPUT

			if not isUsingGamepad then
				usedIndicatorOnce = false
				usedBOnce = false
			end
			updateSelectedObject()
		end
		UserInputService:GetPropertyChangedSignal("PreferredInput"):Connect(preferredInputChanged)
		preferredInputChanged()

		-- This allows for easy highlighting of the topbar when the
		-- when ``Icon.highlightKey`` (i.e. DPadUp) is pressed.
		-- If you'd like to disable, do ``Icon.highlightKey = false``
		UserInputService.InputBegan:Connect(function(input, touchingAnObject)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				-- Sometimes the Roblox gamepad glitches when combined with a cursor
				-- This fixes that by unhighlighting if the cursor is pressed down
				-- (i.e. a mouse click)
				local icon = getIconFromSelectedObject()
				if icon then
					GuiService.SelectedObject = nil
				end
				return
			end
			if input.KeyCode ~= Icon.highlightKey then
				return
			end
			local iconToHighlight = Gamepad.getIconToHighlight()
			if iconToHighlight then
				if GamepadService.GamepadCursorEnabled then
					task.wait(0.2)
					GamepadService:DisableGamepadCursor()
				end
				local clickRegion = iconToHighlight:getInstance("ClickRegion")
				GuiService.SelectedObject = clickRegion
			end
		end)
	end)
end

function Gamepad.getIconToHighlight()
	-- If an icon has already been selected, returns the last selected icon
	-- Else if more than 0 icons, it selects the left-most icon
	local iconsDict = Icon.iconsDictionary
	local iconToHighlight = Icon.highlightIcon or Icon.lastHighlightedIcon
	if not iconToHighlight then
		local currentX
		for _, icon in pairs(iconsDict) do
			if icon.parentIconUID then
				continue
			end
			local thisX = icon.widget.AbsolutePosition.X
			if not currentX or thisX < currentX then
				iconToHighlight = icon
				currentX = iconToHighlight.widget.AbsolutePosition.X
			end
		end
	end
	return iconToHighlight
end

-- This called when the icon's ClickRegion is created
function Gamepad.registerButton(buttonInstance)
	-- This provides a basic level of support for controllers by making
	-- the icons easy to highlight via the virtual cursor, then
	-- when selected, focuses in on the selected icon and hops
	-- between other nearby icons simply by toggling the joystick
	local inputBegan = false
	buttonInstance.InputBegan:Connect(function(input)
		-- Two wait frames required to ensure inputBegan is detected within
		-- UserInputService.InputBegan. We do this because object.InputBegan
		-- does not return the correct input objects (unlike the service)
		inputBegan = true
		task.wait()
		task.wait()
		inputBegan = false
	end)
	local connection = UserInputService.InputBegan:Connect(function(input)
		task.wait()
		if input.KeyCode == Enum.KeyCode.ButtonA and inputBegan then
			-- We focus on an icon when selected via the virtual cursor
			task.wait(0.2)
			GamepadService:DisableGamepadCursor()
			GuiService.SelectedObject = buttonInstance
			return
		end
		local isSelected = GuiService.SelectedObject == buttonInstance
		local unselectKeyCodes = {"ButtonB", "ButtonSelect"}
		local keyName = input.KeyCode.Name
		if table.find(unselectKeyCodes, keyName) and isSelected then
			-- We unfocus when back button is pressed, but ignore
			-- if the virtual cursor is disabled otherwise it will be
			-- impossible to select the topbar
			if not(keyName == "ButtonSelect" and not GamepadService.GamepadCursorEnabled) then
				GuiService.SelectedObject = nil
			end
		end
	end)
	buttonInstance.Destroying:Once(function()
		connection:Disconnect()
	end)
end



return Gamepad]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXBC6087640ED740F2B7F19D0C58DCD039">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Overflow.lua</string>
								<string name="ScriptGuid">{1D78DAD0-9CF9-4BCF-96C1-C1643F498BF9}</string>
								<ProtectedString name="Source"><![CDATA[-- When designing your game for many devices and screen sizes, icons may occasionally
-- particularly for smaller devices like phones, overlap with other icons or the bounds
-- of the screen. The overflow handler solves this challenge by moving the out-of-bounds
-- icon into an overflow menu (with a limited scrolling canvas) preventing overlaps occuring



-- LOCAL
local Overflow = {}
local holders = {}
local orderedAvailableIcons = {}
local iconsDict
local currentCamera = workspace.CurrentCamera
local overflowIcons = {}
local overflowIconUIDs = {}
local Utility = require(script.Parent.Parent.Utility)
local beginCheckingCenterIcons = false
local beganSecondaryCenterCheck = false
local Icon



-- FUNCTIONS
-- This is called upon the Icon initializing
function Overflow.start(incomingIcon)
	Icon = incomingIcon
	iconsDict = Icon.iconsDictionary
	local primaryScreenGui
	for _, screenGui in pairs(Icon.container) do
		if primaryScreenGui == nil and screenGui.ScreenInsets == Enum.ScreenInsets.TopbarSafeInsets then
			primaryScreenGui = screenGui
		end
		for _, holder in pairs(screenGui.Holders:GetChildren()) do
			if holder:GetAttribute("IsAHolder") then
				holders[holder.Name] = holder
			end
		end
	end

	-- We listen for changes in icons (such as them being added, removed,
	-- the setting of a different alignment, the widget size changing, etc)
	local beginOverflow = false
	local updateBoundaries = Utility.createStagger(0.1, function(ignoreAvailable)
		if not beginOverflow then
			return
		end
		if not ignoreAvailable then
			Overflow.updateAvailableIcons("Center")
		end
		Overflow.updateBoundary("Left")
		Overflow.updateBoundary("Right")
	end)
	task.delay(0.5, function()
		beginOverflow = true
		updateBoundaries()
	end)
	task.delay(2, function()
		-- This is essential to prevent central icons begin added
		-- left or right due to incomplete UIListLayout calculations
		-- within the first few frames
		beginCheckingCenterIcons = true
		updateBoundaries()
	end)
	Icon.iconAdded:Connect(updateBoundaries)
	Icon.iconRemoved:Connect(updateBoundaries)
	Icon.iconChanged:Connect(updateBoundaries)
	currentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
		updateBoundaries(true)
	end)
	primaryScreenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		updateBoundaries(true)
	end)
end

function Overflow.getWidth(icon, getMaxWidth)
	local widget = icon.widget
	return widget:GetAttribute("TargetWidth") or widget.AbsoluteSize.X
end

function Overflow.getAvailableIcons(alignment)
	local ourOrderedIcons = orderedAvailableIcons[alignment]
	if not ourOrderedIcons then
		ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	end
	return ourOrderedIcons
end

function Overflow.updateAvailableIcons(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon)
	local ourTotal = 0
	local ourOrderedIcons = {}
	for _, icon in pairs(iconsDict) do
		local parentUID = icon.parentIconUID
		local isDirectlyOnTopbar = not parentUID or overflowIconUIDs[parentUID]
		local isOverflow = overflowIconUIDs[icon.UID]
		if isDirectlyOnTopbar and icon.alignment == alignment and not isOverflow and icon.isEnabled then
			table.insert(ourOrderedIcons, icon)
			ourTotal += 1
		end
	end

	-- Ignore if no icons are available
	if ourTotal <= 0 then
		return {}
	end

	-- This sorts these icons by smallest order, or if equal, left-most position
	-- (even for the right alignment because all icons are sorted left-to-right)
	table.sort(ourOrderedIcons, function(iconA, iconB)
		local orderA = iconA.widget.LayoutOrder
		local orderB = iconB.widget.LayoutOrder
		local hasParentA = iconA.parentIconUID
		local hasParentB = iconB.parentIconUID
		if hasParentA == hasParentB then
			if orderA < orderB then
				return true
			end
			if orderA > orderB then
				return false
			end
			return iconA.widget.AbsolutePosition.X < iconB.widget.AbsolutePosition.X
		elseif hasParentB then
			return false
		elseif hasParentA then
			return true
		end
		return nil
	end)

	-- Finish up
	orderedAvailableIcons[alignment] = ourOrderedIcons
	return ourOrderedIcons

end

function Overflow.getRealXPositions(alignment, orderedIcons)
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local isLeft = alignment == "Left"
	local holder = holders[alignment]
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local holderUIList = holder.UIListLayout
	local topbarInset = holderUIList.Padding.Offset
	local absoluteX = (isLeft and holderXPos) or holderXPos + holderXSize
	local realXPositions = {}
	if isLeft then
		Utility.reverseTable(orderedIcons)
	end
	for i = #orderedIcons, 1, -1 do
		local icon = orderedIcons[i]
		local sizeX = Overflow.getWidth(icon)
		if not isLeft then
			absoluteX -= sizeX
		end
		realXPositions[icon.UID] = absoluteX
		if isLeft then
			absoluteX += sizeX
		end
		absoluteX += (isLeft and topbarInset) or -topbarInset
	end
	return realXPositions
end

function Overflow.updateBoundary(alignment)

	-- We only track items that are directly on the topbar (i.e. not within a parent icon) or within an overflow
	local holder = holders[alignment]
	local holderUIList = holder.UIListLayout
	local holderXPos = holder.AbsolutePosition.X
	local holderXSize = holder.AbsoluteSize.X
	local topbarInset = holderUIList.Padding.Offset
	local topbarPadding = holderUIList.Padding.Offset
	local BOUNDARY_GAP = topbarInset
	local ourOrderedIcons = Overflow.updateAvailableIcons(alignment)
	local boundWidth = 0
	local ourTotal = 0
	for _, icon in pairs(ourOrderedIcons) do
		boundWidth += Overflow.getWidth(icon) + topbarPadding
		ourTotal += 1
	end
	if ourTotal <= 0 then
		return
	end
	
	-- These are the icons with menus which icons will be moved into
	-- when overflowing
	local isCentral = alignment == "Center"
	local isLeft = alignment == "Left"
	local isRight = not isLeft
	local overflowIcon = overflowIcons[alignment]
	if not overflowIcon and not isCentral and #ourOrderedIcons > 0 then
		local order = (isLeft and -9999999) or 9999999
		overflowIcon = Icon.new()--:setLabel(`{alignment}`)
		overflowIcon:setImage(6069276526, "Deselected")
		overflowIcon:setName("Overflow"..alignment)
		overflowIcon:setOrder(order)
		overflowIcon:setAlignment(alignment)
		overflowIcon:autoDeselect(false)
		overflowIcon.isAnOverflow = true
		--overflowIcon:freezeMenu()
		overflowIcon:select("OverflowStart", overflowIcon)
		overflowIcon:setEnabled(false)
		overflowIcons[alignment] = overflowIcon
		overflowIconUIDs[overflowIcon.UID] = true
		if not Icon.closeableOverflowMenus then
			local iconSpot = overflowIcon:getInstance("IconSpot")
			iconSpot.Visible = false
		end
	end

	-- The default boundary is the point where both the left-most-right-icon
	-- and left-most-right-icon meet OR the opposite side of the screen
	local oppositeAlignment = (alignment == "Left" and "Right") or "Left"
	local oppositeOrderedIcons = Overflow.updateAvailableIcons(oppositeAlignment)
	local nearestOppositeIcon = (isLeft and oppositeOrderedIcons[1]) or (isRight and oppositeOrderedIcons[#oppositeOrderedIcons])
	local oppositeOverflowIcon = overflowIcons[oppositeAlignment]
	local boundary = (isLeft and holderXPos + holderXSize) or holderXPos
	if nearestOppositeIcon then
		local oppositeRealXPositions = Overflow.getRealXPositions(oppositeAlignment, oppositeOrderedIcons)
		local oppositeX = oppositeRealXPositions[nearestOppositeIcon.UID]
		local oppositeXSize = Overflow.getWidth(nearestOppositeIcon)
		boundary = (isLeft and oppositeX - BOUNDARY_GAP) or oppositeX + oppositeXSize + BOUNDARY_GAP
	end
	
	-- We get the left-most icon (if left alignment) or right-most-icon (if
	-- right alignment) of the central icons group to see if we need to change
	-- the boundary (if the central icon boundary is smaller than the alignment
	-- boundary then we use the central)
	local totalChecks = 0
	local usingNearestCenter = false
	local function checkToShiftCentralIcon()
		local centerOrderedIcons = Overflow.getAvailableIcons("Center")
		local centerPos = (isLeft and 1) or #centerOrderedIcons
		local nearestCenterIcon = centerOrderedIcons[centerPos]
		local function secondaryCheck()
			if not beganSecondaryCenterCheck then
				beganSecondaryCenterCheck = true
				task.delay(3, Overflow.updateBoundary, alignment)
			end
		end
		if nearestCenterIcon and not nearestCenterIcon.hasRelocatedInOverflow then
			local ourNearestIcon = (isLeft and ourOrderedIcons[#ourOrderedIcons]) or (isRight and ourOrderedIcons[1])
			local centralNearestXPos = nearestCenterIcon.widget.AbsolutePosition.X
			local ourNearestXPos = ourNearestIcon.widget.AbsolutePosition.X
			local ourNearestXSize = Overflow.getWidth(ourNearestIcon)
			local centerBoundary = (isLeft and centralNearestXPos-BOUNDARY_GAP) or centralNearestXPos + Overflow.getWidth(nearestCenterIcon) + BOUNDARY_GAP
			local removeBoundary = (isLeft and ourNearestXPos + ourNearestXSize) or ourNearestXPos
			local hasShifted = false
			if isLeft then
				if centerBoundary < removeBoundary then
					if not beginCheckingCenterIcons then
						secondaryCheck()
						return
					end
					nearestCenterIcon:align("Left")
					nearestCenterIcon.hasRelocatedInOverflow = true
					hasShifted = true
				end
			elseif isRight then
				if centerBoundary > removeBoundary then
					if not beginCheckingCenterIcons or removeBoundary < 0 then
						secondaryCheck()
						return
					end
					nearestCenterIcon:align("Right")
					nearestCenterIcon.hasRelocatedInOverflow = true
					hasShifted = true
				end
			end
			if hasShifted then
				totalChecks += 1
				if totalChecks <= 4 then
					Overflow.updateAvailableIcons("Center")
					checkToShiftCentralIcon()
				end
			end
		end
	end
	checkToShiftCentralIcon()
	
	--[[
	This updates the maximum size of the overflow menus
	The menu determines its bounds from the smallest of either:
	 	1. The closest center-aligned icon (i.e. the boundary)
	 	2. The edge of the opposite overflow menu UNLESS...
	 	3. ... the edge exceeds more than half the screenGui
	--]]
	if overflowIcon then
		local menuBoundary = boundary
		local menu = overflowIcon:getInstance("Menu")
		local holderXEndPos = holderXPos + holderXSize
		local menuWidth = holderXSize
		if menu and oppositeOverflowIcon then
			local oppositeWidget = oppositeOverflowIcon.widget
			local oppositeXPos = oppositeWidget.AbsolutePosition.X
			local oppositeXSize = Overflow.getWidth(oppositeOverflowIcon)
			local oppositeBoundary = (isLeft and oppositeXPos - BOUNDARY_GAP) or oppositeXPos + oppositeXSize + BOUNDARY_GAP
			local oppositeMenu = oppositeOverflowIcon:getInstance("Menu")
			local isDominant = menu.AbsoluteCanvasSize.X >= oppositeMenu.AbsoluteCanvasSize.X
			if not usingNearestCenter then
				local halfwayXPos = holderXPos + holderXSize/2
				local halfwayBoundary = (isLeft and halfwayXPos - BOUNDARY_GAP/2) or halfwayXPos + BOUNDARY_GAP/2
				menuBoundary = halfwayBoundary
				if isDominant then
					menuBoundary = oppositeBoundary
				end
			end
			menuWidth = (isLeft and menuBoundary - holderXPos) or (holderXEndPos - menuBoundary)
		end
		local currentMaxWidth = menu and menu:GetAttribute("MaxWidth")
		menuWidth = Utility.round(menuWidth)
		if menu and currentMaxWidth ~= menuWidth then
			menu:SetAttribute("MaxWidth", menuWidth)
		end
	end

	-- Parent ALL icons of that alignment into the overflow if at least on
	-- sibling exceeds the bounds.
	-- We calculate the the absolute position of icons instead of reading
	-- directly to determine where they would be if not within an overflow
	local joinOverflow = false
	local realXPositions = Overflow.getRealXPositions(alignment, ourOrderedIcons)
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local widgetX = Overflow.getWidth(icon)
		local xPos = realXPositions[icon.UID]
		if (isLeft and xPos + widgetX >= boundary) or (isRight and xPos <= boundary) then
			joinOverflow = true
		end
	end
	for i = #ourOrderedIcons, 1, -1 do
		local icon = ourOrderedIcons[i]
		local isOverflow = overflowIconUIDs[icon.UID]
		if not isOverflow then
			if joinOverflow and not icon.parentIconUID then
				icon:joinMenu(overflowIcon)
			elseif not joinOverflow and icon.parentIconUID then
				icon:leave()
			end
		end
	end
	
	-- Hide the overflows when not in use
	if overflowIcon.isEnabled ~= joinOverflow then
		overflowIcon:setEnabled(joinOverflow)
	end
	
	-- Have the menus auto selected
	if overflowIcon.isEnabled and not overflowIcon.overflowAlreadyOpened then
		overflowIcon.overflowAlreadyOpened = true
		overflowIcon:select()
	end

end



return Overflow]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA0FBD2D18A0347C2BC090A9C7A8F0EB1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Themes.lua</string>
								<string name="ScriptGuid">{E0971ED9-2E35-4077-9F50-B18E7E689E80}</string>
								<ProtectedString name="Source"><![CDATA[-- The functions here are dedicated solely to managing theme state
-- and updating the appearance of instances to match that state.
-- You don't need to use any of these functions, the useful ones
-- have been abstracted as icon methods



-- LOCAL
local Themes = {}
local Utility = require(script.Parent.Parent.Utility)
local baseTheme = require(script.Default)



-- FUNCTIONS
function Themes.getThemeValue(stateGroup, instanceName, property, iconState)
	if stateGroup then
		for _, detail in pairs(stateGroup) do
			local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
			if instanceName == checkingInstanceName and property == checkingPropertyName then
				return checkingValue
			end
		end
	end
	return nil
end

function Themes.getInstanceValue(instance, property)
	local success, value = pcall(function()
		return instance[property]
	end)
	if not success then
		value = instance:GetAttribute(property)
	end
	return value
end

function Themes.getRealInstance(instance)
	if not instance:GetAttribute("IsAClippedClone") then
		return
	end
	local originalInstance = instance:FindFirstChild("OriginalInstance")
	if not originalInstance then
		return
	end
	return originalInstance.Value
end

function Themes.getClippedClone(instance)
	if not instance:GetAttribute("HasAClippedClone") then
		return
	end
	local clippedClone = instance:FindFirstChild("ClippedClone")
	if not clippedClone then
		return
	end
	return clippedClone.Value
end

function Themes.refresh(icon, instance, specificProperty)
	-- Some instances such as notices need immediate refreshing upon creation as
	-- they're added in after the initial refresh period
	if specificProperty then
		local stateGroup = icon:getStateGroup()
		local value = Themes.getThemeValue(stateGroup, instance.Name, specificProperty) or Themes.getInstanceValue(instance, specificProperty)
		Themes.apply(icon, instance, specificProperty, value, true)
		return
	end
	-- If no property is specified we update all properties that exist within
	-- the applied theme appearance
	local stateGroup = icon:getStateGroup()
	if not stateGroup then
		return
	end
	local validInstances = {[instance.Name] = instance}
	for _, child in pairs(instance:GetDescendants()) do
		local collective = child:GetAttribute("Collective")
		if collective then
			validInstances[collective] = child
		end
		validInstances[child.Name] = child
	end
	for _, detail in pairs(stateGroup) do
		local checkingInstanceName, checkingPropertyName, checkingValue = unpack(detail)
		local instanceToUpdate = validInstances[checkingInstanceName]
		if instanceToUpdate then
			Themes.apply(icon, instanceToUpdate.Name, checkingPropertyName, checkingValue, true)
		end
	end
	return
end

function Themes.apply(icon, collectiveOrInstanceNameOrInstance, property, value, forceApply)
	-- This is responsible for **applying** appearance changes to instances within the icon
	-- however it IS NOT responsible for updating themes. Use :modifyTheme for that.
	-- This also calls callbacks given by :setBehaviour before applying these property changes
	-- to the given instances
	if icon.isDestroyed then
		return
	end
	local instances
	local collectiveOrInstanceName = collectiveOrInstanceNameOrInstance
	if typeof(collectiveOrInstanceNameOrInstance) == "Instance" then
		instances = {collectiveOrInstanceNameOrInstance}
		collectiveOrInstanceName = collectiveOrInstanceNameOrInstance.Name
	else
		instances = icon:getInstanceOrCollective(collectiveOrInstanceNameOrInstance)
	end
	local key = collectiveOrInstanceName.."-"..property
	local customBehaviour = icon.customBehaviours[key]
	for _, instance in pairs(instances) do
		local clippedClone = Themes.getClippedClone(instance)
		if clippedClone then
			-- This means theme effects are applied to both the original
			-- instance and its clone (instead of just the instance).
			-- This is important for some properties such as position
			-- and size which might be dictated by the clone
			table.insert(instances, clippedClone)
		end
	end
	for _, instance in pairs(instances) do
		if property == "Position" and Themes.getClippedClone(instance) then
			-- The clone manages the position of the real instance so ignore
			continue
		elseif property == "Size" and Themes.getRealInstance(instance) then
			-- The real instance manages the size of the clone so ignore
			continue
		end
		local currentValue = Themes.getInstanceValue(instance, property)
		if not forceApply and value == currentValue then
			continue
		end
		if customBehaviour then
			local newValue = customBehaviour(value, instance, property)
			if newValue ~= nil then
				value = newValue
			end
		end
		local success = pcall(function()
			instance[property] = value
		end)
		if not success then
			-- If property is not a real property, we set
			-- the value as an attribute instead. This is useful
			-- for instance in :setWidth where we also want to
			-- specify a desired width for every state which can
			-- then be easily read by the widget element
			instance:SetAttribute(property, value)
		end
	end
end

function Themes.getModifications(modifications)
	if typeof(modifications[1]) ~= "table" then
		-- This enables users to do :modifyTheme({a,b,c,d})
		-- in addition of :modifyTheme({{a,b,c,d}})
		modifications = {modifications}
	end
	return modifications
end

function Themes.merge(detail, modification, callback)
	local instanceName, property, value, stateName = table.unpack(modification)
	local checkingInstanceName, checkingPropertyName, _, checkingStateName = table.unpack(detail)
	if instanceName == checkingInstanceName and property == checkingPropertyName and Themes.statesMatch(stateName, checkingStateName) then
		detail[3] = value
		if callback then
			callback(detail)
		end
		return true
	end
	return false
end

function Themes.modify(icon, modifications, modificationsUID)
	-- This is what the 'old set' used to do (although for clarity that behaviour has now been
	-- split into two methods, .modifyTheme and .apply).
	-- modifyTheme is responsible for UPDATING the internal values within a theme for a particular
	-- state, then checking to see if the appearance of the icon needs to be updated.
	-- If no iconState is specified, the change is applied to both Deselected and Selected
	-- A modification can also be 'undone' using :removeModification and passing in
	-- the UID returned from this method
	task.spawn(function()
		modificationsUID = modificationsUID or Utility.generateUID()
		modifications = Themes.getModifications(modifications)
		for _, modification in pairs(modifications) do
			local instanceName, property, value, iconState = table.unpack(modification)
			if iconState == nil then
				-- If no state specified, apply to all states
				Themes.modify(icon, {instanceName, property, value, "Selected"}, modificationsUID)
				Themes.modify(icon, {instanceName, property, value, "Viewing"}, modificationsUID)
			end
			local chosenState = Utility.formatStateName(iconState or "Deselected")
			local stateGroup = icon:getStateGroup(chosenState)
			local function nowSetIt()
				if chosenState == icon.activeState then
					Themes.apply(icon, instanceName, property, value)
				end
			end
			local function updateRecord()
				for stateName, detail in pairs(stateGroup) do
					local didMerge = Themes.merge(detail, modification, function(detail)
						detail[5] = modificationsUID
						nowSetIt()
					end)
					if didMerge then
						return
					end
				end
				local detail = {instanceName, property, value, chosenState, modificationsUID}
				table.insert(stateGroup, detail)
				nowSetIt()
			end
			updateRecord()
		end
	end)
	return modificationsUID
end

function Themes.remove(icon, modificationsUID)
	for iconState, stateGroup in pairs(icon.appearance) do
		for i = #stateGroup, 1, -1 do
			local detail = stateGroup[i]
			local checkingUID = detail[5]
			if checkingUID == modificationsUID then
				table.remove(stateGroup, i)
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.removeWith(icon, instanceName, property, state)
	for iconState, stateGroup in pairs(icon.appearance) do
		if state == iconState or not state then
			for i = #stateGroup, 1, -1 do
				local detail = stateGroup[i]
				local detailName = detail[1]
				local detailProperty = detail[2]
				if detailName == instanceName and detailProperty == property then
					table.remove(stateGroup, i)
				end
			end
		end
	end
	Themes.rebuild(icon)
end

function Themes.change(icon)
	-- This changes the theme to the appearance of whatever
	-- state is currently active
	local stateGroup = icon:getStateGroup()
	for _, detail in pairs(stateGroup) do
		local instanceName, property, value = unpack(detail)
		Themes.apply(icon, instanceName, property, value)
	end
end

function Themes.set(icon, theme)
	-- This is responsible for processing the final appearance of a given theme (such as
	-- ensuring Deselected merge into missing Selected, saving that internal state,
	-- then checking to see if the appearance of the icon needs to be updated
	local themesJanitor = icon.themesJanitor
	themesJanitor:clean()
	themesJanitor:add(icon.stateChanged:Connect(function()
		Themes.change(icon)
	end))
	if typeof(theme) == "Instance" and theme:IsA("ModuleScript") then
		theme = require(theme)
	end
	icon.appliedTheme = theme
	Themes.rebuild(icon)
end

function Themes.statesMatch(state1, state2)
	-- States match if they have the same name OR if nil (because unspecified represents all states)
	local state1lower = (state1 and string.lower(state1))
	local state2lower = (state2 and string.lower(state2))
	return state1lower == state2lower or not state1 or not state2
end

function Themes.rebuild(icon)
	-- A note for my future self: this code can be optimised further by
	-- converting appearance into a instanceName-property dictionary
	-- as apposed to an array of every potential change. When converting
	-- in the future, .modify and .apply would also have to be updated.
	local appliedTheme = icon.appliedTheme
	local statesArray = {"Deselected", "Selected", "Viewing"}
	local function generateTheme()
		for _, stateName in pairs(statesArray) do
			-- This applies themes in layers
			-- The last layers take higher priority as they overwrite
			-- any duplicate earlier applied effects
			local stateAppearance = {}
			local function updateDetails(theme, incomingStateName)
				-- This ensures there's always a base 'default' layer
				if not theme then
					return
				end
				for _, detail in pairs(theme) do
					local modificationsUID = detail[5]
					local detailStateName = detail[4]
					if Themes.statesMatch(incomingStateName, detailStateName) then
						local key = detail[1].."-"..detail[2]
						local newDetail = Utility.copyTable(detail)
						newDetail[5] = modificationsUID
						stateAppearance[key] = newDetail
					end
				end
			end
			-- First we apply the base theme (i.e. the Default module)
			if stateName == "Selected" then
				updateDetails(baseTheme, "Deselected")
			end
			updateDetails(baseTheme, "Empty")
			updateDetails(baseTheme, stateName)
			-- Next we apply any custom themes by the games developer
			if appliedTheme ~= baseTheme then
				if stateName == "Selected" then
					updateDetails(appliedTheme, "Deselected")
				end
				updateDetails(baseTheme, "Empty")
				updateDetails(appliedTheme, stateName)
			end
			-- Finally we apply any modifications that have already been made
			-- Modifiers are all the changes made using icon:modifyTheme(...)
			local alreadyAppliedTheme = {}
			local alreadyAppliedGroup = icon.appearance[stateName]
			if alreadyAppliedGroup then
				for _, modifier in pairs(alreadyAppliedGroup) do
					local modificationsUID = modifier[5]
					if modificationsUID ~= nil then
						local modification = {modifier[1], modifier[2], modifier[3], stateName, modificationsUID}
						table.insert(alreadyAppliedTheme, modification)
					end
				end
			end
			updateDetails(alreadyAppliedTheme, stateName)
			-- This now converts it into our final appearance
			local finalStateAppearance = {}
			for _, detail in pairs(stateAppearance) do
				table.insert(finalStateAppearance, detail)
			end
			icon.appearance[stateName] = finalStateAppearance
		end
		Themes.change(icon)
	end
	generateTheme()
end



return Themes]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXAA5EF8DB36DE4B5EB91B1CB85F5783A1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Themes</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX4508D7E151294239A9B0F67A543F7048">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Classic.lua</string>
									<string name="ScriptGuid">{A9CC459F-DE4D-4033-97BB-F6E2D18B4931}</string>
									<ProtectedString name="Source"><![CDATA[-- This is to provide backwards compatability with the old Roblox
-- topbar while experiences transition over to the new topbar
-- You don't need to apply this yourself, topbarplus automatically
-- applies it if the old roblox topbar is detected


return {
	{"Selection", "Size", UDim2.new(1, -6, 1, -5)},
	{"Selection", "Position", UDim2.new(0, 3, 0, 3)},
	
	{"Widget", "MinimumWidth", 32, "Deselected"},
	{"Widget", "MinimumHeight", 32, "Deselected"},
	{"Widget", "BorderSize", 0, "Deselected"},
	{"IconCorners", "CornerRadius", UDim.new(0, 9), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.5, "Deselected"},
	{"IconLabel", "TextSize", 14, "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.5, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -3), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 15, 0, 15), "Deselected"},
	{"NoticeLabel", "TextSize", 11, "Deselected"},
	
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(0, 0, 0), "Selected"},
	{"IconSpot", "BackgroundTransparency", 0.702, "Selected"},
	{"IconSpotGradient", "Enabled", false, "Selected"},
	{"IconOverlay", "BackgroundTransparency", 0.97, "Selected"},
	
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX507059E315F64A2B8E8B84BB7F3132AC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Default.lua</string>
									<string name="ScriptGuid">{2CD544ED-0497-48A4-9597-4FC76A6D4BCB}</string>
									<ProtectedString name="Source"><![CDATA[-- Themes in v3 work simply by applying the value (agument[3])
-- to the property (agument[2]) of an instance within the icon which
-- matches the name of argument[1]. Argument[1] can also be used to
-- specify a collection of instances with a corresponding 'collective'
-- value. A colletive is simply an attribute applied to some instances
-- within the icon to group them together (such as "IconCorners").
-- If the property (argument[2]) does not exist within the instance,
-- it will instead be applied as an attribute on the instance:
-- (i.e. ``instance:SetAttribute(argument[2], [argument[3])``)
-- Use argument[4] to specify a state: "Deselected", "Selected"
-- or "Viewing". If argument[4] is empty the state will default
-- to "Deselected".
-- I've designed themes this way so you have full control over
-- the appearance of the widget and its descendants


return {
	
	-- When no state is specified the modification is applied to *all* states (Deselected, Selected and Viewing)
	{"IconCorners", "CornerRadius", UDim.new(1, 0)},
	{"Selection", "RotationSpeed", 1},
	{"Selection", "Size", UDim2.new(1, 0, 1, 1)},
	{"Selection", "Position", UDim2.new(0, 0, 0, 0)},
	{"SelectionGradient", "Color", ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(86, 86, 86)),
	})},
	
	-- When the icon is deselected
	{"IconImage", "Image", "", "Deselected"},
	{"IconLabel", "Text", "", "Deselected"},
	{"IconLabel", "Position", UDim2.fromOffset(0, 0), "Deselected"}, -- 0, -1
	{"Widget", "DesiredWidth", 44, "Deselected"},
	{"Widget", "MinimumWidth", 44, "Deselected"},
	{"Widget", "MinimumHeight", 44, "Deselected"},
	{"Widget", "BorderSize", 4, "Deselected"},
  	{"IconButton", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
	{"IconButton", "BackgroundTransparency", 0.08, "Deselected"},
	{"IconImageScale", "Value", 0.5, "Deselected"},
	{"IconImageCorner", "CornerRadius", UDim.new(0, 0), "Deselected"},
	{"IconImage", "ImageColor3", Color3.fromRGB(255, 255, 255), "Deselected"},
	{"IconImage", "ImageTransparency", 0, "Deselected"},
	{"IconImageRatio", "AspectRatio", 1, "Deselected"},
	{"IconLabel", "FontFace", Font.new("rbxasset://fonts/families/BuilderSans.json", Enum.FontWeight.Bold, Enum.FontStyle.Normal), "Deselected"},
	{"IconLabel", "TextSize", 16, "Deselected"},
	{"IconSpot", "BackgroundTransparency", 1, "Deselected"},
	{"IconOverlay", "BackgroundTransparency", 0.85, "Deselected"},
	{"IconSpotGradient", "Enabled", false, "Deselected"},
	{"IconGradient", "Enabled", false, "Deselected"},
	{"ClickRegion", "Active", true, "Deselected"},  -- This is set to false within scrollers to ensure scroller can be dragged on mobile
	{"Menu", "Active", false, "Deselected"},
	{"ContentsList", "HorizontalAlignment", Enum.HorizontalAlignment.Center, "Deselected"},
  	{"Dropdown", "BackgroundColor3", Color3.fromRGB(18, 18, 21), "Deselected"},
	{"Dropdown", "BackgroundTransparency", 0.08, "Deselected"},
	{"Dropdown", "MaxIcons", 4.5, "Deselected"},
	{"Menu", "MaxIcons", 4, "Deselected"},
	{"Notice", "Position", UDim2.new(1, -12, 0, -1), "Deselected"},
	{"Notice", "Size", UDim2.new(0, 20, 0, 20), "Deselected"},
	{"NoticeLabel", "TextSize", 13, "Deselected"},
	{"PaddingLeft", "Size", UDim2.new(0, 9, 1, 0), "Deselected"},
	{"PaddingRight", "Size", UDim2.new(0, 11, 1, 0), "Deselected"},
	
	-- When the icon is selected
	-- Selected also inherits everything from Deselected if nothing is set
	{"IconSpot", "BackgroundTransparency", 0.7, "Selected"},
	{"IconSpot", "BackgroundColor3", Color3.fromRGB(255, 255, 255), "Selected"},
	{"IconSpotGradient", "Enabled", true, "Selected"},
	{"IconSpotGradient", "Rotation", 45, "Selected"},
	{"IconSpotGradient", "Color", ColorSequence.new(Color3.fromRGB(96, 98, 100), Color3.fromRGB(77, 78, 80)), "Selected"},
	
	
	-- When a cursor is hovering above, a controller highlighting, or touchpad (mobile) pressing (but not released)
	--{"IconSpot", "BackgroundTransparency", 0.75, "Viewing"},
	
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXC472280D3D8A4249BFCFE4AE17A8EC14">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Packages</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX270B8B322E9B4880A953AB03626E7758">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">GoodSignal.lua</string>
								<string name="ScriptGuid">{76CD0B7D-4C02-4749-91EA-97B53A73BF08}</string>
								<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread()
	-- Note: We cannot use the initial set of arguments passed to
	-- runEventHandlerInFreeThread for a call to the handler, because those
	-- arguments would stay on the stack for the duration of the thread's
	-- existence, temporarily leaking references. Without access to raw bytecode
	-- there's no way for us to clear the "..." references from the stack.
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end
Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		_handlerListHead = false,
	}, Signal)
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false
end
Signal.Destroy = Signal.DisconnectAll

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
				-- Get the freeRunnerThread to the first yield
				coroutine.resume(freeRunnerThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

-- Implement Signal:Once() in terms of a connection which disconnects
-- itself before running the handler.
function Signal:Once(fn)
	local cn;
	cn = self:Connect(function(...)
		if cn._connected then
			cn:Disconnect()
		end
		fn(...)
	end)
	return cn
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

return Signal]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE36D887485E047FEBA4F37EBB9F6D3E9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Janitor.lua</string>
								<string name="ScriptGuid">{3A0C897C-5EDE-47E1-BE23-58F657CFD803}</string>
								<ProtectedString name="Source"><![CDATA[--[[
-------------------------------------
This package was modified by ForeverHD.

PACKAGE MODIFICATIONS:
	1. Added pascalCase aliases for all methods
	2. Modified behaviour of :add so that it takes both objects and promises (previously only objects)
	3. Slight change to how promises are tracked
	4. Added isAnInstanceBeingDestroyed check to line 228
	5. Added 'OriginalTraceback' to help determine where an error was added to the janitor
	6. Likely some additional changes which weren't record here
	7. Removed comments as these were detected by Moonwave
-------------------------------------
--]]



-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local function getPromiseReference()
	return false
end

local IndicesReference = newproxy(true)
getmetatable(IndicesReference).__tostring = function()
	return "IndicesReference"
end

local LinkToInstanceIndex = newproxy(true)
getmetatable(LinkToInstanceIndex).__tostring = function()
	return "LinkToInstanceIndex"
end

local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

local Janitor = {
	IGNORE_MEMORY_DEBUG = true,
	ClassName = "Janitor";
	__index = {
		CurrentlyCleaning = true;
		[IndicesReference] = nil;
	};
}

local TypeDefaults = {
	["function"] = true;
	["Promise"] = "cancel";
	RBXScriptConnection = "Disconnect";
}

function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

Janitor.is = Janitor.Is

function Janitor.__index:Add(Object, MethodName, Index)
	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end

	local objectType = typeof(Object)
	if objectType == "table" and string.match(tostring(Object), "Promise") then
		objectType = "Promise"
		--local status = Object:getStatus()
		--print("status =", status, status == "Rejected")
	end
	MethodName = MethodName or TypeDefaults[objectType] or "Destroy"
	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil :: any, 2)))
	end

	local OriginalTraceback = debug.traceback("")
	self[Object] = {MethodName, OriginalTraceback}
	return Object
end
Janitor.__index.Give = Janitor.__index.Add

-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

function Janitor.__index:AddPromise(PromiseObject)
	local Promise = getPromiseReference()
	if Promise then
		if not Promise.is(PromiseObject) then
			error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
		end
		if PromiseObject:getStatus() == Promise.Status.Started then
			local Id = newproxy(false)
			local NewPromise = self:Add(Promise.new(function(Resolve, _, OnCancel)
				if OnCancel(function()
						PromiseObject:cancel()
					end) then
					return
				end

				Resolve(PromiseObject)
			end), "cancel", Id)

			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise
		else
			return PromiseObject
		end
	else
		return PromiseObject
	end
end
Janitor.__index.GivePromise = Janitor.__index.AddPromise

-- This will assume whether or not the object is a Promise or a regular object.
function Janitor.__index:AddObject(Object)
	local Id = newproxy(false)
	local Promise = getPromiseReference()
	if Promise and Promise.is(Object) then
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	else
		return self:Add(Object, false, Id), Id
	end
end

Janitor.__index.GiveObject = Janitor.__index.AddObject

function Janitor.__index:Remove(Index)
	local This = self[IndicesReference]
	if This then
		local Object = This[Index]

		if Object then
			local ObjectDetail = self[Object]
			local MethodName = ObjectDetail and ObjectDetail[1]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

function Janitor.__index:Get(Index)
	local This = self[IndicesReference]
	if This then
		return This[Index]
	end
	return nil
end

function Janitor.__index:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil
		for Object, ObjectDetail in next, self do
			if Object == IndicesReference then
				continue
			end

			-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
			local TypeOf = type(Object)
			if TypeOf == "string" or TypeOf == "number" then
				self[Object] = nil
				continue
			end

			local MethodName = ObjectDetail[1]
			local OriginalTraceback = ObjectDetail[2]
			local function warnUser(warning)
				local cleanupLine = debug.traceback("", 3)--string.gsub(debug.traceback("", 3), "%c", "")
				local addedLine = OriginalTraceback
				warn("-------- Janitor Error --------".."\n"..tostring(warning).."\n"..cleanupLine..""..addedLine)
			end
			if MethodName == true then
				local success, warning = pcall(Object)
				if not success then
					warnUser(warning)
				end
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					local success, warning = pcall(ObjectMethod, Object)
					local isAnInstanceBeingDestroyed = typeof(Object) == "Instance" and ObjectMethod == "Destroy"
					if not success and not isAnInstanceBeingDestroyed then
						warnUser(warning)
					end
				end
			end

			self[Object] = nil
		end

		local This = self[IndicesReference]
		if This then
			for Index in next, This do
				This[Index] = nil
			end

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

Janitor.__index.Clean = Janitor.__index.Cleanup

function Janitor.__index:Destroy()
	self:Cleanup()
	--table.clear(self)
	--setmetatable(self, nil)
end

Janitor.__call = Janitor.__index.Cleanup

local Disconnect = {Connected = true}
Disconnect.__index = Disconnect
function Disconnect:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function Disconnect:__tostring()
	return "Disconnect<" .. tostring(self.Connected) .. ">"
end

function Janitor.__index:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, Disconnect)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				coroutine.wrap(function()
					Heartbeat:Wait()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							Heartbeat:Wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)()
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

function Janitor.__index:LinkToInstances(...)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

for FunctionName, Function in next, Janitor.__index do
	local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
	Janitor.__index[NewFunctionName] = Function
end

return Janitor]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX2E7513EEFA6841ADAB5E7313A0B60EAE">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ServerScriptService</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXE7E66A3A9D4D426A9893D1A4C68BD6C9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Video_Player.server.lua</string>
					<string name="ScriptGuid">{7DF4F649-D267-40CF-A931-93E2B545DA9A}</string>
					<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")

local function setupVideo(surfaceGui: SurfaceGui)
	local frame = surfaceGui:FindFirstChildWhichIsA("Frame")
	if not frame then
		warn("[Video_Player] No Frame found in", surfaceGui:GetFullName())
		return
	end

	local videoId = tonumber(surfaceGui:GetAttribute("Video"))
	if not videoId then
		warn("[Video_Player] Invalid or missing Video attribute in", surfaceGui:GetFullName())
		return
	end

	local videoPlayer = Instance.new("VideoFrame")
	videoPlayer.Name = "VideoPlayer"
	videoPlayer.Size = UDim2.new(1, 0, 1, 0)
	videoPlayer.Looped = true
	videoPlayer.Volume = 0
	videoPlayer.Video = "rbxassetid://" .. videoId
	videoPlayer.Parent = frame

	if not videoPlayer.IsLoaded then
		videoPlayer.Loaded:Wait()
	end

	videoPlayer:Play()

--print("[Video_Player] Playing video", videoId, "on", surfaceGui:GetFullName())
end

-- Helper pour protger les appels
local function safeSetup(obj)
	local success, err = pcall(setupVideo, obj)
	if not success then
		warn("[Video_Player] Failed to setup video for", obj:GetFullName(), ":", err)
	end
end

-- Connect new tagged instances
CollectionService:GetInstanceAddedSignal("VideoFrame"):Connect(safeSetup)

-- Initialize already tagged instances
for _, obj in CollectionService:GetTagged("VideoFrame") do
	task.spawn(safeSetup, obj)
end
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX0A988D98771345C898CDAA4B66EFC8F8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Bloxlink.server.lua</string>
					<string name="ScriptGuid">{5AD9D38B-1BB7-428D-A015-B64986F1C4E4}</string>
					<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local Clothing_Mod = require(game.ReplicatedStorage.Data_Mods_F.Clothing_Mod)

local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Sending_F = Channels_F:WaitForChild("Server_Client_F")
local Sending_Events_F = Sending_F:WaitForChild("Events")
local Msg_E = Sending_Events_F:WaitForChild("Display_Data")

local AuthKey = if RunService:IsStudio() then "" else HttpService:GetSecret("BloxLinkAPI")

-- Check if user is in Discord server via Bloxlink API
local function isInServer(userId)
	local url = "https://api.blox.link/v4/public/guilds/1371423884921933837/roblox-to-discord/"..userId
	local headers = { ["Authorization"] = AuthKey }

	local success, result = pcall(function()
		return HttpService:GetAsync(url, false, headers)
	end)

	if success then
		local data = HttpService:JSONDecode(result)
		if data.discordIDs then
			return true, data
		else
			return false, nil
		end
	else
		return nil, nil
	end
end

-- Give reward if not already obtained
local function awardDiscordReward(player: Player)
	local plrData = player:FindFirstChild("Player_Data")
	if not plrData then return false end

	local discordReward = plrData:FindFirstChild("DiscordReward")
	if not discordReward or discordReward.Value == true then
		return false
	end

	if Clothing_Mod.Player_Owns_Gloves_Key(player, "K") then
		return false
	end

	Clothing_Mod.Give_Player_Gloves(player, "K")
	Msg_E:FireClient(player, " You are a member of our community. Here is a pair of Mystic Gloves!", Color3.fromRGB(255, 170, 0))

	discordReward.Value = true
	return true
end

-- Store background tasks
local playertasks = {}

Players.PlayerAdded:Connect(function(player)
	-- Wait for Player_Data to be available (instead of fixed 20s)
	local plrData = player:WaitForChild("Player_Data", 30)
	if not plrData or not player:IsDescendantOf(Players) then return end

	-- Background check task
	playertasks[player] = task.defer(function()
		while player:IsDescendantOf(Players) do
			local joined, info = isInServer(player.UserId)
			if joined == true then
				local rewarded = awardDiscordReward(player)
				if rewarded then
					break -- stop once reward is given
				end
			end
			task.wait(10) -- wait before next check
		end
	end)
end)

Players.PlayerRemoving:Connect(function(plr)
	if playertasks[plr] then
		task.cancel(playertasks[plr])
		playertasks[plr] = nil
	end
end)
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX3A31F010AA534091801CE577B59D0790">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GlobalLeaderBoards.lua</string>
					<string name="ScriptGuid">{028E796D-66AC-4DFB-8386-6F188959D59E}</string>
					<ProtectedString name="Source"><![CDATA[local module = {
	NationElos = {},
	TopPlayers = {}
}

local Players = game:GetService("Players")
local UserService = game:GetService("UserService")
local DataStoreService = game:GetService("DataStoreService")
local Leaderboards_F = game.Workspace:WaitForChild("Leaderboards")

local Data_Mod_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Num_Str_Mod = require(Data_Mod_F:WaitForChild("Num_String_Mod"))
local Country_Mod = require(Data_Mod_F:WaitForChild("Country_Mod"))

local DEFAULT_COUNTRY = "United States"
local THUMBNAIL_TYPE = Enum.ThumbnailType.HeadShot
local THUMBNAIL_SIZE = Enum.ThumbnailSize.Size180x180

local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local RemoteEvents_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Top3_Players_Updated = RemoteEvents_F:WaitForChild("Top3_Players_Updated")

local LeaderboarKeys = {
	Elo = "Best Elo",
	Wins = "Total Wins",
	WinStreak = "Win Streak",
	Knockouts = "Knockouts",
	Submissions = "Submissions Wins",
	GymTraining = "Gym Training",
	RankedWins = "Ranked Wins"
}
local LeaderboardKey = 2

local LeaderboarStores = {}
for i, v in pairs(LeaderboarKeys) do
	LeaderboarStores[i] = DataStoreService:GetOrderedDataStore(v .. LeaderboardKey)
end

local NationEloStore = DataStoreService:GetDataStore("Natio_Elo" .. LeaderboardKey)
local NationEloKey = "_KEYS_"
local NationEloData = {}

local Player_Info_Data = {}
local Player_Thumbnail_Data = {}
local LastPlayerValues = {}

-- ============================================================
-- DataStore Queue System
-- ============================================================
local DataStoreQueue = {}
DataStoreQueue.Queue = {}
DataStoreQueue.Busy = false

function DataStoreQueue:Add(store, key, value, mode, callback)
	table.insert(self.Queue, {
		store = store,
		key = key,
		value = value,
		mode = mode,
		callback = callback
	})
end

function DataStoreQueue:Process()
	if self.Busy then return end
	self.Busy = true
	task.spawn(function()
		while #self.Queue > 0 do
			local req = table.remove(self.Queue, 1)
			local success, err
			if req.mode == "set" then
				success, err = pcall(function()
					req.store:SetAsync(req.key, req.value)
				end)
			elseif req.mode == "update" then
				success, err = pcall(function()
					req.store:UpdateAsync(req.key, req.value)
				end)
			end
			if not success then
				warn("DataStoreQueue error:", err)
				table.insert(self.Queue, req)
				task.wait(2)
			elseif req.callback then
				req.callback()
			end
			task.wait(0.1)
		end
		self.Busy = false
	end)
end

-- ============================================================
-- Player thumbnails and info
-- ============================================================
local function Get_Player_Thumbnail(ID)
	if Player_Thumbnail_Data[ID] then
		return Player_Thumbnail_Data[ID]
	end
	for _ = 1, 3 do
		local success, data = pcall(function()
			return Players:GetUserThumbnailAsync(ID, THUMBNAIL_TYPE, THUMBNAIL_SIZE)
		end)
		if success and data then
			Player_Thumbnail_Data[ID] = data
			return data
		end
		task.wait(1)
	end
	return "rbxassetid://100127687172105"
end

local function Get_Player_Info_Data(ID)
	if Player_Info_Data[ID] then
		return Player_Info_Data[ID]
	end
	for _ = 1, 3 do
		local success, data = pcall(function()
			return UserService:GetUserInfosByUserIdsAsync({tonumber(ID)})
		end)
		if success and data and data[1] and data[1].Username then
			local entry = {
				Username = data[1].Username,
				DisplayName = data[1].DisplayName
			}
			Player_Info_Data[ID] = entry
			return entry
		end
		task.wait(1)
	end
	return { Username = "PlayerName", DisplayName = "Player" }
end

-- ============================================================
-- Utils
-- ============================================================
local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

local function Time_Conversion(Raw_S)
	local Hrs, Min_Secs = math.floor(Raw_S / 3600), Raw_S % 3600
	local Min, Sec = math.floor(Min_Secs / 60), Min_Secs % 60
	if Min < 10 then Min = "0" .. Min end
	if Sec < 10 then Sec = "0" .. Sec end
	if Hrs > 0 then return Format_Number(Hrs) .. ":" .. Min .. ":" .. Sec end
	return Min .. ":" .. Sec
end

local function SerializeDataAndCountry(data: number, country: string)
	local countryId = Country_Mod.Get_Country_Number_From_Index(country)
	data = math.round(data)
	return tonumber(tostring(data) .. string.format("%04d", countryId))
end

local function DeserializeDataAndCountry(serialized: number)
	local str = tostring(serialized)
	local dataPart = 0
	if #str >= 5 then dataPart = tonumber(string.sub(str, 1, #str - 4)) end
	local countryId = tonumber(string.sub(str, -4))
	return math.round(dataPart), countryId
end

-- ============================================================
-- Update leaderboards display
-- ============================================================
local function Update_All_Leaderboard_Displays()
	local function Get_LB_UI_Data(Key)
		local LB_M = Leaderboards_F:FindFirstChild(Key)
		if LB_M and LB_M.PrimaryPart and LB_M.PrimaryPart:FindFirstChildWhichIsA("SurfaceGui") then
			local Main_UI = LB_M.PrimaryPart:FindFirstChildWhichIsA("SurfaceGui")
			local Main_Data_F = Main_UI:FindFirstChild("Main_Data_F")
			if Main_Data_F and Main_Data_F:FindFirstChild("Tabs_F") and Main_Data_F:FindFirstChild("Tab_TMP") then
				Main_Data_F.CanvasPosition = Vector2.new(0, 0)
				return Main_Data_F:FindFirstChild("Tabs_F"), Main_Data_F:FindFirstChild("Tab_TMP")
			end
		end
		return nil, nil
	end

	local function Update_Leaderboard_Display(Key, Data)
		local Y_Pos = 0.0875
		local Tabs_F, Tab_TMP = Get_LB_UI_Data(Key)
		if Tabs_F and Tab_TMP then
			Tabs_F:ClearAllChildren()
			local UIList = Instance.new("UIListLayout")
			UIList.Parent = Tabs_F
			UIList.Padding = UDim.new(0.02, 0)
			UIList.SortOrder = Enum.SortOrder.LayoutOrder

			local function Create_New_Tab(Rank, Data)
				local ID = Data['ID'] or -1
				local Sort_Val = Data['Sort Val'] or 0
				local Country = Data['Country'] or "USA"

				local Tab = Tab_TMP:Clone()
				local Plr_Img = Tab:WaitForChild("Plr_Img")
				local Rank_Txt = Tab:WaitForChild("Rank_Txt")
				local P_Name_Txt = Tab:WaitForChild("P_Name_Txt")
				local P_DisplayName_Txt = Tab:WaitForChild("P_DisplayName_Txt")
				local P_Data_Val = Tab:WaitForChild("P_Data_Val")
				Tab.Parent = Tabs_F
				Tab.Position = UDim2.new(0.5, 0, Y_Pos, 0)
				Tab.Name = "Tab_" .. Rank
				Tab.LayoutOrder = Rank

				Tab:WaitForChild("Country_Img").Image = Country_Mod.Get_Flag_ID(Country)
				P_Data_Val.Text = Num_Str_Mod.NumToString(Sort_Val)
				if Key == "Gym Training" then
					P_Data_Val.Text = Time_Conversion(Sort_Val)
				end
				P_Data_Val.TextXAlignment = Enum.TextXAlignment.Center

				if Key == "Nation Elo" then
					Plr_Img.Visible = false
					Rank_Txt.Visible = true
					Rank_Txt.Text = "#" .. Rank
					P_DisplayName_Txt.Text = "Country"
					P_Name_Txt.Text = Country
				else
					if Rank <= 3 then
						Plr_Img.Image = Get_Player_Thumbnail(ID)
						Rank_Txt.Visible = false
						Plr_Img.Visible = true
					else
						Rank_Txt.Text = "#" .. Rank
						Rank_Txt.Visible = true
						Plr_Img.Visible = false
					end
					local Plr_Info_Data = Get_Player_Info_Data(ID)
					P_Name_Txt.Text = Plr_Info_Data.DisplayName or "Player Name"
					P_DisplayName_Txt.Text = "@" .. (Plr_Info_Data.Username or "Player")
				end

				Y_Pos += 0.175
				Tab.Visible = true
			end

			for i = 1, #Data do
				Create_New_Tab(i, Data[i])
			end
		end
	end

	local function tryGetData(leaderboardStore: OrderedDataStore)
		local success, data = pcall(function()
			return leaderboardStore:GetSortedAsync(false, 100)
		end)
		if success then return data else warn("Could not get leaderboard pages", data) end
	end

	local function tryGetPage(pages: DataStorePages)
		local success, page = pcall(function()
			return pages:GetCurrentPage()
		end)
		if success then return page else warn("Could not get page") end
	end


	for leaderboardType, leaderboardStore in pairs(LeaderboarStores) do

		local lbKey = LeaderboarKeys[leaderboardType]
		
		if not lbKey then continue end
		local leaderboardPages = tryGetData(leaderboardStore)
		if not leaderboardPages then continue end
		local currentPage = tryGetPage(leaderboardPages)
		if not currentPage then continue end

		local finalValues = {}
		for _, data in currentPage do
			local playerKey, playerValue = data.key, data.value
			if playerKey and playerValue then
				local score, countryId = DeserializeDataAndCountry(playerValue)
				local countryName = Country_Mod.Get_Country_Index_From_Number(countryId) or DEFAULT_COUNTRY
				table.insert(finalValues, {["Sort Val"] = score, Country = countryName, ID = playerKey})
			end
		end
		table.sort(finalValues, function(a, b) return a["Sort Val"] > b["Sort Val"] end)

		if lbKey == "Total Wins" then
			local oldTop = {}
			for userId, rank in pairs(module.TopPlayers) do oldTop[userId] = rank end
			module.TopPlayers = {}
			for i = 1, math.min(3, #finalValues) do
				module.TopPlayers[finalValues[i].ID] = i
			end
			Top3_Players_Updated:FireAllClients(module.TopPlayers, oldTop)
		end
		Update_Leaderboard_Display(lbKey, finalValues)
	end

	local finalValues = {}
	for i, v in pairs(NationEloData) do
		finalValues[#finalValues + 1] = {["Sort Val"] = v, Country = i, ID = 1}
	end
	table.sort(finalValues, function(a, b) return a["Sort Val"] > b["Sort Val"] end)
	Update_Leaderboard_Display("Nation Elo", finalValues)
end

-- ============================================================
-- Nation Elo
-- ============================================================
function module:ProcessNationElo()
	local entries = {}
	for _, v in pairs(module.NationElos) do
		entries[v[1]] = (entries[v[1]] or 0) + v[2]
	end
	for _ = 1, 5 do
		local success, err = pcall(function()
			NationEloStore:UpdateAsync(NationEloKey, function(data)
				data = data or {}
				for i in Country_Mod.Get_Country_Data() do
					if not data[i] then data[i] = 0 end
				end
				for i, v in pairs(entries) do
					if data[i] then data[i] += v end
				end
				NationEloData = data
				return data
			end)
		end)
		if success then break else warn(err) task.wait(1) end
	end
end

function module:RegisterNationElo(countryIndex: string, eloCount: number)
	if not countryIndex or not Country_Mod.Get_Country_Data()[countryIndex] then
		error(`Invalid Country Index {countryIndex}`)
	end
	if not eloCount or typeof(eloCount) ~= "number" then
		error(`Invalid Elo {eloCount}`)
	end
	table.insert(module.NationElos, {countryIndex, eloCount})
end

function module:_ClearNationElo()
	module.NationElos = {}
end

-- ============================================================
-- Init
-- ============================================================
function On_Init()
	game:BindToClose(function()
		module:ProcessNationElo()
		module:_ClearNationElo()
	end)

	-- DataStore loop
	task.defer(function()
		while true do
			module:ProcessNationElo()
			module:_ClearNationElo()

			for _, plr in ipairs(Players:GetPlayers()) do
				local key = plr.UserId
				local player_Data = plr:FindFirstChild("Player_Data")
				if not player_Data or not player_Data:FindFirstChild("Country") then continue end
				task.spawn(function()
					local countryId = player_Data["Country"].Value
					local updates = {
						{LeaderboarStores.Wins, "Total Wins"},
						{LeaderboarStores.Elo, "Elo"},
						{LeaderboarStores.Knockouts, "Leg Knockout Wins", "Punch Knockout Wins"},
						{LeaderboarStores.GymTraining, "Gym Training"},
						{LeaderboarStores.Submissions, "Submissions Wins"},
						{LeaderboarStores.RankedWins, "Ranked Wins"},
					}
					for _, entry in ipairs(updates) do
						local store, stat1, stat2 = entry[1], entry[2], entry[3]
						local val = player_Data[stat1].Value
						if stat2 then val = val + player_Data[stat2].Value end
						local serialized = SerializeDataAndCountry(val, countryId)
						if LastPlayerValues[key .. stat1] ~= serialized then
							LastPlayerValues[key .. stat1] = serialized
							DataStoreQueue:Add(store, key, serialized, "set")
						end
					end
					DataStoreQueue:Add(
						LeaderboarStores.WinStreak,
						key,
						function(old)
							local oldScore = 0
							if old then oldScore = DeserializeDataAndCountry(old) end
							return SerializeDataAndCountry(math.max(oldScore, player_Data["Win Streak"].Value), countryId)
						end,
						"update"
					)
					DataStoreQueue:Process()
				end)
			end
			task.wait(120 + math.random() * 30)
		end
	end)

	-- UI loop
	task.defer(function()
		while true do
			Update_All_Leaderboard_Displays()
			task.wait(30)
		end
	end)
end

task.spawn(On_Init)

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXEBF3FF496E554DDDBABBD8AB4C9CB5F1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Codes_Unique.lua</string>
					<string name="ScriptGuid">{41F718C8-F061-4F72-96F3-CA4C31928224}</string>
					<ProtectedString name="Source"><![CDATA[-- Please don't use it if you found it ok? 

local module = {
	[1] = { Code = "0F4AA7QH", Reward = "LargediamondsPack" },
	[2] = { Code = "0HKYWSP8", Reward = "LargediamondsPack" },
	[3] = { Code = "10IZX44L", Reward = "LargediamondsPack" },
	[4] = { Code = "14GN6X52", Reward = "LargediamondsPack" },
	[5] = { Code = "15UT4E3Z", Reward = "LargediamondsPack" },
	[6] = { Code = "19913MO4", Reward = "LargediamondsPack" },
	[7] = { Code = "1BNUVK7F", Reward = "LargediamondsPack" },
	[8] = { Code = "1C2U1RLN", Reward = "LargediamondsPack" },
	[9] = { Code = "1KRDOF81", Reward = "LargediamondsPack" },
	[10] = { Code = "1M10ZJZP", Reward = "LargediamondsPack" },
	[11] = { Code = "1QSWL6VL", Reward = "LargediamondsPack" },
	[12] = { Code = "1SX2XT0B", Reward = "LargediamondsPack" },
	[13] = { Code = "1WZ655T9", Reward = "LargediamondsPack" },
	[14] = { Code = "20R8HC0Y", Reward = "LargediamondsPack" },
	[15] = { Code = "2KXHOT67", Reward = "LargediamondsPack" },
	[16] = { Code = "2NDJ5X2Y", Reward = "LargediamondsPack" },
	[17] = { Code = "2NQT277O", Reward = "LargediamondsPack" },
	[18] = { Code = "2P19PY2A", Reward = "LargediamondsPack" },
	[19] = { Code = "2ZFYZXRM", Reward = "LargediamondsPack" },
	[20] = { Code = "3CXNXNU1", Reward = "LargediamondsPack" },
	[21] = { Code = "3UBMQZTV", Reward = "LargediamondsPack" },
	[22] = { Code = "3X8Z3Z4K", Reward = "LargediamondsPack" },
	[23] = { Code = "3XYU6H8Y", Reward = "LargediamondsPack" },
	[24] = { Code = "439W6RGZ", Reward = "LargediamondsPack" },
	[25] = { Code = "48JMAB7T", Reward = "LargediamondsPack" },
	[26] = { Code = "4KW3OAJW", Reward = "LargediamondsPack" },
	[27] = { Code = "4OU7J8DA", Reward = "LargediamondsPack" },
	[28] = { Code = "501AZUM9", Reward = "LargediamondsPack" },
	[29] = { Code = "558ZPVB5", Reward = "LargediamondsPack" },
	[30] = { Code = "5KZBMKTH", Reward = "LargediamondsPack" },
	[31] = { Code = "5UNQFNRJ", Reward = "LargediamondsPack" },
	[32] = { Code = "5URZ9ZYB", Reward = "LargediamondsPack" },
	[33] = { Code = "5YW22ETQ", Reward = "LargediamondsPack" },
	[34] = { Code = "5Z7N0JDV", Reward = "LargediamondsPack" },
	[35] = { Code = "60S4ANMM", Reward = "LargediamondsPack" },
	[36] = { Code = "61TI1NOA", Reward = "LargediamondsPack" },
	[37] = { Code = "62X05UA0", Reward = "LargediamondsPack" },
	[38] = { Code = "6K1VDR98", Reward = "LargediamondsPack" },
	[39] = { Code = "6Z8HT6GY", Reward = "LargediamondsPack" },
	[40] = { Code = "7CBC4PEM", Reward = "LargediamondsPack" },
	[41] = { Code = "7CLGYJVG", Reward = "LargediamondsPack" },
	[42] = { Code = "7DISFT94", Reward = "LargediamondsPack" },
	[43] = { Code = "7E77HGYF", Reward = "LargediamondsPack" },
	[44] = { Code = "7KBQE13T", Reward = "LargediamondsPack" },
	[45] = { Code = "83C5IK6X", Reward = "LargediamondsPack" },
	[46] = { Code = "8BTB895M", Reward = "LargediamondsPack" },
	[47] = { Code = "8OO3JRS8", Reward = "LargediamondsPack" },
	[48] = { Code = "8UHZ7DJJ", Reward = "LargediamondsPack" },
	[49] = { Code = "8VAT7N9S", Reward = "LargediamondsPack" },
	[50] = { Code = "8WNNHFNH", Reward = "LargediamondsPack" },
	[51] = { Code = "8XG2UAEB", Reward = "HugeMoneyPack" },
	[52] = { Code = "97SOH11Q", Reward = "HugeMoneyPack" },
	[53] = { Code = "9D5IS95K", Reward = "HugeMoneyPack" },
	[54] = { Code = "9FHE5UQ0", Reward = "HugeMoneyPack" },
	[55] = { Code = "9KI14Z3K", Reward = "HugeMoneyPack" },
	[56] = { Code = "9NL4KFHW", Reward = "HugeMoneyPack" },
	[57] = { Code = "9UPTYD0D", Reward = "HugeMoneyPack" },
	[58] = { Code = "A9REG5P5", Reward = "HugeMoneyPack" },
	[59] = { Code = "ABI9E1ZX", Reward = "HugeMoneyPack" },
	[60] = { Code = "B32J2CF1", Reward = "HugeMoneyPack" },
	[61] = { Code = "BCFAM7CY", Reward = "HugeMoneyPack" },
	[62] = { Code = "BEN0HJZE", Reward = "HugeMoneyPack" },
	[63] = { Code = "BISF3AP6", Reward = "HugeMoneyPack" },
	[64] = { Code = "BJT67NX4", Reward = "HugeMoneyPack" },
	[65] = { Code = "BLS4SV10", Reward = "HugeMoneyPack" },
	[66] = { Code = "BNUCD9P5", Reward = "HugeMoneyPack" },
	[67] = { Code = "BPQ18UV6", Reward = "HugeMoneyPack" },
	[68] = { Code = "BXXAIZVZ", Reward = "HugeMoneyPack" },
	[69] = { Code = "C39CESVQ", Reward = "HugeMoneyPack" },
	[70] = { Code = "C6MRCELC", Reward = "HugeMoneyPack" },
	[71] = { Code = "CBX6NGHM", Reward = "HugeMoneyPack" },
	[72] = { Code = "CESP2Y9G", Reward = "HugeMoneyPack" },
	[73] = { Code = "CLZ4WKKS", Reward = "HugeMoneyPack" },
	[74] = { Code = "CZMCBMUT", Reward = "HugeMoneyPack" },
	[75] = { Code = "D1HQGIVK", Reward = "HugeMoneyPack" },
	[76] = { Code = "D2R9HWU5", Reward = "HugeMoneyPack" },
	[77] = { Code = "D5WUIDLT", Reward = "HugeMoneyPack" },
	[78] = { Code = "D6AXGQA6", Reward = "HugeMoneyPack" },
	[79] = { Code = "D9GRWTMP", Reward = "HugeMoneyPack" },
	[80] = { Code = "DEL8JP7S", Reward = "HugeMoneyPack" },
	[81] = { Code = "E4IC5E9Q", Reward = "HugeMoneyPack" },
	[82] = { Code = "E4UCF9NN", Reward = "HugeMoneyPack" },
	[83] = { Code = "EI2IRGNC", Reward = "HugeMoneyPack" },
	[84] = { Code = "EIMW91OJ", Reward = "HugeMoneyPack" },
	[85] = { Code = "EJLXZ3YK", Reward = "HugeMoneyPack" },
	[86] = { Code = "ELS9BZFW", Reward = "HugeMoneyPack" },
	[87] = { Code = "ENVZQ2L4", Reward = "HugeMoneyPack" },
	[88] = { Code = "F483ND4N", Reward = "HugeMoneyPack" },
	[89] = { Code = "F8DGP7A2", Reward = "HugeMoneyPack" },
	[90] = { Code = "FW1NR7Y8", Reward = "HugeMoneyPack" },
	[91] = { Code = "G1LJIZMD", Reward = "HugeMoneyPack" },
	[92] = { Code = "G7DNO6SH", Reward = "HugeMoneyPack" },
	[93] = { Code = "GCNET6FQ", Reward = "HugeMoneyPack" },
	[94] = { Code = "GEXLW8H6", Reward = "HugeMoneyPack" },
	[95] = { Code = "GG6OO722", Reward = "HugeMoneyPack" },
	[96] = { Code = "GO7JN55V", Reward = "HugeMoneyPack" },
	[97] = { Code = "GOX4DJJ6", Reward = "HugeMoneyPack" },
	[98] = { Code = "GSGWHS1Y", Reward = "HugeMoneyPack" },
	[99] = { Code = "GUIWQY3D", Reward = "HugeMoneyPack" },
	[100] = { Code = "GUR2DBGA", Reward = "HugeMoneyPack" },
	[101] = { Code = "HN0ORKU6", Reward = "VIP" },
	[102] = { Code = "HUKUZG4W", Reward = "VIP" },
	[103] = { Code = "I6DC05DZ", Reward = "VIP" },
	[104] = { Code = "IJXCWQR7", Reward = "VIP" },
	[105] = { Code = "IK20LRQJ", Reward = "VIP" },
	[106] = { Code = "IO3I638K", Reward = "VIP" },
	[107] = { Code = "ISC3QNEV", Reward = "VIP" },
	[108] = { Code = "J6AZ1DBA", Reward = "VIP" },
	[109] = { Code = "JCHVHFU6", Reward = "VIP" },
	[110] = { Code = "JEZ0RRGT", Reward = "VIP" },
	[111] = { Code = "JGTQ289T", Reward = "VIP" },
	[112] = { Code = "JHDNSMCY", Reward = "VIP" },
	[113] = { Code = "JLA0ZLLK", Reward = "VIP" },
	[114] = { Code = "JWPLUJQU", Reward = "VIP" },
	[115] = { Code = "KAMBCNKU", Reward = "VIP" },
	[116] = { Code = "KDOLBVY9", Reward = "VIP" },
	[117] = { Code = "KG0XLM7H", Reward = "VIP" },
	[118] = { Code = "KUAEPF43", Reward = "VIP" },
	[119] = { Code = "KZDR7M6P", Reward = "VIP" },
	[120] = { Code = "L65PVTC6", Reward = "VIP" },
	[121] = { Code = "L8WNRB3X", Reward = "VIP" },
	[122] = { Code = "L92W30LG", Reward = "VIP" },
	[123] = { Code = "LL2U23RZ", Reward = "VIP" },
	[124] = { Code = "M3WE3SJA", Reward = "VIP" },
	[125] = { Code = "M9AUXMUK", Reward = "VIP" },
	[126] = { Code = "MBXLA7HO", Reward = "VIP" },
	[127] = { Code = "MI4RY2NU", Reward = "VIP" },
	[128] = { Code = "MJQP6P2Q", Reward = "VIP" },
	[129] = { Code = "MM8DJY4F", Reward = "VIP" },
	[130] = { Code = "MTTVWRZB", Reward = "VIP" },
	[131] = { Code = "MZV8TM0L", Reward = "VIP" },
	[132] = { Code = "N00V9RW5", Reward = "VIP" },
	[133] = { Code = "N1AZZT33", Reward = "VIP" },
	[134] = { Code = "N50DSEZ5", Reward = "VIP" },
	[135] = { Code = "NK8G3SYJ", Reward = "VIP" },
	[136] = { Code = "NKMENE1T", Reward = "VIP" },
	[137] = { Code = "NMFSXPUE", Reward = "VIP" },
	[138] = { Code = "NNQ2Z7AM", Reward = "VIP" },
	[139] = { Code = "NSE40IB6", Reward = "VIP" },
	[140] = { Code = "NWLL7JR2", Reward = "VIP" },
	[141] = { Code = "OEPW0FJN", Reward = "VIP" },
	[142] = { Code = "OMTHR179", Reward = "VIP" },
	[143] = { Code = "OZ64Q44N", Reward = "VIP" },
	[144] = { Code = "P2KV2XQD", Reward = "VIP" },
	[145] = { Code = "P3GSMKG4", Reward = "VIP" },
	[146] = { Code = "PCGX5IGZ", Reward = "VIP" },
	[147] = { Code = "PHXXAJ24", Reward = "VIP" },
	[148] = { Code = "Q6926TK4", Reward = "VIP" },
	[149] = { Code = "Q8DWMJP3", Reward = "VIP" },
	[150] = { Code = "QEEVIM6I", Reward = "VIP" },
	[151] = { Code = "QIPH9CDC", Reward = "2xCash" },
	[152] = { Code = "QV3TA3XW", Reward = "2xCash" },
	[153] = { Code = "R4ZRV0G7", Reward = "2xCash" },
	[154] = { Code = "ROYACZQP", Reward = "2xCash" },
	[155] = { Code = "RXQTR3PF", Reward = "2xCash" },
	[156] = { Code = "RZHKP3VU", Reward = "2xCash" },
	[157] = { Code = "S0HN2Q71", Reward = "2xCash" },
	[158] = { Code = "S4SX17ZW", Reward = "2xCash" },
	[159] = { Code = "S7WENIJ0", Reward = "2xCash" },
	[160] = { Code = "SERAD7DM", Reward = "2xCash" },
	[161] = { Code = "TNBMLWWI", Reward = "2xCash" },
	[162] = { Code = "TUFTJEFV", Reward = "2xCash" },
	[163] = { Code = "TVWFDAN2", Reward = "2xCash" },
	[164] = { Code = "TXU3HWWQ", Reward = "2xCash" },
	[165] = { Code = "TYOFWCLR", Reward = "2xCash" },
	[166] = { Code = "U3O0748S", Reward = "2xCash" },
	[167] = { Code = "U8Q6GCEL", Reward = "2xCash" },
	[168] = { Code = "URXJNJ20", Reward = "2xCash" },
	[169] = { Code = "VCFB0AY3", Reward = "2xCash" },
	[170] = { Code = "VECCLQZI", Reward = "2xCash" },
	[171] = { Code = "VGDDDCZ5", Reward = "2xCash" },
	[172] = { Code = "VOT6PV9H", Reward = "2xCash" },
	[173] = { Code = "VWI6J4GP", Reward = "2xCash" },
	[174] = { Code = "W5G7WRK1", Reward = "2xCash" },
	[175] = { Code = "W67HTAI0", Reward = "2xCash" },
	[176] = { Code = "WJE2L2AH", Reward = "2xCash" },
	[177] = { Code = "WNHGGXV6", Reward = "2xCash" },
	[178] = { Code = "X1TX6ML2", Reward = "2xCash" },
	[179] = { Code = "X2AV6CMJ", Reward = "2xCash" },
	[180] = { Code = "X6CXG5N3", Reward = "2xCash" },
	[181] = { Code = "X8O4T9WZ", Reward = "2xCash" },
	[182] = { Code = "XAA9X32H", Reward = "2xCash" },
	[183] = { Code = "XFLOVDT6", Reward = "2xCash" },
	[184] = { Code = "XIA3MHHW", Reward = "2xCash" },
	[185] = { Code = "XPJXNJTP", Reward = "2xCash" },
	[186] = { Code = "XR8C5UP5", Reward = "2xCash" },
	[187] = { Code = "XTT1WSWW", Reward = "2xCash" },
	[188] = { Code = "XV42E9FY", Reward = "2xCash" },
	[189] = { Code = "XWRH3238", Reward = "2xCash" },
	[190] = { Code = "Y6KB215X", Reward = "2xCash" },
	[191] = { Code = "Y97K6RSD", Reward = "2xCash" },
	[192] = { Code = "Y9WZ853N", Reward = "2xCash" },
	[193] = { Code = "YX3L9RI7", Reward = "2xCash" },
	[194] = { Code = "Z2MKCG7I", Reward = "2xCash" },
	[195] = { Code = "Z2PB5XLR", Reward = "2xCash" },
	[196] = { Code = "ZBQK5OCX", Reward = "2xCash" },
	[197] = { Code = "ZK4HTGHR", Reward = "2xCash" },
	[198] = { Code = "ZLLMN82A", Reward = "2xCash" },
	[199] = { Code = "ZNDD0LEH", Reward = "2xCash" },
	[200] = { Code = "ZRE97OI4", Reward = "2xCash" },
	

	[201] = { Code = "S8CNP5LB", Reward = "LargediamondsPack" },
	[202] = { Code = "3XJSEW6B", Reward = "LargediamondsPack" },
	[203] = { Code = "QLSOODMH", Reward = "LargediamondsPack" },
	[204] = { Code = "XL035IAI", Reward = "LargediamondsPack" },
	[205] = { Code = "PDGV1BTL", Reward = "LargediamondsPack" },
	[206] = { Code = "DH4SS86R", Reward = "LargediamondsPack" },
	[207] = { Code = "7OSE00LH", Reward = "LargediamondsPack" },
	[208] = { Code = "7NSW0NZE", Reward = "LargediamondsPack" },
	[209] = { Code = "Q7VTBWJ0", Reward = "LargediamondsPack" },
	[210] = { Code = "W4XRZM10", Reward = "LargediamondsPack" },
	[211] = { Code = "XFQ65JKB", Reward = "LargediamondsPack" },
	[212] = { Code = "DYW32ZGI", Reward = "LargediamondsPack" },
	[213] = { Code = "DJI5GQJG", Reward = "LargediamondsPack" },
	[214] = { Code = "0ZPKFVTS", Reward = "LargediamondsPack" },
	[215] = { Code = "HK6F1ZFF", Reward = "LargediamondsPack" },
	[216] = { Code = "8KAKSGUY", Reward = "LargediamondsPack" },
	[217] = { Code = "MVNJBLNG", Reward = "LargediamondsPack" },
	[218] = { Code = "2DOQ4HZY", Reward = "LargediamondsPack" },
	[219] = { Code = "BSZX4SJ9", Reward = "LargediamondsPack" },
	[220] = { Code = "LDY8OOHZ", Reward = "LargediamondsPack" },
	[221] = { Code = "4F78D3FM", Reward = "LargediamondsPack" },
	[222] = { Code = "6CCK0IDS", Reward = "LargediamondsPack" },
	[223] = { Code = "8L9UZSL2", Reward = "LargediamondsPack" },
	[224] = { Code = "9DXA8HUN", Reward = "LargediamondsPack" },
	[225] = { Code = "DQNFSXIZ", Reward = "LargediamondsPack" },
	[226] = { Code = "LFKAC83L", Reward = "LargediamondsPack" },
	[227] = { Code = "V49JM0BG", Reward = "LargediamondsPack" },
	[228] = { Code = "76BVVTA1", Reward = "LargediamondsPack" },
	[229] = { Code = "GVS2ITMR", Reward = "LargediamondsPack" },
	[230] = { Code = "NJW8S8IZ", Reward = "LargediamondsPack" },
	[231] = { Code = "ZBMKUOD5", Reward = "LargediamondsPack" },
	[232] = { Code = "BIDBL2RR", Reward = "LargediamondsPack" },
	[233] = { Code = "EL1KRM26", Reward = "LargediamondsPack" },
	[234] = { Code = "7FB8VO3N", Reward = "LargediamondsPack" },
	[235] = { Code = "ZH5CPNCM", Reward = "LargediamondsPack" },
	[236] = { Code = "CFXG835S", Reward = "LargediamondsPack" },
	[237] = { Code = "DGP731KN", Reward = "LargediamondsPack" },
	[238] = { Code = "PXTP8WYW", Reward = "LargediamondsPack" },
	[239] = { Code = "DF63M6E9", Reward = "LargediamondsPack" },
	[240] = { Code = "E24QZLBG", Reward = "LargediamondsPack" },
	[241] = { Code = "63WK497B", Reward = "LargediamondsPack" },
	[242] = { Code = "WHZ991HD", Reward = "LargediamondsPack" },
	[243] = { Code = "RWD44SRY", Reward = "LargediamondsPack" },
	[244] = { Code = "H0K61DOY", Reward = "LargediamondsPack" },
	[245] = { Code = "OIIRN9MM", Reward = "LargediamondsPack" },
	[246] = { Code = "4ULM3WX8", Reward = "LargediamondsPack" },
	[247] = { Code = "RMAURGSB", Reward = "LargediamondsPack" },
	[248] = { Code = "2UFUQHIP", Reward = "LargediamondsPack" },
	[249] = { Code = "OKIUDD4N", Reward = "LargediamondsPack" },
	[250] = { Code = "1YY4D94V", Reward = "LargediamondsPack" },
	[251] = { Code = "XC6ND0PP", Reward = "LargediamondsPack" },
	[252] = { Code = "G2AK3VJD", Reward = "LargediamondsPack" },
	[253] = { Code = "A5S8CMV7", Reward = "LargediamondsPack" },
	[254] = { Code = "VFC9MXW5", Reward = "LargediamondsPack" },
	[255] = { Code = "TCP2C0P0", Reward = "LargediamondsPack" },
	[256] = { Code = "OC8VS7RY", Reward = "LargediamondsPack" },
	[257] = { Code = "KAIVDZSD", Reward = "LargediamondsPack" },
	[258] = { Code = "P25SAMVJ", Reward = "LargediamondsPack" },
	[259] = { Code = "47NVVMY0", Reward = "LargediamondsPack" },
	[260] = { Code = "N6NLDKXC", Reward = "LargediamondsPack" },
	[261] = { Code = "41OV62VW", Reward = "LargediamondsPack" },
	[262] = { Code = "2Z3TTGD0", Reward = "LargediamondsPack" },
	[263] = { Code = "ZVYO5EIR", Reward = "LargediamondsPack" },
	[264] = { Code = "Y1ZMNKBM", Reward = "LargediamondsPack" },
	[265] = { Code = "U04VI1WP", Reward = "LargediamondsPack" },
	[266] = { Code = "NDQ8EWGE", Reward = "LargediamondsPack" },
	[267] = { Code = "GBM227XY", Reward = "LargediamondsPack" },
	[268] = { Code = "3G04V90V", Reward = "LargediamondsPack" },
	[269] = { Code = "NYO8NFUJ", Reward = "LargediamondsPack" },
	[270] = { Code = "I2825ANM", Reward = "LargediamondsPack" },
	[271] = { Code = "T1UCF27J", Reward = "LargediamondsPack" },
	[272] = { Code = "28UI1Z6J", Reward = "LargediamondsPack" },
	[273] = { Code = "JJZ2JQZH", Reward = "LargediamondsPack" },
	[274] = { Code = "U41Y1GS2", Reward = "LargediamondsPack" },
	[275] = { Code = "1CWROZCB", Reward = "LargediamondsPack" },
	[276] = { Code = "KI7AATOC", Reward = "HugeMoneyPack" },
	[277] = { Code = "5KLHVGYZ", Reward = "HugeMoneyPack" },
	[278] = { Code = "PFW8QVWG", Reward = "HugeMoneyPack" },
	[279] = { Code = "CWP52RO6", Reward = "HugeMoneyPack" },
	[280] = { Code = "W4AX1MJV", Reward = "HugeMoneyPack" },
	[281] = { Code = "B7HA9TFE", Reward = "HugeMoneyPack" },
	[282] = { Code = "V2NFVIRD", Reward = "HugeMoneyPack" },
	[283] = { Code = "90VUI4G2", Reward = "HugeMoneyPack" },
	[284] = { Code = "I27K2VCA", Reward = "HugeMoneyPack" },
	[285] = { Code = "M8NB007X", Reward = "HugeMoneyPack" },
	[286] = { Code = "1IJ8JLD0", Reward = "HugeMoneyPack" },
	[287] = { Code = "P8B0EGCU", Reward = "HugeMoneyPack" },
	[288] = { Code = "JW60CRJH", Reward = "HugeMoneyPack" },
	[289] = { Code = "4D9ZRO2V", Reward = "HugeMoneyPack" },
	[290] = { Code = "AAIKNDRE", Reward = "HugeMoneyPack" },
	[291] = { Code = "S99UEG1N", Reward = "HugeMoneyPack" },
	[292] = { Code = "ZGONI1C0", Reward = "HugeMoneyPack" },
	[293] = { Code = "SJ2PYB17", Reward = "HugeMoneyPack" },
	[294] = { Code = "4BW8N04E", Reward = "HugeMoneyPack" },
	[295] = { Code = "NXNWQSW4", Reward = "HugeMoneyPack" },
	[296] = { Code = "6FK2BTBP", Reward = "HugeMoneyPack" },
	[297] = { Code = "BNCUL0P5", Reward = "HugeMoneyPack" },
	[298] = { Code = "DP9A12LQ", Reward = "HugeMoneyPack" },
	[299] = { Code = "6OZDYX4T", Reward = "HugeMoneyPack" },
	[300] = { Code = "ZC62LYRU", Reward = "HugeMoneyPack" },
	[301] = { Code = "2ISL57QK", Reward = "HugeMoneyPack" },
	[302] = { Code = "T7WKTVCU", Reward = "HugeMoneyPack" },
	[303] = { Code = "HRB6JTTS", Reward = "HugeMoneyPack" },
	[304] = { Code = "3QWQ9DHN", Reward = "HugeMoneyPack" },
	[305] = { Code = "PZOSP170", Reward = "HugeMoneyPack" },
	[306] = { Code = "3QBP1C7R", Reward = "HugeMoneyPack" },
	[307] = { Code = "YBCE8G57", Reward = "HugeMoneyPack" },
	[308] = { Code = "8CVM386Z", Reward = "HugeMoneyPack" },
	[309] = { Code = "8LCX5HIF", Reward = "HugeMoneyPack" },
	[310] = { Code = "DNMCHQRG", Reward = "HugeMoneyPack" },
	[311] = { Code = "DAT14YRN", Reward = "HugeMoneyPack" },
	[312] = { Code = "PRTRJNS7", Reward = "HugeMoneyPack" },
	[313] = { Code = "PTPQJLVZ", Reward = "HugeMoneyPack" },
	[314] = { Code = "4WBEB73T", Reward = "HugeMoneyPack" },
	[315] = { Code = "P4DBLH4C", Reward = "HugeMoneyPack" },
	[316] = { Code = "4IRUS17M", Reward = "HugeMoneyPack" },
	[317] = { Code = "IWED5SE6", Reward = "HugeMoneyPack" },
	[318] = { Code = "AD9TT6G6", Reward = "HugeMoneyPack" },
	[319] = { Code = "4PUEU091", Reward = "HugeMoneyPack" },
	[320] = { Code = "29F8FTI6", Reward = "HugeMoneyPack" },
	[321] = { Code = "9RDV2JAN", Reward = "HugeMoneyPack" },
	[322] = { Code = "HOVBV0LA", Reward = "HugeMoneyPack" },
	[323] = { Code = "Y14OST8E", Reward = "HugeMoneyPack" },
	[324] = { Code = "7ZD4AH4M", Reward = "HugeMoneyPack" },
	[325] = { Code = "XXICT35N", Reward = "HugeMoneyPack" },
	[326] = { Code = "BYIAIYX5", Reward = "HugeMoneyPack" },
	[327] = { Code = "IJICQ681", Reward = "HugeMoneyPack" },
	[328] = { Code = "SFWMYU3C", Reward = "HugeMoneyPack" },
	[329] = { Code = "L5P402IS", Reward = "HugeMoneyPack" },
	[330] = { Code = "MUX2BDMQ", Reward = "HugeMoneyPack" },
	[331] = { Code = "EZV6CBUV", Reward = "HugeMoneyPack" },
	[332] = { Code = "ZJLHT63H", Reward = "HugeMoneyPack" },
	[333] = { Code = "7K1Z14SN", Reward = "HugeMoneyPack" },
	[334] = { Code = "Q09RAF37", Reward = "HugeMoneyPack" },
	[335] = { Code = "LCXY3MDB", Reward = "HugeMoneyPack" },
	[336] = { Code = "MW73LTEG", Reward = "HugeMoneyPack" },
	[337] = { Code = "CA32A6KM", Reward = "HugeMoneyPack" },
	[338] = { Code = "RC82WIDM", Reward = "HugeMoneyPack" },
	[339] = { Code = "W8220JQJ", Reward = "HugeMoneyPack" },
	[340] = { Code = "EIS2VFGV", Reward = "HugeMoneyPack" },
	[341] = { Code = "0H9IWDEV", Reward = "HugeMoneyPack" },
	[342] = { Code = "TJSLQ6HP", Reward = "HugeMoneyPack" },
	[343] = { Code = "22WJB57C", Reward = "HugeMoneyPack" },
	[344] = { Code = "66JNO0MA", Reward = "HugeMoneyPack" },
	[345] = { Code = "8GJKI20K", Reward = "HugeMoneyPack" },
	[346] = { Code = "ZUX1SR8Q", Reward = "HugeMoneyPack" },
	[347] = { Code = "NRFDYD84", Reward = "HugeMoneyPack" },
	[348] = { Code = "L5EYCK0Z", Reward = "HugeMoneyPack" },
	[349] = { Code = "YXFMW2XB", Reward = "HugeMoneyPack" },
	[350] = { Code = "XYFTO5BB", Reward = "HugeMoneyPack" },
	[351] = { Code = "EN34JXR3", Reward = "VIP" },
	[352] = { Code = "S8ICOB2W", Reward = "VIP" },
	[353] = { Code = "UXJ4BCYF", Reward = "VIP" },
	[354] = { Code = "SUKHH4K7", Reward = "VIP" },
	[355] = { Code = "HQCIDIKL", Reward = "VIP" },
	[356] = { Code = "MY51Z4YE", Reward = "VIP" },
	[357] = { Code = "CEVQG2K8", Reward = "VIP" },
	[358] = { Code = "G6I8I5X1", Reward = "VIP" },
	[359] = { Code = "VNQ5OWNV", Reward = "VIP" },
	[360] = { Code = "VCJ7EXQ4", Reward = "VIP" },
	[361] = { Code = "K4D3WDJZ", Reward = "VIP" },
	[362] = { Code = "VAHTVFYV", Reward = "VIP" },
	[363] = { Code = "4Y4G4EDC", Reward = "VIP" },
	[364] = { Code = "46W05LOU", Reward = "VIP" },
	[365] = { Code = "3N5QQKOG", Reward = "VIP" },
	[366] = { Code = "IKXZU11E", Reward = "VIP" },
	[367] = { Code = "8EI8IC4C", Reward = "VIP" },
	[368] = { Code = "1JC0YG6P", Reward = "VIP" },
	[369] = { Code = "PWL6C3B7", Reward = "VIP" },
	[370] = { Code = "NM0PITXK", Reward = "VIP" },
	[371] = { Code = "DTIOTHKR", Reward = "VIP" },
	[372] = { Code = "X5B2D25U", Reward = "VIP" },
	[373] = { Code = "6ELDCSOJ", Reward = "VIP" },
	[374] = { Code = "B4MF7KQ9", Reward = "VIP" },
	[375] = { Code = "ARUYR5R2", Reward = "VIP" },
	[376] = { Code = "EO5CN5PM", Reward = "VIP" },
	[377] = { Code = "XGGRGOR3", Reward = "VIP" },
	[378] = { Code = "09BMAYH0", Reward = "VIP" },
	[379] = { Code = "MDGPU025", Reward = "VIP" },
	[380] = { Code = "LJHK33SV", Reward = "VIP" },
	[381] = { Code = "BP16M77R", Reward = "VIP" },
	[382] = { Code = "MF5ULG0I", Reward = "VIP" },
	[383] = { Code = "PHXZ478J", Reward = "VIP" },
	[384] = { Code = "IOXCQVDS", Reward = "VIP" },
	[385] = { Code = "Q2EUAY81", Reward = "VIP" },
	[386] = { Code = "WVN37RNR", Reward = "VIP" },
	[387] = { Code = "YJANS37L", Reward = "VIP" },
	[388] = { Code = "US8VYL5O", Reward = "VIP" },
	[389] = { Code = "DY01W3UX", Reward = "VIP" },
	[390] = { Code = "BIZ9S2SF", Reward = "VIP" },
	[391] = { Code = "DR5YJHXT", Reward = "VIP" },
	[392] = { Code = "F71M2PQR", Reward = "VIP" },
	[393] = { Code = "G5UGCMSZ", Reward = "VIP" },
	[394] = { Code = "DFGKAJNA", Reward = "VIP" },
	[395] = { Code = "4OQCU4W3", Reward = "VIP" },
	[396] = { Code = "7MBKO086", Reward = "VIP" },
	[397] = { Code = "M64FFPX6", Reward = "VIP" },
	[398] = { Code = "481XCJDT", Reward = "VIP" },
	[399] = { Code = "9BIKKTBU", Reward = "VIP" },
	[400] = { Code = "TTSTWATK", Reward = "VIP" },
	[401] = { Code = "Y1UINTKD", Reward = "VIP" },
	[402] = { Code = "8MR8D3BE", Reward = "VIP" },
	[403] = { Code = "Z3GLT2KN", Reward = "VIP" },
	[404] = { Code = "GZVXKS9K", Reward = "VIP" },
	[405] = { Code = "08KHTPD7", Reward = "VIP" },
	[406] = { Code = "14C2Y52M", Reward = "VIP" },
	[407] = { Code = "I7JULYBD", Reward = "VIP" },
	[408] = { Code = "7VR3YRDB", Reward = "VIP" },
	[409] = { Code = "N4RZIAE3", Reward = "VIP" },
	[410] = { Code = "29VWZCPO", Reward = "VIP" },
	[411] = { Code = "GYY44TXG", Reward = "VIP" },
	[412] = { Code = "HGNTT2UG", Reward = "VIP" },
	[413] = { Code = "60KZNFQP", Reward = "VIP" },
	[414] = { Code = "XVYOAH54", Reward = "VIP" },
	[415] = { Code = "145XJ3ZL", Reward = "VIP" },
	[416] = { Code = "KJ0CTSCG", Reward = "VIP" },
	[417] = { Code = "YDAT5704", Reward = "VIP" },
	[418] = { Code = "ET0ECGNR", Reward = "VIP" },
	[419] = { Code = "RCRVF7HB", Reward = "VIP" },
	[420] = { Code = "MI7BE4QM", Reward = "VIP" },
	[421] = { Code = "PLDYPQU6", Reward = "VIP" },
	[422] = { Code = "XD6Y0TLA", Reward = "VIP" },
	[423] = { Code = "FHA7W109", Reward = "VIP" },
	[424] = { Code = "ZJ6V268L", Reward = "VIP" },
	[425] = { Code = "T5MPFAVU", Reward = "VIP" },
	[426] = { Code = "IVQFGDA0", Reward = "2xCash" },
	[427] = { Code = "IF1C81MZ", Reward = "2xCash" },
	[428] = { Code = "X2BXEKJ3", Reward = "2xCash" },
	[429] = { Code = "U7VK1MCC", Reward = "2xCash" },
	[430] = { Code = "P5BA4WQA", Reward = "2xCash" },
	[431] = { Code = "OZV24I1M", Reward = "2xCash" },
	[432] = { Code = "ECTXNLA1", Reward = "2xCash" },
	[433] = { Code = "93247GZR", Reward = "2xCash" },
	[434] = { Code = "DWGFK46R", Reward = "2xCash" },
	[435] = { Code = "FF9HXH2F", Reward = "2xCash" },
	[436] = { Code = "6U0WKZZM", Reward = "2xCash" },
	[437] = { Code = "Y9E7GBC9", Reward = "2xCash" },
	[438] = { Code = "J3LMVTV0", Reward = "2xCash" },
	[439] = { Code = "J5PXWZH3", Reward = "2xCash" },
	[440] = { Code = "DLKF1ZW0", Reward = "2xCash" },
	[441] = { Code = "GPV818U4", Reward = "2xCash" },
	[442] = { Code = "PGFCM7X5", Reward = "2xCash" },
	[443] = { Code = "I4GK0ZKF", Reward = "2xCash" },
	[444] = { Code = "GFWK918G", Reward = "2xCash" },
	[445] = { Code = "03PO6269", Reward = "2xCash" },
	[446] = { Code = "O4Y8X0QS", Reward = "2xCash" },
	[447] = { Code = "OYEPR498", Reward = "2xCash" },
	[448] = { Code = "WNH09X6J", Reward = "2xCash" },
	[449] = { Code = "LYZUCFKX", Reward = "2xCash" },
	[450] = { Code = "M8R96551", Reward = "2xCash" },
	[451] = { Code = "BK7YXQQ2", Reward = "2xCash" },
	[452] = { Code = "TN5RAI7O", Reward = "2xCash" },
	[453] = { Code = "UXTOPGMK", Reward = "2xCash" },
	[454] = { Code = "IPBJZBQN", Reward = "2xCash" },
	[455] = { Code = "VJ8F8XZF", Reward = "2xCash" },
	[456] = { Code = "ACYZD2RL", Reward = "2xCash" },
	[457] = { Code = "9XO0F40U", Reward = "2xCash" },
	[458] = { Code = "UDNMT2B0", Reward = "2xCash" },
	[459] = { Code = "27RXFWGP", Reward = "2xCash" },
	[460] = { Code = "42UFZJDJ", Reward = "2xCash" },
	[461] = { Code = "WA1GEA65", Reward = "2xCash" },
	[462] = { Code = "4LM2MG7X", Reward = "2xCash" },
	[463] = { Code = "XU3TV27R", Reward = "2xCash" },
	[464] = { Code = "R8F54DC3", Reward = "2xCash" },
	[465] = { Code = "4A8DP8C3", Reward = "2xCash" },
	[466] = { Code = "KDDMD7WB", Reward = "2xCash" },
	[467] = { Code = "OQLIBAIP", Reward = "2xCash" },
	[468] = { Code = "M6D93MQ6", Reward = "2xCash" },
	[469] = { Code = "V0BUZE8I", Reward = "2xCash" },
	[470] = { Code = "ZWZMXTUL", Reward = "2xCash" },
	[471] = { Code = "PI28LN0B", Reward = "2xCash" },
	[472] = { Code = "FB6BH30M", Reward = "2xCash" },
	[473] = { Code = "KSMO8BAQ", Reward = "2xCash" },
	[474] = { Code = "QEHN8WCX", Reward = "2xCash" },
	[475] = { Code = "PFRAJJW6", Reward = "2xCash" },
	[476] = { Code = "PVZT7LCJ", Reward = "2xCash" },
	[477] = { Code = "57NXTPK8", Reward = "2xCash" },
	[478] = { Code = "CUO5F2GA", Reward = "2xCash" },
	[479] = { Code = "5TX7Y2WA", Reward = "2xCash" },
	[480] = { Code = "I6UYGFES", Reward = "2xCash" },
	[481] = { Code = "9G5QUK1Y", Reward = "2xCash" },
	[482] = { Code = "8EZ9OEIL", Reward = "2xCash" },
	[483] = { Code = "Y2KAWO4R", Reward = "2xCash" },
	[484] = { Code = "SVXTO11B", Reward = "2xCash" },
	[485] = { Code = "RKUYM5I1", Reward = "2xCash" },
	[486] = { Code = "HZZVVVCH", Reward = "2xCash" },
	[487] = { Code = "BX95ETUY", Reward = "2xCash" },
	[488] = { Code = "7R75UZV4", Reward = "2xCash" },
	[489] = { Code = "1REMDIJG", Reward = "2xCash" },
	[490] = { Code = "N9K537BB", Reward = "2xCash" },
	[491] = { Code = "819NN9FF", Reward = "2xCash" },
	[492] = { Code = "NF05ZHRD", Reward = "2xCash" },
	[493] = { Code = "1HL0QTC3", Reward = "2xCash" },
	[494] = { Code = "NQV9J0AH", Reward = "2xCash" },
	[495] = { Code = "SGF2E6M7", Reward = "2xCash" },
	[496] = { Code = "LAWFRHWU", Reward = "2xCash" },
	[497] = { Code = "BUE0TS0Q", Reward = "2xCash" },
	[498] = { Code = "GR66HY75", Reward = "2xCash" },
	[499] = { Code = "8QYN92ZR", Reward = "2xCash" },
	[500] = { Code = "415FTHKP", Reward = "2xCash" },
}

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX31EC1C3B80A749B081E4E13E7AF632E1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GAModule.lua</string>
					<string name="ScriptGuid">{307E0129-BE45-4066-88B7-D338C4E4978B}</string>
					<ProtectedString name="Source"><![CDATA[local GAModule = {}

local GameAnalytics = require(game.ReplicatedStorage.GameAnalytics)

function GAModule:CreatorSupported(player:Player, creatorId: string, robuxAmount: number)
	if not creatorId or not robuxAmount then
		warn("Missing creatorId or robuxAmount for GA log.")
		return
	end

	GameAnalytics:addBusinessEvent(
		player.UserId,
		{
			currency = "Robux",
			amount = robuxAmount,
			itemType = "DevProduct",
			itemId = "WithCreatorCode",
			cartType = tostring(creatorId)
		}
	)
end

function GAModule:Init()
	GameAnalytics:setEnabledInfoLog(false)
	GameAnalytics:setEnabledVerboseLog(false)
	-- FIX this ask to Mihai if there was a "good" to do this horror
	GameAnalytics:initServer(
		"acf2fbabbd9612a55e53d758fa5f8184", 
		"108c93f6570a18f37d56abda957bbb2c1a8bfb2e"
	) -- I know it's bad but setting up secrets would have been a pain in this project. Sorry
end

GAModule:Init()

return GAModule
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXCFE1456B1B2C4BE29D6F07ADF64705D6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">OffersService.server.lua</string>
					<string name="ScriptGuid">{80C8E2A2-3BDF-4EE2-AF9E-4163DAEB4431}</string>
					<ProtectedString name="Source"><![CDATA[local RS  = game:GetService("ReplicatedStorage")
local MPS = game:GetService("MarketplaceService")

local Data_Mods_F       = RS:WaitForChild("Data_Mods_F")
local Monetization_Mod  = require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Offers_Config    = require(Data_Mods_F:WaitForChild("Offers_Config"))

local Remotes = RS:FindFirstChild("Remotes") or Instance.new("Folder", RS); Remotes.Name = "Remotes"

local Offers  = Remotes:FindFirstChild("Offers") or Instance.new("Folder", Remotes); Offers.Name = "Offers"
local UGC = Offers:FindFirstChild("UGC") or Instance.new("Folder", Offers); UGC.Name = "UGC"

local GetActiveOffers = Offers:FindFirstChild("GetActiveOffers") or Instance.new("RemoteFunction", Offers)
GetActiveOffers.Name = "GetActiveOffers"

local RequestPurchase = Offers:FindFirstChild("RequestPurchase") or Instance.new("RemoteEvent", Offers)
RequestPurchase.Name = "RequestPurchase"

local SendOfferToClint = Offers:FindFirstChild("SendOfferToClint") or Instance.new("RemoteEvent", Offers)
SendOfferToClint.Name = "SendOfferToClint"

local ShowOfferSignalBind = UGC:FindFirstChild("ShowOfferSignalBind") or Instance.new("BindableEvent", UGC)
ShowOfferSignalBind.Name = "ShowOfferSignalBind"

local SendOwnershipDataClient = UGC:WaitForChild("SendOwnershipDataClient")
local ApplyOwnership = UGC:WaitForChild("ApplyOwnership")
local GetUGCItemOffer = UGC:WaitForChild("GetUGCItemOffer")
local GetNewClothOffer = Offers:WaitForChild("GetNewClothOffer")
local ClothItemIdSignal = Offers:WaitForChild("ClothItemIdSignal")
local ShowMessage = Offers:WaitForChild("ShowMessage")


function GetNewClothOffer.OnServerInvoke(plr)
	
	local top = Offers_Config.GetAndCreateClothOffer(plr)
	if not top then return nil end
	return top
	
end

ShowOfferSignalBind.Event:Connect(function(plr, Kind,ItemKey)
	
	local top = Offers_Config.getOfferByKey(plr,Kind,ItemKey)
	if not top and (Kind=="Gloves" or Kind=="Shorts") then
		local offer = Offers_Config.loadOfferState(plr,"ClothOffer_")
		if offer then
			Offers_Config.InsertOffer(offer.ActiveOffer.offer)
		end
		top = Offers_Config.getOfferByKey(plr,Kind,ItemKey)
	end
	if not top then return {} end
	SendOfferToClint:FireClient(plr,top )
	
end)


function GetActiveOffers.OnServerInvoke(plr)

	local top = Offers_Config.pickTopOffer(plr)
	if not top then return {} end
	return { top }
	
end

function GetUGCItemOffer.OnServerInvoke (plr)
	
	return Offers_Config.GetUGCItemNew(plr)
end

RequestPurchase.OnServerEvent:Connect(function(plr,productKind, productKey)
	if type(productKey) ~= "string" then return end

	-- Confirm theyre still eligible for the picked offer
	local top = Offers_Config.getOfferByKey(plr,productKind,productKey)
	if not top or top.ProductKey ~= productKey then return end
	
	if top.EndsAt and top.EndsAt > 0 and os.time() > top.EndsAt then return end

	if top.Kind == "DevProduct" then
		local dev = Monetization_Mod.Get_All_Dev_Product_Data()[productKey]
		if dev and dev.ID then MPS:PromptProductPurchase(plr, dev.ID) end
		return
	end
	
	if top.Kind == "UGC" then
		local gp = Monetization_Mod.Get_All_UGC_Data()[productKey]
		if gp and gp.ID then MPS:PromptPurchase(plr, gp.ID) end
		return
	end
	
	if top.Kind == "Gamepass" then
		
		
			local PD    = plr:FindFirstChild("Player_Data")
			local coins = PD and PD:FindFirstChild("Coins")
			local price = tonumber(top.NewPrice) or 0

			if coins and coins.Value >= price then
				coins.Value = coins.Value - price

				-- Get the real GP_ID from Monetization_Mod
				local gp = Monetization_Mod.Get_All_Gamepass_Data()[productKey]
				if gp and gp.ID then
					-- Grant perks using the bindable event
					local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
					local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
					Bindable_Events_F:WaitForChild("Grant_Gamepass_Perks"):Fire(plr, gp.ID)

					ShowMessage:FireClient(plr, gp.Name .. " unlocked with coins!", true)
				else
					ShowMessage:FireClient(plr, "Something went wrong. GP not found.", false)
					coins.Value = coins.Value + price -- refund
				end
			else
				ShowMessage:FireClient(plr, "Not enough coins!", false)
			end
	
		
		--local gp = Monetization_Mod.Get_All_Gamepass_Data()[productKey]
		--if gp and gp.ID then MPS:PromptGamePassPurchase(plr, gp.ID) end
		return
	end
	
	if top.Kind == "Gloves" then
		local key = top.Ownership and top.Ownership.Key
		if not key then return end
		local PD = plr:FindFirstChild("Player_Data")
		local coins = PD and PD:FindFirstChild("Coins")
		if coins and tonumber(coins.Value) >= top.NewPrice then
			coins.Value = coins.Value - top.NewPrice
			local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
			Clothing_Mod.Give_Player_Gloves(plr, key)
			ApplyOwnership:Fire(plr)
			ClothItemIdSignal:FireClient(plr)
			ShowMessage:FireClient(plr, "Item purchased you can apply on your avatar!", true)
		else
			ShowMessage:FireClient(plr, "You need more coins!",false)
		end
		return
	end

	-- Handle Shorts purchase with coins
	if top.Kind == "Shorts" then
		local key = top.Ownership and top.Ownership.Key
		if not key then return end
		local PD = plr:FindFirstChild("Player_Data")
		local coins = PD and PD:FindFirstChild("Coins")
		if coins and tonumber(coins.Value) >= top.NewPrice then
			coins.Value = coins.Value - top.NewPrice
			local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
			Clothing_Mod.Give_Player_Shorts(plr, key)
			ApplyOwnership:Fire(plr)
			ClothItemIdSignal:FireClient(plr)
			ShowMessage:FireClient(plr, "Item purchased you can apply on your avatar!", true)
		else
			ShowMessage:FireClient(plr, "You need more coins!",false)
		end
		return
	end
	
end)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXD46F382E666844498E3C44689E511FD3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Core_Handles_F</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX0E7AB783FD7448808BD6169ED39C761D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Badge_Attribute_Handle.server.lua</string>
						<string name="ScriptGuid">{7935EE31-A5D1-42E2-9139-13E4AF584991}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	* Award Badges & Check
	* Check if Player's within Group
]]--
local BS = game:GetService("BadgeService")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Receiving_RF = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("RF")
local Group_ID = 35784641

local function Player_Owns_Badge(Plr, Badge_ID)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = BS:UserHasBadgeAsync(Plr.UserId, Badge_ID)
		end)
		
		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end
	
	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end
	
	return false
end

local function Award_Badge_Handle(Plr, Badge_ID)
	if(Player_Owns_Badge(Plr, Badge_ID) == false)then
		local function Async()
			local success, errormessage = pcall(function()
				BS:AwardBadge(Plr.UserId, Badge_ID)
			end)
			
			if(success)then
				return true
			end
			return false
		end
		
		for i = 1, 3 do
			local D = Async()
			if(D)then
				return
			end
		end
	end
end

local function Is_Player_In_Group(Plr)
	local function Async()
		local Data = nil
		local success, errormessage = pcall(function()
			Data = Plr:IsInGroup(Group_ID)
		end)

		if(success and Data ~= nil)then
			return Data
		end
		return nil
	end

	for i = 1, 3 do
		local D = Async()
		if(D ~= nil)then
			return D
		end
	end
	return false
end


Bindable_RF:WaitForChild("Player_In_Group").OnInvoke = function(Plr)
	local In_Group = Is_Player_In_Group(Plr)
	Plr:SetAttribute("In_Group", In_Group)
	return In_Group
end

Receiving_RF:WaitForChild("Player_In_Group").OnServerInvoke = function(Plr)
	local In_Group = Is_Player_In_Group(Plr)
	Plr:SetAttribute("In_Group", In_Group)
	return In_Group
end

Bindable_RF:WaitForChild("Player_Owns_Badge").OnInvoke = function(Plr, Badge_ID)
	return Player_Owns_Badge(Plr, Badge_ID)
end

Receiving_RF:WaitForChild("Player_Owns_Badge").OnServerInvoke = function(Plr, Badge_ID)
	return Player_Owns_Badge(Plr, Badge_ID)
end


Bindable_Events_F:WaitForChild("Award_Badge").Event:Connect(function(Plr, Badge_ID)
	Award_Badge_Handle(Plr, Badge_ID)
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1E116E013DDC4069B5E94BFA86423AD0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Fight_Assignment_Handle.server.lua</string>
						<string name="ScriptGuid">{0AA07F6F-98EB-462C-ACF4-CE7844E8436C}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	* Functionality of the System is to grab Players and get them into Fights
	
]]--

local RS = game:GetService("RunService")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Sending_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Receiving_RF = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("RF")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod")) 
local Fight_Cages_F = game.Workspace:WaitForChild("Fight_Cages_F")
local Invite_Fight_Buttons_UI_TMP = script:WaitForChild("Invite_Buttons_UI")

local Player_Image_Cache = {
	
}
local function Get_Player_Image(P_ID)
	if(Player_Image_Cache[P_ID] == nil)then
		local Type = Enum.ThumbnailType.HeadShot
		local Size = Enum.ThumbnailSize.Size420x420
		
		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				Data = game.Players:GetUserThumbnailAsync(P_ID, Type, Size)
			end)
			
			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end
		
		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				Player_Image_Cache[P_ID] = D
				return D
			end
		end
		
		return "rbxassetid://80237311442114"
	else
		return Player_Image_Cache[P_ID]
	end
end

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

local function Is_Player_Fighting(Char)
	local Is_Fighting = Char:GetAttribute("Is_Fighting")
	if(Is_Fighting ~= nil and Is_Fighting == true)then
		return true
	end
	
	return false
end

local function Get_Player_Val(Plr, Key)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		return PD:FindFirstChild(Key)
	end
	return nil
end

local function Fight_Spawn_Handle(M)
	local Data_F = M:WaitForChild("Fight_Data_F")
	local Active_Fight_V = Data_F:WaitForChild("Active_Fight")
	local Fight_Char_1_V = Data_F:WaitForChild("Fight_Char_1")
	local Fight_Char_2_V = Data_F:WaitForChild("Fight_Char_2")
	local Fight_M1 = M:WaitForChild("Fighter_1")
	local Fight_M2 = M:WaitForChild("Fighter_2")
	local Is_Ranked_Fight = M:GetAttribute("Ranked_Match")
	
	local Occupied_Spawns = {
		
	}
	
	local function Reset_Spawn_M(FM, Char_V)
		local Main_P = FM:FindFirstChild("Main_P")
		local B1, B2 = Main_P:FindFirstChild("B1"), Main_P:FindFirstChild("B2")
		local Display_UI = Main_P:FindFirstChild("Player_Display_UI")
		local Empty_Txt = Display_UI:FindFirstChild("Empty_Txt")
		local Player_F = Display_UI:FindFirstChild("Player_F")
		local Outline_P = FM:FindFirstChild("Outline_P")
		local Rot_P = FM:FindFirstChild("Rot_Part")
		local QueueGlow = FM:FindFirstChild("QueueGlow")
		local QueueNeon = FM:FindFirstChild("QueueNeon")
		
		Player_F.Visible = false
		Empty_Txt.Visible = true

		local Col_Seq = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Color3.fromRGB(248, 248, 248)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(248, 248, 248))
		}
		B1.Color = Col_Seq
		B2.Color = Col_Seq
		Rot_P.Color = Color3.fromRGB(248, 248, 248)
		Outline_P.Color = Color3.fromRGB(248, 248, 248)
		QueueGlow.Color = Color3.fromRGB(207, 172, 169)
		QueueNeon.Color = Color3.fromRGB(207, 172, 169)

		local Prev_Char = Char_V.Value
		if(Prev_Char ~= nil and game.Players:GetPlayerFromCharacter(Prev_Char) ~= nil)then
			--Remove the Player's Invite Buttons from Client
			local Prev_Plr = game.Players:GetPlayerFromCharacter(Prev_Char)
			local PG = Prev_Plr:FindFirstChild("PlayerGui")
			if(PG ~= nil and PG:FindFirstChild("Idle_Fight_Buttons") ~= nil)then
				local All_C = PG:FindFirstChild("Idle_Fight_Buttons"):GetChildren()
				for i = 1, #All_C do
					if(All_C[i] ~= nil and All_C[i]:IsA("LocalScript") == false)then
						All_C[i]:Destroy()
					end
				end
			end
		end

		Display_UI.PlayerToHideFrom = nil
		Char_V.Value = nil
	end
	
	local function Verify_Hit_Part(hit)
		if(hit ~= nil and hit.Parent ~= nil and game.Players:GetPlayerFromCharacter(hit.Parent) ~= nil 
			and Is_Player_Fighting(hit.Parent) == false)then			
			
			return game.Players:GetPlayerFromCharacter(hit.Parent), hit.Parent
		end
		
		return nil, nil
	end
	
	local function Send_Out_Fight_Notification(Plr, Char, Display_Data)
		local Total_Wins_V = Get_Player_Val(Plr, "Total Wins")
		
		local function Get_Player_Spawn_Data()
			if(Fight_Char_1_V.Value ~= Char)then
				return Fight_M1:FindFirstChild("Player_Spawn_P").CFrame
			else
				return Fight_M2:FindFirstChild("Player_Spawn_P").CFrame
			end
		end
		
		if(Is_Ranked_Fight ~= nil and Is_Ranked_Fight == true and Total_Wins_V ~= nil and 
			Total_Wins_V.Value < 10)then
			return
		end
		Sending_Events_F:WaitForChild("Fight_Spawn_Notification"):FireAllClients(Plr, Display_Data, Get_Player_Spawn_Data())
	end
	
	local function Process_Fighter_Touch(FM, Char_V)
		local Main_P = FM:WaitForChild("Main_P")
		local B1, B2 = Main_P:WaitForChild("B1"), Main_P:WaitForChild("B2")
		local Display_UI = Main_P:WaitForChild("Player_Display_UI")
		local Empty_Txt = Display_UI:WaitForChild("Empty_Txt")
		local Player_F = Display_UI:WaitForChild("Player_F")
		local Outline_P = FM:WaitForChild("Outline_P")
		local Rot_P = FM:WaitForChild("Rot_Part")
		local QueueGlow = FM:FindFirstChild("QueueGlow")
		local QueueNeon = FM:FindFirstChild("QueueNeon")
		local Touch_P = FM:WaitForChild("Touch_P")
		local Is_Ranked_Match = M:GetAttribute("Ranked_Match")
		local Debounce_H = false
		local Debounce_Elo_Dif = false
		
		local function New_Fighter_Added(Plr, Char)
			if(Plr ~= nil and Char ~= nil)then
				Empty_Txt.Visible = false
					
				local Select_Col = Color3.new(0, 1, 0)
				if(Is_Ranked_Match ~= nil and Is_Ranked_Match)then
					Select_Col = Color3.new(1, 0, 0)
				end

				local Col_Seq = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Select_Col),
					ColorSequenceKeypoint.new(1, Select_Col)
				}
				B1.Color = Col_Seq
				B2.Color = Col_Seq
				Rot_P.Color = Select_Col
				Outline_P.Color = Select_Col
				QueueGlow.Color = Select_Col
				QueueNeon.Color = Select_Col
				
				local function Update_Player_Data_F()
					local Rank_Data, Elo_Amount = Elo_Mod.Get_Player_Rank_Data(Plr)
					local Rank_F = Player_F:FindFirstChild("Rank_F")
					local Rank_Img = Rank_F:FindFirstChild("Rank_Img")
					local Rank_Txt = Rank_F:FindFirstChild("Rank_Txt")
					local Rank_Col = Rank_Data['Color'] or Color3.fromRGB(170, 170, 127)
					local Plr_Icon = Get_Player_Image(Plr.UserId)
					Rank_Img.Image = Rank_Data['Icon'] or "rbxassetid://89194867048049"
					Rank_Img.ImageColor3 = Rank_Col
					Rank_Txt.Text = Format_Number(Elo_Amount) .. ""
					Rank_Txt.TextColor3 = Rank_Col
					
					Player_F:FindFirstChild("Player_Name").Text = Plr.Name
					Player_F:FindFirstChild("Display_Name").Text = "@" .. Plr.DisplayName
					Player_F:FindFirstChild("Icon_F"):FindFirstChild("Player_Img").Image = Plr_Icon
					
					Display_UI.PlayerToHideFrom = Plr
					Player_F.Visible = true	
					
					return {
						['Name'] = Plr.Name, 
						['Rank Icon'] = Rank_Img.Image,
						['Rank Color'] = Rank_Col,
						['Rank Value'] = Rank_Txt.Text,
						['Player Icon'] = Plr_Icon,
						
						['Main_Char_V'] = Char_V,
						['Char_V1'] = Fight_Char_1_V,
						['Char_V2'] = Fight_Char_2_V,
						['Active_V'] = Active_Fight_V
					}
				end
				local Display_Data = Update_Player_Data_F()
				
				local function Add_Player_Invite_Buttons()
					local PG = Plr:FindFirstChild("PlayerGui")
					if(PG ~= nil and PG:FindFirstChild("Idle_Fight_Buttons") ~= nil)then
						local Idle_Fight_Buttons_F = PG:FindFirstChild("Idle_Fight_Buttons")
						local All_C = Idle_Fight_Buttons_F:GetChildren()
						for i = 1, #All_C do
							if(All_C[i] ~= nil and All_C[i]:IsA("LocalScript") == false)then
								All_C[i]:Destroy()
							end
						end
						
						local New_Invite_Buttons = Invite_Fight_Buttons_UI_TMP:Clone()
						New_Invite_Buttons.Adornee = Main_P
						New_Invite_Buttons.Parent = Idle_Fight_Buttons_F
						New_Invite_Buttons:WaitForChild("Fight_M").Value = M
						
						if M:GetAttribute("No_Bots") == true then
							New_Invite_Buttons.Buttons_F.Bot_Fight_B.Visible = false
						end
					end
				end
				Add_Player_Invite_Buttons()
				
				Char_V.Value = Char
				
				--If both Char Values are filled ~ Start the Fight
					--> Else, tell the whole server that the 2nd Fight Slot is vacant
					
				Occupied_Spawns[FM] = {
					['Model'] = FM,
					['Char_V'] = Char_V,
					['Main Char'] = Char,
					['Touch_P'] = Touch_P,
					['Active_V'] = Active_Fight_V
				}
				
				local function Process_Ranked_Match_Check(C1, C2)
					if(Is_Ranked_Fight ~= nil and Is_Ranked_Fight == true)then
						local P_C1 = game.Players:GetPlayerFromCharacter(C1)
						local P_C2 = game.Players:GetPlayerFromCharacter(C2)
						
						if(P_C1 ~= nil and P_C2 ~= nil)then
							local C1_Rank_Data, C1_Elo = Elo_Mod.Get_Player_Rank_Data(P_C1)
							local C2_Rank_Data, C2_Elo = Elo_Mod.Get_Player_Rank_Data(P_C2)
							
							--if(C1_Rank_Data['Key'] ~= C2_Rank_Data['Key'])then
							--	if(Debounce_Elo_Dif == false)then
							--		task.spawn(function()
							--			Debounce_Elo_Dif = true
							--			Sending_Events_F:WaitForChild("Elo_Rank_Dif"):FireClient(P_C1, P_C2)
							--			Sending_Events_F:WaitForChild("Elo_Rank_Dif"):FireClient(P_C2, P_C1)
							--			wait(3)
							--			Debounce_Elo_Dif = false
							--		end)
							--	end
								
							--	return false
							--end
							
							-- BUGFIX ranked arena now adjacents ranks match also
							
							local idx1 = C1_Rank_Data["Index"]
							local idx2 = C2_Rank_Data["Index"]

							--  same rank => accepted
							if idx1 == idx2 then
								return true
							end

							--  adjacents rank => accepted (ex: Gold vs Emerald)
							if math.abs(idx1 - idx2) == 1 then
								return true
							end

							--  too far ranks => refused + notification
							if(Debounce_Elo_Dif == false)then
								task.spawn(function()
									Debounce_Elo_Dif = true
									Sending_Events_F:WaitForChild("Elo_Rank_Dif"):FireClient(P_C1, P_C2)
									Sending_Events_F:WaitForChild("Elo_Rank_Dif"):FireClient(P_C2, P_C1)
									wait(3)
									Debounce_Elo_Dif = false
								end)
							end
							return false
						end
					end
					
					return true
				end

				if(Fight_Char_1_V.Value ~= nil and Fight_Char_2_V.Value ~= nil and 
					Fight_Char_1_V.Value ~= Fight_Char_2_V.Value and Active_Fight_V.Value == false)then

					if(Process_Ranked_Match_Check(Fight_Char_1_V.Value, Fight_Char_2_V.Value))then
						M:SetAttribute("Bot_Fight", false)
						Bindable_Events_F:WaitForChild("Start_Core_Fight"):Fire(M, Fight_Char_1_V.Value, Fight_Char_2_V.Value)
					end

				elseif(Active_Fight_V.Value == false)then
					Send_Out_Fight_Notification(Plr, Char, Display_Data)
				end
			else
				Reset_Spawn_M(FM, Char_V)
			end
		end
		
		Touch_P.Touched:Connect(function(hit)
			if hit.Name ~= "HumanoidRootPart" then
				return
			end
			
			if(Active_Fight_V.Value == false and Debounce_H == false and Char_V.Value == nil and 
				hit ~= nil and hit.Parent ~= nil)then
				Debounce_H = true
				
				local Plr, Char = Verify_Hit_Part(hit)
				if(Plr ~= nil and Char ~= nil and Fight_Char_1_V.Value ~= Char 
					and Fight_Char_2_V.Value ~= Char)then
					
					New_Fighter_Added(Plr, Char)
					wait(0.25)
				end
				Debounce_H = false
			end
		end)
	end
	Process_Fighter_Touch(Fight_M1, Fight_Char_1_V)
	Process_Fighter_Touch(Fight_M2, Fight_Char_2_V)
	
	
	local function Check_Removal()	
		local function Delete_Old_Fight_Teleports()
			local All_P = game.Players:GetPlayers()
			local function Delete_From_Player_UI(Fight_Buttons_F)
				local UIs = Fight_Buttons_F:GetChildren()
				for i = 1, #UIs do
					if(UIs[i] ~= nil and UIs[i]:IsA("BillboardGui") and UIs[i]:FindFirstChild("Fight_M") ~= nil)then
						local FM = UIs[i]:FindFirstChild("Fight_M")
						if(FM.Value == M)then
							UIs[i]:Destroy()
						end
					end
				end
			end
			
			for i = 1, #All_P do
				local P = All_P[i]
				if(P ~= nil and P:FindFirstChild("PlayerGui") ~= nil)then
					local PG = P:FindFirstChild("PlayerGui")
					local Fight_Buttons_F = PG:FindFirstChild("Idle_Fight_Buttons")
					if(Fight_Buttons_F ~= nil)then
						Delete_From_Player_UI(Fight_Buttons_F)
					end
				end
			end
		end
		
		Active_Fight_V.Changed:Connect(function()
			if(Active_Fight_V.Value == false)then
				Delete_Old_Fight_Teleports()	
			end
		end)
		
		local function Should_Reset_Occupied_Slot()
			local function Check_Char_In_Region(Char, Touch_P)
				local Overlap_P = OverlapParams.new()
				Overlap_P.FilterType = Enum.RaycastFilterType.Include
				Overlap_P.FilterDescendantsInstances = {Char}
				Overlap_P.MaxParts = 50

				local Region_Data = game.Workspace:GetPartsInPart(Touch_P, Overlap_P)
				if(Region_Data ~= nil and #Region_Data > 0)then
					return true
				end

				return false
			end

			for FM, Data in next, Occupied_Spawns do
				local Active_V = Data['Active_V']
				if(Active_V ~= nil and Active_V.Value == false)then
					--Check the Distance or if the HRP is nil
					local Char_V = Data['Char_V']
					local Touch_P = Data['Touch_P']
					local Main_Char = Data['Main Char']

					if(Char_V ~= nil and Touch_P ~= nil and (Main_Char ~= nil and 
						Check_Char_In_Region(Main_Char, Touch_P) == false) or Main_Char == nil)then

						--Reset, not in Region
						Reset_Spawn_M(FM, Char_V)

						--Remove from Occupied
						Occupied_Spawns[FM] = nil
					end
				end
			end
		end

		while wait(0.1) do
			--Handle Resetting Slots of the Player jumps offs
			Should_Reset_Occupied_Slot()
		end
	end
	task.spawn(Check_Removal)
end

Receiving_RF:WaitForChild("Create_Training_Bot").OnServerInvoke = function(Plr)
	--[[
		-- Get Player, their Character, and the Fight Match
		-- Is Ranked Match == false and not Started and vacant Fight Char Value
			-- Create new Training Bot
			-- Pass everything via Bindable
	]]--
	
	if(Plr ~= nil and Plr.Character ~= nil)then
		local Char = Plr.Character
		
		local function Get_Fight_Data_M()
			local All_M = Fight_Cages_F:GetChildren()
			for i = 1, #All_M do
				local M = All_M[i]
				if(M ~= nil and M:FindFirstChild("Fight_Data_F") ~= nil)then
					local Fight_Data_F = M:FindFirstChild("Fight_Data_F")
					local Is_Active = Fight_Data_F:FindFirstChild("Active_Fight")
					local Char_1_V = Fight_Data_F:FindFirstChild("Fight_Char_1")
					local Char_2_V = Fight_Data_F:FindFirstChild("Fight_Char_2")
					
					if(Is_Active ~= nil and Is_Active.Value == false and Char_1_V ~= nil and 
						Char_2_V ~= nil)then
						
						if(Char_1_V.Value == Char)then
							return M, Fight_Data_F, Char_2_V
			
						elseif(Char_2_V.Value == Char)then
							return M, Fight_Data_F, Char_1_V
						end
					end
				end
			end
			
			return nil, nil, nil
		end
		local Fight_M, Fight_Data_F, Vacant_Char_V = Get_Fight_Data_M()
		
		if(Fight_M ~= nil and Fight_Data_F ~= nil and Vacant_Char_V ~= nil)then
			local Is_Ranked_M = Fight_M:GetAttribute("Ranked_Match")
			if(Is_Ranked_M ~= nil and Is_Ranked_M == false)then
				local function Create_AI_Training_Bot()
					local botName = game:GetService("HttpService"):GenerateGUID(false):gsub("_", "")
					botName = botName:gsub("-", "")
					local Bot_M = game.ServerStorage:WaitForChild("Training_Bot"):Clone()
					local Bot_HRP = Bot_M:WaitForChild("HumanoidRootPart")
					Bot_M.Parent = game.Workspace._BOTS_FOLDER_
					Bot_M.Name = botName
					Bot_M.PrimaryPart = Bot_HRP
					Bot_HRP:SetNetworkOwnershipAuto(false)
					Bot_HRP:SetNetworkOwner(nil)
					
					Vacant_Char_V.Value = Bot_M
					
					task.spawn(function()
						local Init_E = Bot_M:WaitForChild("Init_AI_Training_Bot")
						wait(8.5)
						if(Init_E ~= nil and Plr ~= nil and Char ~= nil)then
							Init_E:Fire(Plr, Char)
						end	
					end)
					
					return Bot_M
				end
				local Training_Bot_Char = Create_AI_Training_Bot()
				
				local function Get_C1_C2_Characters()
					if(Vacant_Char_V.Name == "Fight_Char_2")then
						return Char, Training_Bot_Char
					end
					return Training_Bot_Char, Char
				end
				local C1_V, C2_V = Get_C1_C2_Characters()
				
				Fight_M:SetAttribute("Bot_Fight", true)
				Bindable_Events_F:WaitForChild("Start_Core_Fight"):Fire(Fight_M, C1_V, C2_V)
				return true, ""
			else
				return false, " You can't Fight a Training Bot in a Ranked Match!"
			end
		else
			return false, " Make sure you're on a Fight Spawn!"
		end
	end
	
	return false, " Failed to obtain your Character!"
end

function Init_Fight_Spawn_Handles()
	wait(1)	
	local All_M = Fight_Cages_F:GetChildren()
	for i = 1, #All_M do
		if(All_M[i] ~= nil)then
			Fight_Spawn_Handle(All_M[i])
		end
	end
end
Init_Fight_Spawn_Handles()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX0A9066DAD50C41D48E73D48BECEE1955">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Fight_Assignment_Handle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXF44FF8E9AE6344278E51DF20AAC04FA9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Core_Fight_Handle.server.lua</string>
							<string name="ScriptGuid">{125E5568-838F-4F3D-BB95-E7CFD833C93F}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	* Move Players into Fight ~ Set up Values
	* Set up Fighters (Display Wins, set up Presentation if Arena Fight)
	* Update Player Fight Handles
	* Set up Character Removal Handles
	- Set up Timer Handle
	* Set Up Detection & Algo for Hitting until you get to the Ground Game
	* Handle Moving Players to the ground Game
	* Handle Victory Handle
]]--

local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Event_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Sending_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Overhead_Display_E = Sending_Events_F:WaitForChild("Overhead_Display")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local Sound_Effect_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Monetization_Mod = require(Data_Mods_F:WaitForChild("Monetization_Mod"))

local function Disconnect_Cons(Cons)
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Verify_Fight_Can_Start(Fight_M, Fight_Char_1, Fight_Char_2)
	--[[
		* Round Not being Used for a Fight
		* Char 1 is not nil
		* Char 2 is not nil
	]]--
	
	local function Is_Fight_Active()
		local Fight_Data_F = Fight_M:FindFirstChild("Fight_Data_F")
		if(Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild("Active_Fight") ~= nil)then
			local Active_V = Fight_Data_F:FindFirstChild("Active_Fight")
			return Active_V.Value
		end
		
		return false
	end
	
	local function Verify_Character(Char)
		if(Char ~= nil and Char:FindFirstChildWhichIsA("Humanoid") ~= nil and 
			Char:FindFirstChild("HumanoidRootPart") ~= nil)then
			
			return true
		end
		return false
	end
	
	if(Is_Fight_Active() == false and Verify_Character(Fight_Char_1) and Verify_Character(Fight_Char_2))then
		return true
	end
	return false
end

local function Get_Player_Fight_Data_Vals(Char)
	local Fight_Data_F = Char:FindFirstChild("Fight_Data")
	if(Fight_Data_F == nil and game.Players:GetPlayerFromCharacter(Char) ~= nil)then
		local Plr = game.Players:GetPlayerFromCharacter(Char)
		Fight_Data_F = Plr:FindFirstChild("Fight_Data")
	end
	
	return Fight_Data_F:FindFirstChild("Health"), Fight_Data_F:FindFirstChild("Staminia")
end

local function Core_Fight_Logic_Handle(Fight_M, Fight_Char_1, Fight_Char_2)
	local Cons = {}
	local Fight_Data_F = Fight_M:WaitForChild("Fight_Data_F")
	local Inside_Checker_M = Fight_M:WaitForChild("Inside_Checker_M")
	local Active_V = Fight_Data_F:WaitForChild("Active_Fight")
	local Char_1_V = Fight_Data_F:WaitForChild("Fight_Char_1")
	local Char_2_V = Fight_Data_F:WaitForChild("Fight_Char_2")
	local Round_Count_V = Fight_Data_F:WaitForChild("Round_Count")
	local Round_Wins_V = Fight_Data_F:WaitForChild("Round_Wins")
	local Takedown_Track = Fight_Data_F:WaitForChild("Takedown_Track")
	local Takedown_E = Fight_Data_F:WaitForChild("Takedown_E")
	local Submission_Char = Fight_Data_F:WaitForChild("Submission_Hold_Character")
	local C1_Clicked_E = Submission_Char:WaitForChild("C1_Clicked_E")
	local C2_Clicked_E = Submission_Char:WaitForChild("C2_Clicked_E")
	local C1_Health_V, C1_Stam_V = Get_Player_Fight_Data_Vals(Fight_Char_1)
	local C2_Health_V, C2_Stam_V = Get_Player_Fight_Data_Vals(Fight_Char_2)
	local C1_HRP = Fight_Char_1:FindFirstChild("HumanoidRootPart")
	local C2_HRP = Fight_Char_2:FindFirstChild("HumanoidRootPart")
	local C1_HUM = Fight_Char_1:FindFirstChild("Humanoid")
	local C2_HUM = Fight_Char_2:FindFirstChild("Humanoid")
	local C1_Name = Fight_Char_1.Name
	local C2_Name = Fight_Char_2.Name
	local Cage_Parts_M = Fight_M:WaitForChild("Cage_Walls_M")
	local Is_Ranked_Match = Fight_M:GetAttribute("Ranked_Match") or false
	local Is_Bot_Fight = Fight_M:GetAttribute("Bot_Fight") or false
	local Init_C1_Data = Stats_Manager_Mod.Create_Fight_Data_Structure(Fight_Char_1)
	local Init_C2_Data = Stats_Manager_Mod.Create_Fight_Data_Structure(Fight_Char_2)
	local C1_Rank_Data, C1_Elo = Elo_Mod.Get_Player_Rank_Data(game.Players:GetPlayerFromCharacter(Fight_Char_1))
	local C2_Rank_Data, C2_Elo = Elo_Mod.Get_Player_Rank_Data(game.Players:GetPlayerFromCharacter(Fight_Char_2))
	local Win_Data = {}
	local Start_Time = os.clock()
	
	local function Set_Fight_Data()
		Active_V.Value = true
		Char_1_V.Value = Fight_Char_1
		Char_2_V.Value = Fight_Char_2
		Round_Count_V.Value = 1
		Round_Wins_V.Value = ""
		
		local Old_Mid_Point = Submission_Char:FindFirstChild("Midpoint")
		if(Old_Mid_Point ~= nil)then
			Old_Mid_Point:Destroy()
		end
	end
	Set_Fight_Data()
	
	local function Move_Players_Into_Fight(Init_Fight, initialTP)
		local function Client_Set_Up_Event(Char)
			local C_Plr = game.Players:GetPlayerFromCharacter(Char)
			if(C_Plr ~= nil)then
				local Target_HRP, Target_Char, Is_C1 = C1_HRP, Fight_Char_1, true
				if(Char == Char_1_V.Value)then
					Target_HRP, Target_Char, Is_C1 = C2_HRP, Fight_Char_2, false
				end

				if(Init_Fight)then
					local isBot = game.Players:GetPlayerFromCharacter(Target_HRP.Parent) == nil
					if isBot == true then
						Sending_Events_F:WaitForChild("Fight_Set_Up"):FireClient(C_Plr, true, Target_Char.Name, Is_Ranked_Match)
					else
						Sending_Events_F:WaitForChild("Fight_Set_Up"):FireClient(C_Plr, false, Target_Char, Target_HRP, Is_Ranked_Match)
					end
					
					wait(1.1)

					if(Is_Ranked_Match and Target_HRP ~= nil)then
						local Ranked_Spawns_F = Fight_M:FindFirstChild("Ranked_Spawns_F")
						if(Ranked_Spawns_F ~= nil)then
							if(Is_C1 and Ranked_Spawns_F:FindFirstChild("C1_Ranked_Spawn_P") ~= nil)then
								local Spawn_P = Ranked_Spawns_F:FindFirstChild("C1_Ranked_Spawn_P")
								Target_HRP.CFrame = Spawn_P.CFrame
								
							elseif(Is_C1 == false and Ranked_Spawns_F:FindFirstChild("C2_Ranked_Spawn_P") ~= nil)then
								local Spawn_P = Ranked_Spawns_F:FindFirstChild("C2_Ranked_Spawn_P")
								Target_HRP.CFrame = Spawn_P.CFrame
				
							end
						end
					end
				end
			end
		end
		task.spawn(Client_Set_Up_Event, Fight_Char_1)
		task.spawn(Client_Set_Up_Event, Fight_Char_2)
		
		if(Init_Fight and Is_Ranked_Match)then
			wait(18)
		else
			if initialTP == true then
				wait(1)
			end
		end
		
		if(C1_HRP ~= nil)then
			local sp = Fight_Data_F:WaitForChild("Spawn_1")
			C1_HRP.CFrame = sp.CFrame * CFrame.new(0, -sp.Size.Y / 2 + C1_HRP.Size.Y / 2 + C1_HUM.HipHeight, 0)
			
			if(C1_Health_V ~= nil)then
				C1_Health_V.Value = 100
			end
			
			if(C1_Stam_V ~= nil)then
				C1_Stam_V.Value = 100
			end
			
			local Reset_BE = Fight_Char_1:FindFirstChild("Reset_Fight_Health_Data")
			if(Reset_BE ~= nil)then
				Reset_BE:Fire()
			end
		end
		
		if(C2_HRP ~= nil)then
			local sp = Fight_Data_F:WaitForChild("Spawn_2")
			C2_HRP.CFrame = sp.CFrame * CFrame.new(0, -sp.Size.Y / 2 + C2_HRP.Size.Y / 2 + C2_HUM.HipHeight, 0)
			
			if(C2_Health_V ~= nil)then
				C2_Health_V.Value = 100
			end

			if(C2_Stam_V ~= nil)then
				C2_Stam_V.Value = 100
			end
			
			local Reset_BE = Fight_Char_2:FindFirstChild("Reset_Fight_Health_Data")
			if(Reset_BE ~= nil)then
				Reset_BE:Fire()
			end
		end
	end
	Move_Players_Into_Fight(true, true)
	
	local function Clear_Takedown_Tracking()
		Takedown_Track.Value = false
		for Key, Val in next, Takedown_Track:GetAttributes() do
			Takedown_Track:SetAttribute(Key, nil)
		end
	end
	
	local function Nullify_Takedown_Tracking()
		for Key, Val in next, Takedown_Track:GetAttributes() do
			Takedown_Track:SetAttribute(Key, 0)
		end
		Start_Time = os.clock()
	end
	
	local function Victory_Handle(Winning_Char, End_Fight)
		table.insert(Win_Data, Winning_Char.Name)
		Round_Wins_V.Value = table.concat(Win_Data, ",")
		Takedown_Track.Value = false
		
		local function Get_Winning_Result()
			local Needed_Wins = 2
			if(Is_Ranked_Match ~= nil and Is_Ranked_Match == true)then
				Needed_Wins = 3
			end
			
			local C1_Wins, C2_Wins = 0, 0
			for i = 1, #Win_Data do
				if(Win_Data[i] == C1_Name)then
					C1_Wins += 1
				else
					C2_Wins += 1
				end
			end
			
			if(Fight_Char_1 == nil)then
				return Fight_Char_2
			elseif(Fight_Char_2 == nil)then
				return Fight_Char_1
				
			elseif(End_Fight)then				
				if(C1_Wins >= C2_Wins)then
					return Fight_Char_1
				else
					return Fight_Char_2
				end
				
			elseif(C1_Wins >= Needed_Wins or C2_Wins >= Needed_Wins)then
				if(C1_Wins >= Needed_Wins)then
					return Fight_Char_1
				else
					return Fight_Char_2
				end
			end
			
			return nil
		end
		local Winning_Result = Get_Winning_Result()
		
		--This was disabled for some reason, function shows Knockout Display when enabled
		task.spawn(function()
			local Winning_Plr = game.Players:GetPlayerFromCharacter(Winning_Char)
			if(Winning_Plr ~= nil)then
				warn(`{Winning_Char} won the round`)
				local Was_Knockout = (Submission_Char.Value == nil)
				Sending_Events_F:WaitForChild("Round_Result_Win"):FireClient(Winning_Plr, Was_Knockout)
				
				--Give 10 Cash to the Winning Player
				--local Cash_Multi = Monetization_Mod.Get_Cash_Multi(Winning_Plr)
				--local Cash_Reward = math.ceil(10 * Cash_Multi)
				--Stats_Manager_Mod.Add_To_Player_Stats_Data(Winning_Plr, "Coins", Cash_Reward)
			end
		end)
		
		if(Winning_Result ~= nil)then
			local function Get_Target_Char(Char)
				if(Char == Fight_Char_1)then
					return Fight_Char_2
				end
				return Fight_Char_1
			end
			
			local function Move_Players_Out_Of_Ring(Plr, Char)
				local End_Spawn_P = Fight_Data_F:WaitForChild("End_Spawn")
				local HRP = Char:FindFirstChild("HumanoidRootPart")
				
				
				wait(3.5)

				-- BUGFIX of being stuck after an opponent who leaves during a submission
				local Chr = Plr.Character
				if Chr ~= nil then
					local humanoidRootPart = Chr:FindFirstChild("HumanoidRootPart")
					if humanoidRootPart ~= nil and Chr.PrimaryPart ~= nil then
						Chr:PivotTo(End_Spawn_P.CFrame)
						humanoidRootPart.Anchored = true

						task.spawn(function()
							task.wait(1)
							humanoidRootPart.Anchored = false

							--  Now reset client UI + controls after reposition
							if Plr ~= nil then
								Sending_Events_F:WaitForChild("End_Fight"):FireClient(Plr, Get_Target_Char(Char))
							end
						end)
					end
				end
				
				--wait(3.5)
				
				--if(Plr ~= nil)then
				--	Sending_Events_F:WaitForChild("End_Fight"):FireClient(Plr, Get_Target_Char(Char))
				--end
				
				--local Chr = Plr.Character
				--if Chr ~= nil then
				--	local humanoidRootPart = Chr:FindFirstChild("HumanoidRootPart")
				--	if humanoidRootPart ~= nil and Chr.PrimaryPart ~= nil then
				--		Chr:PivotTo(End_Spawn_P.CFrame)
				--		humanoidRootPart.Anchored = true
						
				--		task.spawn(function()
				--			task.wait(1)
				--			humanoidRootPart.Anchored = false
				--		end)
				--	end
				--end
				
				--if(HRP ~= nil)then
				--	HRP.CFrame = End_Spawn_P.CFrame
				--	HRP.Anchored = true
				--	wait(1)
					
				--	if(HRP ~= nil) then
				--		HRP.Anchored = false
				--	end
				--end
			end
			
			local function Award_Stats(Char)
				--> Award Wins, Type of Win, Total Matches, Elo
				local Plr = Char['_PLAYER_VALUE_'].Value
				local Did_Win = (Char == Winning_Char)
				local Elo_Reward = 0
				local Cash_Reward = 5
				
				local function Get_Elo_Reward_Amount()
					if(Is_Ranked_Match)then
						local function Has_More_Elo()
							if(Fight_Char_1 ~= nil and Char == Fight_Char_1 and C1_Elo >= C2_Elo)then
								return true
							elseif(Fight_Char_2 ~= nil and Char == Fight_Char_2 and C1_Elo <= C2_Elo)then
								return true
							end

							return false
						end
						local Has_More = Has_More_Elo()

						if(Did_Win)then
							if(Has_More)then
								return 25
							else
								return 50
							end
						else
							if(Has_More)then
								return -10
							else
								return -5
							end
						end	
					end

					return 0
				end
				local Elo_Reward = Get_Elo_Reward_Amount()
				local Elo_Multi = Monetization_Mod.Get_Elo_Multi(Plr)
				local Elo_R = math.ceil(Elo_Multi * Elo_Reward)

				if(Is_Ranked_Match)then
					Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Ranked Matches", 1)
					Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Elo", Elo_R)
				else
					if Is_Bot_Fight ~= true then
						Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Matches", 1)
					end
				end

				if(Did_Win)then
					if(Is_Ranked_Match)then
						Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Ranked Wins", 1)
					else
						if Is_Bot_Fight ~= true then
							Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Wins", 1)
						end
					end

					if Is_Bot_Fight ~= true then
						if(Submission_Char.Value ~= nil)then
							Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Submissions Wins", 1)
						else
							local Did_Punch_Last = Plr:GetAttribute("Did_Punch_Last")
							if(Did_Punch_Last ~= nil and Did_Punch_Last == false)then
								Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Leg Knockout Wins", 1)
							else
								Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Punch Knockout Wins", 1)
							end
						end
						Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Win Streak", 1)
					end

					Cash_Reward = 20
				else
					if Is_Bot_Fight ~= true then
						Stats_Manager_Mod.Set_Player_Stats_Data(Plr, "Win Streak", 0)
					end
				end
				
				local Cash_Multi = Monetization_Mod.Get_Cash_Multi(Plr)
				local Reward = math.ceil(Cash_Reward * Cash_Multi)
				Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Coins", Reward)
				
				-- Arizona Desert
				task.spawn(Move_Players_Out_Of_Ring, Plr, Char)
			end
			
			Disconnect_Cons(Cons)
			if(Fight_Char_1 ~= nil and Fight_Char_1:GetAttribute("UserId") ~= nil)then
				Award_Stats(Fight_Char_1)
			end
			
			if(Fight_Char_2 ~= nil and Fight_Char_2:GetAttribute("UserId") ~= nil)then
				Award_Stats(Fight_Char_2)
			end
			
			local function Send_Fight_Data_To_Players()
				--Get Final Data if the Character Exist
				local Did_C1_Win = (Winning_Char == Fight_Char_1)
				local Final_C1 = Stats_Manager_Mod.Create_Fight_Data_Structure(Fight_Char_1)
				local Final_C2 = Stats_Manager_Mod.Create_Fight_Data_Structure(Fight_Char_2)
				local Final_Fight_Data = Stats_Manager_Mod.Create_Fight_Result_Data(Init_C1_Data, Init_C2_Data, Final_C1, Final_C2, Win_Data, Did_C1_Win)
				
				if(Fight_Char_1 ~= nil and game.Players:GetPlayerFromCharacter(Fight_Char_1) ~= nil)then
					local C1_Plr = game.Players:GetPlayerFromCharacter(Fight_Char_1) 
					Sending_Events_F:WaitForChild("Fight_Data_Result"):FireClient(C1_Plr, Final_Fight_Data)
				end

				if(Fight_Char_2 ~= nil and game.Players:GetPlayerFromCharacter(Fight_Char_2) ~= nil)then
					local C2_Plr = game.Players:GetPlayerFromCharacter(Fight_Char_2) 
					Sending_Events_F:WaitForChild("Fight_Data_Result"):FireClient(C2_Plr, Final_Fight_Data)
				end
			end
			Send_Fight_Data_To_Players()
			
			local function Fight_Data_Reset()
				Char_1_V.Value = nil
				Char_2_V.Value = nil
				Round_Count_V.Value = 1
				Round_Wins_V.Value = ""
				Submission_Char.Value = nil
				task.spawn(Clear_Takedown_Tracking)
				
				if(C1_Health_V ~= nil)then
					task.defer(function()
						wait(3.5)
						C1_Health_V.Value = 100
					end)
				end
				
				if(C2_Health_V ~= nil)then
					task.defer(function()
						wait(3.5)
						C2_Health_V.Value = 100
					end)
				end
				
				if(C1_Stam_V ~= nil)then
					C1_Stam_V.Value = 100
				end

				if(C2_Stam_V ~= nil)then
					C2_Stam_V.Value = 100
				end
				
				
				if(Is_Bot_Fight)then
					task.spawn(function()
						task.wait(3.5)
						if(Fight_Char_1 ~= nil and game.Players:GetPlayerFromCharacter(Fight_Char_1) == nil)then
							if Fight_Char_1 then
								Fight_Char_1:Destroy()
							end
						end
						if(Fight_Char_2 ~= nil and game.Players:GetPlayerFromCharacter(Fight_Char_2) == nil)then
							if Fight_Char_2 then
								Fight_Char_2:Destroy()
							end
						end
					end)
				end
				
				Active_V.Value = false
			end
			Fight_Data_Reset()
		else
			--No Winner, Next Round

			wait(3.5)

			local Plr1 = game.Players:GetPlayerFromCharacter(Fight_Char_1)
			if Plr1 then
				local Fight_Data_F = Plr1:FindFirstChild("Fight_Data")
				local Block_Power_V = Fight_Data_F:FindFirstChild("Block Power")

				Block_Power_V.Value = 30
			end

			local Plr2 = game.Players:GetPlayerFromCharacter(Fight_Char_2)
			if Plr2 then
				local Fight_Data_F = Plr2:FindFirstChild("Fight_Data")
				local Block_Power_V = Fight_Data_F:FindFirstChild("Block Power")

				Block_Power_V.Value = 30
			end
			
			if(Active_V.Value == true)then
				Round_Count_V.Value += 1
				Submission_Char.Value = nil
				Nullify_Takedown_Tracking()

				Move_Players_Into_Fight(false)
			end
		end

	end
	
	local function Victory_Detection_Tracking()
		--When a Character Leaves, determine Victory
		local Died_From_Health_Debounce = false
		
		if(C1_Health_V ~= nil)then
			table.insert(Cons, C1_Health_V.Changed:Connect(function()
				if(C1_Health_V.Value <= 0 and Died_From_Health_Debounce == false)then
					Died_From_Health_Debounce = true
					Victory_Handle(Fight_Char_2, false)

					wait(3)
					Died_From_Health_Debounce = false
				end
			end))
			table.insert(Cons, C1_HUM.Changed:Connect(function()
				if(C1_HUM.Health <= 0 and Died_From_Health_Debounce == false)then
					Died_From_Health_Debounce = true
					Victory_Handle(Fight_Char_2, true)

					wait(3)
					Died_From_Health_Debounce = false
				end
			end))
		end
		
		if(C2_Health_V ~= nil)then
			table.insert(Cons, C2_Health_V.Changed:Connect(function()
				if(C2_Health_V.Value <= 0 and Died_From_Health_Debounce == false)then
					Died_From_Health_Debounce = true
					Victory_Handle(Fight_Char_1, false)

					wait(3)
					Died_From_Health_Debounce = false
				end
			end))
			table.insert(Cons, C2_HUM.Changed:Connect(function()
				if(C2_HUM.Health <= 0 and Died_From_Health_Debounce == false)then
					Died_From_Health_Debounce = true
					Victory_Handle(Fight_Char_1, true)

					wait(3)
					Died_From_Health_Debounce = false
				end
			end))
		end
		
		if(Fight_Char_1 ~= nil)then
			table.insert(Cons, Fight_Char_1.AncestryChanged:Connect(function()
				if(Fight_Char_1 == nil or Fight_Char_1.Parent == nil or 
					Fight_Char_1:IsDescendantOf(game.Workspace) == false)then

					Victory_Handle(Fight_Char_2, true)
				end
			end))
		end	
		
		if(Fight_Char_2 ~= nil)then
			table.insert(Cons, Fight_Char_2.AncestryChanged:Connect(function()
				if(Fight_Char_2 == nil or Fight_Char_2.Parent == nil or 
					Fight_Char_2:IsDescendantOf(game.Workspace) == false)then

					Victory_Handle(Fight_Char_1, true)
				end
			end))
		end	
		
		local plr1 = game.Players:GetPlayerFromCharacter(Fight_Char_1)
		if plr1 ~= nil then
			table.insert(Cons, game.Players.PlayerRemoving:Connect(function(plr)
				if plr == plr1 then
					Victory_Handle(Fight_Char_2, true)
				end
			end))
		end
		
		local plr2 = game.Players:GetPlayerFromCharacter(Fight_Char_2)
		if plr2 ~= nil then
			table.insert(Cons, game.Players.PlayerRemoving:Connect(function(plr)
				if plr == plr2 then
					Victory_Handle(Fight_Char_1, true)
				end
			end))
		end
	end
	Victory_Detection_Tracking()
	
	local function Takedown_Handle()
		--[[
			* Algorithm to dynamically process when to take down an Opponent
				> Base it on Applied Damage, Player Staminia Consumption and Distance from the Player
				
				- Applied Damage: If the Balance is like 50-75% of the total applied between the both Players
					-> Set Minimum total to be high based on how Skilled the Players are
					-> If Player Stam is low, increase the amount
		]]--
		local Min_Val = 600 -- Change to 500
		Clear_Takedown_Tracking()
		
		local function Analyze_Tracking()
			local function Compute_Val(Key)
				local V = Takedown_Track:GetAttribute(Key) or 0
				--V -= Min_Val
				--if(V < 0)then
				--	V = 0
				--end
				
				return V
			end
			local C1_Val = Compute_Val(C1_Name)
			local C2_Val = Compute_Val(C2_Name)
			
			if (C1_Val >= Min_Val or C2_Val >= Min_Val)then
				Takedown_Track.Value = true
			else
				Takedown_Track.Value = false
			end
		end
		
		local function Player_Hit_Tracking(Key, Health_V, Stam_V)
			local function Normalize_Hits()
				local min = math.huge
				for i, v in pairs(Takedown_Track:GetAttributes()) do
					min = math.min(min, v)
				end
				if min == math.huge then
					min = 0
				end
				
				for i, v in pairs(Takedown_Track:GetAttributes()) do
					Takedown_Track:SetAttribute(i, math.clamp(v - min, 0, Min_Val))
				end
			end
			local function Update_Hit(Health_Dif)
				if Takedown_Track.Value == true then
					return
				end
				
				local Delta_Time = math.clamp((os.clock() - Start_Time) / 60 * 2, 0, 1)
				local Time_Multi = Delta_Time * 1
				local Stam_Multi = (100 - Stam_V.Value) / 100
				local Add_Health = Health_V.Value * (1 + Stam_Multi)
				local Prev_Val = Takedown_Track:GetAttribute(Key) or 0
				Takedown_Track:SetAttribute(Key, Prev_Val + Add_Health * (1 + Time_Multi))
				Normalize_Hits()
				
				
				if(Takedown_Track.Value == false and Submission_Char.Value == nil)then
					Analyze_Tracking()
				end
			end
			
			local Prev_Val = 100
			local Debounce_H = false
			
			table.insert(Cons, Health_V.Changed:Connect(function()
				if(Debounce_H == false)then
					Debounce_H = true
					
					local Current_Health = Health_V.Value
					local Health_Dif = Prev_Val - Current_Health
					Prev_Val = Current_Health

					if(Health_Dif > 0)then
						Update_Hit(Health_Dif)
					end
					wait(1)
					Debounce_H = false
				end
			end))
			
			Takedown_Track:SetAttribute(Key, 0)
		end
		Player_Hit_Tracking(C1_Name, C2_Health_V, C2_Stam_V)
		Player_Hit_Tracking(C2_Name, C1_Health_V, C1_Stam_V) 
		
		--If you miss a Takedown
			--> Update the Tracking Handle here
			
	end
	Takedown_Handle()
	
	local function Move_To_The_Ground_Handle()
		--Wait until the Event gets fired to send the Players to the Ground
			--> Set up Clicker Game and Listen to the Results
			--> If Submission Player wins the Clicker Game -> Win the Round
			--> Else, Jump back to Striking
			--> Add to Stats
			
			
		local Debounce_Takedown = false
		local function Can_Take_Down_Player(Plr)
			--> Has more Hits than the other Player
			local C1_Val = Takedown_Track:GetAttribute(C1_Name) or 0
			local C2_Val = Takedown_Track:GetAttribute(C2_Name) or 0
			local Dist = (C1_HRP.Position - C2_HRP.Position).Magnitude
			
			if((C1_Val > C2_Val and C1_Name == Plr.Name) or 
				(C1_Val < C2_Val and C2_Name == Plr.Name) and Dist <= 20)then
				
				return true
			end
			
			return false
		end	
		
		local function Toggle_Players_Damage_Bars(Char, Is_Enabled)
			local Fight_UI = Char:FindFirstChild("Fighting_UI")
			if(Fight_UI ~= nil)then
				Fight_UI.Enabled = Is_Enabled
			end
		end
		
		local function New_Animation_Handle(T_Char, R_Char, Submission_Plr)
			--[[
				* New Animation Handle to correctly position and Process Player Positions
				* Submission Player, get their Takedown Animation Key and Submission Data Key
				* Lock Players into Position based on CF Offset, Anchor the HUmanoidRootParts
				* Wait based on the Time Length from Takedown Animation Key
				* Update Player Positions based on the Submission Hold CFrame Data Offset
				
				- Outside of the Function, Reset their HUmanoid Root Parts Anchors after the Event
				- Remove the use of a Midpoint
				
				* Client Handle Updates
				* Play Takedown Animations
				* Remove the use of Midpoint when it comes to Camera Effects
				
			]]--
			
			local destructor = function()
				
			end
			
			local T_HRP = T_Char:FindFirstChild("HumanoidRootPart")
			local R_HRP = R_Char:FindFirstChild("HumanoidRootPart")
						
			local function Assert_Check()
				if(T_HRP ~= nil and R_HRP ~= nil and Submission_Plr.Character ~= nil)then
					return true
				end
				return false
			end
			
			if(Assert_Check())then
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Submission_Plr.Character)
				--R_HRP.Anchored = true
				--T_HRP.Anchored = true
				local R_CF_Origin = R_HRP.CFrame 
				T_HRP.CFrame = R_CF_Origin:ToWorldSpace(Takedown_Data['CF Offset'])
				
				local weld = Instance.new("Weld")
				weld.Part0 = R_HRP
				weld.Part1 = T_HRP
				weld.C0 = Takedown_Data['CF Offset']
				
				weld.Parent = R_HRP
				
				Toggle_Players_Damage_Bars(T_Char, false)
				Toggle_Players_Damage_Bars(R_Char, false)
				
				destructor = function()
					weld:Destroy()
				end
				
				task.spawn(function()
					task.wait(Takedown_Data['Time Length'] + 0.25)

					if(Assert_Check())then
						--R_HRP.Anchored = true
						--T_HRP.Anchored = true
						T_HRP.CFrame = R_CF_Origin:ToWorldSpace(Submission_Data['CF Offset'])
						weld.C0 = Submission_Data['CF Offset']
					end
				end)
			end
			return destructor
		end
		
		local function Set_Up_Animation_Handle(T_Char, R_Char, Submission_Plr)
			--Create Midpoint Part between the 2 Characters
			--Get the type of Takedown & Submission
			--Adjust the Player's HRP Accordingly
			--Weld them to the Main Part
			local T_HRP = T_Char:FindFirstChild("HumanoidRootPart")
			local T_HUM = T_Char:FindFirstChild("Humanoid")
			local R_HRP = R_Char:FindFirstChild("HumanoidRootPart")
			local R_HUM = R_Char:FindFirstChild("Humanoid")
			local Old_Mid_Point = Submission_Char:FindFirstChild("Midpoint")
			if(Old_Mid_Point ~= nil)then
				Old_Mid_Point:Destroy()
			end
			
			if(T_HRP ~= nil and R_HRP ~= nil and Submission_Plr.Character ~= nil)then
				local function Create_Midpoint()
					local Dir = (T_HRP.Position - R_HRP.Position).Unit * -1
					local Dist = (T_HRP.Position - R_HRP.Position).Magnitude
					local Mid_Pos = T_HRP.Position + Dir * (Dist / 2)
					
					local Mid_Point_P = Instance.new("Part", Submission_Char)
					Mid_Point_P.Name = "Midpoint"
					Mid_Point_P.Transparency = 1 -- Change to Transparent after testing
					Mid_Point_P.Anchored = true
					Mid_Point_P.CanCollide = false
					Mid_Point_P.Material = Enum.Material.Neon
					Mid_Point_P.Color = Color3.new(0, 1, 0)
					Mid_Point_P.Size = T_HRP.Size
					Mid_Point_P.CFrame = CFrame.new(Mid_Pos) * T_HRP.CFrame.Rotation
					
					local function Verify_Mid_Pos()
						local Dist_Min = 7
						local Dir_Arr = {
							Mid_Point_P.CFrame.LookVector * Dist_Min,
							Mid_Point_P.CFrame.LookVector * Dist_Min * -1,
							Mid_Point_P.CFrame.RightVector * Dist_Min,
							Mid_Point_P.CFrame.RightVector * Dist_Min * -1
						}
						local Ray_Parm = RaycastParams.new()
						Ray_Parm.FilterDescendantsInstances = {Cage_Parts_M}
						Ray_Parm.FilterType = Enum.RaycastFilterType.Include
						
						local function Check_Raycast(Ray_Dir)
							local Ray_Res = game.Workspace:Raycast(Mid_Point_P.CFrame.Position, Ray_Dir, Ray_Parm)
							if(Ray_Res ~= nil and Ray_Res.Instance ~= nil and Ray_Res.Position ~= nil)then
								local New_Pos = Ray_Res.Position + Ray_Dir * -1
								Mid_Point_P.CFrame = CFrame.new(New_Pos) * Mid_Point_P.CFrame.Rotation
								return true
							end	
							
							return false
						end
						
						for i = 1, #Dir_Arr do
							local Ray_Dir = Dir_Arr[i]
							local Ray_Res = Check_Raycast(Ray_Dir)
							if(Ray_Res)then
								return
							end
						end
					end
					Verify_Mid_Pos()

					return Mid_Point_P
				end
				local Midpoint_P = Create_Midpoint()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Submission_Plr.Character)

				T_HRP.CFrame = Midpoint_P.CFrame:ToWorldSpace(Takedown_Data['Takedown CF Offset'])
				R_HRP.CFrame = Midpoint_P.CFrame:ToWorldSpace(Takedown_Data['Receiving CF Offset'])
				
				local function Weld_To_Midpoint(HRP)
					local W = Instance.new("WeldConstraint", Midpoint_P)
					W.Part0 = HRP
					W.Part1 = Midpoint_P
					W.Enabled = true
				end
				Weld_To_Midpoint(T_HRP)
				Weld_To_Midpoint(R_HRP)
				
				Toggle_Players_Damage_Bars(T_Char, false)
				Toggle_Players_Damage_Bars(R_Char, false)
			end
		end
		
		local function Submission_Handle(Submission_Plr)
			local WAIT_INTERVAL = 0.2
			local gameCounter = 0
			local Choke_Cons = {}
			local games = {}
			type gameTable = {
				player1 : Player,
				player2 : Player,
				score : number,
				status : "Running" | "Ended",
				gameID : number
			}

			local function FetchThumbnail(player : Player)
				if(player == nil)then
					return "rbxassetid://80237311442114"
				end
				
				local userId = player.UserId
				local thumbType = Enum.ThumbnailType.HeadShot
				local thumbSize = Enum.ThumbnailSize.Size420x420
				local success, result  = pcall(function()
					return game.Players:GetUserThumbnailAsync(userId, thumbType, thumbSize)
				end)

				if success then
					return result
				else
					warn("Thumbnail fetching for ", player.Name , " has failed, resulting to default")
					return "rbxthumb://type=AvatarHeadShot&id=1233225830&w=420&h=420"
				end
			end

			local function StartChokehold(player1, player2)
				local player1 = game.Players:GetPlayerFromCharacter(Fight_Char_1)
				local player2 = game.Players:GetPlayerFromCharacter(Fight_Char_2)

				--Get thumbnails
				local thumbnail1 = FetchThumbnail(player1)
				local thumbnail2 = FetchThumbnail(player2)

				--Create game table
				local myGame : gameTable = {
					["player1"] = player1 or Fight_Char_1,
					["player2"] = player2 or Fight_Char_2,
					score = 50,
					status = "Running",
					gameID = gameCounter,
					
					destructor = nil
				}

	
				local function On_Click_Update(P_Char)
					if(P_Char ~= nil)then
						if P_Char == Fight_Char_1 then
							myGame.score -= 1
						end

						if P_Char == Fight_Char_2 then
							myGame.score += 1
						end
					end
				end
				
				local MIN_INTERVAL = 1/12

				local lastClick = os.clock()
				local C1_Con = C1_Clicked_E.OnServerEvent:Connect(function(player)
					if os.clock() - lastClick >= MIN_INTERVAL then
						On_Click_Update(player.Character)
						
						lastClick = os.clock()
					end
				end)

				local lastClick = os.clock()
				local C2_Con = C2_Clicked_E.OnServerEvent:Connect(function(player)
					if os.clock() - lastClick >= MIN_INTERVAL then
						On_Click_Update(player.Character)

						lastClick = os.clock()
					end
				end)
				
				table.insert(Cons, C1_Con)
				table.insert(Cons, C2_Con)
				table.insert(Choke_Cons, C1_Con)
				table.insert(Choke_Cons, C2_Con)

				-- Start client connections and UI
				local function Get_R_Char()
					if(Fight_Char_1 ~= nil and Submission_Char.Value == Fight_Char_1)then
						return Fight_Char_2
					else
						return Fight_Char_1
					end
				end
				local R_Char = Get_R_Char()
				--Set_Up_Animation_Handle(Submission_Plr.Character, Get_R_Char(), Submission_Plr)
				local weldDestructor = New_Animation_Handle(Submission_Plr.Character, R_Char, Submission_Plr)
				myGame.destructor = weldDestructor
				
				local Bot_C = nil
				local function AI_Clicking_Handle(Bot_Char)
					if(Submission_Plr.Character ~= nil)then
						Bindable_Event_F:WaitForChild("AI_Training_Submission"):Fire(Bot_Char, Submission_Plr.Character, true)
					end
					Bot_C = Bot_Char
					
					local Click_Time_Delay = 0.2 -- would take 10 Seconds to Complete
					while myGame.status == "Running" and Bot_Char ~= nil do
						On_Click_Update(Bot_Char)
						wait(Click_Time_Delay)
					end
				end
				
				local StartClicker = Sending_Events_F:WaitForChild("Start_Submission")
				if(player1 ~= nil)then
					StartClicker:FireClient(player1, "START", {imageIDs = {thumbnail1,thumbnail2}, flip = true, P1 = player1, P2 = player2}, C1_Clicked_E)
				elseif(Is_Bot_Fight == true and player1 == nil and Fight_Char_1 ~= nil)then
					--Set up Bot Clicking for Player 1
					task.spawn(AI_Clicking_Handle, Fight_Char_1)
				end
				
				if(player2 ~= nil)then
					StartClicker:FireClient(player2, "START", {imageIDs = {thumbnail1,thumbnail2}, flip = false, P1 = player1, P2 = player2}, C2_Clicked_E)
				elseif(Is_Bot_Fight == true and player2 == nil and Fight_Char_2 ~= nil)then
					--Set up Bot Clicking for Player 1
					task.spawn(AI_Clicking_Handle, Fight_Char_2)
				end
				

				task.defer(function()
					while myGame.status == "Running" do
						task.wait(WAIT_INTERVAL)

						if myGame.score >= 100 then
							if(player2 ~= nil and player2 == Submission_Plr)then
								C1_Health_V.Value = -10
								Stats_Manager_Mod.Add_To_Player_Stats_Data(Submission_Plr, "Submissions Finished", 1)
								myGame.status = "Ended"
								--print("Set C1 Health to -10")
							else
								
								if(C2_Stam_V ~= nil)then
									C2_Stam_V.Value = math.clamp(C2_Stam_V.Value * 0.65, 25, 100)
								end
								
								if(C1_Stam_V ~= nil)then
									C1_Stam_V.Value = math.clamp(C1_Stam_V.Value * 0.65, 25, 100)
								end

								if(C1_Health_V ~= nil)then
									C1_Health_V.Value = math.clamp(C1_Health_V.Value * 0.75, 25, 100)
								end
								
								Submission_Char.Value = nil
							end
							break
			
						elseif myGame.score <= 0 then
							if(player1 ~= nil and player1 == Submission_Plr)then
								C2_Health_V.Value = -10
								Stats_Manager_Mod.Add_To_Player_Stats_Data(Submission_Plr, "Submissions Finished", 1)
								myGame.status = "Ended"
								--print("Set C2 Health to -10")
							else
								if(C1_Stam_V ~= nil)then
									C1_Stam_V.Value = math.clamp(C1_Stam_V.Value * 0.65, 25, 100)
								end
								
								if(C2_Stam_V ~= nil)then
									C2_Stam_V.Value = math.clamp(C2_Stam_V.Value * 0.65, 25, 100)
								end
								
								if(C2_Health_V ~= nil)then
									C2_Health_V.Value = math.clamp(C2_Health_V.Value * 0.75, 25, 100)
								end
								
								Submission_Char.Value = nil
							end
							break
						end


						if(player1 ~= nil)then
							C1_Clicked_E:FireClient(player1, {gameProgress = myGame.score})
						end
						
						if(player2 ~= nil)then
							C2_Clicked_E:FireClient(player2, {gameProgress = myGame.score})
						end
					end
					
					weldDestructor()
					
					
					local Old_Mid_Point = Submission_Char:FindFirstChild("Midpoint")
					if(Old_Mid_Point ~= nil)then
						Old_Mid_Point:Destroy()
					end
					
					if(player1 ~= nil)then
						StartClicker:FireClient(player1, "STOP")
					end
					
					if(player2 ~= nil)then
						StartClicker:FireClient(player2, "STOP")
					end
					
					
					Disconnect_Cons(Choke_Cons)
					
					if(Fight_Char_1 ~= nil)then
						Toggle_Players_Damage_Bars(Fight_Char_1, true)
						
						if(C1_HRP ~= nil)then
							C1_HRP.Anchored = false
						end
					end
					
					if(Fight_Char_2 ~= nil)then
						Toggle_Players_Damage_Bars(Fight_Char_2, true)
						
						if(C2_HRP ~= nil)then
							C2_HRP.Anchored = false
						end
					end
					
					if(Is_Bot_Fight and Bot_C ~= nil)then
						Bindable_Event_F:WaitForChild("AI_Training_Submission"):Fire(Bot_C, nil, false)
					end
					
				end)

				games[gameCounter] = myGame
				gameCounter += 1

				return myGame
			end

			local function DetermineWinner(myGame : gameTable)
				if myGame < 50 then
					return myGame["player1"]
				elseif myGame > 50 then
					return myGame["player2"]
				else
					local randomPlayer = "player" .. tostring(math.random(1,2))
					return myGame[randomPlayer]
				end
			end

			local function FinishGame(myGame : gameTable)
				myGame.status = "Ended"
			end

			local function GetGame(id : number)
				local foundGame = games[id]

				--Alternative search method
				if foundGame == nil then
					for _, anyGame in games do
						if anyGame.gameID == id then
							foundGame = anyGame
						end
					end
				end

				return foundGame
			end
			
			if(Fight_Char_1 ~= nil and Fight_Char_2 ~= nil)then
				StartChokehold(Fight_Char_1, Fight_Char_2)	
			end
			
		end
		
		local function Set_Up_Takedown(Plr)
			Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Takedowns Landed", 1)
			Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Submissions Attempted", 1)
			Submission_Char.Value = Plr.Character
			Nullify_Takedown_Tracking()
			
			Submission_Handle(Plr)
		end
		
		local function Deduct_Stam(Plr)
			if(Fight_Char_1 ~= nil and C1_Name == Plr.Name and C1_Stam_V ~= nil)then
				local Val = C1_Stam_V.Value - 25
				C1_Stam_V.Value = math.clamp(Val, 25, 100)
			elseif(Fight_Char_2 ~= nil and C2_Name == Plr.Name and C2_Stam_V ~= nil)then
				local Val = C2_Stam_V.Value - 25
				C2_Stam_V.Value = math.clamp(Val, 25, 100)
			end
		end
		
		local function Missed_Takedown(Plr)
			local P_Char = Plr.Character
			if(P_Char ~= nil and P_Char:FindFirstChild("HumanoidRootPart") ~= nil)then
				local P_HRP = P_Char:FindFirstChild("HumanoidRootPart")
				local Hit_Force = 500 -- Was 350
				local Dir = P_HRP.CFrame.LookVector 
				P_HRP:ApplyImpulse(Dir * Hit_Force * P_HRP:GetMass())
				Overhead_Display_E:FireAllClients(P_Char, "Missed!", Color3.fromRGB(9, 137, 207))
			end
		end
		
		table.insert(Cons, Takedown_E.OnServerEvent:Connect(function(Plr)
			if(Debounce_Takedown == false and Active_V.Value == true and 
				Takedown_Track.Value == true and Submission_Char.Value == nil)then
				
				Debounce_Takedown = true
				Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Takedowns Attempted", 1)
				Deduct_Stam(Plr)
				
				if(Can_Take_Down_Player(Plr))then
					-- Can Takedown Player
					Set_Up_Takedown(Plr)
				else
					-- Missed the Takedown, Subtract Health and Play Animation
					Missed_Takedown(Plr)
				end
				
				wait(10)
				Debounce_Takedown = false
			end
		end))
	end
	Move_To_The_Ground_Handle()
	
	local function Out_Of_Bounds_Handle()
		local function Track_Character(Character)
			local time_outside = 0
			local max_time_outside = 3
			local runCon = game:GetService("RunService").Heartbeat:Connect(function(dt)
				local HRP = Character:FindFirstChild("HumanoidRootPart")

				local isOutside = true
				if HRP then
					local collider = Inside_Checker_M.Collider
					local pos = HRP.Position
					local localPos = collider.CFrame:pointToObjectSpace(pos)
					localPos = Vector2.new(
						localPos.X / (collider.Size.X / 2), 
						math.sqrt(localPos.Y ^ 2 + localPos.Z ^ 2) / (collider.Size.Y / 2)
					)

					if math.abs(localPos.X) <= 1 and math.abs(localPos.Y) <= 1 then
						isOutside = false
					end
				end

				if isOutside == true then
					time_outside += dt
				else
					time_outside -= dt
				end
				time_outside = math.clamp(time_outside, 0, max_time_outside)

				if time_outside >= max_time_outside then
					Character:PivotTo(Inside_Checker_M.Position.CFrame * CFrame.new(0, 3, 0))
				end
			end)

			table.insert(Cons, runCon)
		end

		Track_Character(Fight_Char_1)
		Track_Character(Fight_Char_2)
	end
	Out_Of_Bounds_Handle()
	
	local function Cage_Control_Handle()
		--[[
			* Detection Core
			- Both Characters are in the Cage
			- Not currently in a Submission
			- Submission Sequence not active
			- 1 Character is below 50 health and the other is above 50 Stam
			- Character Below 50 health is agaist the Cage
			
			* Set up Midpoint, Lock both Players into Place
			* Tell both Clients to Play Animations & Camera Sequences
			* Apply Damage and Stam Effects, Delete the Midpoint
		]]--
		
		local Prev_Round = 0
		local Max_Health_To_Trigger = 75 -- Adjust this Health Value to make it more frequent
		
		local function Against_The_Cage_Sequence(Attacking_Char, Bad_Char, Cage_Pos)
			local Attacking_Offset_CF = CFrame.new(Vector3.new(0.8270339965820312, 0, -4.329065322875977)) * CFrame.Angles(math.rad(180), 0, math.rad(180))
			Prev_Round = Round_Count_V.Value
			
			local function Lock_Players_Down()
				local function Move_Bad_Char()
					local Bad_Char_HRP = Bad_Char:FindFirstChild("HumanoidRootPart")
					if(Bad_Char_HRP ~= nil)then
						local Rot = Bad_Char_HRP.CFrame.Rotation
						Bad_Char_HRP.CFrame = CFrame.new(Cage_Pos) * Rot
						Bad_Char_HRP.Anchored = true
						
						return Bad_Char_HRP
					end
					return nil
				end
				local Bad_Char_HRP = Move_Bad_Char()
				
				if(Bad_Char_HRP ~= nil)then
					local function Move_Attacking_Char()
						local Attack_HRP = Attacking_Char:FindFirstChild("HumanoidRootPart")
						if(Attack_HRP ~= nil)then
							Attack_HRP.CFrame = Bad_Char_HRP.CFrame:ToWorldSpace(Attacking_Offset_CF)
							Attack_HRP.Anchored = true
						end
					end
					Move_Attacking_Char()
				end
				
				return Bad_Char_HRP
			end
			local Bar_Char_HRP = Lock_Players_Down()
			
			local function Start_Client_Effects()
				--Generate Animation Sequence & Camera CFrame based on Offset
				--Tell both Players
					-- Remember, AI Bot will use a Bindable Event instead of Remote
				--Loop everything and Play Sound Effects
				
				local function Get_Cam_Clinch_CF()
					local CF_Offset = CFrame.new(Vector3.new(-7.615234375, 5.331428527832031, -7.482333183288574)) * CFrame.Angles(math.rad(-140), math.rad(-40), math.rad(-155))
					if(Bar_Char_HRP ~= nil)then
						return Bar_Char_HRP.CFrame:ToWorldSpace(CF_Offset)
					end
					return CF_Offset
				end
				local Cam_Clinch_CF = Get_Cam_Clinch_CF()
				local Sequence_Keys = Animation_Mod.Generate_Clinch_Attack_Keys()
				
				local function Init_Attacking_Player()
					if(Attacking_Char ~= nil)then
						local Attack_Plr = game.Players:GetPlayerFromCharacter(Attacking_Char)
						if(Attack_Plr ~= nil)then
							Sending_Events_F:WaitForChild("Cage_Clinch_Start"):FireClient(Attack_Plr, Sequence_Keys, true, Cam_Clinch_CF)
						else
							Bindable_Event_F:WaitForChild("Cage_Clinch_Start"):Fire(Attacking_Char, Sequence_Keys, true)
						end
					end
				end
				task.spawn(Init_Attacking_Player)
				
				local function Init_Bad_Player()
					if(Bad_Char ~= nil)then
						local Bad_Plr = game.Players:GetPlayerFromCharacter(Bad_Char)
						if(Bad_Plr ~= nil)then
							Sending_Events_F:WaitForChild("Cage_Clinch_Start"):FireClient(Bad_Plr, Sequence_Keys, false, Cam_Clinch_CF)
						else
							Bindable_Event_F:WaitForChild("Cage_Clinch_Start"):Fire(Bad_Char, Sequence_Keys, false)
						end
					end
				end
				task.spawn(Init_Bad_Player)
				
				wait(2.3) -- 1.3 = Init Clinch Animation + 1 for Idle Delay
				
				for i = 1, 5 do
					--Iterate through all Animations
					--Play hit Sound
					if(Bar_Char_HRP ~= nil)then
						Sound_Effect_Mod.Play_Sound_Effect(Bar_Char_HRP, "Punch_Hit_SE")
					end
					
					wait(1) -- 1 = Strike Animation + 0.5 for Idle Delay
				end
			end
			Start_Client_Effects()
			
			local function End_Sequence_Handle()
				local function Attacking_Char_Handle()
					if(Attacking_Char ~= nil)then
						local A_HRP = Attacking_Char:FindFirstChild("HumanoidRootPart")
						if(A_HRP ~= nil)then
							A_HRP.Anchored = false
						end
						
						if(Fight_Char_1 ~= nil and Attacking_Char == Fight_Char_1 and C1_Stam_V ~= nil)then
							C1_Stam_V.Value = math.clamp(C1_Stam_V.Value - 25, 0, 100)
						elseif(Fight_Char_2 ~= nil and Attacking_Char == Fight_Char_2 and C2_Stam_V ~= nil)then
							C2_Stam_V.Value = math.clamp(C2_Stam_V.Value - 25, 0, 100)
						end
					end
				end
				Attacking_Char_Handle()
				
				local function Bad_Char_Handle()
					if(Bad_Char ~= nil)then
						local B_HRP = Bad_Char:FindFirstChild("HumanoidRootPart")
						if(B_HRP ~= nil)then
							B_HRP.Anchored = false
						end

						if(Fight_Char_1 ~= nil and Bad_Char == Fight_Char_1 and C1_Health_V ~= nil)then
							C1_Health_V.Value -= 25
						elseif(Fight_Char_2 ~= nil and Bad_Char == Fight_Char_2 and C2_Health_V ~= nil)then
							C2_Health_V.Value -= 25
						end
					end
				end
				Bad_Char_Handle()
			end
			End_Sequence_Handle()
			
			wait(5)
		end
		
		local function Detection_Result()
			if(Prev_Round < Round_Count_V.Value and Fight_Char_1 ~= nil and Fight_Char_2 ~= nil and 
				Submission_Char ~= nil and Submission_Char.Value == nil and 
				Takedown_Track ~= nil and Takedown_Track.Value == false)then
				
				local function Get_Attacking_Player()
					local function Is_Against_The_Cage(C_HRP)
						--Fire Raycast, Determine Position if any
						local Dir = C_HRP.CFrame.LookVector * -5
						local Ray_Parms = RaycastParams.new()
						Ray_Parms.FilterDescendantsInstances = {Cage_Parts_M}
						Ray_Parms.FilterType = Enum.RaycastFilterType.Include
						Ray_Parms.IgnoreWater = true
						
						local Ray_Res = game.Workspace:Raycast(C_HRP.Position, Dir, Ray_Parms)
						if(Ray_Res ~= nil and Ray_Res.Position ~= nil)then
							return true, Ray_Res.Position
						end
						return false, nil
					end
					
					if(C1_Health_V.Value <= Max_Health_To_Trigger and C1_HRP ~= nil and C2_Stam_V.Value >= 50 
						and C2_Health_V.Value > Max_Health_To_Trigger)then
						
						local Is_Back_To_Cage, Pos = Is_Against_The_Cage(C1_HRP)
						if(Is_Back_To_Cage == true and Pos ~= nil)then
							return Fight_Char_2, Fight_Char_1, Pos
						end
					end
					
					if(C2_Health_V.Value <= Max_Health_To_Trigger and C2_HRP ~= nil and C1_Stam_V.Value >= 50 
						and C1_Health_V.Value > Max_Health_To_Trigger)then
						
						local Is_Back_To_Cage, Pos = Is_Against_The_Cage(C2_HRP)
						if(Is_Back_To_Cage == true and Pos ~= nil)then
							return Fight_Char_1, Fight_Char_2, Pos
						end
					end
					
					return nil, nil, nil
				end
				local Attacking_Player, Bad_Player, Cage_Pos = Get_Attacking_Player()
				
				if(Attacking_Player ~= nil and Bad_Player ~= nil and Cage_Pos ~= nil)then
					-- Start Against the Cage Sequencing
					Against_The_Cage_Sequence(Attacking_Player, Bad_Player, Cage_Pos)
				end
			end
		end
		
		while Active_V ~= nil and Active_V.Value == true do
			Detection_Result()
			wait(1)
		end
	end
	Cage_Control_Handle()
end

Bindable_Event_F:WaitForChild("Start_Core_Fight").Event:Connect(function(Fight_M, Fight_Char_1, Fight_Char_2)
	if(Verify_Fight_Can_Start(Fight_M, Fight_Char_1, Fight_Char_2))then
		--Set up both Players to Fight Each Other
		
		local fightModels = {
			{Fight_M:FindFirstChild("Fighter_1"), Fight_Char_1},
			{Fight_M:FindFirstChild("Fighter_2"), Fight_Char_2},
		}
		
		for i, fmData in pairs(fightModels) do
			local FM = fmData[1]
			local char = fmData[2]
			
			local Main_P = FM:FindFirstChild("Main_P")
			local B1, B2 = Main_P:FindFirstChild("B1"), Main_P:FindFirstChild("B2")
			local Display_UI = Main_P:FindFirstChild("Player_Display_UI")
			local Empty_Txt = Display_UI:FindFirstChild("Empty_Txt")
			local Player_F = Display_UI:FindFirstChild("Player_F")
			local Outline_P = FM:FindFirstChild("Outline_P")
			local Rot_P = FM:FindFirstChild("Rot_Part")
			local QueueGlow = FM:FindFirstChild("QueueGlow")
			local QueueNeon = FM:FindFirstChild("QueueNeon")

			Player_F.Visible = false
			Empty_Txt.Visible = true

			local Col_Seq = ColorSequence.new{
				ColorSequenceKeypoint.new(0, Color3.fromRGB(248, 248, 248)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(248, 248, 248))
			}
			B1.Color = Col_Seq
			B2.Color = Col_Seq
			Rot_P.Color = Color3.fromRGB(248, 248, 248)
			Outline_P.Color = Color3.fromRGB(248, 248, 248)
			QueueGlow.Color = Color3.fromRGB(207, 172, 169)
			QueueNeon.Color = Color3.fromRGB(207, 172, 169)

			local Prev_Char = char
			if(Prev_Char ~= nil and game.Players:GetPlayerFromCharacter(Prev_Char) ~= nil)then
				--Remove the Player's Invite Buttons from Client
				local Prev_Plr = game.Players:GetPlayerFromCharacter(Prev_Char)
				local PG = Prev_Plr:FindFirstChild("PlayerGui")
				if(PG ~= nil and PG:FindFirstChild("Idle_Fight_Buttons") ~= nil)then
					local All_C = PG:FindFirstChild("Idle_Fight_Buttons"):GetChildren()
					for i = 1, #All_C do
						if(All_C[i] ~= nil and All_C[i]:IsA("LocalScript") == false)then
							All_C[i]:Destroy()
						end
					end
				end
			end
		end
		
		Core_Fight_Logic_Handle(Fight_M, Fight_Char_1, Fight_Char_2)
	end
end)]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXD56584726F4548528A1C5D8CB82BB227">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Core_Character_Handle.server.lua</string>
						<string name="ScriptGuid">{3A902E97-E56D-4154-9DCF-9B4FB54765A0}</string>
						<ProtectedString name="Source"><![CDATA[local PS = game:GetService("PhysicsService")
PS:RegisterCollisionGroup("A")
PS:RegisterCollisionGroup("B")
PS:RegisterCollisionGroup("Hitbox")
PS:CollisionGroupSetCollidable("A", "B", false)
PS:CollisionGroupSetCollidable("A", "A", false)
PS:CollisionGroupSetCollidable("B", "B", false)
PS:CollisionGroupSetCollidable("Hitbox", "A", false)
PS:CollisionGroupSetCollidable("Hitbox", "B", false)

local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Sending_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Receiving_Events_F = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("Events")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Elo_Mod = require(Data_Mods_F:WaitForChild("Elo_Mod"))
local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Country_Mod = require(Data_Mods_F:WaitForChild("Country_Mod"))
local Name_Tag_TMP = script:WaitForChild("Name_Tag_UI")
local Fight_UI_TMP = script:WaitForChild("Fighting_UI")

local function Get_Player_Val(Plr, Key)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Key) ~= nil)then
		return PD:FindFirstChild(Key)
	end

	return nil
end

local function Format_Number(n)
	n = tostring(n)
	return tostring(n:reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", ""))
end

local function Join_Check(t)
	local Joints = {"LeftWrist","RightWrist","LeftAnkle","RightAnkle", "Root"}
	if(table.find(Joints, t) ~= nil)then
		return false
	end
	return true
end

local function Ragdoll_Player(Char)
	local Hum = Char:FindFirstChild("Humanoid")

	local function Set_Up_Character_Ragdoll()
		for _,v in pairs(Char:GetDescendants()) do
			if v:IsA("Motor6D")and Join_Check(v.Name)then
				local b = Instance.new("BallSocketConstraint",v.Parent)
				local a0,a1 = Instance.new("Attachment"),Instance.new("Attachment")

				a0.Parent,a1.Parent = v.Part0,v.Part1
				b.Attachment0,b.Attachment1 = a0,a1
				a0.CFrame,a1.CFrame = v.c0,v.c1
				b.LimitsEnabled = true
				b.TwistLimitsEnabled = true
				b.Enabled = false

			elseif v:IsA'BasePart' or v:IsA("MeshPart") then
				if(v.Name ~= "Hitbox_Part")then
					PS:SetPartCollisionGroup(v, "A")
				else
					v.CanCollide = false
				end
			
				if v.Name == "HumanoidRootPart" then
					PS:SetPartCollisionGroup(v, "B")
				elseif v.Name=="Head"then
					v.CanCollide = true
				end

			end
		end
		PS:CollisionGroupSetCollidable("A", "B", false)
	end
	Set_Up_Character_Ragdoll()

	Hum:SetStateEnabled(Enum.HumanoidStateType.GettingUp, false)
	Hum:ChangeState(Enum.HumanoidStateType.Ragdoll)
	Hum.PlatformStand = true

	for _,v in pairs(Char:GetDescendants()) do
		if v:IsA'Motor6D'and Join_Check(v.Name)then
			v.Enabled = false
		elseif v:IsA'BallSocketConstraint' then
			v.Enabled = true
		end
	end
	
	wait(3.5)
	
	if(Char ~= nil)then
		for _,v in pairs(Char:GetDescendants()) do
			if(v:IsA'BasePart' or v:IsA("MeshPart"))then
				if v.Name == "Hitbox_Part"then
					v.CanCollide = true
				else
					PS:SetPartCollisionGroup(v, "Default")
				end
			end
			
			if v:IsA'Motor6D'and Join_Check(v.Name)then
				v.Enabled = true
			elseif v:IsA'BallSocketConstraint' then
				v.Enabled = false
				v:Destroy()
			end
		end
		
		Hum:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
		Hum:ChangeState(Enum.HumanoidStateType.GettingUp)
		Hum.PlatformStand = false
	end
end

local function Update_Shorts(Plr, Char)
	--Get the Default Key, get the Model, Clone it
	--Remove any Previous Models in Character
	--Loop through Each BodyPart, set up CFrame Offset and Weld to BodyPart
	local Shorts_Key, Shorts_TMP = Clothing_Mod.Get_Player_Current_Shorts(Plr)
	local Prev_Shorts = Char:FindFirstChild("Shorts_M")
	if(Prev_Shorts ~= nil)then
		Prev_Shorts:Destroy()
	end
	
	local New_Shorts = Shorts_TMP:Clone()
	New_Shorts.Parent = Char
	New_Shorts.Name = "Shorts_M"
	
	local function Configure_New_Shorts()
		local function Set_New_Part(P)
			local Main_BP = Char:FindFirstChild(P.Name)
			local Offset_CF = P:GetAttribute("Spawn_Offset_CF") or CFrame.new()
			--if(Offset_CF == nil)then
			--	P.CFrame = Main_BP.CFrame
			--else
			--	P.CFrame = Main_BP.CFrame:ToWorldSpace(Offset_CF)
			--end
			
			local W = Instance.new("Weld", P)
			W.Name = "WeldConstraint"
			W.Part0 = Main_BP
			W.Part1 = P
			W.C0 = Offset_CF
		end
		
		local All_P = New_Shorts:GetChildren()
		for i = 1, #All_P do
			local P = All_P[i]
			if(P ~= nil and Char:FindFirstChild(P.Name) ~= nil)then
				Set_New_Part(P)
			end
		end
	end
	Configure_New_Shorts()
end

local function Update_Gloves(Plr, Char)	
	local Gloves_Key, Gloves_TMP = Clothing_Mod.Get_Player_Current_Gloves(Plr)
	local Prev_Gloves = Char:FindFirstChild("Gloves_M")
	if(Prev_Gloves ~= nil)then
		Prev_Gloves:Destroy()
	end

	local New_Gloves = Gloves_TMP:Clone()
	New_Gloves.Parent = Char
	New_Gloves.Name = "Gloves_M"

	local function Configure_New_Gloves()
		local function Set_New_Part(P, isFlipped)			
			local Main_BP = Char:FindFirstChild(P.Name)
			local HRP = Char:FindFirstChild("HumanoidRootPart")
			local Offset_CF = P:GetAttribute("Spawn_Offset_CF")
			--P.Size = Vector3.new(0.753, 1.094, 0.787)
			P.CFrame = Main_BP.CFrame
			if isFlipped == true then
				P.CFrame *= CFrame.Angles(0, math.pi, 0)
			end
			local Dif_V = Vector3.new(0.753, 1.094, 0.787) / Vector3.new(0.772, 0.938, 0.838)
			
			local W = Instance.new("WeldConstraint", P)
			W.Part0 = P
			W.Part1 = Main_BP
			W.Enabled = true
		end

		local All_P = New_Gloves:GetChildren()
		for i = 1, #All_P do
			local P = All_P[i]
			if(P ~= nil and Char:FindFirstChild(P.Name) ~= nil)then
				Set_New_Part(P, Gloves_TMP:GetAttribute("FlipGloves"))
			end
		end
	end
	Configure_New_Gloves()
end

local function Update_Skin_Color(Plr, Char)
	--Get the Skin Color Val, Create Color3 Val
		--> Update BodyColors Value
		--> 
	
	local Skin_Color_V = Get_Player_Val(Plr, "Skin Tone")
	if(Skin_Color_V ~= nil) then
		local function Configure_Skin_Color()
			local Str = string.split(Skin_Color_V.Value, ",")
			if(Str ~= nil and #Str >= 3)then
				local R, G, B = tonumber(Str[1]), tonumber(Str[2]), tonumber(Str[3])
				R, G, B = math.clamp(R, 0, 255), math.clamp(G, 0, 255), math.clamp(B, 0, 255)
				return Color3.fromRGB(R, G, B)
			end
			
			return Color3.fromRGB(234, 184, 146)
		end
		local Skin_Col = Configure_Skin_Color()
		
		local function Configure_Body_Color()
			local BC = Char:FindFirstChildWhichIsA("BodyColors")
			if(BC ~= nil)then
				BC.HeadColor3 = Skin_Col
				BC.LeftArmColor3 = Skin_Col
				BC.RightArmColor3 = Skin_Col
				BC.LeftLegColor3 = Skin_Col
				BC.RightLegColor3 = Skin_Col
				BC.TorsoColor3 = Skin_Col
			end
		end
		Configure_Body_Color()
		
		local function Update_Surface_Appearance(BP)
			local All_D = BP:GetDescendants()
			for i = 1, #All_D do
				local D = All_D[i]
				if(D ~= nil and D:IsA("SurfaceAppearance"))then
					D.Color = Skin_Col
				end
			end
		end
		Update_Surface_Appearance(Char:WaitForChild("UpperTorso"))
		Update_Surface_Appearance(Char:WaitForChild("RightUpperLeg"):WaitForChild("Mainheight6.002"))
		Update_Surface_Appearance(Char:WaitForChild("RightUpperArm"))
		Update_Surface_Appearance(Char:WaitForChild("RightLowerLeg"):WaitForChild("Mainheight5.002"))
		Update_Surface_Appearance(Char:WaitForChild("RightLowerArm"))
		Update_Surface_Appearance(Char:WaitForChild("LowerTorso"):WaitForChild("r15 tt.003"))
		Update_Surface_Appearance(Char:WaitForChild("LeftUpperLeg"):WaitForChild("Mainheight6.001"))
		Update_Surface_Appearance(Char:WaitForChild("LeftUpperArm"))
		Update_Surface_Appearance(Char:WaitForChild("LeftLowerLeg"):WaitForChild("Mainheight5.001"))
		Update_Surface_Appearance(Char:WaitForChild("LeftLowerArm"))
		
		local function Update_Hand_Colors()
			local Hand_M = Char:FindFirstChildWhichIsA("Model")
			if(Hand_M ~= nil)then
				local All_P = Hand_M:GetChildren()
				for i = 1, #All_P do
					local P = All_P[i]
					if(P ~= nil and P:IsA("MeshPart") and string.match(P.Name, "Hand") ~= nil)then
						P.Color = Skin_Col
					end
				end
			end
		end
		Update_Hand_Colors()
		
		local function Set_Lat_Colors(Lat_P)
			if(Lat_P ~= nil)then
				Lat_P.Color = Skin_Col
			end
		end
		--Set_Lat_Colors(Char:WaitForChild("Lat_L"))
		--Set_Lat_Colors(Char:WaitForChild("Lat_R"))
	end
end

local function Get_Device_Image(Plr)
	local Device_Imgs = {
		['PC'] = "rbxassetid://115464285887151",
		['Console'] = "rbxassetid://120642019576021",
		['Mobile'] = "rbxassetid://98548614504710"
	}

	local Device_Atrib = Plr:GetAttribute("Device")
	if(Device_Atrib == nil or Device_Imgs[Device_Atrib] == nil)then
		Sending_Events_F:WaitForChild("Update_Player_Device"):FireClient(Plr)
	else
		return Device_Imgs[Device_Atrib]
	end

	return Device_Imgs['PC']
end

local function Get_Player_Name_Tag(Plr)
	local Char = Plr.Character
	if(Char ~= nil and Char:FindFirstChild("Name_Tag_UI") ~= nil)then
		return Char:FindFirstChild("Name_Tag_UI")
	end
	return nil
end

local function Update_Name_Tag_Data(Plr, Data_Type)
	--For Health and Stamina
	local Fight_Data_F = Plr:FindFirstChild("Fight_Data")
	local Name_Tag_UI = Get_Player_Name_Tag(Plr)
	if(Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild(Data_Type) ~= nil and Name_Tag_UI ~= nil and  
		Name_Tag_UI:FindFirstChild("Main_F") ~= nil)then
		
		local Data_V = Fight_Data_F:FindFirstChild(Data_Type)
		local Main_F = Name_Tag_UI:FindFirstChild("Main_F")
		local Bar_F = Main_F:FindFirstChild("Stam_Bar_F")
		if(Data_Type == "Health")then
			Bar_F = Main_F:FindFirstChild("Health_Bar_F")
		end
		
		if(Bar_F ~= nil and Bar_F:FindFirstChild("Val_Txt") ~= nil and Bar_F:FindFirstChild("Bar_F") ~= nil)then
			local X_Size = math.clamp(Data_V.Value / 100, 0, 1)
			Bar_F:FindFirstChild("Bar_F"):TweenSize(UDim2.new(X_Size, 0, 1, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
			
			Bar_F:FindFirstChild("Val_Txt").Text = Data_V.Value .. ""
		end
	end
end

local function Update_Name_Tag_Elo(Plr)
	--For the Rank Display
	local Name_Tag_UI = Get_Player_Name_Tag(Plr)
	if(Name_Tag_UI ~= nil and Name_Tag_UI:FindFirstChild("Main_F") ~= nil and 
		Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Rank_F") ~= nil)then
		
		local Rank_F = Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Rank_F")
		local Rank_Txt = Rank_F:FindFirstChild("Rank_Txt")
		local Rank_Img = Rank_F:FindFirstChild("Rank_Img")
		local Rank_Data, Elo_Amount = Elo_Mod.Get_Player_Rank_Data(Plr)
		
		if(Rank_F ~= nil and Rank_Img ~= nil and Rank_Txt ~= nil and Rank_Data ~= nil 
			and Elo_Amount ~= nil)then
			
			local Rank_Col = Rank_Data['Color'] or Color3.fromRGB(170, 170, 127)
			Rank_Txt.Text = Format_Number(Elo_Amount) .. ""
			Rank_Txt.TextColor3 = Rank_Col
			Rank_Img.Image = Rank_Data['Icon'] or "rbxassetid://89194867048049"
			Rank_Img.ImageColor3 = Rank_Col
		end
	end
end

local function Update_Name_Tag_Country(Plr)
	local Name_Tag_UI = Get_Player_Name_Tag(Plr)
	if(Name_Tag_UI ~= nil and Name_Tag_UI:FindFirstChild("Main_F") ~= nil and 
		Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Country_Img") ~= nil)then

		local Country_Img = Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Country_Img")
		local Country_Key, Country_Icon = Country_Mod.Get_Player_Country_Data(Plr)
		if(Country_Icon ~= nil)then
			Country_Img.Image = Country_Icon
		end
	end
end

local function Update_Name_Tag_Connection(Plr)
	--For the Player Connection Handle
	local Name_Tag_UI = Get_Player_Name_Tag(Plr)
	local Ping = Plr:GetNetworkPing() * 100
	--> less than 100 ms (Green)
	--> Less than 250 ms (Yellow)
	--> Greater than 250 ms (Red)
	
	if(Name_Tag_UI ~= nil and Name_Tag_UI:FindFirstChild("Main_F") ~= nil and 
		Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Connection_Img") ~= nil)then
		
		local Connection_Img = Name_Tag_UI:FindFirstChild("Main_F"):FindFirstChild("Connection_Img")
		local UIG = Connection_Img:FindFirstChildWhichIsA("UIGradient")
		
		if(UIG ~= nil)then
			if(Ping <= 100)then
				UIG.Color = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Color3.new(0, 1, 0)),
					ColorSequenceKeypoint.new(1, Color3.new(0, 1, 0))
				}
			elseif(Ping <= 250)then
				UIG.Color = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Color3.new(1, 1, 0)),
					ColorSequenceKeypoint.new(0.6875, Color3.new(1, 1, 0)),
					ColorSequenceKeypoint.new(0.6876, Color3.fromRGB(200, 200, 200)),
					ColorSequenceKeypoint.new(1, Color3.fromRGB(200, 200, 200))
				}
			else
				UIG.Color = ColorSequence.new{
					ColorSequenceKeypoint.new(0, Color3.new(1, 0, 0)),
					ColorSequenceKeypoint.new(0.3875, Color3.new(1, 0, 0)),
					ColorSequenceKeypoint.new(0.3876, Color3.fromRGB(200, 200, 200)),
					ColorSequenceKeypoint.new(1, Color3.fromRGB(200, 200, 200))
				}
			end
		end
	end
end

local function Update_Playtime_Tracking(Plr)
	local Session_Time_V = Get_Player_Val(Plr, "Total Playtime")
	if(Session_Time_V ~= nil)then
		Session_Time_V.Value += 1
	end
end

local function Update_Fight_Block_UI(Plr)
	local function Get_Player_Fight_UI()
		local Char = Plr.Character
		if(Char ~= nil and Char:FindFirstChild("Fighting_UI") ~= nil)then
			return Char:FindFirstChild("Fighting_UI")
		end
		return nil
	end
	local Fight_UI = Get_Player_Fight_UI()
	local Fight_Data_F = Plr:FindFirstChild("Fight_Data")
	
	if(Fight_UI ~= nil and Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild("Block Power") ~= nil 
		and Fight_UI:FindFirstChild("Main_F") ~= nil and 
		Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then
		
		local Block_Power_V = Fight_Data_F:FindFirstChild("Block Power")
		local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
		local Img = Sheild_F:FindFirstChild("Shield_Img")
		local Txt = Sheild_F:FindFirstChild("Shield_Txt")
		
		if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
			local UIG = Img:FindFirstChildWhichIsA("UIGradient")
			local Block_Power = Block_Power_V.Value
			local Dif =  math.clamp(Block_Power / 30, 0, 1)
			local Offset_Pos_Y = (1 - Dif) - 0.5
			
			UIG.Offset = Vector2.new(0, Offset_Pos_Y)
			Txt.Text = Block_Power .. ""
			if(Dif <= 0.25)then
				Txt.TextColor3 = Color3.new(1, 0, 0)
			else
				Txt.TextColor3 = Color3.new(1, 1, 1)
			end
		end
	end
end

local function Toggle_Fight_Block_UI(Plr, Is_Enabled)
	local function Get_Player_Fight_UI()
		local Char = Plr.Character
		if(Char ~= nil and Char:FindFirstChild("Fighting_UI") ~= nil)then
			return Char:FindFirstChild("Fighting_UI")
		end
		return nil
	end
	local Fight_UI = Get_Player_Fight_UI()
	
	if(Fight_UI ~= nil)then
		Fight_UI.Enabled = Is_Enabled
	end
end

local function Character_Handle(Plr: Player, Char)
	local Hum = Char:WaitForChild("Humanoid")
	local HRP = Char:WaitForChild("HumanoidRootPart")
	local Head = Char:WaitForChild("Head")
	
	Char:SetAttribute("UserId", Plr.UserId)

	local plrValue = Instance.new("ObjectValue")
	plrValue.Value = Plr
	plrValue.Name = "_PLAYER_VALUE_"
	plrValue.Parent = Char

	--Set up Skin Color Change Handle based on Data
	--Set up Player Accessories and Face from the Default Character
	--Add Player Gloves and Shorted based on the Current Values
	
	local function Add_Character_Face_Accessories()
		local function Create_Original_Character()
			local function Async()
				local Data = nil
				local success, errormessage = pcall(function()
					Data = game.Players:CreateHumanoidModelFromUserId(Plr.UserId)
				end)
				
				if(success and Data ~= nil)then
					return Data
				end
				return nil
			end
			
			for i = 1, 3 do
				local D = Async()
				if(D ~= nil)then
					D.Parent = script
					return D
				end
			end
			
			return nil
		end
		local Orig_Char = Create_Original_Character()
		
		if(Orig_Char ~= nil)then
			local All_C = Orig_Char:GetChildren()
			for i = 1, #All_C do
				local C = All_C[i]
				if(C ~= nil and C:IsA("Accessory"))then
					--Hum:AddAccessory(C)
					C.Parent = Char
				elseif(C ~= nil and C.Name == "Head" and C:FindFirstChildWhichIsA("Decal") ~= nil)then
					--C:FindFirstChildWhichIsA("Decal").Parent = Head
					
					--Create a Face Part for some reason
					local Old_Face_P = Head:FindFirstChild("Face_Part")
					if(Old_Face_P ~= nil)then
						Old_Face_P:Destroy()
					end
					local Face_P = Instance.new("Part", Head)
					Face_P.Name = "Face_Part"
					Face_P.Size = Head.Size
					Face_P.Anchored = false
					Face_P.CanCollide = false
					Face_P.CanTouch = false
					Face_P.Massless = true
					Face_P.Transparency = 1
					Face_P.Material = Enum.Material.SmoothPlastic
					Face_P.CFrame = Head.CFrame
					
					local W = Instance.new("WeldConstraint", Face_P)
					W.Part0 = Face_P
					W.Part1 = Head
					W.Enabled = true
					
					local New_Face = C:FindFirstChildWhichIsA("Decal"):Clone()
					New_Face.Parent = Face_P
					
				end
			end
			
			Orig_Char:Destroy()
		end
		
		Hum.BreakJointsOnDeath = false
		Hum.RequiresNeck = false
		Hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
		Hum.HealthDisplayType = Enum.HumanoidHealthDisplayType.AlwaysOff
	end
	Add_Character_Face_Accessories()
	
	Update_Skin_Color(Plr, Char)
	Update_Gloves(Plr, Char)
	Update_Shorts(Plr, Char)

	local function Disable_Health_Regen()
		local Health = Char:WaitForChild("Health")
		if(Health ~= nil and Health:IsA("Script"))then
			Health:Destroy()
		end
	end
	Disable_Health_Regen()

	local function Auto_Ragdoll_On_Death()
		if(Hum ~= nil)then
			Hum.Died:Connect(function()
				if(Char ~= nil)then
					Ragdoll_Player(Char)
				end
			end)
		end
	end
	Auto_Ragdoll_On_Death()
	
	local function Name_Tag_Handle()
		if(HRP ~= nil and Char:FindFirstChild("Name_Tag_UI") == nil)then
			--When we have a Name Tag, apply it here
			local Name_Tag_UI = Name_Tag_TMP:Clone()
			Name_Tag_UI.Name = "Name_Tag_UI"
			Name_Tag_UI.Parent = Char
			Name_Tag_UI.Adornee = HRP
			
			local Main_F = Name_Tag_UI:WaitForChild("Main_F")
			Main_F:WaitForChild("Player_Name_Txt").Text = Plr.DisplayName
			Name_Tag_UI.Enabled = true
			Main_F:WaitForChild("Device_Img").Image = Get_Device_Image(Plr)
			
			Update_Name_Tag_Data(Plr, "Health")
			Update_Name_Tag_Data(Plr, "Staminia")
			Update_Name_Tag_Elo(Plr)
			Update_Name_Tag_Connection(Plr)
			Update_Name_Tag_Country(Plr)
		end
		
		if(HRP ~= nil and Char:FindFirstChild("Fighting_UI") == nil)then
			local Fight_UI = Fight_UI_TMP:Clone()
			Fight_UI.Name = "Fighting_UI"
			Fight_UI.Parent = Char
			Fight_UI.Adornee = HRP
			Fight_UI.Enabled = true
			
			Update_Fight_Block_UI(Plr)
			Toggle_Fight_Block_UI(Plr, false)
		end	
	end
	Name_Tag_Handle()
	
	local function Create_Collision_Hitbox()
		--local CF, Size = Char:GetBoundingBox()
		--local HB = Instance.new("Part", Char)
		local HB = script:WaitForChild("Round_Hitbox_P"):Clone()
		HB.Parent = Char
		HB.Name = "Hitbox_Part"
		HB.Transparency = 1
		HB.CanTouch = false
		HB.CanCollide = true
		HB.Anchored = false
		HB.Massless = true
		--HB.Size = Size
		--HB.CFrame = CF
		HB.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, 0, 0)
		HB.CollisionGroup = "Hitbox"
		
		local W = Instance.new("WeldConstraint", HB)
		W.Part0 = HB
		W.Part1 = HRP
		W.Enabled = true		
	end
	Create_Collision_Hitbox()
end

local function Total_Knockout_Badge_Handle(Plr)
	local Badges_Data = {
		[10] = 3359889418756738,
		[50] = 3881066402115385,
		[100] = 2633101226400876,
		[1000] = 873841622513803,
		[10000] = 757308337186417
	}
	
	local function Compile_Total_Knockouts()
		local Total_KO = 0
		local Punch_KO_V = Get_Player_Val(Plr, "Punch Knockout Wins")
		local Kick_KO_V = Get_Player_Val(Plr, "Leg Knockout Wins")
		
		if(Punch_KO_V ~= nil)then
			Total_KO += Punch_KO_V.Value
		end
		
		if(Kick_KO_V ~= nil)then
			Total_KO += Kick_KO_V.Value
		end
		
		return Total_KO
	end
	local Total_Knockouts = Compile_Total_Knockouts()
	
	if(Badges_Data[Total_Knockouts] ~= nil)then
		Bindable_Events_F:WaitForChild("Award_Badge"):Fire(Plr, Badges_Data[Total_Knockouts])
		
		local Txt = " Congrats on over " .. Format_Number(Total_Knockouts) .. " Total Knockouts!"
		Sending_Events_F:WaitForChild("Display_Data"):FireClient(Plr, Txt, Color3.fromRGB(255, 170, 0))
	end
end

local function Player_Data_Changes_Handle(Plr)
	local PD = Plr:WaitForChild("Player_Data")
	local FD = Plr:WaitForChild("Fight_Data")
	
	PD:WaitForChild("Skin Tone").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Skin_Color(Plr, Plr.Character)
		end
	end)
	
	PD:WaitForChild("Current Shorts").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Shorts(Plr, Plr.Character)
		end
	end)
	
	PD:WaitForChild("Current Gloves").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Gloves(Plr, Plr.Character)
		end
	end)
	
	PD:WaitForChild("Elo").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Name_Tag_Elo(Plr)
		end
	end)
	Update_Name_Tag_Elo(Plr)
	
	PD:WaitForChild("Country").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Name_Tag_Country(Plr)
		end
	end)
	
	PD:WaitForChild("Punch Knockout Wins").Changed:Connect(function()
		if(Plr ~= nil)then
			Total_Knockout_Badge_Handle(Plr)
		end
	end)
	
	PD:WaitForChild("Leg Knockout Wins").Changed:Connect(function()
		if(Plr ~= nil)then
			Total_Knockout_Badge_Handle(Plr)
		end
	end)
	
	--Fight Data Changes
	local Health_V = FD:WaitForChild("Health")
	Health_V.Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			if(Health_V.Value <= 0)then
				Ragdoll_Player(Plr.Character)
			end
			
			Update_Name_Tag_Data(Plr, "Health")
		end
	end)
	
	FD:WaitForChild("Staminia").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Name_Tag_Data(Plr, "Staminia")
		end
	end)
	
	FD:WaitForChild("Block Power").Changed:Connect(function()
		if(Plr ~= nil and Plr.Character ~= nil)then
			Update_Fight_Block_UI(Plr)
		end
	end)
end

game.Players.PlayerAdded:Connect(function(Plr)
	local Init_Char = Plr.Character
	if(Init_Char ~= nil)then
		Character_Handle(Plr, Init_Char)
	end

	Plr.CharacterAdded:Connect(function(Char)
		Character_Handle(Plr, Char)
	end)

	Player_Data_Changes_Handle(Plr)
end)

Bindable_Events_F:WaitForChild("Ragdoll_Player").Event:Connect(function(Char)
	if(Char ~= nil and Char:FindFirstChild("Humanoid") ~= nil)then
		Ragdoll_Player(Char)
	end
end)

Receiving_Events_F:WaitForChild("Set_Player_Device").OnServerEvent:Connect(function(Plr, Device_Str)
	if(Plr ~= nil)then
		Plr:SetAttribute("Device", Device_Str)
		
		--Update their Name Tag
		local Name_Tag = Get_Player_Name_Tag(Plr)
		if(Name_Tag ~= nil)then
			Name_Tag:WaitForChild("Main_F"):WaitForChild("Device_Img").Image = Get_Device_Image(Plr)
		end
	end
end)

Receiving_Events_F:WaitForChild("Show_Shield_UI").OnServerEvent:Connect(function(Plr, Is_Enabled)
	if(Plr ~= nil and Plr.Character ~= nil)then
		Toggle_Fight_Block_UI(Plr, Is_Enabled)
	end
end)

function Update_Player_Connections()
	--Update this to run each
	while wait(1) do
		local All_P = game.Players:GetPlayers()
		for i = 1, #All_P do
			local P = All_P[i]
			if(P ~= nil and P.Character ~= nil)then
				Update_Playtime_Tracking(P)
				if(i % 10 == 0)then
					Update_Name_Tag_Connection(P)
				end
			end
		end
	end
end

Update_Player_Connections()

--[[
	* Name Tag Changed Events
		-> Elo Changes
		-> Health Value
		-> Stamina Value
		
		On Init
		-> Name
		-> Device
		
	* Server Update Function of Player Ping every 10 Seconds
]]]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1C0381C7BAFB4EF5A6897C9F37F24650">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Combination_Handle.server.lua</string>
						<string name="ScriptGuid">{DB8E2A39-270B-45DB-9F9F-67D25E91905D}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	* Combination System
	* Emote Event
]]--

local TextService = game:GetService("TextService")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Receiving_RF = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("RF")
local Receiving_Events = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("Events")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Skin_Mod = require(Data_Mods_F:WaitForChild("Skin_Tone_Mod"))
local Country_Mod = require(Data_Mods_F:WaitForChild("Country_Mod"))

local function Get_Player_Val(Plr, Val_Name)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil)then
		local Val = PD:FindFirstChild(Val_Name)
		if(Val ~= nil)then
			return Val
		end
	end	

	return nil
end

local function getFilterResult(text, fromUserId)
	local filterResult
	local success, errorMessage = pcall(function()
		filterResult = TextService:FilterStringAsync(text, fromUserId)
	end)

	if success then
		local success2, filteredText = pcall(function()
			return filterResult:GetNonChatStringForBroadcastAsync()
		end)

		if success2 then
			return filteredText
		else
			warn("Error filtering text")
			return false
		end
	else
		warn("Error generating TextFilterResult:", errorMessage)
		return false
	end
end

Receiving_RF:WaitForChild("Combo_Action_Request").OnServerInvoke = function(Plr, Combo, Strike, Action)
	if(Combo ~= nil and string.match(Combo, "Strike_Combo") ~= nil)then
		local check_if_own = Animation_Mod.Player_Owns_Strike_Key(Plr, Action)
		if (check_if_own == true) then -- free
			local PD = Plr:WaitForChild("Player_Data")
			local Combo_Value = PD:FindFirstChild("Strike Combo "..Combo:match("%d+"))
			local Combo_List = Combo_Value.Value:split(",")

			Combo_List[tonumber(Strike:match("%d+"))] = Action

			local a,b,c = Combo_List[1],Combo_List[2],Combo_List[3]

			Combo_Value.Value = a..","..b..","..c
			return true
		end
	elseif(Combo ~= nil and string.match(Combo, "Submission_Takedown_F") ~= nil)then
		if Strike == "Submission_F" then
			local check_if_owns = Animation_Mod.Player_Owns_Submission_Key(Plr, Action)
			if (check_if_owns == true) then
				local PD = Plr:WaitForChild("Player_Data")
				local Submission_Value = PD:FindFirstChild("Submission Key")
				Submission_Value.Value = Action

				return true
			end
		elseif Strike == "Takedown_F" then
			local check_if_owns = Animation_Mod.Player_Owns_Submission_Key(Plr, Action)
			if (check_if_owns == true) then
				local PD = Plr:WaitForChild("Player_Data")
				local Submission_Value = PD:FindFirstChild("Takedown Key")
				Submission_Value.Value = Action

				return true
			end
		end
	end

	return false
end

Receiving_RF:WaitForChild("Avatar_Clothing_Request").OnServerInvoke = function(Plr, Equipment_Type, Key) -- plr,(glove/shorts),key
	if (Equipment_Type ~= nil) then
		if (Equipment_Type == "Gloves") then
			--// check if own
			local check_if_own = Clothing_Mod.Player_Owns_Gloves_Key(Plr, Key)
			local CurrentGlov = Get_Player_Val(Plr, "Current Gloves")
			if (check_if_own == true and CurrentGlov and CurrentGlov.Value ~= Key) then
				CurrentGlov.Value = Key
				return true
			end

		elseif (Equipment_Type == "Shorts") then

			local check_if_own = Clothing_Mod.Player_Owns_Shorts_Key(Plr, Key)
			local Current_Shorts = Get_Player_Val(Plr, "Current Shorts")
			if (check_if_own == true and Current_Shorts and Current_Shorts.Value ~= Key) then
				Current_Shorts.Value = Key
				return true
			end

		end
	end

	return false
end

Receiving_RF:WaitForChild("Emote_Slot_Request").OnServerInvoke = function(Plr, Slot_Number, Key)
	--// Verify Players own the emote 
	--// If Player owns emote then replace the emote slot with the new emote.
	if (Slot_Number ~= nil and Key ~= nil) then
		local check_if_own = Animation_Mod.Player_Owns_Emote_Key(Plr, Key)
		if (check_if_own == true) then
			local PD = Plr:WaitForChild("Player_Data")
			local Emote_Slot = PD:FindFirstChild("Current Emotes")
			local EmotesSelected = Emote_Slot.Value:split(",")
			if (Emote_Slot ~= nil) then
				EmotesSelected[tonumber(Slot_Number:match("%d+"))] = Key
				Emote_Slot.Value = table.concat(EmotesSelected, ",")
				return true
			end
		end
	end

	return false
end

Receiving_Events:WaitForChild("Reset_Sequence").OnServerEvent:Connect(function(Plr, Combo, Default)
	local PD = Plr:WaitForChild("Player_Data")
	if(Combo ~= nil and string.match(Combo, "Strike_Combo") ~= nil)then
		local Combo_Value = PD:FindFirstChild("Strike Combo "..Combo:match("%d+"))
		Combo_Value.Value = Default[1]..","..Default[2]..","..Default[3]
	elseif (Combo ~= nil and string.match(Combo, "Submission_Takedown") ~= nil) then
		PD:FindFirstChild("Submission Key").Value = "A"
		PD:FindFirstChild("Takedown Key").Value = "A"
	end
end)

Receiving_Events:WaitForChild("Save_Appearance").OnServerEvent:Connect(function(Plr, bio, country, skin)
	if(Plr ~= nil)then
		local PD = Plr:WaitForChild("Player_Data")
		if (PD ~= nil) then
			if (getFilterResult(bio, Plr.UserId)) then
				PD:FindFirstChild("Bio").Value = getFilterResult(bio, Plr.UserId)
			end
			if Country_Mod.Get_Country_Data()[country] then
				PD:FindFirstChild("Country").Value = country
			end
			if (Skin_Mod.Get_Skin_Tone_Data()[skin]) then
				local color = Skin_Mod.Get_Skin_Tone_Data()[skin]
				local R,G,B 
				R = math.round(color.R * 255)
				G = math.round(color.G * 255)
				B = math.round(color.B * 255)
				PD:FindFirstChild("Skin Tone").Value = R .. "," .. G .. "," .. B
			end
		end
	end
end)

Receiving_Events:WaitForChild("Claim_Group_Reward").OnServerEvent:Connect(function(plr: Player)
	if plr:IsInGroup(35784641) == true then
		if Clothing_Mod.Player_Owns_Gloves_Key(plr, "K1") == false then
			Clothing_Mod.Give_Player_Gloves(plr, "K1")
		end
	end
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX474748E70F80410FA0AE88AAACB2B5BB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Codes_Handle.server.lua</string>
						<string name="ScriptGuid">{83110B78-3E06-4ED0-AA5E-53C8EEA7FA7D}</string>
						<ProtectedString name="Source"><![CDATA[local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Sending_F = Channels_F:WaitForChild("Server_Client_F")
local Receiving_F = Channels_F:WaitForChild("Client_Server_F")
local Receiving_RF = Receiving_F:WaitForChild("RF")
local Receiving_Events_F = Receiving_F:WaitForChild("Events")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Data_Mod_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Monetization_Mod = require(Data_Mod_F:WaitForChild("Monetization_Mod"))
local Rewards_Mod = require(Data_Mod_F:WaitForChild("Rewards_Mod"))
local Crate_Mod = require(Data_Mod_F:WaitForChild("Crate_Mod"))
local Skill_Tree_Mod = require(Data_Mod_F:WaitForChild("Skill_Tree_Mod"))
local Animation_Mod = require(Data_Mod_F:WaitForChild("Animation_Mod"))

local function Get_Player_Val(Plr, Val_Name)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil)then
		local Val = PD:FindFirstChild(Val_Name)
		if(Val ~= nil)then
			return Val
		end
	end	

	return nil
end

--Grant Cash, Cash Packs, Increase Cash Multiplier, Free Car (Or Cash Value of Car if already owned), Free Boosts

local function Boost_Cash(Plr, Amount)
	local Cash_Val = Get_Player_Val(Plr, "Coins")
	Cash_Val.Value += Amount
end

local function Boost_Gems(Plr, Amount)
	local Gems_Val = Get_Player_Val(Plr, "Gems")
	Gems_Val.Value += Amount
end

local function Boost_Cash_Via_Pack(Plr, Cash_Key)
	local Cash_Val = Get_Player_Val(Plr, "Coins")
	local Cash_Boost_Data = Monetization_Mod.Get_Cash_Boost_Amount(Plr)
	local Amount = Cash_Boost_Data[Cash_Key] or 1000
	
	Cash_Val.Value += Amount
end

local function Boost_Gems_Via_Pack(Plr, Gems_Key)
	local Gems_Val = Get_Player_Val(Plr, "Gems")
	local Amount = Monetization_Mod.Get_Gems_Pack_Amount(Gems_Key)

	Gems_Val.Value += Amount
end

local function Grant_Free_Gamepass(Plr, GP_Key)
	local GP_ID = Monetization_Mod.Get_ID_From_Key(true, GP_Key)
	if(GP_ID ~= -1)then
		Bindable_Events_F:WaitForChild("Grant_Gamepass_Perks"):Fire(Plr, GP_ID)
	end	
end

local function Award_Free_Crate(Plr, Crate_Key)
	--[[
		* get Crate Data from Key
		* Award Player the Coins in order to buy the Crate real quick
		* Fire the Shop UI to Play the Effects of the Crate Opening up
	]]--
	
	local Crate_Data = Crate_Mod.GetCrates()[Crate_Key]
	if(Crate_Data ~= nil)then
		local Price_In_Coins = Crate_Data['PriceCoins'] or 0
		Boost_Cash(Plr, Price_In_Coins)
		Sending_F:WaitForChild("Events"):WaitForChild("Grant_Free_Crate"):FireClient(Plr, Crate_Data)
	end
end

local function Award_Ranked_Move(Plr, Select_Key)
	--[[
		* Get Moves the Player doesn't own that cost money
		* Get one Randomly, add to Player Data
	]]--
	
	local Owned_Submissions_V = Get_Player_Val(Plr, "Owned Special Submissions")
	if(Plr ~= nil and Owned_Submissions_V ~= nil)then
		local Owned_Keys = string.split(Owned_Submissions_V.Value, ",")
		if(Select_Key == nil or table.find(Owned_Keys, Select_Key) ~= nil)then
			local Keys_To_Give = Animation_Mod.Get_Unlockable_Submission_Keys(Plr)
			if(Keys_To_Give ~= nil and #Keys_To_Give > 0)then
				Select_Key = Keys_To_Give[math.random(1, #Keys_To_Give)]
			end
		end
		
		if(Select_Key ~= nil)then
			table.insert(Owned_Keys, Select_Key)
			Owned_Submissions_V.Value = table.concat(Owned_Keys, ",")

			local Submission_Data = Animation_Mod.Get_Special_Submission_Data(Select_Key)
			if(Submission_Data ~= nil and Submission_Data['Name'] ~= nil)then
				return Submission_Data['Name'] .. "!"
			end
		end
	end
	
	return ""
end

local function Award_Ranked_Strike(Plr, Select_Key)
	--Same as Ranked Move
	local Owned_Strikes_V = Get_Player_Val(Plr, "Owned Special Strikes")
	if(Plr ~= nil and Owned_Strikes_V ~= nil)then
		local Owned_Keys = string.split(Owned_Strikes_V.Value, ",")
		if(Select_Key == nil or table.find(Owned_Keys, Select_Key) ~= nil)then
			local Keys_To_Give = Animation_Mod.Get_Unlockable_Strike_Keys(Plr)
			if(Keys_To_Give ~= nil and #Keys_To_Give > 0)then
				Select_Key = Keys_To_Give[math.random(1, #Keys_To_Give)]
			end
		end

		if(Select_Key ~= nil)then
			table.insert(Owned_Keys, Select_Key)
			Owned_Strikes_V.Value = table.concat(Owned_Keys, ",")

			local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Select_Key)
			if(Strike_Data ~= nil and Strike_Data['Name'] ~= nil)then
				return Strike_Data['Name'] .. "!"
			end
		end
	end

	return ""
end

local function Award_Emotes(Plr, Select_Key)
	local Owned_Emotes_V = Get_Player_Val(Plr, "Owned Emotes")
	if(Plr ~= nil and Owned_Emotes_V ~= nil)then
		local Owned_Keys = string.split(Owned_Emotes_V.Value, ",")
		if(Select_Key == nil or table.find(Owned_Keys, Select_Key) ~= nil)then
			local Keys_To_Give = Animation_Mod.Get_Unlockable_Emotes(Plr)
			if(Keys_To_Give ~= nil and #Keys_To_Give > 0)then
				Select_Key = Keys_To_Give[math.random(1, #Keys_To_Give)]
			end
		end

		if(Select_Key ~= nil)then
			table.insert(Owned_Keys, Select_Key)
			Owned_Emotes_V.Value = table.concat(Owned_Keys, ",")

			local Emote_Data = Animation_Mod.Get_Emote_Data_From_Key(Select_Key)
			if(Emote_Data ~= nil and Emote_Data['Name'] ~= nil)then
				return Emote_Data['Name'] .. "!"
			end
		end
	end

	return ""
end

local function Give_Free_Boost(Plr, Boost_Data)
	--BOOST_DATA = {['Key'] = Boost_Key, ['Amount'] = 1}
	
	local Owned_Products_V = Get_Player_Val(Plr, "Owned Products")
	local Boost_Key = Boost_Data['Key'] or "D"
	local Amount = Boost_Data['Amount'] or 1
	local Owned_Products = string.split(Owned_Products_V.Value, ",")
	
	for i = 1, Amount do
		table.insert(Owned_Products, Boost_Key)
	end
	
	Owned_Products_V.Value = table.concat(Owned_Products, ",")
	
	Sending_F:WaitForChild("Events"):WaitForChild("Open_Shop"):FireClient(Plr, "Boosts")
end

local Codes_Data = {
	['A'] = {
		['Code'] = "CHAMPS",
		['Reward'] = Boost_Gems,
		['Amount'] = 100,
		['Text'] = " Successfully Redeemed Code & Earned +100 Gems!"
	},
	['B'] = {
		['Code'] = "2MILLIONS",
		['Reward'] = Boost_Gems,
		['Amount'] = 165,
		['Text'] = " Successfully Redeemed Code & Earned +165 Gems!"
	},
	['C'] = {
		['Code'] = "UFCPARIS2025",
		['Reward'] = Boost_Gems,
		['Amount'] = 150,
		['Text'] = " Successfully Redeemed Code & Earned +150 Gems!"
	},
	
}

local function Get_Code_Key(Code)
	for Key, Data in next, Codes_Data do
		if(Data['Code'] == Code)then
			return Key
		end
	end
	return nil
end

Receiving_RF:WaitForChild("Redeem_Code").OnServerInvoke = function(Plr, Code)
	--Verify Valid Code, Check if Player has used this Code
	--> If not, Redeem this Reward!
	
	local ok = function(msg)
		return msg
	end
	local notOk = function(msg, recurse)
		local UniqueCodeFunc = game.ServerScriptService.Core_Handles_F.Unique_Codes_Handle.Function
		
		if recurse == true then
			local result = UniqueCodeFunc:Invoke(Plr, Code)
			return result
		else
			return msg
		end
	end
	
	
	local Code_Key = Get_Code_Key(string.upper(Code))
	if(Code_Key ~= nil)then
		local Plr_Codes_Val = Get_Player_Val(Plr, "Codes")
		local Used_Codes = string.split(Plr_Codes_Val.Value, ",")
		if(table.find(Used_Codes, Code_Key) == nil)then
			--Reward
			table.insert(Used_Codes, Code_Key)
			Plr_Codes_Val.Value = table.concat(Used_Codes, ",")

			local Data = Codes_Data[Code_Key]
			local Amount = Data['Amount']
			Data['Reward'](Plr, Amount)

			return ok(Data['Text'])
		else
			return notOk(" You've already Redeemed this Code!", false)
		end
	else
		return notOk(" Invalid Code! Please try another!", true)
	end
end


-----	Redeem Daily Rewards Handle	-----

local Func_Data = {
	['Gems'] = Boost_Gems,
	['Cash'] = Boost_Cash,
	['Cash Pack'] = Boost_Cash_Via_Pack,
	['Gems Pack'] = Boost_Gems_Via_Pack,
	['Crate'] = Award_Free_Crate,
	['Gamepass'] = Grant_Free_Gamepass,
	['Ranked Move'] = Award_Ranked_Move,
	['Ranked Strike'] = Award_Ranked_Strike,
	['Emotes'] = Award_Emotes
}

Receiving_RF:WaitForChild("Claim_Daily_Reward").OnServerInvoke = function(Plr, Key)
	local Owned_Key_Val =  Get_Player_Val(Plr, "Redeemed Rewards")
	local Owned_Keys = Rewards_Mod.Get_Claimed_Daily_Player_Rewards(Plr)
	local Current_Streak = Rewards_Mod.Get_Player_Retention_Streak(Plr)

	if(Owned_Key_Val ~= nil and Current_Streak >= Key and table.find(Owned_Keys, Key .. "") == nil)then
		local Reward_Data = Rewards_Mod.Get_Specific_Daily_Reward(Key)
		local Reward_Type = Reward_Data['Type']
		local Amount = Reward_Data['Amount']
		Func_Data[Reward_Type](Plr, Amount)

		table.insert(Owned_Keys, Key)
		Owned_Key_Val.Value = table.concat(Owned_Keys, ",")

		return true
	end

	return false
end

-----	Skill Tree Reward Handle	-----
local function Unit_Test_For_Progression(Plr, Key, Next_Index)
	wait(1)
	local Data_V = Get_Player_Val(Plr, Key)
	local Skill_Tree_Data, Reward_Data = Skill_Tree_Mod.Get_All_Skill_Tree_Data()
	if(Next_Index < #Skill_Tree_Data[Key])then
		Data_V.Value = Skill_Tree_Data[Key][Next_Index] + 1
	end
end

Receiving_RF:WaitForChild("Redeem_Skill_Tree_Reward").OnServerInvoke = function(Plr, Key, Tree_Index)
	--[[
		* Verify Player & Data Value
		* Verify the Player hasn't Redeemed already
		* Verify the Reward / Requirement Exists
		* Verify the Player has met the Requirement
		
		- Add Data Packet to the Value
		- Redeem the Reward
		- Process and return the Reward Text
	]]--
	
	local Owned_Skill_Tree_V = Get_Player_Val(Plr, "Redeemed Skill Tree")
	if(Plr ~= nil and Owned_Skill_Tree_V ~= nil and Skill_Tree_Mod.Verify_Tree_Index(Key, Tree_Index) 
		and Skill_Tree_Mod.Has_Player_Can_Redeemed_Reward(Plr, Key, Tree_Index) and 
		Skill_Tree_Mod.Player_Has_Met_Requirement(Plr, Key, Tree_Index))then
		
		local Redeemed_ST_Rewards = string.split(Owned_Skill_Tree_V.Value, ",")
		local Data_Entry = Skill_Tree_Mod.Get_Redeem_Data_Entry(Key, Tree_Index)
		table.insert(Redeemed_ST_Rewards, Data_Entry)
		Owned_Skill_Tree_V.Value = table.concat(Redeemed_ST_Rewards, ",")
		
		local Reward_Data = Skill_Tree_Mod.Get_Reward_Data(Key, Tree_Index)
		local Reward_Type = Reward_Data['Reward']
		local Amount = Reward_Data['Amount']
		local Ret_Txt = Reward_Data['Text'] 
		local Res_Txt = Func_Data[Reward_Type](Plr, Amount)
		if(Res_Txt ~= nil)then
			Ret_Txt = string.gsub(Ret_Txt, "Takedown & Submission Combo!", Res_Txt)
		end
		
		--task.spawn(Unit_Test_For_Progression, Plr, Key, Tree_Index + 1)
		return true, Ret_Txt
	end
	
	return false, ""
end



-----	Save & Update Settings Handle	-----
Receiving_Events_F:WaitForChild("Save_Settings").OnServerEvent:Connect(function(Plr, New_Data)
	if(Plr ~= nil)then
		for Data_Key, Data_Val in next, New_Data do
			local Val = Get_Player_Val(Plr, Data_Key)
			if(Val ~= nil and Val:IsA("BoolValue") and typeof(Data_Val) == "boolean")then
				Val.Value = Data_Val
			end
		end
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9238B74FF84D45C3B12F7BFE736FB015">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Monetization_Handle.server.lua</string>
						<string name="ScriptGuid">{D7E7223C-EB2D-41F7-B4F4-AA8E54B075DD}</string>
						<ProtectedString name="Source"><![CDATA[local MPS = game:GetService("MarketplaceService")
local ENS = game:GetService("ExperienceNotificationService")
local MS = game:GetService("MessagingService")
local Data_Mod_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Monetization_Mod = require(Data_Mod_F:WaitForChild("Monetization_Mod"))
local Num_Str_Mod = require(Data_Mod_F:WaitForChild("Num_String_Mod"))
local Clothing_Mod = require(Data_Mod_F:WaitForChild("Clothing_Mod"))

local DatastoreService = game:GetService("DataStoreService")
local LimitedItemsStore = DatastoreService:GetDataStore("Limited_Items")

local ItemKeyName = "Fury_Gloves"
local ItemMaxCount = 1000

local GAModule = require(game.ServerScriptService.GAModule)
local GameAnalytics = require(game.ReplicatedStorage.GameAnalytics)
local CreatorCodes = require(game.ReplicatedStorage.CreatorCodes)

local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Receiving_F = Channels_F:WaitForChild("Client_Server_F")
local Sending_F = Channels_F:WaitForChild("Server_Client_F")
local Sending_Events_F = Sending_F:WaitForChild("Events")
local Msg_E = Sending_Events_F:WaitForChild("Display_Data")
local Open_Shop_E = Sending_Events_F:WaitForChild("Open_Shop")

--For Gamepass Data Purchasing
local function Get_Player_Val(Plr, Val)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Val) ~= nil) then
		return PD:FindFirstChild(Val)
	end

	return nil
end

local function Award_Cash_Gems(Plr, Data_Type, Amount)
	local Cash_Val = Get_Player_Val(Plr, Data_Type)
	if(Cash_Val ~= nil)then
		Cash_Val.Value += Amount
	end
end

local function Award_Emotes_To_Player(Plr, Emote_Keys)
	local Owned_Emotes_V = Get_Player_Val(Plr, "Owned Emotes")
	if(Owned_Emotes_V ~= nil)then
		local Owned_Emotes_Arr = string.split(Owned_Emotes_V.Value, ",") or {}
		for i = 1, #Emote_Keys do
			local K = string.gsub(Emote_Keys[i], " ", "")
			if(K ~= nil and string.len(K) > 0 and table.find(Owned_Emotes_Arr, K) == nil)then
				table.insert(Owned_Emotes_Arr, K)
			end
		end
		
		Owned_Emotes_V.Value = table.concat(Owned_Emotes_Arr, ",")
	end
end

local function Gamepass_Handle(Plr, ID)
	local Key = Monetization_Mod.Get_Key_From_ID(true, ID)
	local Owned_Gamepass_Val = Get_Player_Val(Plr, "Owned Gamepasses")
	if(Owned_Gamepass_Val ~= nil) then
		local Owned_Keys = string.split(Owned_Gamepass_Val.Value, ",")
		if(table.find(Owned_Keys, Key) == nil)then
			table.insert(Owned_Keys, Key)
			Owned_Gamepass_Val.Value = table.concat(Owned_Keys, ",")
		end

		--Core Logic of Gamepass being Earned
		local GP_Msg_Data = {
			['B'] = {
				['Text'] = " Successfully purchased! You're now Earning x2 ELO after Winning Ranked Fights!",
				['Color'] = Color3.fromRGB(170, 85, 255)
			},
			
			['C'] = {
				['Text'] = " Successfully purchased! You're now Earning x2 more Cash per Knockout!",
				['Color'] = Color3.new(0, 1, 0)
			},
			
			['E'] = {
				['Text'] = " Successfully purchased! You'll have x2 more Luck when opening Equipment Crates!",
				['Color'] = Color3.fromRGB(170, 255, 0)
			},
			
			['F'] = {
				['Text'] = " Successfully purchased! You'll have x3 more Luck when opening Equipment Crates!",
				['Color'] = Color3.fromRGB(170, 85, 255)
			},
			
		}

		if(Key == "A")then
			Plr:SetAttribute("Is_VIP", true)

			local Txt = " You're now a VIP Player! Enjoy + 10% more Cash per Knockout & a VIP Chat Tag!"
			Msg_E:FireClient(Plr, Txt, Color3.fromRGB(255, 170, 0))

			local Txt = Plr.Name .. " is now a VIP Player!"
			Sending_F:WaitForChild("Events"):WaitForChild("Server_Chat"):FireAllClients(Txt, Color3.fromRGB(255, 170, 0))

		elseif(Key == "D")then
			local Txt = " Successfully purchased! You've Unlocked 3 Special Emotes!"
			Msg_E:FireClient(Plr, Txt, Color3.fromRGB(0, 170, 255))
			
			--Give to Player
			Award_Emotes_To_Player(Plr, {"I", "J", "K"}) -- Add in the 3 new Emote Keys later when you add these in
			
			Sending_Events_F:WaitForChild("Open_Emotes"):FireClient(Plr)

		elseif(GP_Msg_Data[Key] ~= nil)then
			local D = GP_Msg_Data[Key]
			Msg_E:FireClient(Plr, D['Text'], D['Color'])
			
			if(Key == "E" or Key == "F")then
				Open_Shop_E:FireClient(Plr, "Crates")
			end
		end
	end
end

local function Additional_GP_Security_Delay(Plr, GP_ID)
	--3 Second Delay to check if Player owns Gamepass
	for i = 1, 3 do
		if(Plr == nil)then
			return false
		end

		local Did_Buy = Monetization_Mod.Hard_Gamepass_Check(Plr, GP_ID)
		if(Did_Buy == true)then
			return true
		end

		wait(1)
	end

	return false	
end

local GamepassCache = {}
MPS.PromptGamePassPurchaseFinished:Connect(function(Plr, GP_ID, Did_Buy)
	wait() -- Wait until Gamepass is fully Processed
	if(Plr ~= nil and Did_Buy)then
		local Secondary_Security_Check = Additional_GP_Security_Delay(Plr, GP_ID)
		if(Secondary_Security_Check)then
			Gamepass_Handle(Plr, GP_ID)
		end
		
		--task.spawn(function()
		--	GameAnalytics:GamepassPurchased(Plr, GP_ID)
		--end)
		task.spawn(function()
			local plrData = Plr:FindFirstChild("Player_Data")
			if plrData ~= nil then
				local creatorCode = plrData:FindFirstChild("Creator Code")
				if creatorCode ~= nil then
					local newCodeIndex = creatorCode.Value
					if CreatorCodes[newCodeIndex] ~= nil then
						local gamepassInfo = GamepassCache[GP_ID]

						--Cache
						if not gamepassInfo then
							--Get
							gamepassInfo = MPS:GetProductInfo(GP_ID, Enum.InfoType.GamePass)
							GamepassCache[GP_ID] = gamepassInfo
						end

						if gamepassInfo then
							GAModule:CreatorSupported(Plr, CreatorCodes[newCodeIndex].Name, gamepassInfo.PriceInRobux)
						end
					end
				end
			end
		end)
	end
end)

Bindable_Events_F:WaitForChild("Grant_Gamepass_Perks").Event:Connect(function(Plr, GP_ID)
	if(Plr ~= nil)then
		Gamepass_Handle(Plr, GP_ID)
	end
end)

--[[
MS:SubscribeAsync("Special_Vehicle_Topic", function(Msg)
	local Owner_Name = Msg.Data['Owner Name']
	local Vehicle_Key = Msg.Data['Vehicle_Key']
	local V_Data = Vehicle_Mod.Get_Vehicle_From_Key(Vehicle_Key)

	if(V_Data['Limited Hint'] ~= nil)then
		--Limited Vehicle
		local Txt = Owner_Name .. " has unlocked a LIMITED " .. V_Data['Name'] .. " Vehicle!"
		Sending_Events_F:WaitForChild("Server_Chat"):FireAllClients(Txt, Color3.fromRGB(170, 85, 255))
	elseif(V_Data['Purchase Data'] ~= nil)then
		--Exclusive Vehicle
		local Txt = Owner_Name .. " has purchased an EXCLUSIVE " .. V_Data['Name'] .. " Vehicle from the Shop!"
		Sending_Events_F:WaitForChild("Server_Chat"):FireAllClients(Txt, Color3.fromRGB(255, 193, 60))
	end
end)
]]--

local function Dev_Product_Handle(Plr, ID)
	local Key = Monetization_Mod.Get_Key_From_ID(false, ID)
	local Item_Data = Monetization_Mod.Get_All_Dev_Product_Data()[Key]
	local Type = Item_Data['Type']
	local Owned_Products_Val = Get_Player_Val(Plr, "Owned Products")

	local function Update_Owned_Products_Val(Key, Amount)
		local Owned_Keys = string.split(Owned_Products_Val.Value, ",")
		for i = 1, Amount do
			table.insert(Owned_Keys, Key)
		end

		Owned_Products_Val.Value = table.concat(Owned_Keys, ",")
	end
	
	local HasCreatorCode = false
	local plrData = Plr:FindFirstChild("Player_Data")
	if plrData ~= nil then
		local creatorValue = plrData:FindFirstChild("Creator Code")
		if creatorValue ~= nil then
			local creatorKey = creatorValue.Value
			if CreatorCodes[creatorKey] ~= nil then
				HasCreatorCode = true
			end
		end
	end
	
	local multiplier = 1
	if HasCreatorCode == true then
		multiplier = 1.1
	end

	if(Type == "Cash")then
		local Boost_Amount = math.ceil(Monetization_Mod.Get_Cash_Boost_Amount(Plr)[Key] * multiplier)
		Award_Cash_Gems(Plr, "Coins", Boost_Amount)

		local Txt = " You successfully purchased + $" .. Num_Str_Mod.NumToString(Boost_Amount) .. "!"
		Msg_E:FireClient(Plr, Txt, Color3.fromRGB(170, 255, 0))
		return true
		
	elseif(Type == "Gems")then
		local Boost_Amount = math.ceil((Item_Data['Amount'] or 10) * multiplier)
		Award_Cash_Gems(Plr, Type, Boost_Amount)

		local Txt = " You successfully purchased + " .. Num_Str_Mod.NumToString(Boost_Amount) .. " Gems!"
		Msg_E:FireClient(Plr, Txt, Color3.fromRGB(0, 170, 255))
		return true
	elseif (Type == "StarterPack")then
		local plrData = Plr:FindFirstChild("Player_Data")
		if plrData == nil then
			return false
		end
		
		local starterPackTimer = plrData:FindFirstChild("StarterPackTimer")
		if starterPackTimer == nil then
			return false
		end
		local rookieTag = plrData:FindFirstChild("RookieTag")
		if rookieTag == nil then
			return false
		end
		
		local deltaTime = starterPackTimer.Value - os.time()
		if deltaTime <= -10 then
			return false
		end

		local Txt = "You successfully purchased the Starter Pack!"
		Msg_E:FireClient(Plr, Txt, Color3.fromRGB(255, 200, 0))

		Award_Cash_Gems(Plr, "Coins", math.ceil(200 * multiplier))
		Award_Cash_Gems(Plr, "Gems", math.ceil(5 * multiplier))
		Clothing_Mod.Give_Player_Gloves(Plr, "C")
		rookieTag.Value = true
		
		starterPackTimer.Value = os.time() - 15 -- Reset it so that 
		
		return true
	elseif Type == "Special Gloves" then

		local Txt = "You successfully purchased the Special Gloves!"
		Msg_E:FireClient(Plr, Txt, Color3.fromRGB(255, 200, 0))
		
		local value = false
		LimitedItemsStore:UpdateAsync(ItemKeyName, function(oldValue)
			if oldValue == nil then
				oldValue = 0
			end
			
			local newValue = oldValue + 1
			game.Workspace:SetAttribute("Remaining_Special_Gloves", math.min(newValue, ItemMaxCount))
			
			if newValue <= ItemMaxCount * 1.05 then
				value = true
			else
				value = false
			end
			
			if value == true then
				local plrData = Plr:FindFirstChild("Player_Data")
				if plrData ~= nil then
					if Clothing_Mod.Player_Owns_Gloves_Key(Plr, "G2") ~= true then
						Clothing_Mod.Give_Player_Gloves(Plr, "G2")
						Channels_F.Server_Client_F.Events.Hide_Special_Gloves_Frame:FireClient(Plr)
					end
				end
			end
			
			return newValue
		end)
		
		return true
	end

	return false
end

task.spawn(function()
	while true do
		local currentCount = ItemMaxCount
		pcall(function()
			currentCount = LimitedItemsStore:GetAsync(ItemKeyName) or 0
		end)
		
		game.Workspace:SetAttribute("Total_Special_Gloves", ItemMaxCount)
		game.Workspace:SetAttribute("Remaining_Special_Gloves", currentCount)
		
		task.wait(60)
	end
end)

--ADDITIONAL SECURITY CHECKS NEEDED SINCE PROMPTFINISHED FUNCTIONS CAN BE SPOOFED
local Dev_Product_Receipts = {

}

local ProductCache = {}
local function Create_Receipt(receiptInfo)
	--Verify Player exists, Verify Dev Product exists
	--Add Result of Purchase to Dev Product Receipt Table
	local P_ID = receiptInfo.PlayerId
	local Dev_ID = tonumber(receiptInfo.ProductId)
	local Plr = game.Players:GetPlayerByUserId(P_ID)
	local Dev_Key = Monetization_Mod.Get_Key_From_ID(false, Dev_ID)

	if(Plr ~= nil and Dev_Key ~= nil)then
		--Add to Data Table
		if(Dev_Product_Receipts[Dev_ID] ~= nil)then
			table.insert(Dev_Product_Receipts[Dev_ID], P_ID)
		else
			Dev_Product_Receipts[Dev_ID] = {P_ID}
		end
		
		task.spawn(function()
			GameAnalytics:ProcessReceiptCallback(receiptInfo)
		end)
		task.spawn(function()
			local plrData = Plr:FindFirstChild("Player_Data")
			if plrData ~= nil then
				local creatorCode = plrData:FindFirstChild("Creator Code")
				if creatorCode ~= nil then
					local newCodeIndex = creatorCode.Value
					if CreatorCodes[newCodeIndex] ~= nil then
						local ProductInfo = ProductCache[receiptInfo.ProductId]

						if not ProductInfo then
							local success, err = pcall(function()
								ProductInfo = MPS:GetProductInfo(receiptInfo.ProductId, Enum.InfoType.Product)
								ProductCache[receiptInfo.ProductId] = ProductInfo
							end)
							if success == false then
								warn(err)
							end
						end

						if ProductInfo then
							GAModule:CreatorSupported(Plr, CreatorCodes[newCodeIndex].Name, ProductInfo.PriceInRobux)
						end
					end
				end
			end
		end)

		return Enum.ProductPurchaseDecision.PurchaseGranted
	end

	return Enum.ProductPurchaseDecision.NotProcessedYet
end
MPS.ProcessReceipt = Create_Receipt

MPS.PromptProductPurchaseFinished:Connect(function(P_ID, Dev_ID, Did_Buy)
	wait() -- Wait until Recepit is made and Processed
	if(game.Players:GetPlayerByUserId(P_ID) ~= nil and Did_Buy and Dev_Product_Receipts[Dev_ID] ~= nil)then
		local P_Index = table.find(Dev_Product_Receipts[Dev_ID], P_ID)
		if(P_Index ~= nil)then
			local Plr = game.Players:GetPlayerByUserId(P_ID)
			local Was_Processed = Dev_Product_Handle(Plr, Dev_ID)

			--Don't remove if this is a Home Sale Listing Slot
			if(Was_Processed)then
				table.remove(Dev_Product_Receipts[Dev_ID], P_Index)
			end
		end
	end
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9751E2F8D9FC4412ADBB37C9F221EC7D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Server_List_Handle.server.lua</string>
						<string name="ScriptGuid">{5BCCD163-0E7C-4C21-86DB-E6E1FF98D90C}</string>
						<ProtectedString name="Source"><![CDATA[local Teleport_Service = game:GetService("TeleportService")
local RunService = game:GetService("RunService")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Sending_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Receiving_RF = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("RF")
local MS_Mod = require(script:WaitForChild("MS_Module"))
local Server_ID = game.JobId

-- Helper pour rcuprer une valeur stocke dans Player_Data
local function Get_Player_Val(Plr, Key)
	local PD = Plr:FindFirstChild("Player_Data")
	if PD and PD:FindFirstChild(Key) then
		return PD[Key].Value
	end
	return 0
end

-- Compile les infos du serveur local et les envoie  la MemoryStore
local function Compile_Main_Server_Data()
	local Server_Size_Data = {}
	local Highest_Elo = -1
	local Avg_Elo, Avg_Wins, Avg_Ranked_Wins = 0, 0, 0
	local All_P = game.Players:GetPlayers()

	local function Process_Plr(Plr)
		local P_Elo = Get_Player_Val(Plr, "Elo")
		local P_Wins = Get_Player_Val(Plr, "Total Wins")
		local P_Ranked_Wins = Get_Player_Val(Plr, "Ranked Wins")

		Avg_Elo += P_Elo
		Avg_Wins += P_Wins
		Avg_Ranked_Wins += P_Ranked_Wins

		if P_Elo >= Highest_Elo then
			Highest_Elo = P_Elo
		end

		table.insert(Server_Size_Data, Plr.UserId)
	end

	for _, P in ipairs(All_P) do
		Process_Plr(P)
	end

	local count = #Server_Size_Data
	if count == 0 then count = 1 end -- viter division par 0

	local S_Data = {
		['Highest Elo'] = Highest_Elo,
		['Average Elo'] = math.ceil(Avg_Elo / count),
		['Average Wins'] = math.ceil(Avg_Wins / count),
		['Average Ranked Wins'] = math.ceil(Avg_Ranked_Wins / count),
		['Server Size'] = Server_Size_Data
	}

	MS_Mod.Add_Data(Server_ID, S_Data)
	--print("[Server_List_Handle] Compiled + pushed data for server:", Server_ID, S_Data)
end
task.spawn(Compile_Main_Server_Data)

-- Mise  jour force par vnement
Bindable_Events_F:WaitForChild("Update_Server_Data").Event:Connect(function()
	if not RunService:IsStudio() then		
		Compile_Main_Server_Data()
	end
end)

-- Rcupration et broadcast des donnes de tous les serveurs
local function Get_All_Server_Data()
	local Raw_Data = MS_Mod.Get_All_World_Data()
	local Compiled_Data = {}

	for S_ID, Data in pairs(Raw_Data) do
		local size = Data['Server Size'] and #Data['Server Size'] or 0
		if size > 0 then -- ignore empty servers
			local D = {
				['Highest Elo'] = Data['Highest Elo'] or 0,
				['Average Elo'] = Data['Average Elo'] or 0,
				['Average Wins'] = Data['Average Wins'] or 0,
				['Average Ranked Wins'] = Data['Average Ranked Wins'] or 0,
				['Server Size'] = Data['Server Size'] or {},
				['Server ID'] = S_ID
			}
			table.insert(Compiled_Data, D)
		else
			--print("[Server_List_Handle] Ignored empty server", S_ID)
		end
	end

	--print("[Server_List_Handle] Get_All_Server_Data ->", #Compiled_Data, "servers")
	Sending_Events_F:WaitForChild("Update_All_Server_Data"):FireAllClients(Compiled_Data)
	return Compiled_Data
end

local All_Server_Data = Get_All_Server_Data()

Receiving_RF:WaitForChild("Get_All_Server_Data").OnServerInvoke = function()
	--print("[Server_List_Handle] Client requested server list, returning", #All_Server_Data)
	return All_Server_Data
end

-- Tlportation inter-serveurs
local function Teleport_Player_To_Server(Plr, S_ID)
	local Place_ID = 117620200631077
	local TP_Data = Instance.new("TeleportOptions")
	TP_Data.ReservedServerAccessCode = ""
	TP_Data.ServerInstanceId = tostring(S_ID)
	TP_Data.ShouldReserveServer = false

	local function Async()
		local success, errormessage = pcall(function()
			Teleport_Service:TeleportAsync(Place_ID, {Plr}, TP_Data)
		end)
		if not success then
			warn("[Server_List_Handle] Teleport failed:", errormessage)
		end
		return success
	end

	for i = 1, 3 do 
		if Async() then
			return true
		end
	end
	return false
end

Receiving_RF:WaitForChild("Teleport_To_Server").OnServerInvoke = function(Plr, S_ID)
	return Teleport_Player_To_Server(Plr, S_ID)
end

-- Boucle dauto-update
local function Auto_Update_Servers_Data()
	while task.wait(60) do
		-- Forcer une recompilation locale
		Compile_Main_Server_Data()
		-- Mettre  jour la variable globale + notifier clients
		All_Server_Data = Get_All_Server_Data()
	end
end
task.spawn(Auto_Update_Servers_Data)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX0BF06F2BB1EB4518A9E08F5C7D611EBB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Server_List_Handle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXAECD6046914E4F91AA2A1BA0DC8F45FB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MS_Module.lua</string>
							<string name="ScriptGuid">{8A9E355C-81A6-4DBC-A053-83B25DF08C71}</string>
							<ProtectedString name="Source"><![CDATA[local funcs = {}
local MSS = game:GetService("MemoryStoreService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

-- Main MemoryStore SortedMap used to share data between servers
local Servers_Data = MSS:GetSortedMap("Servers_Data")

-- Default data duration (time-to-live) in seconds (30 minutes)
local Data_Duration = 1800

-- === Helpers ===

-- Ensure TTL stays in Roblox allowed range (5s - 12h)
local function clampTTL(ttl)
	ttl = tonumber(ttl) or Data_Duration
	if ttl < 5 then ttl = 5 end
	if ttl > 43200 then ttl = 43200 end
	return ttl
end

-- Ensure key is safe (non-empty string).
-- Always generate a fallback if empty.
local function safeKey(key)
	local k = (key ~= nil and tostring(key) or "")
	if k == "" then
		-- fallback key, works both in Studio and production
		k = ("server_%s_%d"):format(game.PlaceId, os.time())
		if RunService:IsStudio() then
			warn("[Servers_Data] Generated fallback key:", k)
		end
	end
	return k
end

-- Generic retry wrapper for MemoryStore operations
-- action: function(attemptIndex) -> result or nil
local function retry(attempts, action)
	for i = 1, attempts do
		local success, result = pcall(action, i)
		if success and result ~= nil then
			return result
		end
		if not success then
			warn("[Servers_Data] attempt #" .. i .. " failed: " .. tostring(result))
		end
	end
	return nil
end

-- === Core API ===

-- Store a JSON-encoded data table under a given key
function funcs.Add_Data(Key, Data)
	local k = safeKey(Key)
	if not k then
		warn("[Servers_Data] Add_Data ignored: empty key")
		return false
	end

	return retry(3, function()
		Servers_Data:SetAsync(k, HttpService:JSONEncode(Data), clampTTL(Data_Duration))
		return true
	end)
end

-- Retrieve and decode JSON data for a given key
function funcs.Get_Data(Key)
	local k = safeKey(Key)
	if not k then
		warn("[Servers_Data] Get_Data ignored: empty key")
		return nil
	end

	return retry(3, function()
		local data = Servers_Data:GetAsync(k)
		return data and HttpService:JSONDecode(data) or nil
	end)
end

-- Remove a key from the store
function funcs.Remove_Data(Key)
	local k = safeKey(Key)
	if not k then
		warn("[Servers_Data] Remove_Data ignored: empty key")
		return false
	end

	return retry(3, function()
		Servers_Data:RemoveAsync(k)
		return true
	end)
end

-- Retrieve all available entries (up to 200) as a dictionary
-- { key -> decoded JSON value }
function funcs.Get_All_World_Data()
	return retry(3, function()
		local data = Servers_Data:GetRangeAsync(Enum.SortDirection.Descending, 200)
		if not data then return nil end

		local ret = {}
		for _, entry in ipairs(data) do
			ret[entry.key] = HttpService:JSONDecode(entry.value)
		end

		--print("[Servers_Data] Get_All_World_Data ->", #data, "entries")
		return ret
	end) or {}
end

return funcs
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX28A7F5DA42214E69B7884A1CAE2EC0A3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MS_Module_OLD.lua</string>
							<string name="ScriptGuid">{B7676575-BE70-4D1C-825F-BB7879398BC4}</string>
							<ProtectedString name="Source"><![CDATA[-- === add helpers to prevent nil keys seen in the logs ===

local function clampTTL(ttl)
	ttl = tonumber(ttl) or 1800
	if ttl < 5 then ttl = 5 end
	if ttl > 43200 then ttl = 43200 end
	return ttl
end

local function safeKey(key)
	-- Keep provided key if non-empty
	local k = (key ~= nil and tostring(key) or "")
	if k ~= "" then return k end
	-- In Studio, fallback to a non-empty key to prevent exceptions
	if RunService:IsStudio() then
		return ("server_dev_%s_%d"):format(game.PlaceId, os.time())
	end
	-- In production, reject empty key (log + no write)
	return nil
end

local function SetServer(key, value, ttl)
	-- Prefer the module's map instance if present, else fallback to a fresh handle
	local mapOk, map = pcall(function()
		return (rawget(_G, "__Servers_Data") or __Servers_Data)
	end)
	map = mapOk and map or __Servers_Data

	local k = safeKey(key)
	if not k then
		warn("[Servers_Data] SetAsync ignored: empty key in production")
		return false, "empty_key"
	end

	local ok, err = pcall(function()
		map:SetAsync(k, value, clampTTL(ttl))
	end)
	if not ok then
		warn(string.format("[Servers_Data] SetAsync failed key=%s err=%s", tostring(k), tostring(err)))
	end
	return ok, (ok and nil or tostring(err))
end
-- === End helpers ===

local funcs = {}
local MSS = game:GetService("MemoryStoreService")
local HTTPService = game:GetService("HttpService")
local Servers_Data = MSS:GetSortedMap("Servers_Data")
local Data_Duration = 1800 -- Data Slot will be auto removed after 30 minutes if it's not updated

function funcs.Add_Data(Key, Data)	
	local function Async(Attempt)
		local success, errormessage = pcall(function()
			SetServer(Key, HTTPService:JSONEncode(Data), Data_Duration)
		end)

		if(success)then
			return true
		else
			if(errormessage ~= nil)then
				print("Failed to Add " .. Key .. " to World Data! | Attempt #" .. Attempt .. " | Error: " .. errormessage)
			end
			return false
		end
	end

	for i = 1, 3 do
		local D = Async(i)
		if(D)then
			return
		end
	end
end

function funcs.Get_Data(Key)
	local function Async(Attempt)
		local Data = nil
		local success, errormessage = pcall(function()
			Data = Servers_Data:GetAsync(Key)
		end)

		if(success and Data ~= nil)then
			return HTTPService:JSONDecode(Data)
		else
			if(errormessage ~= nil)then
				print("Failed to Get " .. Key .. " from Public Server Data! | Attempt #" .. Attempt .. " | Error: " .. errormessage)
			end

			return nil
		end
	end

	for i = 1, 3 do
		local D = Async(i)
		if(D ~= nil)then
			return D
		end
	end

	return nil
end

function funcs.Remove_Data(Key)
	local function Async()
		local success, errormessage = pcall(function()
			Servers_Data:RemoveAsync(Key)
		end)

		if(success)then
			return true
		end
		return false
	end

	for i = 1, 3 do
		if(Async())then
			return
		end
	end
end

local function Get_All_Data()
	local function Async(Attempt)
		local Data = nil
		local success, errormessage = pcall(function()
			Data = Servers_Data:GetRangeAsync(Enum.SortDirection.Descending, 200)
		end)

		if(success and Data ~= nil)then
			return Data
		else
			if(errormessage ~= nil)then
				print("Failed to All Data from Public Server Data! | Attempt #" .. Attempt .. " | Error: " .. errormessage)
			end
			return nil
		end
	end

	for i = 1, 3 do
		local D = Async(i)
		if(D ~= nil)then
			return D
		end
	end
	return nil
end

function funcs.Get_All_World_Data()
	local Data = Get_All_Data()
	local Ret_Data = {

	}

	if(Data ~= nil)then
		for i = 1, #Data do
			Ret_Data[Data[i].key] = HTTPService:JSONDecode(Data[i].value)
		end
	end

	return Ret_Data
end

return funcs]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX7C997144DC384F1BB7C5FFBEAB03F0E0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Shop_Handle.server.lua</string>
						<string name="ScriptGuid">{CC020220-64D5-42C1-BD0B-5653276A7199}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	* Shop Handler
	* Handles most of the crate system and shop system
]]--


local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Receiving_RF = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("RF")
local Receiving_Events = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("Events")
local Sending_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Crate_Mod = require(Data_Mods_F:WaitForChild("Crate_Mod"))
local Clothing_Mod = require(Data_Mods_F:WaitForChild("Clothing_Mod"))
local Monetization_Mod = require(Data_Mods_F:WaitForChild("Monetization_Mod"))

-- Monetization_Mod.Get_Luck_Multi(Player Object)

local function Get_Player_Val(Plr, Val_Name)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil)then
		local Val = PD:FindFirstChild(Val_Name)
		if(Val ~= nil)then
			return Val
		end
	end	

	return nil
end

local function Check_Crate(CrateName)
	local Crates = Crate_Mod.GetCrates()
	for i, crate in pairs(Crates) do
		if (crate["Name"] == CrateName) then
			return true, i
		end
	end
	return false, nil
end

local function GetNearbyPlayers(originPlayer, range)
	local nearby = {}
	local originChar = originPlayer.Character
	if not originChar or not originChar:FindFirstChild("HumanoidRootPart") then return nearby end

	local originPos = originChar.HumanoidRootPart.Position

	for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
		if otherPlayer ~= originPlayer then
			local otherChar = otherPlayer.Character
			if otherChar and otherChar:FindFirstChild("HumanoidRootPart") then
				local dist = (otherChar.HumanoidRootPart.Position - originPos).Magnitude
				if dist <= range then
					table.insert(nearby, otherPlayer)
				end
			end
		end
	end

	table.insert(nearby, originPlayer)

	return nearby
end


--// Server Message

Receiving_Events:WaitForChild("Server_Message_Crate").OnServerEvent:Connect(function(Plr, Txt, Clr)
	if(Plr ~= nil)then
		Sending_F:WaitForChild("Server_Chat"):FireAllClients(Txt, Clr)
		task.wait()
	end
end)

--// Handle Crate Purchasing

Receiving_RF:WaitForChild("Crate_Action_Request").OnServerInvoke = function(Plr, Crate, Currency)
	local Crates = Crate_Mod.GetCrates()
	local CheckCrate, Index = Check_Crate(Crate["Name"])

	if (Plr and CheckCrate == true) then
		if (Currency == "Gems" or Currency == "Coins") then
			local Player_Currency = Get_Player_Val(Plr, Currency)
			local Chosen_Currency = "PriceCoins"
			if Currency == "Gems" then
				Chosen_Currency = "PriceGems"
			end

			if(Player_Currency and Player_Currency.Value >= Crates[Index][Chosen_Currency]) then
				Player_Currency.Value -= Crates[Index][Chosen_Currency]

				local Luck = Monetization_Mod.Get_Luck_Multi(Plr)
				local rewardType = Crates[Index].RewardType
				local rewardFunction
				if rewardType == "Gloves" then
					rewardFunction = Clothing_Mod.Give_Player_Gloves
				elseif rewardType == "Shorts" then
					rewardFunction = Clothing_Mod.Give_Player_Shorts
				end
				if rewardFunction == nil then
					Player_Currency.Value += Crates[Index][Chosen_Currency] -- REFUND
					return false, nil
				end

				local items = Crates[Index]["Items"]
				local selectedItem = nil
				local selectedItemKey = nil

				local scaling = 1.0

				local totalWeight = 0
				local adjustedItems = {}

				for _, item in pairs(items) do
					local baseChance = item["Rarity"]
					local boostFactor = 1 + ((1 / baseChance) ^ 0.5 - 1) * (Luck - 1) * scaling
					local adjustedChance = baseChance * boostFactor

					table.insert(adjustedItems, {
						Name = item["Name"],
						Weight = adjustedChance,
						ItemKey = item["ItemKey"],
					})

					totalWeight += adjustedChance
				end

				local roll = Random.new():NextNumber(0, totalWeight)
				local cumulative = 0
				for _, item in ipairs(adjustedItems) do
					cumulative += item.Weight
					if roll <= cumulative then
						selectedItem = item.Name
						selectedItemKey = item.ItemKey
						break
					end
				end

				rewardFunction(Plr, selectedItemKey)

				adjustedItems = nil

				if (selectedItem) then
					return true, selectedItem
				end

			end

		end
	end

	return false, nil
end

--// Handle Displaying Crate

local function PlayKeyframeCallback(animation, Position, Callback)
	local Animation = animation
	while (task.wait() and Animation.IsPlaying) do
		if (Animation.TimePosition >= Position) then
			if (Callback) then coroutine.wrap(Callback)() end
			break
		end
	end
end

Receiving_Events:WaitForChild("Crate_Display").OnServerEvent:Connect(function(Plr, item, rarity, color)
	if (Plr ~= nil and Plr.Character ~= nil) then
		if (workspace.Crates:FindFirstChild(Plr.Name) == nil) then

			local ClothingFolder = game.ReplicatedStorage:WaitForChild("Clothing_F")
			local GymCaseRig = workspace:WaitForChild("GymCaseRig")

			if not item or not item.Name then return end
			local template = ClothingFolder:FindFirstChild(item.Name, true)
			if not template then return end

			local char = Plr.Character
			if not char then return end
			local rootPart = char:FindFirstChild("HumanoidRootPart")
			if not rootPart then return end

			local forwardVec = rootPart.CFrame.LookVector
			local offsetPos = rootPart.Position + forwardVec * 10
			local rayOrigin = offsetPos + Vector3.new(0, 10, 0)
			local rayDirection = Vector3.new(0, -100, 0)

			local rayParams = RaycastParams.new()
			rayParams.FilterDescendantsInstances = {char}
			rayParams.FilterType = Enum.RaycastFilterType.Exclude

			local result = workspace:Raycast(rayOrigin, rayDirection, rayParams)
			if not result then return end

			local groundPos = result.Position

			local crate = GymCaseRig:Clone()
			crate.Name = Plr.Name
			crate.Parent = workspace.Crates

			local size = crate:GetExtentsSize()
			local halfHeight = size.Y / 12
			local cratePos = groundPos + Vector3.new(0, halfHeight, 0)
			local flatLookVector = -Vector3.new(forwardVec.X, 0, forwardVec.Z).Unit
			local lookCFrame = CFrame.new(cratePos, cratePos + flatLookVector)

			local anim = Instance.new("Animation")
			anim.AnimationId = "rbxassetid://113179003402113"
			local track_cons = {}
			local track = crate.AnimationController.Animator:LoadAnimation(anim)

			--[[
			--table.insert(track_cons,track:GetMarkerReachedSignal("Open_Crate"):Connect(function(param)
			--	print(param)
			--	print("crate opened show glove")

			--	glove = template:Clone()

			--	if (glove:FindFirstChild("LeftHand")) then
			--		glove:WaitForChild("LeftHand").Anchored = true
			--		glove:WaitForChild("RightHand").Anchored = true

			--		glove:WaitForChild("LeftHand").Position = Vector3.new(-0.645, 0, 0)
			--		glove:WaitForChild("RightHand").Position = Vector3.new(0.245, 0, -0)
			--		glove:WaitForChild("LeftHand").Orientation = Vector3.new(0, 0, 0)
			--		glove:WaitForChild("RightHand").Orientation = Vector3.new(0, 0, 0)
			--	elseif (glove:FindFirstChild("LowerTorso")) then
			--		glove.PrimaryPart.PivotOffset = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
			--	end

			--	local cf,size = glove:GetBoundingBox()
			--	local handle = Instance.new("Part")
			--	handle.Name = "Handle"
			--	handle.Size = Vector3.new(1, 1, 1)
			--	handle.CFrame = cf
			--	handle.Transparency = 1
			--	handle.Anchored = true
			--	handle.CanCollide = false
			--	handle.Parent = glove
			--	glove.PrimaryPart = handle
			--	glove:SetAttribute("Owner", Plr.Name)

			--	for _, part in pairs(glove:GetDescendants()) do
			--		if part:IsA("BasePart") then
			--			part.Anchored = true
			--			part.CanCollide = false
			--		end
			--	end

			--	glove:PivotTo(crate.PrimaryPart.CFrame + Vector3.new(0, 0.1, 0))
			--	glove:ScaleTo(1.5)
			--	glove.Parent = workspace.Crates
			--	track:AdjustSpeed(.2)
			--end))
]]--

			track:Play()
			task.wait(.1)
			crate:PivotTo(lookCFrame * CFrame.new(0,-0.65,0))

			-- Fire client to handle animations/VFX
			local nearbyPlayers = GetNearbyPlayers(Plr, 30) 
			for _, player in ipairs(nearbyPlayers) do
				Sending_F:WaitForChild("Show_Crate_Effects"):FireClient(player, crate, item.Name, color)
			end

			local glove

			PlayKeyframeCallback(track, 4, function()

				glove = template:Clone()

				if (glove:FindFirstChild("LeftHand")) then

					for _, part in pairs(glove:GetChildren()) do
						if (part:IsA("BasePart") and (part.Name == "LeftHand" or part.Name == "RightHand")) then
							local groupName = part.Name .. "M"
							local group = glove:FindFirstChild(groupName) or Instance.new("Model")
							group.Name = groupName
							group.Parent = glove
							part.Parent = group
							part.Anchored = true
						end
					end

					if (glove:FindFirstChild("LeftHandM") and glove:FindFirstChild("RightHandM")) then
						glove:PivotTo(CFrame.new(0,0,0))
						
						glove:WaitForChild("RightHandM"):PivotTo(CFrame.new(0.5, 0, 0))
						
						glove:WaitForChild("LeftHandM"):PivotTo(CFrame.new(-0.5, 0, 0))
					end


				elseif (glove:FindFirstChild("LowerTorso")) then
					glove.PrimaryPart.PivotOffset = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
				end

				local cf,size = glove:GetBoundingBox()
				local handle = Instance.new("Part")
				handle.Name = "Handle"
				handle.Size = Vector3.new(1, 1, 1)
				handle.CFrame = cf
				handle.Transparency = 1
				handle.Anchored = true
				handle.CanCollide = false
				handle.Parent = glove
				glove.PrimaryPart = handle
				glove:SetAttribute("Owner", Plr.Name)

				for _, part in pairs(glove:GetDescendants()) do
					if part:IsA("BasePart") then
						part.Anchored = true
						part.CanCollide = false
					end
				end

				glove:PivotTo(crate.PrimaryPart.CFrame + Vector3.new(0, 1, 0))
				glove:ScaleTo(1.5)
				glove.Parent = workspace.Crates
				task.wait(1)
				track:AdjustSpeed(.2)
				task.wait(6)
				track:AdjustSpeed(1)
			end)

			table.insert(track_cons, track.Stopped:Connect(function()
				crate:Destroy()
				crate = nil

				for i = 1, #track_cons do
					if(track_cons[i] ~= nil)then
						track_cons[i]:Disconnect()
					end
				end
				table.clear(track_cons)

				task.delay(1 + 0.25, function()
					if (glove) then
						glove:Destroy()
						glove = nil
					end
				end)
			end))
			
			task.delay(18, function()
				if (crate) then
					crate:Destroy()
				end
				if (glove) then
					glove:Destroy()
				end
				
				for i = 1, #track_cons do
					if(track_cons[i] ~= nil)then
						track_cons[i]:Disconnect()
					end
				end
				table.clear(track_cons)
			end)

		end
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7049FC6467BF42BEA0B2F8646A93048D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Unique_Codes_Handle.server.lua</string>
						<string name="ScriptGuid">{B55BA961-9837-429F-9028-293E0CD5CBB5}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local DataStoreService = game:GetService("DataStoreService")

local Channels_F = ReplicatedStorage.Channels_F
local Client_Server_F = Channels_F.Client_Server_F
local Events = Client_Server_F.RF
local Unique_Code = Events.Redeem_Unique_Code

local Codes = require(game.ServerScriptService.Codes_Unique)
local RewardModules = ServerStorage.Unique_Codes_Rewards

local UsedCodesStore = DataStoreService:GetDataStore("UsedUniqueCodes_FINAL")


local debounceList = {}
game.Players.PlayerAdded:Connect(function(plr)
	debounceList[plr] = 0
end)
game.Players.PlayerRemoving:Connect(function(plr)
	debounceList[plr] = nil
end)

script.Function.OnInvoke = function(player: Player, code: any) 
	if debounceList[player] == nil then
		return " Too many requests. Try again later!"
	end
	if os.clock() - debounceList[player] <= 1 then
		debounceList[player] = os.clock()
		return " Too many requests. Try again later!"
	end
	
	
	local ok = function(msg)
		return msg
	end
	
	local notOk = function(msg)
		debounceList[player] = os.clock()
		return msg
	end
	
	
	local playerData = player:FindFirstChild("Player_Data")
	if not playerData then
		return notOk(" Too many requests. Try again later!")
	end

	local UniqueCodeUsed = playerData:FindFirstChild("UniqueCodeUsed")
	if UniqueCodeUsed and UniqueCodeUsed.Value then
		return notOk(" Already used a code before!")
	end

	local codeFound, codeData
	for _, codeInfo in Codes do
		if codeInfo.Code == code then
			codeFound = true
			codeData = codeInfo
			break
		end
	end

	if not codeFound then
		return notOk(" Invalid Code! Please try another!")
	end

	local success, alreadyUsed = pcall(function()
		return UsedCodesStore:GetAsync(code)
	end)

	if not success then
		warn("DataStore error checking code usage:", alreadyUsed)
		return notOk(" Error checking code. Try again later.")
	end

	if alreadyUsed then
		return notOk(" This code has already been redeemed!")
	end

	local rewardName = codeData.Reward
	local rewardModule = RewardModules:FindFirstChild(rewardName)

	if rewardModule and rewardModule:IsA("ModuleScript") then
		local giveReward = require(rewardModule)
		giveReward(player)

		pcall(function()
			UsedCodesStore:SetAsync(code, true)
		end)

		if UniqueCodeUsed then
			UniqueCodeUsed.Value = true
		end

		return ok(" Successfully Redeemed Code!")
	else
		return notOk(" Please try again!")
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCD9234E7990F41E3A3D999B3470134C2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Training_Handle.server.lua</string>
						<string name="ScriptGuid">{997C149F-9731-4506-82FB-2712F0615DFC}</string>
						<ProtectedString name="Source"><![CDATA[--/// setup all proximity prompts and setting up the trigger functions for them 
--// when start training fire remote to client to show exit button to exit training and the training stats ui (update stats on server)

local RunService = game:GetService("RunService")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Receiving_RF = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("RF")
local Receiving_Events = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("Events")
local Sending_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")

--// machine tables
local Prompts = {}
local Cons = {}

--// time tables
local Player_Times = {}
local Server_Plr_Times = {}
local last_RepTime = {}

local Most_Time_Spent = nil

--// track player who spent most time working 

local function len(t)
	local n = 0

	for _ in pairs(t) do
		n = n + 1
	end
	return n
end

local function Get_Player_Val(Plr, Val)
	local PD = Plr:FindFirstChild("Player_Data")
	if(PD ~= nil and PD:FindFirstChild(Val) ~= nil) then
		return PD:FindFirstChild(Val)
	end

	return nil
end

local function Check_Training(plr: Player)
	if (plr ~= nil) then
		for _, machine in pairs(workspace.Main_World_F.ScriptableObjects.GymObjects:GetChildren()) do
			if (machine ~= nil and machine:FindFirstChild("Stats")) then
				if (machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == plr.Name) then
					return true, machine
				end
			end
		end
	end
end

local function Check_Most_Time()
	local n = len(Server_Plr_Times)
	if n >= 1 then
		local most_Time = 0
		local most_Plr = nil

		for player, number in pairs(Server_Plr_Times) do
			if number > most_Time then
				most_Time = number
				most_Plr = player
			end
			
			local playerInstance = game.Players:FindFirstChild(player)
			if not playerInstance then
				continue
			end
			
			local Gym_V = Get_Player_Val(playerInstance, "Gym Training")
			if (number > Gym_V.Value) then
				Gym_V.Value = number
			end
			
		end

		if (most_Plr) then
			Most_Time_Spent = most_Plr
		end


	end
end

local function Disconnect_PlrCons(PlayerName)
	if not Cons[PlayerName] then return end

	if Cons[PlayerName].Connection then
		task.cancel(Cons[PlayerName].Connection)
	end

	if Cons[PlayerName].Event then
		Cons[PlayerName].Event:Disconnect()
	end
	
	--if Cons[PlayerName].Trigger then
	--	Cons[PlayerName].Trigger:Disconnect()
	--end 

	Cons[PlayerName] = nil
end

--// setup tracking time spent on machine
--// Have a 0.1% chance that the Player can earn +1 Diamond / Gem instead of Cash after each Rep
--// Reward the Player with occasional Cash during/after Reps

--// treadmill : every 30 seconds, do +1 Rep 
local function Weld_Model_Parts(model: Model)
	for _, part in pairs(model:GetDescendants()) do
		if (model.PrimaryPart ~= nil) then
			if (part:IsA("BasePart") and part ~= model.PrimaryPart) then
				local weld = Instance.new("WeldConstraint")
				weld.Part0 = model.PrimaryPart
				weld.Part1 = part
				weld.Parent = model.PrimaryPart
			end
		end
	end
end

local function Weld_Obj(Plr : Player, GymObj : Instance) -- if gym obj has weight then this will weld it to the player
	if (Plr ~= nil and GymObj ~= nil) then
		local char = Plr.Character
		if not char then return end

		local hand = char:FindFirstChild("RightHand")
		if not hand then return end

		local torso = char:FindFirstChild("HumanoidRootPart")
		if not torso then return end

		if (GymObj.Name == "Barbell") then
			local barbell = GymObj:Clone()
			barbell.Name = "GymObj"
			barbell.Parent = workspace[Plr.Name]

			if not barbell.PrimaryPart then
				if barbell:FindFirstChild("BarbellRod") then
					barbell.PrimaryPart = barbell.BarbellRod
				end
			end

			Weld_Model_Parts(barbell)

			for _, part in ipairs(barbell:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Anchored = false
					part.Massless = true
					part.Transparency = 0
				end
			end

			for _, part in ipairs(GymObj:GetChildren()) do
				if part:IsA("BasePart") then
					part.Transparency = 1
				end
			end

			barbell.PrimaryPart:SetNetworkOwner(Plr)

			local handAttachment = hand:FindFirstChild("BarbellAttachment") or Instance.new("Attachment")
			handAttachment.Name = "BarbellAttachment"
			handAttachment.Parent = hand
			--handAttachment.Position = Vector3.new(0, 0, 0) ---0.3, 1.3

			local barbellAttachment = Instance.new("Attachment")
			barbellAttachment.Name = "HandleAttachment"
			barbellAttachment.Parent = barbell.PrimaryPart

			local alignPos = Instance.new("AlignPosition")
			alignPos.Attachment0 = barbellAttachment
			alignPos.Attachment1 = handAttachment
			alignPos.RigidityEnabled = true
			alignPos.ReactionForceEnabled = false
			alignPos.MaxForce = math.huge
			alignPos.Responsiveness = 200
			alignPos.Parent = barbell.PrimaryPart

			local alignOri = Instance.new("AlignOrientation")
			alignOri.Attachment0 = barbellAttachment
			alignOri.Attachment1 = handAttachment
			alignOri.RigidityEnabled = true
			alignOri.ReactionTorqueEnabled = false 
			alignOri.MaxTorque = math.huge
			alignOri.Responsiveness = 200
			alignOri.Mode = Enum.OrientationAlignmentMode.OneAttachment
			alignOri.Parent = barbell.PrimaryPart

			alignOri.CFrame = CFrame.Angles(0, math.rad(90), 0) 

			if (GymObj.Parent.Name == "BenchPress") then
				barbellAttachment.CFrame = CFrame.new(0, -0.3, 1.4)
			elseif (GymObj.Parent.Name == "BenchPress2") then
				barbellAttachment.CFrame = CFrame.new(0, -0.3, -1.4)
			elseif (GymObj.Parent.Name == "SquatRack") then
				barbellAttachment.CFrame = CFrame.new(0, -0.3, -1.8)
			end

			--[[
			barbell:PivotTo(hand.CFrame * CFrame.new(0, -1, 1.5))


			barbell:PivotTo(hand.CFrame  * CFrame.new(-1.5, -0.5, 0)) --* CFrame.Angles(0, math.rad(90), 0)

			local weld = Instance.new("WeldConstraint")
			weld.Name = "BarbellWeld"
			weld.Part0 = hand
			weld.Part1 = barbell.PrimaryPart
			weld.Parent = barbell.PrimaryPart

			barbell.PrimaryPart.CFrame = hand.CFrame  * CFrame.new(-1.5, -0.5, 0) --* CFrame.Angles(0, math.rad(90), 0)
			
			]]--

		elseif (GymObj.Name == "Dumbells") then

			local LDumbell = GymObj:FindFirstChild("Dumbell"):Clone()
			LDumbell.Name = "LDumbell"
			LDumbell.Parent = workspace[Plr.Name]
			LDumbell.Anchored = false
			LDumbell.Massless = true
			LDumbell.Transparency = 0

			local RDumbell = GymObj:FindFirstChild("Dumbell"):Clone()
			RDumbell.Name = "RDumbell"
			RDumbell.Parent = workspace[Plr.Name]
			RDumbell.Anchored = false
			RDumbell.Massless = true
			RDumbell.Transparency = 0

			--for _, part in ipairs(GymObj:GetChildren()) do
			--	if part:IsA("BasePart") then
			--		part.Transparency = 1
			--	end
			--end

			LDumbell:SetNetworkOwner(Plr)
			RDumbell:SetNetworkOwner(Plr)

			RDumbell:PivotTo(char:FindFirstChild("RightHand").CFrame  * CFrame.new(0, -0.35, 0)) -- * CFrame.new(-1.5, -0.5, 0) * CFrame.Angles(0, math.rad(90), 0)
			LDumbell:PivotTo(char:FindFirstChild("LeftHand").CFrame  * CFrame.new(0, -0.35, 0))

			local weld = Instance.new("WeldConstraint")
			weld.Name = "DumbellWeld"
			weld.Part0 = char:FindFirstChild("RightHand")
			weld.Part1 = RDumbell
			weld.Parent = RDumbell

			local weld2 = Instance.new("WeldConstraint")
			weld2.Name = "DumbellWeld"
			weld2.Part0 = char:FindFirstChild("LeftHand")
			weld2.Part1 = LDumbell
			weld2.Parent = LDumbell

			--RDumbell.CFrame = char:FindFirstChild("RightHand").CFrame  * CFrame.new(0, 2, 0) --* CFrame.Angles(0, math.rad(90), 0)
			--LDumbell.CFrame = char:FindFirstChild("LeftHand").CFrame  * CFrame.new(0, 2, 0)

		end
	end
end

local function Detach_Obj(Plr: Player, Machine : Instance)
	if (Plr ~= nil and Machine ~= nil) then
		if (Plr.Character:FindFirstChild("GymObj")) then

			Plr.Character:FindFirstChild("GymObj"):Destroy()

			if (Machine:FindFirstChild("Barbell") ~= nil) then
				for _, part in pairs(Machine:FindFirstChild("Barbell"):GetChildren()) do
					if part:IsA("BasePart") then
						part.Transparency = 0
					end
				end
			end

		elseif (Plr.Character:FindFirstChild("LDumbell")) then
			Plr.Character:FindFirstChild("LDumbell"):Destroy()
			Plr.Character:FindFirstChild("RDumbell"):Destroy()

			if (Machine:FindFirstChild("Dumbells") ~= nil) then
				for _, part in pairs(Machine:FindFirstChild("Dumbells"):GetChildren()) do
					if part:IsA("BasePart") then
						part.Transparency = 0
					end
				end
			end

		end
		--if (Machine and Machine:FindFirstChild(Plr.Name) ~= nil) then


		--end
	end
end

local function Reward_Player(player : Player)
	local randomRoll = math.random(1, 100) 
	if randomRoll == 1 then -- 1% chance
		print(player.Name .. " earned 5 GEMS!")
		local Gem_Val = Get_Player_Val(player, "Gems")
		if(Gem_Val ~= nil)then
			Gem_Val.Value += 5
		end
	else
		print(player.Name .. " earned some cash.")
		local Cash_Val = Get_Player_Val(player, "Coins")
		if(Cash_Val ~= nil)then
			Cash_Val.Value += 1
		end
	end
end

local function Update_Stats(Plr : Player, bool : boolean, Object : Instance)
	--// update the stats on the ui and training
	if (Plr ~= nil and Plr.Character ~= nil) then

		local IsTraining, Machine = Check_Training(Plr)
		if (IsTraining == true and bool == true) then
			if (Plr.Character:FindFirstChild("HumanoidRootPart"):FindFirstChild("Training_Stats_UI") == nil) then
				--// start training
				local UI = script:WaitForChild("Training_Stats_UI"):Clone()
				UI.Parent = Plr.Character:FindFirstChild("HumanoidRootPart")
				UI.Adornee = Plr.Character:FindFirstChild("HumanoidRootPart")
				UI.Enabled = true

				if (Most_Time_Spent == Plr.Name and Server_Plr_Times[Plr.Name] ~= nil) then
					UI.Main_F.Longest_Trainer_F.Data_Txt.Text = string.format("%02i:%02i", Server_Plr_Times[Plr.Name]/60, Server_Plr_Times[Plr.Name]%60)
					UI.Main_F.Longest_Trainer_F.Visible = true
				end

				if (Object ~= nil and Object.Name == "Treadmill") then
					Cons[Plr.Name] = {}

					Cons[Plr.Name].Connection = task.spawn(function()
						Player_Times[Plr.Name] = 0
						local current_Time = 0
						local Countdown = 31
						local machine_stats = Machine.Stats

						--// time
						while task.wait(1) do

							--local Check_Training, Machine_Obj = Check_Training(Plr)
							--if not Check_Training then break end
							if not Cons[Plr.Name] then break end
							
							if Plr:FindFirstChild("Player_Data") then
								if Plr.Player_Data:FindFirstChild("Gym Training") then
									Plr.Player_Data["Gym Training"].Value += 1
								end
							end

							Countdown -= 1
							current_Time += 1
							Player_Times[Plr.Name] += 1
							UI.Main_F.Countdown_Timer_F.Data_Txt.Text = tostring(Countdown).."s"
							UI.Main_F.Current_Timer_F.Data_Txt.Text = string.format("%02i:%02i", machine_stats.Time_Spent.Value/60, machine_stats.Time_Spent.Value%60)
							machine_stats.Time_Spent.Value = Player_Times[Plr.Name]

							if current_Time >= 30 then -- every 30 seconds rep time for treadmil
								current_Time = 0

								if Machine and Machine:FindFirstChild("Stats") then
									machine_stats.Reps.Value += 1
									UI.Main_F.Rep_Counter_F.Data_Txt.Text = tostring(machine_stats.Reps.Value).." Reps"
								end

							end

							if (Countdown <= 0) then
								--// reward player cash or gems etc.. 
								--// reward player reward
								Reward_Player(Plr)
								Countdown = 31 -- default
							end 


						end
						--// countdown for next reward

						--// reward player cash or gems etc.. 
						--local rand = math.random()
						--if rand < 0.001 then -- 0.1% chance for gem

						--end



					end)


				elseif (Object ~= nil and Machine:FindFirstChild("Stats") ~= nil) then --and Object.Name == "BenchPress" or Object.Name == "SquatRack"

					local machine_stats = Machine.Stats

					if (Object:FindFirstChild("Barbell") ~= nil) then
						Weld_Obj(Plr, Object:FindFirstChild("Barbell"))
					elseif (Object:FindFirstChild("Dumbells") ~= nil) then
						Weld_Obj(Plr, Object:FindFirstChild("Dumbells"))
					end

					Cons[Plr.Name] = {}

					Cons[Plr.Name].Connection = task.spawn(function()
						Player_Times[Plr.Name] = 0
						local current_Time = 0
						local Countdown = 31

						--// time
						while task.wait(1) do

							--local Check_Training, Machine_Obj = Check_Training(Plr)
							--if not Check_Training then break end
							if not Cons[Plr.Name] then break end

							if not UI then break end
							
							if Plr:FindFirstChild("Player_Data") then
								if Plr.Player_Data:FindFirstChild("Gym Training") then
									Plr.Player_Data["Gym Training"].Value += 1
								end
							end

							Countdown -= 1
							current_Time += 1
							Player_Times[Plr.Name] += 1
							UI.Main_F.Countdown_Timer_F.Data_Txt.Text = tostring(Countdown).."s"
							UI.Main_F.Current_Timer_F.Data_Txt.Text = string.format("%02i:%02i", machine_stats.Time_Spent.Value/60, machine_stats.Time_Spent.Value%60)
							machine_stats.Time_Spent.Value = Player_Times[Plr.Name]

							if current_Time >= 30 then -- every 30 seconds rep time for treadmil
								current_Time = 0
							end

							if (Countdown <= 0) then
								Reward_Player(Plr)
								Countdown = 31 -- default
							end 

						end

					end)

					if (Machine.Name ~= "Pusher") then
						Cons[Plr.Name].Event = Receiving_Events:WaitForChild("Workout_Rep").OnServerEvent:Connect(function(player)
							if (player.Name == Plr.Name) then
								local now = tick()
								if last_RepTime[player.Name] and now - last_RepTime[player.Name] < 1 then
									return
								end

								last_RepTime[player.Name] = now
								--// plus 1 rep 
								if Machine and Machine:FindFirstChild("Stats") then
									machine_stats.Reps.Value += 1
									UI.Main_F.Rep_Counter_F.Data_Txt.Text = tostring(machine_stats.Reps.Value).." Reps"
								end

							end
						end)
					elseif (Machine.Name == "Pusher") then
						local initialMachineCFrame = Machine:FindFirstChild("Push").PrimaryPart.CFrame
						local initialPlayerCFrame = Plr.Character.HumanoidRootPart.CFrame
						local PushMachine = Machine:FindFirstChild("Push")
						
						Cons[Plr.Name].Event = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
							if (Plr.Character:FindFirstChild("Humanoid") ~= nil) then
								
								local distance = (Machine:FindFirstChild("End_HitBox").Position - Plr.Character.HumanoidRootPart.Position).Magnitude
								
								local direction = PushMachine.PrimaryPart.CFrame.LookVector
								PushMachine:PivotTo(PushMachine.PrimaryPart.CFrame + direction * 2 * deltaTime)

								local offset = -PushMachine.PrimaryPart.CFrame.LookVector * 3.5
								Plr.Character.HumanoidRootPart.CFrame = PushMachine.PrimaryPart.CFrame * CFrame.new(offset.X, 1.1, offset.Z)
								
								if distance < 4 then
									-- Reset Pusher
									Machine:FindFirstChild("Push"):PivotTo(initialMachineCFrame)
									Plr.Character.HumanoidRootPart.CFrame = initialPlayerCFrame

									if Machine and Machine:FindFirstChild("Stats") then
										machine_stats.Reps.Value += 1
										UI.Main_F.Rep_Counter_F.Data_Txt.Text = tostring(machine_stats.Reps.Value).." Reps"
									end
								end
								
							end
							task.wait(0.1)
						end)
						
					end


				end
			end
		elseif (IsTraining == true and bool == false) then-- end training reset everything finished training

			if (Plr.Character:FindFirstChild("HumanoidRootPart"):FindFirstChild("Training_Stats_UI")) then
				Plr.Character:FindFirstChild("HumanoidRootPart"):FindFirstChild("Training_Stats_UI"):Destroy()
			end

			for _, machine in pairs(workspace.Main_World_F.ScriptableObjects.GymObjects:GetChildren()) do
				if (machine ~= nil and machine:FindFirstChild("Stats")) then
					if (machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == Plr.Name) then
						machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value = ""
						machine:FindFirstChild("Stats"):FindFirstChild("Reps").Value = 0
						machine:FindFirstChild("Stats"):FindFirstChild("Time_Spent").Value = 0
						break
					end
				end
			end

			if (Machine:FindFirstChild("Barbell") ~= nil or Machine:FindFirstChild("Dumbells") ~= nil) then
				Detach_Obj(Plr, Machine)
			end
			
			if (Machine.Name == "Pusher") then
				Machine:FindFirstChild("Push"):PivotTo(CFrame.new(Machine:FindFirstChild("Push").PrimaryPart.CFrame.X,Machine:FindFirstChild("Push").PrimaryPart.CFrame.Y,-247.739))
			end
			
			--if (Machine.Name == "BenchPress" or Machine.Name == "SquatRack") then
			--	Detach_Obj(Plr, Machine)
			--end

			if (Prompts[Plr.Name]) then
				Prompts[Plr.Name].Enabled = true
				Prompts[Plr.Name] = nil
			end

			if (Server_Plr_Times[Plr.Name] == nil and Player_Times[Plr.Name] ~= nil) then
				Server_Plr_Times[Plr.Name] = Player_Times[Plr.Name]
			elseif (Server_Plr_Times[Plr.Name] ~= nil and Player_Times[Plr.Name] ~= nil) then
				if (Player_Times[Plr.Name] >= Server_Plr_Times[Plr.Name]) then
					Server_Plr_Times[Plr.Name] = Player_Times[Plr.Name]
				end
			end

			if (last_RepTime[Plr.Name] ~= nil) then
				last_RepTime[Plr.Name] = nil
			end

			if (Cons[Plr.Name]) then
				Disconnect_PlrCons(Plr.Name)
			end
		end

	end
	task.wait()
end

--// setup all the proximity prompts and triggering the basic stuff
local function Setup_Gym() -- dumbells, gymfloormat, treadmill, benchpress, pusher, squatrack
	local Machines = workspace.Main_World_F.ScriptableObjects.GymObjects:GetChildren()

	for i = 1, #Machines do
		local Machine = Machines[i]
		if(Machine ~= nil and Machine:FindFirstChild("ProximityPrompt", true)) then 
			--if (Machine.Name == "Treadmill") then
			Machine:FindFirstChild("ProximityPrompt", true).Triggered:Connect(function(Plr)
				if (Prompts[Plr.Name] == nil) then
					Prompts[Plr.Name] = Machine:FindFirstChild("ProximityPrompt", true)
					Prompts[Plr.Name].Enabled = false
					if (Machine:FindFirstChild("Stats") ~= nil and Machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == "") then
						if (Plr.Character:FindFirstChild("Humanoid")) then
							local char = Plr.Character
							local hum = char:WaitForChild("Humanoid")
							Machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value = Plr.Name
							char:FindFirstChild("HumanoidRootPart"):PivotTo(Machine:FindFirstChild("Player_Pos").CFrame)
							Sending_F:WaitForChild("Init_Gym_Training"):FireClient(Plr, true)
							Update_Stats(Plr, true, Machine)
							task.wait(.3)
							char:FindFirstChild("HumanoidRootPart").Anchored = true
						end
					end
				end
			end)
			--end
		end
	end

	task.spawn(function()
		while task.wait(100) do
			Check_Most_Time()
		end
	end)

end

local function Exit_Machine(Plr : Player) -- // exit the machine and reset everything 
	task.spawn(Check_Most_Time)
	Update_Stats(Plr, false, nil)
	
	local playerCharacter = Plr.Character
	local hrp:BasePart = playerCharacter:FindFirstChild("HumanoidRootPart")
	if not hrp then
		warn("Can't get HRP for player",Plr.Name)
		return
	end
	
	if (hrp ~= nil) then
		hrp.Anchored = false
	end

	if (Cons[Plr.Name]) then
		Disconnect_PlrCons(Plr.Name)
	end

	Sending_F:WaitForChild("Init_Gym_Training"):FireClient(Plr, false)
end

Receiving_Events:WaitForChild("Exit_Machine").OnServerEvent:Connect(Exit_Machine)
Setup_Gym()

--// setup player removing and make sure everything is cleaned up and reset in-case they were using a machine and remove them from the server time table

game:GetService("Players").PlayerRemoving:Connect(function(Plr)
	if (Prompts[Plr.Name]) then
		--local Last_Used = nil

		for _, machine in pairs(workspace.Main_World_F.ScriptableObjects.GymObjects:GetChildren()) do
			if (machine ~= nil and machine:FindFirstChild("Stats")) then
				if (machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value == Plr.Name) then
					machine:FindFirstChild("Stats"):FindFirstChild("Player_Using").Value = ""
					machine:FindFirstChild("Stats"):FindFirstChild("Reps").Value = 0
					machine:FindFirstChild("Stats"):FindFirstChild("Time_Spent").Value = 0
					--Last_Used = machine
					break
				end
			end
		end

		if (Prompts[Plr.Name]) then
			Prompts[Plr.Name].Enabled = true
			Prompts[Plr.Name] = nil
		end
		
		

		if (Cons[Plr.Name]) then
			Disconnect_PlrCons(Plr.Name)
			--Last_Used = nil
		end

	end
	
	Player_Times[Plr.Name] = nil
	Server_Plr_Times[Plr.Name] = nil
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX05AEB07B9B2747BDA56B74299D495612">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Session_Reward_Handle.server.lua</string>
						<string name="ScriptGuid">{0FBD7ACA-934E-428E-AA2B-5051EBB6A7FE}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local DataMods = ReplicatedStorage:WaitForChild("Data_Mods_F")
local SessionRewardMod = require(DataMods:WaitForChild("Session_Reward_Mod"))

local Channels = ReplicatedStorage:WaitForChild("Channels_F")
local SC_Events = Channels.Server_Client_F.Events
local CS_RF = Channels.Client_Server_F.RF

local ProgressRE = SC_Events:WaitForChild("Session_Reward_Progress")
local ClaimResRE = SC_Events:WaitForChild("Session_Reward_Claim_Result")
local ClaimRF    = CS_RF:WaitForChild("Claim_Session_Reward")
local GetProgressRF = CS_RF:WaitForChild("Get_Session_Progress") --  nouveau RemoteFunction

-- UTC day key for daily reset
local function todayUTC()
	local d = os.date("!*t")
	return string.format("%04d-%02d-%02d", d.year, d.month, d.day)
end

local function getPD(plr)
	return plr:FindFirstChild("Player_Data")
end

-- Ensure flat values under Player_Data
local function ensureSR(pd)
	local day  = pd:FindFirstChild("SR_Day")  or Instance.new("StringValue")
	day.Name = "SR_Day"; if not day.Parent then day.Parent = pd end

	local cnt  = pd:FindFirstChild("SR_Count") or Instance.new("IntValue")
	cnt.Name = "SR_Count"; if not cnt.Parent then cnt.Parent = pd end

	local clm  = pd:FindFirstChild("SR_ClaimedTimes") or Instance.new("StringValue")
	clm.Name = "SR_ClaimedTimes"; if not clm.Parent then clm.Parent = pd end

	if day.Value ~= todayUTC() then
		day.Value = todayUTC()
		cnt.Value = 0
		clm.Value = ""
	end
	return day, cnt, clm
end

local function parseClaimed(csv)
	local map = {}
	if csv and csv ~= "" then
		for _, s in ipairs(string.split(csv, ",")) do
			local n = tonumber(s)
			if n then map[n] = true end
		end
	end
	return map
end

local function appendClaimed(claimedSV, tSec)
	local cur = claimedSV.Value
	if cur == "" then claimedSV.Value = tostring(tSec)
	else claimedSV.Value = cur .. "," .. tostring(tSec) end
end

-- Anti double-click per player
local ClaimLock = {}
-- Track join times for authoritative elapsed computation
local JoinTimes = {}

local function sendProgress(p)
	local pd = getPD(p)
	if pd then
		local _, cnt, clm = ensureSR(pd)
		local joinTime = JoinTimes[p.UserId] or os.time()
		local elapsed = os.time() - joinTime
		ProgressRE:FireClient(p, {
			thresholds   = SessionRewardMod.Thresholds,
			elapsed      = elapsed,
			count        = cnt.Value,
			maxClaims    = SessionRewardMod.GetMaxClaims(),
			claimedTimes = clm.Value,
		})
	end
end

Players.PlayerAdded:Connect(function(p)
	JoinTimes[p.UserId] = os.time()
	sendProgress(p)
end)

Players.PlayerRemoving:Connect(function(p)
	ClaimLock[p] = nil
	JoinTimes[p.UserId] = nil
end)

--  RemoteFunction pour rafrachissement immdiat
GetProgressRF.OnServerInvoke = function(player)
	local pd = getPD(player)
	if not pd then return nil end
	local _, cnt, clm = ensureSR(pd)
	local joinTime = JoinTimes[player.UserId] or os.time()
	local elapsed = os.time() - joinTime
	return {
		thresholds   = SessionRewardMod.Thresholds,
		elapsed      = elapsed,
		count        = cnt.Value,
		maxClaims    = SessionRewardMod.GetMaxClaims(),
		claimedTimes = clm.Value,
	}
end

ClaimRF.OnServerInvoke = function(player, thresholdTime)
	if ClaimLock[player] then
		return { ok = false, reason = "busy" }
	end
	ClaimLock[player] = true

	local ok, res = pcall(function()
		local pd = getPD(player)
		if not pd then return { ok=false, reason="no_pd" } end

		local _, cnt, clm = ensureSR(pd)
		local claimed = parseClaimed(clm.Value)

		-- Validate threshold exists
		local index
		for i, th in ipairs(SessionRewardMod.Thresholds) do
			if th.t == thresholdTime then index = i break end
		end
		if not index then return { ok=false, reason="invalid_threshold" } end

		-- Check not already claimed
		if claimed[thresholdTime] then
			return { ok=false, reason="already_claimed" }
		end

		-- Daily quota
		if cnt.Value >= SessionRewardMod.GetMaxClaims() then
			return { ok=false, reason="already_max_claims_today" }
		end

		-- Authoritative check
		local joinTime = JoinTimes[player.UserId] or os.time()
		local serverElapsed = os.time() - joinTime
		if serverElapsed < thresholdTime then
			return { ok=false, reason="not_unlocked_yet" }
		end

		-- Apply reward (Cash/Coins or Gems)
		local reward = SessionRewardMod.GetReward(index)
		if reward == nil then
			return { ok=false, reason="no_reward" }
		end

		if reward.type and reward.amount then
			local PD = player:FindFirstChild("Player_Data")
			if PD then
				if reward.type == "Cash" or reward.type == "Coins" then
					local coins = PD:FindFirstChild("Coins")
					if coins then
						coins.Value += reward.amount
					else
						warn("[SessionRewards] No Coins value found in Player_Data for", player.Name)
						return { ok=false, reason="missing_coins" }
					end
				elseif reward.type == "Gems" then
					local gems = PD:FindFirstChild("Gems")
					if gems then
						gems.Value += reward.amount
					else
						warn("[SessionRewards] No Gems value found in Player_Data for", player.Name)
						return { ok=false, reason="missing_gems" }
					end
				else
					return { ok=false, reason="invalid_reward_type" }
				end
			else
				return { ok=false, reason="no_player_data" }
			end
		else
			return { ok=false, reason="invalid_reward" }
		end


		cnt.Value += 1
		appendClaimed(clm, thresholdTime)

		-- Notify client
		ClaimResRE:FireClient(player, { ok = true, t = thresholdTime, reward = reward })
		return { ok = true, reward = reward }
	end)

	ClaimLock[player] = nil
	if not ok then
		warn("[SessionRewards] error:", res)
		return { ok=false, reason="server_error" }
	end
	return res
end

-- Broadcast progress toutes les 30s
task.spawn(function()
	while true do
		for _, p in ipairs(Players:GetPlayers()) do
			sendProgress(p)
		end
		task.wait(30)
	end
end)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX60CFDDB0B99343ACAFDD2B0E55667338">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">DS_Service</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX5920C165A5C74441B277E8CD0AB1C8C6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DS_Module.lua</string>
						<string name="ScriptGuid">{7C28F30D-AC2F-4F1A-9C03-B1D66B4DEBD9}</string>
						<ProtectedString name="Source"><![CDATA[local DataStoreService = game:GetService("DataStoreService")
local WebService = game:GetService("HttpService")
local funcs = {}

--Set up for Leaderboards pertaining to Wins and Donations!
function funcs.Save_Leaderboard(Key, DataType, Value)
	local function Attempt_To_Save()
		local success, errormessage = pcall(function()
			local ODS = DataStoreService:GetOrderedDataStore(DataType)
			ODS:SetAsync(Key, Value)
		end)
		
		if(success)then
			return true
		else
			print("Saving Error -> Key: " .. Key .. " | Data Type : " .. DataType .. " | Error Msg : "  .. errormessage)
			return false
		end
	end
	
	for i = 1, 3 do
		local Save = Attempt_To_Save()
		if(Save)then
			i = 3
			break
		end
	end
end

function funcs.Load_Leaderboard(DataType, PageSize)
	local function Get_Data()
		local Data = nil
		local success, errormessage = pcall(function()
			local ODS = DataStoreService:GetOrderedDataStore(DataType)
			Data = ODS:GetSortedAsync(false, PageSize)
		end)
		
		if(success and Data ~= nil)then
			return Data
		else
			return nil
		end
	end
	
	for i = 1, 3 do
		local Data = Get_Data()
		if(Data ~= nil)then
			return Data:GetCurrentPage()
		end
	end
	
	return nil
end

function funcs.Delete_Leaderboard(Key, DataType)
	local function Attempt_To_Delete()
		local success, errormessage = pcall(function()
			local ODS = DataStoreService:GetOrderedDataStore(DataType)
			ODS:RemoveAsync(Key)
		end)
		
		if(success)then
			return true
		else
			return false
		end
	end
	
	for i = 1, 3 do
		local Removed = Attempt_To_Delete()
		if(Removed)then
			i = 3
			break
		end
	end
end


function funcs.Load_Data(Key, DataType)
	--Get the Datastore
	--Load the Data, return it
		--If Data is blank or Errored, Load up Backup Datastore
			--If Backup Data is blank, return Blank Value
	--Else, return the Backup Data
	local function Attempt_Load()
		local Data = nil

		local success, errormessage = pcall(function()
			local DataStore = DataStoreService:GetDataStore(Key)
			Data = WebService:JSONDecode(DataStore:GetAsync(DataType))
		end)
		
		if(success and Data ~= nil)then
			return Data
		else
			print("Loading Error -> Key: " .. Key .. " | Data Type : " .. DataType .. " | Error Msg : "  .. errormessage)
		end
		
		return nil
	end
	
	local function Retrieve_From_Backup()
		local Data = nil
		local success_BACK, errormessage_BACK = pcall(function()
			local DataStore = DataStoreService:GetDataStore(Key)
			Data = WebService:JSONDecode(DataStore:GetAsync(DataType .. "_BACKUP"))
		end)
		
		if(success_BACK and Data ~= nil)then
			return Data
		else
			print("Loading Backup Error -> Key: " .. Key .. " | Data Type : " .. DataType .. "_BACKUP | Error Msg : "  .. errormessage_BACK)
		end
		
		return nil
	end
	
	--Attempt Main Load
	for i = 1, 3 do
		local D = Attempt_Load()
		if(D ~= nil)then
			return D
		end
	end
	
	--Attempt Backup Load
	--[[
	for i = 1, 3 do
		local D = Retrieve_From_Backup()
		if(D ~= nil)then
			return D
		end
	end
	]]--
	return nil
end

function funcs.Save_Data(Key, DataType, Value)
	local function Attempt_To_Save(DT)
		local success, errormessage = pcall(function()
			local DataStore = DataStoreService:GetDataStore(Key)
			DataStore:SetAsync(DT, WebService:JSONEncode(Value))
		end)
		
		if(success)then
			return true
		else
			print("Saving Error -> Key: " .. Key .. " | Data Type : " .. DataType .. " | Error Msg : "  .. errormessage)
			return false
		end
	end
	
	--Atempt to Save to Main Data
	for i = 1, 3 do
		local Saved = Attempt_To_Save(DataType)
		if(Saved)then
			i = 3
			break
		end
	end
	
	--Save to Backup!
	for i = 1, 3 do
		local Saved = Attempt_To_Save(DataType .. "_BACKUP")
		if(Saved)then
			i = 3
			break
		end
	end
end

function funcs.Delete_Data(Key, DataType)
	local function Attempt_To_Delete(DT)
		local success, errormessage = pcall(function()
			local DataStore = DataStoreService:GetDataStore(Key)
			DataStore:RemoveAsync(DT)
		end)

		if(success)then
			return true
		else
			print("Deleting Error -> Key: " .. Key .. " | Data Type : " .. DataType .. " | Error Msg : "  .. errormessage)
			return false
		end
	end
	
	for i = 1, 3 do
		local Removed = Attempt_To_Delete(DataType)
		if(Removed)then
			i = 3
			break
		end
	end

	--Store to Backup
	for i = 1, 3 do
		local Removed = Attempt_To_Delete(DataType .. "_BACKUP")
		if(Removed)then
			i = 3
			break
		end
	end
end

return funcs
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6E7D3E42FA074BC5A850517556783EC9">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DS_Handle.server.lua</string>
						<string name="ScriptGuid">{ACF06AB1-4B0C-4293-820F-828BC886B405}</string>
						<ProtectedString name="Source"><![CDATA[local MPS = game:GetService("MarketplaceService")
local DS_Mod = require(script.Parent:WaitForChild("DS_Module"))
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Monetization_Mod = require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Sending_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Receiving_F = Channels_F:WaitForChild("Client_Server_F") 
local GlobalLeaderboardsModule = require(game.ServerScriptService.GlobalLeaderBoards)

local Leaderboard_Keys = {}
local Welcome_Badge_ID = 1326039894106761
local PLAYER_DATA_KEY = "PLAYER_DATASTORE_LIVE"

-- !!! HANDLE CAREFULLY !!! for testing purpose
--local PLAYER_DATA_KEY = "PLAYER_DATASTORE_LIVE_TEST"

--[[
	Player Data Profile
	> Stored Player Data
		- Elo
		- Cash
		- Gems
		- Used Codes
		- Retention Streak (and the other Values assosiated with this)
		- Bio
		- Country
		- Skin Tone
		- Right Handed
		- Total Wins
		- Total Ties
		- Total Matches
		- Ranked Wins
		- Total Strikes
		- Dodged Strikes
		- Takedowns Landed
		- Takedowns Attempted
		- Submissions Finished
		- Submissions Attempted
		- Punch Knockout Wins
		- Leg Knockout Wins
		- Submission Wins
		
		- Power per Strike
		- Strike Defense
		- Submission Timeout
		- Submission Defense
		- Staminia
		
		- Current Shorts
		- Current Gloves
		- Inventory Shorts
		- Inventory Gloves
		- Inventory Special Strikes
		- Inventory Special Submissions
		
		- Background Music
		- Sound Effects
		- Voice Over
		- Show Fight Prompt
]]--

-- Tag for top players
local function applyTopPlayerTag(player, rank)
	
	-- FIX : NEED BETTER UI INTEGRATION BEFORE TO RELEASE
	
	--local function addTag(char)
	--	local head = char:WaitForChild("Head", 10)
	--	if not head then return end

	--	-- remove ancien tag si existant
	--	local old = head:FindFirstChild("TopTag")
	--	if old then old:Destroy() end

	--	local billboard = Instance.new("BillboardGui")
	--	billboard.Name = "TopTag"
	--	billboard.Size = UDim2.new(0, 100, 0, 30)
	--	billboard.StudsOffset = Vector3.new(0, 2, 0)
	--	billboard.AlwaysOnTop = true
	--	billboard.Parent = head

	--	local text = Instance.new("TextLabel")
	--	text.Size = UDim2.new(1, 0, 1, 0)
	--	text.BackgroundTransparency = 1
	--	text.TextColor3 = Color3.fromRGB(255, 215, 0)
	--	text.TextStrokeTransparency = 0
	--	text.Text = "[TOP #" .. rank .. "]"
	--	text.Font = Enum.Font.SourceSansBold
	--	text.TextScaled = true
	--	text.Parent = billboard
	--end

	---- connecter une seule fois
	--if not player:GetAttribute("TopTagConnected") then
	--	player:SetAttribute("TopTagConnected", true)
	--	player.CharacterAdded:Connect(addTag)
	--end

	---- appliquer directement si le personnage est dj prsent
	--if player.Character then
	--	addTag(player.Character)
	--end
end


-- Remove TopTag billboard if it exists
local function clearTopTag(player)
	if player.Character and player.Character:FindFirstChild("Head") then
		local head = player.Character.Head
		local old = head:FindFirstChild("TopTag")
		if old then old:Destroy() end
	end
end


local function Is_Premium_Member(Plr)
	if(Plr.MembershipType == Enum.MembershipType.Premium)then
		Plr:SetAttribute("Is_Premium", true)
	else
		Plr:SetAttribute("Is_Premium", false)
	end
end

local function Update_Retention_Streak(Plr)
	local Current_Time = os.time()
	local PD = Plr:WaitForChild("Player_Data")
	local Prev_Time_Val = PD:WaitForChild("Previous Session Time")
	local Streak_Val = PD:WaitForChild("Retention Streak")
	local Raw_Time_Val = PD:WaitForChild("Raw Prev Session Time")
	local Rewards_Val = PD:WaitForChild("Redeemed Rewards")

	local Dif = Current_Time - Prev_Time_Val.Value
	local Raw_Dif = Current_Time - Raw_Time_Val.Value

	local function Is_Next_Day()
		local Month_Data = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
		local Prev_Data = os.date("!*t", Prev_Time_Val.Value)
		local Prev_Month, Prev_Day = Prev_Data['month'], Prev_Data['day']
		local Current_Day = os.date("!*t", Current_Time)['day'] 

		local Next_Day_Val = Prev_Day + 1
		if(Month_Data[Prev_Month] < Next_Day_Val)then			
			Next_Day_Val = 1
		end

		if(Current_Day == Next_Day_Val or (Dif >= 86400 and Dif <= 172800))then
			return true
		end
		return false
	end

	--[[
	local function Has_Unlocked_All_Rewards()
		if(Rewards_Val ~= nil and Rewards_Val.Value ~= "")then
			local Max_Rewards_Count = Daily_Rewards_Mod.Get_Total_Reward_Amount()
			local Rewards_Keys = string.split(Rewards_Val.Value, ",")
			local Count = 0
			
			for i = 1, #Rewards_Keys do
				local K = string.gsub(Rewards_Keys[i], " ", "")
				if(K ~= nil and K ~= "")then
					Count += 1
				end
			end
			
			if(Count >= Max_Rewards_Count)then
				return true
			end
		end
		
		return false
	end
	local Has_Unlocked_All_R = Has_Unlocked_All_Rewards()
	]]--
	local Has_Unlocked_All_R = false

	if(Is_Next_Day() and Has_Unlocked_All_R == false)then
		Prev_Time_Val.Value = Current_Time
		Streak_Val.Value = Streak_Val.Value + 1
		--print("Is the next Day! Earn new Reward!")

	elseif(Dif > 172800 or Has_Unlocked_All_R == true)then

		--print("Resetting Streak!")
		Prev_Time_Val.Value = Current_Time
		Streak_Val.Value = 1
		Rewards_Val.Value = ""
	end

	Raw_Time_Val.Value = Current_Time
	Plr:SetAttribute("Join_Time", Current_Time)
end

local function Load_Player_Data(Plr)
	local Key = Plr.UserId .. "_Game_Data"
	local Default_Data = {
		--General Player Stats
		['Total Sessions'] = 0,
		['Total Playtime'] = 0,
		['Elo'] = 400,
		['Coins'] = 0,
		['Gems'] = 0,
		['Bio'] = "",
		['Country'] = "United States",
		['Skin Tone'] = "234,184,146",
		['Right Handed'] = true,
		['Creator Code'] = "",
		['Total Wins'] = 0,
		['Total Ties'] = 0,
		['Total Matches'] = 0,
		['Win Streak'] = 0,
		['Ranked Wins'] = 0,
		['Ranked Matches'] = 0,
		['Ranked Ties'] = 0,
		['Total Strikes'] = 0,
		['Strikes Landed'] = 0,
		['Dodged Strikes'] = 0,
		['Takedowns Landed'] = 0,
		['Takedowns Attempted'] = 0,
		['Submissions Finished'] = 0,
		['Submissions Attempted'] = 0,
		['Punch Knockout Wins'] = 0,
		['Leg Knockout Wins'] = 0,
		['Submissions Wins'] = 0,
		['Gym Training'] = 0,
		
		['Power per Strike'] = 2.5,
		['Strike Defense'] = 30,
		['Submission Timeout'] = 1,
		['Submission Defense'] = 1,
		['Staminia'] = 100,
		
		['Vip'] = false,
		['Cash2x'] = false,

		['StarterPackTimer'] = nil,
		['RookieTag'] = false,
		['DiscordReward'] = false,
		
		--General Player Data
		['Codes'] = {},
		['Previous Session Time'] = os.time(),
		['Retention Streak'] = 1,
		['Raw Prev Session Time'] = os.time(),
		['Redeemed Rewards'] = {},
		['Owned Gamepasses'] = {},
		['Owned Products'] = {},
		['Redeemed Skill Tree'] = {},
		-- Session Rewards (NEW SL)
		['SR_Day'] = os.date("!%Y-%m-%d"),
		['SR_Count'] = 0,
		['SR_ClaimedTimes'] = "",
		
		--Player Inventory Data
		['Current Shorts'] = "A",
		['Current Gloves'] = "A",
		['Current Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Owned Shorts'] = {"A"},
		['Owned Gloves'] = {"A"},
		['Owned Special Strikes'] = {},
		['Owned Special Submissions'] = {},
		['Owned Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Strike Combo 1'] = {"C", "A", "B"},
		['Strike Combo 2'] = {"F", "D", "E"},
		['Strike Combo 3'] = {"G", "L", "M"},
		['Strike Combo 4'] = {"F", "J", "H"},
		['Takedown Key'] = "A",
		['Submission Key'] = "A",
		
		--Player Settings
		['Background Music'] = true,
		['Sound Effects'] = true,
		['Voice Over'] = true,
		['Fight Prompts'] = true,
		['Trading'] = true

	}
	local Plr_Data = DS_Mod.Load_Data(Key,PLAYER_DATA_KEY)
	if Plr_Data == nil then
		Plr_Data = Default_Data
		GlobalLeaderboardsModule:RegisterNationElo(Plr_Data.Country, Plr_Data.Elo)
	end
	if Plr_Data.StarterPackTimer == nil then
		Plr_Data.StarterPackTimer = os.time() + 24 * 60 * 60
	end
	if Plr_Data.RookieTag == true then
		Plr:SetAttribute("Rookie", true)
	else
		Plr:SetAttribute("Rookie", false)
	end

	--if Plr.Name == "HoltSvardo" then Plr_Data = Default_Data end --Clears the Data for a specific User

	local PD = Instance.new("Folder", Plr)
	PD.Name = "Player_Data"

	-----------------------------------

	local function Get_Object_Type(Data)
		local Data_Type = {
			['string'] = "StringValue",
			['table'] = "StringValue",
			['number'] = "NumberValue",
			['boolean'] = "BoolValue"
		}

		local Key = typeof(Data)
		return Data_Type[Key]
	end

	for Data_Key, Data_Val in next, Plr_Data do
		local Obj_Type = Get_Object_Type(Data_Val)
		local V = Instance.new(Obj_Type, PD)
		V.Name = Data_Key

		if(typeof(Data_Val) == "table")then
			V.Value = table.concat(Data_Val, ",")
		else
			V.Value = Data_Val
		end
	end

	for Data_Key, Data_Val in next, Default_Data do
		if not PD:FindFirstChild(Data_Key) then
			local Obj_Type = Get_Object_Type(Data_Val)
			local V = Instance.new(Obj_Type, PD)
			V.Name = Data_Key

			if(typeof(Data_Val) == "table")then
				V.Value = table.concat(Data_Val, ",")
			else
				V.Value = Data_Val
			end
		end
	end
	
	local function Increment_Session_Count()
		local Val = PD:FindFirstChild("Total Sessions")
		if(Val ~= nil)then
			Val.Value += 1
		end
	end
	Increment_Session_Count()
	
	PD:WaitForChild("RookieTag").Changed:Connect(function()
		if PD.RookieTag.Value == true then
			Plr:SetAttribute("Rookie", true)
		end
	end)

	local lastCountry = PD:WaitForChild("Country").Value
	PD:WaitForChild("Country").Changed:Connect(function()
		local newElo = PD:WaitForChild("Elo").Value
		local newCountry = PD:WaitForChild("Country").Value

		GlobalLeaderboardsModule:RegisterNationElo(lastCountry, -newElo)
		GlobalLeaderboardsModule:RegisterNationElo(newCountry, newElo)
		
		lastCountry = newCountry
	end)
	
	local lastElo = PD:WaitForChild("Elo").Value
	PD:WaitForChild("Elo").Changed:Connect(function()
		local newElo = PD:WaitForChild("Elo").Value
		
		GlobalLeaderboardsModule:RegisterNationElo(PD.Country.Value, newElo - lastElo)
		
		lastElo = newElo
	end)
end

local function Fight_Data_Non_Saveable(Plr)
	local Fight_Data_F = Instance.new("Folder", Plr)
	Fight_Data_F.Name = "Fight_Data"
	
	local Health_V = Instance.new("IntValue", Fight_Data_F)
	Health_V.Name = "Health"
	Health_V.Value = 100
	
	local Stam_V = Instance.new("IntValue", Fight_Data_F)
	Stam_V.Name = "Staminia"
	Stam_V.Value = 100
	Stam_V:SetAttribute("Is_Dodging", false)
	
	local Strike_Power_V = Instance.new("NumberValue", Fight_Data_F)
	Strike_Power_V.Name = "Strike Power"
	Strike_Power_V.Value = 6
	
	local Block_Power_V = Instance.new("IntValue", Fight_Data_F)
	Block_Power_V.Name = "Block Power"
	Block_Power_V.Value = 30
	Block_Power_V:SetAttribute("Is_Blocking", false)
end

local function Update_Player_Friend_Boosts()
	local All_Plrs = game.Players:GetPlayers()

	local function Get_Friends_Count(P)
		local function Is_Friends_Async(Other_Plr)
			local function Async()
				local Data = nil
				local success, errormessage = pcall(function()
					Data = P:IsFriendsWith(Other_Plr.UserId)
				end)

				if(success and Data ~= nil)then
					return Data
				end
				return nil
			end

			for i = 1, 3 do
				local D = Async()
				if(D ~= nil)then
					return D
				end
			end
			return false
		end

		local Count = 0

		for i = 1, #All_Plrs do
			if(All_Plrs[i] ~= nil and All_Plrs[i] ~= P and Is_Friends_Async(All_Plrs[i]))then
				Count = Count + 1
			end
		end

		return Count
	end

	for i = 1, #All_Plrs do
		local Plr = All_Plrs[i]
		if(Plr ~= nil)then
			Plr:SetAttribute("Friends_Count", Get_Friends_Count(Plr))
		end
	end
end


local function Init_Gamepass_Data(Plr)
	local Gamepass_Val = Plr:WaitForChild("Player_Data"):WaitForChild("Owned Gamepasses")
	local Gamepass_Data = Monetization_Mod.Get_All_Gamepass_Data()
	local Owned_Keys = Monetization_Mod.Get_Player_Owned_Gamepasses_Keys(Plr)

	for GP_Key, GP_Data in next, Gamepass_Data do
		if(table.find(Owned_Keys, GP_Key) == nil and Monetization_Mod.Hard_Gamepass_Check(Plr, GP_Data['ID']))then
			table.insert(Owned_Keys, GP_Key)
		end
	end
	Gamepass_Val.Value = table.concat(Owned_Keys, ",")
end
--[[

local function Give_Weekend_Boost(Plr)
	--Gives x2 Power if you play on the Weekend!
	local Plr_Boost_F = Plr:WaitForChild("Current_Boosts")
	local V = Instance.new("NumberValue", script)
	V.Name = "D"
	V.Value = 86400
	V:SetAttribute("Is_Timed", true)
	V.Parent = Plr_Boost_F

	local Txt = " You're Earning x2 Cash for playing on the Weekend!"
	Sending_Events_F:WaitForChild("Display_Data"):FireClient(Plr, Txt, Color3.fromRGB(255, 170, 0))
end

]]--

game.Players.PlayerAdded:Connect(function(Plr)
	Load_Player_Data(Plr)
	Fight_Data_Non_Saveable(Plr)
	
	--Set up Attributes
	local In_Group = Bindable_RF:WaitForChild("Player_In_Group"):Invoke(Plr)
	Is_Premium_Member(Plr)
	Update_Player_Friend_Boosts()

	local Owns_Welcome = Bindable_RF:WaitForChild("Player_Owns_Badge"):Invoke(Plr, Welcome_Badge_ID)
	Plr:SetAttribute("First_Time_Player", not Owns_Welcome)
	--Give Welcome Badge
	if(Owns_Welcome == false)then
		Bindable_Events_F:WaitForChild("Award_Badge"):Fire(Plr, Welcome_Badge_ID)
	end
	
	Update_Retention_Streak(Plr)
	
	--INIT MONETIZATION HANDLE TO GIVE PLAYERS THE GAMEPASSES THEY INITIALLY BOUGHT FROM WEBSITE
	Init_Gamepass_Data(Plr)
	local Is_VIP = Monetization_Mod.Does_Player_Own_Gamepass_Key(Plr, "A")
	Plr:SetAttribute("Is_VIP", Is_VIP)
	
	if Plr.Player_Data.Vip.Value == true then
		Plr:SetAttribute("Is_VIP", true)
	end

	if Plr:GetAttribute("Is_VIP") then
		local Txt = "A VIP Player has Joined! Welcome back " .. Plr.Name .. "!"
		Sending_Events_F:WaitForChild("Server_Chat"):FireAllClients(Txt, Color3.fromRGB(255, 170, 0))
	end

	Bindable_Events_F:WaitForChild("Player_Leaderboard_Data"):Fire(Plr)
	Bindable_Events_F:WaitForChild("Update_Server_Data"):Fire()
	
	Sending_Events_F:WaitForChild("Update_Player_List"):FireAllClients(Plr, true)
	
	
	-- Add tag if player is among top3 players
	--local rank = GlobalLeaderboardsModule.TopPlayers[Plr.UserId]
	--if rank then
	--	applyTopPlayerTag(Plr, rank)
	--else	
	--	clearTopTag(Plr)
	--end
	
end)

game.Players.PlayerMembershipChanged:Connect(function(Plr)
	if(Plr.MembershipType == Enum.MembershipType.Premium)then
		Plr:SetAttribute("Is_Premium", true)
	end
end)

local function Save_Player_Data(Plr)
	local Plr_Key = Plr.UserId .. "_Game_Data"
	local PD_Vals = Plr:FindFirstChild("Player_Data"):GetChildren()
	local Current_Player_Data = {
		--General Player Stats
		['Total Sessions'] = 0,
		['Total Playtime'] = 0,
		['Elo'] = 400,
		['Coins'] = 0,
		['Gems'] = 0,
		['Bio'] = "",
		['Country'] = "United States",
		['Skin Tone'] = "234,184,146",
		['Right Handed'] = true,
		['Creator Code'] = "",
		['Win Streak'] = 0,
		['Total Wins'] = 0,
		['Total Ties'] = 0,
		['Total Matches'] = 0,
		['Ranked Wins'] = 0,
		['Ranked Matches'] = 0,
		['Ranked Ties'] = 0,
		['Total Strikes'] = 0,
		['Strikes Landed'] = 0,
		['Dodged Strikes'] = 0,
		['Takedowns Landed'] = 0,
		['Takedowns Attempted'] = 0,
		['Submissions Finished'] = 0,
		['Submissions Attempted'] = 0,
		['Punch Knockout Wins'] = 0,
		['Leg Knockout Wins'] = 0,
		['Submissions Wins'] = 0,
		['Gym Training'] = 0,

		['Power per Strike'] = 2.5,
		['Strike Defense'] = 30,
		['Submission Timeout'] = 1,
		['Submission Defense'] = 1,
		['Staminia'] = 100,

		['StarterPackTimer'] = nil,
		['DiscordReward'] = false,

		--General Player Data
		['Codes'] = {},
		['Previous Session Time'] = os.time(),
		['Retention Streak'] = 1,
		['Raw Prev Session Time'] = os.time(),
		['Redeemed Rewards'] = {},
		['Owned Gamepasses'] = {},
		['Owned Products'] = {},
		['Redeemed Skill Tree'] = {},
		
		-- Session Rewards (NEW SL)
		['SR_Day'] = os.date("!%Y-%m-%d"),
		['SR_Count'] = 0,
		['SR_ClaimedTimes'] = "",
		
		--Player Inventory Data
		['Current Shorts'] = "A",
		['Current Gloves'] = "A",
		['Current Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Owned Shorts'] = {"A"},
		['Owned Gloves'] = {"A"},
		['Owned Special Strikes'] = {},
		['Owned Special Submissions'] = {},
		['Owned Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Strike Combo 1'] = {"C", "A", "B"},
		['Strike Combo 2'] = {"F", "D", "E"},
		['Strike Combo 3'] = {"G", "L", "M"},
		['Strike Combo 4'] = {"F", "J", "H"},
		['Takedown Key'] = "A",
		['Submission Key'] = "A",

		--Player Settings
		['Background Music'] = true,
		['Sound Effects'] = true,
		['Voice Over'] = true,
		['Fight Prompts'] = true,
		['Trading'] = true,

	}

	for i = 1, #PD_Vals do
		local Key, Data = PD_Vals[i].Name, PD_Vals[i].Value
		if(typeof(Current_Player_Data[Key]) == "table")then
			Current_Player_Data[Key] = string.split(Data, ",")
		else
			Current_Player_Data[Key] = Data
		end

		--Leaderboard Data
		if(table.find(Leaderboard_Keys, Key) ~= nil)then
			DS_Mod.Save_Leaderboard(Plr_Key, Key, Data)
		end
	end

	--local Leaderboard_Data = Compile_Leaderboard_Data_RF:Invoke(Plr, Current_Player_Data)

	DS_Mod.Save_Data(Plr_Key, PLAYER_DATA_KEY, Current_Player_Data)
	--Save_Leaderboard_Data_E:Fire(Plr_Key, Leaderboard_Data)
end

local function Reset_Coolhockeydawg_Data()
	local ID = 5617581305
	local Plr_Key = ID .. "_Game_Data"
	local Current_Player_Data = {
		--General Player Stats
		['Total Sessions'] = 0,
		['Total Playtime'] = 0,
		['Elo'] = 400,
		['Coins'] = 0,
		['Gems'] = 0,
		['Bio'] = "",
		['Country'] = "United States",
		['Skin Tone'] = "234,184,146",
		['Right Handed'] = true,
		['Creator Code'] = "",
		['Win Streak'] = 0,
		['Total Wins'] = 0,
		['Total Ties'] = 0,
		['Total Matches'] = 0,
		['Ranked Wins'] = 0,
		['Ranked Matches'] = 0,
		['Ranked Ties'] = 0,
		['Total Strikes'] = 0,
		['Strikes Landed'] = 0,
		['Dodged Strikes'] = 0,
		['Takedowns Landed'] = 0,
		['Takedowns Attempted'] = 0,
		['Submissions Finished'] = 0,
		['Submissions Attempted'] = 0,
		['Punch Knockout Wins'] = 0,
		['Leg Knockout Wins'] = 0,
		['Submissions Wins'] = 0,
		['Gym Training'] = 0,

		['Power per Strike'] = 2.5,
		['Strike Defense'] = 30,
		['Submission Timeout'] = 1,
		['Submission Defense'] = 1,
		['Staminia'] = 100,

		['StarterPackTimer'] = nil,
		['DiscordReward'] = false,


		--General Player Data
		['Codes'] = {},
		['Previous Session Time'] = os.time(),
		['Retention Streak'] = 1,
		['Raw Prev Session Time'] = os.time(),
		['Redeemed Rewards'] = {},
		['Owned Gamepasses'] = {},
		['Owned Products'] = {},
		['Redeemed Skill Tree'] = {},
		['SR_Day'] = os.date("!%Y-%m-%d"),
		['SR_Count'] = 0,
		['SR_ClaimedTimes'] = "",

		--Player Inventory Data
		['Current Shorts'] = "A",
		['Current Gloves'] = "A",
		['Current Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Owned Shorts'] = {"A"},
		['Owned Gloves'] = {"A"},
		['Owned Special Strikes'] = {},
		['Owned Special Submissions'] = {},
		['Owned Emotes'] = {"A","B","C","D","E","F","G","H"},
		['Strike Combo 1'] = {"C", "A", "B"},
		['Strike Combo 2'] = {"F", "D", "E"},
		['Strike Combo 3'] = {"G", "L", "M"},
		['Strike Combo 4'] = {"F", "J", "H"},
		['Takedown Key'] = "A",
		['Submission Key'] = "A",

		--Player Settings
		['Background Music'] = true,
		['Sound Effects'] = true,
		['Voice Over'] = true,
		['Fight Prompts'] = true,
		['Trading'] = true,

	}

	DS_Mod.Save_Data(Plr_Key, PLAYER_DATA_KEY, Current_Player_Data)
end

local function Update_Player_Data_Val(P_ID, Key, New_Data)
	local DS_Mod = require(game.ServerScriptService.DS_Service.DS_Module)
	local Plr_Key = P_ID .. "_Game_Data"
	local P_Data = DS_Mod.Load_Data(Plr_Key, PLAYER_DATA_KEY)
	if(P_Data[Key] ~= nil)then
		P_Data[Key] = New_Data
	end
	
	DS_Mod.Save_Data(Plr_Key, PLAYER_DATA_KEY, P_Data)
	print("Successfully Updated Player Data Value: " .. Key)
end


Receiving_F.Events.Set_Creator_Reward_Code.OnServerEvent:Connect(function(plr, newCodeIndex)
	local plrData = plr:FindFirstChild("Player_Data")
	if plrData == nil then
		return
	end
	
	local creatorCode = plrData:FindFirstChild("Creator Code")
	if creatorCode == nil then
		return
	end
	
	local codes = require(game.ReplicatedStorage.CreatorCodes)
	if codes[newCodeIndex] == nil then
		creatorCode.Value = ""
	else
		creatorCode.Value = newCodeIndex
	end
end)

game.Players.PlayerRemoving:Connect(function(Plr)
	task.defer(function()
		Save_Player_Data(Plr)

		Update_Player_Friend_Boosts()
		Bindable_Events_F:WaitForChild("Update_Server_Data"):Fire()
		Sending_Events_F:WaitForChild("Update_Player_List"):FireAllClients(Plr, false)
	end)
end)


--local RemoteEvents_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
--local Top3_Players_Updated = RemoteEvents_F:WaitForChild("Top3_Players_Updated")

--Top3_Players_Updated.Event:Connect(function(newTop, oldTop)
--	for _, player in ipairs(game.Players:GetPlayers()) do
--		local newRank = newTop[player.UserId]
--		local oldRank = oldTop[player.UserId]

--		if newRank ~= oldRank then
--			-- clear ancien tag
--			clearTopTag(player)

--			-- appliquer le nouveau si le joueur est encore dans le top
--			if newRank then
--				applyTopPlayerTag(player, newRank)
--			end
--		end
--	end
--end)


game:BindToClose(function()
	if(game:GetService("RunService"):IsStudio())then
		return
	end	

	local Plrs = game.Players:GetPlayers()
	for i = 1, #Plrs do
		if(Plrs[i] ~= nil)then
			Save_Player_Data(Plrs[i])
		end
	end
end)

while task.wait(15) do
	local playerList = game:GetService("Players"):GetPlayers()
	for _, Plr in pairs(playerList) do
		local success, err = pcall(function()
			Save_Player_Data(Plr)
		end)
		
		print(`Auto-saving for player {Plr} was ${success and "successful" or "errored"}`)
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXF3D5E8DBD75C4324A67078D14DF08422">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ServerStorage</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXCCC80E8CA3D4418BA7AB2FFBF4BD1C03">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Unique_Codes_Rewards</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX75CC48FD38A84995B61336E9E0244ECE">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">2xCash.lua</string>
						<string name="ScriptGuid">{890D8A6F-C428-479F-9E01-0E3DD82D940B}</string>
						<ProtectedString name="Source"><![CDATA[return function(player)
	local playerData = player:FindFirstChild("Player_Data")

	if playerData then
		playerData.Cash2x.Value = true
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0576C1CFBE9149169FB57FA14C89209A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">HugeMoneyPack.lua</string>
						<string name="ScriptGuid">{4E0400D5-1841-4A26-9326-56B5FE900298}</string>
						<ProtectedString name="Source"><![CDATA[return function(player)
	local playerData = player:FindFirstChild("Player_Data")

	if playerData then
		playerData.Coins.Value += 3000
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0025DBA5D40C4F048AFD31621E840DCB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LargediamondsPack.lua</string>
						<string name="ScriptGuid">{3ED40420-4FEF-4575-8340-99BED801C295}</string>
						<ProtectedString name="Source"><![CDATA[return function(player)
	local playerData = player:FindFirstChild("Player_Data")

	if playerData then
		playerData.Gems.Value += 500
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1D9B4B9D9180436489D80169D5FC3C3D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">VIP.lua</string>
						<string name="ScriptGuid">{C5AF13AB-699C-4FDD-AB37-57C9EFF4A0EE}</string>
						<ProtectedString name="Source"><![CDATA[return function(player)
	local playerData = player:FindFirstChild("Player_Data")

	if playerData then
		playerData.Vip.Value = true
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXED4621EBB6CF47B3BA0840CE89C19CF7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Tool_Select_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXF5DED987678F449ABD102B0CAA1C7E55">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Tool_Select_Handle.client.lua</string>
						<string name="ScriptGuid">{24AB80B4-86DB-48C8-AD6C-381D55B0862B}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))

local Debounce_C = false
local Main_F = script.Parent.Bottom_Bar_F
local Fight_B = Main_F.Fight_B
local Fight_Key_F = Fight_B.Key_F
local Emotes_B = Main_F.Emotes_B
local Emotes_Key_F = Emotes_B.Key_F

local function Is_There_A_Blur()
	local Blur = game.Lighting:FindFirstChildWhichIsA("BlurEffect")
	if(Blur ~= nil and Blur.Name ~= "Emotes_Blur")then
		return true
	end
	return false
end

function On_Init()
	--Init Key Code Displays for Buttons
	--Set up Clicked Events for the Buttons
	--Set up the Input Handle for the Buttons if not Mobile
	local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
	local Click_SE = SE_Mod.Get_SE_Object(Plr, "Click_SE")
	
	local function Keycode_Display_Handle()
		if(UIS.TouchEnabled)then
			Emotes_Key_F.Visible = false
			Fight_Key_F.Visible = false
		else
			if(UIS.GamepadEnabled)then
				Fight_Key_F:FindFirstChild("Key_Txt").Text = "L1"
				Emotes_Key_F:FindFirstChild("Key_Txt").Text = "R1"
			else
				Fight_Key_F:FindFirstChild("Key_Txt").Text = "1"
				Emotes_Key_F:FindFirstChild("Key_Txt").Text = "2"
			end
			
			Emotes_Key_F.Visible = true
			Fight_Key_F.Visible = true
		end
	end
	Keycode_Display_Handle()
	
	local function Update_Fight_Button_Display()
		local Tween_Fight_B = TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0.275)
		local Stroke = Fight_B:FindFirstChild("UIStroke")
		
		if(Stroke.Color == Color3.fromRGB(25, 25, 25))then
			Stroke.Color = Color3.fromRGB(35, 244, 68)
			TS:Create(Fight_B, Tween_Fight_B, {Size = UDim2.new(0.4375, 0, 0.9875, 0)}):Play()
		else
			Stroke.Color = Color3.fromRGB(25, 25, 25)
			TS:Create(Fight_B, Tween_Fight_B, {Size = UDim2.new(0.3875, 0, 0.875, 0)}):Play()
		end
	end
	
	Fight_B:FindFirstChild("Selected").MouseButton1Click:Connect(function()
		if(Debounce_C == false and Is_There_A_Blur() == false and Fight_B.Visible == true)then
			Debounce_C = true
			Click_SE:Play()
			TS:Create(Fight_B, Tween_Click, {Size = UDim2.new(0.290625, 0, 0.65625, 0)}):Play()
			
			Update_Fight_Button_Display()
			Bindable_Events_F:WaitForChild("Enter_Fight_Mode"):Fire()
			
			wait(0.375)
			Debounce_C = false
		end
	end)
	
	Emotes_B:FindFirstChild("Selected").MouseButton1Click:Connect(function()
		if(Debounce_C == false and Is_There_A_Blur() == false)then
			Debounce_C = true
			Click_SE:Play()
			TS:Create(Emotes_B, Tween_Click, {Size = UDim2.new(0.290625, 0, 0.65625, 0)}):Play()
			
			Bindable_Events_F:WaitForChild("Open_Emotes"):Fire()

			wait(0.25)
			Debounce_C = false
		end
	end)
	
	if(UIS.TouchEnabled == false)then
		local Is_Chatbox_Typing = Bindable_RF:WaitForChild("Is_Chatbox_Typing")
		
		UIS.InputBegan:Connect(function(input, GPE)
			if(Debounce_C == false and Is_Chatbox_Typing:Invoke() == false and Is_There_A_Blur() == false)then
				if((input.KeyCode == Enum.KeyCode.One or input.KeyCode == Enum.KeyCode.ButtonL1) and Fight_B.Visible == true)then
					Debounce_C = true
					Click_SE:Play()
					TS:Create(Fight_B, Tween_Click, {Size = UDim2.new(0.290625, 0, 0.65625, 0)}):Play()

					Update_Fight_Button_Display()
					Bindable_Events_F:WaitForChild("Enter_Fight_Mode"):Fire()

					wait(0.375)
					Debounce_C = false
				elseif(input.KeyCode == Enum.KeyCode.Two or input.KeyCode == Enum.KeyCode.ButtonR1)then
					Debounce_C = true
					Click_SE:Play()
					TS:Create(Emotes_B, Tween_Click, {Size = UDim2.new(0.290625, 0, 0.65625, 0)}):Play()

					Bindable_Events_F:WaitForChild("Open_Emotes"):Fire()

					wait(0.25)
					Debounce_C = false
				end
			end
		end)	
	end
	
	
	local function Toggle_Button_Display(Is_Enabled)
		--For Fight Mode, Disable Fight Button and move Emotes to the Middle
		if(Is_Enabled)then
			Emotes_B:TweenPosition(UDim2.new(0.8, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true, nil)
			Fight_B.Visible = true
		else
			Fight_B.Visible = false
			Emotes_B:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.375, true, nil)
		end
	end
	
	local function Toggle_Whole_Menu(Is_Enabled)
		Main_F.Visible = Is_Enabled
	end
	
	Bindable_Events_F:WaitForChild("Toggle_Tool_Buttons").Event:Connect(function(Is_Enabled)
		Toggle_Button_Display(Is_Enabled)
	end)
	
	Bindable_Events_F:WaitForChild("On_Submission_Handle").Event:Connect(function(Is_Attacking, Is_Submission)
		local state = not (Is_Attacking or Is_Submission)
		Toggle_Whole_Menu(state)
	end)
end
On_Init()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX6CB840021D7B41DA88321E524AE6297C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main_Fight_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXF968CF2ACEAB4B108E793985BF499C6D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Fight_Handle.client.lua</string>
						<string name="ScriptGuid">{3A14E35E-0A11-4D06-A036-5AF8B73F8795}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local RS = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Head = Char:WaitForChild("Head")
local Fight_Data_F = Plr:WaitForChild("Fight_Data")
local Cam = game.Workspace.CurrentCamera
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Receiving_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Sending_Events_F = Channels_F:WaitForChild("Client_Server_F"):WaitForChild("Events")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Bindable_RF = Bindable_F:WaitForChild("RF")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Cam_Shake_Mod = require(Data_Mods_F:WaitForChild("CameraShaker"))
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Fight_Cages_F = game.Workspace:WaitForChild("Fight_Cages_F")

local Can_Enter_Fight = true
local Locked_In_Fight = false
local Events_F = script.Parent.Local_Events_F
local Mobile_Buttons_F = script.Parent.Mobile_Buttons_F
local Fight_Walkspeed = 10
local Cam_FOV = 45
--local Cam_Offset = Vector3.new(2.75, -2.75, -2.75)
local Cam_Offset = Vector3.new(4, -3, -5)
local Min_Angle = math.rad(-35) 
local Max_Angle = math.rad(-25)

local Tween_Cam = TweenInfo.new(0.375, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
local RS_Con = nil
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	
	RS:UnbindFromRenderStep("UpdateLoop")
	
	table.clear(Cons)
end

local function Is_Player_Fighting(T_Char)
	local Is_Fighting = T_Char:GetAttribute("Is_Fighting")
	if(Is_Fighting ~= nil and Is_Fighting == true)then
		return true
	end

	return false
end

local function Set_Cam_Adjustments(Is_Alone)
	if(Is_Alone)then
		TS:Create(Cam, Tween_Cam, {FieldOfView = 70}):Play()
		TS:Create(Hum, Tween_Cam, {CameraOffset = Vector3.new(0, 0, 0)}):Play()
		Cam.CameraType = Enum.CameraType.Track
	else
		TS:Create(Cam, Tween_Cam, {FieldOfView = Cam_FOV}):Play()
		TS:Create(Hum, Tween_Cam, {CameraOffset = Cam_Offset}):Play()
		Cam.CameraType = Enum.CameraType.Scriptable
	end
end

local function Get_Fighting_UI()
	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
		local Main_F = Fight_UI:FindFirstChild("Main_F") 
		local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
		if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
			return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
		end
	end

	return nil, nil
end

local function Get_Current_Fighting_M()
	local All_Cages_M = Fight_Cages_F:GetChildren()
	
	local function Is_Main_Cage(Cage_M)
		local FD = Cage_M:FindFirstChild("Fight_Data_F")
		if(FD ~= nil and FD:FindFirstChild("Fight_Char_1") ~= nil and 
			FD:FindFirstChild("Fight_Char_2") ~= nil)then
			
			local C1_V = FD:FindFirstChild("Fight_Char_1")
			local C2_V = FD:FindFirstChild("Fight_Char_2")
			if(C1_V.Value == Char or C2_V.Value == Char) then
				return true
			end
		end
		
		return false
	end
	
	for i = 1, #All_Cages_M do
		local Cage_M = All_Cages_M[i]
		if(Cage_M ~= nil and Is_Main_Cage(Cage_M))then
			return Cage_M
		end
	end
	
	return nil
end

local function Reset_BG()
	if(RS_Con ~= nil)then
		RS_Con:Disconnect()
		RS_Con = nil
	end
	Disconnect_Cons()

	if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
		HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
	end

	if(Hum ~= nil)then
		Hum.AutoRotate = true
		Hum.WalkSpeed = 16
		Hum.JumpPower = 50
		
		Animation_Mod.Reset_Character_Animations(Char)
		
		Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
		Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, true)
		Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
	end
	
	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil)then
		Damage_Bar_Img.Visible = false
	end
	
	Plr.CameraMaxZoomDistance = game.StarterPlayer.CameraMaxZoomDistance
	Plr.CameraMinZoomDistance = game.StarterPlayer.CameraMinZoomDistance
	
	Cam.CameraType = Enum.CameraType.Custom
	UIS.MouseBehavior = Enum.MouseBehavior.Default
	UIS.MouseIconEnabled = true
	UIS.MouseDeltaSensitivity = 1
	Hum.CameraOffset = Vector3.new(0, 0, 0)
	Cam.FieldOfView = 70
	Char:SetAttribute("Is_Fighting", false)
	
	Bindable_Events_F:WaitForChild("Display_Takedown_Tracking"):Fire(false)
	
	--Hard Reset Player Blocking Handle
	task.spawn(function()
		Events_F:WaitForChild("Unblocking_Strike"):FireServer()
	end)
end
Reset_BG()

local function Init_Testing_For_Camera(Target_HRP)
	--[[
		* Adjust Camera Offset and FOV
		* Lock the Mouse to Center of the Screen, Hide the Cursor
		* Apply BodyGyro to HRP
		* Get a Target Player ~ if not, let the Mouse Free Rotate
		
		* When no Target Player is selected or Found, Keep your Mouse / Camera in a relaxed View
		* Else, Set the Target and Lock in
		
	]]--
	
	local function Rotate_Connection_Handle()
		Reset_BG()

		local function Create_BG()
			local OldG = HRP:FindFirstChildWhichIsA("BodyGyro")
			if(OldG ~= nil)then
				OldG:Destroy()
			end

			local bodyG = Instance.new("BodyGyro", HRP)
			bodyG.P = 1000
			bodyG.MaxTorque = Vector3.new(0, 1000, 0)
			bodyG.D = 10

			return bodyG
		end
		local BG = Create_BG()

		--Cam.CameraType = Enum.CameraType.Track
		Plr.CameraMaxZoomDistance = 18
		Plr.CameraMinZoomDistance = 18
		UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
		UIS.MouseIconEnabled = false
		UIS.MouseDeltaSensitivity = 0.5

		if(Hum ~= nil)then
			Hum.AutoRotate = false
			Hum.WalkSpeed = Fight_Walkspeed
			Hum.JumpPower = 0
			
			Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
			Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
			Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
		end
		
		Char:SetAttribute("Is_Fighting", true)
		
		return BG
	end
	local BG = Rotate_Connection_Handle()
	local Is_Hit = false
	
	local function Get_Target_Player()
		local All_P = game.Players:GetPlayers()
		local Max_Dist, T_HRP = 60, nil
		
		for i = 1, #All_P do
			local T_Plr = All_P[i]
			if(T_Plr ~= nil and T_Plr ~= Plr and T_Plr.Character ~= nil and 
				Is_Player_Fighting(T_Plr.Character) == false and 
				T_Plr.Character:FindFirstChild("HumanoidRootPart") ~= nil)then
				
				local Char_HRP = T_Plr.Character:FindFirstChild("HumanoidRootPart")
				local Dist = (HRP.Position - Char_HRP.Position).Magnitude
				if(Dist <= Max_Dist)then
					Max_Dist = Dist
					T_HRP = Char_HRP
				end
				
			end
		end
		
		return T_HRP
	end
	--local Target_HRP = Get_Target_Player()
	--Target_HRP = game.Workspace.StarterCharacter.HumanoidRootPart
	
	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(false)
	if(Target_HRP ~= nil)then
		Locked_In_Fight = true
		Bindable_Events_F:WaitForChild("Toggle_Tool_Buttons"):Fire(false)
		Bindable_Events_F:WaitForChild("Toggle_BG_Volume"):Fire(false)
		Bindable_Events_F:WaitForChild("Display_Takedown_Tracking"):Fire(true)
	end
	
	Set_Cam_Adjustments((Target_HRP == nil))
	
	table.insert(Cons, Receiving_Events_F:WaitForChild("Set_Player_Fight_Opponent").OnClientEvent:Connect(function(Opp_Char)
		if(Opp_Char ~= nil and Opp_Char:FindFirstChild("HumanoidRootPart") ~= nil)then
			Target_HRP = Opp_Char:FindFirstChild("HumanoidRootPart")
		else
			Target_HRP = nil
		end
		
		Set_Cam_Adjustments((Target_HRP == nil))
	end))
	
	table.insert(Cons, Hum.Died:Connect(function()
		Target_HRP = nil
		Reset_BG()
	end))
	
	local function Update_BG()
		local LookPos  = HRP.Position + (Cam.CFrame.LookVector * 25)
		if(Target_HRP ~= nil)then
			LookPos = Target_HRP.Position
		end
		BG.CFrame = CFrame.new(HRP.Position, LookPos)
	end
	Update_BG()
	
	RS_Con = RS.Stepped:Connect(function()
		if(BG ~= nil and Cam ~= nil)then
			Update_BG()
		end
	end)
	table.insert(Cons, RS_Con) 
	
	table.insert(Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
		if(Hum.PlatformStand == true)then
			BG.P = 0
			BG.MaxTorque = Vector3.new(0, 0, 0)
			BG.D = 0
		else
			BG.P = 1000
			BG.MaxTorque = Vector3.new(0, 1000, 0)
			BG.D = 10
		end
	end))
	
	local offset = CFrame.new()
	local lastCFrame = Cam.CFrame
	--Disable Custom Camera Movement when in a Cutscene-based State (Takedown, Knockout, Cage Clinch)
	local function Allow_Custom_Camera_Movement_Effects()
		if(Is_Hit == true or (Hum ~= nil and Hum.WalkSpeed <= 0) or 
			(HRP ~= nil and HRP.Anchored == true))then
			
			return false
		end
		return true
	end
	
	RS:BindToRenderStep("UpdateLoop", Enum.RenderPriority.Camera.Value - 1, function(dt)
		if(Allow_Custom_Camera_Movement_Effects())then
			local lerp = 0.3
			local alpha = 1 - (1 - lerp) ^ (60 * dt)
			local targetCFrame = HRP.CFrame * CFrame.Angles(Max_Angle, 0, 0) * CFrame.new(3, 2, 13)
			Cam.CFrame = lastCFrame:Lerp(targetCFrame, alpha)

			lastCFrame = Cam.CFrame
		end
		--local rX, rY, rZ = Cam.CFrame:ToOrientation()
		--Cam.CFrame = CFrame.new(Cam.CFrame.p) * CFrame.fromOrientation(Max_Angle, rY, rZ)
	end)
	
	-------------------
	-- Set up the Fight UI
	-- Set up the Actual Connections to start Swinging, Blocking, Moving, Ect
	
	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
		Damage_UIG.Offset = Vector2.new(0, -0.5)
		Damage_Bar_Img.Visible = true
	end
	
	local function Create_Anim_Arr_Data(Anim_Track_Data)
		local D = {}
		for Key, Anim_Track in next, Anim_Track_Data do
			table.insert(D, Anim_Track)
		end
		return D
	end
	
	local function Get_Fight_Data_Vals()
		local FD_Vals = Fight_Data_F:GetChildren()
		local Vals = {
			
		}
		
		for i = 1, #FD_Vals do
			local V = FD_Vals[i]
			if(V ~= nil)then
				Vals[V.Name] = V
			end
		end
		
		return Vals
	end
	local Fight_Data_Vals = Get_Fight_Data_Vals()
	local Health_V = Fight_Data_Vals['Health']
	local Blocking_Power_V = Fight_Data_Vals['Block Power']
	local Staminia_V = Fight_Data_Vals['Staminia']
	local Punch_Power_V = Fight_Data_Vals['Strike Power']
	local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	local Combo_Strike_Index = 1
	local Combo_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(Plr, Hum)
	local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)
	
	local Debounce_Striking = false
	local Debounce_Dodge = false
	local Debounce_Blocking = false
	local Debounce_Takedown = false
	
	
	local function Striking_Movement_Handle()
		--> Update Movement, Moving Forward or Backwards | Moving Left to Right | Standing Idle
		--> Track Humanoid MoveDirection
		local Cam_Move_Tween = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
		local Reset_Cam_Move_Tween = TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
		local Cam_Tween = nil
		
		table.insert(Cons, Hum:GetPropertyChangedSignal("MoveDirection"):Connect(function()
			local Move_Dir = Hum.MoveDirection
			if(Move_Dir.Magnitude > 0 and Anim_Track_Data['Shuffle Forward'].IsPlaying == false)then
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				Anim_Track_Data['Shuffle Forward']:Play()
				--Anim_Track_Data['Shuffle Forward']:AdjustSpeed(-1)
				
				if(Is_Hit == false)then
					if(Cam_Tween ~= nil)then
						Cam_Tween:Cancel()
						Cam_Tween = nil
					end
					Cam_Tween = TS:Create(Cam, Cam_Move_Tween, {FieldOfView = 55})
					Cam_Tween:Play()
				end
				
			elseif(Move_Dir.Magnitude <= 0 and 
				(Anim_Track_Data['Shuffle Forward'].IsPlaying == true or 
					Anim_Track_Data['Shuffle Side'].IsPlaying == true))then
				
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				
				if(Is_Hit == false)then
					if(Cam_Tween ~= nil)then
						Cam_Tween:Cancel()
						Cam_Tween = nil
					end
					Cam_Tween = TS:Create(Cam, Reset_Cam_Move_Tween, {FieldOfView = Cam_FOV})
					Cam_Tween:Play()
				end
			end
		end))
		
		Anim_Track_Data['Idle']:Play()
		Anim_Track_Data['Idle']:AdjustSpeed(0.5)
	end
	Striking_Movement_Handle()
	
	local function On_Hit_Effects()
		--[[
			* When Health goes Down!
				> Camera Shake Effects
					-> Quick Shake
				> Apply Hit Effects
					-> Reset all Animations, Play the Hit One
				> Set Debounce till Hit Effect goes Away
		]]--
		
		local Prev_Health = Health_V.Value
		local Hit_Anim_Track = Striking_Anim_Tracks['Taking Hit']
		
		local function Cam_Shake()
			local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
				Cam.CFrame = Cam.CFrame * shakeCf
			end)
			return CS
		end
		local CamShake = Cam_Shake()
		
		local function Show_Sweat_Effects()
			if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
				local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
				local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
				if(PE ~= nil)then
					PE:Emit(25)
				end
			end
		end
		
		table.insert(Cons, Health_V.Changed:Connect(function()
			local Current_V = Health_V.Value
			if(Current_V < Prev_Health and Is_Hit == false)then
				Is_Hit = true
				
				CamShake:Start()
				CamShake:Shake(Cam_Shake_Mod.Presets.Bump)
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Show_Sweat_Effects()
				
				task.spawn(function()
					Animation_Mod.Play_Animation_Track(Hit_Anim_Track)
					CamShake:Stop()
					Is_Hit = false
				end)
			end
			
			Prev_Health = Current_V
		end))
	end
	On_Hit_Effects()
	
	local function Get_Target_Players_Hand()
		if(Target_HRP ~= nil and Target_HRP.Parent ~= nil and 
			game.Players:GetPlayerFromCharacter(Target_HRP.Parent) ~= nil)then

			local T_Plr = game.Players:GetPlayerFromCharacter(Target_HRP.Parent)
			local T_Plr_PD = T_Plr:FindFirstChild("Player_Data")

			if(T_Plr_PD ~= nil and T_Plr_PD:FindFirstChild("Right Handed") ~= nil)then
				return T_Plr_PD:FindFirstChild("Right Handed").Value
			end
		end

		return true
	end
	
	local function Play_Blocking_Animation()
		local Anim_Track = Striking_Anim_Tracks['Main Block']
		if(Anim_Track ~= nil)then
			Anim_Track:Play()
			Anim_Track:AdjustSpeed(1)
			wait(Anim_Track.Length * 0.9)
			
			if(Anim_Track ~= nil and Debounce_Blocking == true)then
				Anim_Track:AdjustSpeed(0)
			end
		end
	end
	
	local function Blocking_Effects()
		--[[
			* On Sheild Blocking Power goes down (Greater than 0) and Debounce_Blocking == true
			* Get the Opponent Handed Type
				> Play the Coresponding Animation
		]]--
		local Prev_Blocking = Blocking_Power_V.Value
		
		local function Get_Blocking_Animation()
			if(Get_Target_Players_Hand())then
				--Target is Right Handed, Block with your Left
				return Striking_Anim_Tracks['Body Block Left']
			else
				return Striking_Anim_Tracks['Body Block Right']
			end
		end
		
		table.insert(Cons, Blocking_Power_V.Changed:Connect(function()
			local Current_V = Blocking_Power_V.Value
			if(Current_V > 0 and Current_V < Prev_Blocking and Debounce_Blocking == true)then
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Get_Blocking_Animation())
				
				if(Debounce_Blocking == true)then
					task.spawn(Play_Blocking_Animation)
				end
			end

			Prev_Blocking = Current_V
		end))
	end
	Blocking_Effects()
	
	local function Strike_Power_Handle()
		local function Update_Damage_Bar()
			local Dif =  math.clamp(Punch_Power_V.Value / 6, 0, 1)
			local Offset_Pos_Y = (1 - Dif) - 0.5
			Damage_UIG.Offset = Vector2.new(0, Offset_Pos_Y)
		end
		Update_Damage_Bar()
		
		table.insert(Cons, Punch_Power_V.Changed:Connect(function()
			Update_Damage_Bar()
		end))
	end
	Strike_Power_Handle()
	
	--Striking Handle
	local function Client_Striking_Handle()
		--[[
			* On Click / R2 ~ Strike
			* Q / X ~ Dodge Left
			* E / B ~ Dodge Right
			* Space / L2 ~ Blocking Handle
		]]--
		local Woosh_SE = SE_Mod.Get_SE_Object(Plr, "Punch_Woosh_SE")
		
		local function Strike_Handle()
			--[[
				* Play Woosh Sound Effect locally
				* Play Animation
				* Tell the Server that you are Striking
			]]--
			
			Debounce_Striking = true
			if(Woosh_SE ~= nil)then
				Woosh_SE:Play()
			end
			
			local function Play_Strike_Animation()
				local Track = Combo_Anim_Arr[Combo_Strike_Index]
				local Key = Track:GetAttribute("Strike_Key") or "A"
				
				task.spawn(function()
					Events_F:WaitForChild("Throwing_Strike"):FireServer(Key)
				end)
				
				Combo_Strike_Index += 1
				if(Combo_Strike_Index > #Combo_Anim_Arr)then
					Combo_Strike_Index = 1
				end
				
				Animation_Mod.Stop_Animation_Tracks(Combo_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Track)
			end
			task.spawn(Play_Strike_Animation)
			wait(0.5)
			
			if(UIS.TouchEnabled == false)then
				wait(0.25)
			end
			
			Debounce_Striking = false
		end
		
		local Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left']
		local Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		local Back_Dodge_Ani = Striking_Anim_Tracks['Dodge Back']
		local function Dodge_Handle(Dodge_Type)
			--[[
				* Get the Type First
					-> First Index? Just play the Slip Animation
					-> 2nd Index? Play the Dodge Animation AND apply Force to the Player in the direction
				
					-> Tell the Server that you are Dodging and should reduce Staminia Value
			]]--
			
			Debounce_Dodge = true
			
			local function Apply_Force(Dir)
				local Force = 68
				if(Dodge_Type == "Dodge Back")then
					Force = 90
				end
				
				HRP:ApplyImpulse(Dir * (Fight_Walkspeed * Force) * HRP:GetMass())
			end
			
			task.spawn(function()
				Events_F:WaitForChild("Dodging_Strike"):FireServer()
			end)
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Bindable_Events_F:WaitForChild("Show_White_Fade"):Fire(Color3.new(1, 1, 1))
			
			if(Dodge_Type == "Dodge Left")then
				--Left
				if(Left_Dodge_Ani == Striking_Anim_Tracks['Headblock Left'])then
					--Apply_Force(HRP.CFrame.RightVector * -1)
				end
				Apply_Force(HRP.CFrame.RightVector * -1)
				Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
			elseif(Dodge_Type == "Dodge Right")then
				--Right
				if(Right_Dodge_Ani == Striking_Anim_Tracks['Headblock Right'])then
					--Apply_Force(HRP.CFrame.RightVector)
				end
				Apply_Force(HRP.CFrame.RightVector)
				Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
				
			else
				Apply_Force(HRP.CFrame.LookVector * -1)
				Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
			end
			
			
			local function Increment_Anim()
				if(Dodge_Type == "Dodge Left")then
					if(Left_Dodge_Ani == Striking_Anim_Tracks['Slip Left'])then
						Left_Dodge_Ani = Striking_Anim_Tracks['Headblock Left']
					else
						Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left'] 
					end
				elseif(Dodge_Type == "Dodge Right")then
					--Right
					if(Right_Dodge_Ani == Striking_Anim_Tracks['Slip Right'])then
						Right_Dodge_Ani = Striking_Anim_Tracks['Headblock Right']
					else
						Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right'] 
					end
				end
			end
			Increment_Anim()
			
			Debounce_Dodge = false
		end
		
		local Low_Block_Con = nil
		local function Disable_Blocking_Handle()
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end
			
			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed
			end
			
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Events_F:WaitForChild("Unblocking_Strike"):FireServer()
			Events_F:WaitForChild("Release_Mobile_Blocking"):Fire()
			Debounce_Blocking = false
		end
		
		local function Blocking_Handle()
			Debounce_Blocking = true
			
			if(Hum ~= nil)then
				Hum.WalkSpeed = 5
			end
			
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end
			
			Low_Block_Con = Blocking_Power_V.Changed:Connect(function()
				if(Blocking_Power_V.Value <= 0 and Debounce_Blocking == true)then
					if(Low_Block_Con ~= nil)then
						Low_Block_Con:Disconnect()
						Low_Block_Con = nil
					end
					
					Disable_Blocking_Handle()
				end
			end)
			table.insert(Cons, Low_Block_Con)
			
			task.spawn(Play_Blocking_Animation)
			
			Events_F:WaitForChild("Blocking_Strike"):FireServer()
		end
		
		local function Takedown_Handle()
			--[[
				* Get the Takedown Event
					- Get the Fight Model
					- Get the Event
					- Get check the Takedown Tracker
					- Make sure you're not already on the ground
			]]--
			
			local function Get_Takedown_Event()
				local function Check_Takedown_Data(Takedown_V)
					local Your_V, Other_V = 0, 0
					for Plr_Name, Val in next, Takedown_V:GetAttributes() do
						if(Plr_Name == Char.Name)then
							Your_V = Val
						else
							Other_V = Val
						end
					end
					
					if(Your_V > Other_V)then
						return true
					end
					return false
				end
				
				local function Is_Fighting_Model(Cage_M)
					local Fight_Data_F = Cage_M:FindFirstChild("Fight_Data_F")
					if(Fight_Data_F ~= nil and Fight_Data_F:FindFirstChild("Fight_Char_1") ~= nil and 
						Fight_Data_F:FindFirstChild("Fight_Char_2") ~= nil and 
						Fight_Data_F:FindFirstChild("Active_Fight") ~= nil and 
						Fight_Data_F:FindFirstChild("Takedown_Track") ~= nil and 
						Fight_Data_F:FindFirstChild("Submission_Hold_Character") and 
						Fight_Data_F:FindFirstChild("Takedown_E") ~= nil)then

						local Char_V1 = Fight_Data_F:FindFirstChild("Fight_Char_1")
						local Char_V2 = Fight_Data_F:FindFirstChild("Fight_Char_2")
						local Can_Takedown = Fight_Data_F:FindFirstChild("Takedown_Track")
						local Active_Fight_V = Fight_Data_F:FindFirstChild("Active_Fight")
						local Submission_Hold_V = Fight_Data_F:FindFirstChild("Submission_Hold_Character")

						if(Active_Fight_V.Value == true and Can_Takedown.Value == true and
							(Char_V1.Value == Char or Char_V2.Value == Char) and 
							Submission_Hold_V.Value ~= Char and Check_Takedown_Data(Can_Takedown))then
							
							return Fight_Data_F:FindFirstChild("Takedown_E")
						end
					end

					return nil
				end

				local All_Cages_M = Fight_Cages_F:GetChildren()
				for i = 1, #All_Cages_M do
					local Cage_M = All_Cages_M[i] 
					if(Cage_M ~= nil)then
						local Takedown_E = Is_Fighting_Model(Cage_M)
						if(Takedown_E ~= nil)then
							return Takedown_E
						end
					end
				end
				
				return nil
			end
			local Takedown_E = Get_Takedown_Event()
			
			if(Takedown_E ~= nil)then
				Debounce_Takedown = true
				
				--Play the Animation
				SE_Mod.Play_Voice_Over("Submission_Attempt")
				Takedown_E:FireServer()
				
				wait(10)
				Debounce_Takedown = false
			end
		end
		
		if(UIS.TouchEnabled == false)then
			local Is_Chat_Typing = Bindable_RF:WaitForChild("Is_Chatbox_Typing")
			
			local function Input_Handle(input)
				if(input.UserInputType == Enum.UserInputType.MouseButton1 or 
					input.KeyCode == Enum.KeyCode.ButtonR2)then
					
					return "Striking"
				elseif(input.KeyCode == Enum.KeyCode.Q or input.KeyCode == Enum.KeyCode.ButtonX)then
					return "Dodge Left"
				elseif(input.KeyCode == Enum.KeyCode.E or input.KeyCode == Enum.KeyCode.ButtonB)then
					return "Dodge Right"
				elseif(input.KeyCode == Enum.KeyCode.F or input.KeyCode == Enum.KeyCode.ButtonA)then
					return "Dodge Back"
				elseif(input.KeyCode == Enum.KeyCode.Space or input.KeyCode == Enum.KeyCode.ButtonL2)then
					return "Blocking"
				elseif(input.KeyCode == Enum.KeyCode.R or input.KeyCode == Enum.KeyCode.ButtonY)then
					return "Takedown"
				end
				
				return "None"
			end
			
			table.insert(Cons, UIS.InputBegan:Connect(function(input, GPE)
				if(Is_Chat_Typing:Invoke() == false and Health_V.Value > 0 and Is_Hit == false)then
					local Input_Type = Input_Handle(input)
					if(Input_Type == "Striking" and Debounce_Striking == false and 
						Staminia_V.Value >= 3 and Punch_Power_V.Value > 0)then
						
						if(Debounce_Blocking == true)then
							task.spawn(Disable_Blocking_Handle)
						end
						
						Strike_Handle()
						
					elseif(Input_Type == "Blocking" and Debounce_Blocking == false and 
						Blocking_Power_V.Value > 0)then
						
						Blocking_Handle()
						
				elseif((Input_Type == "Dodge Left" or Input_Type == "Dodge Right" or Input_Type == "Dodge Back") and 
						Debounce_Dodge == false and Staminia_V.Value >= 7)then
						
						if(Debounce_Blocking == true)then
							task.spawn(Disable_Blocking_Handle)
						end
						
						Dodge_Handle(Input_Type)
						
					elseif(Input_Type == "Takedown"and Debounce_Takedown == false and 
						Staminia_V.Value >= 15)then

						Takedown_Handle()
					end
				end
			end))

			table.insert(Cons, UIS.InputEnded:Connect(function(input, GPE)
				if(Is_Chat_Typing:Invoke() == false and Input_Handle(input) == "Blocking" and 
					Debounce_Blocking == true)then
					
					Disable_Blocking_Handle()
				end
			end))
			
			Events_F:WaitForChild("Toggle_Key_Labels"):Fire(true)
		else
			--Set up Mobile Button Handle
			local Mobile_Button_Data = Events_F:WaitForChild("Get_Mobile_Buttons"):Invoke()
			local Click_SE = SE_Mod.Get_SE_Object(Plr, "Click_SE")
			
			local function Get_Click_Size()
				local B = Mobile_Button_Data['Strike_B']
				local Def_Size = B.Size.X.Offset
				local CS = Def_Size * 0.75
				return B.Size, UDim2.new(0, CS, 0, CS)
			end
			local Def_Size, Click_Size = Get_Click_Size()
			
			local function Input_Handle(Input_Type)
				if(Input_Type == "Striking" and Debounce_Striking == false and 
					Staminia_V.Value >= 3 and Punch_Power_V.Value > 0)then

					if(Debounce_Blocking == true)then
						task.spawn(Disable_Blocking_Handle)
					end

					Strike_Handle()

				elseif(Input_Type == "Blocking" and Debounce_Blocking == false and 
					Blocking_Power_V.Value > 0)then

					Blocking_Handle()

			elseif((Input_Type == "Dodge Left" or Input_Type == "Dodge Right" or Input_Type == "Dodge Back") and 
					Debounce_Dodge == false and Staminia_V.Value >= 7)then

					if(Debounce_Blocking == true)then
						task.spawn(Disable_Blocking_Handle)
					end

					Dodge_Handle(Input_Type)

				elseif(Input_Type == "Takedown"and Debounce_Takedown == false and 
					Staminia_V.Value >= 15)then

					Takedown_Handle()
				end
			end
			
			local function Click_Handle(B, Input_Type)
				local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
				local Selected = B:FindFirstChild("Selected")
				local Debounce_C = false
				B.Visible = true
				
				table.insert(Cons, Selected.MouseButton1Click:Connect(function()
					if(Debounce_C == false and B.Visible == true and Health_V.Value > 0 and Is_Hit == false)then
						Debounce_C = true
						if(Click_SE ~= nil)then
							Click_SE:Play()
						end
						TS:Create(B, Tween_Click, {Size = Click_Size}):Play()
						
						Input_Handle(Input_Type)
						
						wait(0.25)
						Debounce_C = false
					end
				end))
			end
			Click_Handle(Mobile_Button_Data['Strike_B'], "Striking")
			Click_Handle(Mobile_Button_Data['Dodge_Left_B'], "Dodge Left")
			Click_Handle(Mobile_Button_Data['Dodge_Right_B'], "Dodge Right")
			Click_Handle(Mobile_Button_Data['Takedown_B'], "Takedown")
			Click_Handle(Mobile_Button_Data['Dodge_Back_B'], "Dodge Back")
			
			local function Blocking_Handle(B)
				local Selected = B:FindFirstChild("Selected")
				local Icon_Img = B:FindFirstChild("Icon_Img")
				local Debounce_C = false
				B.Visible = true
				Icon_Img.ImageColor3 = Color3.new(1, 1, 1)
				
				table.insert(Cons, Selected.MouseButton1Down:Connect(function()
					if(Debounce_C == false and B.Visible == true and Health_V.Value > 0 and Is_Hit == false)then
						Debounce_C = true
						if(Click_SE ~= nil)then
							Click_SE:Play()
						end
						Icon_Img.ImageColor3 = Color3.fromRGB(150, 150, 150)
						B:TweenSize(Click_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.125, true, nil)
						Input_Handle("Blocking")
					end
				end))
				
				table.insert(Cons, Selected.MouseButton1Up:Connect(function()
					if(Debounce_C)then
						if(Click_SE ~= nil)then
							Click_SE:Play()
						end
						Icon_Img.ImageColor3 = Color3.new(1, 1, 1)
						B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.125, true, nil)
						
						if(Debounce_Blocking == true)then
							task.spawn(Disable_Blocking_Handle)
						end
						
						Debounce_C = false
					end
				end))	
				
				table.insert(Cons, Events_F:WaitForChild("Release_Mobile_Blocking").Event:Connect(function()
					if(Debounce_C and B.Size == Click_Size)then
						if(Click_SE ~= nil)then
							Click_SE:Play()
						end
						Icon_Img.ImageColor3 = Color3.new(1, 1, 1)
						B:TweenSize(Def_Size, Enum.EasingDirection.Out, Enum.EasingStyle.Linear, 0.125, true, nil)
						Debounce_C = false
					end
				end))
			end
			Blocking_Handle(Mobile_Button_Data['Block_B'])
			
			Mobile_Button_Data['Takedown_B'].Visible = false
		end
	end
	Client_Striking_Handle()
	
	
	--Set up Submission Handle
	local Prev_Camera_Offset, Cam_Tween, Cam_RS_Con = nil, TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0), nil
	local function On_Submission_Handle(Is_Attacking, Is_Submission)
		Animation_Mod.Reset_Character_Animations(Char)
		Events_F:WaitForChild("Toggle_Key_Labels"):Fire(not Is_Submission)
		
		if(Cam_RS_Con ~= nil)then
			Cam_RS_Con:Disconnect()
			Cam_RS_Con = nil
		end
		
		if(Is_Submission)then
			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
			
			if(HRP ~= nil)then
				HRP.Anchored = true
				
				if(Is_Attacking == false)then
					--HRP.CFrame *= CFrame.new(Vector3.new(0, 0.15, 0))
				end
			end
		
			--> Play Animation
				--> Get Submission Character & Player
				--> Get their Takedown and Submission Data
				
				--> If Attacking Player, Set HRP CFrame Position
				--> Play Take Down Animation
				
				--> Play Submission Animation
				--> Play Submission Loop Animation
			
			
			local function Get_Takedown_Submission_Tracks()
				local function Get_Fighting_Character()
					local All_FM = Fight_Cages_F:GetChildren()

					local function Check_Fight_Data(FD_F)
						local Char_V1 = FD_F:FindFirstChild("Fight_Char_1")
						local Char_V2 = FD_F:FindFirstChild("Fight_Char_2")
						local Submission_Char = FD_F:FindFirstChild("Submission_Hold_Character")

						if(Char ~= nil and Char_V1 ~= nil and Char_V2 ~= nil and 
							(Char_V1.Value == Char or Char_V2.Value == Char) and 
							Submission_Char ~= nil and Submission_Char.Value ~= nil)then

							return Submission_Char.Value 
						end

						return nil
					end

					for i = 1, #All_FM do
						local FM = All_FM[i]
						if(FM ~= nil and FM:FindFirstChild("Fight_Data_F") ~= nil)then
							local Fight_Data_F = FM:FindFirstChild("Fight_Data_F")
							local Other_Char = Check_Fight_Data(Fight_Data_F)
							if(Other_Char ~= nil)then
								return Other_Char
							end
						end
					end

					return nil
				end
				local Attacking_Char = Get_Fighting_Character()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)

				if(Is_Attacking)then
					local function Set_HRP_CFrame()
						local Attack_HRP = Attacking_Char:FindFirstChild("HumanoidRootPart")
						local CF_Offset = Takedown_Data['CF Offset']
						local Offset_Pos = CF_Offset.Position
						local Offset_Rot = CF_Offset.Rotation
						
						if(Attack_HRP ~= nil and CF_Offset ~= nil and HRP ~= nil)then
							local New_Pos = Attack_HRP.Position + (Attack_HRP.CFrame.LookVector * math.abs(Offset_Pos.Z))
							local Rot_CF = CFrame.new(HRP.Position, New_Pos)
							--HRP.CFrame = CFrame.new(New_Pos) * Rot_CF.Rotation
						end
					end
					Set_HRP_CFrame()
					
					return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Takedown ID'], Submission_Data['Submission ID'], Submission_Data['Submission Loop ID'])
				else
					return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Receiving ID'], Submission_Data['Receiving ID'], Submission_Data['Receiving Loop ID'])
				end
			end
			local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()
			
			local function Play_Init_Camera_Effects()
				if(Prev_Camera_Offset == nil)then
					Prev_Camera_Offset = HRP.CFrame:ToObjectSpace(Cam.CFrame)
				end

				local function Get_Receiving_HRP()
					local Cage_M = Get_Current_Fighting_M()
					if(Cage_M ~= nil and Cage_M:FindFirstChild("Fight_Data_F") ~= nil)then
						local FD = Cage_M:FindFirstChild("Fight_Data_F")
						local Submission_Char_V = FD:FindFirstChild("Submission_Hold_Character")
						local Fight_Char_1_V = FD:FindFirstChild("Fight_Char_1")
						local Fight_Char_2_V = FD:FindFirstChild("Fight_Char_2")
						
						if(Submission_Char_V ~= nil and Fight_Char_1_V ~= nil and Fight_Char_2_V ~= nil)then
							if(Fight_Char_1_V.Value ~= Submission_Char_V.Value)then
								local T_HRP = Fight_Char_1_V.Value:FindFirstChild("UpperTorso")
								if(T_HRP ~= nil)then
									return T_HRP
								end
							else
								local T_HRP = Fight_Char_2_V.Value:FindFirstChild("UpperTorso")
								if(T_HRP ~= nil)then
									return T_HRP
								end
							end
						end
					end

					return HRP
				end
				local T_HRP = Get_Receiving_HRP()
				
				local CF_Offset_Pos = CFrame.new(Vector3.new(4.31428, 5.22440, -5.47107))
				local Final_Pos = T_HRP.CFrame:ToWorldSpace(CF_Offset_Pos).Position
				local Rot_CF = CFrame.new(Final_Pos, T_HRP.Position)
				local Final_CF = CFrame.new(Final_Pos) * Rot_CF.Rotation
				
				Cam.CameraType = Enum.CameraType.Scriptable
				TS:Create(Cam, Tween_Cam, {CFrame = Final_CF}):Play()	
				--TS:Create(Hum, Tween_Cam, {CameraOffset = Vector3.new(0, 0, 0)}):Play()	
				
				if(Cam_RS_Con ~= nil)then
					Cam_RS_Con:Disconnect()
					Cam_RS_Con = nil
				end
				
				Cam_RS_Con = RS.Stepped:Connect(function()
					if(Cam ~= nil and T_HRP ~= nil and Cam.CameraType == Enum.CameraType.Scriptable)then
						Cam.CFrame = CFrame.new(Cam.CFrame.Position, T_HRP.Position)
					end
				end)
				table.insert(Cons, Cam_RS_Con)
			end
			Play_Init_Camera_Effects()
			
			Animation_Mod.Play_Animation_Track(Takedown_Track, true)
			
			--Bindable_Events_F:WaitForChild("Transition_Hole"):Fire(Color3.fromRGB(50, 50, 50))
			--wait(0.25)
			
			Animation_Mod.Play_Animation_Track(Submission_Track, true)
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
		else
			Is_Hit = false

			if(HRP ~= nil)then
				HRP.Anchored = false
				
				local function Reset_Player_Camera()
					if(Prev_Camera_Offset == nil)then
						Prev_Camera_Offset = CFrame.new(Vector3.new()) * CFrame.Angles(0, 0, 0)
					end
					
					local Cam_CF = HRP.CFrame:ToWorldSpace(Prev_Camera_Offset)
					Cam.CameraType = Enum.CameraType.Scriptable
					TS:Create(Cam, Cam_Tween, {CFrame = Cam_CF}):Play()
					TS:Create(Hum, Tween_Cam, {CameraOffset = Cam_Offset}):Play()
					
					wait(0.75)
					
					Set_Cam_Adjustments((Target_HRP == nil))
				end
				task.spawn(Reset_Player_Camera)
			end

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
				Cam.FieldOfView = Cam_FOV
			end
			
		end
	end
	
	table.insert(Cons, Bindable_Events_F:WaitForChild("On_Submission_Handle").Event:Connect(function(Is_Attacking, Is_Submission)
		On_Submission_Handle(Is_Attacking, Is_Submission)
	end))
	
	
	--Set up Cage Clinch Handle
	local function Cage_Clinch_Handle(Animation_Sequence_Data, Is_Attacking, Camera_CF)
		--[[	
			* Freeze Character
			* Lock the Camera into Position
			* Play Cage Clinch Init
			* Play the Cage Clinch Loop
			* Play the Animation Sequence
			* Reset the Player Animations
			* Play the Idle Animation
			* Reset Player Camera
		]]--

		local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(Char)
			Events_F:WaitForChild("Toggle_Key_Labels"):Fire(false)

			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
		end
		Freeze_Character()
		
		local function Lock_Camera()
			local Tween_Cam_Clinch = TweenInfo.new(0.375, Enum.EasingStyle.Quint, Enum.EasingDirection.Out, 0, false, 0)
			local Cam_Offset = HRP.CFrame:ToObjectSpace(Cam.CFrame)
			local Init_FOV = Cam.FieldOfView
			
			Cam.CameraType = Enum.CameraType.Scriptable
			TS:Create(Cam, Cam_Tween, {CFrame = Camera_CF, FieldOfView = 50}):Play()
			
			return Cam_Offset, Init_FOV
		end
		local Cam_CF_Offset, Init_Cam_FOV = Lock_Camera()
		
		local function Cam_Shake()
			local CS = Cam_Shake_Mod.new(Enum.RenderPriority.Camera.Value, function(shakeCf)
				Cam.CFrame = Cam.CFrame * shakeCf
			end)
			return CS
		end
		local CamShake = Cam_Shake()
		
		local function Play_Strike_Sequences()
			local Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
			Animation_Mod.Play_Animation_Track(Clinch_Tracks_Data['Init_Clinch'], true)
			task.spawn(Animation_Mod.Play_Animation_Track, Clinch_Tracks_Data['Loop_Clinch'])
			wait(1)
			
			CamShake:Start()
			local function Play_Clinch_Hit_Effects()
				local Col = Color3.new(1, 0, 0)
				if(Is_Attacking)then
					Col = Color3.new(1, 1, 1)
				end
				
				Bindable_Events_F:WaitForChild("Show_White_Fade"):Fire(Col)
				CamShake:Shake(Cam_Shake_Mod.Presets.Bump)
			end
			
			for i = 1, #Animation_Sequence_Data do
				local Strike_Key = Animation_Sequence_Data[i]
				local Strike_Track = Clinch_Tracks_Data[Strike_Key]

				if(Strike_Track ~= nil)then
					--Play Flash, Play Hit Sound Effect, Quick Camera Shake
					Play_Clinch_Hit_Effects()
					Animation_Mod.Play_Animation_Track(Strike_Track)
					--wait(0.5)
				end
			end
			
			CamShake:Stop()
		end
		Play_Strike_Sequences()
		
		local function Clinch_Reset_Handle()
			local function Reset_Player_Camera()
				local Tween_Cam_Clinch = TweenInfo.new(0.75, Enum.EasingStyle.Quint, Enum.EasingDirection.In, 0, false, 0)
				local Cam_CF = HRP.CFrame:ToWorldSpace(Cam_CF_Offset)
				Cam.CameraType = Enum.CameraType.Scriptable
				TS:Create(Cam, Tween_Cam_Clinch, {CFrame = Cam_CF, FieldOfView = Init_Cam_FOV}):Play()

				wait(0.75)

				Set_Cam_Adjustments((Target_HRP == nil))
			end
			task.spawn(Reset_Player_Camera)
			
			Animation_Mod.Reset_Character_Animations(Char)
			Events_F:WaitForChild("Toggle_Key_Labels"):Fire(true)
			Is_Hit = false
			
			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
				Cam.FieldOfView = Cam_FOV
			end
		end	
		Clinch_Reset_Handle()
	end
	
	table.insert(Cons, Receiving_Events_F:WaitForChild("Cage_Clinch_Start").OnClientEvent:Connect(function(Sequence_Keys, Is_Attacking, Camera_CF)
		Cage_Clinch_Handle(Sequence_Keys, Is_Attacking, Camera_CF)
	end))	
end

Bindable_Events_F:WaitForChild("Enter_Fight_Mode").Event:Connect(function(Target_HRP)
	if(Locked_In_Fight == false)then
		if(Char ~= nil and RS_Con == nil and Can_Enter_Fight == true)then
			if(Target_HRP ~= nil)then
				Locked_In_Fight = true
			end
			
			task.spawn(function()
				Sending_Events_F:WaitForChild("Show_Shield_UI"):FireServer(true)
			end)
			Init_Testing_For_Camera(Target_HRP)
		else
			Reset_BG()
			Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true)
			Events_F:WaitForChild("Toggle_Key_Labels"):Fire(false)
			Events_F:WaitForChild("Toggle_Mobile_Buttons"):Fire(false)
			
			task.spawn(function()
				Sending_Events_F:WaitForChild("Show_Shield_UI"):FireServer(false)
			end)
		end
	end
end)

Bindable_Events_F:WaitForChild("Disable_Fight_Mode").Event:Connect(function()
	Can_Enter_Fight = false
	Locked_In_Fight = false
	Reset_BG()
	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true)
	Events_F:WaitForChild("Toggle_Key_Labels"):Fire(false)
	Events_F:WaitForChild("Toggle_Mobile_Buttons"):Fire(false)
	
	task.spawn(function()
		Sending_Events_F:WaitForChild("Show_Shield_UI"):FireServer(false)
	end)
	
	wait(3)
	Can_Enter_Fight = true
end)


local function Reset_Name_Tag_Handle(C)
	local Name_Tag = C:FindFirstChild("Name_Tag_UI")
	local Toggle_Tabs = {"UIStroke", "Rank_F", "Connection_Img", "Device_Img", "Country_Img", 
		"Player_Name_Txt"}

	if(Name_Tag ~= nil and Name_Tag:FindFirstChild("Main_F") ~= nil)then
		local Main_F = Name_Tag:FindFirstChild("Main_F")

		for i = 1, #Toggle_Tabs do
			local Tab = Main_F:FindFirstChild(Toggle_Tabs[i])
			if(Tab ~= nil)then
				if(Tab:IsA("UIStroke"))then
					Tab.Enabled = true
				else
					Tab.Visible = true
				end
			end
		end

		Main_F.BackgroundTransparency = 0.125

		if(C ~= Char)then
			Name_Tag.StudsOffset = Vector3.new(0, -4, 0)
		end
		
		Name_Tag.Enabled = true
	end
end

Receiving_Events_F:WaitForChild("End_Fight").OnClientEvent:Connect(function(Target_Char)
	Reset_BG()
	
	Reset_Name_Tag_Handle(Char)
	if(Target_Char ~= nil)then
		Reset_Name_Tag_Handle(Target_Char)
	end
	
	Bindable_Events_F:WaitForChild("Toggle_Tool_Buttons"):Fire(false)
	Bindable_Events_F:WaitForChild("Toggle_BG_Volume"):Fire(true)
	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons"):Fire(true)
	Events_F:WaitForChild("Toggle_Key_Labels"):Fire(false)
	Events_F:WaitForChild("Toggle_Mobile_Buttons"):Fire(false)
	
	task.spawn(function()
		Sending_Events_F:WaitForChild("Show_Shield_UI"):FireServer(false)
	end)
	
	local Ding_SE = SE_Mod.Get_SE_Object(Plr, "Start_Fight_Bell_SE")
	if(Ding_SE ~= nil)then
		Ding_SE:Play()
	end
	
	Locked_In_Fight = false
end)


]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX5EA7596E20DD475DB1D93E8971819877">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Client_Fight_Handle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX0BBBA2239D80463288CFDE0618D5D91C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Mobile_Buttons_Handle.client.lua</string>
							<string name="ScriptGuid">{4E2CEDEE-0C78-4553-9FF4-6152A9678A2C}</string>
							<ProtectedString name="Source"><![CDATA[local UIS = game:GetService("UserInputService")
local TS = game:GetService("TweenService")
local Plr = game.Players.LocalPlayer
local PG = Plr:WaitForChild("PlayerGui")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Bindable_RF = Bindable_F:WaitForChild("RF")

local Main_UI = script.Parent.Parent
local Mobile_Buttons_F = Main_UI.Mobile_Buttons_F
local Key_Labels_F = Main_UI.Key_Labels_F
local Events_F = Main_UI.Local_Events_F
local Toggle_Key_Labels_E = Events_F.Toggle_Key_Labels
local Get_Mobile_Buttons_BF = Events_F.Get_Mobile_Buttons
local Toggle_Mobile_Buttons_E = Events_F.Toggle_Mobile_Buttons

local function Toggle_Mobile_Buttons(Should_Show)
	local All_B = Mobile_Buttons_F:GetChildren()
	for i = 1, #All_B do
		if(All_B[i] ~= nil)then
			All_B[i].Visible = Should_Show
		end
	end
end

local function Toggle_Key_Labels(Should_Show)
	if(Should_Show and UIS.TouchEnabled == false)then
		local function Configure_Buttons()
			local function Update_Tab_Display(T)
				local Key_F = T:FindFirstChild("Key_F")
				local Button_F = T:FindFirstChild("Button_F")
				
				if(Key_F ~= nil and Button_F ~= nil)then
					if(UIS.GamepadEnabled)then
						Key_F.Visible = false
						Button_F.Visible = true
					else
						Key_F.Visible = true
						Button_F.Visible = false
					end
				end
			end
			
			local All_Tabs = Key_Labels_F:GetChildren()
			for i = 1, #All_Tabs do
				local T = All_Tabs[i]
				if(T ~= nil and T:IsA("Frame"))then
					Update_Tab_Display(T)
				end
			end
		end
		Configure_Buttons()
		
		Key_Labels_F:TweenPosition(UDim2.new(1, 0, 0.975, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.5, true, nil)
	else
		Key_Labels_F:TweenPosition(UDim2.new(1.15, 0, 0.975, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.375, true, nil)
	end
end

Toggle_Key_Labels_E.Event:Connect(function(Should_Show)
	Toggle_Key_Labels(Should_Show)
end)


local function Configure_Mobile_Buttons()
	local function Get_Size_Origin_Pos()
		local T_Gui = PG:FindFirstChild("TouchGui")
		if(T_Gui ~= nil and T_Gui:FindFirstChild("TouchControlFrame") ~= nil)then
			local TCF = T_Gui:FindFirstChild("TouchControlFrame")
			local JB = TCF:FindFirstChild("JumpButton")
			
			if(JB ~= nil)then
				local S = JB.Size
				local Main_S = S.X.Offset
				local Split = Main_S / 2
				local Pos = JB.Position
				local Pos_X = Pos.X.Offset + Split
				local Pos_Y = Pos.Y.Offset + Split
				local Origin_Pos = UDim2.new(1, Pos_X, 1, Pos_Y)
				
				return S, Origin_Pos 
			end
		end
		
		return UDim2.new(0, 70, 0, 70), UDim2.new(1, -60, 1, -55)
	end
	local Size, Origin_Pos = Get_Size_Origin_Pos()
	local Scale_Inc = Size.X.Offset * 1.3
	
	local All_B = Mobile_Buttons_F:GetChildren()
	local Button_Data = {

	}
	
	local function Configure_Button(B)
		local Y_Index = B:GetAttribute("Y_Index") or 0
		local X_Index = B:GetAttribute("X_Index") or 0
		local X_Pos = Origin_Pos.X.Offset + (X_Index * Scale_Inc)
		local Y_Pos = Origin_Pos.Y.Offset + (Y_Index * Scale_Inc)
		
		B.Size = Size
		B.Position = UDim2.new(1, X_Pos, 1, Y_Pos)
		B.Visible = true
		Button_Data[B.Name] = B
	end
	
	for i = 1, #All_B do
		local B = All_B[i]
		if(B ~= nil)then
			Configure_Button(B)
		end
	end
	
	return Button_Data
end

Get_Mobile_Buttons_BF.OnInvoke = function()
	return Configure_Mobile_Buttons()
end

Toggle_Mobile_Buttons_E.Event:Connect(function(Should_Show)
	if(UIS.TouchEnabled == false)then
		Should_Show = false
	end
	
	Toggle_Mobile_Buttons(Should_Show)
end)

Bindable_Events_F:WaitForChild("Mobile_Takedown_Toggle").Event:Connect(function(Should_Show)
	if(UIS.TouchEnabled)then
		local B = Mobile_Buttons_F:FindFirstChild("Takedown_B")
		if(B ~= nil)then
			B.Visible = Should_Show
		end
	end
end)

Bindable_RF:WaitForChild("Get_Mobile_Button_Data").OnInvoke = function()
	local B = Mobile_Buttons_F:FindFirstChild("Takedown_B")
	if(B ~= nil)then
		return B.Size, B.Position
	end
	return nil, nil
end

]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX5CFDBA0147CE4AEDABE973E52606E4B1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Server_Fight_Handle.server.lua</string>
						<string name="ScriptGuid">{9239D500-14AD-49AA-840B-7016D7453D90}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	* Everything important should happen on the Server
		-> Hit Detection? Check Player's Hitbox Region
			-> Player Found? Use the Damage Power Val and Multiply it by the Damage Power Bar
			-> Apply Damage to Player's Health Value
			-> Apply Force to Player's RootPart
			
			-> Not Blocking? Play Hit Animation on to the Player, Debounce their ability to hit until
]]--
local Debris = game:GetService("Debris")
local TS = game:GetService("TweenService")
local Plr = script.Parent:FindFirstAncestorWhichIsA("Player")
local PD = Plr:WaitForChild("Player_Data")
local FD = Plr:WaitForChild("Fight_Data")
local Health_V = FD:WaitForChild("Health")
local Block_Power_V = FD:WaitForChild("Block Power")
local Stam_V = FD:WaitForChild("Staminia")
local Strike_Power_V = FD:WaitForChild("Strike Power")
local Char = Plr.Character or Plr.CharacterAdded:Wait()
local Hum = Char:WaitForChild("Humanoid")
local HRP = Char:WaitForChild("HumanoidRootPart")
local Head = Char:WaitForChild("Head")
local Reset_Fight_Health_Data_E = Char:WaitForChild("Reset_Fight_Health_Data")
local Fight_UI = Char:WaitForChild("Fighting_UI")
local Shield_Img = Fight_UI:WaitForChild("Main_F"):WaitForChild("Shield_F"):WaitForChild("Shield_Img")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Sending_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Bindable_E = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Overhead_Display_E = Sending_Events_F:WaitForChild("Overhead_Display")
local Punch_Hit_VFX = Sending_Events_F:WaitForChild("Show_Punch_Effects")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local Sound_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))

local Events_F = script.Parent:WaitForChild("Local_Events_F")
local Heal_PE_TMP = script:WaitForChild("Heal_PE")

local function Compile_Punching_Bags()
	local Gym_Equipment_F = game.Workspace:WaitForChild("Main_World_F"):WaitForChild("ScriptableObjects"):WaitForChild("GymObjects")
	local All_E = Gym_Equipment_F:GetChildren()
	local Bags = {}
	
	for i = 1, #All_E do
		local M = All_E[i]
		if(M ~= nil and M.Name == "PunchingBag" and M:FindFirstChild("PunchingBag") ~= nil)then
			local P_Bag = M:FindFirstChild("PunchingBag")
			local Rope_Con = P_Bag:FindFirstChildWhichIsA("RopeConstraint")
			
			if(Rope_Con ~= nil and P_Bag.Anchored == false)then
				P_Bag:SetNetworkOwner(nil)
				table.insert(Bags, P_Bag)
			end
		end
	end
	
	return Bags
end
local Punching_Bags = Compile_Punching_Bags()

local function Get_Player_Val(Key, Get_Object)
	local Val = PD:FindFirstChild(Key)
	if(Val ~= nil)then
		if(Get_Object)then
			return Val
		else
			return Val.Value
		end
	end

	return nil
end

local function Verify_Player(P)
	if(P ~= nil and P == Plr and Char ~= nil and Hum ~= nil)then
		return true
	end
	return false
end

local function Has_Enough_Stam(Min_V)
	if(Stam_V ~= nil and Stam_V.Value >= Min_V)then
		Stam_V.Value -= Min_V
		return true
	end
	return false
end

Events_F:WaitForChild("Dodging_Strike").OnServerEvent:Connect(function(P)
	if(Verify_Player(P) and Has_Enough_Stam(7))then
		--Play the Sound Effect
		--Toggle Value
		Sound_Mod.Play_Sound_Effect(HRP, "Missed_SE")
		Stam_V:SetAttribute("Is_Dodging", true)
		wait(0.5)
		Stam_V:SetAttribute("Is_Dodging", false)
	end
end)


local function Toggle_Heal_PE(Is_Enabled)
	local All_C = HRP:GetChildren()
	for i = 1, #All_C do
		local C = All_C[i]
		if(C ~= nil and C.Name == "Heal_PE" and C:IsA("ParticleEmitter"))then
			C.Enabled = Is_Enabled
		end
	end
	
	if(Shield_Img ~= nil)then
		if(Is_Enabled)then
			Shield_Img.Image = "rbxassetid://130871917395731"
		else
			Shield_Img.Image = "rbxassetid://125284121534949"
		end
	end
end

Events_F:WaitForChild("Blocking_Strike").OnServerEvent:Connect(function(P)
	if(Verify_Player(P) and Block_Power_V ~= nil and Block_Power_V.Value > 0)then
		Block_Power_V:SetAttribute("Is_Blocking", true)
		Toggle_Heal_PE(true)
	end
end)

Events_F:WaitForChild("Unblocking_Strike").OnServerEvent:Connect(function(P)
	if(Verify_Player(P))then
		Block_Power_V:SetAttribute("Is_Blocking", false)
		Toggle_Heal_PE(false)
	end
end)


local function Get_Player_To_Hit()
	local function Create_Whitelist()
		local All_C = game.Workspace:GetChildren()
		local Ret_Chars = {}
		
		for i = 1, #All_C do
			local C = All_C[i]
			if(C ~= nil and C:IsA("Model") and C:FindFirstChildWhichIsA("Humanoid") ~= nil 
				and C ~= Char and C:FindFirstChildWhichIsA("Humanoid").Health > 0)then
				
				table.insert(Ret_Chars, C)
			end
		end
		
		return Ret_Chars
	end
	local Whitelist_Chars = Create_Whitelist()
	local Overlap_P = OverlapParams.new()
	Overlap_P.MaxParts = 1
	Overlap_P.FilterType = Enum.RaycastFilterType.Include
	Overlap_P.FilterDescendantsInstances = {Whitelist_Chars}
	
	local function Create_Region_CF()
		local Plr_Ping = math.clamp(Plr:GetNetworkPing(), 0, 0.5)
		local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
		local Distance = ((Speed * Plr_Ping) + 3)
		local Head_Dir = Head.CFrame.LookVector
		local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

		--local cframe = CFrame.new(Adjusted_Pos) * HRP.CFrame.Rotation
		local cframe = HRP.CFrame * CFrame.new(0, 0, -3)
		return cframe
	end
	local Spawn_CF = Create_Region_CF()
	local Hitbox_Size = Vector3.new(4, 8, 4)
	
	local function Create_Hitbox_Part()
		local P = Instance.new("Part", game.Workspace)
		P.Name = "Hitbox_Part"
		P.Anchored = true
		P.CanCollide = false
		P.Transparency = 0.5
		P.Color = Color3.new(1, 0, 0)
		P.Material = Enum.Material.SmoothPlastic
		P.Size = Hitbox_Size
		P.CFrame = Spawn_CF
		
		Debris:AddItem(P, 5)
	end
	--Create_Hitbox_Part()
	
	local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
	if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
		local function Get_Char_From_BP()
			for i = 1, #Whitelist_Chars do
				local C = Whitelist_Chars[i]
				if(C ~= nil and Region_Data[1]:IsDescendantOf(C))then
					return C
				end
			end
			
			return Whitelist_Chars[1]
		end
		
		return Get_Char_From_BP()
	end
	
	return nil
end

local function Get_Bag_You_Hit()
	local Overlap_P = OverlapParams.new()
	Overlap_P.MaxParts = 1
	Overlap_P.FilterType = Enum.RaycastFilterType.Include
	Overlap_P.FilterDescendantsInstances = Punching_Bags

	local function Create_Region_CF()
		local Plr_Ping = math.clamp(Plr:GetNetworkPing(), 0, 0.5)
		local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
		local Distance = ((Speed * Plr_Ping) + 3)
		local Head_Dir = Head.CFrame.LookVector
		local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

		return CFrame.new(Adjusted_Pos) * HRP.CFrame.Rotation
	end
	local Spawn_CF = Create_Region_CF()
	local Hitbox_Size = Vector3.new(4, 8, 4)

	local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
	if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
		return Region_Data[1]
	end

	return nil
end

local function Get_Punch_Power()
	local Tween_Punch_Power_Back = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0.75)
	local Strike_Power = Strike_Power_V.Value
	Strike_Power_V.Value = 1
	TS:Create(Strike_Power_V, Tween_Punch_Power_Back, {Value = 6}):Play()
	return Strike_Power
end

local function Get_Target_Fight_Data(Hit_Char)
	local Hit_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
	if(Hit_Plr ~= nil)then
		return Hit_Plr:FindFirstChild("Fight_Data")
	else
		return Hit_Char:FindFirstChild("Fight_Data")
	end
end

Events_F:WaitForChild("Throwing_Strike").OnServerEvent:Connect(function(P, Strike_Key, Dir)
	--> Verify Player, Verify owns the Strike Key, Verify has Enough Stam to throw the Punch
		--> Get & Reset Punch Power
		--> Check if There is a Character within the Region Box 
			--> Are they Blocking and do they have Enough Block Power? ~ Damage the Block Power & Play Damage Text
			--> Are they Dodging? Play the Dodging Text above their Head
			--> Hit them, Apply Health Deduct ~ Apply Force to HRP, Play Sound Effect
			
	if(Verify_Player(P) and HRP ~= nil and Animation_Mod.Player_Owns_Strike_Key(P, Strike_Key) and 
		Has_Enough_Stam(3))then
		
		local Base_Punch_Power = Get_Punch_Power()
		local Hit_Char = Get_Player_To_Hit()
		local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Strike_Key)
		local Power_Inc = Strike_Data['Power Multi'] or 0
		local Punch_Power = math.ceil(Base_Punch_Power * (1  + Power_Inc))
		Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Strikes", 1)
		
		if(Hit_Char ~= nil)then
			local Hit_Fight_Data = Get_Target_Fight_Data(Hit_Char)
			if(Hit_Fight_Data ~= nil and Hit_Fight_Data:FindFirstChild("Health") ~= nil and 
				Hit_Fight_Data:FindFirstChild("Block Power") ~= nil and 
				Hit_Fight_Data:FindFirstChild("Staminia") ~= nil)then
				
				local T_Health = Hit_Fight_Data:FindFirstChild("Health")
				local T_Block_Power = Hit_Fight_Data:FindFirstChild("Block Power")
				local T_Staminia = Hit_Fight_Data:FindFirstChild("Staminia")
				
				local function Is_Dodging_Check()
					local Is_Dodging = T_Staminia:GetAttribute("Is_Dodging")
					if(Is_Dodging ~= nil and Is_Dodging == true)then
						local Target_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
						if(Target_Plr ~= nil)then
							Stats_Manager_Mod.Add_To_Player_Stats_Data(Target_Plr, "Dodged Strikes", 1)
						end
						
						return true
					end
					return false
				end

				local function Is_Blocking_Check()
					local Is_Block = T_Block_Power:GetAttribute("Is_Blocking")
					if(Is_Block ~= nil and Is_Block == true)then
						T_Block_Power.Value -= Punch_Power
						Overhead_Display_E:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.fromRGB(170, 85, 255))
						
						if(T_Block_Power.Value < 0)then
							local Dif = math.abs(T_Block_Power.Value)
							T_Health.Value = math.clamp(T_Health.Value - Dif, 0, 100)
							T_Block_Power.Value = 0
							
							Sound_Mod.Play_Sound_Effect(HRP, "Punch_Hit_SE")
							Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
							
							Overhead_Display_E:FireAllClients(Hit_Char, "-" .. Dif, Color3.new(1, 0, 0))
						
						else
							Sound_Mod.Play_Sound_Effect(HRP, "Blocked_Hit_SE")
						end
						
						return true
					end
					
					return false
				end

				if(Is_Dodging_Check())then
					--Play Dodging Text
					Overhead_Display_E:FireAllClients(Hit_Char, "Dodged", Color3.fromRGB(35, 244, 68))
				elseif(Is_Blocking_Check())then
					--Play Blocking 
				else
					--Apply the Hit
					local function Apply_Strike()
						T_Health.Value = math.clamp(T_Health.Value - Punch_Power, 0, 100)
						Sound_Mod.Play_Sound_Effect(HRP, "Punch_Hit_SE")
						Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
						Overhead_Display_E:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.new(1, 0, 0))
						Punch_Hit_VFX:FireClient(Plr, Hit_Char)
						--Play Damage Val Show
						
						local T_HRP = Hit_Char:FindFirstChild("HumanoidRootPart")
						if(T_HRP ~= nil)then
							local Hit_Force = 625 -- Was 350 then 500
							local Dir = HRP.CFrame.LookVector 
							T_HRP:ApplyImpulse(Dir * Hit_Force * T_HRP:GetMass())
						end
					end
					Apply_Strike()
				end
			end
		
		else
			local Hit_Punching_Bag = Get_Bag_You_Hit()
			if(Hit_Punching_Bag ~= nil)then
				local Hit_Force = 50 -- Was 350 then 500
				local Dir = HRP.CFrame.LookVector 
				Hit_Punching_Bag:ApplyImpulse(Dir * Hit_Force * Hit_Punching_Bag:GetMass())
			end
		end
	end
end)


local function Fight_Data_Growth_Handle()
	--Autonatically Heal the Player when Blocking and Blocking Power is >0
	--Automatically Heal the Block Power 
	repeat wait() until Block_Power_V:GetAttribute("Is_Blocking") ~= nil
	
	local Tween_Health_Con = nil
	local Tween_Stam_Con = nil
	local Tween_Block_Con = nil

	local function Reset_Healing_Cons()
		if(Tween_Health_Con ~= nil)then
			Tween_Health_Con:Cancel()
			Tween_Health_Con = nil
		end
		
		if(Tween_Stam_Con ~= nil)then
			Tween_Stam_Con:Cancel()
			Tween_Stam_Con = nil
		end
	end
	
	local function Set_Healing_Cons()
		local Health_Time = math.clamp((100 - Health_V.Value) * 0.6, 0.6, 60)
		local Tween_Full_Health = TweenInfo.new(Health_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
		Tween_Health_Con = TS:Create(Health_V, Tween_Full_Health, {Value = 100})
		Tween_Health_Con:Play()
		
		local Stam_Time = math.clamp((100 - Stam_V.Value) * 0.1, 0.1, 10)
		local Tween_Full_Stam = TweenInfo.new(Stam_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)	
		Tween_Stam_Con = TS:Create(Stam_V, Tween_Full_Stam, {Value = 100})
		Tween_Stam_Con:Play()
	end

	Block_Power_V.AttributeChanged:Connect(function(Attrib_Key)
		if(Attrib_Key == "Is_Blocking" and Block_Power_V:GetAttribute("Is_Blocking") ~= nil)then
			Reset_Healing_Cons()
			if(Block_Power_V:GetAttribute("Is_Blocking") == true)then
				Set_Healing_Cons()
			end
		end
	end)
	
	local Prev_Block_Val = Block_Power_V.Value
	Block_Power_V.Changed:Connect(function()
		--Wait 3 Seconds, If Block Power not maxed
			--> Tween the 
		local Main_Prev = Prev_Block_Val
		Prev_Block_Val = Block_Power_V.Value
		if(Block_Power_V.Value < 30 and Block_Power_V.Value < Main_Prev)then
			if(Tween_Block_Con ~= nil)then
				Tween_Block_Con:Cancel()
				Tween_Block_Con = nil
			end
			
			local Block_Time = math.clamp((30 - Block_Power_V.Value) * 0.2667, 0.2667, 8)
			local Tween_Block_Power = TweenInfo.new(Block_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 6)
			Tween_Block_Con = TS:Create(Block_Power_V, Tween_Block_Power, {Value = 30})
			Tween_Block_Con:Play()
			Tween_Block_Con.Completed:Wait()
			--Tween_Block_Con:Disconnect()
			Tween_Block_Con = nil
		end
	end)
	
	Reset_Fight_Health_Data_E.Event:Connect(function()
		Reset_Healing_Cons()
		
		if(Tween_Block_Con ~= nil)then
			Tween_Block_Con:Cancel()
			Tween_Block_Con = nil
		end
		
		Health_V.Value = 100
		Stam_V.Value = 100
		Block_Power_V.Value = 30
	end)
end
Fight_Data_Growth_Handle()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX784EABE37B60462B9672F1FF3ECAFA94">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Side_Button_UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX9D0D859BD2824E52BE2A518A60E10770">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Main_Code.client.lua</string>
						<string name="ScriptGuid">{AEAE4384-1F79-4BB6-9888-0F7CB985A985}</string>
						<ProtectedString name="Source"><![CDATA[local MPS = game:GetService("MarketplaceService")
local TS = game:GetService("TweenService")
local SS = game:GetService("SocialService")
local Plr = game.Players.LocalPlayer
local Channel_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channel_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Msg_E = Bindable_Events_F:WaitForChild("Display_Notification")
local Module_F = game.ReplicatedStorage:WaitForChild("Modules_F")
local Monetization_Mod = require(Module_F:WaitForChild("Monetization_Mod"))

local SE = script.Parent.SE
local Main_F = script.Parent.Main_F

local Debounce_E = false
local Debounce_C = false

local GP_Data = Monetization_Mod.Get_All_Gamepass_Data()
local Invite_Options = Instance.new("ExperienceInviteOptions")
Invite_Options.PromptMessage = "Invite your Friends for +10 Health!"
Invite_Options.InviteMessageId = "7b5f8fd4-c329-4f4c-bf16-b833ab2e12ab"

local function Invite_Handle()
	local function Can_Send_Invite()
		local function Async()
			local success, errormessage = pcall(function()
				return SS:CanSendGameInviteAsync(Plr)
			end)

			if(success)then
				return true
			end
			return false
		end

		for i = 1, 3 do
			local D = Async()
			if(D)then
				return D
			end
		end

		return false
	end

	if(Can_Send_Invite())then
		local function Show_Invite()
			local function Async()
				local success, errormessage = pcall(function()
					SS:PromptGameInvite(Plr, Invite_Options)
				end)

				if(success)then
					return true
				end
				return false
			end

			for i = 1, 3 do
				local D = Async()
				if(D)then
					return
				end
			end
		end
		Show_Invite()
	end
end

local function Set_Button_Effects()
	local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
	local All_B = Main_F:GetChildren()
	local Owned_Color_Sequence = ColorSequence.new{
		ColorSequenceKeypoint.new(0, Color3.fromRGB(170, 255, 0)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 170, 0))
	}
	
	
	local function Effects(B)
		local GP_Key = B:GetAttribute("GP_Key")
		if(GP_Key ~= nil and Monetization_Mod.Does_Player_Own_Gamepass(Plr, GP_Key))then
			B:FindFirstChild("UIGradient").Color = Owned_Color_Sequence
		end
		
		B.Selected.MouseEnter:Connect(function()
			if(Debounce_E == false)then
				Debounce_E = true
				SE.Hover_SE:Play()
				B:TweenSize(UDim2.new(0.5, 0, 0.33, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
				wait(0.25)
				Debounce_E = false
			end
		end)
		
		B.Selected.MouseLeave:Connect(function()
			B:TweenSize(UDim2.new(0.375, 0, 0.275, 0), Enum.EasingDirection.In, Enum.EasingStyle.Sine, 0.25, true, nil)
		end)
		
		B.Selected.MouseButton1Click:Connect(function()
			if(Debounce_C == false)then
				Debounce_C = true
				SE.Click_SE:Play()
				TS:Create(B, Tween_Click, {Size = UDim2.new(0.28125, 0, 0.20625, 0)}):Play()
				
				if(B.Name == "Invite_B")then
					Invite_Handle()
				else
					local D = GP_Data[GP_Key]
					
					if(B.UIGradient.Color == Owned_Color_Sequence)then
						Msg_E:Fire(" You already own this gamepass!", Color3.fromRGB(85, 255, 127))
					else
						Msg_E:Fire(" You must purchase the " .. D['Name'] .. " gamepass!!!", Color3.fromRGB(225, 0, 0))
						Monetization_Mod.Prompt_Gamepass_Purchase(Plr, GP_Key)
					end
				end
				
				wait(0.25)
				Debounce_C = false
			end
		end)
	end
	
	for i = 1, #All_B do
		if(All_B[i]:IsA("Frame"))then
			Effects(All_B[i])
		end
	end
	
	local function Purchased_GP_Button_Update(Key)
		for i = 1, #All_B do
			if(All_B[i]:IsA("Frame") and All_B[i]:GetAttribute("GP_Key") ~= nil and 
				All_B[i]:GetAttribute("GP_Key") == Key and All_B[i]:FindFirstChild("UIGradient") ~= nil)then
				
				All_B[i]:FindFirstChild("UIGradient").Color = Owned_Color_Sequence
				return
			end
		end
	end
	
	MPS.PromptGamePassPurchaseFinished:Connect(function(P, ID, Did_Buy)
		if(P == Plr and Did_Buy)then
			local GP_Key = Monetization_Mod.Get_GP_Key_From_ID(ID)
			
			Msg_E:Fire(" You successfully purchased the " .. GP_Key .. " gamepass!", Color3.fromRGB(170, 170, 255))
			Purchased_GP_Button_Update(GP_Key)
		end
	end)
end
Set_Button_Effects()




]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX20A6B1B095E34EC08E7C5AF950B7C66D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Side_Button_Handle.client.lua</string>
						<string name="ScriptGuid">{378CDCAC-7894-4586-B696-D06EFF9B9709}</string>
						<ProtectedString name="Source"><![CDATA[local TS = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local Plr = game.Players.LocalPlayer
local PD = Plr:WaitForChild("Player_Data")
local Cash_V = PD:WaitForChild("Coins")
local Gems_V = PD:WaitForChild("Gems")
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_F = Channels_F:WaitForChild("Bindable_F")
local Bindable_Events_F = Bindable_F:WaitForChild("Events")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Monetization_Mod = require(Data_Mods_F:WaitForChild("Monetization_Mod"))
local Num_Str_Mod = require(Data_Mods_F:WaitForChild("Num_String_Mod"))
local Sound_Effects_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Click_SE = Sound_Effects_Mod.Get_SE_Object(Plr, "Click_SE")
local Hover_SE = Sound_Effects_Mod.Get_SE_Object(Plr, "Hover_SE")
local Cash_SE = Sound_Effects_Mod.Get_SE_Object(Plr, "Cash_SE")
local Gems_SE = Sound_Effects_Mod.Get_SE_Object(Plr, "Gems_SE")

local Right_F = script.Parent.Main_F
local Top_Bar_F = script.Parent.Top_Bar_Buttons_F
local Left_F = script.Parent.Left_Main_F
local Main_Info_F = Left_F.Info_Display_F
local Cash_F = Main_Info_F.Cash_F
local Gems_F = Main_Info_F.Gems_F


local Tween_Click = TweenInfo.new(0.125, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true, 0)
local Debounce_C = false
local Debounce_E = false
local Is_Showing = true

local Event_Data = {
	['Invite_B'] = Bindable_Events_F:WaitForChild("Prompt_Invite"),
	['VC_B'] = Bindable_Events_F:WaitForChild("Voice_Chat_Prompt"),
	['List_B'] = Bindable_Events_F:WaitForChild("Toggle_Player_List"),
	['Settings_B'] = Bindable_Events_F:WaitForChild("Open_Settings"),
	
	['Combos_B'] = Bindable_Events_F:WaitForChild("Open_Combos"),
	['Avatar_B'] = Bindable_Events_F:WaitForChild("Open_Avatar"),
	['Codes_B'] = Bindable_Events_F:WaitForChild("Open_Codes"),
	['Codes_B_2'] = Bindable_Events_F:WaitForChild("Open_Unique_Codes"),
	['Stats_B'] = Bindable_Events_F:WaitForChild("Open_Stats"),
	['Shop_B'] = Bindable_Events_F:WaitForChild("Open_Shop"),
	['Servers_B'] = Bindable_Events_F:WaitForChild("Open_Servers"),
}

local Blur_Data = {
	['Result_Blurr'] = Bindable_Events_F:WaitForChild("Close_Fight_Result"),
	['Codes_Blurr'] = Bindable_Events_F:WaitForChild("Open_Codes"),
	['Codes_Blurr_2'] = Bindable_Events_F:WaitForChild("Open_Unique_Codes"),
	['Stats_Blurr'] = Bindable_Events_F:WaitForChild("Open_Stats"),
	['Emotes_Blur'] = Bindable_Events_F:WaitForChild("Open_Emotes"),
	['Shop_Blurr'] = Bindable_Events_F:WaitForChild("Open_Shop"),
	['Servers_Blurr'] = Bindable_Events_F:WaitForChild("Open_Servers"),
	['Settings_Blurr'] = Bindable_Events_F:WaitForChild("Open_Settings"),
	['Inventory_Blurr'] = Bindable_Events_F:WaitForChild("Open_Appearance"),
}

local function Set_Up_Core_Button_Handle()
	local Main_Tabs = Right_F:GetChildren()
	local Left_Main_Tabs = Left_F:GetChildren() 
	local Top_Tabs = Top_Bar_F:GetChildren()
	
	local function Button_Handle(B)
		local Selected = B:FindFirstChild("Selected")
		local Stroke = B:FindFirstChild("UIStroke")
		local Img = B:FindFirstChildWhichIsA("ImageLabel")
		local Txt = B:FindFirstChildWhichIsA("TextLabel")
		
		Selected.MouseEnter:Connect(function()
			if(Debounce_E == false and Is_Showing)then
				Debounce_E = true
				if(Hover_SE ~= nil)then
					Hover_SE:Play()
				end
				
				Img.ImageColor3 = Color3.fromRGB(200, 200, 200)
				Stroke.Color = Color3.new(1, 1, 1)
				Txt.TextColor3 = Color3.new(1, 1, 1)
				B.BackgroundColor3 = Color3.fromRGB(35, 244, 68)
				B:TweenSize(UDim2.new(0.5, 0, 0.33, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
				
			
				Debounce_E = false
			end
		end)
		
		Selected.MouseLeave:Connect(function()
			Img.ImageColor3 = Color3.new(1, 1, 1)
			Stroke.Color = Color3.fromRGB(35, 244, 68)
			Txt.TextColor3 = Color3.fromRGB(35, 244, 68)
			B.BackgroundColor3 = Color3.fromRGB(75, 75, 75)
			
			B:TweenSize(UDim2.new(0.425, 0, 0.2875, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Sine, 0.25, true, nil)
		end)
		
		Selected.MouseButton1Click:Connect(function()
			if(Debounce_C == false and Is_Showing)then
				Debounce_C = true
				
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				TS:Create(B, Tween_Click, {Size = UDim2.new(0.31875, 0, 0.215625, 0)}):Play()
				
				if(Event_Data[B.Name] ~= nil)then
					Event_Data[B.Name]:Fire()
				end
				
				wait(0.25)
				Debounce_C = false
			end
		end)	
	end
	
	for i = 1, #Main_Tabs do
		local B = Main_Tabs[i]
		if(B ~= nil and B:IsA("Frame") and string.match(B.Name, "_B") ~= nil)then
			Button_Handle(B)
		end
	end
	
	for i = 1, #Left_Main_Tabs do
		local B = Left_Main_Tabs[i]
		if(B ~= nil and B:IsA("Frame") and string.match(B.Name, "_B") ~= nil)then
			Button_Handle(B)
		end
	end
	
	
	local function Top_Bar_Handle(B)
		local Selected = B:FindFirstChild("Selected")
		B.BackgroundColor3 = Color3.new(0, 0, 0)
		
		Selected.MouseEnter:Connect(function()
			if(Debounce_E == false and B.Visible == true)then
				Debounce_E = true
				Hover_SE:Play()
				B.BackgroundColor3 = Color3.fromRGB(75, 75, 75)
				
				Debounce_E = false
			end
		end)
		
		Selected.MouseLeave:Connect(function()
			if(B.Visible == true)then
				B.BackgroundColor3 = Color3.new(0, 0, 0)
			end
		end)
		
		Selected.MouseButton1Click:Connect(function()
			if(Debounce_C == false and B.Visible == true)then
				Debounce_C = true
				if(Click_SE ~= nil)then
					Click_SE:Play()
				end
				
				if(Event_Data[B.Name] ~= nil)then
					Event_Data[B.Name]:Fire()
				end
				
				wait(0.25)
				Debounce_C = false
			end
		end)
	end
	
	for i = 1, #Top_Tabs do
		local B = Top_Tabs[i]
		if(B ~= nil and B:IsA("Frame"))then
			Top_Bar_Handle(B)
		end
	end
end
Set_Up_Core_Button_Handle()

local function Set_Up_Info_Display_Handle(Info_F, Data_V, SE)
	local Data_Txt = Info_F:FindFirstChild("Data_F"):FindFirstChild("Data_Txt")
	local Buy_B = Info_F:FindFirstChild("Buy_B")
	local Selected = Buy_B:FindFirstChild("Selected")
	local Img = Buy_B:FindFirstChild("Plus_Img")
	local Key = string.gsub(Info_F.Name, "_F", "")
	local Debounce_Display = false
	
	local function Update_Display(firstTime)
		Data_Txt.Text = Num_Str_Mod.NumToString(Data_V.Value)
		
		if(Debounce_Display == false)then
			Debounce_Display = true
			TS:Create(Data_Txt, Tween_Click, {Size = UDim2.new(0.78125, 0, 1.09375, 0)}):Play()
			
			if(SE ~= nil) and firstTime ~= true then
				SE:Play()
			end
			
			wait(0.25)
			Debounce_Display = false
		end
		
	end
	Update_Display(true)
	
	Data_V.Changed:Connect(function()
		Update_Display()
	end)
	
	---------------------------------------------
	
	Selected.MouseEnter:Connect(function()
		if(Debounce_E == false and Is_Showing)then
			Debounce_E = true
			
			if(Hover_SE ~= nil)then
				Hover_SE:Play()
			end
			Img.ImageColor3 = Color3.fromRGB(100, 100, 100)
			
			Debounce_E = false
		end
	end)
	
	Selected.MouseLeave:Connect(function()
		Img.ImageColor3 = Color3.new(1, 1, 1)
	end)
	
	Selected.MouseButton1Click:Connect(function()
		if(Debounce_C == false and Is_Showing)then
			Debounce_C = true
			
			if(Click_SE ~= nil)then
				Click_SE:Play()
			end
			TS:Create(Buy_B, Tween_Click, {Size = UDim2.new(0.16875, 0, 0.5625, 0)}):Play()
			Bindable_Events_F:WaitForChild("Open_Shop"):Fire(Key)
			
			wait(0.25)
			Debounce_C = false
		end
	end)
end
Set_Up_Info_Display_Handle(Cash_F, Cash_V, Cash_SE)
Set_Up_Info_Display_Handle(Gems_F, Gems_V, Gems_SE)

local function On_Removal_Handle()
	local function Get_Y_Pos()
		if(UIS.TouchEnabled)then
			return 0.25
		end
		return 0.5
	end
	local Y_Pos = Get_Y_Pos()
	
	local function Toggle_Top_Buttons(Is_Enabled)
		local Tabs = Top_Bar_F:GetChildren()
		for i = 1, #Tabs do
			local T = Tabs[i]
			if(T ~= nil and T:IsA("Frame"))then
				T.Visible = Is_Enabled
			end
		end
	end
	Toggle_Top_Buttons(true)
	
	local function Display_UI(affectBottomBar)
		Right_F:TweenPosition(UDim2.new(1, 0, 0.5, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
		Left_F:TweenPosition(UDim2.new(0, 0, Y_Pos, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Back, 0.75, true, nil)
		Toggle_Top_Buttons(true)

		if(Click_SE ~= nil)then
			Click_SE:Play()
		end
		Is_Showing = true
	end
	Display_UI()
	
	local function Remove_UI()
		Toggle_Top_Buttons(false)
		Right_F:TweenPosition(UDim2.new(1.25, 0, 0.5, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.375, true, nil)
		Left_F:TweenPosition(UDim2.new(-0.25, 0, Y_Pos, 0), Enum.EasingDirection.In, Enum.EasingStyle.Back, 0.375, true, nil)

		if(Click_SE ~= nil)then
			Click_SE:Play()
		end
		Is_Showing = false
	end
	
	Bindable_Events_F:WaitForChild("Toggle_Side_Buttons").Event:Connect(function(Should_Show, affectBottomBar)		
		if(Should_Show == true and Is_Showing == false)then
			Display_UI(affectBottomBar)
		elseif(Should_Show == false and Is_Showing == true)then
			Remove_UI(affectBottomBar)
		end
	end)
	
	Plr.CharacterAdded:Connect(function(Char)
		local Old_Blur = game.Lighting:FindFirstChildWhichIsA("BlurEffect")
		if(Old_Blur == nil and Is_Showing == false)then
			Display_UI()
		end
	end)
end
On_Removal_Handle()

local function Remove_Previous_UI()
	local function Remove_Old_UI(New_Blur)
		local All_C = game.Lighting:GetChildren()
		for i = 1, #All_C do
			local C = All_C[i]
			if(C ~= nil and C:IsA("BlurEffect") and C ~= New_Blur and Blur_Data[C.Name] ~= nil)then
				Blur_Data[C.Name]:Fire()
			end
		end
	end
	
	game.Lighting.ChildAdded:Connect(function(C)
		if(C ~= nil and C:IsA("BlurEffect"))then
			Remove_Old_UI(C)
		end
	end)
end
Remove_Previous_UI()




]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX83812CAF670741228651EB6F713B0317">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Client_Side_Button_Handle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXC2378F7263FE4DAB9F9932C32F7C5035">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Friend_Invite_Handle.client.lua</string>
							<string name="ScriptGuid">{11018E41-63C4-418E-93DF-535B7424AC79}</string>
							<ProtectedString name="Source"><![CDATA[local SS = game:GetService("SocialService")
local VCS = game:GetService("VoiceChatService")
local Plr = game.Players.LocalPlayer
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Display_Data_E = Bindable_Events_F:WaitForChild("Display_Data")

local Invite_Options = Instance.new("ExperienceInviteOptions")
Invite_Options.PromptMessage = "Invite your Friends for +10% Luck!"
Invite_Options.InviteMessageId = "bc7cffbc-7709-214a-8ecb-b6452021927d"

local function Display_Invite_UI(Show_Msg)
	local function Can_Send_Invite()
		local function Async()
			local success, errormessage = pcall(function()
				return SS:CanSendGameInviteAsync(Plr)
			end)

			if(success)then
				return true
			end
			return false
		end

		for i = 1, 3 do
			local D = Async()
			if(D)then
				return D
			end
		end

		return false
	end

	if(Show_Msg)then
		Display_Data_E:Fire(" Invite your Friends to earn more Luck!", Color3.new(1, 1, 0))
	end

	if(Can_Send_Invite())then
		local function Show_Invite()
			local function Async()
				local success, errormessage = pcall(function()
					SS:PromptGameInvite(Plr, Invite_Options)
				end)

				if(success)then
					return true
				end
				return false
			end

			for i = 1, 3 do
				local D = Async()
				if(D)then
					return
				end
			end
		end
		Show_Invite()
	end
end

Bindable_Events_F:WaitForChild("Prompt_Invite").Event:Connect(function()
	Display_Invite_UI(true)
end)


local function VC_Prompt()
	local function Can_Prompt_VC()
		local function Async()
			local Data = nil
			local success, errormessage = pcall(function()
				VCS:IsVoiceEnabledForUserIdAsync(Plr.UserId)
			end)
			
			if(success and Data ~= nil)then
				return Data
			end
			return nil
		end
		
		for i = 1, 3 do
			local D = Async()
			if(D ~= nil)then
				return D
			end
		end	
		
		return false
	end
	
	if(Can_Prompt_VC() == false)then
		local Txt = " You must enable your Voice Chat within your Roblox Settings!"
		Display_Data_E:Fire(Txt, Color3.fromRGB(225, 0, 0))
	else
		local Txt = " Trash Talk with Voice Chat!"
		Display_Data_E:Fire(Txt, Color3.fromRGB(0, 170, 255))
	end
end

Bindable_Events_F:WaitForChild("Voice_Chat_Prompt").Event:Connect(function()
	VC_Prompt()
end)]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX9C1882D7C90748BDADB2EC7000CE7728">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Training_Bot</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX0700F9D91FCB4FF0BD0AB4D9BE9399C7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Animate.client.lua</string>
						<string name="ScriptGuid">{E31241A8-47F0-4A1E-977D-2DBF705D2902}</string>
						<ProtectedString name="Source"><![CDATA[-- humanoidAnimateR15Moods.lua

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local userAnimateScaleRunSuccess, userAnimateScaleRunValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimateScaleRun") end)
local userAnimateScaleRun = userAnimateScaleRunSuccess and userAnimateScaleRunValue

local function getRigScale()
	if userAnimateScaleRun then
		return Character:GetScale()
	else
		return 1
	end
end

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)

-- Clear any existing animation tracks
-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
if animator then
	local animTracks = animator:GetPlayingAnimationTracks()
	for i,track in ipairs(animTracks) do
		track:Stop(0)
		track:Destroy()
	end
end

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			-- When auto scaling is not enabled, the rig scale stands in for
			-- a computed scale.
			return getRigScale()
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return getRigScale()
end

local function rootMotionCompensation(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale
	return runSpeed
end

local smallButNotZero = 0.0001
local function setRunSpeed(speed)
	local normalizedWalkSpeed = 0.5 -- established empirically using current `913402848` walk animation
	local normalizedRunSpeed  = 1
	local runSpeed = rootMotionCompensation(speed)

	local walkAnimationWeight = smallButNotZero
	local runAnimationWeight = smallButNotZero
	local timeWarp = 1

	if runSpeed <= normalizedWalkSpeed then
		walkAnimationWeight = 1
		timeWarp = runSpeed/normalizedWalkSpeed
	elseif runSpeed < normalizedRunSpeed then
		local fadeInRun = (runSpeed - normalizedWalkSpeed)/(normalizedRunSpeed - normalizedWalkSpeed)
		walkAnimationWeight = 1 - fadeInRun
		runAnimationWeight  = fadeInRun
	else
		timeWarp = runSpeed/normalizedRunSpeed
		runAnimationWeight = 1
	end
	currentAnimTrack:AdjustWeight(walkAnimationWeight)
	runAnimTrack:AdjustWeight(runAnimationWeight)
	currentAnimTrack:AdjustSpeed(timeWarp)
	runAnimTrack:AdjustSpeed(timeWarp)
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)
	local heightScale = if userAnimateScaleRun then getHeightScale() else 1
	
	local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
	local speedThreshold = movedDuringEmote and (Humanoid.WalkSpeed / heightScale) or 0.75
	if speed > speedThreshold * heightScale then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if userAnimateScaleRun then
		speed /= getHeightScale()
	end
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
	end
end)

-- emote bindable hook
script:WaitForChild("PlayEmote").OnInvoke = function(emote)
	-- Only play emotes when idling
	if pose ~= "Standing" then
		return
	end

	if emoteNames[emote] ~= nil then
		-- Default emotes
		playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		
		return true, currentAnimTrack
	elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
		-- Non-default emotes
		playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

		return true, currentAnimTrack
	end
	
	-- Return false to indicate that the emote could not be played
	return false
end

if Character.Parent ~= nil then
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
end

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXEB8128967E894EEBAE6552509F46C481">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Init_AI_Training_Bot</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX614D3C988B914013A742F0EBE9990408">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AI_Training_Bot_Handle.server.lua</string>
							<string name="ScriptGuid">{F10D0043-E859-431E-8D1C-7C8E1BFE2305}</string>
							<ProtectedString name="Source"><![CDATA[local RS = game:GetService("RunService")
local TS = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local Init_E = script.Parent
local Char = Init_E.Parent
local Channels_F = game.ReplicatedStorage:WaitForChild("Channels_F")
local Bindable_Events_F = Channels_F:WaitForChild("Bindable_F"):WaitForChild("Events")
local Sending_Events_F = Channels_F:WaitForChild("Server_Client_F"):WaitForChild("Events")
local Overhead_Display_E = Sending_Events_F:WaitForChild("Overhead_Display")
local Data_Mods_F = game.ReplicatedStorage:WaitForChild("Data_Mods_F")
local Animation_Mod = require(Data_Mods_F:WaitForChild("Animation_Mod"))
local SE_Mod = require(Data_Mods_F:WaitForChild("Sound_Effect_Mod"))
local Stats_Manager_Mod = require(Data_Mods_F:WaitForChild("Stats_Manager_Mod"))
local HRP = Char:WaitForChild("HumanoidRootPart")
local Hum = Char:WaitForChild("Humanoid")
local Head = Char:WaitForChild("Head")
local Fight_Data_F = Char:WaitForChild("Fight_Data")
local Stamina_V = Fight_Data_F:WaitForChild("Staminia") -- adjust name if it's 'Stamina'

-- Direct stamina regeneration for bot (server-side)
local function Reload_Stamina()
	while Stamina_V.Value < 40 do
		Stamina_V.Value = math.min(Stamina_V.Value + 1, 100) -- regen step, adjust as needed
		task.wait(0.1)
	end
end
local Fight_UI = Char:WaitForChild("Fighting_UI")
local Health_V = Fight_Data_F:WaitForChild("Health")
local Stam_V = Fight_Data_F:WaitForChild("Staminia")
local Block_Power_V = Fight_Data_F:WaitForChild("Block Power")
local Strike_Power_V = Fight_Data_F:WaitForChild("Strike Power")

local Fight_Walkspeed = 12
local Is_Active = false
local Cons = {}
local function Disconnect_Cons()
	for i = 1, #Cons do
		if(Cons[i] ~= nil)then
			Cons[i]:Disconnect()
		end
	end
	table.clear(Cons)
end

local function Get_Fighting_UI()
	local Fight_UI = Char:FindFirstChild("Fighting_UI")
	if(Fight_UI ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil) then
		local Main_F = Fight_UI:FindFirstChild("Main_F") 
		local Damage_Bar = Main_F:FindFirstChild("Damage_Bar_Img")
		if(Damage_Bar ~= nil and Damage_Bar:FindFirstChildWhichIsA("UIGradient") ~= nil)then
			return Damage_Bar, Damage_Bar:FindFirstChildWhichIsA("UIGradient")
		end
	end

	return nil, nil
end

local function Reset_AI()
	Disconnect_Cons()

	Health_V.Value = 100
	Stam_V.Value = 100
	Block_Power_V.Value = 30
	Strike_Power_V.Value = 6

	if(HRP ~= nil and HRP:FindFirstChildWhichIsA("BodyGyro") ~= nil)then
		HRP:FindFirstChildWhichIsA("BodyGyro"):Destroy()
	end

	if(Hum ~= nil)then
		Hum.AutoRotate = false
		Hum.WalkSpeed = 12
		Hum.JumpPower = 0

		Animation_Mod.Reset_Character_Animations(Char)

		Hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.Climbing, false)
		Hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
	end

	Char:SetAttribute("Is_Fighting", false)
	Is_Active = false
end

local function Core_AI_Handle(T_Plr, T_Char)
	local T_HRP = T_Char:WaitForChild("HumanoidRootPart")
	local T_Fight_Data = T_Plr:FindFirstChild("Fight_Data")
	local T_Health_V = T_Fight_Data:WaitForChild("Health")
	local T_Stam_V = T_Fight_Data:WaitForChild("Staminia")
	local T_Block_Power_V = T_Fight_Data:WaitForChild("Block Power")
	local T_Strike_Power_V = T_Fight_Data:WaitForChild("Strike Power")
	local Is_Submission = false

	Char:SetAttribute("Is_Fighting", true)
	Reset_AI()
	Is_Active = true

	wait(3)
	if(Is_Active == false)then
		return
	end

	--Fight Data Changes
	table.insert(Cons, Health_V.Changed:Connect(function()
		if(Char ~= nil and Health_V.Value <= 0)then
			Bindable_Events_F:WaitForChild("Ragdoll_Player"):Fire(Char)
		end
	end))

	local function Create_BG()
		local OldG = HRP:FindFirstChildWhichIsA("BodyGyro")
		if(OldG ~= nil)then
			OldG:Destroy()
		end

		local bodyG = Instance.new("BodyGyro", HRP)
		bodyG.P = 1000
		bodyG.MaxTorque = Vector3.new(0, 1000, 0)
		bodyG.D = 10

		return bodyG
	end
	local BG = Create_BG()

	local function Movement_Handle()
		local function Update_Player_Movement()
			local function Get_Target_Position()
				if(T_HRP ~= nil)then
					local Move_Speed = T_HRP.Velocity
					local Def_Pos = T_HRP.Position + T_HRP.CFrame.LookVector * 3.5

					if(math.floor(Move_Speed.Magnitude) <= 0)then
						return Def_Pos, T_HRP.Position
					else
						local Ping = T_Plr:GetNetworkPing()
						local Dir = Move_Speed.Unit
						local Speed = Move_Speed.Magnitude
						local Extrapolated_Pos = Def_Pos + Dir * (Speed * Ping)
						local Travel_Time = ((Extrapolated_Pos - HRP.Position).Magnitude) / Hum.WalkSpeed
						return Extrapolated_Pos + Dir * (Hum.WalkSpeed * Travel_Time), Extrapolated_Pos
					end
				end

				return HRP.Position, HRP.Position + HRP.CFrame.LookVector * 3
			end
			local Move_Pos, Look_Pos = Get_Target_Position()

			BG.CFrame = CFrame.new(HRP.Position, Look_Pos)
			Hum:MoveTo(Move_Pos)
		end

		table.insert(Cons, RS.Stepped:Connect(function()
			if(BG ~= nil and HRP ~= nil and Hum ~= nil and Hum.PlatformStand == false and T_Plr ~= nil and T_HRP ~= nil)then
				if(T_Health_V ~= nil and T_Health_V.Value > 0 and Is_Submission == false)then
					Update_Player_Movement()
				else
					Hum:MoveTo(HRP.Position)
				end
			end
		end))

		table.insert(Cons, Hum:GetPropertyChangedSignal("PlatformStand"):Connect(function()
			if(Hum.PlatformStand == true)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			else
				BG.P = 1000
				BG.MaxTorque = Vector3.new(0, 1000, 0)
				BG.D = 10
			end
		end))
	end
	Movement_Handle()

	local Damage_Bar_Img, Damage_UIG = Get_Fighting_UI()
	if(Damage_Bar_Img ~= nil and Damage_UIG ~= nil)then
		Damage_UIG.Offset = Vector2.new(0, -0.5)
		Damage_Bar_Img.Visible = false
	end

	local function Create_Anim_Arr_Data(Anim_Track_Data)
		local D = {}
		for Key, Anim_Track in next, Anim_Track_Data do
			table.insert(D, Anim_Track)
		end
		return D
	end

	local Striking_Anim_Tracks = Animation_Mod.Get_Striking_Animation_Tracks(Hum)
	local Striking_Anim_Arr = Create_Anim_Arr_Data(Striking_Anim_Tracks)
	local Combo_Strike_Index = 1
	local Combo_Anim_Arr = Animation_Mod.Get_Striking_Combination_Tracks(T_Plr, Hum)
	local Anim_Track_Data = Animation_Mod.Get_Movement_Animation_Tracks(Hum)
	local Anim_Arr_Data = Create_Anim_Arr_Data(Anim_Track_Data)

	local Debounce_Striking = false
	local Debounce_Dodge = false
	local Debounce_Blocking = false
	local Debounce_Takedown = false
	local Is_Hit = false

	local function Striking_Movement_Handle()
		--> Update Movement, Moving Forward or Backwards | Moving Left to Right | Standing Idle
		--> Track Humanoid MoveDirection
		table.insert(Cons, Hum:GetPropertyChangedSignal("WalkToPoint"):Connect(function()
			local Move_Speed = math.floor(HRP.Velocity.Magnitude)
			if(Move_Speed > 3 and Anim_Track_Data['Shuffle Forward'].IsPlaying == false)then
				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
				Anim_Track_Data['Shuffle Forward']:Play()
				Anim_Track_Data['Shuffle Forward']:AdjustSpeed(-1)

			elseif(Move_Speed <= 3 and 
				(Anim_Track_Data['Shuffle Forward'].IsPlaying == true or 
					Anim_Track_Data['Shuffle Side'].IsPlaying == true))then

				Animation_Mod.Stop_Animation_Tracks(Anim_Arr_Data, {Anim_Track_Data['Idle']})
			end
		end))

		Anim_Track_Data['Idle']:Play()
		Anim_Track_Data['Idle']:AdjustSpeed(0.5)
	end
	Striking_Movement_Handle()

	local function On_Hit_Effects()
		--[[
			* When Health goes Down!
				> Camera Shake Effects
					-> Quick Shake
				> Apply Hit Effects
					-> Reset all Animations, Play the Hit One
				> Set Debounce till Hit Effect goes Away
		]]--

		local Prev_Health = Health_V.Value
		local Hit_Anim_Track = Striking_Anim_Tracks['Taking Hit']

		local function Show_Sweat_Effects()
			if(Head ~= nil and Head:FindFirstChild("Sweat_VFX"))then
				local Sweat_VFX = Head:FindFirstChild("Sweat_VFX")
				local PE = Sweat_VFX:FindFirstChildWhichIsA("ParticleEmitter")
				if(PE ~= nil)then
					PE:Emit(25)
				end
			end
		end

		table.insert(Cons, Health_V.Changed:Connect(function()
			local Current_V = Health_V.Value
			if(Current_V < Prev_Health and Is_Hit == false)then
				Is_Hit = true

				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Show_Sweat_Effects()

				task.spawn(function()
					Animation_Mod.Play_Animation_Track(Hit_Anim_Track)
					Is_Hit = false
				end)
			end

			Prev_Health = Current_V
		end))
	end
	On_Hit_Effects()

	local function Blocking_Effects()
		--[[
			* On Sheild Blocking Power goes down (Greater than 0) and Debounce_Blocking == true
			* Get the Opponent Handed Type
				> Play the Coresponding Animation
		]]--

		local Prev_Blocking = Block_Power_V.Value
		local Tween_Health_Con = nil
		local Tween_Stam_Con = nil
		local Tween_Block_Con = nil
		Block_Power_V:SetAttribute("Is_Blocking", false)

		local function Reset_Healing_Cons()
			if(Tween_Health_Con ~= nil)then
				Tween_Health_Con:Cancel()
				Tween_Health_Con = nil
			end

			if(Tween_Stam_Con ~= nil)then
				Tween_Stam_Con:Cancel()
				Tween_Stam_Con = nil
			end
		end

		local function Set_Healing_Cons()
			local Health_Time = math.clamp((100 - Health_V.Value) * 0.6, 0.6, 60)
			local Tween_Full_Health = TweenInfo.new(Health_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)
			Tween_Health_Con = TS:Create(Health_V, Tween_Full_Health, {Value = 100})
			Tween_Health_Con:Play()

			local Stam_Time = math.clamp((100 - Stam_V.Value) * 0.1, 0.1, 10)
			local Tween_Full_Stam = TweenInfo.new(Stam_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0)	
			Tween_Stam_Con = TS:Create(Stam_V, Tween_Full_Stam, {Value = 100})
			Tween_Stam_Con:Play()
		end

		table.insert(Cons, Block_Power_V.AttributeChanged:Connect(function(Attrib_Key)
			if(Attrib_Key == "Is_Blocking" and Block_Power_V:GetAttribute("Is_Blocking") ~= nil)then
				Reset_Healing_Cons()
				if(Block_Power_V:GetAttribute("Is_Blocking") == true)then
					Set_Healing_Cons()
				end
			end
		end))


		local function Update_Fight_Block_UI()
			if(Fight_UI ~= nil and Block_Power_V ~= nil and Fight_UI:FindFirstChild("Main_F") ~= nil and 
				Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F") ~= nil)then

				local Sheild_F = Fight_UI:FindFirstChild("Main_F"):FindFirstChild("Shield_F")
				local Img = Sheild_F:FindFirstChild("Shield_Img")
				local Txt = Sheild_F:FindFirstChild("Shield_Txt")

				if(Img ~= nil and Txt ~= nil and Img:FindFirstChildWhichIsA("UIGradient") ~= nil)then
					local UIG = Img:FindFirstChildWhichIsA("UIGradient")
					local Block_Power = Block_Power_V.Value
					local Dif =  math.clamp(Block_Power / 30, 0, 1)
					local Offset_Pos_Y = (1 - Dif) - 0.5

					UIG.Offset = Vector2.new(0, Offset_Pos_Y)
					Txt.Text = Block_Power .. ""
					if(Dif <= 0.25)then
						Txt.TextColor3 = Color3.new(1, 0, 0)
					else
						Txt.TextColor3 = Color3.new(1, 1, 1)
					end

				end
			end

		end

		table.insert(Cons, Block_Power_V.Changed:Connect(function()
			local Current_V = Block_Power_V.Value
			if(Current_V > 0 and Current_V < Prev_Blocking and Debounce_Blocking == true)then
				Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Striking_Anim_Tracks['Body Block Left'])

				if(Block_Power_V.Value < 30)then
					if(Tween_Block_Con ~= nil)then
						Tween_Block_Con:Cancel()
						Tween_Block_Con = nil
					end

					local Block_Time = math.clamp((30 - Block_Power_V.Value) * 0.2667, 0.2667, 8)
					local Tween_Block_Power = TweenInfo.new(Block_Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 6)
					Tween_Block_Con = TS:Create(Block_Power_V, Tween_Block_Power, {Value = 30})
					Tween_Block_Con:Play()
					Tween_Block_Con.Completed:Wait()
					Tween_Block_Con = nil
				end
			end

			Update_Fight_Block_UI()
			Prev_Blocking = Current_V

		end))

	end
	Blocking_Effects()

	local function Get_Core_Strike_Handles()
		local Funcs = {}
		local Woosh_SE = SE_Mod.Get_SE_Object(T_Plr, "Punch_Woosh_SE")

		local function Has_Enough_Stam(Min_V)
			if(Stam_V ~= nil and Stam_V.Value >= Min_V)then
				Stam_V.Value -= Min_V
				return true
			end
			return false
		end

		local function Get_Player_To_Hit()
			local Whitelist_Chars = {T_Char}
			local Overlap_P = OverlapParams.new()
			Overlap_P.MaxParts = 1
			Overlap_P.FilterType = Enum.RaycastFilterType.Include
			Overlap_P.FilterDescendantsInstances = {Whitelist_Chars}

			local function Create_Region_CF()
				local Speed = math.clamp(HRP.Velocity.Magnitude, 0, 16)
				local Distance = (Speed + 3)
				local Head_Dir = Head.CFrame.LookVector
				local Adjusted_Pos = HRP.Position + (Head_Dir * Distance)

				local cframe = HRP.CFrame * CFrame.new(0, 0, -3)
				return cframe
			end
			local Spawn_CF = Create_Region_CF()
			local Hitbox_Size = Vector3.new(4, 8, 4)

			local function Create_Hitbox_Part()
				local P = Instance.new("Part", game.Workspace)
				P.Name = "Hitbox_Part"
				P.Anchored = true
				P.CanCollide = false
				P.Transparency = 0.5
				P.Color = Color3.new(1, 0, 0)
				P.Material = Enum.Material.SmoothPlastic
				P.Size = Hitbox_Size
				P.CFrame = Spawn_CF

				Debris:AddItem(P, 5)
			end
			--Create_Hitbox_Part()

			local Region_Data = game.Workspace:GetPartBoundsInBox(Spawn_CF, Hitbox_Size, Overlap_P)
			if(Region_Data ~= nil and #Region_Data > 0 and Region_Data[1] ~= nil)then
				local function Get_Char_From_BP()
					for i = 1, #Whitelist_Chars do
						local C = Whitelist_Chars[i]
						if(C ~= nil and Region_Data[1]:IsDescendantOf(C))then
							return C
						end
					end

					return Whitelist_Chars[1]
				end

				return Get_Char_From_BP()
			end

			return nil
		end

		local function Get_Punch_Power()
			local Tween_Punch_Power_Back = TweenInfo.new(1.75, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)
			local Strike_Power = Strike_Power_V.Value
			Strike_Power_V.Value = 0
			TS:Create(Strike_Power_V, Tween_Punch_Power_Back, {Value = 6}):Play()
			return Strike_Power
		end

		local function Get_Target_Fight_Data(Hit_Char)
			local Hit_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
			if(Hit_Plr ~= nil)then
				return Hit_Plr:FindFirstChild("Fight_Data")
			else
				return Hit_Char:FindFirstChild("Fight_Data")
			end
		end

		function Funcs.Strike_Handle()
			if Stamina_V.Value < 20 then Reload_Stamina() end
			--[[
				* Play Woosh Sound Effect locally
				* Play Animation
				* Tell the Server that you are Striking
			]]--

			Debounce_Striking = true
			-- AI is Striking!
			if(Woosh_SE ~= nil)then
				Woosh_SE:Play()
			end

			local function Play_Strike_Animation()
				local Track = Combo_Anim_Arr[Combo_Strike_Index]
				local Key = Track:GetAttribute("Strike_Key") or "A"

				task.spawn(function()
					if(HRP ~= nil and Has_Enough_Stam(10))then
						local Base_Punch_Power = Get_Punch_Power()
						local Hit_Char = Get_Player_To_Hit()
						local Strike_Data = Animation_Mod.Get_Strike_Combo_Data(Key)
						local Power_Inc = Strike_Data['Power Multi'] or 0
						local Punch_Power = math.ceil(Base_Punch_Power * (1  + Power_Inc))
						--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Total Strikes", 1)

						if(Hit_Char ~= nil)then
							local Hit_Fight_Data = Get_Target_Fight_Data(Hit_Char)
							if(Hit_Fight_Data ~= nil and Hit_Fight_Data:FindFirstChild("Health") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Block Power") ~= nil and 
								Hit_Fight_Data:FindFirstChild("Staminia") ~= nil)then

								local T_Health = Hit_Fight_Data:FindFirstChild("Health")
								local T_Block_Power = Hit_Fight_Data:FindFirstChild("Block Power")
								local T_Staminia = Hit_Fight_Data:FindFirstChild("Staminia")

								local function Is_Dodging_Check()
									local Is_Dodging = T_Staminia:GetAttribute("Is_Dodging")
									if(Is_Dodging ~= nil and Is_Dodging == true)then
										local Target_Plr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if(Target_Plr ~= nil)then
											Stats_Manager_Mod.Add_To_Player_Stats_Data(Target_Plr, "Dodged Strikes", 1)
										end

										return true
									end
									return false
								end

								local function Is_Blocking_Check()
									local Is_Block = T_Block_Power:GetAttribute("Is_Blocking")
									if(Is_Block ~= nil and Is_Block == true)then
										T_Block_Power.Value -= Punch_Power
										Overhead_Display_E:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.fromRGB(170, 85, 255))

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Sending_Events_F:WaitForChild("Got_Hit_Effect"):FireClient(targetPlr)
										end

										if(T_Block_Power.Value < 0)then
											local Dif = math.abs(T_Block_Power.Value)
											T_Health.Value = math.clamp(T_Health.Value - Dif, 0, 100)
											T_Block_Power.Value = 0

											SE_Mod.Play_Sound_Effect(HRP, "Punch_Hit_SE")
											--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)

											Overhead_Display_E:FireAllClients(Hit_Char, "-" .. Dif, Color3.new(1, 0, 0))

										else
											SE_Mod.Play_Sound_Effect(HRP, "Blocked_Hit_SE")	
										end

										return true
									end

									return false
								end

								if(Is_Dodging_Check())then
									--Play Dodging Text
									Overhead_Display_E:FireAllClients(Hit_Char, "Dodged", Color3.fromRGB(35, 244, 68))
								elseif(Is_Blocking_Check())then
									--Play Blocking 
								else
									--Apply the Hit
									local function Apply_Strike()
										T_Health.Value = math.clamp(T_Health.Value - Punch_Power, 0, 100)
										SE_Mod.Play_Sound_Effect(HRP, "Punch_Hit_SE")
										--Stats_Manager_Mod.Add_To_Player_Stats_Data(Plr, "Strikes Landed", 1)
										Overhead_Display_E:FireAllClients(Hit_Char, "-" .. Punch_Power, Color3.new(1, 0, 0))
										--Punch_Hit_VFX:FireClient(Plr, Hit_Char)
										--Play Damage Val Show

										local targetPlr = game.Players:GetPlayerFromCharacter(Hit_Char)
										if targetPlr ~= nil then
											Sending_Events_F:WaitForChild("Got_Hit_Effect"):FireClient(targetPlr)
										end

										local T_HRP = Hit_Char:FindFirstChild("HumanoidRootPart")
										if(T_HRP ~= nil)then
											local Hit_Force = 625 -- Was 350 then 500
											local Dir = HRP.CFrame.LookVector 
											T_HRP:ApplyImpulse(Dir * Hit_Force * T_HRP:GetMass())
										end
									end
									Apply_Strike()
								end
							end

						end
					end
				end)

				Combo_Strike_Index += 1
				if(Combo_Strike_Index > #Combo_Anim_Arr)then
					Combo_Strike_Index = 1
				end

				Animation_Mod.Stop_Animation_Tracks(Combo_Anim_Arr, {})
				Animation_Mod.Play_Animation_Track(Track)
			end
			task.spawn(Play_Strike_Animation)
			wait(0.5)

			Debounce_Striking = false
		end

		local Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left']
		local Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		local Back_Dodge_Ani = Striking_Anim_Tracks['Slip Right']
		function Funcs.Dodge_Handle(Dodge_Type)
			--[[
				* Get the Type First
					-> First Index? Just play the Slip Animation
					-> 2nd Index? Play the Dodge Animation AND apply Force to the Player in the direction
				
					-> Tell the Server that you are Dodging and should reduce Staminia Value
			]]--

			Debounce_Dodge = true
			-- AI is Dodging

			local function Apply_Force(Dir)
				HRP:ApplyImpulse(Dir * (Fight_Walkspeed * 65) * HRP:GetMass())
			end

			task.spawn(function()
				if(Has_Enough_Stam(5))then
					--Play the Sound Effect
					--Toggle Value
					SE_Mod.Play_Sound_Effect(HRP, "Missed_SE")
					Stam_V:SetAttribute("Is_Dodging", true)
					wait(0.5)
					Stam_V:SetAttribute("Is_Dodging", false)
				end
			end)
			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})

			local function Increment_Anim()
				if(Dodge_Type == "Dodge Left")then
					if(Left_Dodge_Ani == Striking_Anim_Tracks['Slip Left'])then
						Left_Dodge_Ani = Striking_Anim_Tracks['Headblock Left']
					else
						Left_Dodge_Ani = Striking_Anim_Tracks['Slip Left'] 
					end
				else
					--Right
					if(Right_Dodge_Ani == Striking_Anim_Tracks['Slip Right'])then
						Right_Dodge_Ani = Striking_Anim_Tracks['Headblock Right']
					else
						Right_Dodge_Ani = Striking_Anim_Tracks['Slip Right'] 
					end
				end
			end

			if(Dodge_Type == "Dodge Left")then
				--Left
				if(Left_Dodge_Ani == Striking_Anim_Tracks['Headblock Left'])then
					--Apply_Force(HRP.CFrame.RightVector * -1)
				end
				Apply_Force(HRP.CFrame.RightVector * -1)
				Animation_Mod.Play_Animation_Track(Left_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Right")then
				--Right
				if(Right_Dodge_Ani == Striking_Anim_Tracks['Headblock Right'])then
					--Apply_Force(HRP.CFrame.RightVector)
				end
				Apply_Force(HRP.CFrame.RightVector)
				Animation_Mod.Play_Animation_Track(Right_Dodge_Ani)
				Increment_Anim()

			elseif(Dodge_Type == "Dodge Back")then
				Apply_Force(HRP.CFrame.LookVector * -1)
				Animation_Mod.Play_Animation_Track(Back_Dodge_Ani)
			end

			Debounce_Dodge = false
		end

		local function Toggle_Sheild_Icon(Is_Enabled)
			local Main_F =  Fight_UI:FindFirstChild("Main_F")
			if(Main_F ~= nil and Main_F:FindFirstChild("Shield_F") ~= nil)then
				local SF = Main_F:FindFirstChild("Shield_F")
				local Img = SF:FindFirstChild("Shield_Img")

				if(Img ~= nil)then
					if(Is_Enabled)then
						Img.Image = "rbxassetid://130871917395731"
					else
						Img.Image = "rbxassetid://125284121534949"
					end
				end
			end
		end

		local function Toggle_Heal_PE(Is_Enabled)
			local PE = HRP:GetChildren()
			for i = 1, #PE do
				if(PE[i] ~= nil and PE[i].Name == "Heal_PE" and PE[i]:IsA("ParticleEmitter"))then
					PE[i].Enabled = Is_Enabled
				end
			end

			Toggle_Sheild_Icon(Is_Enabled)
		end

		local Low_Block_Con = nil
		local function Disable_Blocking_Handle()
			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = Fight_Walkspeed
			end

			Animation_Mod.Stop_Animation_Tracks(Striking_Anim_Arr, {})
			Block_Power_V:SetAttribute("Is_Blocking", false)
			Toggle_Heal_PE(false)

			Debounce_Blocking = false
		end

		local function Play_Blocking_Animation()
			local Anim_Track = Striking_Anim_Tracks['Main Block']
			if(Anim_Track ~= nil)then
				Anim_Track:Play()
				Anim_Track:AdjustSpeed(1)
				wait(Anim_Track.Length * 0.9)

				if(Anim_Track ~= nil and Debounce_Blocking == true)then
					Anim_Track:AdjustSpeed(0)
				end
			end
		end

		function Funcs.Disable_Blocking_Handle()
			-- AI is turning off Blocking
			Disable_Blocking_Handle()
		end

		function Funcs.Blocking_Handle()
			Debounce_Blocking = true
			-- AI Is Blocking

			if(Hum ~= nil)then
				Hum.WalkSpeed = 8
			end

			if(Low_Block_Con ~= nil)then
				Low_Block_Con:Disconnect()
				Low_Block_Con = nil
			end

			Low_Block_Con = Block_Power_V.Changed:Connect(function()
				if(Block_Power_V.Value <= 0 and Debounce_Blocking == true)then
					if(Low_Block_Con ~= nil)then
						Low_Block_Con:Disconnect()
						Low_Block_Con = nil
					end

					Disable_Blocking_Handle()
				end
			end)
			table.insert(Cons, Low_Block_Con)
			task.spawn(Play_Blocking_Animation)

			if(Block_Power_V ~= nil and Block_Power_V.Value > 0)then
				Block_Power_V:SetAttribute("Is_Blocking", true)
				Toggle_Heal_PE(true)
			end
		end

		function Funcs.Get_Hitbox_Res()
			return (Get_Player_To_Hit() ~= nil)
		end		

		function Funcs.Get_Dodge_Type()
			local function Get_Ray_Distance_Data()
				local Origin = HRP.Position
				local Ray_Parm = RaycastParams.new()
				Ray_Parm.FilterType = Enum.RaycastFilterType.Exclude
				Ray_Parm.FilterDescendantsInstances = {Char, T_Char}

				local function Get_Ray_Dist(Dir)
					local Ray_Res = game.Workspace:Raycast(Origin, Dir * 10, Ray_Parm)
					if(Ray_Res ~= nil and Ray_Res.Distance ~= nil)then
						return Ray_Res.Distance
					end
					return 15
				end

				return {
					{
						['Type'] = "Dodge Back",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.LookVector * -1)
					},

					{
						['Type'] = "Dodge Left",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector * -1)
					},

					{
						['Type'] = "Dodge Right",
						['Distance'] = Get_Ray_Dist(HRP.CFrame.RightVector)
					},

				}
			end
			local Ray_Dist_Arr = Get_Ray_Distance_Data()

			table.sort(Ray_Dist_Arr, function(A, B)
				return A['Distance'] > B['Distance']
			end)

			return Ray_Dist_Arr[1]['Type']
		end

		function Funcs.Is_Player_Striking_You()
			if(T_Strike_Power_V ~= nil and T_Strike_Power_V.Value < 4)then
				return true
			end
			return false
		end

		return Funcs
	end
	local Core_Strike_Funcs = Get_Core_Strike_Handles()

	--[[
		Core AI Decision Making goes here
		
		* If within Striking Distance ~ 5 Studs
			* If Player is Striking too, Dodge Left Right or Back (Max 2 Dodges)
			* Has to Strike (Max 3 Strikes)
				* Dodge Back if Strike (or left or Right)
		* Default to Blocking Handle
	]]--

	local function Submission_Handle(Is_Submitting, Attacking_Char)
		Animation_Mod.Reset_Character_Animations(Char)
		if(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end

		if(Is_Submitting)then
			Is_Submission = true
			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end

			if(HRP ~= nil)then
				--HRP.Anchored = true
				--HRP.CFrame *= CFrame.new(Vector3.new(0, 0.15, 0))
			end

			--> Play Animation
			--> Get Submission Character & Player
			--> Get their Takedown and Submission Data

			--> If Attacking Player, Set HRP CFrame Position
			--> Play Take Down Animation

			--> Play Submission Animation
			--> Play Submission Loop Animation

			local function Get_Takedown_Submission_Tracks()
				local Takedown_Data, Submission_Data = Animation_Mod.Get_Takedown_Submission_Data(Attacking_Char)
				return Animation_Mod.Get_Takedown_Submission_Tracks(Hum, Takedown_Data['Receiving ID'], Submission_Data['Receiving ID'], Submission_Data['Receiving Loop ID'])
			end
			local Takedown_Track, Submission_Track, Submission_Loop_Track = Get_Takedown_Submission_Tracks()

			Takedown_Track.Priority = Enum.AnimationPriority.Action2
			Animation_Mod.Play_Animation_Track(Takedown_Track, true)

			wait(0.25)

			Submission_Track.Priority = Enum.AnimationPriority.Action3
			Animation_Mod.Play_Animation_Track(Submission_Track)

			Submission_Loop_Track.Priority = Enum.AnimationPriority.Action4
			Animation_Mod.Play_Animation_Track(Submission_Loop_Track)
		else
			Is_Hit = false

			if(HRP ~= nil)then
				HRP.Anchored = false
			end

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
			Is_Submission = false
		end
	end

	table.insert(Cons, Bindable_Events_F:WaitForChild("AI_Training_Submission").Event:Connect(function(AI_Char, Attacking_Char, Is_Submitting)
		if(AI_Char == Char)then
			Submission_Handle(Is_Submitting, Attacking_Char)
		end
	end))


	local function Clinch_Handle(Animation_Sequence_Data, Is_Attacking)
		local function Freeze_Character()
			Animation_Mod.Reset_Character_Animations(Char)

			if(Debounce_Blocking == true)then
				task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
			end

			Is_Hit = true
			if(BG ~= nil)then
				BG.P = 0
				BG.MaxTorque = Vector3.new(0, 0, 0)
				BG.D = 0
			end

			if(Hum ~= nil)then
				Hum.WalkSpeed = 0
			end
		end
		Freeze_Character()

		local function Play_Strike_Sequences()
			local Clinch_Tracks_Data = Animation_Mod.Get_Cage_Clinch_Tracks(Hum, Is_Attacking)
			Animation_Mod.Play_Animation_Track(Clinch_Tracks_Data['Init_Clinch'], true)
			task.spawn(Animation_Mod.Play_Animation_Track, Clinch_Tracks_Data['Loop_Clinch'])
			wait(1)

			for i = 1, #Animation_Sequence_Data do
				local Strike_Key = Animation_Sequence_Data[i]
				local Strike_Track = Clinch_Tracks_Data[Strike_Key]

				if(Strike_Track ~= nil)then
					--Play Flash, Play Hit Sound Effect, Quick Camera Shake
					Animation_Mod.Play_Animation_Track(Strike_Track)
					--wait(0.5)
				end
			end

		end
		Play_Strike_Sequences()

		local function Clinch_Reset_Handle()
			Animation_Mod.Reset_Character_Animations(Char)
			Is_Hit = false

			if(Hum ~= nil)then
				if(BG ~= nil and Hum.PlatformStand == false)then
					BG.P = 1000
					BG.MaxTorque = Vector3.new(0, 1000, 0)
					BG.D = 10
				end

				Hum.WalkSpeed = Fight_Walkspeed
				Anim_Track_Data['Idle']:Play()
				Anim_Track_Data['Idle']:AdjustSpeed(0.5)
			end
		end	
		Clinch_Reset_Handle()
	end

	table.insert(Cons, Bindable_Events_F:WaitForChild("Cage_Clinch_Start").Event:Connect(function(AI_Char, Sequence_Keys, Is_Attacking)
		if(AI_Char == Char)then
			Clinch_Handle(Sequence_Keys, Is_Attacking)
		end
	end))


	local Strike_Count, Dodge_Count = 0, 0
	local function Main_AI_Logic_Gate()
		if(Health_V.Value > 0 and Is_Hit == false and T_Health_V ~= nil and T_Health_V.Value > 0)then
			if(Core_Strike_Funcs.Get_Hitbox_Res())then -- Within Strike Zone
				local Is_Player_Hitting_You = Core_Strike_Funcs.Is_Player_Striking_You()
				if(Is_Player_Hitting_You)then
					--Take the HIts until you're below 20 Block Power
					-- Dodge? or Strike
					if(Block_Power_V.Value > 10)then
						if(Dodge_Count < 2 or Strike_Count >= 3)then
							--Dodge
							if(Debounce_Dodge == false and Stam_V.Value >= 5)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								local Dodge_Type = Core_Strike_Funcs.Get_Dodge_Type()
								Core_Strike_Funcs.Dodge_Handle(Dodge_Type)

								Dodge_Count += 1
								if(Strike_Count >= 3)then
									Strike_Count = 0
								end
							end

						else
							--Strike
							if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
								if(Debounce_Blocking == true)then
									task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
								end

								Core_Strike_Funcs.Strike_Handle()
								Strike_Count += 1
								if(Dodge_Count >= 2)then
									Dodge_Count = 0
								end
							end
						end
					elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
						--Not within Strike Zone, resort to Blocking
						Core_Strike_Funcs.Blocking_Handle()
					end
				else
					--Strike
					if(Debounce_Striking == false and Stam_V.Value >= 10 and Strike_Power_V.Value > 0)then
						if(Debounce_Blocking == true)then
							task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
						end

						Core_Strike_Funcs.Strike_Handle()
						Strike_Count += 1
						if(Dodge_Count >= 2)then
							Dodge_Count = 0
						end
					end
				end
			elseif(Debounce_Blocking == false and Block_Power_V.Value > 0)then
				--Not within Strike Zone, resort to Blocking
				Core_Strike_Funcs.Blocking_Handle()
			end

		elseif(Debounce_Blocking == true)then
			task.spawn(Core_Strike_Funcs.Disable_Blocking_Handle)
		end
	end

	while Is_Active do
		if(Is_Submission == false)then
			Main_AI_Logic_Gate()
		end
		wait(0.5)
	end
end

Init_E.Event:Connect(function(T_Plr, T_Char,OtherStuff)	
	if(Is_Active == false and T_Plr ~= nil and T_Char ~= nil)then
		Core_AI_Handle(T_Plr, T_Char)
	elseif(Is_Active)then
		Reset_AI()
	end
end)]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>